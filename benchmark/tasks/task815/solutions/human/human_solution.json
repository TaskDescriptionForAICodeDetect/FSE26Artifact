[
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\trd(n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\trd(m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\trd(k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tgap[0]=T;\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include <cassert>\n#include <set>\n\nusing namespace std;\n\nstruct MaxFlow{\n  typedef long long ll;\n  const ll INF = 1e18;\n  struct Edge{\n    int u,v;\n    ll c,rc;\n    shared_ptr<ll> flow;\n    Edge(int _u, int _v, ll _c, ll _rc = 0):u(_u),v(_v),c(_c),rc(_rc){\n    }\n  };\n  struct FlowTracker{\n    ll cap, rcap;\n    shared_ptr<ll> flow;\n    bool dir;\n    FlowTracker(ll _cap, ll _rcap, shared_ptr<ll> _flow, int _dir):cap(_cap),rcap(_rcap),flow(_flow),dir(_dir){ }\n    ll rem() const {\n      if(dir == 0){\n        return cap-*flow;\n      }\n      else{\n        return rcap+*flow;\n      }\n    }\n    void add_flow(ll f){\n      if(dir == 0)\n        *flow += f;\n      else\n        *flow -= f;\n      assert(*flow <= cap);\n      assert(-*flow <= rcap);\n    }\n    operator ll() const { return rem(); }\n    void operator-=(ll x){ add_flow(x); }\n    void operator+=(ll x){ add_flow(-x); }\n  };\n  int source,sink;\n  vector<vector<int> > adj;\n  vector<vector<FlowTracker> > cap;\n  vector<Edge> edges;\n  MaxFlow(int _source, int _sink):source(_source),sink(_sink){\n    assert(source != sink);\n  }\n  int add_edge(int u, int v, ll c, ll rc = 0){\n    edges.push_back(Edge(u,v,c,rc));\n    return edges.size()-1;\n  }\n  vector<int> now,lvl;\n  void prep(){\n    int max_id = max(source, sink);\n    for(auto edge : edges)\n      max_id = max(max_id, max(edge.u, edge.v));\n    adj.resize(max_id+1);\n    cap.resize(max_id+1);\n    now.resize(max_id+1);\n    lvl.resize(max_id+1);\n    for(auto &edge : edges){\n      auto flow = make_shared<ll>(0);\n      adj[edge.u].push_back(edge.v);\n      cap[edge.u].push_back(FlowTracker(edge.c, edge.rc, flow, 0));\n      if(edge.u != edge.v){\n        adj[edge.v].push_back(edge.u);\n        cap[edge.v].push_back(FlowTracker(edge.c, edge.rc, flow, 1));\n      }\n      assert(cap[edge.u].back() == edge.c);\n      edge.flow = flow;\n    }\n  }\n  bool dinic_bfs(){\n    fill(now.begin(),now.end(),0);\n    fill(lvl.begin(),lvl.end(),0);\n    lvl[source] = 1;\n    vector<int> bfs(1,source);\n    for(int i = 0; i < (int) bfs.size(); ++i){\n      int u = bfs[i];\n      for(int j = 0; j < (int) adj[u].size(); ++j){\n        int v = adj[u][j];\n        if(cap[u][j] > 0 && lvl[v] == 0){\n          lvl[v] = lvl[u]+1;\n          bfs.push_back(v);\n        }\n      }\n    }\n    return lvl[sink] > 0;\n  }\n  ll dinic_dfs(int u, ll flow){\n    if(u == sink)\n      return flow;\n    while(now[u] < (int) adj[u].size()){\n      int v = adj[u][now[u]];\n      if(lvl[v] == lvl[u] + 1 && cap[u][now[u]] != 0){\n        ll res = dinic_dfs(v,min(flow,(ll)cap[u][now[u]]));\n        if(res > 0){\n          cap[u][now[u]] -= res;\n          return res;\n        }\n      }\n      ++now[u];\n    }\n    return 0;\n  }\n  ll calc_max_flow(){\n    prep();\n    ll ans = 0;\n    while(dinic_bfs()){\n      ll cur = 0;\n      do{\n        cur = dinic_dfs(source,INF);\n        ans += cur;\n      }while(cur > 0);\n    }\n    return ans;\n  }\n  ll flow_on_edge(int edge_index){\n    assert(edge_index < (int) edges.size());\n    return *edges[edge_index].flow;\n  }\n};\n\n// auto mf = MaxFlow(1,n);\n// arguments source and sink, memory usage\n// O(largest node index + input size), sink\n// doesn't need to be last index\n// int edge_index;\n// for(int i = 0; i < m; ++i){\n//    int a,b,c;\n//    cin >> a >> b >> c;\n//mf.add\\_edge(a,b,c); // for directed edges\n//      edge_index = mf.add_edge(a,b,c,c); // store edge index if care about flow value\n//   }\n//  cout << mf.calc_max_flow() << '\\n';\n//cout << mf.flow\\_on\\_edge(edge\\_index) << endl; // return flow on this edge\n//}\n\nvoid failure () {\n  cout << -1 << endl;\n  exit(0);\n}\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N]; // adj[v] is the set of edgesets v is in\n\nconst int HYPER = 1e5 + 5;\nconst int SOURCE = 2e5 + 10;\nconst int SINK = SOURCE + 1;\n\nint adder [MAX_N];\nint match [MAX_N]; // match[e] is the v matching to edgeset e\npair<int, int> ans [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  auto mf = MaxFlow(SOURCE, SINK);\n\n  vector<pair<pair<int, int>, int>> edges; // <<vertex, edgeset>, mf idx>\n  for (int i = 1; i < n; i++) {\n    int cnt;\n    cin >> cnt;\n\n    for (int j = 0; j < cnt; j++) {\n      int v;\n      cin >> v;\n\n      adj[v].push_back(i);\n      int idx = mf.add_edge(v, HYPER + i, 1);\n      edges.push_back({{v, i}, idx});\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    mf.add_edge(SOURCE, i, 1);\n  }\n\n  for (int i = 1; i < n; i++) {\n    mf.add_edge(HYPER + i, SINK, 1);\n  }\n\n  int flow = mf.calc_max_flow();\n  if (flow != n - 1) failure();\n  \n  set<int> freevs;\n  for (int i = 1; i <= n; i++) {\n    freevs.insert(i);\n  }\n\n  for (auto e : edges) {\n    if (mf.flow_on_edge(e.second) == 1) {\n      match[e.first.second] = e.first.first;\n      freevs.erase(e.first.first);\n    }\n  }\n\n  int start = *freevs.begin();\n\n  set<int> esets;\n  for (int e : adj[start]) {\n    esets.insert(e);\n    adder[e] = start;\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    if (esets.empty()) failure();\n\n    int E = *esets.begin();\n    esets.erase(E);\n\n    int v = match[E];\n    for (int e : adj[v]) {\n      if (adder[e] == 0) {\n        esets.insert(e);\n        adder[e] = v;\n      }\n    }\n\n    ans[E] = {v, adder[E]};\n  }\n\n  for (int i = 1; i < n; i++) {\n    cout << ans[i].first << \" \" << ans[i].second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fr[maxn],to[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[dy[y]]) {\n\t\t\tfr[y] = x;\n\t\t\tto[y] = dy[y];\n\t\t\tdfs(dy[y]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 400000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint x[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) x[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (x[i]) q.push(x[i]), ++k, fa[getfa(g[k] = s)] = getfa(h[k] = x[i]), x[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int INF=1e9+10;\nvec w[500100],o[500010];\nbool u[500010];\npa ans[500010];\nint nedge,q[2000010],rt,S,T,d[2000010],maxmatch,n,h[500010],too[2000010],hed[1000010],nxt[2000010],cap[2000010];\nvoid ae(int x,int y,int w){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n\tcap[nedge]=w;\n}\nvoid add(int x,int y,int w){\n\tae(x,y,w),ae(y,x,0);\n}\nbool build(){\n\tint he=0,ta=1;\n\tq[1]=S;\n\tFOR(i,S,T) d[i]=-1;\n\td[S]=0;\n\twhile (he!=ta){\n\t\tint x=q[++he];\n\t\tfor (int i=hed[x];i;i=nxt[i]){\n\t\t\tint y=too[i];\n\t\t\tif (!cap[i] || d[y]!=-1) continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tq[++ta]=y;\n\t\t}\n\t}\n\treturn (d[T]!=-1);\n}\nint fnd(int x,int flo){\n\tif (x==T) return flo;\n\tint ret,w=0;\n\tfor (int i=hed[x];i && w<flo;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (d[y]==d[x]+1 && cap[i] && (ret=fnd(y,min(flo-w,cap[i]))))\n\t\t\tcap[i]-=ret,cap[i^1]+=ret,w+=ret;\n\t}\n\tif (!w) d[x]=-1;\n\treturn w;\n}\nint dinic(){\n\tint ans=0;\n\twhile (build())\n\t\twhile (1){\n\t\t\tint flo=fnd(S,INF);\n\t\t\tif (!flo) break;\n\t\t\tans+=flo;\n\t\t}\n\treturn ans;\n}\nvoid dfs(int x){\n\tif (u[x]) return;\n\tu[x]=1;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (!cap[i]) continue;\n\t\tdfs(y);\n\t}\n}\nint main(){\n\tcin>>n;\n\tFOR(i,1,n-1){\n\t\tint t,x;\n\t\tgetint(t);\n\t\twhile (t--){\n\t\t\tgetint(x);\n\t\t\tw[i].pb(x);\n\t\t\to[x].pb(i);\n\t\t}\n\t}\n\tS=0;\n\tnedge=1;\n\tT=n+n;\n\tFOR(i,1,n) add(S,i,1);\n\tFOR(i,n+1,n+n-1) add(i,T,1);\n\tFOR(x,1,n-1){\n\t\tFOR(i,0,SZ(w[x])-1)\n\t\t\tadd(w[x][i],x+n,1);\n\t}\n\tmaxmatch=dinic();\n\tif (maxmatch<n-1) return puts(\"-1\"),0;\n\tdfs(S);\n\tFOR(i,1,n) if (!u[i]) return puts(\"-1\"),0;\n\tfor (int i=hed[S];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (cap[i]){rt=y;break;}\n\t}\n\tFOR(x,1,n){\n\t\tif (x==rt) continue;\n\t\tfor (int i=hed[x];i;i=nxt[i]){\n\t\t\tint y=too[i];\n\t\t\tif (!cap[i] && y>=n+1 && y<=n+n-1){h[y-n]=x;break;}\n\t\t}\n\t}\n\tFOR(i,1,n) u[i]=0;\n\tint he=0,ta=1;\n\tq[1]=rt;\n\tu[rt]=1;\n\twhile (ta<n){\n\t\tint x=q[++he];\n\t\tFOR(i,0,SZ(o[x])-1){\n\t\t\tint y=h[o[x][i]];\n\t\t\tif (u[y]) continue;\n\t\t\tu[y]=1;\n\t\t\tans[o[x][i]]=mp(x,y);\n\t\t\tq[++ta]=y;\n\t\t}\n\t}\n\tFOR(i,1,n-1) printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 200010;\nint mat[N];\nnamespace mf {\n  const int M = 400010;\n  const int INF = 0x3f3f3f3f;\n  struct edge {\n    int la,b,cap;\n  } con[M << 1];\n  int tot = 1, fir[N];\n  void add(int from,int to,int capc) {\n    con[++tot] = (edge) {fir[from], to, capc};\n    fir[from] = tot;\n    con[++tot] = (edge) {fir[to], from, 0};\n    fir[to] = tot;\n  }\n  int dis[N], st, en, cur[N], n;\n  int dfs(int pos,int imp) {\n    if (pos == en || !imp) return imp;\n    int ret = 0, tmp;\n    for (int& i = cur[pos]; i; i = con[i].la) {\n      if (dis[con[i].b] == dis[pos] + 1) {\n\ttmp = dfs(con[i].b, min(imp, con[i].cap));\n\tcon[i].cap -= tmp;\n\tcon[i^1].cap += tmp;\n\timp -= tmp;\n\tret += tmp;\n\tif (!imp) break;\n      }\n    }\n    return ret;\n  }\n  bool bfs() {\n    queue<int> q;\n    rep (i, 1, n) dis[i] = INF;\n    dis[st] = 0;\n    q.push(st);\n    for (int pos; !q.empty(); q.pop()) {\n      pos = q.front();\n      for (int i = fir[pos]; i; i = con[i].la) {\n\tif (con[i].cap && dis[con[i].b] == INF) {\n\t  dis[con[i].b] = dis[pos] + 1;\n\t  q.push(con[i].b);\n\t}\n      }\n    }\n    if (dis[en] == INF) return false;\n    rep (i, 1, n) cur[i] = fir[i];\n    return true;\n  }\n  int calc() {\n    int ret = 0;\n    while (bfs())\n      ret += dfs(st, INF);\n    rep (pos, (n/2)+1, n-2) {\n      for (int i = fir[pos]; i; i = con[i].la) {\n\tif (con[i].b <= (n/2) && con[i].cap > 0)\n\t  mat[pos - (n/2)] = con[i].b;\n      }\n    }\n    return ret;\n  }\n  \n}\nint n, vis[N];\nvector<int> vec[N], rec[N];\npii ans[N];\nvoid dfs(int pos) {\n  vis[pos] = 1;\n  rep (i, 0, (int)rec[pos].size()-1) {\n    if (vis[mat[rec[pos][i]]]) continue;\n    ans[rec[pos][i]] = pii(pos, mat[rec[pos][i]]);\n    dfs(mat[rec[pos][i]]);\n  }\n}\nint main() {\n  read(n);\n  rep (i, 1, n-1) {\n    int tmp, x;\n    read(tmp);\n    rep (j, 1, tmp) {\n      read(x);\n      vec[i].push_back(x);\n      rec[x].push_back(i);\n      if (x != 1) mf::add(x, i + n, 1);\n    }\n  }\n  mf::n = 2 * n - 1;\n  mf::st = ++ mf::n;\n  mf::en = ++ mf::n;\n  rep (i, 1, n) mf::add(mf::st, i, 1);\n  rep (i, n+1, 2*n-1) mf::add(i, mf::en, 1);\n  int res = mf::calc();\n  if (res < n-1) {\n    puts(\"-1\");\n    return 0;\n  }\n  dfs(1);\n  int tmp = 1;\n  rep (i, 1, n) if (!vis[i]) tmp = 0;\n  if (tmp == 0) puts(\"-1\");\n  else {\n    rep (i, 1, n-1) {\n      printf(\"%d %d\\n\", ans[i].fir, ans[i].sec);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\treturn 0;\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf < N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 200010\n#define T n+n+1\n#define add(x,y,z) addedge(x,y,z),addedge(y,x,0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nint head[N],tot=1,cur[N],vis[N],dis[N],n,p[N],fa[N],s; vector<int> v[N];\nstruct Edge{int v,next,f,w;}edge[N*10]; queue<int> q;\ninline void addedge(int x,int y,int z){edge[++tot]=Edge{y,head[x],0,z};head[x]=tot;}\ninline int bfs()\n{\tmemset(vis,0,sizeof(vis)); memcpy(cur,head,sizeof(cur)); q.push(0); vis[0]=1;\n\twhile(!q.empty())\n\t{\tint x=q.front(); q.pop();\n\t\tfor(rint i=head[x];i;i=edge[i].next)\n\t\tif(!vis[to]&&edge[i].f<edge[i].w) dis[to]=dis[x]+1,vis[to]=1,q.push(to);\n\t}\n\treturn vis[T];\n}\nint dfs(int x,int res)\n{\tif(x==T||!res) return res; int flow=0,f;\n\tfor(rint &i=cur[x];i;i=edge[i].next)\n\tif(dis[to]==dis[x]+1&&(f=dfs(to,min(res,edge[i].w-edge[i].f))))\n\t{edge[i].f+=f;edge[i^1].f-=f;res-=f;flow+=f;if(!res)break;}\n\treturn flow;\n}\ninline int dinic(){int A=0;while(bfs())A+=dfs(0,INT_MAX);return A;}\nvoid dfs(int x){vis[x]=1;s++;for(auto y:v[x])if(!vis[p[y]])fa[y]=x,dfs(p[y]);}\nint main()\n{\tint m,x; cin>>n; for(rint i=1;i<=n;i++) add(n+i,T,1);\n\tfor(rint i=1;i<n;add(0,i,1),i++)\n\tfor(scanf(\"%d\",&m);m--;){scanf(\"%d\",&x),v[x].push_back(i);if(x!=1)add(i,n+x,1);}\n\tif(dinic()!=n-1) return !printf(\"-1\");\n\tfor(rint j=1;j<n;j++)\n\tfor(rint i=head[j];i;i=edge[i].next) if(n<to&&to<=n+n&&edge[i].f) p[j]=to-n;\n\tdfs(1); if(s!=n) return !printf(\"-1\");\n\tfor(rint i=1;i<n;i++) printf(\"%d %d\\n\",fa[i],p[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint next[N],head[N],edge[N],v[N],next2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnext[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnext2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=next[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=next2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=600005;\nvector<int> bel[N];\nint cur[N],from[N],S,T,ne[N],a[N],b[N],dis[N],flag[N],x,y,n,m,fi[N],tot,zz[N],sl[N];\nqueue<int>Q;\nvoid jb(int x,int y,int z){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n\tsl[tot]=z;\n\tne[++tot]=fi[y];\n\tfi[y]=tot;\n\tzz[tot]=x;\n\tsl[tot]=0;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,-1,sizeof dis);\n\tdis[S]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]==-1){\n\t\t\t\tdis[zz[i]]=dis[now]+1;\n\t\t\t\tQ.push(zz[i]);\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&dis[zz[i]]==dis[x]+1&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\ty-=b;\n\t\t\ts+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=0;T=2*n;\n\ttot=1;\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tjb(S,i+n,1);\n\t\twhile (x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tjb(i+n,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)jb(i,T,1);\n\tint ans=0;\n\twhile (bfs()){\n\t\tfor (int i=S;i<=T;i++)cur[i]=fi[i];\n\t\tans+=dfs(S,1e9);\n\t}\n\tif (ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=fi[i+n];j;j=ne[j])\n\t\t\tif (zz[j]&&!sl[j]){\n\t\t\t\tflag[zz[j]]=1;\n\t\t\t\tb[i]=zz[j];\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])Q.push(i);\n\tans=0;\n\tmemset(flag,0,sizeof flag);\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tans++;\n\t\tfor (int i=0;i<bel[now].size();i++)\n\t\t\tif (!flag[bel[now][i]]){\n\t\t\t\tflag[bel[now][i]]=1;\n\t\t\t\ta[bel[now][i]]=now;\n\t\t\t\tQ.push(b[bel[now][i]]);\n\t\t\t}\n\t}\n\tif (ans!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=2e5+5,M=N<<3,inf=0x7fffffff;\n\nint t[M],f[M],nxt[M],lst[N],l;\n\nvoid add(int x,int y,int z) {\n\tt[++l]=y;f[l]=z;nxt[l]=lst[x];lst[x]=l;\n\tt[++l]=x;f[l]=0;nxt[l]=lst[y];lst[y]=l;\n}\n\nint n,S,T,q[N],dis[N],p[N],fa[N];\nvector<int> to[N];\n\nbool bfs() {\n\tfo(i,S,T) dis[i]=0;dis[S]=1;\n\tint i=0,j=1;q[1]=S;\n\twhile (i<j) {\n\t\trep(k,q[++i])\n\t\t\tif (f[k]&&!dis[t[k]]) {\n\t\t\t\tdis[t[k]]=dis[q[i]]+1;\n\t\t\t\tq[++j]=t[k];\n\t\t\t}\n\t}\n\treturn dis[T];\n}\n\nint dinic(int x,int y) {\n\tif (x==T) return y;\n\tint now=0;\n\trep(i,x)\n\t\tif (f[i]&&dis[t[i]]==dis[x]+1) {\n\t\t\tint k=dinic(t[i],min(y,f[i]));\n\t\t\tf[i]-=k;f[i^1]+=k;\n\t\t\ty-=k;now+=k;\n\t\t\tif (!y) break;\n\t\t}\n\tif (!now) dis[x]=-1;\n\treturn now;\n}\n\nbool vis[N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x])\n\t\tif (!vis[p[y]]) {\n\t\t\tfa[y]=x;\n\t\t\tdfs(p[y]);\n\t\t}\n}\n\nint main() {\n\tn=read();S=0;T=n<<1;l=1;\n\tfo(i,1,n-1) {\n\t\tadd(S,i,1);\n\t\tfor(int c=read();c;c--) {\n\t\t\tint x=read();\n\t\t\tif (x>1) add(i,x+n-1,1);\n\t\t\tto[x].push_back(i);\n\t\t}\n\t}\n\tfo(i,1,n) add(i+n-1,T,1);\n\tint ret=0;\n\twhile (bfs()) ret+=dinic(S,inf);\n\tif (ret<n-1) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) rep(j,i) if (!f[j]&&t[j]) p[i]=t[j]-n+1;\n\tdfs(1);\n\tfo(i,1,n-1) if (!fa[i]) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[200010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], fa[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) assert(to[i] == 0), to[i] = e[j].v - n + 1;\n        assert(to[i] < n);\n        assert(to[i]);\n    }\n    queue < int > q;\n    q.push(n);\n    int cnt = 0;\n    while (!q.empty()) {\n        cnt++;\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!fa[e[i].v]) {\n                q.push(to[e[i].v]);\n                fa[e[i].v] = now;\n            }\n        }\n    }\n    if (cnt != n) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", fa[i], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline void solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\tsolve();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=200000+10,inf=0x3f3f3f3f;\nint n,fa[MAXN],e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<1],to[MAXN<<1],out[MAXN<<1],cap[MAXN<<1],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tfa[mh[v]]=x,vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,n)printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[1]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(now,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 3e5 + 50, M = 2e6 + 50;\ncs int INF = 1e9 + 7;\nint n, S, T, fi[N], nxt[M], to[M], w[M], ec=1;\nvoid adde(int x, int y, int z){\n\tnxt[++ec]=fi[x], fi[x]=ec, to[ec]=y, w[ec]=z;\n\tnxt[++ec]=fi[y], fi[y]=ec, to[ec]=x, w[ec]=0;\n} int eu[N], ev[N], ct, d[N];\nbool bfs(){\n\tqueue<int> q; q.push(S); \n\tmemset(d,-1,sizeof(d)); d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x],v;e;e=nxt[e]) if(w[e]){\n\t\t\tv=to[e]; if(d[v]==-1){\n\t\t\t\td[v]=d[x]+1; q.push(v);\n\t\t\t\tif(v==T) return true;\n\t\t\t}\n\t\t}\n\t} return false;\n}\nint dfs(int u, int flw){\n\tif(u==T) return flw; int ans = 0;\n\tfor(int e=fi[u],v;e;e=nxt[e])\n\tif(d[v=to[e]]==d[u]+1){\n\t\tint dt=dfs(v,min(w[e],flw));\n\t\tans+=dt; flw-=dt;\n\t\tw[e]-=dt; w[e^1]+=dt; if(!flw) break;\n\t} if(flw) d[u]=-1; return ans;\n}\nint dinic(){ int flw = 0; while(bfs()) flw += dfs(S,INF); return flw; }\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1,k,x; i<n; i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1; j<=k; j++) \n\t\tscanf(\"%d\",&x), adde(x,i+n,1);\n\t} S=0, T=n+n;\n\tfor(int i=1; i<=n; i++) adde(S,i,1);\n\tfor(int i=1; i<n; i++) adde(i+n,T,1);\n\tint flw = dinic();\n\tif(flw < n-1) return puts(\"-1\"),0;\n\t\n\tstatic int tr[N];\n\tfor(int i=n+1; i<n+n; i++)\n\tfor(int e=fi[i];e;e=nxt[e]) \n\tif(to[e]!=T&&w[e]) tr[i]=to[e];\n\t\n\tqueue<int> q;\n\tfor(int e=fi[S];e;e=nxt[e])\n\tif(w[e]) q.push(to[e]);\n\t\n\tstatic bool ban[N];\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x];e;e=nxt[e]) \n\t\tif(to[e]!=S&&!ban[to[e]]){\n\t\t\teu[to[e]-n]=x; ev[to[e]-n]=tr[to[e]];\n\t\t\tq.push(tr[to[e]]); ban[to[e]]=true; ++ct;\n\t\t}\n\t} if(ct<n-1) return puts(\"-1\"),0;\n\tfor(int i=1; i<n; i++) cout<<eu[i]<<\" \"<<ev[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int maxm=400111;\n\nstruct edge{int to,cap;};\nnamespace flow\n{\n\tint head[maxn],nxt[maxm<<1],iter[maxn],tot;\n\tedge e[maxm<<1];\n\tvoid clear()\n\t{\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=1;\n\t}\n\tmax_flow(){clear();}\n\tvoid addedge(int u,int v,int cap)\n\t{\n\t\tnxt[++tot]=head[u];\n\t\thead[u]=tot;\n\t\te[tot]=edge{v,cap};\n\t\tnxt[++tot]=head[v];\n\t\thead[v]=tot;\n\t\te[tot]=edge{u,0};\n\t}\n\t \n\tint lvl[maxn],q[maxn];\n\tbool bfs(int s,int t)\n\t{\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;int rr=0;q[rr++]=s;\n\t\tfor(int fr=0;fr<rr;fr++)\n\t\t{\n\t\t\tint x=q[fr];if(x==t)return true;\n\t\t\tfor(int i=head[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==-1)\n\t\t\t{\n\t\t\t\tlvl[e[i].to]=lvl[x]+1;\n\t\t\t\tq[rr++]=e[i].to;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int x,int t,int f)\n\t{\n\t\tif(x==t||f==0)return f;\n\t\tint ret=0;\n\t\tfor(int&i=iter[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==lvl[x]+1)\n\t\t{\n\t\t\tint d=dfs(e[i].to,t,min(f,e[i].cap));\n\t\t\te[i].cap-=d;e[i^1].cap+=d;\n\t\t\tf-=d;ret+=d;\n\t\t\tif(!f)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint maxflow(int s,int t)\n\t{\n\t\tint flow=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemcpy(iter,head,sizeof(head));\n\t\t\tflow+=dfs(s,t,inf);\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nvector<int> e[maxn],g[maxn];\nint n,piv[maxn],fa[maxn];\n\nbool use[maxn];\nvoid dfs(int x)\n{\n\tuse[x]=1;\n\tfor(auto&v:g[x])if(!use[v])\n\t{\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tget1(n);\n\tint S=1,T=n+n;\n\tfor(int i=2;i<=n;i++)flow::addedge(S,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint cnt,x;get1(cnt);\n\t\tflow::addedge(i+n,T,1);\n\t\twhile(cnt--)\n\t\t{\n\t\t\tget1(x);\n\t\t\te[i].pb(x);\n\t\t\tif(x>1)flow::addedge(x,i+n,1);\n\t\t}\n\t}\n\tif(flow::maxflow(S,T)<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=2;i<=n;i++)for(int j=flow::head[i];j;j=flow::nxt[j])if(flow::e[j].to!=S&&!flow::e[j].cap)\n\t\tpiv[flow::e[j].to-n]=i;\n\t\n\tfor(int i=1;i<n;i++)for(int j=0;j<(int)e[i].size();j++)if(e[i][j]!=piv[i])g[e[i][j]].pb(piv[i]);\n\t\n\tdfs(1);\n\tfor(int i=2;i<=n;i++)if(!fa[i])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",piv[i],fa[piv[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<set<ll>>& cap){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[v].count(nex) == 0)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            if (plusflow == 0){\n                cap[v].insert(nex);\n                continue;\n            }\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n\n            return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        vector<ll> level(N,inf);\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<set<ll>> cap(N); \n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%lld\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%lld\" , &c);\n        rep(i,0,c){\n            scanf (\"%lld\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%lld %lld\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int N = 200228;\nvector<int> e[N];\nvector<int> erev[N];\n\nint n;\n\nint p[N];\nint pr[N];\n\nint w[N];\nint curv;\n\nint av[N], au[N];\n\nvoid nein() {\n    cout << -1 << \"\\n\";\n    exit(0);\n}\n\nbool dfs(int v) {\n    if (w[v] == curv) {\n        return false;\n    }\n\n    w[v] = curv;\n\n    for (int u: e[v]) {\n        if (p[u] == 0) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    for (int u: e[v]) {\n        if (dfs(p[u])) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool go[N];\n\nvoid dfsgo(int v) {\n    go[v] = true;\n    for (int u: erev[v]) {\n        if (!go[pr[u]]) {\n            av[u] = v;\n            au[u] = pr[u];\n            dfsgo(pr[u]);\n        }\n    }\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n\n    cin >> n;\n\n    for (curv = 1; curv < n; ++curv) {\n        int s;\n        cin >> s;\n        e[curv].resize(s);\n        for (int& v: e[curv]) {\n            cin >> v;\n            erev[v].push_back(curv);\n        }\n\n        if (!dfs(curv)) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        pr[p[i]] = i;\n    }\n\n    int root = 1;\n    while (p[root]) {\n        ++root;\n    }\n\n    dfsgo(root);\n    for (int i = 1; i <= n; ++i) {\n        if (!go[i]) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        cout << av[i] << \" \" << au[i] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int i = 0; i + 1 < n; ++i) {\n        memset(used, 0, sizeof(used));\n        dfs(i);\n    }\n    /*for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }*/\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=1e5+5,inf=0x3f3f3f3f;\nint n,s,t,head[N<<1],num=1;\nstruct edge{int to,flo,next;} e[N*10];\ninline void add(int u,int v){\n    e[++num]=(edge){v,1,head[u]},head[u]=num;\n    e[++num]=(edge){u,0,head[v]},head[v]=num;\n}\n\nint dis[N<<1];\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof dis);\n    q.push(s),dis[s]=1;\n    while(!q.empty()){\n\tint u=q.front();q.pop();\n\tfor(int i=head[u];i;i=e[i].next){\n\t    int v=e[i].to;if(dis[v]||!e[i].flo)continue;\n\t    dis[v]=dis[u]+1,q.push(v);\n\t}\n    }\n    return dis[t];\n}\nint dfs(int u,int lim){\n    if(u==t||!lim)return lim;\n    int flow=0;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(dis[v]!=dis[u]+1||!e[i].flo)continue;\n\tint f=dfs(v,min(lim,e[i].flo));\n\te[i].flo-=f,e[i^1].flo+=f;\n\tlim-=f,flow+=f;\n\tif(!lim)break;\n    }\n    return flow;\n}\nint Netflow(){\n    int ans=0;\n    while(bfs())ans+=dfs(s,inf);\n    return ans;\n}\n\nint fa[N<<1],vis[N<<1],cnt;\npii ans[N];\nvoid serch(int u,int pa){\n    cnt+=u<=n,vis[u]=1,fa[u]=pa;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(vis[v]||!e[i].flo)continue;\n\tserch(v,u);\n    }\n}\n\nint main(){\n    //freopen(\"in.in\",\"r\",stdin);\n    n=read();s=n+n,t=s+1;\n    REP(i,1,n)add(s,i);\n    REP(i,1,n-1)add(n+i,t);\n    REP(i,1,n-1)REP(c,1,read()){int u=read();add(u,n+i);}\n    if(Netflow()<n-1)return puts(\"-1\"),0;\n    int rt=0;\n    for(int i=head[s];i;i=e[i].next)if(e[i].flo){rt=e[i].to;break;}\n    serch(rt,0);\n    if(cnt<n)return puts(\"-1\"),0;\n    REP(i,1,n)if(i!=rt){\n\tint id=fa[i],p=fa[id];\n\tans[id-n]=mp(p,i);\n    }\n    REP(i,1,n-1)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nvoid nie(){\n  cout << \"-1\\n\";\n  exit(0);\n}\n\nconst int MAX = 1e5+1;\nint n;\nvector<int> d[MAX],d2[MAX];\nint cz[MAX],sx[MAX],sy[MAX];\nbool dfs(int x){\n  if(cz[x])return 0;\n  cz[x] = 1;\n  for(int el:d[x]){\n    if(sy[el] == -1 || dfs(sy[el])){\n      sy[el] = x;\n      sx[x] = el;\n      return 1;\n    }\n  }\n  return 0;\n}\nPII out[MAX];\nint ilout = 0;\nvoid buduj(int x){\n  for(int el:d2[x]){\n    if(!cz[el]){\n      cz[el] = 1;\n      ilout ++;\n      out[el] = {x, sx[el]};\n      buduj(sx[el]);\n    }\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  R(i,n-1){\n    int pom;\n    cin >> pom;\n    d[i].resize(pom);\n    R(j,pom){\n      cin >> d[i][j];\n      d[i][j]--;\n      d2[d[i][j]].PB(i);\n    }\n  }\n  R(i,n){\n    sx[i] = -1;\n    sy[i] = -1;\n  }\n  int res = 0;\n  bool x = 1;\n  while(x){\n    x = 0;\n    R(i,n)cz[i] = 0;\n    R(i,n)if(sx[i] == -1){\n      if(dfs(i)){\n        res ++;\n        x = 1;\n      }\n    }\n  }\n  R(i,n-1){\n    debug(sx[i]);\n  }\n  if(res != n-1)nie();\n  R(i,n)cz[i] = 0;\n  R(i,n){\n    if(sy[i] == -1){\n      buduj(i);\n    }\n  }\n  if(ilout!=n-1)nie();\n  R(i,n-1){\n    cout << out[i].FI + 1 << \" \" << out[i].SE + 1 << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nnamespace MaxFlow{\n\tconst int MV = 300020;\n\tconst int ME = 700040;\n\tconst int INF = 1e9;\n\tint dis[MV];\n\tint st[MV], en[ME<<1], nxt[ME<<1], flow[ME<<1], ce;\n\tint start[MV];\n\tvoid init() {\n\t\tmemset(st, 0, sizeof st);\n\t\tce = 1;\n\t}\n\tvoid addE(int s, int e, int f = 1) {\n\t\t++ce; nxt[ce] = st[s]; st[s] = ce; en[ce] = e; flow[ce] = f;\n\t\t++ce; nxt[ce] = st[e]; st[e] = ce; en[ce] = s; flow[ce] = 0;\n\t}\n\tint que[MV];\n\tint bfs(int N, int S, int E) {\n\t\tfor(int i=1;i<=N;i++) dis[i] = -1;\n\t\tdis[S] = 0;\n\t\tint *fr = que, *re = que;\n\t\t*fr++ = S;\n\t\twhile(fr != re) {\n\t\t\tint t = *re++;\n\t\t\tfor(int i=st[t];i;i=nxt[i]) if(flow[i] > 0 && dis[en[i]] == -1) {\n\t\t\t\tdis[en[i]] = dis[t] + 1;\n\t\t\t\t*fr++ = en[i];\n\t\t\t}\n\t\t}\n\t\treturn dis[E] != -1;\n\t}\n\t\n\tint dfs(int x, int E, int f) {\n\t\tif(x == E) return f;\n\t\tfor(int &i=start[x],t;i;i=nxt[i]) if(flow[i] > 0 && dis[en[i]] == dis[x] + 1 && (t = dfs(en[i], E, min(f, flow[i]))) > 0){\n\t\t\tflow[i] -= t;\n\t\t\tflow[i^1] += t;\n\t\t\treturn t;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint Get(int N, int S, int E) {\n\t\tint res = 0;\n\t\twhile(bfs(N, S, E)) {\n\t\t\tfor(int i=1;i<=N;i++) start[i] = st[i];\n\t\t\twhile(1) {\n\t\t\t\tint t = dfs(S, E, INF);\n\t\t\t\tif(t == 0) break;\n\t\t\t\tres += t;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid trace(int N, int S, int E, int chk[]) {\n\t\tbfs(N, S, E);\n\t\tfor(int i=1;i<=N;i++) chk[i] = (dis[i] != -1);\n\t}\n}\n\nint N;\nvector <int> R[100010], L[100010];\nint V[100010], W[100010];\nint mark[100010];\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<N;i++) {\n\t\tint c; scanf(\"%d\", &c);\n\t\twhile(c--) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tR[i].pb(x);\n\t\t}\n\t}\n\tint ST = 1;\n\tMaxFlow::init();\n\tfor(int i=1;i<N;i++) {\n\t\tMaxFlow::addE(1, i + 1);\n\t\tfor(int j=0;j<szz(R[i]);j++) {\n\t\t\tif(R[i][j] != 1) MaxFlow::addE(i+1, N + R[i][j] - 1);\n\t\t}\n\t}\n\tfor(int i=1;i<N;i++) MaxFlow::addE(N + i, 2 * N);\n\tint r = MaxFlow::Get(2*N, 1, 2*N);\n\tif(r != N - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=N;i++) {\n\t\tfor(int j=MaxFlow::st[i];j;j=MaxFlow::nxt[j]) {\n\t\t\tint e = MaxFlow::en[j];\n\t\t\tif(N+1 <= e && e < 2*N && MaxFlow::flow[j] == 0) V[i-1] = e - N + 1;\n\t\t}\n\t}\n\tfor(int i=1;i<N;i++) for(int e : R[i]) if(e != V[i]) L[e].pb(i);\n\tvector <int> q;\n\tfor(int e : L[1]) {\n\t\tW[e] = 1; mark[e] = 1;\n\t\tq.pb(e);\n\t}\n\trep(i, szz(q)) {\n\t\tint t = q[i];\n\t\tint v = V[t];\n\t\tfor(int e : L[v]) {\n\t\t\tif(mark[e] == 0) {\n\t\t\t\tW[e] = v;\n\t\t\t\tmark[e] = 1;\n\t\t\t\tq.pb(e);\n\t\t\t}\n\t\t}\n\t}\n\tif(szz(q) < N - 1) puts(\"-1\");\n\telse {\n\t\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\", V[i], W[i]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 19.12.2019 15:42:22       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  matching mat(n - 1, n);\n  vector<vector<int>> gr(n);\n  for (int i = 0; i < n - 1; i++) {\n    int foo;\n    cin >> foo;\n    while (foo--) {\n      int bar;\n      cin >> bar;\n      --bar;\n      mat.add(i, bar);\n      gr[bar].push_back(i);\n    }\n  }\n  if (mat.solve() != n - 1) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int start = -1;\n  for (int i = 0; i < n; i++) {\n    if (mat.pb[i] == -1) {\n      start = i;\n      break;\n    }\n  }\n  vector<pair<int, int>> res(n - 1);\n  vector<bool> was(n, false);\n  vector<int> que(1, start);\n  was[start] = true;\n  for (int b = 0; b < (int) que.size(); b++) {\n    int x = que[b];\n    for (int v : gr[x]) {\n      int y = mat.pa[v];\n      if (!was[y]) {\n        was[y] = true;\n        que.push_back(y);\n        res[v] = make_pair(y, x);\n      }\n    }\n  }\n  if ((int) que.size() != n) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    cout << res[i].first + 1 << \" \" << res[i].second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\n\nint src, sink;\n\nint n, l[maxn<<1], L[maxn<<1], Q[maxn<<1], r, fa[maxn], p[maxn], vis[maxn], e;\nvector<int> vec[maxn];\n\nstruct Edge {\n\tint v, c, x;\n} E[maxn<<3];\n\ninline void addEdge(int u, int v, int c) {\n\tE[e].v = v; E[e].x = l[u]; E[e].c = c; l[u] = e++;\n\tE[e].v = u; E[e].x = l[v]; E[e].c = 0; l[v] = e++;\n}\n\nint _bfs() {\n\tmemset(L, -1, sizeof(L));\n\tint s = 0, t = 0, u;\n\tL[src] = 0; Q[t++] = src;\n\twhile (s < t) {\t\n\t\tu = Q[s++];\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tif (E[p].c && L[E[p].v] == -1) {\n\t\t\t\tL[Q[t++] = E[p].v] = L[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn L[sink] != -1;\n}\n\nint _find(int u, int in) {\n\tif (u == sink) return in;\n\tint w = 0, t;\n\tfor (int p = l[u]; p >= 0 && w < in; p = E[p].x) {\n\t\tif (L[E[p].v] == L[u] + 1 && E[p].c) {\n\t\t\tif ((t = _find(E[p].v, min(in-w, E[p].c)))) {\n\t\t\t\tE[p].c -= t;\n\t\t\t\tE[p^1].c += t;\n\t\t\t\tw += t;\n\t\t\t}\n\t\t}\n\t}\n\tif (w < in) L[u] = -1;\n\treturn w;\n}\n\nint dinic() {\n\tint res = 0, t;\n\twhile (_bfs()) {\n\t\twhile ((t = _find(src, inf))) {\n\t\t\tres += t;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d\", &n);\n\tsrc = n-1+n+1; sink = n-1+n+2;\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tint c = 0; scanf(\"%d\", &c);\n\t\tfor (int j = 1; j <= c; j++) {\n\t\t\tint w; scanf(\"%d\", &w);\n\t\t\taddEdge(i, n-1+w, 1);\n\t\t\tvec[w].push_back(i);\n\t\t}\n\t\taddEdge(src, i, 1);\n\t}\n\tfor (int i = 1; i <= n; i++) addEdge(n-1+i, sink, 1);\n\tint c = dinic();\n\tif (c < n-1) {puts(\"-1\"); return 0;}\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tfor (int _p = l[i]; _p >= 0; _p = E[_p].x) {\n\t\t\tif (!E[_p].c && E[_p].v >= n) {\n\t\t\t\tp[i] = E[_p].v - n  + 1;\n\t\t\t\tvis[p[i]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) r = i;\n\tfor (int i = 1; i <= n; i++) vis[i] ^= 1;\n\tint s = 0, t = 0, u;\n\tQ[t++] = r;\n\twhile (s < t) {\n\t\tu = Q[s++];\n\t\tfor (int i = 0; i < vec[u].size(); i++) {\n\t\t\tint v = vec[u][i];\n\t\t\tif (!vis[p[v]]) {\n\t\t\t\tvis[p[v]] = 1;\n\t\t\t\tfa[p[v]] = u;\n\t\t\t\tQ[t++] = p[v];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) {puts(\"-1\"); return 0;}\n\tfor (int i = 1; i <= n-1; i++) printf(\"%d %d\\n\", p[i], fa[p[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 200005\n#define M 800005\n#define inf 0x3f3f3f3f\nint tar[M], nex[M], cap[M], fir[N], cnt = 1;\nint n, m, dis[N], now[N], use[N][2];\nvector<int>A[N];\nset<int>S[N];\nqueue<int>Q;\nvoid add(int a, int b, int c)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tcap[cnt] = c;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nvoid Add(int a, int b)\n{\n\tadd(a, b, 1);\n\tadd(b, a, 0);\n}\nint aug(int s, int b, int e, int g, int augco)\n{\n\tif (s == e)\n\t\treturn augco;\n\tint augc = augco;\n\tfor (int &i = now[s]; i; i = nex[i])\n\t{\n\t\tint v = tar[i];\n\t\tif (cap[i])\n\t\t{\n\t\t\tif (dis[v] == dis[s] + 1)\n\t\t\t{\n\t\t\t\tint delta = aug(v, b, e, g, min(augc, cap[i]));\n\t\t\t\tcap[i] -= delta;\n\t\t\t\tcap[i ^ 1] += delta;\n\t\t\t\taugc -= delta;\n\t\t\t\tif (!augc)\n\t\t\t\t\treturn augco;\n\t\t\t}\n\t\t}\n\t}\n\treturn augco - augc;\n}\nbool Bfs(int s, int t)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tdis[s] = 0;\n\tqueue<int>que;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front();\n\t\tnow[x] = fir[x];\n\t\tque.pop();\n\t\tfor (int i = fir[x]; i; i = nex[i])\n\t\t{\n\t\t\tint v = tar[i];\n\t\t\tif (!cap[i])\n\t\t\t\tcontinue;\n\t\t\tif (dis[x] + 1 < dis[v])\n\t\t\t{\n\t\t\t\tdis[v] = dis[x] + 1;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t] != inf;\n}\nint sap(int b, int e, int g)\n{\n\tint flow = 0;\n\twhile (Bfs(b, e))\n\t\tflow += aug(b, b, e, g, inf);\n\treturn flow;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int j = 1; j <= t; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tS[x].insert(i);\n\t\t\tA[i].push_back(x);\n\t\t\tif (x != 1)\n\t\t\t\tAdd(i, n + x);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tAdd(2 * n + 1, i);\n\t\tAdd(n + i, 2 * n + 2);\n\t}\n\tint ans = sap(2 * n + 1, 2 * n + 2, 2 * n + 2);\n\tif (ans < n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = fir[i]; j; j = nex[j])\n\t\t{\n\t\t\tint v = tar[j];\n\t\t\tif (v > n && !cap[j])\n\t\t\t\tuse[i][0] = v - n;\n\t\t}\n\t}\n\tQ.push(1);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front();\n\t\tm++;\n\t\tQ.pop();\n\t\tset<int>::iterator it = S[x].begin();\n\t\tfor (; it != S[x].end(); it++)\n\t\t{\n\t\t\tif (!use[*it][1])\n\t\t\t{\n\t\t\t\tuse[*it][1] = x;\n\t\t\t\tQ.push(use[*it][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (m < n)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", use[i][0], use[i][1]);\n}\n//"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\t//dmp(s);\n\t\tfor(auto t:adj[s]){\n\t\t\tif(t.fs<=0)return;\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\ta[t.sc]=t.fs;\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\tmatch[btoa[i]]=1;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({btoa[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\n//dmp(sum);\n//assert(sum>=n);\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << a[i] << \" \" << b[i] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005 , S = 0 , T = 200000;\nstruct node{int to,next,val;}e[N<<4];\nint head[N],cnt,dep[N],q[N],c[N],n;\nvoid add(int x,int y,int z){e[cnt]=(node){y,head[x],z};head[x]=cnt++;}\nvoid insert(int x,int y,int z){add(x,y,z),add(y,x,0);}\nint bfs()\n{\n\tint l=0,r=0;q[r++] = S;memset(dep,-1,sizeof(dep));dep[S] = 1;\n\twhile(l<r)\n\t{\n\t\tint x = q[l++];\n\t\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t\t{\n\t\t\tint to1=e[i].to;\n\t\t\tif(dep[to1]==-1&&e[i].val)dep[to1] = dep[x]+1 , q[r++] = to1;\n\t\t}\n\t}return dep[T] != -1;\n}\nint dfs(int x,int maxf)\n{\n\tif(x==T)return maxf;int tflow = maxf , nowf;\n\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t{\n\t\tint to1=e[i].to;\n\t\tif(dep[to1]==dep[x]+1&&e[i].val)\n\t\t{\n\t\t\tnowf = dfs(to1 , min(tflow , e[i].val) );\n\t\t\tif(nowf && x>=1 && x<=n-1 && to1) c[x]=to1-n+2;\n\t\t\te[i].val-=nowf , tflow -= nowf , e[i^1].val += nowf;\n\t\t\tif(!tflow)break;\n\t\t}\n\t}if(tflow)dep[x]=-1;return maxf-tflow;\n}\nvector<int >v[N];\nint Dinic()\n{\n\tint sum = 0;\n\twhile(bfs())sum += dfs(S,1<<30);\n\treturn sum;\n}\nint vis[N];pair<int ,int > ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);memset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint siz; scanf(\"%d\",&siz); insert(S,i,1); insert(n+i-1,T,1);\n\t\tfor(int j=1,x;j<=siz;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x),v[x].push_back(i);\n\t\t\tif(x!=1)insert(i,n+x-2,1);\n\t\t}\n\t}\n\t// puts(\"B\");\n\tif(Dinic()==n-1)\n\t{\n\t\t// puts(\"a\");\n\t\tint l = 0 , r = 0;\n\t\tfor(int i=0;i<v[1].size();i++)\n\t\t\tq[r++] = v[1][i] , vis[v[1][i]] = 1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint x = q[l++]; ans[x] = make_pair(vis[x] , c[x]); x = c[x];\n\t\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\t\tif(!vis[v[x][i]]) q[r++] = v[x][i] , vis[v[x][i]] = x;\n\t\t}\n\t\tif(r==n-1)for(int i=1;i<n;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\telse puts(\"-1\");\n\t}else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int INF=0x3f3f3f3f;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+2*NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tinline void AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int Aug(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tint sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min(e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tint Flow;\n\tint ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c;i<n;i++) {\n\t\tscanf(\"%d\",&c);\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1,u;j<=c;j++) {\n\t\t\tscanf(\"%d\",&u);\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nconst int N=1e5+6,V=2e5+6;\nstruct edge{int v,c,nxt;}g[800003];\nint n,m,head[V],k,iter[V],S,T,d[V],q[V],l,r,f[N],x[N],vis[N];\nstd::vector<int>e[N];\ninline void Insert(int u,int v){\n\tg[k]=(edge){v,1,head[u]},head[u]=k++;\n\tg[k]=(edge){u,0,head[v]},head[v]=k++;\n}\ninline bool Bfs(){\n\tint u,v;\n\tfor(u=1;u<=T;u++)d[u]=0;\n\td[q[l=r=0]=S]=1;\n\tfor(;l<=r;){\n\t  u=q[l++];\n\t  for(int i=head[u];~i;i=g[i].nxt)if(g[i].c&&!d[v=g[i].v])\n\t\td[v]=d[u]+1,q[++r]=v;\n\t}return d[T];\n}\nint Dfs(int u,int f){\n\tif(!f||u==T)return f;\n\tint v,res=0,tmp;\n\tfor(int&i=iter[u];~i;i=g[i].nxt)\n\t  if(g[i].c&&d[v=g[i].v]>d[u]&&(tmp=Dfs(v,std::min(f,g[i].c)))){\n\t\tg[i].c-=tmp,g[i^1].c+=tmp;\n\t\tf-=tmp,res+=tmp;\n\t\tif(!f)return res;\n\t  }\n\treturn res;\n}\ninline int Maxflow(){\n\tint res=0;\n\tfor(;;){\n\t  if(!Bfs())return res;\n\t  for(int u=1;u<=T;u++)iter[u]=head[u];\n\t  res+=Dfs(S,n-1);\n\t}\n}\nvoid Ans(int u){\n\tvis[u]=1;\n\tfor(int i=0;i<e[u].size();i++)if(!vis[f[e[u][i]]])\n\t  x[e[u][i]]=u,Ans(f[e[u][i]]);\n}\nint main(){\n\tint u;\n\tscanf(\"%d\",&n);\n\tS=n+n-1,T=n+n;\n\tfor(u=1;u<=T;u++)head[u]=-1;\n\tfor(int i=1;i<n;i++){\n\t  scanf(\"%d\",&m);\n\t  for(;m--;){\n\t\tscanf(\"%d\",&u);\n\t\tif(u<n)Insert(u,i+n-1);\n\t\te[u].push_back(i);\n\t  }\n\t  Insert(i+n-1,T);\n\t}\n\tfor(u=1;u<n;u++)Insert(S,u);\n\tif(Maxflow()!=n-1)return 0*puts(\"-1\");\n\tfor(int u=1;u<n;u++)\n\t  for(int i=head[u];~i;i=g[i].nxt)if(!g[i].c)\n\t\tf[g[i].v-n+1]=u;\n\tAns(n);\n\tfor(int u=1;u<=n;u++)if(!vis[u])return 0*puts(\"-1\");\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",x[i],f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n  return 0;\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;Gap[0]=n;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\n\nstruct UnionFind // UnionFind Tree (0-indexed)\n{\n    vector<int> par, rank;\n    UnionFind(int N) : par(N), rank(N) { REP(i, N) par[i] = i; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (rank[x] < rank[y]) par[x] = y; else par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    vector<set<int>> ves(N);\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        for (auto v : w) ves[i].insert(v);\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        wm[i] = w[0];\n        for (auto v : w) if (v != w[0]) a.add_edge(i, N + v, 10);\n    }\n    REP(i, N) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    lint mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 9) ans.push_back(pint(wm[from], ed.to - N));\n        }\n\n        if(ans.size() != N - 1) exit(1);\n        UnionFind uf(N + 1);\n        for (auto pa : ans) uf.unite(pa.first, pa.second);\n        REP(i, N) if (!uf.same(1, i + 1)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].first)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].second)) exit(1);\n\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\tint tot = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) {\n\t\t\t\twrite(i), putchar(' ');\n\t\t\t\twrite(par[par[i]]), putchar('\\n');\n\t\t\t\ttot++;\n\t\t\t} \n\t\t}\n\t\tif (tot != n - 1) {\n\t\t\twhile (true) tot++;\n\t\t}\n\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge { int to, cap, rev, id; };\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        level = vector<int>(N);\n        iter = vector<int>(N);\n    }\n\n    //実際の流量を求めたい辺には0以上のidを与える　逆辺のcapを用いる\n    void add_Directed_edge(int from, int to, int cap, int id = -1){\n        G[from].push_back((edge){to, cap, (int)G[to].size(), -1});\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1, id});\n    }\n\n    void bfs(int s){\n        memset(&level[0], -1, sizeof(level[0]) * level.size());\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(!que.empty()){\n            int v = que.front(); que.pop();\n            REP(i, G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        for(int &i = iter[v]; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t){\n        int flow = 0;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            memset(&iter[0], 0, sizeof(iter[0]) * iter.size());\n            int f;\n            while((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    //実際の流量を求める、max_flow(s, t)を使ってから\n    vector<int> calc_flow(int max_id){\n        vector<int> flow(max_id + 1, -1);\n        REP(v, N) for(auto e: G[v]) if(e.id >= 0) flow[e.id] = e.cap;\n        return flow;\n    }\n\n};\n\nvoid dfs(int v, vector<pairs> &es, pairs &ans, bools &used){\n    used[v] = true;\n    for(Pii q: es[v]) if(!used[q.f]){\n        ans[q.s] = Pii(v, q.f);\n        dfs(q.f, es, ans, used);\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec c(N - 1);\n    mat w(N - 1);\n    REP(i, N - 1){\n        cin >> c[i];\n        w[i].resize(c[i]);\n        cin >> w[i];\n        REP(j, c[i]) w[i][j]--;\n    }\n\n    Graph G(2 * N + 2);\n    int s = 2 * N, t = s + 1;\n    REP(i, N - 1){\n        G.add_Directed_edge(s, i, 1);\n        G.add_Directed_edge(i + N, t, 1);\n    }\n\n    int e = 0;\n    pairs info;\n    REP(i, N - 1){\n        for(int x: w[i]) if(x != N - 1){\n            G.add_Directed_edge(i, x + N, 1, e);\n            e++;\n            info.pb(Pii(i, x + N));\n        }\n    }\n    int f = G.max_flow(s, t);\n    vec flow = G.calc_flow(e - 1);\n\n    if(f != N - 1){\n        Return(-1);\n    }\n\n    vector<pairs> es(N);\n    REP(k, e) if(flow[k] == 1){\n        int i = info[k].f, x = info[k].s - N;\n        for(int y: w[i]){\n            es[y].pb(Pii(x, i));\n        }\n    }\n    bools used(N, false);\n    pairs ans(N - 1);\n    dfs(N - 1, es, ans, used);\n\n    REP(i, N) if(!used[i]){\n        Return(-1);\n    }\n    REP(i, N - 1) cout << ans[i].f + 1 << \" \" << ans[i].s + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MN 201000\n#define MM 801000\n\nint h[MN], nxt[MM], to[MM], cap[MM], K = 1;\nint iter[MN], d[MN], q[MN], hh = 0, tt = 0;\nstd::vector<int> B[MN];\nint x[MN], y[MN];\nbool used[MN]; int mat[MN];\n\nvoid ins(int u, int v, int c) {nxt[++K] = h[u]; h[u] = K; to[K] = v; cap[K] = c;}\nvoid insw(int u, int v, int c) {ins(u, v, c); ins(v, u, 0);}\n\nbool bfs(int S, int T)\n{\n\tmemset(d, 0, sizeof(d));\n\thh = tt = 0; d[S] = 1; q[tt++] = S;\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t\tif(cap[i] && !d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\tif(to[i] == T) return 1;\n\t\t\t\tq[tt++] = to[i];\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int T, int f)\n{\n\tif(u == T) return f;\n\tint used = 0;\n\tfor(int &i = iter[u]; i; i = nxt[i])\n\t\tif(cap[i] && d[to[i]] == d[u] + 1)\n\t\t{\n\t\t\tint w = dfs(to[i], T, std::min(f - used, cap[i]));\n\t\t\tif(w)\n\t\t\t{\n\t\t\t\tcap[i] -= w; cap[i ^ 1] += w; used += w; \n\t\t\t\tif(used == f) return f;\n\t\t\t}\n\t\t}\n\treturn used;\n}\n\nint dinic(int S, int T)\n{\n\tint flow = 0;\n\twhile(bfs(S, T))\n\t{\n\t\tmemcpy(iter, h, sizeof(h));\n\t\tint f;\n\t\twhile(f = dfs(S, T, 1e9)) flow += f;\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint S = 2 * n, T = S + 1; \n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint o; scanf(\"%d\", &o);\n\t\tfor(int j = 1; j <= o; j++) \n\t\t{\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\tB[k].push_back(i);\n\t\t\tinsw(i, n - 1 + k, 1); \n\t\t}\n\t\tinsw(S, i, 1);\n\t}\n\tfor(int i = n; i < 2 * n; i++) insw(i, T, 1);\n\tif(dinic(S, T) != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = h[i]; j; j = nxt[j])\n\t\t\tif(!cap[j] && n <= to[j] && to[j] < 2 * n) mat[i] = to[j] - n + 1;\n\tfor(int i = 1; i < n; i++) used[mat[i]] = 1;\n\thh = tt = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) q[tt++] = i; \n\tmemset(used, 0, sizeof(used));\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = 0; i < B[u].size(); i++)\n\t\t{\n\t\t\tif(!used[B[u][i]]) \n\t\t\t{\n\t\t\t\tused[B[u][i]] = 1;\n\t\t\t\tx[B[u][i]] = mat[B[u][i]]; y[B[u][i]] = u;\n\t\t\t\tq[tt++] = mat[B[u][i]];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i < n; i++) if(!used[i]) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        ans += dfs(s,t,inf);\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , bel[N] , n;\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 2;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1 ){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t\tbel[e[j].to] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"_-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nconst int N=1e6+5;\nint n,s,ans,now=1,v[N],w[N],cr[N],vi[N],dis[N],nex[N],head[N];\nvoid addedges(int x,int y,int z){\n\tnex[++now]=head[x],w[now]=z;\n\thead[x]=now,v[now]=y;\n}\nvoid add(int x,int y,int z){\n\taddedges(x,y,z);\n\taddedges(y,x,0);\n}\nqueue<int>que;\nbool bfs(){\n\tfor(int i=0;i<=s;i++)\tcr[i]=head[i];\n\tfor(int i=0;i<s;i++)\tdis[i]=0;\n\tdis[s]=1,que.push(s);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tfor(int i=head[x];i;i=nex[i]){\n\t\t\tif(w[i]&&!dis[v[i]]){\n\t\t\t\tdis[v[i]]=dis[x]+1;\n\t\t\t\tque.push(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[0];\n}\nint dfs(int x,int f){\n\tint ans=0;\n\tif(!x||!f)\treturn f;\n\tfor(int &i=cr[x];i;i=nex[i])\n\t\tif(w[i]&&dis[v[i]]==dis[x]+1){\n\t\t\tint d=dfs(v[i],min(w[i],f));\n\t\t\tif(!d)\tcontinue;\n\t\t\tans+=d,w[i]-=d;\n\t\t\tw[i^1]+=d,f-=d;\n\t\t\tif(!f)\tbreak;\n\t\t}\n\tif(!ans)\tdis[x]=-1;\n\treturn ans;\n}\nint bl[N],fa[N];\nvector<int>b[N];\nint main(){\n\tscanf(\"%d\",&n),s=n*2;\n\tfor(int i=1,si,x;i<n;i++){\n\t\tscanf(\"%d\",&si),add(s,i+n,1);\n\t\twhile(si--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tb[x].push_back(i+n);\n\t\t\tif(x!=1)\tadd(i+n,x,1);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\tadd(i,0,1);\n\n\twhile(bfs())\n\twhile(int d=dfs(s,inf))\tans+=d;\n\n\tif(ans!=n-1)\tputs(\"-1\"),exit(0);\n\tfor(int i=n+1;i<s;i++)\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t\tif(!w[j])\tbl[i]=v[j];\n\tque.push(1);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tint si=b[x].size();\n\t\tfor(int i=0;i<si;i++)\n\t\t\tif(!vi[b[x][i]]){\n\t\t\t\tfa[b[x][i]]=x,vi[b[x][i]]=1;\n\t\t\t\tque.push(bl[b[x][i]]);\n\t\t\t}\n\t}\n\tfor(int i=n+1;i<s;i++)\n\t\tprintf(\"%d %d\\n\",fa[i],bl[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nvector<int>rev[110000];\nint n;\nvector<int>g[210000];\nint t[210000];\nint L[110000];\nint R[110000];\nvoid dfs(int a){\n\tt[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tint to=g[a][i];\n\t\tif(t[to])continue;\n\t\tif(to<a-1){\n\t\t\tR[to]=a-n+1;\n\t\t}else{\n\t\t\tL[a]=to-n+1;\n\t\t}\n\t\tdfs(to);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t\trev[c].push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=0;i<a-1;i++){\n\t\t// std::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tif(0==v[i][j])continue;\n\t\t\t// printf(\"[%d] [%d]\\n\",i,v[i][j]);\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\t// printf(\"%d %d\\n\",i,to);\n\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\tg[v[i][k]+a-1].push_back(i);\n\t\t\t\t}\n\t\t\t\tg[i].push_back(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++)L[i]=R[i]-1;\n\tdfs(a-1);\n\tfor(int i=0;i<a-1;i++){\n\t\tif(L[i]==-1||R[i]==-1){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",L[i]+1,R[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n\n\tedge() {}\n\tedge(int to, int cap, int rev): to(to), cap(cap), rev(rev) {}\n};\n\nstruct max_flow {\n\tint n, S, T;\n\tvector<vector<edge> > g;\n\n\tmax_flow() {}\n\tmax_flow(int N): n(N) { g.resize(N); }\n\tmax_flow(int N, int s, int t): n(N), S(s), T(t) { g.resize(N); }\n\n\tinline void add_edge(int from, int to, int cap) {\n\t\tg[from].push_back(edge(to, cap, g[to].size()));\n\t\tg[to].push_back(edge(from, 0, g[from].size() - 1));\n\t\treturn;\n\t}\n\n\tinline int dinic() {\n\t\tvector<int> dst(n), iter(n);\n\t\tauto bfs = [&]() {\n\t\t\tfill(dst.begin(), dst.end(), -1);\n\t\t\tqueue<int> q;\n\t\t\tq.push(S);\n\t\t\tdst[S] = 0;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint u = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (auto &e: g[u]) if(e.cap && !~dst[e.to]) dst[e.to] = dst[u] + 1, q.push(e.to);\n\t\t\t}\n\t\t\treturn dst[T] != -1;\n\t\t};\n\t\tint ret = 0;\n\t\twhile(bfs()) {\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tfunction<int(int, int)> dfs = [&](int u, int f) {\n\t\t\t\tif(u == T) return f;\n\t\t\t\tint t = f;\n\t\t\t\tfor (int &i = iter[u]; i < g[u].size(); ++i) {\n\t\t\t\t\tauto &e = g[u][i];\n\t\t\t\t\tif(e.cap && dst[e.to] == dst[u] + 1) {\n\t\t\t\t\t\tint F = dfs(e.to, min(t, e.cap));\n\t\t\t\t\t\te.cap -= F;\n\t\t\t\t\t\tg[e.to][e.rev].cap += F;\n\t\t\t\t\t\tt -= F;\n\t\t\t\t\t\tif(!t) return f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn f - t;\n\t\t\t};\n\t\t\tstatic const int oo = INT_MAX;\n\t\t\tfor (int f = dfs(S, oo); f; f = dfs(S, oo)) ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > apr(n + 1);\n\tmax_flow flow(n * 2, 0, 1);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint sz, foo = i + n;\n\t\tcin >> sz;\n\t\tflow.add_edge(foo, 1, 1);\n\t\tflow.add_edge(0, i + 1, 1);\n\t\twhile(sz--) {\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tflow.add_edge(u, foo, 1);\n\t\t\tapr[u].push_back(foo);\n\t\t}\n\t}\n\tif(flow.dinic() != n - 1) { cout << \"-1\\n\"; return 0; }\n\tvector<int> rem(n * 2, -1), con(n * 2, -1);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u = i + n;\n\t\tfor (auto &e: flow.g[u]) if(e.cap && e.to >= 2 && e.to <= n) rem[u] = e.to;\n\t\tif(!~rem[u]) { cout << \"-1\\n\"; return 0; }\n\t}\n\tqueue<int> q;\n\tq.push(1);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i: apr[u]) if(!~con[i]) {\n\t\t\tq.push(rem[i]);\n\t\t\tcon[i] = u;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u = i + n;\n\t\tif(!~rem[u] || !~con[u]) { cout << \"-1\\n\"; return 0; }\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u = i + n;\n\t\tcout << rem[u] << ' ' << con[u] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modInt {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }\n    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }\n    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }\n\n    friend void check(modInt& a, modInt& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modInt operator+(modInt a, modInt b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modInt operator-(modInt a, modInt b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modInt operator-(const modInt& a) { return modInt(0)-a; }\n\n    friend modInt operator*(modInt a, modInt b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modInt exp(modInt a, ll p) {\n        modInt ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modInt inv(const modInt& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modInt operator/(modInt a, modInt b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modInt<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Dinic {\n    struct Edge { int v, rev; ll flow, cap; };\n\n    vector<Edge> adj[SZ];\n\n    void addEdge(int u, int v, ll cap) {\n        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};\n        adj[u].pb(a), adj[v].pb(b);\n    }\n\n    int ST, EN, level[SZ], ind[SZ];\n\n    bool bfs() { // level = shortest distance from source\n        // after computing flow, edges {u,v} such that level[u] \\neq -1, level[v] = -1 are part of min cut\n        F0R(i,SZ) level[i] = -1, ind[i] = 0;\n        level[ST] = 0;\n\n        queue<int> q; q.push(ST);\n        while (sz(q)) {\n            int u = q.front(); q.pop();\n            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {\n                level[e.v] = level[u] + 1;\n                q.push(e.v);\n            }\n        }\n\n        return level[EN] >= 0;\n    }\n\n    ll sendFlow(int s, ll flow) {\n        if (s == EN) return flow;\n\n        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {\n            Edge& e = adj[s][ind[s]];\n\n            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;\n            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));\n\n            if (f) { // saturate at least one edge\n                e.flow += f; adj[e.v][e.rev].flow -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    ll maxFlow(int _ST, int _EN) {\n        ST = _ST, EN = _EN;\n        if (ST == EN) return -1;\n        ll tot = 0;\n        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;\n        return tot;\n    }\n};\n\nDinic<200002> D;\nint N, match[MX];\nbool vis[MX], done[MX];\npi ans[MX];\n\nvoid dfs(int x) {\n    vis[x] = 1;\n    trav(t,D.adj[x+N]) if (t.flow == 0 && 1 <= t.v && t.v < N) {\n        if (!vis[match[t.v]]) {\n            ans[t.v] = {match[t.v],x};\n            dfs(match[t.v]);\n        }\n    }\n}\n\nint main() {\n    setIO(); re(N);\n    FOR(i,1,N) {\n        D.addEdge(0,i,1);\n        int c; re(c); \n        F0R(j,c) {\n            int w; re(w);\n            D.addEdge(i,N+w,1);\n        }\n    }\n    FOR(i,N+1,2*N+1) D.addEdge(i,2*N+1,1);\n    if (D.maxFlow(0,2*N+1) != N-1) {\n        ps(-1);\n        exit(0);\n    }\n    FOR(i,1,N) {\n        trav(t,D.adj[i]) if (N+1 <= t.v && t.v <= 2*N && t.flow > 0) {\n            match[i] = t.v-N;\n            done[match[i]] = 1;\n        }\n    }\n    FOR(i,1,N+1) if (!done[i]) {\n        dfs(i);\n        break;\n    }\n    FOR(i,1,N) if (ans[i].f == 0) {\n        ps(-1);\n        exit(0);\n    }\n    FOR(i,1,N) ps(ans[i].f,ans[i].s);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define STS system(\"pause\")\n#define C(x,y) memset(x,y,sizeof(x))\ntemplate<class U>I read(U &res){\n\tres=0;register U g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nconst int INF=1e9+7;\nvector<int>v[101000];\nstruct E{int to,nt,w;}e[808000];\n#define T e[k].to\nint n,m,p,head[202000],dis[202000],X,tot=-1,S,D,cur[202000];\nint a[202000],b[202000],vis[202000][2];\nqueue<int>q;\nIN B_1(){\n\tC(dis,-1);dis[S]=0;q.push(S);\n\tmemcpy(cur,head,sizeof(head));\n\twhile(!q.empty()){\n\t\tp=q.front();q.pop();\n\t\tfor(re k=head[p];k!=-1;k=e[k].nt){\n\t\t\tif(dis[T]==-1&&e[k].w>0){dis[T]=dis[p]+1;q.push(T);}\n\t\t}\n\t}\n\treturn dis[D]!=-1;\n} \nIN D_1(int x,int lim){\n\tif(x==D||!lim)return lim;\n\tre flow=0,ext;\n\tfor(re &k=cur[x];k!=-1;k=e[k].nt){\n\t\tif(dis[x]+1==dis[T]&&e[k].w>0){\n\t\t\text=D_1(T,min(lim,e[k].w));\n\t\t\tif(!ext)continue;\n\t\t\tflow+=ext;lim-=ext;\n\t\t\te[k].w-=ext;e[k^1].w+=ext;\n\t\t\tif(!lim)break;\n\t\t}\n\t}\n\tif(lim)dis[x]=-1;\n\treturn flow;\n}\nI add(int x,int y,int w){\n\te[++tot].to=y;\n\te[tot].nt=head[x];\n\thead[x]=tot;\n\te[tot].w=w;\n\te[++tot].to=x;\n\te[tot].nt=head[y];\n\thead[y]=tot;\n\te[tot].w=0;\n}\nIN dinic(){re res=0;while(B_1())res+=D_1(S,INF);return res;}\nint main(){\n\tread(n);tot=-1;C(head,-1);S=0;D=(n<<1);\n\tF(i,1,n-1){\n\t\tread(m);add(S,n+i,1);add(i,D,1);\n\t\tF(j,1,m){read(X);add(n+i,X,1);v[X].emplace_back(i);}\n\t}\n\tadd(n,D,1);\n\tif(dinic()<n-1){cout<<\"-1\";return 0;}\n\tF(i,1,n-1){\n\t\tfor(re k=head[n+i];k!=-1;k=e[k].nt){\n\t\t\tif(T&&(!e[k].w))a[i]=T,vis[T][0]=1;\n\t\t}\n\t}\n\tF(i,1,n)if(!vis[i][0])q.push(i);\n\tm=0;\n\twhile(!q.empty()){\n\t\tp=q.front();q.pop();m++;\n\t\tfor(auto k:v[p]){\n\t\t\tif(!vis[k][1]){vis[k][1]=1;b[k]=p;q.push(a[k]);}\n\t\t}\n\t}\n\tif(m<n){cout<<\"-1\";return 0;}\n\tF(i,1,n-1)cout<<a[i]<<\" \"<<b[i]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline int solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\tint link = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tlink++;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn link;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif (solve() < n - 1) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 8e5 + 10, maxm = maxn;\nint to[maxm], nxt[maxm], head[maxn], cap[maxm], e, dep[maxn], flow[maxm], vis[maxn], s, t, cur[maxn];\npair<int, int> p[maxn];\n\nvoid add(int x, int y, int z)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0;\n}\n\nint bfs()\n{\n\tfor(int i = s; i <= t; ++i) dep[i] = 0;\n\tqueue<int> Q;\n\tdep[s] = 1; Q.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(!dep[v] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dep[t]) \n\t{\n\t\tfor(int i = s; i <= t; ++i) cur[i] = head[i];\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint dfs(int x, int a)\n{\n\tif(x == t || a == 0) return a;\n\tint FLOW = 0, f;\n\tfor(int &i = cur[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif(dep[v] == dep[x] + 1 && (f = dfs(v, min(a, cap[i] - flow[i]))) > 0)\n\t\t{\n\t\t\tFLOW += f;\n\t\t\ta -= f;\n\t\t\tflow[i] += f; flow[i ^ 1] -= f;\n\t\t\tif(!a) return FLOW;\n\t\t}\n\t}\n\treturn FLOW;\n}\n\nint main()\n{\n\n\tint n = read();\n\te = 1; s = 0; t = n + n;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint m = read();\n\t\tfor(int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\n\tfor(int i = 2; i <= n; ++i) add(s, i, 1);\n\tfor(int i = n + 1; i <= n + n - 1; ++i) add(i, t, 1);\n\n\tint All = 0;\n\twhile(bfs()) All += dfs(s, 0x3f3f3f3f);\n\tif(All != n - 1) return puts(\"-1\"), 0;\n\tfor(int u = 2; u <= n; ++u)\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(cap[i] == flow[i] && to[i] != s)\n\t\t\tp[to[i]].x = u;\n\n\tqueue<int> Q; Q.push(1);\n\tint fg = n - 1;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(to[i] != s && !vis[to[i]])\n\t\t\tp[to[i]].y = u, vis[to[i]] = 1, Q.push(p[to[i]].x), --fg;\n\t}\n\tif(fg) return puts(\"-1\"), 0;\n\n\tfor(int i = n + 1; i <= n + n - 1; ++i) printf(\"%d %d\\n\", p[i].x, p[i].y);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\n// O(V^2 E)\nstruct Dinic {\n    using F = ll;\n    static constexpr F INF = numeric_limits<F>::max();\n\n    struct Edge {\n        int to, rev;\n        F cap;\n        Edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev){};\n    };\n\n    using E = Edge;\n\n    VV<E> g;\n    V<int> level, iter;\n\n    Dinic() {}\n    Dinic(int n) : g(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, F cap) {\n        g[from].emplace_back(to, cap, (int)g[to].size());\n        g[to].emplace_back(from, 0, (int)g[from].size() - 1);\n    }\n\n    void bfs(int s) {\n        fill(ALL(level), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (auto& e : g[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    F dfs(int v, int t, F f) {\n        if (v == t) return f;\n        for (int& i = iter[v]; i < g[v].size(); i++) {\n            auto& e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                F d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    F max_flow(int s, int t) {\n        F flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(ALL(iter), 0);\n            F f;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    VV<int> E(N);\n    rep(i, N - 1) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int x;\n            cin >> x;\n            --x;\n            E[i].pb(x);\n        }\n    }\n\n    rep(r, N) {  // special\n        Dinic flow(N + N + 2);\n        int s = N * 2, t = s + 1;\n        rep(i, N - 1) {\n            flow.add_edge(i + N, t, 1);\n            for (int x : E[i])\n                if (x != r) {\n                    flow.add_edge(x, i + N, 1);\n                }\n        }\n        rep(i, N) { flow.add_edge(s, i, 1); }\n        int f = flow.max_flow(s, t);\n        if (f != N - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct Edge {\n  int t,f,next;\n  Edge() {}\n  Edge(int a,int b,int c):t(a),f(b),next(c) {}\n};\n\nEdge e[1000000];\nint head[200005],vs,vt,tot=-1;\n\ninline void addEdge(int x,int y,int z) {\n  e[++tot]=Edge(y,z,head[x]);\n  head[x]=tot;\n  e[++tot]=Edge(x,0,head[y]);\n  head[y]=tot;\n}\n\nnamespace Flow {\n\t\nint d[200005],cur[200005];\nqueue <int> q;\n\nbool bfs() {\n  while (!q.empty()) q.pop();\n  memset(d,255,sizeof(d));\n  d[vs]=0;cur[vs]=head[vs];\n  q.push(vs);\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tfor(int i=head[x];i!=-1;i=e[i].next)\n  \t  if (e[i].f&&d[e[i].t]==-1) {\n  \t  \t  int u=e[i].t;\n  \t  \t  d[u]=d[x]+1;\n  \t  \t  cur[u]=head[u];\n  \t  \t  if (u==vt) return 1;\n  \t  \t  q.push(u);\n\t\t}\n  }\n  return 0;\n}\n\nint dfs(int x,int a) {\n  if (x==vt||!a) return a;\n  int ans=0;\n  for(int &i=cur[x];i!=-1;i=e[i].next)\n    if (e[i].f&&d[e[i].t]==d[x]+1) {\n    \tint u=e[i].t;\n    \tint f=dfs(u,min(a,e[i].f));\n    \tif (f) {\n    \t\te[i].f-=f;\n    \t\te[i^1].f+=f;\n    \t\tans+=f;\n    \t\ta-=f;\n    \t\tif (!a) break;\n\t\t}\n\t}\n  return ans;\n} \n\nint maxflow() {\n  int ans=0;\n  while (bfs())\n    ans+=dfs(vs,inf);\n  return ans;\n}\n\t\n}\n\nvector <int> bel[100005];\nbool vis1[100005],vis2[100005];\nint id[100005],nxt[100005];\n\nqueue <int> q;\n\nbool solve(int n) {\n  for(int i=1;i<n;i++)\n    for(int j=head[n+i];j!=-1;j=e[j].next)\n      if (e[j].t&&!e[j].f) {\n      \tint u=e[j].t;\n      \tid[i]=u;\n      \tvis1[u]=1;\n\t  }\n  for(int i=1;i<=n;i++)\n    if (!vis1[i]) q.push(i);\n  int cnt=0;\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tcnt++;\n  \tfor(int i=0;i<bel[x].size();i++)\n  \t  if (!vis2[bel[x][i]]) {\n  \t  \t  int u=bel[x][i];\n  \t  \t  vis2[u]=1;\n  \t  \t  nxt[u]=x;\n  \t  \t  q.push(id[u]);\n\t\t}\n  }\n  return cnt==n;\n}\n\nint main() {\n  memset(head,255,sizeof(head));\n  int n;\n  scanf(\"%d\",&n);\n  vs=0;vt=2*n;\n  for(int i=1;i<n;i++) {\n  \tint x;\n  \tscanf(\"%d\",&x);\n  \taddEdge(vs,n+i,1);\n  \tfor(int j=1;j<=x;j++) {\n  \t\tint y;\n  \t\tscanf(\"%d\",&y);\n  \t\taddEdge(n+i,y,1);\n  \t\tbel[y].push_back(i);\n\t  }\n  }\n  for(int i=1;i<=n;i++) addEdge(i,vt,1);\n  if (Flow::maxflow()<n-1) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  if (!solve(n)) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  for(int i=1;i<n;i++) printf(\"%d %d\\n\",id[i],nxt[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,F[N],vis[N];\nvector<int> go[N];\n\nnamespace flow {\n\tconst int V = 200020, E = 1000004;\n\tint S, T, tot = 1, fst[V], nxt[E], to[E], flow[E], lvl[V];\n\t\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; flow[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; flow[tot] = 0;\n\t}\n\t\n\tint bfs() {\n\t\tqueue<int> q;\n\t\tfor(int i = 0; i <= T; i ++)\n\t\t\tlvl[i] = 0;\n\t\tq.push(S); lvl[S] = 1;\n\t\tint u, v;\n\t\twhile (!q.empty()) {\n\t\t\tu = q.front(); q.pop();\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (flow[i] && !lvl[v = to[i]]) {\n\t\t\t\t\tlvl[v] = lvl[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t}\n\t\treturn lvl[T];\n\t}\n\t\n\tint dinic(int u, int f) {\n\t\tif (u == T)\n\t\t\treturn f;\n\t\tint v, k = f;\n\t\tfor (int i = fst[u]; i && k; i = nxt[i])\n\t\t\tif (flow[i] && lvl[v = to[i]] == lvl[u] + 1) {\n\t\t\t\tint t = dinic(v, min(k, flow[i]));\n\t\t\t\tif (!t)\n\t\t\t\t\tlvl[v] = 0;\n\t\t\t\telse\n\t\t\t\t\tk -= t, flow[i] -= t, flow[i ^ 1] += t;\n\t\t\t}\n\t\treturn f - k;\n\t}\n\t\n\tint mf() {\n\t\tint res = 0;\n\t\twhile(bfs()) res += dinic(S, 2e9);\n\t\treturn res;\n\t}\n\t\n\tvoid getmatch() {\n\t\tfor(int s = 1; s < n; ++s)\n\t\t\tfor(int i = fst[s]; i; i = nxt[i])\n\t\t\t\tif(to[i] != S && !flow[i]) {\n\t\t\t\t\tF[s] = to[i] - n; break;\n\t\t\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tflow::S=2*n+1;\n\tflow::T=2*n+2;\n\tfor(int i=1,d,x; i<n; i++)\n\t{\n\t\tflow::addedge(flow::S,i,1);\n\t\tscanf(\"%d\",&d);\n\t\tfor(int j=1; j<=d; ++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tgo[x].push_back(i);\n\t\t\tif(x!=1)\n\t\t\t\tflow::addedge(i,n+x,1);\n\t\t}\n\t}\n\tfor(int i=2; i<=n; i++)\n\t\tflow::addedge(n+i,flow::T,1);\n\tint f=flow::mf();\n\tif(f<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tflow::getmatch();\n\tvector<pair<int,int>> out;\n\tout.resize(n);\n\tqueue<int> q;\n\tq.push(1);\n\tvis[1]=true;\n\twhile(!q.empty()) {\n\t\tint u=q.front(); q.pop();\n\t\tfor(auto &v:go[u]) if(!vis[F[v]]) {\n\t\t\tvis[F[v]]=true;\n\t\t\tout[v]=make_pair(u,F[v]);\n\t\t\tq.push(F[v]);\n\t\t}\n\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tif(!p->first){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tprintf(\"%d %d\\n\",p->first,p->second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;\n}E[MAXN * 20];\nint N,head[MAXN * 2],sumE = 1,S,T,tot,lev[MAXN * 2],cur[MAXN * 2],ch[MAXN],fa[MAXN];\nvector<int> v[MAXN];\nbool vis[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c) {\n    add(u,v,c);add(v,u,0);\n}\nbool BFS() {\n    static int que[MAXN * 2],ql,qr;\n    que[ql = qr = 1] = S;\n    for(int i = 1 ; i <= T ; ++i) lev[i] = -1,cur[i] = head[i];\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    int v = E[i].to;\n\t    if(E[i].cap > 0 && lev[v] == -1) {\n\t\tlev[v] = lev[u] + 1;\n\t\tif(v == T) return true;\n\t\tque[++qr] = v;\n\t    }\n\t}\n    }\n    return false;\n}\nint dfs(int u,int aug) {\n    if(u == T) return aug;\n    int flow = 0;\n    for(int &i = cur[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(E[i].cap > 0 && lev[v] > lev[u]) {\n\t    int t = dfs(v,min(E[i].cap,aug - flow));\n\t    flow += t;E[i].cap -= t;E[i ^ 1].cap += t;\n\t    if(flow == aug) break;\n\t}\n    }\n    if(flow != aug) lev[u] = -1;\n    return flow;\n}\nint Dinic() {\n    int res = 0;\n    while(BFS()) {\n\tres += dfs(1,0x7fffffff);\n    }\n    return res;\n}\nvoid Init() {\n    read(N);\n    S = 1;\n    for(int i = 1 ; i < N ; ++i) {\n\taddtwo(S,i + N,1);\n\tint c,w;\n\tread(c);\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    read(w);\n\t    if(w != 1) addtwo(i + N,w,1);\n\t    v[w].pb(i);\n\t}\n    }\n    T = 2 * N;\n    for(int i = 2 ; i <= N ; ++i) addtwo(i,T,1);\n}\nvoid construct() {\n    static int que[MAXN],ql,qr;\n    que[ql = qr = 1] = 1;\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(auto t : v[u]) {\n\t    if(!vis[t]) {\n\t\tvis[t] = 1;\n\t\tfa[ch[t]] = u;\n\t\tque[++qr] = ch[t];\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    if(Dinic() != N - 1) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= N - 1 ; ++i) {\n\tint u = i + N;\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(v > 1 && E[j].cap == 0) {ch[i] = v;break;}\n\t}\n    }\n    construct();\n    for(int i = 1 ; i < N ; ++i) {\n\tif(!vis[i]) {puts(\"-1\");return;}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tout(fa[ch[i]]);space;out(ch[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>ans[200005];\nint beg = -1;\nbool in[400005];\n\n//O(E sqrt V)\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph, rev;\n  vector< int > dist, match, revmatch;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), rev(m), match(m, -1), revmatch(n,-1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    rev[v].push_back(u);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        revmatch[a] = b;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n  \n  void put_ans() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        ans[match[i]].pb(i);\n      }\n      else{\n      \tbeg = i;\n      }\n    }\n  }\n  \n  void DFS(int cur,bool right){\n      //cout << cur << \" \" << right << endl;\n  \tif(right){\n  \t\t\n  \t\tfor(int i=0;i<rev[cur].size();i++){\n  \t\t\tif(match[cur] == rev[cur][i]) continue;\n  \t\t\tint to = rev[cur][i];\n  \t\t\t//cout << to << endl;\n  \t\t\tif(in[to]) continue;\n  \t\t\tin[to] = 1;\n  \t\t\tans[to].pb(cur);\n  \t\t\t//cout << to << \" \" << cur << endl;\n  \t\t\t//cout << to << endl;\n  \t\t\tDFS(to,false);\n  \t\t}\n  \t}\n  \telse{\n  \t\t\n\t\tfor(int i=0;i<graph[cur].size();i++){\n  \t\t\tif(match[graph[cur][i]] != cur) continue;\n  \t\t\tint to = graph[cur][i];\n  \t\t\tif(in[to+200001]) continue;\n  \t\t\tin[to+200001] = 1;\n  \t\t\tDFS(to,true);\n  \t\t}\n  \t}\n  }\n};\n\nint n;\nvector<int>vec[200005];\n\nint par[200005],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tHopcroftKarp bm(n-1,n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\trep(j,a){\n\t\t\tint x; scanf(\"%d\",&x); x--;\n\t\t\tvec[i].pb(x);\n\t\t\tbm.add_edge(i,x);\n\t\t}\n\t}\n\tint v = bm.bipartite_matching(); \n\tbm.put_ans();\n\tif(beg != -1) bm.DFS(beg,true);\n\tinit();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ans[i].size() != 2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tint x = ans[i][0], y = ans[i][1];\n\t\tif(same(x,y)){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tunite(x,y);\n\t}\n//\tputs(\"YES\");\n\trep(i,n-1) cout << ans[i][0]+1 << \" \" << ans[i][1]+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint n,S,T,fir[200010],head[200010],dep[200010],dis[1000010],nxt[1000010],w[1000010],id=1;\nvoid link(int a,int b,int c){\n\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c;\n\tnxt[++id]=fir[b],fir[b]=id,dis[id]=a,w[id]=0;\n}\nint que[200010],hd,tl,el[100010];\nstd::vector<pr>E[100010];\nbool BFS(){\n\thd=tl=0;memset(dep,0,sizeof dep);\n\tdep[S]=1;que[tl++]=S;\n\twhile(hd^tl){\n\t\tint x=que[hd++];\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t\tif(w[i]&&!dep[dis[i]])\n\t\t\t\tdep[dis[i]]=dep[x]+1,que[tl++]=dis[i];\n\t}\n\treturn dep[T];\n}\nint Dinic(int x,int maxflow){\n\tif(x==T)return maxflow;\n\tint ret=0;\n\tfor(int&i=head[x];i;i=nxt[i])\n\t\tif(w[i]&&dep[dis[i]]==dep[x]+1){\n\t\t\tint d=Dinic(dis[i],std::min(maxflow-ret,w[i]));\n\t\t\tw[i]-=d,w[i^1]+=d,ret+=d;if(ret==maxflow)break;\n\t\t}\n\treturn ret;\n}\nint match[100010],fa[100010],set[1000010];\nint ax[100010],ay[100010];\nvoid DFS(int x){\n\tfor(int i=fir[x];i;i=nxt[i])\n\t\tif(w[i]&&dis[i]!=S&&!fa[match[dis[i]-n]]){\n\t\t\tfa[match[dis[i]-n]]=x;\n\t\t\tset[match[dis[i]-n]]=dis[i]-n;\n\t\t\tDFS(match[dis[i]-n]);\n\t\t}\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi();\n\tfor(int i=1;i<n;++i){\n\t\tint o=gi(),x;E[i].resize(o);\n\t\tfor(int j=0;j<o;++j)link(x=gi(),i+n,1),E[i][j]={id,x};\n\t}\n\tS=n+n,T=n+n+1;\n\tfor(int i=1;i<=n;++i)link(S,i,1),el[i]=id;\n\tfor(int i=n+1;i<n+n;++i)link(i,T,1);\n\tint flow=0;\n\twhile(BFS())memcpy(head,fir,sizeof head),flow+=Dinic(S,1e9);\n\tif(flow<n-1)puts(\"-1\"),exit(0);\n\tint r=0;\n\tfor(int i=1;i<=n;++i)if(!w[el[i]])r=i;\n\tfor(int i=1;i<n;++i)for(pr j:E[i])if(w[j.fi])match[i]=j.se;\n\tfa[r]=-1;DFS(r);\n\tint cnt=0;for(int i=1;i<=n;++i)cnt+=!!fa[i];\n\tif(cnt<n)puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;++i)if(~fa[i])ax[set[i]]=i,ay[set[i]]=fa[i];\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ax[i],ay[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fa[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[dy[y]]) {\n\t\t\tfa[dy[y]] = x;\n\t\t\tdfs(dy[y]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //不能直接判f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t}\n\tfor(int i=n-1;i>=0;--i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nint cur;\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v] == cur) {\n        return false;\n    }\n    used[v] = cur;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int i = 0; i + 1 < n; ++i) {\n        ++cur;\n        dfs(i);\n    }\n    /*for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }*/\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N;\nvector<int> adj[MN];\nint vis[MN], U[MN], V[MN];\n\nvoid dfs(int u) {\n    vis[u] = 1;\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(vis[v]) continue;\n        if(u < N) {\n            U[v - N] = u;\n            dfs(v);\n        }\n        else {\n            V[u - N] = v;\n            dfs(v);\n            return;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int k; scanf(\"%d\", &k);\n\n        for(int j = 0; j < k; j++) {\n            int t; scanf(\"%d\", &t);\n            t--;\n\n            adj[N + i].push_back(t);\n            adj[t].push_back(N + i);\n        }\n    }\n\n    memset(U, -1, sizeof(U));\n    memset(V, -1, sizeof(V));\n    dfs(0);\n    for(int i = 0; i < N - 1; i++) if(U[i] == -1 || V[i] == -1) {\n        printf(\"-1\");\n        return 0;\n    }\n    for(int i = 0; i < N - 1; i++) {\n        printf(\"%d %d\\n\", U[i] + 1, V[i] + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nconst int N = 100179;\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define SZ 2333333\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define ad_de ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n;\nvector<int> t[SZ],g[SZ];\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t\tsort(t[i].begin(),t[i].end());\n\t}\n\tN=n+n-1+2; S=N-1; T=N;\n\tfor(int i=2;i<=n;++i)\n\t\tad_de(S,i,1);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\tad_de(t[i][j],i+n,1),g[i].pb(M);\n\t\tad_de(i+n,T,1);\n\t}\n\tint s=dinic();\n\tif(s!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\tif(cap[g[i][j-1]])\n\t\t\t\tprintf(\"%d %d\\n\",t[i][0],t[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa, adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005];\nvoid bfstree(int s){\n\tqueue<int > q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\tfor(auto t:adj[s]){\n\t\t\tif(!vis[t]){\n\t\t\t\tif(dist[t]>=dist[s]+1){\n\t\t\t\t\tq.push(t);\n\t\t\t\t\tp[t]=s;\n\t\t\t\t\tdist[t]=dist[s]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\tmatch[btoa[i]]=1;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb(btoa[i]);\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << btoa[i] << \" \" << p[btoa[i]] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, M = 8e5 + 5;\n\nstruct edge_t { int u, v, next, cap, flow; } G[M];\n\nvector <int> adj[N];\nqueue <int> q;\nint head[N], nowhead[N], d[N];\nint n, m, s, t, tot = 1;\n\ninline void addedge(int u, int v, int cap) {\n\tG[++tot] = (edge_t) {u, v, head[u], cap, 0}, head[u] = tot;\n\tG[++tot] = (edge_t) {v, u, head[v], 0, 0}, head[v] = tot;\n}\n\nint bfs() {\n\tmemset(d, 0, sizeof(d));\n\td[s] = 1; q.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (!d[v] && G[i].cap > G[i].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\n\nint dfs(int u, int Flow) {\n\tif (u == t || !Flow) return Flow;\n\tint f, flow = 0;\n\tfor (int &i = nowhead[u]; i; i = G[i].next) {\n\t\tint v = G[i].v;\n\t\tif (d[v] == d[u] + 1 && (f = dfs(v, min(Flow, G[i].cap - G[i].flow))) > 0) {\n\t\t\tG[i].flow += f; G[i ^ 1].flow -= f;\n\t\t\tflow += f; Flow -= f;\n\t\t\tif (!Flow) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint dinic() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemcpy(nowhead, head, sizeof(nowhead));\n\t\tans += dfs(s, 0x7fffffff);\n\t}\n\treturn ans;\n}\n\nint fa[N], vis[N], match[N], cnt;\n\nvoid dfs1(int u) {\n\tfor (auto v : adj[u]) {\n\t\tif (!vis[match[v]]) {\n\t\t\tvis[match[v]] = 1;\n\t\t\tfa[match[v]] = u;\n\t\t\t++cnt;\n\t\t\tdfs1(match[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n); s = 0; t = 2 * n;\n\tfor (int i = 1; i < n; i++) {\n\t\tread(m);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x; read(x);\n\t\t\tadj[i].push_back(x + n - 1);\n\t\t\tadj[x + n - 1].push_back(i);\n\t\t\taddedge(i, x + n - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) addedge(s, i, 1);\n\tfor (int i = n; i < 2 * n; i++) addedge(i, t, 1);\n\tif (dinic() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint rt = 0;\n\tfor (int i = head[n * 2]; i; i = G[i].next) {\n\t\tif (G[i].flow == 0) {\n\t\t\trt = G[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int u = 1; u < n; u++) {\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (n <= v && v < n * 2 && G[i].flow) match[u] = v;\n\t\t}\n\t}\n\tvis[rt] = 1; dfs1(rt);\n\tif (cnt != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tprint(match[i] - n + 1, ' ');\n\t\tprint(fa[match[i]] - n + 1, '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\treturn 0;\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=1600010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nint lst[200005], to[2000005], pre[2000005], cap[2000005], tot;\nint dep[200005], que[200005], fst[200005];\ninline void add_edge(int u, int v, int _cap)\n{\n\t// printf(\"%d %d %d\\n\", u, v, _cap);\n\tauto add = [&] (int x, int y, int c)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = c;\n\t\tlst[x] = tot++;\n\t};\n\tadd(u, v, _cap);\n\tadd(v, u, 0);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tint he = 0, ta = 0;\n\tque[ta++] = s;\n\twhile (he < ta)\n\t{\n\t\tint u = que[he++];\n\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t{\n\t\t\tif (cap[i] && dep[to[i]] == -1)\n\t\t\t{\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t\tque[ta++] = to[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tint ans = 0;\n\tfor (int i = fst[u]; ~i; i = pre[i])\n\t{\n\t\tif (cap[i] && dep[to[i]] == dep[u] + 1)\n\t\t{\n\t\t\tint res = dfs(to[i], t, std::min(rem - ans, cap[i]));\n\t\t\tcap[i] -= res;\n\t\t\tcap[i ^ 1] += res;\n\t\t\tif (cap[i])\n\t\t\t\tfst[u] = i;\n\t\t\tans += res;\n\t\t\tif (ans == rem)\n\t\t\t\treturn ans;\n\t\t}\n\t}\n\tif (!ans)\n\t\tdep[u] = -1;\n\treturn ans;\n}\ninline int dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t))\n\t{\n\t\tmemcpy(fst, lst, sizeof(lst));\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nstd::vector<int> vec[200005], bel[200005];\nint fa[200005], rep[200005];\nbool vis[200005];\nint add(int u)\n{\n\tint res = 1;\n\tvis[u] = true;\n\tfor (int x : bel[u])\n\t{\n\t\tif (!vis[rep[x]])\n\t\t{\n\t\t\tfa[x] = u;\n\t\t\tres += add(rep[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC029-F.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint len;\n\t\tscanf(\"%d\", &len);\n\t\twhile (len--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tif (--u)\n\t\t\t\tadd_edge(i + 1, u + n - 1, 1);\n\t\t\tvec[i].pb(u);\n\t\t\tbel[u].pb(i);\n\t\t}\n\t\tadd_edge(0, i + 1, 1);\n\t\tadd_edge(i + n, n + n, 1);\n\t}\n\tif (dinic(0, n + n) != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = lst[i]; ~j; j = pre[j])\n\t\t{\n\t\t\tif (to[j] && !cap[j])\n\t\t\t\trep[i - 1] = to[j] - n + 1;\n\t\t}\n\t}\n\tif (add(0) != n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", fa[i] + 1, rep[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 2e5+5;\n\ntypedef ll Flow;\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\n\nstruct PushRelabel {\n\tvector<vector<Edge>> g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\n\nint n, m[MAXN], r[MAXN];\nvector<int> e[MAXN], g[MAXN];\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tPushRelabel mf(2*n+1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tmf.add_edge(0, i+1, 1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tmf.add_edge(i+1, x+n, 1);\n\tfor (int i = n; i < 2*n; ++i)\n\t\tmf.add_edge(i, 2*n, 1);\n\tint fl = mf.maxflow(0, 2*n);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\treturn 0;\n\tauto h = mf.g;\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 1) {\n\t\t\t\tm[i] = e.dest-n;\n\t\t\t\tr[e.dest-n] = i;\n\t\t\t\ts -= (e.dest - n);\n\t\t\t\t// cout << i << ' ' << m[i]+1 << endl;\n\t\t\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 0) {\n\t\t\t\t// cout << e.dest - n << ' ' << m[i] << endl;\n\t\t\t\tg[e.dest - n].push_back(m[i]);\n\t\t\t}\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e5 + 10;\nconst int INF = 1e9;\n\nstruct Edge {\n  int u, v, cap, flow;\n};\n\nnamespace Max_flow {\n\nvector<Edge> E;\nvector<int> G[N];\n\nint S, T, n, d[N];\n\nvoid init(int _n, int _s, int _t) {\n  n = _n, S = _s, T = _t;\n  for (int i = 0; i <= n; i++) G[i].clear();\n  E.clear();\n}\n\nvoid addedge(int u, int v, int cap) {\n  E.push_back((Edge) {u, v, cap, 0});\n  E.push_back((Edge) {v, u, 0, 0});\n  int m = E.size();\n  G[u].push_back(m - 2);\n  G[v].push_back(m - 1);\n}\n\nbool bfs() {\n  for (int i = 0; i <= n; i++) d[i] = 0;\n  d[S] = 1;\n  queue<int> q;\n  q.push(S);\n  while (q.size()) {\n    int u = q.front(); q.pop();\n    for (int i : G[u]) {\n      if (E[i].cap > E[i].flow && !d[E[i].v]) {\n        d[E[i].v] = d[u] + 1;\n        q.push(E[i].v);\n      }\n    }\n  }\n  return d[T];\n}\n\nint dfs(int u, int a) {\n  if (!a || u == T) return a;\n  int flow = 0;\n  for (int i : G[u]) {\n    if (d[E[i].v] != d[u] + 1) continue;\n    int f = dfs(E[i].v, min(E[i].cap - E[i].flow, a));\n    flow += f;\n    a -= f;\n    E[i].flow += f;\n    E[i ^ 1].flow -= f;\n  }\n  if (!flow) d[u] = 0;\n  return flow;\n}\n\nint max_flow() {\n  int flow = 0;\n  while (bfs()) {\n    flow += dfs(S, INF);\n  }\n  return flow;\n}\n\n}\n\nint n, c[N], p[N], q[N], vis[N];\nvector<int> g[N], bel[N];\n\nint main() {\n  scanf(\"%d\", &n);\n  Max_flow::init(2 * n + 1, 0, 2 * n + 1);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d\", &c[i]);\n    g[i].resize(c[i]);\n    Max_flow::addedge(0, i, 1);\n    for (int j = 0; j < c[i]; j++) {\n      scanf(\"%d\", &g[i][j]);\n      bel[g[i][j]].push_back(i);\n      Max_flow::addedge(i, g[i][j] + n, 1);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    Max_flow::addedge(i + n, 2 * n + 1, 1);\n  }\n  if (Max_flow::max_flow() != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (Edge e : Max_flow::E) {\n    if (e.u <= n && e.v > n && e.cap == e.flow) {\n      p[e.u] = e.v - n;\n      vis[e.v - n] = 1;\n    }\n  }\n  queue<int> tmp;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) tmp.push(i);\n    vis[i] = 0;\n  }\n  int cnt = 0;\n  while (tmp.size()) {\n    cnt++;\n    int u = tmp.front(); tmp.pop();\n    for (int i : bel[u]) if (!vis[i]) {\n      vis[i] = 1;\n      q[i] = u;\n      tmp.push(p[i]);\n    }\n  }\n  if (cnt != n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", p[i], q[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nbitset<maxn> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    auto o = (q[x] & q[y]);\n    for (int i = o._Find_first(); i < o.size(); i = o._Find_next(i)) {\n        g.erase({d[i], i});\n        d[i]--;\n        g.insert({d[i], i});\n    }\n    q[x] |= q[y];\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (w != tos) {\n                y = i;\n                break;\n            }\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 2333333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //不能直接判f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t}\n\tfor(int i=n-1;i>=0;--i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n/*\nstruct E {\n    int to, rev, cap;\n};\nVV<E> g;\nauto add_edge = [&](int from, int to, int cap) {\n    g[from].push_back(E{to, int(g[to].size()), cap});\n    g[to].push_back(E{from, int(g[from].size())-1, 0});\n};\n*/\n\ntemplate<class C>\nstruct MaxFlow {\n    C flow;\n    V<char> dual;  // false: S-side true: T-side\n};\n\ntemplate<class C, class E>\nstruct MFExec {\n    static constexpr C INF = numeric_limits<C>::max();\n    C eps;\n    VV<E>& g;\n    int s, t;\n    V<int> level, iter;\n\n    C dfs(int v, C f) {\n        if (v == t) return f;\n        C res = 0;\n        for (int& i = iter[v]; i < int(g[v].size()); i++) {\n            E& e = g[v][i];\n            if (e.cap <= eps || level[v] >= level[e.to]) continue;\n            C d = dfs(e.to, min(f, e.cap));\n            e.cap -= d;\n            g[e.to][e.rev].cap += d;\n            res += d;\n            f -= d;\n            if (f == 0) break;\n        }\n        return res;\n    }\n\n    MaxFlow<C> info;\n    MFExec(VV<E>& _g, int _s, int _t, C _eps)\n            : eps(_eps), g(_g), s(_s), t(_t) {\n        int N = int(g.size());\n\n        C& flow = (info.flow = 0);\n        while (true) {\n            queue<int> que;\n            level = V<int>(N, -1);\n            level[s] = 0;\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front(); que.pop();\n                for (E e: g[v]) {\n                    if (e.cap <= eps || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n            if (level[t] == -1) break;\n            iter = V<int>(N, 0);\n            while (true) {\n                C f = dfs(s, INF);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        for (int i = 0; i < N; i++) info.dual.push_back(level[i] == -1);\n    }\n};\n\ntemplate<class C, class E>\nMaxFlow<C> get_mf(VV<E>& g, int s, int t, C eps) {\n    return MFExec<C, E>(g, s, t, eps).info;\n}\n\nvoid imp() {\n    cout << -1 << endl;\n    exit(0);\n}\n\nstruct E {\n    int to, rev, cap;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    int n;\n    cin >> n;\n    int v = n + n - 1 + 2;\n    VV<E> g(v);\n    int sv = n + n - 1, tv = sv + 1;\n\n    auto add_edge = [&](int from, int to, int cap) {\n        g[from].push_back(E{to, int(g[to].size()), cap});\n        g[to].push_back(E{from, int(g[from].size())-1, 0});\n    };\n\n    for (int i = 0; i < n-1; i++) {\n        add_edge(sv, i, 1);\n    }\n    for (int i = 0; i < n; i++) {\n        add_edge(n - 1 + i, tv, 1);\n    }\n\n    for (int i = 0; i < n-1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x; x--;\n            add_edge(i, n - 1 + x, 1);\n        }\n    }\n    auto mf = get_mf<int>(g, sv, tv, 0);\n    if (mf.flow != n-1) imp();\n\n    V<int> mt1(n - 1, -1), mt2(n - 1, -1);\n    VV<int> g2(v);\n    auto add_e2 = [&](int s, int t) {\n        //cerr << \"E2 \" << s << \" -> \" << t << endl;\n        g2[s].push_back(t);\n    };\n    for (int i = n - 1; i < n + n - 1; i++) {\n        for (auto e: g[i]) {\n            if (e.to < n - 1) {\n                if (e.cap) {\n                    mt1[e.to] = i - (n - 1);\n                    add_e2(e.to, i);\n                } else {\n                    add_e2(i, e.to);\n                }\n            } else if (e.to == tv) {\n                if (e.cap) {\n                    cerr << \"FIND Unused : \" << i - (n - 1) << endl;\n                    add_e2(tv, i);\n                }\n            } else assert(false);\n        }\n    }\n\n    V<int> prev(v, -1);\n    queue<int> q;\n    q.push(tv);\n    prev[tv] = -2;\n    while (!q.empty()) {\n        int p = q.front(); q.pop();\n        for (int d: g2[p]) {\n            if (prev[d] != -1) continue;\n            prev[d] = p;\n            q.push(d);\n        }\n    }\n    for (int i = 0; i < n - 1; i++) {\n        if (prev[i] == -1) imp();\n        mt2[i] = prev[i] - (n - 1);\n        cout << mt1[i] + 1 << \" \" << mt2[i] + 1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) {\n\t\t\t\twrite(i), putchar(' ');\n\t\t\t\twrite(par[par[i]]), putchar('\\n');\n\t\t\t} \n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F> struct dinic {\n    static constexpr F inf = numeric_limits<F>::has_infinity ?\n        numeric_limits<F>::infinity() : numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return { res, flow };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    int src = 0, snk = 2 * N;\n    dinic<int> g(2 * N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        g.arc(src, i, 1);\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        g.arc(N + i, snk, 1);\n\n        int sz, w;\n        cin >> sz;\n        for (int j = 0; j < sz; j++) {\n            cin >> w;\n            g.arc(w, N + i, 1);\n        }\n    }\n\n    auto max_flow = g.max_flow(src, snk);\n    int F = get<0>(max_flow);\n    vi flow = get<1>(max_flow);\n\n    if (F != N - 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int root;\n    for (int e : g.adj[src]) {\n        if (flow[e] == 0) {\n            root = g.dest[e];\n            break;\n        }\n    }\n\n    vi vis(g.V);\n    vis[src] = -1;\n    vis[snk] = -1;\n    vis[root] = root;\n\n    queue<int> bfs({ root });\n    while (!bfs.empty()) {\n        int loc = bfs.front();\n        bfs.pop();\n        for (int e : g.adj[loc]) {\n            if (!vis[g.dest[e]] && (loc > N && flow[e] == -1 || loc <= N && flow[e] == 0)) {\n                vis[g.dest[e]] = loc;\n                bfs.push(g.dest[e]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> res(N - 1);\n    for (int i = 1; i <= N; i++) {\n        if (i == root) continue;\n        if (!vis[i]) { cout << -1 << endl; return 0; }\n        res[vis[i] - N - 1] = { i, vis[vis[i]] };\n    }\n\n    for (auto e : res) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 1, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tif(Dinic() != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; bl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nvector<int> adj[MaxN];\nint N;\nbool visited[MaxN];\nint match_left[MaxN], match_right[MaxN];\nVI rev_adj[MaxN];\n\nbool DfsMatch(int v) {\n  if (visited[v]) { return false; }\n  visited[v] = true;\n  for (int s : adj[v]) {\n    if (match_right[s] == -1 || DfsMatch(match_right[s])) {\n      match_right[s] = v;\n      match_left[v] = s;\n      return true;\n    }\n  }\n  return false;\n}\n\nint Matching() {\n  fill_n(match_left, N, -1);\n  fill_n(match_right, N, -1);\n  int size = 0;\n  bool has_incr;\n  do {\n    has_incr = false;\n    fill_n(visited, N, false);\n    for (int i = 0; i < N; ++i)\n      if (match_left[i] == -1 && !visited[i] && DfsMatch(i)) {\n        ++size;\n        has_incr = true;\n      }\n  } while (has_incr);\n  return size;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  for (int i = 1; i <= N - 1; ++i) {\n    int sz;\n    cin >> sz;\n    for (int j = 0; j < sz; ++j) {\n      int v; cin >> v;\n      --v;\n      adj[i].PB(v);\n      rev_adj[v].PB(i);\n    }\n    adj[0].PB(i - 1);\n  }\n\n  if (Matching() != N) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  for (int i = 0; i < N; ++i)\n    debug(i, match_left[i]);\n\n  vector<PII> edges(N - 1);\n  int num_edges = 0;\n  queue<int> Q;\n  vector<bool> vis_set(N);\n  vector<bool> vis_vert(N);\n\n  Q.push(match_left[0]);\n  vis_set[0] = true;\n  vis_vert[match_left[0]] = true;\n\n  while (!Q.empty()) {\n    const int v = Q.front();\n    Q.pop();\n\n    for (int set_id : rev_adj[v]) {\n      if (vis_set[set_id]) { continue; }\n      vis_set[set_id] = true;\n      const int s = match_left[set_id];\n      assert(!vis_vert[s]);\n      vis_vert[s] = true;\n      debug(set_id, v, s);\n      edges[set_id - 1] = make_pair(v, s);\n      ++num_edges;\n      Q.push(s);\n    }\n  }\n\n  if (num_edges != N - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  for (auto &edge : edges)\n    cout << edge.st + 1 << \" \" << edge.nd + 1 << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define SZ 2333333\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define ad_de ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n;\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n#define mp make_pair\nvector<int> t[SZ],g[SZ],vv[SZ];\npii ans[SZ];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b),\n\t\t\tvv[b].pb(i);\n\t\tsort(t[i].begin(),t[i].end());\n\t}\n\tset<int> v; v.insert(1);\n\tvector<int> u; u.pb(1);\n\tset<int> done;\n\tN=n+n+2; S=N-1; T=N;\n\twhile(done.size()<n-1)\n\t{\n\t\tint s=done.size();\n\t\tset<int> iq;\n\t\tset<int> NS;\n\t\tNS.insert(S); NS.insert(T);\n\t\tfor(auto g:u)\n\t\t\tfor(auto h:vv[g])\n\t\t\t{\n\t\t\t\tif(done.count(h)) continue;\n\t\t\t\tiq.insert(h);\n\t\t\t}\n\t\tif(!iq.size())\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tmap<pii,int> tmp;\n\t\tstatic int GS[SZ];\n\t\tfor(auto h:iq)\n\t\t{\n\t\t\tint cn=0,gs=0;\n\t\t\tfor(auto w:t[h])\n\t\t\t\tif(v.count(w)) gs=w;\n\t\t\tGS[h]=gs;\n\t\t\tfor(auto w:t[h])\n\t\t\t\tif(!v.count(w))\n\t\t\t\t{\n\t\t\t\t\tif(!NS.count(w))\n\t\t\t\t\t\tNS.insert(w),\n\t\t\t\t\t\tad_de(S,w,1);\n\t\t\t\t\t++cn; ad_de(w,h+n,1);\n\t\t\t\t\ttmp[pii(h,w)]=M;\n\t\t\t\t}\n\t\t\tad_de(h+n,T,1);\n\t\t\tNS.insert(h+n);\n\t\t}\n\t\tu.clear(); \n\t\tint ss=dinic();\n\t\tfor(auto h:iq)\n\t\t{\n\t\t\tint okk=0;\n\t\t\tfor(auto w:t[h])\n\t\t\t\tif(!v.count(w)&&cap[tmp[pii(h,w)]])\n\t\t\t\t{\n\t\t\t\t\tdone.insert(h); okk=1;\n\t\t\t\t\tans[h]=pii(GS[h],w);\n\t\t\t\t}\n\t\t\tif(!okk)\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tM=1;\n\t\tfor(auto t:NS) fst[t]=0;\n\t\tfor(auto h:iq) v.insert(ans[h].se),u.pb(ans[h].se);\n\t\tif(done.size()==s)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nint n,S,T,d[100010],ans,a[100010],b[100010];\nvector<int> v[100010];\nint cnt=1,head[200010],to[800010],nxt[800010],w[800010];\nbool used[100010];\nvoid add(int x,int y,int z)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n\tw[cnt]=z;\n}\nvoid ins(int x,int y,int z)\n{\n\tadd(x,y,z);\n\tadd(y,x,0);\n}\nbool bfs()\n{\n\tfor (int i=S;i<=T;i++)\n\t{\n\t\td[i]=-1;\n\t}\n\tqueue<int> q;\n\td[S]=0;\n\tq.push(S);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tif (x==T)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif (w[i] && d[y]==-1)\n\t\t\t{\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x,int f)\n{\n\tint res=0;\n\tif (x==T)\n\t{\n\t\treturn f;\n\t}\n\tfor (int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif (w[i] && d[y]==d[x]+1)\n\t\t{\n\t\t\tint tmp=dfs(y,min(f-res,w[i]));\n\t\t\tw[i]-=tmp;\n\t\t\tw[i^1]+=tmp;\n\t\t\tres+=tmp;\n\t\t\tif (res==f)\n\t\t\t{\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\tif (!res)\n\t{\n\t\td[x]=-1;\n\t}\n\treturn res;\n}\nvoid dinic()\n{\n\twhile (bfs())\n\t{\n\t\tans+=dfs(S,inf);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tS=1;\n\tT=2*n;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tif (x!=1)\n\t\t\t{\n\t\t\t\tins(x,n+i,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tins(S,i,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tins(n+i,T,1);\n\t}\n\tdinic();\n\tif (ans!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=n+1;i<2*n;i++)\n\t{\n\t\tfor (int j=head[i];j;j=nxt[j])\n\t\t{\n\t\t\tif (!w[j])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i-n]=to[j];\n\t\t}\n\t}\n\tqueue<int> q;\n\tused[1]=true;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=0;i<v[x].size();i++)\n\t\t{\n\t\t\tint y=v[x][i];\n\t\t\tif (!used[a[y]])\n\t\t\t{\n\t\t\t\tused[a[y]]=true;\n\t\t\t\tq.push(a[y]);\n\t\t\t\tb[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tbool f=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tf&=used[i];\n\t}\n\tif (!f)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",a[i],b[i]);\n\t}\n\treturn 0;\n}\n//霓为衣兮风为马，云之君兮纷纷而来下。\n//——李白《梦游天姥吟留别》"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nstruct edge{\n\tint y,next,c;\n}s[N<<4];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[st]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tif(t==tot) break;\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t}\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(c[P[c[x]][i]]!=c[x] && !las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2+N*4];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N*2],BZ,dis[N*2];\nEDGE *cur[N*2];\n#define rev(ei) (e+(int((ei)-e)^1))\nbool getdis(){\n\tstatic int q[N*2];\n\tmemcpy(cur,last,sizeof(EDGE*)*(T+1));\n\tmemset(dis,0,sizeof(int)*(T+1));\n\tdis[S]=1;\n\tq[1]=S;\n\tint head=1,tail=1;\n\twhile (head<=tail){\n\t\tint x=q[head++];\n\t\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\t\tif (ei->c && !dis[ei->to]){\n\t\t\t\tdis[ei->to]=dis[x]+1;\n\t\t\t\tq[++tail]=ei->to;\n\t\t\t}\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]==dis[x]+1){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (getdis()){\n\t\tint tmp;\n\t\tdo{\n\t\t\ttmp=dfs(S,INF);\n\t\t\tr+=tmp;\n\t\t}\n\t\twhile (tmp);\n\t}\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define inf 1<<30\n#define sqr(x) ((x)*(x))\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next,f;\n}e[N*10];\nint head[N*2],tot=1,S,T;\nint dis[N*2],q[N*2];\nvoid add(int x,int y,int v){\n\te[++tot]=(edge){y,head[x],v};\n\thead[x]=tot;\n\te[++tot]=(edge){x,head[y],0};\n\thead[y]=tot;\n}\nbool bfs(){\n\tFor(i,1,T) dis[i]=-1;\n\tq[0]=1; q[1]=S; dis[S]=1;\n\tFor(h,1,q[0])\n\t\tfor (int i=head[q[h]];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]==-1&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[q[h]]+1;\n\t\t\t\tif (e[i].to==T) return 1;\n\t\t\t\tq[++q[0]]=e[i].to;\n\t\t\t}\n\treturn 0;\n}\nint dfs(int x,int flow){\n\tif (x==T) return flow;\n\tint k,rest=flow;\n\tfor (int i=head[x];i&&rest;i=e[i].next)\n\t\tif (dis[e[i].to]==dis[x]+1&&e[i].f){\n\t\t\tk=dfs(e[i].to,min(rest,e[i].f));\n\t\t\te[i].f-=k; e[i^1].f+=k; rest-=k;\n\t\t}\n\tif (rest) dis[x]=-1;\n\treturn flow-rest;\n}\nvector<int> v[N],V[N];\nint cnt,n;\nint fa[N],mat[N];\nbool vis[N];\nvoid dfs(int x){\n\t++cnt; vis[x]=1;\n\tfor (auto i:V[x])\n\t\tif (!vis[mat[i]]){\n\t\t\tfa[i]=x;\n\t\t\tdfs(mat[i]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=2*n; T=2*n+1;\n\tFor(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tv[i].resize(cnt);\n\t\tFor(j,0,cnt-1){\n\t\t\tscanf(\"%d\",&v[i][j]);\n\t\t\tif (v[i][j]!=1)\n\t\t\t\tadd(i+n,v[i][j],1);\n\t\t\tV[v[i][j]].PB(i);\n\t\t}\n\t}\n\tFor(i,2,n)\n\t\tadd(i,T,1);\n\tint flow=0;\n\tfor (;bfs();flow+=dfs(S,inf));\n\tif (flow!=n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tfor (int j=head[i+n];j;j=e[j].next)\n\t\t\tif (e[j].to<S&&!e[j].f)\n\t\t\t\tmat[i]=e[j].to;\n\tdfs(1);\n\tif (cnt!=n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",mat[i],fa[i]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i]);\n    }\n    queue < int > q;\n    q.push(n);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 800008\n#define N 200002\nint A[N],B[M],C[M],F[M],S,T,a[N],b[M],c[M],e[N],h[N],l,n,q[N],r,t;bool D[M],d[M];\ninline void add(int u,int v){b[++t]=a[u],c[a[u]=t]=v,d[t]=true,b[++t]=a[v],c[a[v]=t]=u;}\ninline bool bfs()\n{\n\tmemset(h+1,-1,T<<2),*h=l=0,*q=S,r=1;\n\twhile(l<r)for(int u=q[l++],i=a[u];i;i=b[i])if(d[i]&&h[c[i]]<0)h[q[r++]=c[i]]=h[u]+1;\n\treturn h[T]>=0;\n}\nbool dfs(int u)\n{\n\tif(u==T)return true;\n\tfor(int&i=e[u];i;i=b[i])if(d[i]&&dfs(c[i]))return d[i]=false,d[i^1]=true;\n\treturn false; \n}\nvoid ans(int u)\n{\n\tD[u]=true;\n\tfor(int&i=A[u];i;i=B[i])if(!D[C[i]])t++,F[C[i]]=u,ans(C[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n),T=n<<1;\n\tfor(int i=t=1,u,v;i<n;i++)for(scanf(\"%d\",&u);u--;)scanf(\"%d\",&v),add(n+i,v);\n\tfor(int i=2;i<=n;i++)add(i,T);\n\tfor(int i=1;i<n;i++)add(S,n+i);\n\tfor(t=0;bfs();)for(memcpy(e,a,T+1<<2);dfs(S);t++);\n\tif(t!=n-1)return 0*puts(\"-1\");\n\tfor(int i=2;i<=n;i++)while(a[i]=b[a[i]])if(d[a[i]])e[c[a[i]]-n]=i;\n\tfor(int i=t=1;i<n;i++)while(a[n+i]=b[a[n+i]])if(d[a[n+i]])B[++t]=A[c[a[n+i]]],C[A[c[a[n+i]]]=t]=e[i];\n\tif(t=0,ans(1),t!=n-1)return 0*puts(\"-1\");\n\telse for(int i=1;i<n;i++)printf(\"%d %d\\n\",F[e[i]],e[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, c, u;\n\nvector<int> edge[216000];\nvector<int> ans[216000];\nbool come[216000];\n\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tedge[i].push_back(n + u);\n\t\t\tedge[n+u].push_back(i);\n\t\t}\t\n\t}\n\tdfs(n+1);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(root);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\n\nnamespace flow {\nstruct edge_t {\n  int to, cap, rev;\n\n  edge_t(int t, int c, int r) {\n    to = t;\n    cap = c;\n    rev = r;\n  }\n};\n\nint n, source, sink, answer;\nvector<vector<edge_t>> adj;\nvector<int> dist, current;\n\nvoid init(int v, int s, int t) {\n  n = v;\n  source = s;\n  sink = t;\n  answer = 0;\n  adj.clear();\n  adj.resize(n);\n  dist.resize(n);\n  current.resize(n);\n}\n\nvoid add(int x, int y, int c) {\n  adj[x].push_back(edge_t(y, c, adj[y].size()));\n  adj[y].push_back(edge_t(x, 0, adj[x].size() - 1));\n}\n\nbool bfs() {\n  queue<int> q;\n  for (int i = 0; i < n; ++i) {\n    dist[i] = -1;\n  }\n  dist[source] = 0;\n  q.push(source);\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto e : adj[x]) {\n      if (e.cap && !~dist[e.to]) {\n        dist[e.to] = dist[x] + 1;\n        if (e.to == sink) {\n          return true;\n        }\n        q.push(e.to);\n      }\n    }\n  }\n  return false;\n}\n\nint dfs(int x, int f) {\n  if (x == sink) {\n    return f;\n  }\n  for (int &i = current[x]; ~i; --i) {\n    edge_t &e = adj[x][i];\n    if (e.cap && dist[e.to] == dist[x] + 1) {\n      int w = dfs(e.to, min(e.cap, f));\n      if (w) {\n        e.cap -= w;\n        adj[e.to][e.rev].cap += w;\n        return w;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow() {\n  while (bfs()) {\n    for (int i = 0; i < n; ++i) {\n      current[i] = adj[i].size() - 1;\n    }\n    while (true) {\n      int flow = dfs(source, inf);\n      if (!flow) {\n        break;\n      }\n      answer += flow;\n    }\n  }\n  return answer;\n}\n}\n\nusing flow::source;\nusing flow::sink;\nusing flow::init;\nusing flow::add;\nusing flow::adj;\nusing flow::max_flow;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  scanf(\"%d\", &n);\n  vector<vector<int>> a(n - 1);\n  vector<vector<int>> v(n);\n  init(n * 2, n * 2 - 2, n * 2 - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    int s;\n    scanf(\"%d\", &s);\n    a[i].resize(s);\n    add(source, i, 1);\n    for (int j = 0; j < s; ++j) {\n      scanf(\"%d\", &a[i][j]);\n      --a[i][j];\n      v[a[i][j]].push_back(i);\n      if (a[i][j]) {\n        add(i, a[i][j] - 1 + n - 1, 1);\n      }\n    }\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    add(i + n - 1, sink, 1);\n  }\n  if (max_flow() != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  vector<int> match(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (auto e : adj[i]) {\n      if (e.to < n * 2 - 2 && !e.cap) {\n        match[i] = e.to - (n - 1) + 1;\n      }\n    }\n  }\n  vector<bool> visit(n);\n  vector<int> parent(n - 1);\n  int cc = 0;\n  function<void(int)> insert = [&](int x) {\n    ++cc;\n    visit[x] = true;\n    for (auto i : v[x]) {\n      if (!visit[match[i]]) {\n        parent[i] = x;\n        insert(match[i]);\n      }\n    }\n  };\n  insert(0);\n  if (cc != n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    printf(\"%d %d\\n\", match[i] + 1, parent[i] + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, M = 200005, inf = 0x3f3f3f3f;\nint n, p[N], fa[N];\nvector<int> E[N], F[N];\n\nnamespace flow {\n\tconst int V = 2 * N, E = 2 * (M + 2 * N);\n\tint ans, S, T, tot = 1, nxt[E], fst[V], to[E], f[E], cur[V], d[V];\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; f[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; f[tot] = 0;\n\t}\n\tbool bfs() {\n\t\tstatic int q[E];\n\t\tint st = 0, ed = 0;\n\t\tq[ed++] = S;\n\t\tfor (int i = 1; i <= T; i++) d[i] = -1, cur[i] = fst[i];\n\t\td[S] = 0;\n\t\twhile (st < ed) {\n\t\t\tint u = q[st++];\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (f[i] && d[to[i]] == -1) {\n\t\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\t\tif (to[i] == T) return true;\n\t\t\t\t\tq[ed++] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint aug(int u, int flow) {\n\t\tif (u == T || !flow) return flow;\n\t\tint used = 0;\n\t\tfor (int &i = cur[u], w; i; i = nxt[i])\n\t\t\tif (d[to[i]] == d[u] + 1 && (w = aug(to[i], min(f[i], flow - used)))) {\n\t\t\t\tf[i] -= w, f[i ^ 1] += w;\n\t\t\t\tif ((used += w) == flow) break;\n\t\t\t}\n\t\tif (!used) d[u] = -1;\n\t\treturn used;\n\t}\n\tint dinic() {\n\t\twhile (bfs()) ans += aug(S, inf);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs(int u) {\n\tfor (int v : F[u])\n\t\tif (!fa[p[v]]) {\n\t\t\tfa[p[v]] = u;\n\t\t\tdfs(p[v]);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tflow::S = 2 * (n - 1) + 1, flow::T = 2 * (n - 1) + 2;\n\tfor (int i = 1, k; i < n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tE[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tscanf(\"%d\", &E[i][j]);\n\t\t\tif (E[i][j] != n)\n\t\t\t\tflow::addedge(E[i][j], n - 1 + i, 1);\n\t\t\tF[E[i][j]].push_back(i);\n\t\t}\n\t\tflow::addedge(flow::S, i, 1);\n\t\tflow::addedge(n - 1 + i, flow::T, 1);\n\t}\n\tint x = flow::dinic();\n\tif (x != n - 1) return !puts(\"-1\");\n\tfor (int i = 2; i <= flow::tot; i += 2)\n\t\tif (!flow::f[i] && flow::to[i] != flow::T && flow::to[i ^ 1] != flow::S)\n\t\t\tp[flow::to[i] - n + 1] = flow::to[i ^ 1];\n\tfa[n] = -1, dfs(n);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!fa[i]) return !puts(\"-1\");\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", fa[p[i]], p[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\nreturn printf(\"-1\"), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint n,S,T,fir[200010],head[200010],dep[200010],dis[1000010],nxt[1000010],w[1000010],id=1;\nvoid link(int a,int b,int c){\n\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c;\n\tnxt[++id]=fir[b],fir[b]=id,dis[id]=a,w[id]=0;\n}\nint que[200010],hd,tl,el[100010];\nstd::vector<pr>E[100010];\nbool BFS(){\n\thd=tl=0;memset(dep,0,sizeof dep);\n\tdep[S]=1;que[tl++]=S;\n\twhile(hd^tl){\n\t\tint x=que[hd++];\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t\tif(w[i]&&!dep[dis[i]])\n\t\t\t\tdep[dis[i]]=dep[x]+1,que[tl++]=dis[i];\n\t}\n\treturn dep[T];\n}\nint Dinic(int x,int maxflow){\n\tif(x==T)return maxflow;\n\tint ret=0;\n\tfor(int&i=head[x];i;i=nxt[i])\n\t\tif(w[i]&&dep[dis[i]]==dep[x]+1){\n\t\t\tint d=Dinic(dis[i],std::min(maxflow-ret,w[i]));\n\t\t\tw[i]-=d,w[i^1]+=d,ret+=d;if(ret==maxflow)break;\n\t\t}\n\treturn ret;\n}\nint match[100010],fa[100010],set[1000010];\nint ax[100010],ay[100010];\nvoid DFS(int x){\n\tfor(int i=fir[x];i;i=nxt[i])\n\t\tif(w[i]&&dis[i]!=S&&!fa[match[dis[i]-n]]){\n\t\t\tfa[match[dis[i]-n]]=x;\n\t\t\tset[match[dis[i]-n]]=dis[i]-n;\n\t\t\tDFS(match[dis[i]-n]);\n\t\t}\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi();\n\tfor(int i=1;i<n;++i){\n\t\tint o=gi(),x;E[i].resize(o);\n\t\tfor(int j=0;j<o;++j)link(x=gi(),i+n,1),E[i][j]={id,x};\n\t}\n\tS=n+n,T=n+n+1;\n\tfor(int i=1;i<=n;++i)link(S,i,1),el[i]=id;\n\tfor(int i=n+1;i<n+n;++i)link(i,T,1);\n\tint flow=0;\n\twhile(BFS())memcpy(head,fir,sizeof head),flow+=Dinic(S,1e9);\n\tif(flow<n-1)puts(\"-1\"),exit(0);\n\tint r=0;\n\tfor(int i=1;i<=n;++i)if(!w[el[i]])r=i;\n\tfor(int i=1;i<n;++i)for(pr j:E[i])if(w[j.fi])match[i]=j.se;\n\tfa[r]=-1;DFS(r);\n\tint cnt=0;for(int i=1;i<=n;++i)cnt+=!!fa[i];\n\tif(cnt<n)puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;++i)if(~fa[i])ax[set[i]]=i,ay[set[i]]=fa[i];\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ax[i],ay[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        printf(\"%d %d\\n\",u,v);\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]),g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace flow{\n\tconst int _ = 1e6 + 7 , __ = 1e7 + 7;\n\tstruct Edge{int end , upEd , f;}Ed[__];\n\tint head[_] , dep[_] , cur[_] , cntEd = 1 , S , T;\n\n\tvoid addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}\n\tvoid addE(int a , int b , int c){addEd(a , b , c); addEd(b , a , 0);}\n\t\n\tqueue < int > q;\n\tbool bfs(){\n\t\tmemset(dep , 0 , sizeof(int) * (T + 1)); while(!q.empty()) q.pop();\n\t\tdep[S] = 1; q.push(S);\n\t\twhile(!q.empty()){\n\t\t\tint t = q.front(); q.pop();\n\t\t\tfor(int i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && !dep[Ed[i].end]){\n\t\t\t\t\tdep[Ed[i].end] = dep[t] + 1;\n\t\t\t\t\tif(Ed[i].end == T){memcpy(cur , head , sizeof(int) * (T + 1)); return 1;}\n\t\t\t\t\tq.push(Ed[i].end);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dfs(int x , int mn){\n\t\tif(x == T) return mn;\n\t\tint sum = 0;\n\t\tfor(int &i = cur[x] ; i ; i = Ed[i].upEd)\n\t\t\tif(Ed[i].f && dep[Ed[i].end] == dep[x] + 1){\n\t\t\t\tint t = dfs(Ed[i].end , min(mn - sum , Ed[i].f));\n\t\t\t\tsum += t; Ed[i].f -= t; Ed[i ^ 1].f += t;\n\t\t\t\tif(sum == mn) break;\n\t\t\t}\n\t\treturn sum;\n\t}\n\n\tint Dinic(int s , int t){int sum = 0; S = s; T = t; while(bfs()) sum += dfs(s , 1e9); return sum;}\n}using namespace flow;\n\nint read(){\n\tint a = 0; char c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();}\n\treturn a;\n}\n\nint N , pos[200003] , E[200003][2]; vector < int > id[200003];\n\nint main(){\n\tN = read();\n\tfor(int i = 2 ; i <= N ; ++i) addE(0 , i , 1);\n\tfor(int i = 1 ; i < N ; ++i){\n\t\taddE(N + i , N + N , 1);\n\t\tfor(int p , x = read() ; x ; --x){addE(p = read() , i + N , 1); id[p].push_back(i);}\n\t}\n\tif(Dinic(0 , N + N) != N - 1){puts(\"-1\"); return 0;}\n\tfor(int i = 2 ; i <= N ; ++i)\n\t\tfor(int j = head[i] ; j ; j = Ed[j].upEd)\n\t\t\tif(Ed[j].end > N && !Ed[j].f){pos[Ed[j].end - N] = i; break;}\n\tqueue < int > q; q.push(1);\n\twhile(!q.empty()){\n\t\tint t = q.front(); q.pop();\n\t\tfor(auto x : id[t]) if(pos[x]){E[x][0] = t; E[x][1] = pos[x]; q.push(pos[x]); pos[x] = 0;}\n\t}\n\tfor(int i = 1 ; i < N ; ++i) printf(\"%d %d\\n\" , E[i][0] , E[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nvector<int> E[N],in[N];\nnamespace Graph{\n\tconst int inf = 1e9;\n\tvector<pair<int,int> > ans;\n\tint n,tot,t,head[N],b[N],vis[N],cur[N];\n\tstruct edge{int v,nxt,f;}e[N*4];\n\tvoid init(int m){\n\t\tn=m;t=2*n+1;tot=1;\n\t}\n\tvoid add(int x,int y,int z){\n\t\te[++tot]={y,head[x],z};\n\t\thead[x]=tot;\n\t\te[++tot]={x,head[y],0};\n\t\thead[y]=tot;\n\t}\n\tbool bfs(){\n\t\tmemset(b,0,sizeof(b));b[0]=1;\n\t\tqueue<int> q;q.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&!b[e[i].v]){\n\t\t\t\t\tb[e[i].v]=b[u]+1;\n\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t}\n\t\t}\n\t\treturn b[t];\n\t}\n\tint dfs(int x,int flow){\n\t\tif(!flow||x==t) return flow;\n\t\tint f=flow,tmp;\n\t\tfor(int &i=cur[x];i;i=e[i].nxt)\n\t\t\tif(b[e[i].v]==b[x]+1&&(tmp=dfs(e[i].v,min(e[i].f,f)))){\n\t\t\t\tf-=tmp;e[i].f-=tmp;e[i^1].f+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\treturn flow-f;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tans+=dfs(0,inf);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(int x){\n\t\tvis[x]=1;\n\t\tvector<int> v;\n\t\tfor(int p:in[x])\n\t\t\tfor(int i=head[p+n];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&e[i].v!=t) v.push_back(e[i].v);\n\t\tfor(int p:v) if(!vis[p]){\n\t\t\tans.emplace_back(x,p);\n\t\t\tsolve(p);\n\t\t}\n\t}\n\tvoid print(){\n\t\tif(ans.size()!=n-1){puts(\"-1\");return;}\n\t\tfor(auto&pr:ans)\n\t\t\tprintf(\"%d %d\\n\",pr.first,pr.second);\n\t}\n}\nint n;\nint main(){\n\tread(n);\n\tGraph::init(n);\n\tfor(int i=1;i<n;i++){\n\t\tint k;read(k);\n\t\twhile(k--){\n\t\t\tint x;read(x);\n\t\t\tE[i].push_back(x);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int x:in[i]) Graph::add(i,x+n,1);\n\t\tGraph::add(0,i,1);\n\t}\n\tfor(int i=1;i<n;i++) Graph::add(i+n,Graph::t,1);\n\tif(Graph::Dinic()<n-1){puts(\"-1\");return 0;}\n\tGraph::solve(1);\n\tGraph::print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace max_flow {\n\nconst int max_v = 200222, inf = 1000111222;\n\nstruct edge {\n    int to, residual_capacity;\n\n    edge(int to, int residual_capacity): to(to), residual_capacity(residual_capacity) {\n    }\n};\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid add_edge(int u, int v, int capacity) {\n    g[u].push_back(edges.size());\n    edges.push_back({v, capacity});\n    g[v].push_back(edges.size());\n    edges.push_back({u, 0});\n}\n\nint h[max_v], num[max_v];\n\nbool bfs(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        h[i] = -1;\n    }\n    h[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int id : g[v]) {\n            if (edges[id].residual_capacity && h[edges[id].to] == -1) {\n                h[edges[id].to] = h[v] + 1;\n                q.push(edges[id].to);\n            }\n        }\n    }\n    return h[t] != -1;\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) {\n        return f;\n    }\n    for (int &i = num[v]; i < g[v].size(); ++i) {\n        const int id = g[v][i];\n        if (edges[id].residual_capacity && h[v] + 1 == h[edges[id].to]) {\n            int res = dfs(edges[id].to, t, min(f, edges[id].residual_capacity));\n            if (res) {\n                edges[id].residual_capacity -= res;\n                edges[id ^ 1].residual_capacity += res;\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(int s, int t) {\n    int res = 0;\n    while (bfs(s, t)) {\n        memset(num, 0, sizeof(num));\n        while (int f = dfs(s, t, inf)) {\n            res += f;\n        }\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], ans[max_n], used[max_n];\nvector<int> g[max_n], g2[max_n];\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    int s = 2 * n - 1, t = 2 * n;\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        max_flow::add_edge(s, i, 1);\n        for (int to : g[i]) {\n            max_flow::add_edge(i, n - 1 + to, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        max_flow::add_edge(n - 1 + i, t, 1);\n    }\n    int f = max_flow::dinic(s, t);\n    memset(p, -1, sizeof(p));\n    memset(nxt, -1, sizeof(nxt));\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int id : max_flow::g[i]) {\n            const auto &e = max_flow::edges[id];\n            if (e.to != s && e.residual_capacity == 0) {\n                nxt[i] = e.to - n + 1;\n                p[nxt[i]] = i;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) u[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (u[i]) q.push(u[i]), ++k, fa[getfa(g[k] = s)] = getfa(h[k] = u[i]), u[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 2e5+5;\n\ntypedef int Flow;\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\n\nstruct PushRelabel {\n\tvector<vector<Edge>> g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\n\nint n, m[MAXN], r[MAXN];\nvector<int> e[MAXN], g[MAXN];\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tPushRelabel mf(2*n+1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tmf.add_edge(0, i+1, 1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tmf.add_edge(i+1, x+n, 1);\n\tfor (int i = n; i < 2*n; ++i)\n\t\tmf.add_edge(i, 2*n, 1);\n\tint fl = mf.maxflow(0, 2*n);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tauto h = mf.g;\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 1) {\n\t\t\t\tm[i] = e.dest-n;\n\t\t\t\tr[e.dest-n] = i;\n\t\t\t\ts -= (e.dest - n);\n\t\t\t\t// cout << i << ' ' << m[i]+1 << endl;\n\t\t\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 0) {\n\t\t\t\t// cout << e.dest - n << ' ' << m[i] << endl;\n\t\t\t\tg[e.dest - n].push_back(m[i]);\n\t\t\t}\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nvoid cl(int i) {\n    set<int> o;\n    swap(o, q[i]);\n}\n\nvoid cel() {\n    set<pair<int, int> > o;\n    swap(g, o);\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++)\n        p[i] = i, r[i] = 0, cl(i);\n    cel();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < a[i].size(); j++)\n            q[a[i][j]].insert(i);\n        d[i] = a[i].size();\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            return;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n    exit(0);\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    double ts = clock();\n    cin >> n;\n    if (n > 1000)\n        exit(1);\n    return 0;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n    }\n    while ((clock() - ts) / CLOCKS_PER_SEC < 3.7) {\n        solve();\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < a[i].size(); j++)\n                swap(a[i][j], a[i][rnd() % (j + 1)]);\n    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,inf=1e9;\nint n,c,p[N],q[N];vector<int> a[N];\nstruct edge{int u,v,c,f;};\nstruct Dinic{\n    vector<edge> e;\n    vector<int> G[N];queue<int> q;\n    int cur[N],d[N],n,m,s,t;bool vis[N];\n    inline void add(int u,int v,int c){\n        //printf(\"%d %d %d\\n\",u,v,c);\n        e.pb((edge){u,v,c,0});e.pb((edge){v,u,0,0});\n        m=e.size();G[u].pb(m-2);G[v].pb(m-1);\n    }\n    bool bfs(){\n        memset(d,0,sizeof(d));memset(vis,0,sizeof(vis));vis[s]=1;q.push(s);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int &x:G[u]){\n                edge &E=e[x];\n                if(E.c>E.f&&!vis[E.v]) d[E.v]=d[u]+1,vis[E.v]=1,q.push(E.v);\n            }\n        }\n        return vis[t];\n    }\n    int dfs(int u,int a){\n        if(u==t||!a) return a;\n        int flow=0,f;\n        for(int &i=cur[u];i<(int)G[u].size();++i){\n            edge &E=e[G[u][i]];\n            if(d[E.v]==d[u]+1&&(f=dfs(E.v,min(a,E.c-E.f)))){\n                E.f+=f;e[G[u][i]^1].f-=f;\n                flow+=f;a-=f;if(!a) break;\n            }\n        }\n        return flow;\n    }\n    int max_flow(int s,int t){\n        this->s=s;this->t=t;\n        int flow=0;\n        while(bfs()){memset(cur,0,sizeof(cur));flow+=dfs(s,inf);}\n        return flow;\n    }\n}G,H;\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);int S=1,T=2*n+1;G.n=H.n=T;\n    rep(i,1,n-1) G.add(1,i+1,1),H.add(1,i+1,1);\n    rep(i,1,n-1){\n        scanf(\"%d\",&c);a[i].resize(c);\n        rep(j,0,c-1) scanf(\"%d\",&a[i][j]),G.add(i+1,a[i][j]+n,1);\n    }\n    rep(i,1,n-1) G.add(i+n,T,1);\n    rep(i,2,n) H.add(i+n,T,1);\n    int t=G.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    //puts(\"dsynb\");\n    rep(i,2,n){\n        for(int &x:G.G[i]){\n            edge &e=G.e[x];\n            if(e.v>1&&!e.f) H.add(i,e.v,1);\n            else p[i]=e.v-n;\n        }\n    }\n    t=H.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    rep(i,2,n){\n        for(int &x:H.G[i]){\n            edge &e=H.e[x];\n            if(e.v>1&&e.f) q[i]=e.v-n;\n        }\n    }\n    rep(i,2,n) printf(\"%d %d\\n\",p[i],q[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next,f;\n}e[N*10];\nint head[N*2],tot=1;\nint dis[N*2],q[N*2];\nint n,S,T,sum;\nint fa[N],mat[N],vis[N];\nvector<int> vec[N],adj[N];\nvoid add(int x,int y,int f){\n\te[++tot]=(edge){y,head[x],f};\n\thead[x]=tot;\n\te[++tot]=(edge){x,head[y],0};\n\thead[y]=tot;\n}\nbool bfs(){\n\tFor(i,1,T) dis[i]=-1;\n\tint h=0,t=1;\n\tq[1]=S; dis[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h];\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]==-1&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\t\tq[++t]=e[i].to;\n\t\t\t\tif (e[i].to==T) return 1;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int x,int flow){\n\tif (x==T) return flow;\n\tint k,rest=flow;\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (dis[e[i].to]==dis[x]+1&&e[i].f){\n\t\t\tk=dfs(e[i].to,min(rest,e[i].f));\n\t\t\te[i].f-=k; e[i^1].f+=k; rest-=k;\n\t\t}\n\tif (rest) dis[x]=-1;\n\treturn flow-rest;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor (auto i:vec[x])\n\t\tif (!vis[mat[i]]){\n\t\t\tfa[i]=x;\n\t\t\tdfs(mat[i]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=2*n; T=2*n+1;\n\tFor(i,1,n-1){\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tadd(n+i,T,1);\n\t\tFor(j,1,cnt){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tadd(x,n+i,1);\n\t\t\tvec[x].PB(i);\n\t\t\t//adj[i].PB(x);\n\t\t}\n\t}\n\tFor(i,2,n)\n\t\tadd(S,i,1);\n\tfor (;bfs();sum+=dfs(S,1<<30));\n\tif (sum!=n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tfor (int j=head[n+i];j;j=e[j].next)\n\t\t\tif (e[j].f==1&&e[j].to<=n)\n\t\t\t\tmat[i]=e[j].to;\n\tdfs(1);\n\tFor(i,1,n) if (!vis[i])\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nstruct edge{\n\tint y,next,c;\n}s[N<<3];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[st]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tif(t==tot) break;\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t}\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(c[P[c[x]][i]]!=c[x] && !las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\\n\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,M=800005,oo=1e9;\nstruct edge{\n\tint di,nxt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N];\nPI an[N];\ninline void aedge(int a,int b,int c){\n\te[++nedge].nxt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void ins(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=0;i<N;i++)deep[i]=oo;\n    for(int i=0;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nxt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nxt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\nint dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nvector<int> v[N>>1];\nint match[N>>1];\nint main(){\n\tint n=read(),s=n,t=n+1;\n\tFor(i,1,n-1){\n\t\tint c=read();\n\t\tins(s,i,1); ins(n+i+1,t,1);\n\t\tFor(j,1,c){int t=read(); v[t].pb(i); if(t>1)ins(i,t+n,1);}\n\t}\n\tint ans=dinic(s,t); \n\tif(ans!=n-1)GG();\n\tFor(i,1,n-1)for(int j=son[i];j;j=e[j].nxt)if(!e[j].di){match[i]=e[j].ed-n; break;}\n\tqueue<int> q; q.push(1);\n\twhile(q.size()){\n\t\tint t=q.front(); q.pop(); \n\t\tfor(auto i:v[t])if(match[i]){\n\t\t\tq.push(match[i]);  ans--;\n\t\t\tan[i]=mp(t,match[i]);\n\t\t\tmatch[i]=0;\n\t\t}\n\t}\n\tif(ans)GG();\n\tFor(i,1,n-1){wri(an[i].fi);writeln(an[i].se);}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5;\nint n, lk[maxn + 10], vis[maxn + 10], clk;\nint l[maxn + 10], r[maxn + 10];\nvector<int> g[maxn + 10];\n\nbool dfs(int p) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tif (!lk[e] || dfs(lk[e])) {\n\t\t\t\tlk[e] = p; return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid getans(int p, int lst) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (e != lst && vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tl[e] = p; r[e] = lk[e];\n\t\t\tgetans(lk[e], e);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint k; scanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\trandom_shuffle(g[i].begin(), g[i].end());\n\tfor (int i = 1; i < n; ++i) {\n\t\t++clk;\n\t\tif (!dfs(i)) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\t}\n\t++clk;\n\tgetans(n, 0); \n\tfor (int i = 1; i < n; ++i)\n\t\tif (!l[i]) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", l[i], r[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) u[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (u[i]) q.push(u[i]), fa[getfa(g[i] = s)] = getfa(h[i] = u[i]), u[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5;\nint n, lk[maxn + 10], vis[maxn + 10], clk;\nint l[maxn + 10], r[maxn + 10];\nvector<int> g[maxn + 10];\n\nbool dfs(int p) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tif (!lk[e] || dfs(lk[e])) {\n\t\t\t\tlk[e] = p; return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid getans(int p, int lst) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (e != lst && vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tl[e] = p; r[e] = lk[e];\n\t\t\tgetans(lk[e], e);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint k; scanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\t++clk;\n\t\tif (!dfs(i)) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\t}\n\t++clk;\n\tgetans(n, 0); \n\tfor (int i = 1; i < n; ++i)\n\t\tif (!l[i]) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", l[i], r[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tvis[v2[x][i]]=1;\n\t\tson[x].push_back(ma[v2[x][i]]);\n\t\tdfs(ma[v2[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200010\n#define M 1000010\n#define maxn 200010\n#define INF 2147483647\nusing namespace std;\nvector<int> node[maxn], pos[maxn];\nvector<pair<int, int> > res;\nint id[2][maxn], s = 1, t = 2, cnt = 2, head[N], nxt[M], a[M], r[M], level[N];\nint cur[N], edge, sum, ch[maxn], used[maxn], pre[maxn], dl[N];\nvoid create(int u, int v, int t)\n{\n\tedge++; a[edge] = v; nxt[edge] = head[u]; head[u] = edge; r[edge] = t;\n}\nvoid build()\n{\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tlevel[i] = 0;\n\t\tcur[i] = head[i];\n\t}\n\tint lef = 1, righ = 1;\n\tlevel[s] = 1;\n\tdl[1] = s;\n\twhile (lef <= righ)\n\t{\n\t\tint u = dl[lef];\n\t\tfor (int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = a[i];\n\t\t\tif (r[i] && level[v] == 0)\n\t\t\t{\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tdl[++righ] = v;\n\t\t\t}\n\t\t}\n\t\tlef++;\n\t}\n}\nint dinic(int u, int flow)\n{\n\tif (u == t) return flow;\n\tint ans = 0;\n\tfor (int i = cur[u]; i; i = nxt[i])\n\t{\n\t\tint v = a[i];\n\t\tif (r[i] && level[v] == level[u] + 1)\n\t\t{\n\t\t\tint low = dinic(v, min(flow, r[i]));\n\t\t\tans += low; flow -= low;\n\t\t\tr[i] -= low; if (i % 2) r[i + 1] += low; else r[i - 1] += low;\n\t\t}\n\t}\n\tif (ans == 0) level[u] = -1;\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tid[1][i] = ++cnt;\n\t\tcreate(cnt, t, 1); create(t, cnt, 0);\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tid[0][i] = ++cnt;\n\t\tcreate(s, cnt, 1); create(cnt, s, 0);\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tnode[i].push_back(x);\n\t\t\tpos[x].push_back(i);\n\t\t\tif (x != 1)\n\t\t\t{\n\t\t\t\tcreate(id[0][i], id[1][x], 1);\n\t\t\t\tcreate(id[1][x], id[0][i], 0);\n\t\t\t}\n\t\t}\n\t}\n\tbuild();\n\twhile (level[t])\n\t{\n\t\tsum += dinic(s, INF);\n\t\tbuild();\n\t}\n\tif (sum != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u = id[0][i];\n\t\tfor (int j = head[u]; j; j = nxt[j])\n\t\t{\n\t\t\tint v = a[j];\n\t\t\tif (v >= id[1][1] && r[j] == 0) {ch[i] = v - id[1][1] + 1; break;}\n\t\t}\n\t}\n\tint cnt = 1;\n\tpre[1] = 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tint u = pre[i], len = pos[u].size();\n\t\tfor (int j = 0; j <= len - 1; j++)\n\t\t{\n\t\t\tint x = pos[u][j];\n\t\t\tif (used[x] == 0)\n\t\t\t{\n\t\t\t\tused[x] = 1;\n\t\t\t\tres.push_back(make_pair(u, ch[x]));\n\t\t\t\tpre[++cnt] = ch[x];\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n) puts(\"-1\");\n\telse\n\tfor (int i = 0; i <= n - 2; i++)\n\t\tprintf(\"%d %d\\n\", res[i].first, res[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\nvector<int> r;\nvector<int> z;\n\nint ccc = 0;\n\nbool dfs(int x) {\n//    cout << x << \"\\n\";\n    if (z[x] == ccc) return false;\n    z[x] = ccc;\n    for (int y : g[x]) {\n        if (r[y] == -1 || dfs(r[y])) {\n            r[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    g.resize(n);\n    r.assign(n, -1);\n    z.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x;\n            x--;\n            g[x].push_back(i);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::random_shuffle(g[i].begin(), g[i].end());\n    }\n\n    int ff = -1;\n    for (int i = 0; i < n; i++) {\n        ccc++;\n        bool ok = false;\n        for (int y : g[i]) {\n            if (r[y] == -1) {\n                r[y] = i;\n                ok = true;\n                break;\n            }\n        }\n        if (!ok) {\n            if (!dfs(i)) {\n                if (ff == -1) {\n                    ff = i;\n                } else {\n                    cout << -1 << \"\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n\n//    for (int i = 0; i < n - 1; i++) {\n//        cout << r[i] << \"\\n\";\n//    }\n\n    vector<int> q;\n    vector<bool> zz(n);\n    q.push_back(ff);\n    vector<pair<int, int>> res(n - 1);\n    for (int i = 0; i < q.size(); i++) {\n        int x = q[i];\n        for (int c : g[x]) {\n            if (!zz[c]) {\n                zz[c] = true;\n                q.push_back(r[c]);\n                res[c] = {r[c], x};\n            }\n        }\n    }\n\n    if (q.size() < n) {\n        cout << \"-1\\n\";\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            cout << res[i].first + 1 << \" \" << res[i].second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 222222\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint E = MAX_V / 2;\nint s = MAX_V - 2;\nint g = MAX_V - 1;\nint mp[MAX_V/2];\nint rmp[MAX_V/2];\nbool used[MAX_V/2];\nbool visited[MAX_V/2];\n\nvector<vector<int>> v(MAX_V / 2);\nvector<vector<int>> nv(MAX_V / 2);\nvector<pair<int,pair<int,int>>> ans;\n\nvoid dfs(int num){\n\tvisited[num] = true;\n\tREP(i,nv[num].size()){\n\t\tif(!visited[nv[num][i]]){\n\t\t\tans.PB(MP(rmp[nv[num][i]], MP(num, nv[num][i])));\n\t\t\tdfs(nv[num][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tREP(i,n) {\n\t\tif(i != n -1)add_edge(s,i,1);\n\t\tadd_edge(E+i,g,1);\n\t}\n\t\t\n\tREP(i,n-1){\n\t\t\n\t\tint e;cin >> e;\n\t\tREP(j,e){\n\t\t\tint tmp;cin >> tmp;tmp--;\n\t\t\tv[i].EB(tmp);\n\t\t\tadd_edge(i, E+tmp, 1);\n\t\t}\n\t}\n\t\n\tint seica = Dinic(s, g);\n\tif(seica != n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,n-1) {\n\t\tREP(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0){\n\t\t\t\tmp[i] = G[i][j].to - E;\n\t\t\t\trmp[mp[i]] = i;\n\t\t\t\tused[mp[i]] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n-1){\n\t\tREP(j,v[i].size()){\n\t\t\tif(v[i][j] != mp[i])nv[v[i][j]].EB(mp[i]);\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(!used[i])dfs(i);\n\t}\n\t\n\tif(ans.size() == n-1){\n\t\tsort(ALL(ans));\n\t\tREP(i,ans.size()){\n\t\t\tcout << ans[i].SE.FI + 1 << \" \" << ans[i].SE.SE + 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<ctype.h>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f,oo = inf;\n#define pc putchar\n#define RG register\n#define gc getchar\ninline ll read(){\n\tRG ll x=0,f=1;RG char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tif(x<0)x=-x,pc('-');\n\tif(x>=10)write(x/10);\n\tputchar(x%10+'0');\n}\n#define rd read\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define rep(i,a,b) for(RG int i=(a);i<(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define y1 ________y1\n#define int ll\n#define N 1000005\n#define M 4000005\nstruct Edge{\n\tint to,nxt,cap;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap):to(to),nxt(nxt),cap(cap){};\n}edge[M*2];\nint first[N],cur[N],nume;\nvoid Addedge(int a,int b,int c){\n\tedge[nume] = Edge(b,first[a],c);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0);first[b] = nume++;\n}\nint q[N],dis[N],S,T,n,m,tot;\nbool bfs(){\n\tint front,rear;\n\tfront = rear = 0;\n\tmemset(dis,-1,sizeof(dis));\n\tq[rear++] = T;dis[T] = 1;\n\twhile(front < rear){\n\t\tint u = q[front++];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tint v=edge[e].to;\n\t\t\tif(edge[e^1].cap && dis[v]==-1){\n\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\tq[rear++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[S] != -1;\n}\nint dfs(int u,int flow){\n\tif(u==T) return flow;\n\tint used = 0,d;\n\tfor(int &e = cur[u];~e;e=edge[e].nxt){\n\t\tint v=edge[e].to;\n\t\tif(dis[u] == dis[v] + 1 && edge[e].cap && (d = dfs(v,min(flow-used,edge[e].cap)))){\n\t\t\tedge[e].cap -= d;\n\t\t\tedge[e^1].cap += d;\n\t\t\tused += d;\n\t\t}\n\t\tif(used == flow) break;\n\t}\n\tif(!used) dis[u] = -1;\n\treturn used;\n}\nint dinic(){\n\tll ans = 0;\n\twhile(bfs()){\n\t\tRep(i,1,tot) cur[i] = first[i];\n\t\tans += dfs(S,inf);\n\t}\n\treturn ans;\n}\nint id[N],Id[N],x[N];\nvector<int> g[N];\nsigned main(){\n\tmem(first,-1);nume = 0;\n\tn = read();\n\ttot = 0;\n\tS = ++tot;\n\tT = ++tot;\n\tRep(i,2,n){\n\t\tid[i] = ++tot;\n\t\tAddedge(id[i],T,1);\n\t}\n\tRep(i,1,n-1){\n\t\tId[i] = ++tot;\n\t\tAddedge(S,Id[i],1);\n\t\t//v[i] . resize(read());\n\t\tint t = read();\n\t\trep(j,0,t){\n\t\t\tint t = read();\n\t\t\tif(t != 1) Addedge(Id[i],id[t],1);\n\t\t\tg[t] . push_back(i);\n\t\t}\n\t}\n\tif(dinic() != n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tRep(i,1,n-1){\n\t\tint u = Id[i];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(e%2==0 && !edge[e].cap){\n//\t\t\t\tprintf(\"{%d %d}\\n\",u,edge[e].to);\n\t\t\t\tx[i] = edge[e].to - 1;\n\t\t\t}//完美，简直太棒了呀 \n\t\t}\n\t}\n\tqueue<int> Q;\n\tstatic int vis[N],y[N];\n\tQ.push(1);vis[1]=true;\n\twhile(!Q.empty()){\n\t\tint u = Q.front();Q.pop();\n\t\tfor(auto v:g[u]){\n\t\t//\tprintf(\"{%d)\\n\",x[v]);\n\t\t\tif(!vis[x[v]]){\n\t\t\t\tvis[x[v]] = u;\n\t\t\t\tQ.push(x[v]);\n\t\t\t\ty[v] = u;\n//\t\t\t\tprintf(\"%d %d\\n\",u,x[v]);\n\t\t\t}\n\t\t}\n\t}\n\tRep(i,1,n-1){\n\t\twrite(x[i]),pc(' '),write(y[i]),pc('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;\n}E[MAXN * 20];\nint N,head[MAXN * 2],sumE = 1,S,T,tot,lev[MAXN * 2],cur[MAXN * 2],ch[MAXN],fa[MAXN];\nvector<int> v[MAXN];\nbool vis[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c) {\n    add(u,v,c);add(v,u,0);\n}\nbool BFS() {\n    static int que[MAXN * 2],ql,qr;\n    que[ql = qr = 1] = S;\n    for(int i = 1 ; i <= T ; ++i) lev[i] = -1,cur[i] = head[i];\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    int v = E[i].to;\n\t    if(E[i].cap > 0 && lev[v] == -1) {\n\t\tlev[v] = lev[u] + 1;\n\t\tif(v == T) return true;\n\t\tque[++qr] = v;\n\t    }\n\t}\n    }\n    return false;\n}\nint dfs(int u,int aug) {\n    if(u == T) return aug;\n    int flow = 0;\n    for(int &i = cur[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(E[i].cap > 0 && lev[v] > lev[u]) {\n\t    int t = dfs(v,min(E[i].cap,aug - flow));\n\t    flow += t;E[i].cap -= t;E[i ^ 1].cap += t;\n\t    if(flow == aug) break;\n\t}\n    }\n    if(flow != aug) lev[u] = -1;\n    return flow;\n}\nint Dinic() {\n    int res = 0;\n    while(BFS()) {\n\tint x;\n\tdo {\n\t    x = dfs(1,0x7fffffff);\n\t    res += x;\n\t}while(x);\n    }\n    return res;\n}\nvoid Init() {\n    read(N);\n    S = 1;\n    for(int i = 1 ; i < N ; ++i) {\n\taddtwo(S,i + N,1);\n\tint c,w;\n\tread(c);\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    read(w);\n\t    if(w != 1) addtwo(i + N,w,1);\n\t    v[w].pb(i);\n\t}\n    }\n    T = 2 * N;\n    for(int i = 2 ; i <= N ; ++i) addtwo(i,T,1);\n}\nvoid construct() {\n    static int que[MAXN],ql,qr;\n    que[ql = qr = 1] = 1;\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(auto t : v[u]) {\n\t    if(!vis[t]) {\n\t\tvis[t] = 1;\n\t\tfa[ch[t]] = u;\n\t\tque[++qr] = ch[t];\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    if(Dinic() != N - 1) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= N - 1 ; ++i) {\n\tint u = i + N;\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(v > 1 && E[j].cap == 0) {ch[i] = v;break;}\n\t}\n    }\n    construct();\n    for(int i = 1 ; i < N ; ++i) {\n\tif(!vis[i]) {puts(\"-1\");return;}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tout(fa[ch[i]]);space;out(ch[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],u[N],v[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,e) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; u[m]=i; v[m]=id[j]; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,m) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nvector<int>rev[110000];\nint n;\nvector<int>g[210000];\nint t[210000];\nint L[110000];\nint R[110000];\nvoid dfs(int a){\n\tt[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tint to=g[a][i];\n\t\tif(t[to])continue;\n\t\tif(to<a-1){\n\t\t\tR[to]=a-n+1;\n\t\t}else{\n\t\t\tL[a]=to-n+1;\n\t\t}\n\t\tdfs(to);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t\trev[c].push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=0;i<a-1;i++){\n\t\t// std::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tif(0==v[i][j])continue;\n\t\t\t// printf(\"[%d] [%d]\\n\",i,v[i][j]);\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\tg[v[i][k]+a-1].push_back(i);\n\t\t\t\t}\n\t\t\t\tg[i].push_back(to+a-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++)L[i]=R[i]-1;\n\tdfs(a-1);\n\tfor(int i=0;i<a-1;i++){\n\t\tif(L[i]==-1||R[i]==-1){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",L[i]+1,R[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline int solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\tint link = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tlink++;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn link;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif (solve() < n - 1)\n\t\treturn 0;\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nnamespace NetworkFlow {\n\tconst int INF = 2e9;\n\tconst int MAXP = 2e5 + 5;\n\tstruct edge {\n\t\tint dest, flow;\n\t\tunsigned pos;\n\t};\n\tvector <edge> a[MAXP];\n\tint tot, s, t, dist[MAXP];\n\tunsigned curr[MAXP];\n\tvoid addedge(int x, int y, int z) {\n\t\ta[x].push_back((edge) {y, z, a[y].size()});\n\t\ta[y].push_back((edge) {x, 0, a[x].size() - 1});\n\t}\n\tint dinic(int pos, int limit) {\n\t\tif (pos == t) return limit;\n\t\tint used = 0, tmp;\n\t\tfor (unsigned &i = curr[pos]; i < a[pos].size(); i++)\n\t\t\tif (a[pos][i].flow != 0 && dist[pos] + 1 == dist[a[pos][i].dest] && (tmp = dinic(a[pos][i].dest, min(limit - used, a[pos][i].flow)))) {\n\t\t\t\tused += tmp;\n\t\t\t\ta[pos][i].flow -= tmp;\n\t\t\t\ta[a[pos][i].dest][a[pos][i].pos].flow += tmp;\n\t\t\t\tif (used == limit) return used;\n\t\t\t}\n\t\treturn used;\n\t}\n\tbool bfs() {\n\t\tstatic int q[MAXP];\n\t\tint l = 0, r = 0;\n\t\tmemset(dist, 0, sizeof(dist));\n\t\tdist[s] = 1, q[0] = s;\n\t\twhile (l <= r) {\n\t\t\tint tmp = q[l];\n\t\t\tfor (unsigned i = 0; i < a[tmp].size(); i++)\n\t\t\t\tif (dist[a[tmp][i].dest] == 0 && a[tmp][i].flow != 0) {\n\t\t\t\t\tq[++r] = a[tmp][i].dest;\n\t\t\t\t\tdist[q[r]] = dist[tmp] + 1;\n\t\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\treturn dist[t] != 0;\n\t}\n\tint flow() {\n\t\tint ans = 0;\n\t\twhile (bfs()) {\n\t\t\tmemset(curr, 0, sizeof(curr));\n\t\t\tans += dinic(s, INF);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid getmatch(int n, int *match) {\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (auto x : a[i])\n\t\t\t\tif (x.dest > n && x.flow == 0) {\n\t\t\t\t\tmatch[i] = x.dest - n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\nbool vis[MAXN], used[MAXN];\nint n, match[MAXN];\npair <int, int> ans[MAXN];\nvector <int> a[MAXN], b[MAXN];\nint main() {\n\tread(n);\n\tNetworkFlow :: s = 1;\n\tNetworkFlow :: t = n * 2 + 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint k; read(k);\n\t\tNetworkFlow :: addedge(1, i, 1);\n\t\twhile (k--) {\n\t\t\tint x; read(x);\n\t\t\ta[i].push_back(x);\n\t\t\tb[x].push_back(i);\n\t\t\tNetworkFlow :: addedge(i, x + n, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tNetworkFlow :: addedge(i + n, n * 2 + 1, 1);\n\tif (NetworkFlow :: flow() < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tNetworkFlow :: getmatch(n, match);\n\tfor (int i = 1; i <= n; i++)\n\t\tvis[i] = true;\n\tfor (int i = 2; i <= n; i++)\n\t\tvis[match[i]] = false;\n\tqueue <int> q;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (vis[i]) {\n\t\t\tfor (auto x : b[i]) {\n\t\t\t\tq.push(x);\n\t\t\t\tused[x] = true;\n\t\t\t}\n\t\t}\n\twhile (!q.empty()) {\n\t\tint tmp = q.front();\n\t\tfor (auto x : a[tmp])\n\t\t\tif (vis[x]) {\n\t\t\t\tans[tmp] = make_pair(x, match[tmp]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tvis[match[tmp]] = true;\n\t\tfor (auto x : b[match[tmp]])\n\t\t\tif (!used[x]) {\n\t\t\t\tq.push(x);\n\t\t\t\tused[x] = true;\n\t\t\t}\n\t\tq.pop();\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tif (ans[i].first == 0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(1e9);\nconst int MX = 222222;\n\nstruct edge\n{\n\tint to,cap,rev;\n\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n};\nvector <edge> vec[MX];\nint level[MX];\nint iter[MX];\n\nvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n{\n\tint S=vec[s].size(),T=vec[t].size();\n\tvec[s].push_back(edge(t,c,T));\n\tvec[t].push_back(edge(s,0,S));\n}\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue <int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t{\n\t\t\tedge&e=vec[v][i];\n\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t{\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll flow_dfs(int v,int t,ll f)\n{\n\tif (v==t) return f;\n\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t{\n\t\tedge &e=vec[v][i];\n\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t{\n\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\tif (d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll maxflow(int s,int t) //finds max flow using dinic from s to t\n{\n\tll flow = 0;\n\twhile(1)\n\t{\n\t\tbfs(s);\n\t\tif (level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\twhile (1)\n\t\t{\n\t\t\tll f=flow_dfs(s,t,INF);\n\t\t\tif(f==0) break;\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nvi A[222222];\nvi contained[222222];\nbool visited[222222];\nii chosen[222222];\nint match[222222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tint s = MX-1; int e = MX-2;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tchosen[i]=mp(-1,-1);\n\t\tint k; cin>>k;\n\t\taddedge(s,i,1);\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint u; cin>>u; u--;\n\t\t\taddedge(i,u+n,1);\n\t\t\tA[i].pb(u); contained[u].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) addedge(i+n,e,1);\n\tint maxmatch = maxflow(s,e);\n\tif(maxmatch!=n-1)\n\t{\n\t\tcout<<-1<<'\\n'; return 0;\n\t}\n\tset<int> S;\n\tfor(int i=0;i<n;i++) S.insert(i);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(auto X:vec[i])\n\t\t{\n\t\t\tif(X.to-n>=0&&X.to-n<n&&X.cap==0)\n\t\t\t{\n\t\t\t\tmatch[i]=X.to-n; S.erase(match[i]); break;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tq.push((*S.begin()));\n\twhile(!q.empty())\n\t{\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v:contained[u])\n\t\t{\n\t\t\tif(visited[v]) continue;\n\t\t\t//cerr<<\"CHOOSE \"<<v<<\" : \"<<u<<' '<<match[v]<<'\\n';\n\t\t\tchosen[v] = mp(u, match[v]);\n\t\t\tvisited[v]=1;\n\t\t\tq.push(match[v]);\n\t\t}\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(chosen[i].fi<0){cout<<-1<<'\\n'; return 0;}\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tcout<<chosen[i].fi+1<<' '<<chosen[i].se+1<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    for (int to : g[v]) {\n        if (dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n#define aimbot\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--) \n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a % b == 0) return 0;\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\n\nint n;\nvector<vector<int>> g;\nvector<int> rez;\nvector<int> sc;\nvector<bool> used;\n\nbool ktun(int v) {\n\tused[v] = true;\n\tfor (int sub : g[v]) {\n\t\tif (rez[sub] == -1) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int sub : g[v]) {\n\t\tif (used[rez[sub]]) continue;\n\t\tif (ktun(rez[sub])) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\t\n\tg.resize(n);\n\trez.resize(n - 1, -1);\n\tsc.resize(n - 1, -1);\n\tf(i, n - 1) {\n\t\tint k;\n\t\tscan k;\n\t\tf(j, k) {\n\t\t\tint x;\n\t\t\tscan x;\n\t\t\tx--;\n\t\t\tg[x].pb(i);\n\t\t}\n\t}\n\tused = vector<bool>(n, false);\n\tf(i, n) {\n\t\tif (ktun(i)) {\n\t\t\tused = vector<bool>(n, false);\n\t\t}\n\t}\n\tset<int> all;\n\tf(i, n) {\n\t\tall.insert(i);\n\t}\n\tvector<int> id(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (rez[i] == -1) {\n\t\t\tprint -1;\n\t\t\treturn 0;\n\t\t}\n\t\tid[rez[i]] = i;\n\t\tall.erase(rez[i]);\n\t}\n\tused = vector<bool>(n, false);\n\tdeque<int> deq{*all.begin()};\n\tused[deq[0]] = true;\n\twhile (!deq.empty()) {\n\t\tint v = deq[0];\n\t\tdeq.pop_front();\n\t\tfor (int sub : g[v]) {\n\t\t\tif (used[rez[sub]]) continue;\n\t\t\tused[rez[sub]] = true;\n\t\t\tsc[sub] = v;\n\t\t\tdeq.pb(rez[sub]);\n\t\t}\n\t}\n\tif (used != vector<bool>(n, true)) {\n\t\tprint -1;\n\t\treturn 0;\n\t}\n\tf(i, n - 1) {\n\t\tprint rez[i] + 1, sc[i] + 1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200100;\nstruct T {\n\tint to, nxt, v;\n} way[maxn << 1];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n\tway[++num] = {y, h[x], v}, h[x] = num;\n\tway[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n\tstd::queue<int> q;\n\tfor(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n\tfor(q.push(s), dis[s] = 0;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n\t\t\tdis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n\t}\n\treturn dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n\tif(s == t || !lim) return lim;\n\tint ans = 0, mn;\n\tfor(int & i = head[s];i;i = way[i].nxt)\n\t\tif(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n\t\t\tway[i].v -= mn;\n\t\t\tway[i ^ 1].v += mn;\n\t\t\tans += mn; lim -= mn;\n\t\t\tif(!lim) break;\n\t\t}\n\treturn ans;\n}\ninline int dinic(int s,int t) {\n\tint ans = 0;\n\tfor(;bfs(s,t);) ans += dfs(s,t,1e9);\n\treturn ans;\n}\nint n;\nstd::vector<int> v[maxn];\nstd::vector<int> to[maxn];\nint id[maxn], fa[maxn];\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1,x,a;i < n;++i) {\n\t\tstd::cin >> x, adde(0, i, 1);\n\t\tfor(;x--;) {\n\t\t\tstd::cin >> a, v[i].push_back(a);\n\t\t\tif(a != n) adde(i, a + n, 1);\n\t\t}\n\t}\n\tfor(int i = 1;i < n;++i) adde(i + n,n + n + 1,1);\n\tif(dinic(0,n + n + 1) != n - 1) {\n\t\tstd::cout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i <= n;++i) for(int j = h[i + n];j;j=way[j].nxt) if(way[j].v == 1 && way[j].to < n)\n\t\tid[way[j].to] = i;\n\tfor(int i = 1;i < n;++i) for(int j : v[i])\n\t\tto[j].push_back(id[i]);\n\tstd::queue<int> q; \n\tfor(q.push(n), fa[n] = 1;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i : to[t]) if(!fa[i])\n\t\t\tq.push(i), fa[i] = t;\n\t}\n\tif(std::count(fa + 1,fa + n + 1,0)) {\n\t\tstd::cout << - 1 << '\\n';\n\t} else {\n\t\tfor(int i = 1;i < n;++i) std::cout << fa[i] << ' ' << i << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G2;\nint n, Deg[N_], UF[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nvector<int>TP[N_];\nint Num[N_], Q[N_], head, tail, vis[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG2.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\n\t\tG2.Add_Edge(G2.source, i, 1);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tTP[a].push_back(i);\n\t\t\tif (a != 1) {\n\t\t\t\tG2.Add_Edge(i, n - 1 + a, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif(i!=1)G2.Add_Edge(n - 1 + i, G2.sink, 1);\n\t}\n\tG2.Dinic();\n\tfor (i = 2; i <= n; i++) {\n\t\tfor (auto &x : G2.G[n - 1 + i]) {\n\t\t\tEdge tp = G2.E[x];\n\t\t\tif (tp.f) {\n\t\t\t\tNum[tp.e] = i;\n\t\t\t}\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : TP[x]) {\n\t\t\tif (!vis[t]) {\n\t\t\t\tRes[t][0] = x;\n\t\t\t\tRes[t][1] = Num[t];\n\t\t\t\tQ[++tail] = Num[t];\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (tail!=n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nconst int N=1e6+5;\nint n,s,ans,now=1,v[N],w[N],cr[N],vi[N],dis[N],nex[N],head[N];\nvoid addedges(int x,int y,int z){\n\tnex[++now]=head[x],w[now]=z;\n\thead[x]=now,v[now]=y;\n}\nvoid add(int x,int y,int z){\n\taddedges(x,y,z);\n\taddedges(y,x,0);\n}\nqueue<int>que;\nbool bfs(){\n\tfor(int i=0;i<=s;i++)\tcr[i]=head[i];\n\tfor(int i=0;i<s;i++)\tdis[i]=0;\n\tdis[s]=1,que.push(s);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tfor(int i=head[x];i;i=nex[i]){\n\t\t\tif(w[i]&&!dis[v[i]]){\n\t\t\t\tdis[v[i]]=dis[x]+1;\n\t\t\t\tque.push(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[0];\n}\nint dfs(int x,int f){\n\tint ans=0;\n\tif(!x||!f)\treturn f;\n\tfor(int &i=cr[x];i;i=nex[i])\n\t\tif(w[i]&&dis[v[i]]==dis[x]+1){\n\t\t\tint d=dfs(v[i],min(w[i],f));\n\t\t\tif(!d)\tcontinue;\n\t\t\tans+=d,w[i]-=d;\n\t\t\tw[i^1]+=d,f-=d;\n\t\t\tif(!f)\tbreak;\n\t\t}\n\tif(!ans)\tdis[x]=-1;\n\treturn ans;\n}\nint bl[N];\nvector<int>b[N];\nint main(){\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),s=n*2;\n\tfor(int i=1,si,x;i<n;i++){\n\t\tscanf(\"%d\",&si),add(s,i+n,1);\n\t\twhile(si--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tb[x].push_back(i+n);\n\t\t\tif(x!=1)\tadd(i+n,x,1);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\tadd(i,0,1);\n\n\twhile(bfs())\n\twhile(int d=dfs(s,inf))\tans+=d;\n\n\tif(ans!=n-1)\tputs(\"-1\"),exit(0);\n\tfor(int i=n+1;i<s;i++)\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t\tif(!w[j])\tbl[i]=v[j];\n\tque.push(1);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tint si=b[x].size();\n\t\tfor(int i=0;i<si;i++)\n\t\t\tif(!vi[b[x][i]]){\n\t\t\t\tprintf(\"%d %d\\n\",x,bl[b[x][i]]);\n\t\t\t\tvi[b[x][i]]=1,que.push(bl[b[x][i]]);\n\t\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint n;\nvector<edge> G[200005];\nint S, T;\nllint level[200005], iter[200005];\n\nvector<llint> revG[200005];\nllint succ[200005];\nbool used[200005];\nvector<P> avec;\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nvoid dfs2(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tavec.push_back(P(v, succ[revG[v][i]]));\n\t\tdfs2(succ[revG[v][i]]);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint c, w;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> w;\n\t\t\tadd_edge(i, n+w, 1);\n\t\t\trevG[w].push_back(i);\n\t\t}\n\t}\n\tS = 2*n+1, T = 2*n+2;\n\t\n\tfor(int i = 1; i <= n-1; i++) add_edge(S, i, 1);\n\tfor(int i = 1; i <= n; i++) add_edge(n+i, T, 1);\n\t\n\tllint ans = 0, flow;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(level[T] >= inf) break;\n\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\twhile(1){\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t}\n\tif(ans < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].to == S) continue;\n\t\t\tif(G[i][j].cap == 0) succ[i] = G[i][j].to-n;\n\t\t}\n\t}\n\tint r;\n\tfor(int i = 0; i < G[T].size(); i++){\n\t\tif(G[T][i].cap == 0){\n\t\t\tr = G[T][i].to-n;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdfs2(r);\n\t\n\tif(avec.size() < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < avec.size(); i++){\n\t\tcout << avec[i].first << \" \" << avec[i].second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint cnt=1,head[MAXN],cur[MAXN],d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool BFS(){\n\tmemset(d,0,sizeof(d)),d[S]=1;queue<int>q;q.push(S);\n\tfor(int x;!q.empty();){\n\t\tx=q.front(),q.pop();\n\t\tfor(int i=head[x],y;i;i=edges[i].next)\n\t\t\tif(!d[y=edges[i].to]&&edges[i].w)d[y]=d[x]+1,q.push(y);\n\t}return d[T];\n}int DFS(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(d[y=edges[i].to]==d[x]+1&&edges[i].w){\n\t\tk=DFS(y,min(dist,edges[i].w)),edges[i].w-=k,edges[i^1].w+=k,z+=k,dist-=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(BFS())memcpy(cur,head,sizeof(head)),ans+=DFS(S,1e9);return ans;}\n//struct Edge{int to,next,w;}edges[MAXM];\n//int head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\n//inline void add(int x,int y,int w){\n//\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n//\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n//}inline bool bfs(){\n//\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n//\tfor(int x;!q.empty();q.pop())\n//\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n//\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n//\treturn d[T];\n//}int dfs(int x,int dist){\n//\tif(x==T||!dist)return dist;int z=0;\n//\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n//\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n//\t\tif(!dist)break;\n//\t}return z;\n//}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\treturn 0;\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n//\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const inf=1e8;\nint n,target[800005],pre[800005],last[200005],cap[800005],tot=1,maxflow,\ncur[200005],s,t,dis[200005],ans[200005],ans2[200005];\nbool visited[200005];\nqueue<int>q;\nvoid add(int x,int y,int z)\n{\n\ttarget[++tot]=y;\n\tpre[tot]=last[x];\n\tlast[x]=tot;\n\tcap[tot]=z;\n\ttarget[++tot]=x;\n\tpre[tot]=last[y];\n\tlast[y]=tot;\n}\nbool bfs()\n{\n\tfor(int i=1;i<=t;i++)dis[i]=inf,cur[i]=last[i];\n\tcur[0]=last[0];\n\tq.push(0);\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=last[now];i;i=pre[i])\n\t\t{\n\t\t\tif(cap[i]&&dis[target[i]]==inf)\n\t\t\t{\n\t\t\t\tdis[target[i]]=dis[now]+1;\n\t\t\t\tq.push(target[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=inf;\n}\nint dfs(int x,int lim)\n{\n\tif((!lim)||x==t)return lim;\n\tint flow=0;\n\tfor(int i=cur[x];i;cur[x]=i,i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(cap[i]&&dis[target[i]]==dis[x]+1)\n\t\t{\n\t\t\tint d=dfs(target[i],min(lim,cap[i]));\n\t\t\tcap[i]-=d;\n\t\t\tcap[i^1]+=d;\n\t\t\tflow+=d;\n\t\t\tlim-=d;\n\t\t\tif(!lim)return flow;\n\t\t}\n\t}\n\treturn flow;\n}\nvoid dinic()\n{\n\twhile(bfs())maxflow+=dfs(s,inf);\n}\nvoid getans(int x,int fa)\n{\n\t//cout<<x<<endl;\n\tif(x>n)visited[x]=1;\n\tfor(int i=last[x];i;i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(x<=n)\n\t\t{\n\t\t\tif(tar==s||tar==t)continue;\n\t\t\tif(!visited[tar])\n\t\t\t{\n\t\t\t\tgetans(tar,x);\n\t\t\t\t//return;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tar==t||(!cap[i]))continue;\n\t\t\tans[++ans[0]]=fa;\n\t\t\tans2[ans[0]]=tar;\n\t\t\tgetans(tar,tar);\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main()\n{\n\tint x,T;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&T);\n\t\twhile(T--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tadd(x,i+n,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)add(0,i,1);\n\tfor(int i=n+1;i<n*2;i++)add(i,n*2,1);\n\tt=n*2,s=0;\n\tdinic();\n\tif(maxflow<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint st;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor(int j=last[i];j;j=pre[j])\n\t\t{\n\t\t\t//cout<<i<<\" \"<<target[j]<<\" \"<<cap[j]<<endl;\n\t\t\tif(target[j]>n&&(!cap[j]))\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgetans(st,st);\n\tif(ans[0]!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=ans[0];i++)printf(\"%d %d\\n\",ans[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\n\nint n;\n\ninline void failed(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<int> G[N];\nbool vis[N];\nint match[N];\nint pref[N];\nstack<int> stk;\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<G[x].size();i++){\n\t\tint v=G[x][i];if(vis[v])continue;\n\t\tvis[v]=1;stk.push(v);\n\t\tif(!pref[v] || dfs(pref[v])){\n\t\t\tmatch[x] = v;\n\t\t\tpref[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint s[N];\ntypedef pair<int,int> pi;\nvector<pi> tr;\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<n;i++){\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int j=1,e;j<=c;j++){\n\t\t\tscanf(\"%d\",&e);\n\t\t\tG[e].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\t// cout << i << \":\";\n\t\tif(!dfs(i))failed();\n\t\twhile(stk.size()){\n\t\t\t// cout << stk.top();\n\t\t\tvis[stk.top()]=0;\n\t\t\tstk.pop();\n\t\t}\n\t\t// cout << \"?\" << endl;\n\t}\n\tqueue<int> q;\n\tfor(size_t i=0;i<G[1].size();i++){\n\t\ts[G[1][i]]=1;\n\t\tq.push(G[1][i]);\n\t}\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tint v = pref[u];\n\t\ttr.push_back(pi(v,s[u]));\n\t\tfor(size_t i=0;i<G[v].size();i++){\n\t\t\tif(!s[G[v][i]])s[G[v][i]]=v,q.push(G[v][i]);\n\t\t}\n\t}\n\tif((int)tr.size()<n-1){\n\t\tfailed();\n\t}\n\tfor(size_t i=0;i<tr.size();i++){\n\t\tprintf(\"%d %d\\n\",tr[i].first,tr[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back({x,i,mxfl::adde(x,i+n,1)});\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[1]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200005;\nconst int ME = 500005;\nconst int oo = 123123123;\n\ntemplate<typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate<typename T> void read(T &x)\n{\n\tx = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v, c;\n\n\tEDGE (const int &v0 = 0, const int &c0 = 0) : v(v0), c(c0) {}\n};\n\nstruct GRAPH\t//板子\n{\n\tEDGE e[ME];\n\tint fst[MX], nxt[ME], lnum;\n\tint dep[MX],q[MX];          //分层网络的深度，bfs 的队列\n\n\tvoid addeg(int nu, int nv, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\tfst[nu] = lnum;\n\t\te[lnum] = EDGE(nv, nc);\n\t}\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tint bfs(int frm,int to)     //生成分层网络\n\t{\n\t\tint h=0,t=1,x,y;\n\t\tmemset(dep,0xff,sizeof(dep));\n\t\tq[++h]=frm;\n\t\tdep[frm]=0;\n\t\twhile(h>=t)\n\t\t{\n\t\t\tx=q[t++];\n\t\t\tfor(int i=fst[x];i!=-1;i=nxt[i])\n\t\t\t{\n\t\t\t\ty=e[i].v;\n\t\t\t\tif(dep[y]==-1&&e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tq[++h]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dep[to]>=0);    //返回分层网络是否成功生成\n\t}\n\n\tint cur[MX];                //当前弧优化的记录数组\n\tint dinic(int x,int mn,int tar)\n\t{\n\t\tif(x==tar)return mn;\n\t\tint y,a,now=0;\n\t\tfor(int &i=cur[x];i!=-1;i=nxt[i])   //\"int &i=\"这一句是当前弧优化的核心\n\t\t{\n\t\t\ty=e[i].v;\n\t\t\tif(e[i].c&&dep[y]==dep[x]+1)\n\t\t\t{\n\t\t\t\ta=dinic(y,min(mn-now,e[i].c),tar);\n\t\t\t\tnow+=a;                     //整体流量优化，记录当前节点往下流的最大流量后再返回\n\t\t\t\te[i].c-=a,e[i^1].c+=a;      //帮助 dinic 反悔\n\t\t\t\tif(mn==now)return now;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\n\tint mxflow(int s, int t)\n\t{\n\t\tint tot=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemmove(cur,fst,sizeof(fst));\n\t\t\ttot+=dinic(s,+oo,t);\n\t\t}\n\t\treturn tot;\n\t}\n} G;\n\nint n;\nint global_s, global_t;\n\nvoid input()\n{\n\tG.init();\n\tread(n);\n\tglobal_s = n*2, global_t = n*2+1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint c, x;\n\t\tread(c);\n\t\tfor(int j=1; j<=c; j++)\n\t\t{\n\t\t\tread(x);\n\t\t\tG.addeg(x, n+i, 1);\n\t\t\tG.addeg(n+i, x, 0);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tG.addeg(global_s, i, 1);\n\t\tG.addeg(i, global_s, 0);\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tG.addeg(n+i, global_t, 1);\n\t\tG.addeg(global_t, n+i, 0);\n\t}\n}\n\nint frm[MX];\n\nvoid dfs(int x, int f)\n{\n\tfrm[x] = f;\n\tfor(int i=G.fst[x]; ~i; i=G.nxt[i])\n\t\tif(G.e[i].c && !frm[G.e[i].v])\n\t\t\tdfs(G.e[i].v, x);\n}\n\nvoid work()\n{\n\tif(G.mxflow(global_s, global_t) != n-1) puts(\"-1\");\n\telse\n\t{\n\t\tint root = 0;\n\t\tfor(int i=G.fst[global_s]; ~i; i=G.nxt[i])\n\t\t\tif(G.e[i].c)\n\t\t\t\troot = G.e[i].v;\n\t\tdfs(root, -1);\n\t\tbool fucked = 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tif(!frm[i])\n\t\t\t\tfucked = 1;\n\t\tif(fucked) puts(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++)\n\t\t\t\tif(i != root)\n\t\t\t\t\tprintf(\"%d %d\\n\", i, frm[frm[i]]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200005;\nconst int MAXM = 400005;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint S, T, level[MAXN], q[MAXN], head, tail;\n\nstruct Edge {\n\tint v, w, nxt;\n} e[MAXM << 1];\nint first[MAXN], used[MAXN], eCnt;\n\ninline void AddEdge(int u, int v, int w) {\n\te[++eCnt].v = v;\n\te[eCnt].w = w;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\ninline void Add(int u, int v, int w) {\n\tAddEdge(u, v, w);\n\tAddEdge(v, u, 0);\n}\n\ninline int Match(int u) {\n\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\tif (e[i].v != T && e[i].w) return e[i].v;\n\t}\n\treturn 0;\n}\n\nbool BFS() {\n\tfor (int i = 1; i <= T; ++i) {\n\t\tlevel[i] = -1;\n\t\tused[i] = first[i];\n\t}\n\tlevel[S] = 0;\n\tq[head = tail = 1] = S;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tif (u == T) return 1;\n\t\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && level[v] == -1) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++tail] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint DFS(int u, int flow) {\n\tif (u == T) return flow;\n\tint ret = 0;\n\tfor (int i = used[u]; i; i = e[i].nxt, used[u] = i) {\n\t\tint v = e[i].v;\n\t\tif (e[i].w && level[v] == level[u] + 1) {\n\t\t\tint tmp = DFS(v, min(flow, e[i].w));\n\t\t\te[i].w -= tmp;\n\t\t\te[i ^ 1].w += tmp;\n\t\t\tflow -= tmp;\n\t\t\tret += tmp;\n\t\t\tif (!flow) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Dinic() {\n\tint ret = 0;\n\twhile (BFS()) {\n\t\tret += DFS(S, INF);\n\t}\n\treturn ret;\n}\n\nint n, son[MAXN], fa[MAXN];\nvector<int> ine[MAXN];\n\nvoid init() {\n\tread(n);\n\teCnt = S = 1, T = n * 2;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint siz; read(siz);\n\t\tAdd(S, n + i, 1);\n\t\tfor (int j = 1; j <= siz; ++j) {\n\t\t\tint x; read(x);\n\t\t\tine[x].push_back(i);\n\t\t\tif (x == 1) continue;\n\t\t\tAdd(n + i, x, 1);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tAdd(i, T, 1);\n\t}\n}\n\nvoid solve() {\n\tif (Dinic() < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tson[Match(i) - n] = i;\n\t}\n\tq[head = tail = 1] = 1;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tfor (auto v : ine[u]) {\n\t\t\tif (fa[v]) continue;\n\t\t\tfa[v] = u;\n\t\t\tq[++tail] = son[v];\n\t\t}\n\t}\n\tif (tail < n) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tprintf(\"%d %d\\n\", fa[i], son[i]);\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 20];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int i=h[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[u]=v-n;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+99,M=61e4;\ninline int min(const int&a,const int&b){return a<b?a:b;}\nstruct graph{\n\tstruct edge{int to,next,f;}e[M<<1];\n\tint h[N],cur[N],xb;\n\tinline void addedge(int x,int y,int z){\n\t\te[++xb]=(edge){y,h[x],z};h[x]=xb;\n\t\te[++xb]=(edge){x,h[y],0};h[y]=xb;\n\t}\n\tint S,T,d[N],n;\n\tinline bool bfs(){\n\t\tstatic int q[N];int t=0,w=1;q[1]=S;\n\t\tmemset(d+1,0,n<<2);d[S]=1;\n\t\tfor(;t<w;){\n\t\t\tint u=q[++t];\n\t\t\tfor(int i=h[u];i;i=e[i].next)if(e[i].f && !d[e[i].to])\n\t\t\t\td[e[i].to]=d[u]+1,q[++w]=e[i].to;\n\t\t}\n\t\treturn d[T];\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==T)return f;\n\t\tint ans=0,&i=cur[x],t;\n\t\tfor(;i;i=e[i].next)if(e[i].f && d[e[i].to]==d[x]+1){\n\t\t\tif(t=dfs(e[i].to,min(f,e[i].f))){\n\t\t\t\tans+=t,e[i].f-=t;e[i^1].f+=t;f-=t;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tinline int dinic(int s,int t){\n\t\tint ans=0;S=s;T=t;\n\t\tfor(;bfs();ans+=dfs(s,1<<30))memcpy(cur+1,h+1,n<<2);\n\t\treturn ans;\n\t}\n}g;\nint n,i,j,fa[N],bel[N],u1[N],v1[N];\nvector<int>v[N],vv[N];\nvoid dfs(int x){\n\tauto t=v[x];v[x].clear();\n\tfor(int y:t)if(!fa[y])fa[y]=x,dfs(y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tg.n=n*2;g.xb=1;\n\tfor(i=2;i<=n;++i)g.addedge(n-2+i,g.n,1);\n\tfor(i=1;i<n;++i){\n\t\tscanf(\"%d\",&j);vv[i].resize(j);\n\t\tfor(int&x:vv[i]){scanf(\"%d\",&x);if(x>1)g.addedge(i,n-2+x,1);}\n\t\tg.addedge(g.n-1,i,1);\n\t}\n\tif(g.dinic(g.n-1,g.n)<n-1){puts(\"-1\");return 0;}\n\tfor(i=1;i<n;++i){\n\t\tfor(j=g.h[i];g.e[j].f;j=g.e[j].next);\n\t\tint x=g.e[j].to-(n-2);bel[x]=i;\n//cerr<<x<<' '<<i<<endl;\n\t\tfor(int y:vv[i])if(y!=x)v[y].push_back(x);\n\t}\n\tdfs(1);\n\tfor(i=1,j=0;i<=n;++i)j+=!fa[i];\n\tif(j>1){puts(\"-1\");return 0;}\n\tfor(i=2;i<=n;++i)u1[bel[i]]=i,v1[bel[i]]=fa[i];\n//\tfor(i=1;i<=n;++i)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\tfor(i=1;i<n;++i)printf(\"%d %d\\n\",u1[i],v1[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define inf 1<<30\n#define sqr(x) ((x)*(x))\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next,f;\n}e[N*10];\nint head[N*2],tot=1,S,T;\nint dis[N*2],q[N*2];\nvoid add(int x,int y,int v){\n\te[++tot]=(edge){y,head[x],v};\n\thead[x]=tot;\n\te[++tot]=(edge){x,head[y],v};\n\thead[y]=tot;\n}\nbool bfs(){\n\tFor(i,1,T) dis[i]=-1;\n\tq[0]=1; q[1]=S; dis[S]=1;\n\tFor(h,1,q[0])\n\t\tfor (int i=head[q[h]];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]==-1&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[q[h]]+1;\n\t\t\t\tif (e[i].to==T) return 1;\n\t\t\t\tq[++q[0]]=e[i].to;\n\t\t\t}\n\treturn 0;\n}\nint dfs(int x,int flow){\n\tif (x==T) return flow;\n\tint k,rest=flow;\n\tfor (int i=head[x];i&&rest;i=e[i].next)\n\t\tif (dis[e[i].to]==dis[x]+1&&e[i].f){\n\t\t\tk=dfs(e[i].to,min(rest,e[i].f));\n\t\t\te[i].f-=k; e[i^1].f+=k; rest-=k;\n\t\t}\n\tif (rest) dis[x]=-1;\n\treturn flow-rest;\n}\nvector<int> v[N],V[N];\nint cnt,n;\nint fa[N],mat[N];\nbool vis[N];\nvoid dfs(int x){\n\t++cnt; vis[x]=1;\n\tfor (auto i:V[x])\n\t\tif (!vis[mat[i]]){\n\t\t\tfa[i]=x;\n\t\t\tdfs(mat[i]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=2*n; T=2*n+1;\n\tFor(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tv[i].resize(cnt);\n\t\tFor(j,0,cnt-1){\n\t\t\tscanf(\"%d\",&v[i][j]);\n\t\t\tif (v[i][j]!=1)\n\t\t\t\tadd(i+n,v[i][j],1);\n\t\t\tV[v[i][j]].PB(i);\n\t\t}\n\t}\n\tFor(i,2,n)\n\t\tadd(i,T,1);\n\tint flow=0;\n\tfor (;bfs();flow+=dfs(S,inf));\n\tif (flow!=n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tfor (int j=head[i+n];j;j=e[j].next)\n\t\t\tif (e[j].to<S&&!e[j].f)\n\t\t\t\tmat[i]=e[j].to;\n\tdfs(1);\n\tif (cnt!=n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",mat[i],fa[i]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=2147483647;\n#define N 100005\nint n,m,S,T,cc=1,hd[1000005],iter[1000005],d[1000005],vis[N],t[N],t1[N],t2[N];\nvector<int>g[N];\nstruct E{int v,nxt,w;}e[1000005];\nvoid add(int u,int v,int w){e[++cc]=(E){v,hd[u],w};hd[u]=cc;e[++cc]=(E){u,hd[v],0};hd[v]=cc;}\nbool bfs()\n{\n\tfor(int i=1;i<=T;i++)d[i]=inf;\n\tqueue<int>q;q.push(S);d[S]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=hd[x];i;i=e[i].nxt)if(e[i].w&&d[e[i].v]==inf){d[e[i].v]=d[x]+1;q.push(e[i].v);}\n\t}\n\treturn d[T]<inf;\n}\nint dfs(int x,int f)\n{\n\tif(!f||x==T)return f;\n\tint sf=0;\n\tfor(int &i=iter[x];i;i=e[i].nxt)if(e[i].w&&d[e[i].v]==d[x]+1)\n\t{\n\t\tint ff=dfs(e[i].v,min(f,e[i].w));\n\t\tif(ff){e[i].w-=ff;e[i^1].w+=ff;f-=ff;sf+=ff;}\n\t}\n\treturn sf;\n} \nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tmemcpy(iter,hd,sizeof(iter));\n\t\tint f;while(f=dfs(S,inf))ans+=f;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);S=1;T=2*n;\n\tfor(int i=2;i<=n;i++)add(S,i,1);\n\tfor(int i=n+1;i<2*n;i++)add(i,T,1);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tg[x].push_back(i);\n\t\t\tif(x>1)add(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic()!=n-1){puts(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)for(int j=hd[i];j;j=e[j].nxt)if(!e[j].w)t[i]=e[j].v-n+1;\n\tqueue<int>q;q.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=0;i<g[x].size();i++)\n\t\t{\n\t\t\tint y=g[x][i];\n\t\t\tif(vis[y])continue;\n\t\t\tvis[y]=1;t1[y]=x;t2[y]=t[y];\n\t\t\tq.push(t[y]);\n\t\t} \n\t}\n\tfor(int i=2;i<=n;i++)if(!t1[i]){puts(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",t1[i],t2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\nint vt[N*2],tim;\nint cur[N*2];\n\nbool bfs(){\n\ttim++;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tvt[st]=tim;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt){\n\t\t\tint y=e[p].x;\n\t\t\tif (vt[y]<tim&&e[p].f){\n\t\t\t\tvt[y]=tim;\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tque[++ta]=y;\n\t\t\t}\n\t\t}\n\t}\n\treturn vt[ed]==tim;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int &p=cur[x];p;p=e[p].nxt)\n\tif (e[p].f&&vt[e[p].x]==tim&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs()){\n\t\tfo(i,0,n*2+1)cur[i]=h[i];\n\t\tint tmp=aug(st,INF);\n\t\twhile(tmp){\n\t\t\tret+=tmp;\n\t\t\ttmp=aug(st,INF);\n\t\t}\n\t}\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\nstruct Bipartite_matching{\n\tint V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\tBipartite_matching(int N){\n\t\tV=N;\n\t\tG.assign(V,vector<int>());\n\t\tmatch.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\tvoid add_edge(int v,int u){\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tbool dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res=0;\n\t\tfill(all(match),-1);\n\t\trep(v,V){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(all(used),false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint N;\n\tcin>>N;\n\tVV<int> A(N-1);\n\tVV<int> v2as(N);\n\trep(i,N-1){\n\t\tint K;\n\t\tcin>>K;\n\t\trep(j,K){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tx--;\n\t\t\tA[i].pb(x);\n\t\t\tv2as[x].pb(i);\n\t\t}\n\t}\n\tBipartite_matching BM(N-1+N);\n\trep(i,N-1){\n\t\tfor(int v:A[i]) BM.add_edge(i,v+N-1);\n\t}\n\tint f = BM.max_matching();\n\tif(f != N-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tV<int> match(N-1);\n\trep(i,N-1) match[i] = BM.match[i] - (N-1);\n\n\t\n\tVV<int> ans(N-1,V<int>(2,-1));\n\trep(i,N-1) ans[i][0] = match[i];\n\n\tint r = 0;\n\trep(i,N) r ^= i;\n\trep(i,N-1) r ^= match[i];\n\tqueue<int> que;\n\tque.push(r);\n\t\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i: v2as[v]) if(ans[i][0] != v && ans[i][1] == -1){\n\t\t\tans[i][1] = v;\n\t\t\tque.push(ans[i][0]);\n\t\t}\n\t}\n\trep(i,N-1) if(ans[i][1] == -1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,N-1) cout<<ans[i][0]+1<<\" \"<<ans[i][1]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1000010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int i = head[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        if (a == 0)\n            d[e[i].v] = 0;\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], vis[100010], to[100010], ans[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue <int> q;\n    q.push(n);\n    vis[n] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (e[i].c == 0 && !::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 4e5, inf = 1e9;\nint n, tot, ter[maxn + 3], wei[maxn + 3], nxt[maxn + 3], lnk[maxn + 3];\nint cur[maxn + 3], dep[maxn + 3], num[maxn + 3], ans[maxn + 3];\nbool vis[maxn + 3];\nvector<int> S[maxn + 3], V[maxn + 3], G[maxn + 3];\n\nint adj(int x) {\n\treturn x & 1 ? x + 1 : x - 1;\n}\n\nint add(int u, int v, int w) {\n\tter[++tot] = v, wei[tot] = w;\n\tnxt[tot] = lnk[u], lnk[u] = tot;\n\treturn tot;\n}\n\nint add_f(int u, int v) {\n\tint t = add(u, v, 1);\n\treturn add(v, u, 0), t;\n}\n\nbool bfs() {\n\tqueue<int> Q;\n\tQ.push(1);\n\tmemset(dep, -1, sizeof(dep));\n\tdep[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = lnk[u], v, w; i; i = nxt[i]) {\n\t\t\tv = ter[i], w = wei[i];\n\t\t\tif ((~dep[v]) || !w) continue;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tQ.push(v);\n\t\t}\n\t}\n\treturn ~dep[n * 2];\n}\n\nint dfs(int u, int t, int lft) {\n\tif (u == t) {\n\t\treturn lft;\n\t}\n\tint ret = 0;\n\tfor (int &i = cur[u], v, w; i && ret < lft; i = nxt[i]) {\n\t\tv = ter[i], w = wei[i];\n\t\tif (w && dep[u] + 1 == dep[v]) {\n\t\t\tint x = dfs(v, t, min(lft - ret, w));\n\t\t\twei[i] -= x, wei[adj(i)] += x, ret += x;\n\t\t}\n\t}\n\tif (ret < lft) {\n\t\tdep[u] = -1;\n\t}\n\treturn ret;\n}\n\nint flow() {\n\tint ret = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur, lnk, sizeof(cur));\n\t\tret += dfs(1, n * 2, inf);\n\t}\n\treturn ret;\n}\n\nvoid dfs(int u) {\n\tvis[u] = true;\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tv = G[u][i];\n\t\tif (vis[v]) continue;\n\t\tans[v] = u;\n\t\tdfs(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, m; i <= n - 1; i++) {\n\t\tscanf(\"%d\", &m);\n\t\tS[i].resize(m), V[i].resize(m);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &S[i][j]);\n\t\t\tif (S[i][j] != 1) {\n\t\t\t\tV[i][j] = add_f(S[i][j], i + n);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tadd_f(1, i);\n\t}\n\tfor (int i = n + 1; i < n * 2; i++) {\n\t\tadd_f(i, n * 2);\n\t}\n\tif (flow() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint x = 0;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != 1 && !wei[V[i][j]]) {\n\t\t\t\tx = S[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum[i] = x;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != x) {\n\t\t\t\tG[S[i][j]].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tputs(\"-1\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tprintf(\"%d %d\\n\", ans[num[i]], num[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst int INF = 2147483600;\n\nint N;\n\nint Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],C[MAXN<<1],cnt; \ninline void addedge(int u,int v,int c){\n\tNode[cnt]=v; Next[cnt]=Root[u]; C[cnt]=c; Root[u]=cnt++;\n}\ninline void insert(int u,int v,int c){\n\taddedge(u,v,c); addedge(v,u,0);\n}\nint S,T; int dis[MAXN+1];\ninline bool BFS(){\n\tfor(int i=S;i<=T;i++) dis[i]=0;\n\tqueue<int> que; que.push(S); dis[S]=1;\n\twhile(!que.empty()){\n\t\tint k=que.front();\n\t\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\t\tint v=Node[x]; \n\t\t\tif(C[x]>0&&!dis[v]) dis[v]=dis[k]+1,que.push(v); \n\t\t} que.pop();\n\t} \n\treturn (dis[T]?1:0);\n}\ninline int DFS(int k,int t){\n\tif(k==T) {return t;} int ret=0;\n\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\tint v=Node[x]; if(C[x]>0&&dis[v]==dis[k]+1){\n\t\t\tint d=DFS(v,min(t,C[x]));\n\t\t\tC[x]-=d; C[x^1]+=d; ret+=d; t-=d;\n\t\t\tif(!t) return ret;\n\t\t}\n\t} if(!ret) dis[k]=0;\n\treturn ret;\n}\nint nod;\nqueue<int> que; int vis[MAXN+1],chs[MAXN+1],root;\nvector<int> vec[MAXN+1]; int P[MAXN+1];\ninline void Add(int k){\n\t++nod; for(int i=0,sz=vec[k].size();i<sz;i++){\n\t\tint j=vec[k][i];\n\t\tif(!vis[j]&&chs[j]!=k) vis[j]=k,que.push(j); \n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); T=2*N,S=0;\n\tmemset(Root,-1,sizeof(Root));\n\tfor(int i=1;i<N;i++){\n\t\tP[i]=read();\n\t\tinsert(S,i,1);\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tint x=read();\n\t\t\tvec[x].push_back(i);\n\t\t\tinsert(i,x+N-1,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) insert(i+N-1,T,1);\n\tint sum=0; while(BFS()) sum+=DFS(S,INF);\n\tif(sum!=N-1){ puts(\"-1\"); return 0; }\n\tint id=1; int now=0;\n\tfor(int i=1;i<N;i++){\n\t\tnow+=2;\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tif(!C[now]) chs[i]=Node[now]-(N-1);\n\t\t\tnow+=2;\n\t\t}\n\t}\n\twhile(now<cnt) {\n\t\tif(C[now]) {\n\t\t\troot=id; break;\n\t\t} now+=2; ++id;\n\t} \n\tAdd(root);\n\twhile(!que.empty()){ int k=que.front();  Add(chs[k]); que.pop(); }\n\tif(nod!=N){ puts(\"-1\"); return 0; }\n\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\",chs[i],vis[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--, q[a[i][j]].insert(i);\n        sort(a[i].begin(), a[i].end());\n        reverse(a[i].begin(), a[i].end());\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nconst int N = 100179;\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);return 0;\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UF {\n\tvi t;\n\tUF(int n){\n\t\tt.resize(n, -1);\n\t}\n\tint find(int a){\n\t\treturn t[a]<0 ? a : t[a] = find(t[a]);\n\t}\n\tbool same(int a, int b){\n\t\treturn find(a) == find(b);\n\t}\n\tvoid uni(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return;\n\t\tif(t[a] < t[b]) swap(a,b);\n\t\tt[b] += t[a];\n\t\tt[a] = b;\n\t}\n\tint ss(int a){\n\t\treturn -t[find(a)];\n\t}\n};\n\nvoid fail(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid rem(vector<pii> &v, pii p){\n\trep(i,0,sz(v)) if(v[i]==p){\n\t\tv.erase(v.begin()+i);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tint m = n-1;\n\n\tvector<vi> es(m);\n\ttrav(v, es){\n\t\tint c;\n\t\tcin >> c;\n\t\tv.resize(c);\n\t\ttrav(x, v) cin >> x, --x;\n\t}\n\tvector<vector<pii>> gr(n);\n\tvector<pii> uv(m);\n\tvector<bool> used(m, false);\n\tUF uf(n);\n\trep(i,0,m){\n\t\tint u = es[i][0];\n\t\ttrav(v, es[i]) if(!uf.same(v, u)){\n\t\t\tuf.uni(v, u);\n\t\t\tuv[i] = pii(u, v);\n\t\t\tgr[v].emplace_back(u, i);\n\t\t\tgr[u].emplace_back(v, i);\n\t\t\tused[i] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tset<pii> s;\n\trep(i,0,m) if(!used[i])\n\t\ts.insert(pii(uf.ss(es[i][0]),i));\n\n\tvi pix(n);\n\tvector<bool> vis(m, false);\n\t\n\twhile(!s.empty()){\n\t\tauto it = s.begin();\n\t\tpii pa = *it;\n\t\ts.erase(it);\n\t\tint l = pa.second;\n\t\tint v0 = es[l][0];\n\n\t\tif(pa.first != uf.ss(v0)){\n\t\t\ts.insert(pii(uf.ss(v0),l));\n\t\t\tcontinue;\n\t\t}\n\t\tpix[v0] = -1;\n\t\tstack<int> st;\n\t\tst.push(v0);\n\n\t\twhile(!st.empty()){\n\t\t\tint v = st.top(); st.pop();\n\t\t\trep(i,0,sz(gr[v])){\n\t\t\t\tint u, q;\n\t\t\t\ttie(u,q) = gr[v][i];\n\t\t\t\tif(q == pix[v]) continue;\n\t\t\t\tpix[u] = q;\n\t\t\t\tst.push(u);\n\t\t\t}\n\t\t}\n\n\t\tvi todo;\n\n\t\tfunction<bool(int)> rek = [&](int q){\n\t\t\tif(q < 0 || vis[q]) return false;\n\t\t\tvis[q] = true;\n\t\t\ttodo.push_back(q);\n\t\t\tint v = uv[q].first;\n\t\t\tif(pix[v]==q) v = uv[q].second;\n\t\t\tint w = uv[q].first^uv[q].second^v;\n\n\t\t\ttrav(u, es[q]) if(!uf.same(v, u)){\n\t\t\t\tuf.uni(v,u);\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(rek(pix[v])) return true;\n\t\t\ttrav(u, es[q]) if(rek(pix[u])){\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\ttrav(v, es[l]) if(rek(pix[v])){\n\t\t\tgr[v0].emplace_back(v,l);\n\t\t\tgr[v].emplace_back(v0,l);\n\t\t\tuv[l] = pii(v, v0);\n\t\t\tgoto bar;\n\t\t}\n\t\tfail();\n\t\tbar:\n\t\ttrav(q, todo) vis[q] = false;\n\n\t}\n\n\trep(i,0,m) cout << 1+uv[i].first << ' ' << 1+uv[i].second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,M=1000020,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint cnt,n,m,S,T,ans[N],ansu[N],h[N];\nvector<int> a[N],b[N];\nint fir[N],firr[N],siz;\nstruct edge{int u,v,w,nex;}e[M];\nvoid add(int u,int v,int w){\n\te[++siz]=(edge){u,v,w,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,0,fir[v]};fir[v]=siz;\n}\nint dist[N],que[N];\nvoid dec(int x,int fl){e[x].w-=fl;e[x^1].w+=fl;}\nbool bfs(){\n\tmemset(dist,0x3f,4*(cnt+1));\n\tint l=1,r=1;que[l]=S;dist[S]=0;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].w)&&(dist[e[i].v]>dist[x]+1)){\n\t\t\tque[++r]=e[i].v;\n\t\t\tdist[e[i].v]=dist[x]+1;\n\t\t}\n\t\tl++;\n\t}\n\treturn dist[T]!=inf;\n}\nint dfs(int x,int flow,int &T){\n\tif (x==T) return flow;\n\tint fl=0,t=0;\n\tfor (int i=firr[x];i;i=e[i].nex)\n\tif (e[i].w&&(dist[e[i].v]>dist[x])){\n\t\tt=dfs(e[i].v,min(flow-fl,e[i].w),T);\n\t\tdec(i,t);fl+=t;\n\t\tif (fl==flow) {firr[x]=i;return fl;}\n\t}\n\tfirr[x]=0;\n\treturn fl;\n}\nint dinic(){\n\tint flow=0;\n\twhile (bfs()){\n\t\tfor (int i=0;i<=cnt;i++) firr[i]=fir[i];\n\t\tflow+=dfs(S,inf,T);\n\t\t//cerr<<flow<<endl;\n\t}\n\treturn flow;\n}\nvoid check(int x){\n\th[x]=1;\n\tfor (auto i : b[x])\n\tif (!h[ans[i]]){ansu[i]=x;check(ans[i]);}\n}\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tsiz=1;\n\tn=read();S=1,T=cnt=n*2;\n\tfor (int i=2;i<=n;i++) add(S,i,1);\n\tfor (int i=1;i<n;i++) add(i+n,T,1);\n\tfor (int i=1;i<n;i++){\n\t\tint m=read();\n\t\twhile (m--){\n\t\t\tint x=read();a[i].push_back(x);\n\t\t\tb[x].push_back(i);\n\t\t\tif (x!=1) add(x,i+n,1);\n\t\t}\n\t}\n\tif (dinic()!=n-1){puts(\"-1\");return 0;}\n\tfor (int i=2;i<=siz;i++)\n\tif ((!e[i].w)&&(e[i].u>=1)&&(e[i].u<=n)&&(e[i].v>n)&&(e[i].v<n+n)) ans[e[i].v-n]=e[i].u;\n\tcheck(1);\n\tfor (int i=1;i<=n;i++) if (!h[i]) {puts(\"-1\");return 0;}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ansu[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nset<int> E[N],app[N];\nvector<pii> ans;\nset<pii> s;\nint n,c,w;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tread(c);\n\t\trep(j,1,c){\n\t\t\tread(w);\n\t\t\tE[i].insert(w);\n\t\t\tapp[w].insert(i);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts.insert(mp(app[i].size(),i));\n\t}\n\twhile(s.size()>=2){\n\t\tint x=s.begin()->se;\n\t\ts.erase(s.begin());\n\t\tif(!app[x].size())GG();\n\t\tint k=*app[x].begin();\n\t\tfor(auto t:app[x])\n\t\t\tif(E[t].size()<E[k].size())k=t;\n\t\tif(E[k].size()<app[x].size())GG();\n\t\tif(E[k].size()<2)GG();\n\t\tint U=*E[k].begin();\n\t\tint V=*(--E[k].end());\n\t\tif(x==U)ans.pb(mp(x,V));\n\t\telse ans.pb(mp(x,U));\n\t\tE[k].erase(x);\n\t\tapp[x].erase(k);\n\t\tfor(auto y:E[k]){\n\t\t\ts.erase(mp(app[y].size(),y));\n\t\t\tapp[y].erase(k);\n\t\t\ts.insert(mp(app[y].size(),y));\n\t\t}\n\t\tfor(auto t:app[x])\n\t\t\tE[t].erase(x);\n\t}\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n\tint v, cap, rev;\n\tedge(int a, int b, int c) : v(a), cap(b), rev(c) {}\n};\nvector<edge> adj[200005];\nint lst[200005], dep[200005];\nvoid add(int x, int y, int c)\n{\n\tadj[x].emplace_back(y, c, (int)adj[y].size());\n\tadj[y].emplace_back(x, 0, (int)adj[x].size() - 1);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint u = que.front();\n\t\tque.pop();\n\t\tfor (edge &e : adj[u]) {\n\t\t\tif (e.cap && dep[e.v] == -1) {\n\t\t\t\tdep[e.v] = dep[u] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int c)\n{\n\tif (u == t) {\n\t\treturn c;\n\t}\n\tint res = 0;\n\tfor (int &i = lst[u]; i >= 0; i--) {\n\t\tauto &e = adj[u][i];\n\t\tif (e.cap && dep[e.v] == dep[u] + 1) {\n\t\t\tint x = dfs(e.v, t, min(c - res, e.cap));\n\t\t\te.cap -= x;\n\t\t\tadj[e.v][e.rev].cap += x;\n\t\t\tres += x;\n\t\t\tif (res == c) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\tif (!res) {\n\t\tdep[u] = 0;\n\t}\n\treturn res;\n}\nint dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t)) {\n\t\tfor (int i = 0; i <= t; i++) {\n\t\t\tlst[i] = (int)adj[i].size() - 1;\n\t\t}\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nvector<int> have[200005];\nint ans[200005], node[200005];\nbool in[200005];\nint dfs(int u)\n{\n\tint res = 1;\n\tin[u] = true;\n\tfor (int x : have[u]) {\n\t\tif (!in[node[x]]) {\n\t\t\tans[x] = u;\n\t\t\tres += dfs(node[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\thave[--x].push_back(i);\n\t\t\tif (x) {\n\t\t\t\tadd(i + 1, x + n - 1, 1);\n\t\t\t}\n\t\t}\n\t\tadd(0, i + 1, 1);\n\t\tadd(i + n, n * 2, 1);\n\t}\n\tif (dinic(0, n * 2) != n - 1) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (edge &e : adj[i]) {\n\t\t\tif (e.v != 0 && !e.cap) {\n\t\t\t\tnode[i - 1] = e.v - n + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (dfs(0) != n) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcout << ans[i] + 1 << \" \" << node[i] + 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[201010];\nint match[201010];\nbool used[201010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        assert(false);\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint n,s,t;\nint tot,rd[200005],sz[200005],bg[200005],ed[200005],use[200005];\nint h[200005],fr[1000005],to[1000005],f[1000005],cnt=1;\nvoid add(int x,int y,int z)\n{\n\tfr[++cnt]=h[x];\n\th[x]=cnt;\n\tto[cnt]=y;\n\tf[cnt]=z;\n}\nint dis[200005];\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[now];i;i=fr[i])\n\t\t{\n\t\t\tif(f[i]&&dis[to[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[now]+1;\n\t\t\t\tif(to[i]==t)return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now)\n{\n\tif(now==t)return 1;\n\tfor(int i=use[now];i;i=fr[i])\n\t{\n\t\tuse[now]=i;\n\t\tif(dis[to[i]]==dis[now]+1&&f[i])\n\t\t{\n\t\t\tint r=dfs(to[i]);\n\t\t\tif(!r)dis[to[i]]=-1;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\t//cout<<now<<' '<<to[i]<<endl;\n\t\t\t\tf[i]=0;\n\t\t\t\tf[i^1]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=0;i<=t;i++)use[i]=h[i];\n\t\twhile(dfs(s))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nint bel[100005],rt,g[100005][2],fa[100005];\nvoid dfs1(int now)\n{\n\tcnt++;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(!fa[to[i]])\n\t\t{\n\t\t\tfa[to[i]]=now;\n\t\t\tg[bel[to[i]]][0]=now;g[bel[to[i]]][1]=to[i];\n\t\t\tdfs1(to[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&sz[i]);\n\t\tbg[i]=tot+1;\n\t\tfor(int j=1;j<=sz[i];j++)\n\t\t{\n\t\t\tscanf(\"%d\",&rd[tot+1]);\n\t\t\ttot++;\n\t\t}\n\t\ted[i]=tot;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tt=2*n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t\tfor(int j=bg[i];j<=ed[i];j++)\n\t\t{\n\t\t\tadd(rd[j],i+n,1);\n\t\t\tadd(i+n,rd[j],0);\n\t\t}\n\t}\n\tint flow=dinic();\n\t//cout<<flow<<endl;\n\tif(flow!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=h[i];j;j=fr[j])\n\t\t{\n\t\t\t//cout<<i<<' '<<to[j]<<endl;\n\t\t\tif(to[j]!=s&&f[j]==0)\n\t\t\t{\n\t\t\t\tbel[i]=to[j]-n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!bel[i])rt=i;\n\t\t//cout<<i<<' '<<bel[i]<<endl;\n\t}\n\tmemset(h,0,sizeof(h));\n\tcnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=rt)\n\t\t{\n\t\t\tfor(int j=bg[bel[i]];j<=ed[bel[i]];j++)\n\t\t\t{\n\t\t\t\tif(rd[j]!=i)add(rd[j],i,0);\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tdfs1(rt);\n\t//cout<<cnt<<endl;\n\tif(cnt!=n)printf(\"-1\");\n\telse\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",g[i][0],g[i][1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n, s, t;\nint hd[400005], nx[1000006], to[1000006], c[1000006], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid fadd(int f, int t, int c) { add(f, t, c), add(t, f, 0); }\n\nint dep[400005];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= t; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i]) {\n            if (!c[i] || dep[v = to[i]]) continue;\n            dep[v] = dep[u] + 1, q.push(v);\n        }\n    }\n    return dep[t];\n}\n\nint iter[400005];\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v, d; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        if (d = dfs(v, min(dist, c[i]))) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= t; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\n\nvector<int> e[400005];\nint p[400005];\nstruct Res {\n    int u, v;\n} res[400005];\nbool get_res() {\n    for (int u = 1; u < n; ++u)\n        for (int i = hd[u]; i; i = nx[i])\n            if (to[i] != s && c[i] == 0) p[u] = to[i] - n + 1;\n\n    int sum = 0;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        ++sum, q.pop();\n        for (int i = 0, v; i < e[u].size(); ++i)\n            if (p[v = e[u][i]]) res[v] = (Res){u, p[v]}, q.push(p[v]), p[v] = 0;\n    }\n    return sum == n;\n}\n\nint main() {\n    n = read(), s = 2 * n - 1, t = 2 * n, cnt = 1;\n    for (int i = 1; i < n; ++i) fadd(i + n - 1, t, 1);\n    for (int i = 1, c, u; i < n; ++i) {\n        c = read(), fadd(s, i, 1);\n        while (c--) {\n            if ((u = read()) != n) fadd(i, u + n - 1, 1);\n            e[u].push_back(i);\n        }\n    }\n    if (Dinic() < n - 1) return puts(\"-1\"), 0;\n    if (!get_res()) return puts(\"-1\"), 0;\n\n    for (int i = 1; i < n; ++i) printf(\"%d %d\\n\", res[i].u, res[i].v);\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define SZ 2333333\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define ad_de ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n;\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n#define mp make_pair\nvector<int> t[SZ],g[SZ],u[SZ];\nint fa[SZ],mat[SZ];\npii ts[SZ];\nvoid dfs(int x)\n{\n\tfor(auto s:u[x])\n\t{\n\t\tif(!mat[s]) continue;\n\t\tint p=mat[s];\n\t\tts[s]=pii(x,p);\n\t\tmat[s]=0;dfs(p);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b),\n\t\t\tt[i].pb(b),\n\t\t\tu[b].pb(i);\n\t}\n\tN=n+n+2; S=N-1; T=N;\n\tfor(int i=2;i<=n;++i)\n\t\tad_de(S,i,1);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(auto s:t[i])\n\t\t\tad_de(s,i+n,1),g[i].pb(M);\n\t\tad_de(i+n,T,1);\n\t}\n\tint s=dinic();\n\tif(s!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(int j=0;j<t[i].size();++j)\n\t\t\tif(cap[g[i][j]])\n\t\t\t\tmat[i]=t[i][j];\n\tfa[1]=-1; dfs(1);\n\tfor(int i=1;i<n;++i)\n\t\tif(!ts[i].fi)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",ts[i].fi,ts[i].se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nvoid init(){\n\tqueue<int> Q;\n\t++u[d[t]=1];Q.push(t);\n\twhile(!Q.empty()){\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=fr[x];i;i=nex[i])if(wi[i]&&!d[vi[i]]){\n\t\t\t++u[d[vi[i]]=d[x]+1];Q.push(vi[i]);\n\t\t}\n\t}\n}\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]]==0)d[s]=t+3;else ++u[++d[x]];\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;init();\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//const int MOD=1e9+7;\nconst int MOD=998244353;\n\nconst double PI=3.14159265359;\n\nclass Edge{\n    public:\n    int cap,flow,dest;\n    bool inGraph;\n    Edge *flEdgePair, *resEdgePair;\n    Edge(int _dest, int _cap, bool ing, int _flow=0):dest(_dest),inGraph(ing),\n    cap(_cap), flow(_flow){}\n    \n    void addFlow(int fl){\n        cap-=fl;\n        resEdgePair->cap+=fl;\n        if(inGraph) flEdgePair->flow+=fl;\n        else flEdgePair->flow-=fl;\n    }\n};\n\nclass Dinic{\n    public:\n    vector<vector<Edge*>> flow, res;\n    vector<int> dists, preds;\n    \n    int S,n,T;\n    Dinic(vector<vector<pair<int,int>>>& net):S(0), n(net.size()), T(n-1){\n        flow.resize(n);\n        res.resize(n);\n        dists.resize(n);\n        preds.resize(n);\n\t\tfill(preds.begin(), preds.end(),-1);\n        \n        for(int i=0; i<n; i++){\n            for(auto p:net[i]){\n                Edge* e1=new Edge(p.first, p.second, true);\n                Edge* e2=new Edge(i, 0, false);\n                Edge* e3=new Edge(p.first, p.second, true);\n                \n                e1->flEdgePair=e3;\n                e2->flEdgePair=e3;\n                e1->resEdgePair=e2;\n                e2->resEdgePair=e1;\n                flow[i].push_back(e3);\n                res[i].push_back(e1);\n                res[p.first].push_back(e2);\n            }\n        }\n    }\n    bool bfs(){\n        fill(dists.begin(), dists.end(),-1);\n        queue<int> q;\n        q.push(S);\n        dists[S]=0;\n        while(q.size()){\n            int cur=q.front();\n            q.pop();\n            for(auto e:res[cur]){\n                if(e->cap && dists[e->dest]==-1){\n                    dists[e->dest]=dists[cur]+1;\n                    q.push(e->dest);\n                }\n            }\n        }\n        return dists[T]!=-1;\n    }\n    \n    void dfs(){\n        vector<int> ep(n);\n        vector<bool> dead(n);\n        while(!dead[S]){\n            //vector<int> preds(n,-1);\n            stack<int> st;\n            st.push(0);\n            while(st.size()){\n                int cur=st.top();\n                //cout<<cur<<endl;\n                if(cur==T) break;\n                while(ep[cur]<res[cur].size() && (dead[res[cur][ep[cur]]->dest] ||\n                dists[res[cur][ep[cur]]->dest]!=dists[cur]+1 || \n                res[cur][ep[cur]]->cap==0)){\n                    ep[cur]++;\n                }\n                if(ep[cur]==res[cur].size()){\n                    dead[cur]=true;\n                    st.pop();\n                }\n                else{\n                    preds[res[cur][ep[cur]]->dest]=cur;\n                    st.push(res[cur][ep[cur]]->dest);\n                }\n            }\n            if(st.size() && st.top()==T){\n                //cout<<st.size()<<endl;\n                int flVal=1e9;\n                int cur=T;\n                while(cur!=S){\n                    //cout<<cur<<endl;\n                    cur=preds[cur];\n                    flVal=min(flVal,res[cur][ep[cur]]->cap);\n                }\n                cur=T;\n                while(cur!=S){\n                    cur=preds[cur];\n                    res[cur][ep[cur]]->addFlow(flVal);\n                }\n            }\n            else{\n                dead[S]=true;\n            }\n            \n        }\n        \n    }\n    \n    vector<vector<Edge*>> maxflow(){\n        //bfs();\n        //dfs();\n        while(bfs()){\n            dfs();\n        }\n        return flow;\n    }\n    \n    \n};\n\n\n\nint main(){\n    \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int n;\n    cin>>n;\n    \n    vector<vector<int>> e(n);\n    \n    for(int i=1; i<n; i++){\n        int t;\n        cin>>t;\n        e[i].resize(t);\n        for(int& j:e[i]) cin>>j;\n    }\n    \n    vector<vector<pair<int,int>>> net(2*n+1);\n    for(int i=1; i<=n; i++){\n        net[0].push_back({i,1});\n    }\n    for(int i=1; i<n; i++){\n        net[n+i].push_back({2*n,1});\n        for(int j:e[i]){\n            net[j].push_back({i+n,1});\n        }\n    }\n    /*\n    for(int i=0; i<=2*n; i++){\n        cout<<i<<\":\\n\";\n        for(auto p:net[i]){\n            cout<<p.first<<' ';\n        }\n        cout<<'\\n';\n    }\n    */\n    \n    Dinic din(net);\n    auto f=din.maxflow();\n    int fl=0;\n    \n    int start=-1;\n    \n    \n    for(auto e:f[0]){\n        fl+=e->flow;\n        if(!(e->flow)) start=e->dest;\n    }\n    if(fl!=n-1){\n        cout<<-1;\n        //cout<<fl<<endl;\n        return 0;\n    }\n    \n    queue<int> q;\n    q.push(start);\n    vector<int> preds(2*n+1,-1);\n    while(q.size()){\n        int cur=q.front();\n        q.pop();\n        for(auto e:din.res[cur]){\n            if(e->dest && e->cap && preds[e->dest]==-1){\n                preds[e->dest]=cur;\n                q.push(e->dest);\n            }\n        }\n    }\n    for(int i=n+1; i<2*n; i++){\n        if(preds[i]==-1){\n            cout<<-1;\n            return 0;\n        }\n    }\n    \n    vector<int> ans1(n);\n    for(int i=1; i<=n; i++){\n        for(auto e:f[i]){\n            if(e->flow){\n                ans1[e->dest-n]=i;\n            }\n        }\n    }\n    \n    for(int i=1; i<n; i++){\n        cout<<ans1[i]<<' '<<preds[i+n]<<'\\n';\n    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nvector<int> vis, deg, match, lmatch;\nvector<array<int, 2>> res;\nvector<int> adj[1<<17];\ndsu tmp(0);\nvoid process(int v) {\n\tvis[v] = 1;\n\tfor(auto u : adj[v]) if(match[u] != -1 && !vis[match[u]]) {\n\t\ttmp.unite(match[u], v);\n\t\tres[u] = {match[u], v};\n\t\tprocess(match[u]);\n\t}\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\ttmp = (n);\n\tdeg = vector<int>(n);\n\tmatch.resize(n, -1);\n\tlmatch.resize(n, -1);\n\tvis.resize(n);\n\tint kk = 0;\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j, assert(j-1 < n), deg[j-1]++, adj[j-1].push_back(kk);\n\t\tkk++;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching();\n\tres.resize(n-1);\n\tset<int> q;\n\tfor(int i = 0; i < n; i++) q.insert(i);\n\tfor(auto [i, x] : matching) {\n\t\tmatch[i-1] = x-n;\n\t\tlmatch[x-n] = i-1;\n\t\tq.erase(match[i-1]);\n\t}\n\tprocess(*q.begin());\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a << \" \" << b << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9+7;\nconst int N=1e5+2;\nint mat[N],par[N];\nstruct Dinic \n{\n   int n, s, t;\n   struct Edge \n   {\n      int to, cap, flow, rev;\n      Edge(int to = 0, int cap = 0, int flow = 0, int rev = 0) :\n         to(to), cap(cap), flow(flow), rev(rev) {}\n   };\n   vector <int> d;\n   vector <int> ptr;\n   vector<vector<Edge>> g;\n \n   Dinic(int n = 0, int s = 0, int t = 0) :\n      n(n), s(s), t(t), d(n + 2), ptr(n + 2), g(n + 2) {}\n   void addEdge(int u, int v, int cap) \n   {\n      g[u].emplace_back(v, cap, 0, g[v].size());\n      g[v].emplace_back(u, 0, 0, g[u].size() - 1);\n   }\n \n   bool bfs() \n   {\n      fill(d.begin(), d.end(), -1);\n      fill(ptr.begin(), ptr.end(), 0);\n \n      queue <int> q;\n      d[s] = 0;\n      q.push(s);\n      while (!q.empty()) \n      {\n         int u = q.front();\n         q.pop();\n         for (auto e : g[u]) \n         {\n            if (d[e.to] == -1 && e.cap > e.flow) \n            {\n               d[e.to] = d[u] + 1;\n               q.push(e.to);\n            }\n         }\n      }\n      return d[t] != -1;\n   }\n \n   int dfs(int u, int flow) \n   {\n      if (u == t) \n      {\n         return flow;\n      }\n      for (int &i = ptr[u]; i < (int)g[u].size(); i++) \n      {\n         auto &e = g[u][i];\n         if (e.cap <= e.flow || d[e.to] != d[u] + 1) \n            continue;\n         int nxt = dfs(e.to, min(flow, e.cap - e.flow));\n         if (nxt) \n         {\n            e.flow += nxt;\n            g[e.to][e.rev].flow -= nxt;\n            return nxt;\n         }\n      }\n      return 0;\n   }\n   int maxFlow() \n   {\n      int ans = 0;\n      while (bfs()) \n      {\n         while(true)\n         {\n            int now = dfs(s, inf);\n            if (now) ans += now;\n            else break;\n         }\n      }\n      return ans;\n   }\n   void trace(){\n   \t    for(int i=2;i<=(n-1)/2;i++){\n\t     for(int j=0;j<g[i].size();j++){\n\t     \t//cout<<g[i][j].cap<<' '<<g[i][j].flow<<' '<<i<<' '<<g[i][j].to<<endl;\n\t     \tif(g[i][j].cap==g[i][j].flow&&g[i][j].cap>0){\n\t     \t\tmat[g[i][j].to-(n-1)/2]=i;\n\t\t\t }\n\t\t }\n\t    }\n   }\n};\nvector<int> lis[N];\nbool used[N];\nvoid dfs1(int x){\n\tused[x]=true;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!used[mat[lis[x][i]]]){\n\t\t\tused[mat[lis[x][i]]]=true;\n\t\t\tpar[lis[x][i]]=x;\n\t\t\tdfs1(mat[lis[x][i]]);\n\t\t}\n\t}\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l;\n\tcin>>n;\n\tDinic dn(2*n+1,n+1,2*n+1);\n\tfor(i=2;i<=n;i++){\n\t\tcin>>j;\n\t\twhile(j--){\n\t\t\tcin>>k;\n\t\t\tlis[k].push_back(i);\n\t\t\tif(k!=1){\n\t\t\t\tdn.addEdge(k,n+i,1);\n\t\t\t}\n\t\t}\n\t\tdn.addEdge(n+1,i,1);\n\t\tdn.addEdge(i+n,2*n+1,1);\n\t}\n\tif(dn.maxFlow()!=n-1){\n\t\tcout<<\"-1\";\n\t\treturn 0;\n\t}\n\tdn.trace();\n//\tfor(i=1;i<=n;i++){\n//\t\tcout<<mat[i]<<endl;\n//\t}\n\tdfs1(1);\n\tfor(i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tcout<<\"-1\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=2;i<=n;i++){\n\t\tcout<<par[i]<<' '<<mat[i]<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 222222\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint E = MAX_V / 2;\nint s = MAX_V - 2;\nint g = MAX_V - 1;\nint mp[MAX_V/2];\nbool used[MAX_V/2];\nbool visited[MAX_V/2];\n\nvector<vector<int>> v(MAX_V / 2);\nvector<vector<int>> nv(MAX_V / 2);\nvector<pair<int,int>> ans;\n\nvoid dfs(int num){\n\tvisited[num] = true;\n\tREP(i,nv[num].size()){\n\t\tif(!visited[nv[num][i]]){\n\t\t\tans.EB(num, nv[num][i]);\n\t\t\tdfs(nv[num][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tREP(i,n) {\n\t\tif(i != n -1)add_edge(s,i,1);\n\t\tadd_edge(E+i,g,1);\n\t}\n\t\t\n\tREP(i,n-1){\n\t\t\n\t\tint e;cin >> e;\n\t\tREP(j,e){\n\t\t\tint tmp;cin >> tmp;tmp--;\n\t\t\tv[i].EB(tmp);\n\t\t\tadd_edge(i, E+tmp, 1);\n\t\t}\n\t}\n\t\n\tint seica = Dinic(s, g);\n\t//cout << \"seica is \" << seica << endl;\n\tif(seica != n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,n-1) {\n\t\tREP(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0){\n\t\t\t\tmp[i] = G[i][j].to - E;\n\t\t\t\tused[mp[i]] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n-1){\n\t\tREP(j,v[i].size()){\n\t\t\tif(v[i][j] != mp[i])nv[v[i][j]].EB(mp[i]);\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(!used[i])dfs(i);\n\t}\n\t\n\t//cout << \"ans is \" << ans.size() << endl;\n\t//SHOW1d(used,n);\n\tif(ans.size() == n-1){\n\t\tREP(i,ans.size()){\n\t\t\tcout << ans[i].FI + 1 << \" \" << ans[i].SE + 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UF {\n\tvi t;\n\tUF(int n){\n\t\tt.resize(n, -1);\n\t}\n\tint find(int a){\n\t\treturn t[a]<0 ? a : t[a] = find(t[a]);\n\t}\n\tbool same(int a, int b){\n\t\treturn find(a) == find(b);\n\t}\n\tvoid uni(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return;\n\t\tif(t[a] < t[b]) swap(a,b);\n\t\tt[b] += t[a];\n\t\tt[a] = b;\n\t}\n\tint ss(int a){\n\t\treturn -t[find(a)];\n\t}\n};\n\nvoid fail(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid rem(vector<pii> &v, pii p){\n\trep(i,0,sz(v)) if(v[i]==p){\n\t\tv.erase(v.begin()+i);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tint m = n-1;\n\n\tvector<vi> es(m);\n\ttrav(v, es){\n\t\tint c;\n\t\tcin >> c;\n\t\tv.resize(c);\n\t\ttrav(x, v) cin >> x, --x;\n\t}\n\tvector<vector<pii>> gr(n);\n\tvector<pii> uv(m);\n\tvector<bool> used(m, false);\n\tUF uf(n);\n\tvi perm(m);\n\tiota(all(perm), 0);\n\trandom_shuffle(all(perm));\n\ttrav(i, perm){\n\t\tint u = es[i][0];\n\t\ttrav(v, es[i]) if(!uf.same(v, u)){\n\t\t\tuf.uni(v, u);\n\t\t\tuv[i] = pii(u, v);\n\t\t\tgr[v].emplace_back(u, i);\n\t\t\tgr[u].emplace_back(v, i);\n\t\t\tused[i] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tset<pii> s;\n\trep(i,0,m) if(!used[i])\n\t\ts.insert(pii(uf.ss(es[i][0]),i));\n\n\tvi pix(n);\n\tvector<bool> vis(m, false);\n\t\n\twhile(!s.empty()){\n\t\tauto it = s.begin();\n\t\tpii pa = *it;\n\t\ts.erase(it);\n\t\tint l = pa.second;\n\t\tint v0 = es[l][0];\n\n\t\tif(pa.first != uf.ss(v0)){\n\t\t\ts.insert(pii(uf.ss(v0),l));\n\t\t\tcontinue;\n\t\t}\n\t\tpix[v0] = -1;\n\t\tstack<int> st;\n\t\tst.push(v0);\n\n\t\twhile(!st.empty()){\n\t\t\tint v = st.top(); st.pop();\n\t\t\trep(i,0,sz(gr[v])){\n\t\t\t\tint u, q;\n\t\t\t\ttie(u,q) = gr[v][i];\n\t\t\t\tif(q == pix[v]) continue;\n\t\t\t\tpix[u] = q;\n\t\t\t\tst.push(u);\n\t\t\t}\n\t\t}\n\n\t\tvi todo;\n\n\t\tfunction<bool(int)> rek = [&](int q){\n\t\t\tif(q < 0 || vis[q]) return false;\n\t\t\tvis[q] = true;\n\t\t\ttodo.push_back(q);\n\t\t\tint v = uv[q].first;\n\t\t\tif(pix[v]==q) v = uv[q].second;\n\t\t\tint w = uv[q].first^uv[q].second^v;\n\n\t\t\ttrav(u, es[q]) if(!uf.same(v, u)){\n\t\t\t\tuf.uni(v,u);\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(rek(pix[v])) return true;\n\t\t\ttrav(u, es[q]) if(rek(pix[u])){\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\ttrav(v, es[l]) if(rek(pix[v])){\n\t\t\tgr[v0].emplace_back(v,l);\n\t\t\tgr[v].emplace_back(v0,l);\n\t\t\tuv[l] = pii(v, v0);\n\t\t\tgoto bar;\n\t\t}\n\t\tfail();\n\t\tbar:\n\t\ttrav(q, todo) vis[q] = false;\n\n\t}\n\n\trep(i,0,m) cout << 1+uv[i].first << ' ' << 1+uv[i].second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\tassert(la == n - 1);\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        while ( (f = dfs(s,t,inf) ) > 0 ) ans += f;\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , n;\n\nint main(){\n\t\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<ctype.h>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f,oo = inf;\n#define pc putchar\n#define RG register\n#define gc getchar\ninline ll read(){\n\tRG ll x=0,f=1;RG char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tif(x<0)x=-x,pc('-');\n\tif(x>=10)write(x/10);\n\tputchar(x%10+'0');\n}\n#define rd read\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define rep(i,a,b) for(RG int i=(a);i<(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define y1 ________y1\n#define int ll\n#define N 1000005\n#define M 4000005\nstruct Edge{\n\tint to,nxt,cap;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap):to(to),nxt(nxt),cap(cap){};\n}edge[M*2];\nint first[N],cur[N],nume;\nvoid Addedge(int a,int b,int c){\n\tedge[nume] = Edge(b,first[a],c);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0);first[b] = nume++;\n}\nint q[N],dis[N],S,T,n,m,tot;\nbool bfs(){\n\tint front,rear;\n\tfront = rear = 0;\n\tmemset(dis,-1,sizeof(dis));\n\tq[rear++] = T;dis[T] = 1;\n\twhile(front < rear){\n\t\tint u = q[front++];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tint v=edge[e].to;\n\t\t\tif(edge[e^1].cap && dis[v]==-1){\n\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\tq[rear++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[S] != -1;\n}\nint dfs(int u,int flow){\n\tif(u==T) return flow;\n\tint used = 0,d;\n\tfor(int &e = cur[u];~e;e=edge[e].nxt){\n\t\tint v=edge[e].to;\n\t\tif(dis[u] == dis[v] + 1 && edge[e].cap && (d = dfs(v,min(flow-used,edge[e].cap)))){\n\t\t\tedge[e].cap -= d;\n\t\t\tedge[e^1].cap += d;\n\t\t\tused += d;\n\t\t}\n\t\tif(used == flow) break;\n\t}\n\tif(!used) dis[u] = -1;\n\treturn used;\n}\nint dinic(){\n\tll ans = 0;\n\twhile(bfs()){\n\t\tRep(i,1,tot) cur[i] = first[i];\n\t\tans += dfs(S,inf);\n\t}\n\treturn ans;\n}\nint id[N],Id[N],x[N];\nvector<int> g[N];\nsigned main(){\n\tmem(first,-1);nume = 0;\n\tn = read();\n\ttot = 0;\n\tS = ++tot;\n\tT = ++tot;\n\tRep(i,2,n){\n\t\tid[i] = ++tot;\n\t\tAddedge(id[i],T,1);\n\t}\n\tRep(i,1,n-1){\n\t\tId[i] = ++tot;\n\t\tAddedge(S,Id[i],1);\n\t\t//v[i] . resize(read());\n\t\tint t = read();\n\t\trep(j,0,t){\n\t\t\tint t = read();\n\t\t\tif(t != 1) Addedge(Id[i],id[t],1);\n\t\t\tg[t] . push_back(i);\n\t\t}\n\t}\n\tif(dinic() != n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tRep(i,1,n-1){\n\t\tint u = Id[i];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(e%2==0 && !edge[e].cap){\n//\t\t\t\tprintf(\"{%d %d}\\n\",u,edge[e].to);\n\t\t\t\tx[i] = edge[e].to - 1;\n\t\t\t}//完美，简直太棒了呀 \n\t\t}\n\t}\n\tqueue<int> Q;\n\tstatic bool vis[N];\n\tQ.push(1);vis[1]=true;\n\twhile(!Q.empty()){\n\t\tint u = Q.front();Q.pop();\n\t\tfor(auto v:g[u]){\n\t\t//\tprintf(\"{%d)\\n\",x[v]);\n\t\t\tif(!vis[x[v]]){\n\t\t\t\tvis[x[v]] = true;\n\t\t\t\tQ.push(x[v]);\n\t\t\t\tprintf(\"%d %d\\n\",u,x[v]);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],pos[N],vis[N],dis[N << 1],cur[N << 1];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline bool bfs() {\n\tqueue <int> q;\n\tmemset(dis,0,sizeof(dis));\n\tq.push(S),dis[S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front();q.pop();\n\t\tif(x == T) return true;\n\t\tfor(int i = beg[x];i;i = nex[i])\n\t\t\tif(!dis[to[i]] && flow[i]) {\n\t\t\t\tdis[to[i]] = dis[x] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int &i = cur[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] + 1 == dis[to[i]]) {\n\t\t\tint val = dfs(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\treturn f - res;\n}\n\nint main() {\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\twhile(bfs()) {\n\t\tmemcpy(cur,beg,sizeof(cur));\n\t\tans += dfs(S,INF);\n\t}\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include <cassert>\n#include <set>\n\nusing namespace std;\n\nstruct MaxFlow{\n  typedef long long ll;\n  const ll INF = 1e18;\n  struct Edge{\n    int u,v;\n    ll c,rc;\n    shared_ptr<ll> flow;\n    Edge(int _u, int _v, ll _c, ll _rc = 0):u(_u),v(_v),c(_c),rc(_rc){\n    }\n  };\n  struct FlowTracker{\n    ll cap, rcap;\n    shared_ptr<ll> flow;\n    bool dir;\n    FlowTracker(ll _cap, ll _rcap, shared_ptr<ll> _flow, int _dir):cap(_cap),rcap(_rcap),flow(_flow),dir(_dir){ }\n    ll rem() const {\n      if(dir == 0){\n        return cap-*flow;\n      }\n      else{\n        return rcap+*flow;\n      }\n    }\n    void add_flow(ll f){\n      if(dir == 0)\n        *flow += f;\n      else\n        *flow -= f;\n      assert(*flow <= cap);\n      assert(-*flow <= rcap);\n    }\n    operator ll() const { return rem(); }\n    void operator-=(ll x){ add_flow(x); }\n    void operator+=(ll x){ add_flow(-x); }\n  };\n  int source,sink;\n  vector<vector<int> > adj;\n  vector<vector<FlowTracker> > cap;\n  vector<Edge> edges;\n  MaxFlow(int _source, int _sink):source(_source),sink(_sink){\n    assert(source != sink);\n  }\n  int add_edge(int u, int v, ll c, ll rc = 0){\n    edges.push_back(Edge(u,v,c,rc));\n    return edges.size()-1;\n  }\n  vector<int> now,lvl;\n  void prep(){\n    int max_id = max(source, sink);\n    for(auto edge : edges)\n      max_id = max(max_id, max(edge.u, edge.v));\n    adj.resize(max_id+1);\n    cap.resize(max_id+1);\n    now.resize(max_id+1);\n    lvl.resize(max_id+1);\n    for(auto &edge : edges){\n      auto flow = make_shared<ll>(0);\n      adj[edge.u].push_back(edge.v);\n      cap[edge.u].push_back(FlowTracker(edge.c, edge.rc, flow, 0));\n      if(edge.u != edge.v){\n        adj[edge.v].push_back(edge.u);\n        cap[edge.v].push_back(FlowTracker(edge.c, edge.rc, flow, 1));\n      }\n      assert(cap[edge.u].back() == edge.c);\n      edge.flow = flow;\n    }\n  }\n  bool dinic_bfs(){\n    fill(now.begin(),now.end(),0);\n    fill(lvl.begin(),lvl.end(),0);\n    lvl[source] = 1;\n    vector<int> bfs(1,source);\n    for(int i = 0; i < (int) bfs.size(); ++i){\n      int u = bfs[i];\n      for(int j = 0; j < (int) adj[u].size(); ++j){\n        int v = adj[u][j];\n        if(cap[u][j] > 0 && lvl[v] == 0){\n          lvl[v] = lvl[u]+1;\n          bfs.push_back(v);\n        }\n      }\n    }\n    return lvl[sink] > 0;\n  }\n  ll dinic_dfs(int u, ll flow){\n    if(u == sink)\n      return flow;\n    while(now[u] < (int) adj[u].size()){\n      int v = adj[u][now[u]];\n      if(lvl[v] == lvl[u] + 1 && cap[u][now[u]] != 0){\n        ll res = dinic_dfs(v,min(flow,(ll)cap[u][now[u]]));\n        if(res > 0){\n          cap[u][now[u]] -= res;\n          return res;\n        }\n      }\n      ++now[u];\n    }\n    return 0;\n  }\n  ll calc_max_flow(){\n    prep();\n    ll ans = 0;\n    while(dinic_bfs()){\n      ll cur = 0;\n      do{\n        cur = dinic_dfs(source,INF);\n        ans += cur;\n      }while(cur > 0);\n    }\n    return ans;\n  }\n  ll flow_on_edge(int edge_index){\n    assert(edge_index < (int) edges.size());\n    return *edges[edge_index].flow;\n  }\n};\n\n// auto mf = MaxFlow(1,n);\n// arguments source and sink, memory usage\n// O(largest node index + input size), sink\n// doesn't need to be last index\n// int edge_index;\n// for(int i = 0; i < m; ++i){\n//    int a,b,c;\n//    cin >> a >> b >> c;\n//mf.add\\_edge(a,b,c); // for directed edges\n//      edge_index = mf.add_edge(a,b,c,c); // store edge index if care about flow value\n//   }\n//  cout << mf.calc_max_flow() << '\\n';\n//cout << mf.flow\\_on\\_edge(edge\\_index) << endl; // return flow on this edge\n//}\n\nvoid failure () {\n  cout << -1 << endl;\n  exit(0);\n}\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N]; // adj[v] is the set of edgesets v is in\n\nconst int HYPER = 1e5 + 5;\nconst int SOURCE = 2e5 + 10;\nconst int SINK = SOURCE + 1;\n\nint adder [MAX_N];\nint match [MAX_N]; // match[e] is the v matching to edgeset e\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  auto mf = MaxFlow(SOURCE, SINK);\n\n  vector<pair<pair<int, int>, int>> edges; // <<vertex, edgeset>, mf idx>\n  for (int i = 1; i < n; i++) {\n    int cnt;\n    cin >> cnt;\n\n    for (int j = 0; j < cnt; j++) {\n      int v;\n      cin >> v;\n\n      adj[v].push_back(i);\n      int idx = mf.add_edge(v, HYPER + i, 1);\n      edges.push_back({{v, i}, idx});\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    mf.add_edge(SOURCE, i, 1);\n  }\n\n  for (int i = 1; i < n; i++) {\n    mf.add_edge(HYPER + i, SINK, 1);\n  }\n\n  int flow = mf.calc_max_flow();\n  if (flow != n - 1) failure();\n  \n  set<int> freevs;\n  for (int i = 1; i <= n; i++) {\n    freevs.insert(i);\n  }\n\n  for (auto e : edges) {\n    if (mf.flow_on_edge(e.second) == 1) {\n      match[e.first.second] = e.first.first;\n      freevs.erase(e.first.first);\n    }\n  }\n\n  int start = *freevs.begin();\n\n  set<int> esets;\n  for (int e : adj[start]) {\n    esets.insert(e);\n    adder[e] = start;\n  }\n\n  vector<pair<int, int>> ans;\n  for (int i = 0; i < n - 1; i++) {\n    if (esets.empty()) failure();\n\n    int E = *esets.begin();\n    esets.erase(E);\n\n    int v = match[E];\n    for (int e : adj[v]) {\n      if (adder[e] == 0) {\n        esets.insert(e);\n        adder[e] = v;\n      }\n    }\n\n    ans.push_back({v, adder[E]});\n  }\n\n  for (auto pr : ans) {\n    cout << pr.first << \" \" << pr.second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 1e5 + 10;\n\nvector<int> E[maxn];\nint ord[maxn], u[maxn], v[maxn], par[maxn];\n\nint F(int u) { return par[u] == u ? u : par[u] = F(par[u]); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tauto BEG = clock();\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tord[i] = i;\n\t\tint sz;\n\t\tcin >> sz;\n\t\tE[i].resize(sz);\n\t\tfor (int j = 0; j < sz; ++j) cin >> E[i][j], --E[i][j];\n\t}\n\trandom_shuffle(ord, ord + n - 1);\n\tfor (int i = 0; i < n; ++i) par[i] = i;\n\tfor (int _i = 0; _i < n - 1; ++_i) {\n\t\tint i = ord[_i];\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tint u = E[i][0], anc = F(u), rem = -1;\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tfor (int v: E[i]) {\n\t\t\tif(F(v) != anc) {\n\t\t\t\trem = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(~rem) {\n\t\t\t::u[i] = u;\n\t\t\t::v[i] = rem;\n\t\t\tpar[F(u)] = F(rem);\n\t\t}\n\t\telse {\n\t\t\tif(1. * (clock() - BEG) > 3.6 * CLOCKS_PER_SEC) { puts(\"-1\"); return 0; }\n\t\t\tbool flag = 0;\n\t\t\tfor (int _j = _i - 1; ~_j; --_j) {\n\t\t\t\tint j = ord[_j];\n\t\t\t\tif(F(::u[j]) == anc) {\n\t\t\t\t\tint nrem = -1;\n\t\t\t\t\tfor (int v: E[ord[j]]) if(F(v) != anc) { nrem = v; break; }\n\t\t\t\t\tif(~nrem) {\n\t\t\t\t\t\t::v[j] = nrem;\n\t\t\t\t\t\tpar[F(::u[j])] = F(::v[j]);\n\t\t\t\t\t\t::u[i] = E[i][0];\n\t\t\t\t\t\t::v[i] = E[i][1];\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) { puts(\"-1\"); return 0; }\n\t\t}\n#ifdef DEBUGg\n\t\tcout << i << endl;\n\t\tfor (int i = 0; i < n - 1; ++i) cout << ::u[i] + 1 << ' ' << v[i] + 1 << endl;\n\t\tcout << '\\n';\n#endif\n\t}\n\tfor (int i = 0; i < n - 1; ++i) cout << u[i] + 1 << ' ' << v[i] + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FO(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define fo(i,j,k) for(int i=(j),end_i=(k);i<=end_i;i++)\n#define ff(i,j,k) for(int i=(j),end_i=(k);i< end_i;i++)\n#define fd(i,j,k) for(int i=(j),end_i=(k);i>=end_i;i--)\n#define DEBUG(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(x) (x).begin(),(x).end()\n#define cle(x) memset(x,0,sizeof(x))\n#define lowbit(x) ((x)&-(x))\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define lb long db\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ninline int read()\n{\n\tint x=0; char ch=getchar(); bool f=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\n#define CASET fo(___,1,read())\n\nconst int N=200010;\nconst int M=2000000;\nnamespace Dinic{\n\tconst int inf=2e9;\n\tint s,t;\n\tint head[N],cur[N],ne[M],ver[M],val[M],tot=1;\n\tint d[N];\n\tqueue<int> q;\n\tinline void add(int x,int y,int v)\n\t{\n\t\tver[++tot]=y; val[tot]=v; ne[tot]=head[x]; head[x]=tot;\n\t\tver[++tot]=x; val[tot]=0; ne[tot]=head[y]; head[y]=tot;\n\t}\n\tinline bool bfs()\n\t{\n\t\tfo(i,0,t) cur[i]=head[i];\n\t\tfor(;!q.empty();q.pop());\n\t\tfo(i,0,t) d[i]=-1; q.push(s); d[s]=0;\n\t\tfor(int u,v;!q.empty();)\n\t\t{\n\t\t\tu=q.front(); q.pop();\n\t\t\tfor(int i=head[u];i;i=ne[i])\n\t\t\t\tif(val[i]&&d[v=ver[i]]==-1)\n\t\t\t\t{\n\t\t\t\t\td[v]=d[u]+1,q.push(v);\n\t\t\t\t\tif(v==t) return 1;\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int flow)\n\t{\n\t\tif(!flow||u==t) return flow;\n\t\tint res=flow,r,v;\n\t\tfor(int &i=cur[u];i;i=ne[i])\n\t\t\tif(val[i]&&d[v=ver[i]]==d[u]+1)\n\t\t\t{\n\t\t\t\tr=dfs(v,min(res,val[i]));\n\t\t\t\tif(!r) continue;\n\t\t\t\tval[i]-=r; val[i^1]+=r;\n\t\t\t\tres-=r; if(!res) break;\n\t\t\t}\n\t\treturn flow-res;\n\t}\n\tint dinic()\n\t{\n\t\tint flow=0;\n\t\twhile(bfs()) flow+=dfs(s,inf);\n\t\treturn flow;\n\t}\n}\nusing namespace Dinic;\nint n;\nint X[N],Y[N],cnt;\nbool vis[N];\nvoid dfs(int u)\n{\n\tfor(int i=head[u],v;i;i=ne[i])\n\t\tif((v=ver[i])!=s&&!vis[v-n])\n\t\t{\n\t\t\tvis[v-n]=1;\n\t\t\tfor(int j=head[v];j;j=ne[j])\n\t\t\t\tif(val[j])\n\t\t\t\t\tcnt++,X[v-n]=u,Y[v-n]=ver[j],dfs(ver[j]);\n\t\t}\n}\nint main()\n{\n\tn=read();\n\tDinic::t=2*n;\n\ts=0; t=2*n;\n\tff(i,n+1,2*n) CASET add(read(),i,1);\n\tfo(i,1,n) add(s,i,1);\n\tff(i,n+1,2*n) add(i,t,1);\n\tif(dinic()!=n-1) return puts(\"-1\")&0;\n\tint root;\n\tfor(int i=head[0];i;i=ne[i]) if(val[i]) root=ver[i];\n\tdfs(root);\n\tif(cnt!=n-1) return puts(\"-1\")&0;\n\tff(i,1,n) printf(\"%d %d\\n\",X[i],Y[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tvis[v2[x][i]]=1;\n\t\tson[x].push_back(ma[v2[x][i]]);\n\t}\n\tfor(int i=0;i<(int)son[x].size();i++)dfs(son[x][i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,h[200005],cnt=1,pre[200005],s,t,p[200005],num;\nvector<int> e[200005];\nstruct que\n{\n\tint x,y;\n}hs[200005];\nstruct Edge\n{\n\tint to,next,d;\n}w[800005];\nvoid add(int x,int y,int d)\n{\n\tw[++cnt]=(Edge){y,h[x],d};\n\th[x]=cnt;\n\tw[++cnt]=(Edge){x,h[y],0};\n\th[y]=cnt;\n}\nbool bfs()\n{\n\tmemset(pre,0,sizeof(pre));\n\tpre[s]=1;\n\tqueue<int> q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[u];i;i=w[i].next)\n\t\t{\n\t\t\tint to=w[i].to;\n\t\t\tif(w[i].d&&!pre[to])\n\t\t\t{\n\t\t\t\tpre[to]=pre[u]+1;\n\t\t\t\tif(to==t) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int x,int p)\n{\n\tif(x==t||!p) return p;\n\tint r=p;\n\tfor(int i=h[x];i;i=w[i].next)\n\t{\n\t\tint to=w[i].to;\n\t\tif(r&&w[i].d&&pre[to]==pre[x]+1)\n\t\t{\n\t\t\tint p2=dfs(to,min(r,w[i].d));\n\t\t\tif(p2)\n\t\t\t{\n\t\t\t\tw[i].d-=p2,w[i^1].d+=p2;\n\t\t\t\tr-=p2;\n\t\t\t}\n\t\t\tif(!r) return p;\n\t\t}\n\t}\n\tif(r==p) pre[x]=0;\n\treturn p-r;\n}\nint Dinic()\n{\n\tint ans=0;\n\twhile(bfs()) ans+=dfs(s,0x3f3f3f3f);\n\treturn ans;\n}\nbool Solve()\n{\n\tfor(int i=1;i<n;i++)\n\tfor(int j=h[i];j;j=w[j].next)\n\t{\n\t\tint to=w[j].to;\n\t\tif(!to) continue;\n\t\tif(!w[j].d) p[i]=to-n+1;\n\t}\n\tqueue<int> q;\n\tq.push(n);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tnum++;\n\t\tint sz=e[u].size();\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tint x=e[u][i];\n\t\t\tif(p[x]) hs[x]=((que){u,p[x]}),q.push(p[x]),p[x]=0;\n\t\t}\n\t}\n\treturn num==n;\n}\nint main()\n{\n\tn=read();\n\ts=0,t=2*n-1;\n\tfor(int i=1;i<=n-1;i++) add(s,i,1),add(i+n-1,t,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint num=read();\n\t\twhile(num--)\n\t\t{\n\t\t\tint x=read();\n\t\t\tif(x!=n) add(i,x+n-1,1);\n\t\t\te[x].push_back(i);\n\t\t}\n\t}\n\tif(Dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",hs[i].x,hs[i].y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200100;\n\nvector<int> g[N];\n\nbool mark[N];\nint match[N];\nint n;\n\nbool dfs(int v) {\n  if (mark[v]) {\n    return false;\n  }\n  mark[v] = true;\n  for (int to : g[v]) {\n    if (match[to] == -1 || dfs(match[to])) {\n      match[to] = v;\n      match[n + v] = to;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching() {\n  memset(match, -1, sizeof match);\n  while (true) {\n    memset(mark, false, sizeof mark);\n    bool done = true;\n    for (int i = 0; i < n - 1; i++) {\n      if (match[n + i] == -1) {\n        done &= !dfs(i);\n      }\n    }\n    if (done) {\n      break;\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n - 1; i++) {\n    res += (match[n + i] != -1);\n  }\n  return res;\n}\n\nvector<pair<int, int>> ed;\n\nvoid make(int v) {\n  mark[v] = 1;\n  for (int to : g[n + v]) {\n    if (!mark[to]) {\n      ed.emplace_back(v, match[to]);\n      make(match[to]);\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int c;\n    cin >> c;\n    while (c--) {\n      int x;\n      cin >> x;\n      --x;\n      g[i].push_back(x);\n      g[n + x].push_back(i);\n    }\n  }\n  if (matching() != n - 1) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int root = -1;\n  for (int i = 0; i < n; i++) {\n    if (match[i] == -1) {\n      root = i;\n      break;\n    }\n  }\n  memset(mark, 0, sizeof mark);\n  make(root);\n  if ((int) ed.size() != n - 1) {\n    cout << -1 << '\\n';\n  } else {\n    for (auto e : ed) {\n      cout << e.first + 1 << \" \" << e.second + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nnamespace Dinic {\n\tconst int N = 2e5 + 7, M = 2e6 + 7;\n\tconst ll inf = 1e18;\n\tint n, S, T, d[N];\n\tint h[N], hi[N], e[M], t[M], tot;\n\tll f[M], mxf;\n\n\tinline void add(int x, int y, ll z, bool o = 1) {\n\t\te[++tot] = y, f[tot] = z, t[tot] = h[x], h[x] = tot;\n\t\tif (o) add(y, x, 0, 0);\n\t}\n\n\tinline bool bfs() {\n\t\tfor (int i = 1; i <= n; i++) d[i] = 0;\n\t\tqueue<int> q;\n\t\tq.push(S), d[S] = 1;\n\t\twhile (q.size()) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = h[x]; i; i = t[i]) {\n\t\t\t\tint y = e[i];\n\t\t\t\tll z = f[i];\n\t\t\t\tif (d[y] || !z) continue;\n\t\t\t\tq.push(y), d[y] = d[x] + 1;\n\t\t\t\tif (y == T) return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll dfs(int x, ll now = inf) {\n\t\tif (x == T) return now;\n\t\tll rst = now;\n\t\tfor (int &i = hi[x]; i; i = t[i]) {\n\t\t\tint y = e[i];\n\t\t\tll z = f[i];\n\t\t\tif (d[y] != d[x] + 1 || !z) continue;\n\t\t\tll k = dfs(y, min(z, rst));\n\t\t\tif (!k) d[y] = 0;\n\t\t\telse f[i] -= k, f[i^1] += k, rst -= k;\n\t\t\tif (!rst) break;\n\t\t}\n\t\treturn now - rst;\n\t}\n\n\tinline void main() {\n\t\twhile (bfs()) {\n\t\t\tfor (int i = 1; i <= n; i++) hi[i] = h[i];\n\t\t\tll now;\n\t\t\twhile ((now = dfs(S))) mxf += now;\n\t\t}\n\t}\n\n\tinline void init(int _n, int _S, int _T) {\n\t\tn = _n, S = _S, T = _T, tot = 1, mxf = 0;\n\t\tfor (int i = 1; i <= n; i++) h[i] = 0; \n\t}\n}\nusing Dinic::add;\n\nconst int N = 1e5 + 7;\nint n, f[N], fa[N], id[N];\nset<int> e[N], g[N];\nbool v[N];\npi ans[N];\n\nint main() {\n\trd(n), Dinic::init(2 * n, 1, 2 * n);\n\tfor (int i = 1, c, x; i < n; i++) {\n\t\tadd(1, i + 1, 1), add(i + n, 2 * n, 1);\n\t\trd(c);\n\t\twhile (c--) {\n\t\t\trd(x), e[i].insert(x), g[x].insert(i);\n\t\t\tif (x == 1) continue;\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\tDinic::main();\n\tif (Dinic::mxf != n - 1) return print(-1), 0;\n\tfor (int x = 1; x < n; x++)\n\t\tfor (int i = Dinic::h[x+n]; i; i = Dinic::t[i])\n\t\t\tif (Dinic::e[i] <= n && Dinic::f[i]) f[x] = Dinic::e[i];\n\tqueue<int> q;\n\tq.push(1);\n\twhile (q.size()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor (int y : g[x])\n\t\t\tif (!v[y]) v[y] = 1, fa[f[y]] = x, id[f[y]] = y, q.push(f[y]);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tif (!v[i]) return print(-1), 0;\n\tfor (int i = 2; i <= n; i++) ans[id[i]] = mp(fa[i], i);\n\tfor (int i = 1; i < n; i++) print(ans[i].fi, ans[i].se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\trep(i, 1, n - 1) assert(bl[i] > 1 && bl[i] <= n);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    for (int it = 0; it < n - 1; it++) {\n      assert(!q.empty());\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v + 1, done + 1);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back({x,i,mxfl::adde(x,i+n,1)});\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << #x << ':' << x << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate<class T> class Dinic {\n\tstruct edge {\n\t\tint to;\n\t\tT cap, icap;\n\t\tint rev;\n\t};\n\tvector<vector<edge>> graph;\n\tvector<int> level, iter;\npublic:\n\tDinic(int n) {\n\t\tgraph = vector<vector<edge>>(n, vector<edge>());\n\t\tlevel = iter = vector<int>(n);\n\t}\n\tvoid add_edge(int from, int to, T cap) {\n\t\tgraph[from].push_back({ to,cap,cap,(int)graph[to].size() });\n\t\tgraph[to].push_back({ from,0,0,(int)graph[from].size() - 1 });\n\t}\n\tvoid bfs(int s) {\n\t\tfor (int &i : level) i = -1;\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < graph[v].size(); i++) {\n\t\t\t\tedge &e = graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tT dfs(int v, int t, T f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < graph[v].size(); i++) {\n\t\t\tedge &e = graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tT d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s, int t) {\n\t\tT flow = 0;\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfor (int &i : iter) i = 0;\n\t\t\tT f = 0;\n\t\t\twhile ((f = dfs(s, t, inf)) > 0) flow += f;\n\t\t}\n\t}\n\tvector<P> bipartite_matching(int s, int t) {\n\t\tvector<P> res;\n\t\tmax_flow(s, t);\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tif (i == s) continue;\n\t\t\tfor (edge e : graph[i]) {\n\t\t\t\tif (e.cap == 0 && e.icap == 1 && e.to != t) {\n\t\t\t\t\tres.push_back({ i,e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n;\n\tcin >> n;\n\tDinic<int> flow(2 * n + 2);\n\tvector<vector<int>> pl(n, vector<int>());\n\trep(i, n - 1) {\n\t\tint sz;\n\t\tcin >> sz;\n\t\trep(j, sz) {\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tv--;\n\t\t\tpl[v].pb(i);\n\t\t\tflow.add_edge(i, n + v, 1);\n\t\t}\n\t}\n\trep(i, n) {\n\t\tflow.add_edge(2 * n, i, 1);\n\t\tflow.add_edge(n + i, 2 * n + 1, 1);\n\t}\n\tvector<P> match = flow.bipartite_matching(2 * n, 2 * n + 1);\n\tsort(all(match));\n\tif (match.size() != n - 1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tvector<P> ans(n - 1);\n\trep(i, n - 1) ans[i].first = match[i].second - n;\n\tvector<bool> ap(n);\n\trep(i, n - 1) ap[ans[i].first] = true;\n\tint st = -1;\n\trep(i, n) if (!ap[i]) st = i;\n\tvector<bool> vis(n), use(n - 1);\n\tvis[st] = true;\n\tqueue<int> que;\n\tque.push(st);\n\twhile (!que.empty()) {\n\t\tint q = que.front(); que.pop();\n\t\tfor (int i : pl[q]) {\n\t\t\tif (!use[i] && !vis[ans[i].first]) {\n\t\t\t\tans[i].second = q;\n\t\t\t\tuse[i] = true;\n\t\t\t\tvis[ans[i].first] = true;\n\t\t\t\tque.push(ans[i].first);\n\t\t\t}\n\t\t}\n\t}\n\tbool ok = true;\n\trep(i, n) if (!vis[i]) ok = false;\n\tif (ok) rep(i, n - 1) cout << ans[i].first + 1 << ' ' << ans[i].second + 1 << '\\n';\n\telse cout << \"-1\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn << 1];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[201010];\nint match[201010];\nbool used[201010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=8e5+9,inf=1e8;\n\tint head[N],nex[N],to[N],fl[N],cnt=1;\n\tinline void add(int u,int v,int flow){\n\t//\tcout<<u<<\" \"<<v<<\" \"<<flow<<endl;\n\t\tnex[++cnt]=head[u],head[u]=cnt,to[cnt]=v,fl[cnt]=flow;\n\t\tnex[++cnt]=head[v],head[v]=cnt,to[cnt]=u,fl[cnt]=0;\n\t}\n\tint S,T,dist[N],cur[N];\n\tqueue<int> q;\n\tinline bool bfs(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=T;i++) dist[i]=inf;\n\t\tq.push(S),dist[S]=0;\n\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tif(u==T) return 1;\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(fl[i] && dist[to[i]]==inf){\n\t\t\t\t\tdist[to[i]]=dist[u]+1;\n\t\t\t\t\tq.push(to[i]);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tinline int dfs(int u,int flow){\n\t\tif(u==T) return flow;\n\t\tint rest=flow,k;\n\t\tfor(int &i=cur[u];rest && i;i=nex[i])\n\t\t\tif(fl[i] && dist[to[i]]==dist[u]+1){\n\t\t\t\tk=dfs(to[i],min(fl[i],flow));\n\t\t\t\tfl[i]-=k,fl[i^1]+=k,rest-=k;\n\t\t\t}\n\t\treturn flow-rest;\n\t}\n\n\tint n,mat[N],vis[N];\n\tvector<int> pos[N],E[N],ans[N];\n\tinline bool fortry(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!mat[i+n-1]){q.push(i);break;}\n\n\t\tint tot=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();tot++;\n\t\t\tfor(int i=0;i<pos[u].size();i++) if(!vis[pos[u][i]]){\n\t\t\t\tint id=pos[u][i];\n\t\t\t\tvis[pos[u][i]]=1,ans[id].push_back(mat[id]-n+1),ans[id].push_back(u);\n\t\t\t\tq.push(mat[id]-n+1);\n\t\t\t}\n\t\t}\n\t\tif(tot!=n) return 0;\n\t\treturn 1;\n\t}\n\tint main(){\n\t\tn=read<int>();\n\t\tS=n-1+n+1,T=S+1;\n\t\tfor(int t=1;t<n;t++){\n\t\t\tint k=read<int>();\n\t\t\tfor(int i=1;i<=k;i++){\n\t\t\t\tint u=read<int>();\n\t\t\t\tE[t].push_back(u),pos[u].push_back(t);\n\t\t\t\tadd(t,u+n-1,1);\n\t\t\t}\n\t\t\tadd(S,t,1);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+n-1,T,1);\n\t\tint mxfl=0;\n\t\twhile(bfs()){\n\t\t\tfor(int i=1;i<=T;i++) cur[i]=head[i];\n\t\t\tint d;\n\t\t\tdo{d=dfs(S,inf),mxfl+=d;}while(d);\n\t\t}\n\t\tif(mxfl!=n-1) puts(\"-1\"),exit(0);\n\t\tfor(int u=1;u<n;u++)\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(!fl[i]){mat[u]=to[i],mat[to[i]]=u;break;}\n\t\tif(!fortry()) puts(\"-1\"),exit(0);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][0]);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, tot = 0;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n), g(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j) {\n      fnd[--e[i][j]].push_back(i);\n      if (j) {\n        g[e[i][j]].push_back(e[i][0]);\n        g[e[i][0]].push_back(e[i][j]);\n      }\n    }\n    tot += c;\n  }\n  vector<int> from(n - 1, -1), dfn(n, -1);\n  int tm = 0;\n  function<void(int)> dfs = [&](int u) {\n    dfn[u] = tm++;\n    for (int v : g[u])\n      if (dfn[v] == -1)\n        dfs(v);\n  };\n  dfs(0);\n  if (count(dfn.begin(), dfn.end(), -1)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int myn = e[i][0];\n    for (size_t j = 1; j < e[i].size(); ++j)\n      if (dfn[e[i][j]] < dfn[myn])\n        myn = e[i][j];\n    from[i] = myn;\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i])\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i)\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i] && eref[i][j].get())\n        cout << (from[i] + 1) << ' ' << (e[i][j] + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// constructor(n)\n// addEdge(a, b) // bipartite graph (undirected)\n// === build() returns max flow ===\n// O(VE) but very fast\n// match[i] = some or -1\n// === restoreMinVertexCover() ===\n// O(V + E)\n// vertexCovered[i] = 1 or 0\n// === restoreMaxStableSet() ===\n// alias of previous\n// stable[i] = 1 or 0\n// === restoreMinEdgeCover() ===\n// O(V + E)\n// isolated cannot be covered\n// match2[i] = 1 or 0\n/// --- BipartiteMatching Library {{{ ///\nstruct BipartiteMatching {\n  int n;\n  vector< vector< int > > g;\n  BipartiteMatching(int n) : n(n), g(n) {}\n  void addEdge(int a, int b) {\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  vector< int > match;\n\nprivate:\n  vector< int > used;\n\npublic:\n  int build() {\n    match = vector< int >(n, -1);\n    int flow = 0;\n    for(int i = 0; i < n; i++) {\n      if(match[i] < 0) {            ///\n        used = vector< int >(n, 0); ///\n        if(dfs(i)) flow++;\n      }\n    }\n    return flow;\n  }\n  vector< int > vertexCovered;\n  vector< int > stable;\n  inline void restoreMaxStableSet() { restoreMinVertexCover(); }\n  void restoreMinVertexCover() {\n    vertexCovered = vector< int >(n);\n    stable = vector< int >(n, 1);\n    vector< int > used0(n), used1(n);\n    vector< int > color(n);\n    vector< int > red(n);\n    for(int i = 0; i < n; i++)\n      if(!used0[i]) {\n        // bfs\n        queue< int > q0;\n        queue< int > q1;\n        q0.emplace(i);\n        used0[i] = 1;\n        while(q0.size()) {\n          int j = q0.front();\n          q0.pop();\n          if(color[j] == 0 && match[j] == -1) q1.emplace(j);\n          for(int k : g[j])\n            if(!used0[k]) {\n              used0[k] = 1;\n              color[k] = color[j] ^ 1;\n              q0.emplace(k);\n            }\n        }\n        used1[i] = 1;\n        while(q1.size()) {\n          int j = q1.front();\n          q1.pop();\n          red[j] = 1;\n          if(color[j] == 1) {\n            if(match[j] != -1) q1.emplace(match[j]);\n          } else {\n            for(int k : g[j])\n              if(!used1[k] && k != match[j]) {\n                used1[k] = 1;\n                q1.emplace(k);\n              }\n          }\n        }\n      }\n    for(int i = 0; i < n; i++)\n      if(color[i] ^ red[i] ^ 1) vertexCovered[i] = 1, stable[i] = 0;\n  }\n  vector< int > match2;\n  void restoreMinEdgeCover() {\n    match2 = match;\n    for(int i = 0; i < n; i++)\n      if(match2[i] == -1) {\n        for(int j : g[i])\n          if(match2[j] == -1) {\n            match2[i] = j;\n            match2[j] = i;\n            break;\n          }\n      }\n  }\n\nprivate:\n  bool dfs(int v) {\n    if(used[v]) return false; ///\n    used[v] = 1;\n    for(int u : g[v])\n      if(match[u] < 0 || dfs(match[u])) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    return false;\n  }\n};\n/// }}}--- ///\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := xを要素に持つグループら\n\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// メモ：\n// k個のグループにk頂点しか無い場合は自明にループができるので不可\n// よって (k+1) 頂点以上に繋がってていなきゃいけない\n// そのとき k 頂点に必ず繋がっていることになる\n// これは結婚定理と同じ条件なので，必ずn-1本のマッチングが存在することになる\n\n// すると E_i has i を必ず達成できるように番号付けできる\n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} が成り立ってはいけない，と言い換えられる\n// どのような頂点からはじめても，頂点Nにたどり着けなければならない\n// 頂点Nから逆にたどってやって，全てにたどり着けるかだけ調べればいい\n\n// その仮定で，そのDFS木をそのまま構成する木にできる\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  BipartiteMatching eca(n - 1 + n);\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      eca.addEdge(i, n - 1 + x);\n    }\n  }\n  int sz = eca.build();\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(int i = 0; i < n - 1; i++) {\n    int v = eca.match[i] - (n - 1);\n    ans[i][0] = v;\n    found[v] = 1;\n  }\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, c, u;\n\nvector<int> edge[108000];\nvector<int> ans[108000];\nbool come[108000];\n\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tedge[i].push_back(n + u);\n\t\t\tedge[n+u].push_back(i);\n\t\t}\t\n\t}\n\tdfs(n+1);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\n\n\nconst int INF = 1.01e9;\n\n\n\nstruct Edge {\n    int to, cap, flow;\n};\n\nstruct Graph {\n    int n;\n    vector<vector<int> > e;\n    vector<Edge> edges;\n    vector<int> d, c;\n\n    Graph() {}\n    Graph(int _n) {\n        n = _n;\n        e.resize(n);\n    }\n\n    void addEdge(int from, int to, int cap) {\n        e[from].push_back(edges.size());\n        edges.push_back(Edge({to, cap, 0}));\n        e[to].push_back(edges.size());\n        edges.push_back(Edge({from, 0, 0}));\n    }\n\n    bool bfs() {\n        d.assign(n, INF);\n        c.assign(n, 0);\n        vector<int> q(n);\n        int qL = 0, qR = 0;\n        d[0] = 0;\n        q[qR++] = 0;\n        while (qL < qR) {\n            int v = q[qL++];\n            for (int i = 0; i < (int)e[v].size(); i++) {\n                Edge cur = edges[e[v][i]];\n                if (d[cur.to] > d[v] + 1 && cur.flow < cur.cap) {\n                    d[cur.to] = d[v] + 1;\n                    q[qR++] = cur.to;\n                }\n            }\n        }\n        return d[n - 1] != INF;\n    }\n\n    int dfs(int v, int flow) {\n        if (v == n - 1) return flow;\n        if (flow == 0) return 0;\n        for (int &i = c[v]; i < (int)e[v].size(); i++) {\n            Edge cur = edges[e[v][i]];\n            if (d[cur.to] != d[v] + 1) continue;\n            int pushed = dfs(cur.to, min(flow, cur.cap - cur.flow));\n            if (pushed > 0) {\n                edges[e[v][i]].flow += pushed;\n                edges[e[v][i] ^ 1].flow -= pushed;\n                return pushed;\n            }\n        }\n        return 0;\n    }\n\n    ll flow() {\n        ll flow = 0;\n        while (bfs()) {\n            while (int pushed = dfs(0, INF)) {\n                flow += pushed;\n            }\n        }\n        return flow;\n    }\n};\n\nvoid print(vector<pair<int, int>> a) {\n    if (a.empty()) printf(\"%d\\n\", -1);\n    else for (auto o : a) printf(\"%d %d\\n\", o.first + 1, o.second + 1);\n}\n\nvector<pair<int, int>> solve(vector<vector<int>> a) {\n    int n = a.size() + 1;\n\n    Graph gr(1 + n-1 + n + 1);\n    for (int i = 0; i < n-1; i++) {\n        gr.addEdge(0, 1 + i, 1);\n    }\n    for (int i = 0; i < n-1; i++) {\n        for (int x : a[i]) {\n            gr.addEdge(1 + i, 1 + n-1 + x, 1);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        gr.addEdge(1 + n-1 + i, 1 + n-1 + n, 1);\n    }\n    int fl = gr.flow();\n\n    if (fl != n-1) {\n        return vector<pair<int, int>>();\n    }\n\n    vector<pair<int, int>> e1, e2;\n    for (int i = 0; i < n-1; i++) {\n        for (auto id : gr.e[1 + i]) {\n            auto ed = gr.edges[id];\n            if (ed.to >= 1 + n-1 && ed.to < 1 + n-1 + n) {\n                if (ed.flow > 0) {\n                    e1.push_back({i, ed.to - (1 + n-1)});\n                } else {\n                    e2.push_back({i, ed.to - (1 + n-1)});\n                }\n            }\n        }\n    }\n    assert(e1.size() == n-1);\n\n    vector<int> cov(n);\n    for (auto o : e1) cov[o.second] = 1;\n\n    vector<int> ncov;\n    for (int i = 0; i < n; i++) if (cov[i] == 0) ncov.push_back(i);\n    assert(ncov.size() == 1);\n\n    vector<vector<int>> g(n + n-1);\n    for (auto ed : e1) {\n        g[ed.first].push_back(n-1 + ed.second);\n    }\n    for (auto ed : e2) {\n        g[n-1 + ed.second].push_back(ed.first);\n    }\n\n    vector<char> vis(n-1 + n);\n\n    function<void(int)> dfs = [&](int v) {\n        //cerr << v << endl;\n        vis[v] = 1;\n        for (int to : g[v]) {\n            if (!vis[to]) {\n                if (v >= n-1) {\n                    e1.push_back({to, v - (n-1)});\n                }\n                dfs(to);\n            }\n        }\n    };\n    dfs(n-1 + ncov[0]);\n\n    if ((int)e1.size() != 2 * (n - 1)) {\n        return vector<pair<int, int>>();\n    }\n    sort(e1.begin(), e1.end());\n\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < (int)e1.size(); i += 2) {\n        assert(e1[i].first == e1[i + 1].first);\n        ans.push_back({e1[i].second, e1[i + 1].second});\n    }\n\n    {\n        vector<int> p(n);\n        iota(p.begin(), p.end(), 0);\n        function<int(int)> get = [&](int x) {\n            if (x == p[x]) return x;\n            return p[x] =get(p[x]);\n        };\n        auto uni = [&](int u, int v) {\n            u = get(u);\n            v = get(v);\n            if (u == v) return 0;\n            p[v] = u;\n            return  1;\n        };\n        assert((int)ans.size() == n - 1);\n        for (int i = 0; i < n-1; i++) {\n            assert(find(a[i].begin(), a[i].end(), ans[i].first) != a[i].end());\n            assert(find(a[i].begin(), a[i].end(), ans[i].second) != a[i].end());\n            assert(uni(ans[i].first, ans[i].second));\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<vector<int>> a(n - 1);\n        for (int i = 0; i < n - 1; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            a[i].resize(k);\n            for (int j = 0; j < k; j++) {\n                scanf(\"%d\", &a[i][j]);\n                a[i][j]--;\n            }\n        }\n\n        print(solve(a));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MN 200010\n#define MM 800010\n#define inf 999999999\nusing namespace std;\nint fr[MN],dy[MN],ne[MM],v[MM],w[MM],bs=0;\nvoid add(int a,int b,int c)\n{\n\tv[bs]=b;\n\tw[bs]=c;\n\tne[bs]=fr[a];\n\tfr[a]=bs++;\n}\nvoid addb(int a,int b,int c)\n{\n\tadd(a,b,c);\n\tadd(b,a,0);\n}\nint dl[MN],jl[MN],N,S,T;bool bk[MN];\nbool bfs()\n{\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tbk[i]=false;\n\t\tjl[i]=inf;\n\t}\n\tbk[S]=true;jl[S]=0;\n\tint he=0,ta=1;dl[0]=S;\n\twhile(he<ta)\n\t{\n\t\tint u=dl[he++];\n\t\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t\t{\n\t\t\tif(w[i]>0&&!bk[v[i]])\n\t\t\t{\n\t\t\t\tbk[v[i]]=true;\n\t\t\t\tjl[v[i]]=jl[u]+1;\n\t\t\t\tdl[ta++]=v[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn jl[T]<inf;\n}\nint dfs(int u,int z)\n{\n\tif(u==T)\n\t\treturn z;\n\tfor(int &i=dy[u];i!=-1;i=ne[i])\n\t{\n\t\tif(w[i]>0&&jl[v[i]]==jl[u]+1)\n\t\t{\n\t\t\tint t=dfs(v[i],z<w[i]?z:w[i]);\n\t\t\tif(t!=-1)\n\t\t\t{\n\t\t\t\tw[i]-=t;\n\t\t\t\tw[i^1]+=t;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint dinic()\n{\n\tint jg=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tdy[i]=fr[i];\n\t\twhile(1)\n\t\t{\n\t\t\tint t=dfs(S,inf);\n\t\t\tif(t==-1)\n\t\t\t\tbreak;\n\t\t\tjg+=t;\n\t\t}\n\t}\n\treturn jg;\n}\nvector<int> ve[100010],to[100010];\nint pp[100010],fa[100010];\nvoid dfs2(int u,int f)\n{\n\tif(bk[u])return;\n\tfa[u]=f;bk[u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],u);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint s,a;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<s;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tN=n*2+1;S=N-1;T=N;\n\tfor(int i=1;i<=N;i++)\n\t\tfr[i]=-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\taddb(S,i,1);\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t\taddb(i,ve[i][j]+n-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\taddb(i+n-1,T,1);\n\tif(dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbk[i]=false;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=fr[i];j!=-1;j=ne[j])\n\t\t{\n\t\t\tint t=v[j];\n\t\t\tif(t>n-1&&w[j]==0)\n\t\t\t{\n\t\t\t\tpp[i]=t-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t{\n\t\t\tif(ve[i][j]!=pp[i])\n\t\t\t\tto[ve[i][j]].push_back(pp[i]);\n\t\t}\n\t\tbk[pp[i]]=true;\n\t}\n\tint ro=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!bk[i])\n\t\t{\n\t\t\tro=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)bk[i]=false;\n\tdfs2(ro,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=ro&&fa[i]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t\tprintf(\"%d %d\\n\",pp[i],fa[pp[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)  cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tcout<<i<<' '<<i+1<<endl;\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cctype>\nconst int N=100007;\nstd::vector<int>e[N];std::queue<int>q;\nint vis[N],mat[N],tam[N];\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nint dfs(int u,int root)\n{\n    for(int v:e[u]) if(vis[v]^root) if(vis[v]=root,!mat[v]||dfs(mat[v],root)) return mat[v]=u;\n    return 0;\n}\nint main()\n{\n    int n=read();\n    for(int i=1;i<n;++i) for(int j=read();j;--j) e[read()].push_back(i);\n    for(int i=2;i<=n;++i) if(!dfs(i,i)) return puts(\"-1\"),0;\n    q.push(1);\n    for(int i=1,u;i<=n;++i)\n    {\n\tif(q.empty()) return puts(\"-1\"),0;\n\tu=q.front(),q.pop();\n\tfor(int v:e[u]) if(!tam[v]) tam[v]=u,q.push(mat[v]);\n    }\n    for(int i=1;i<n;++i) printf(\"%d %d\\n\",tam[i],mat[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[N<<1],got[N<<1],tak[N<<1];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[tot]=x,b[tot]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint father[N],get[N];\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][15];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n//\tif(total2%2==1)\n//\tprintf(\"%d %d %d\\n\",x,y,z);\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n//\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (y>TT) continue;\n\t\t\tif (v[i]>0&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{ \n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y>TT) continue;\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tif (i==6&&y==11)\n\t\t\t{\n\t\t\t\tT++;T--;\n\t\t\t}\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic(int start)\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(start,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nvoid dfs2(int k,int fa)\n{\n\tfor (int i=head2[k+n];i;i=nexts2[i])\n\t{\n\t\tint y=edge2[i];\n\t\tif (father[y]==0)\n\t\t{\n\t\t\tfather[y]=k;\n\t\t\tdfs2(get[y],k);\n\t\t}\n\t}\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic(SS);\n\tif (maxflow==sum)\n\t{\n\t\ttotal1=1;\n\t\tSS=S=0;TT=T=2*n+1;\n\t\tmemset(head,0,sizeof(head));\n\t\tmemset(nexts,0,sizeof(nexts));\n\t\tmemset(edge,0,sizeof(edge));\n\t\tmemset(v,0,sizeof(v));\n\t\ttotal2=1;\n\t\tmemset(head2,0,sizeof(head2));\n\t\tmemset(edge2,0,sizeof(edge2));\n\t\tmemset(nexts2,0,sizeof(nexts2));\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tinsert(SS,i,1);\n\t\t\tinsert(i,SS,0);\n\t\t//\tprintf(\"%d %d %d\\n\",SS,i,1); \n\t\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t\t{\n\t\t\t\tinsert2(s[i][j]+n,i,0,0);\n\t\t\t\tif (s[i][j]==1) continue;\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,s[i][j]+n,1);\n\t\t\t\tinsert(i,s[i][j]+n,1);\n\t\t\t\tinsert(s[i][j]+n,i,0);\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tinsert(i+n,TT,1);\n\t\t\tinsert(TT,i+n,0);\n\t\t//\tprintf(\"%d %d %d\\n\",i+n,TT,1);\n\t\t}\n\t\tmaxflow=re_dinic(SS);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tfor (int j=head[i];j;j=nexts[j])\n\t\t\t{\n\t\t\t\tint y=edge[j];\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,y,v[j^1]);\n\t\t\t\tif (j%2==0&&v[j]==0)\n\t\t\t\t{\n\t\t\t\t\tget[i]=y-n;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tmemset(father,0,sizeof(father));\n\t\t//stotal=0;\n\t\tdfs2(1,0);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",get[i],father[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=200000+10,inf=0x3f3f3f3f;\nint n,e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<1],to[MAXN<<1],out[MAXN<<1],cap[MAXN<<1],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nPII side[MAXN];\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tside[v]=mp(mh[v],x),vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,1,n-1)printf(\"%d %d\\n\",side[i].ft,side[i].sd);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\tconst int N = 2e5 + 5, INF = 0x3f3f3f3f;\n\n\tint n, s, t, Head[N], dep[N], cur[N], mat[N], from[N];\n\tstruct edge { int to, next, w; } E[N << 2];\n\tvector<int> Bel[N >> 1]; \n\n\tinline void add(const int u, const int v)\n\t{\n\t\tstatic int ec = 1;\n\t\tE[++ec] = (edge){v, Head[u], 1};\n\t\tHead[u] = ec;\n\t\tE[++ec] = (edge){u, Head[v], 0};\n\t\tHead[v] = ec;\n\t}\n\n\tbool bfs()\n\t{\n\t\tmemcpy(cur, Head, sizeof(int[t + 1]));\n\t\tmemset(dep, 0, sizeof(int[t + 1]));\n\t\tstatic queue<int> q;\n\t\tq.push(s);\n\t\tdep[s] = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = Head[u], v; i; i = E[i].next)\n\t\t\t\tif (E[i].w && !dep[v = E[i].to])\n\t\t\t\t\tdep[v] = dep[u] + 1, q.push(v);\n\t\t}\n\t\treturn dep[t];\n\t}\n\n\tint dfs(const int u, const int mn)\n\t{\n\t\tif (u == t || !mn)\n\t\t\treturn mn;\n\t\tint v, w, used = 0;\n\t\tfor (int &i = cur[u]; i; i = E[i].next)\n\t\t\tif (E[i].w && dep[v = E[i].to] == dep[u] + 1)\n\t\t\t{\n\t\t\t\tw = dfs(v, min(mn - used, E[i].w));\n\t\t\t\tused += w;\n\t\t\t\tE[i].w -= w;\n\t\t\t\tE[i ^ 1].w += w;\n\t\t\t\tif (used == mn)\n\t\t\t\t\treturn used;\n\t\t\t}\n\t\tif (!used)\n\t\t\tdep[u] = -1;\n\t\treturn used;\n\t}\n\n\tint Dinic()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t\tans += dfs(s, INF);\n\t\treturn ans;\n\t}\n\n\tbool search()\n\t{\n\t\tstatic queue<int> q;\n\t\tq.push(n);\n\t\tfrom[n] = -1;\n\t\tint cnt = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(), p;\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\tfor (int i : Bel[x])\n\t\t\t\tif (!from[p = mat[i]])\n\t\t\t\t\tfrom[p] = x, q.push(p);\n\t\t}\n\t\treturn cnt == n;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1, c, j; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &j);\n\t\t\t\tif (j != n)\n\t\t\t\t\tadd(j, i + n);\n\t\t\t\tBel[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\ts = n + n, t = s + 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tadd(s, i), add(i + n, t);\n\t\tint flow = Dinic();\n\t\tif (flow != n - 1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor (int u = 1; u < n; u++)\n\t\t\t\tfor (int i = Head[u + n]; i; i = E[i].next)\n\t\t\t\t\tif (E[i].w == 1 && E[i].to < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tmat[u] = E[i].to;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!search())\n\t\t\t\tputs(\"-1\");\n\t\t\telse\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tprintf(\"%d %d\\n\", i, from[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nnamespace DinicFlows {\n\ttypedef long long LL;\n\tconst LL Inf = 0x3f3f3f3f3f3f3f3f;\n\tconst int MN = 200005, MM = 400005;\n\t\n\tint N, S, T;\n\tint h[MN], iter[MN], nxt[MM * 2], to[MM * 2], tot; LL w[MM * 2];\n\t\n\tinline void SetST(int, int);\n\tinline void Init(int _N) {\n\t\tN = _N, tot = 1;\n\t\tfor (int i = 1; i <= N; ++i) h[i] = 0;\n\t\tSetST(_N - 1, _N);\n\t}\n\tinline void SetST(int _S, int _T) { S = _S, T = _T; }\n\t\n\tinline void ins(int u, int v, LL x) { nxt[++tot] = h[u], to[tot] = v, w[tot] = x, h[u] = tot; }\n\tinline void insw(int u, int v, LL w1 = Inf, LL w2 = 0) {\n\t\tif (!u) u = S; if (!v) v = T;\n\t\tins(u, v, w1), ins(v, u, w2);\n\t}\n\t\n\tint lv[MN], que[MN], l, r;\n\t\n\tinline bool Lvl() {\n\t\tfor (int i = 1; i <= N; ++i) lv[i] = 0;\n\t\tlv[S] = 1;\n\t\tque[l = r = 1] = S;\n\t\twhile (l <= r) {\n\t\t\tint u = que[l++];\n\t\t\tfor (int i = h[u]; i; i = nxt[i])\n\t\t\t\tif (w[i] && !lv[to[i]]) {\n\t\t\t\t\tlv[to[i]] = lv[u] + 1;\n\t\t\t\t\tque[++r] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn lv[T] != 0;\n\t}\n\t\n\tLL Flow(int u, LL f) {\n\t\tif (u == T) return f;\n\t\tLL d = 0, s = 0;\n\t\tfor (int &i = iter[u]; i; i = nxt[i])\n\t\t\tif (w[i] && lv[to[i]] == lv[u] + 1) {\n\t\t\t\td = Flow(to[i], std::min(f, w[i]));\n\t\t\t\tf -= d, s += d;\n\t\t\t\tw[i] -= d, w[i ^ 1] += d;\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\treturn s;\n\t}\n\t\n\tinline LL Dinic() {\n\t\tLL Ans = 0;\n\t\twhile (Lvl()) {\n\t\t\tfor (int i = 1; i <= N; ++i) iter[i] = h[i];\n\t\t\tAns += Flow(S, Inf);\n\t\t}\n\t\treturn Ans;\n\t}\n}\nusing DinicFlows::h;\nusing DinicFlows::to;\nusing DinicFlows::nxt;\nusing DinicFlows::w;\nusing DinicFlows::insw;\n\nconst int MN = 100005;\n\nint N, mch[MN], vis[MN];\nint eu[MN], ev[MN], M;\n\nvoid DFS(int u) {\n\tfor (int j = h[u]; j; j = nxt[j]) {\n\t\tif (to[j] == N + N || vis[to[j] - N]) continue;\n\t\tint id = to[j] - N;\n\t\tvis[id] = 1;\n\t\tfor (int k = h[to[j]]; k; k = nxt[k]) if(w[k])\n\t\t\t++M, eu[id] = u, ev[id] = to[k], DFS(to[k]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tDinicFlows::Init(N + N + 1);\n\tfor (int i = 1; i <= N; ++i) insw(0, i, 1);\n\tfor (int i = 1, c, x; i < N; ++i) {\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) scanf(\"%d\", &x), insw(x, N + i, 1);\n\t\tinsw(N + i, 0, 1);\n\t}\n\tif (DinicFlows::Dinic() != N - 1) return puts(\"-1\"), 0;\n\tint Root = 0;\n\tfor (int i = h[N + N]; i; i = nxt[i]) if (w[i]) Root = to[i];\n\tDFS(Root);\n\tif (M != N - 1) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < N; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[101010];\nint match[101010];\nbool used[101010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: wxyww\n* @Date: 2020-04-01 11:25:14\n* @Last Modified time: 2020-04-01 11:48:30\n*/\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 200010;\nll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nvector<int>t[N];\nqueue<int>q;\nint V[N],U[N];\nvector<int>::iterator it;\nstruct node {\n\tint v,nxt,w;\n}e[N << 1];\nint head[N],ejs = 1,cur[N];\nvoid add(int u,int v,int w) {\n\te[++ejs].v = v;e[ejs].nxt = head[u];head[u] = ejs;e[ejs].w = w;\n\te[++ejs].v = u;e[ejs].nxt = head[v];head[v] = ejs;e[ejs].w = 0;\n}\nint dep[N],S,T;\nint bfs() {\n\tq.push(S);\n\tmemset(dep,0,sizeof(dep));\n\tdep[S] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!dep[v] && e[i].w) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T];\n}\nint dfs(int u,int now) {\n\tif(u == T) return now;\n\tint ret = 0;\n\tfor(int &i = cur[u];i;i = e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif(dep[v] == dep[u] + 1 && e[i].w) {\n\t\t\tint k = dfs(v,min(now - ret,e[i].w));\n\t\t\te[i].w -= k;\n\t\t\te[i ^ 1].w += k;\n\t\t\tret += k;\n\t\t\tif(ret == now) return ret;\n\t\t}\n\t}\n\treturn ret;\n}\nint dinic() {\n\tint ret = 0;\n\twhile(bfs()) {\n\t// puts(\"!!!!\");\n\t\tmemcpy(cur,head,sizeof(cur));\n\t\tret += dfs(S,10000000);\n\t}\n\treturn ret;\n}\nint flag[N];\nint main() {\n\tint n = read();\n\tS = 1,T = n + n;\n\tfor(int i = 2;i <= n;++i)\n\t\tadd(S,i,1);\n\tfor(int i = n + 1;i < n + n;++i)\n\t\tadd(i,T,1);\n\tfor(int i = 2;i <= n;++i) {\n\t\tint tot = read();\n\t\tfor(int j = 1;j <= tot;++j) {\n\t\t\tint x = read();\n\t\t\tt[x].push_back(i);\n\t\t\tif(x == 1) continue;\n\t\t\tadd(i,x + n - 1,1);\n\t\t}\n\t}\n\n\tif(dinic() != n - 1) {\n\t\tputs(\"-1\");return 0;\n\t}\n\n\n\tfor(int u = 2;u <= n;++u)\n\t\tfor(int i = head[u];i;i = e[i].nxt)\n\t\t\tif(!e[i].w)\n\t\t\t\tV[u] = e[i].v - n + 1;\n\n\t// for(int i = 2;i <= n;++i) printf(\"%d \",V[i]);\n\t// puts(\"\");\n\n\tq.push(S);\n\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tfor(it = t[u].begin();it != t[u].end();++it) {\n\t\t\t\tif(flag[*it]) continue;\n\t\t\t\tflag[*it] = 1;\n\t\t\t\tU[*it] = u;\n\t\t\t\tq.push(V[*it]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tif(!U[i]) {\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=1e5+5,inf=0x3f3f3f3f;\nint n,s,t,head[N<<1],num=1;\nstruct edge{int to,flo,next;} e[N*10];\ninline void add(int u,int v){\n    e[++num]=(edge){v,1,head[u]},head[u]=num;\n    e[++num]=(edge){u,0,head[v]},head[v]=num;\n}\n\nint dis[N<<1];\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof dis);\n    q.push(s),dis[s]=1;\n    while(!q.empty()){\n\tint u=q.front();q.pop();\n\tfor(int i=head[u];i;i=e[i].next){\n\t    int v=e[i].to;if(dis[v]||!e[i].flo)continue;\n\t    dis[v]=dis[u]+1,q.push(v);\n\t}\n    }\n    return dis[t];\n}\nint dfs(int u,int lim){\n    if(u==t||!lim)return lim;\n    int flow=0;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(dis[v]!=dis[u]+1||!e[i].flo)continue;\n\tint f=dfs(v,min(lim,e[i].flo));\n\te[i].flo-=f,e[i^1].flo+=f;\n\tlim-=f,flow+=f;\n\tif(!lim)break;\n    }\n    return flow;\n}\nint Netflow(){\n    int ans=0;\n    while(bfs())ans+=dfs(s,inf);\n    return ans;\n}\n\nint fa[N<<1],vis[N<<1],cnt;\npii ans[N];\nvoid serch(int u,int pa){\n    cnt+=u<=n,vis[u]=1,fa[u]=pa;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(vis[v]||!e[i].flo)continue;\n\tserch(v,u);\n    }\n}\n\nint main(){\n    //freopen(\"in.in\",\"r\",stdin);\n    n=read();s=n+n,t=s+1;\n    REP(i,1,n)add(s,i);\n    REP(i,1,n-1)add(n+i,t);\n    REP(i,1,n-1)REP(c,1,read()){int u=read();add(u,n+i);}\n    if(Netflow()<n-1)return puts(\"-1\"),0;\n    int rt=0;\n    for(int i=head[s];i;i=e[i].next)if(e[i].flo){rt=e[i].to;break;}\n    serch(rt,0);\n    if(cnt<n)return puts(\"-1\"),0;\n    REP(i,1,n)if(i!=rt){\n\tint id=fa[i],p=fa[id];\n\tans[id-n]=mp(p,i);\n    }\n    REP(i,1,n-1)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg {\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int i=head[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()) {\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\nvector<pii>ans;\nint main(){\n    ios::sync_with_stdio(0);\n    int n;cin>>n;\n    rep(i,1,n-1) {\n        int c;cin>>c;\n        rep(j,1,c) {\n            int u;cin>>u;E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        cout<<\"-1\";return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans.pb(mk(u,set_match));\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        cout<<\"-1\";return 0;\n    }\n    for(int i=0;i<ans.size();i++) {\n        cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, tot = 0;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n    tot += c;\n  }\n  vector<int> from(n - 1, -1);\n  vector<bool> vis(n);\n  queue<int> q;\n  vis[0] = true;\n  q.push(0);\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    for (int id : fnd[u]) {\n      if (from[id] != -1) continue;\n      from[id] = u;\n      for (int v : e[id])\n        if (!vis[v]) {\n          vis[v] = true;\n          q.push(v);\n        }\n    }\n  }\n  if (count(vis.begin(), vis.end(), false)) {\n    puts(\"-1\");\n    return 0;\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i])\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i)\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i] && eref[i][j].get())\n        cout << (from[i] + 1) << ' ' << (e[i][j] + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nset<int> E[N],app[N];\nvector<pii> ans;\nset<pii> s;\nint n,c,w;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tread(c);\n\t\trep(j,1,c){\n\t\t\tread(w);\n\t\t\tE[i].insert(w);\n\t\t\tapp[w].insert(i);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts.insert(mp(app[i].size(),i));\n\t}\n\twhile(s.size()>=2){\n\t\tint x=s.begin()->se;\n\t\ts.erase(s.begin());\n\t\tif(!app[x].size())GG();\n\t\tint k=*app[x].begin();\n\t\tif(E[k].size()<app[x].size())GG();\n\t\tif(E[k].size()<2)GG();\n\t\tint U=*E[k].begin();\n\t\tint V=*(--E[k].end());\n\t\tif(x==U)ans.pb(mp(x,V));\n\t\telse ans.pb(mp(x,U));\n\t\tE[k].erase(x);\n\t\tapp[x].erase(k);\n\t\tfor(auto y:E[k]){\n\t\t\ts.erase(mp(app[y].size(),y));\n\t\t\tapp[y].erase(k);\n\t\t\ts.insert(mp(app[y].size(),y));\n\t\t}\n\t\tfor(auto t:app[x])\n\t\t\tE[t].erase(x);\n\t}\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2], Q[Max_N], U[Max_N * 2], V[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 1;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u), Father[Get_Father(u)] = i;\n\t\t\tif (u != 1)\n\t\t\t\tG::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 1;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(1))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tQ[Q[0] = 1] = 1;\n\t\tfor (int u, ft = 1;ft <= Q[0];)\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = 0, t;i < In[u].size();++i)\n\t\t\t\tif (!done[t = In[u][i]])\n\t\t\t\t{\n\t\t\t\t\tdone[t] = true;\n\t\t\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\t\t\tU[t] = u, V[t] = v, Q[++Q[0]] = v;\n\t\t\t\t}\n\t\t}\n\t\tfor (int i = N + 1;i <= N + (N - 1);++i)\n\t\t\tprint(U[i]), putc(' '), print(V[i]), putc('\\n');\n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\treturn 0;\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tprintf(\"%d %d\\n\",x,ma[v2[x][i]]);\n\t\tvis[v2[x][i]]=1;\n\t\tson[x].push_back(ma[v2[x][i]]);\n\t}\n\tfor(int i=0;i<(int)son[x].size();i++)dfs(son[x][i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=2;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tif(x!=1)add(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=2;x<=n;x++)\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz)ma[w[i].to-n]=x;\n\tdfs(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MN 200010\n#define MM 800010\n#define inf 999999999\nusing namespace std;\nint fr[MN],ne[MM],v[MM],w[MM],bs=0;\nvoid add(int a,int b,int c)\n{\n\tv[bs]=b;\n\tw[bs]=c;\n\tne[bs]=fr[a];\n\tfr[a]=bs++;\n}\nvoid addb(int a,int b,int c)\n{\n\tadd(a,b,c);\n\tadd(b,a,0);\n}\nint dl[100010],jl[100010],N,S,T;bool bk[100010];\nbool bfs()\n{\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tbk[i]=false;\n\t\tjl[i]=inf;\n\t}\n\tbk[S]=true;jl[S]=0;\n\tint he=0,ta=1;dl[0]=S;\n\twhile(he<ta)\n\t{\n\t\tint u=dl[he++];\n\t\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t\t{\n\t\t\tif(w[i]>0&&!bk[v[i]])\n\t\t\t{\n\t\t\t\tbk[v[i]]=true;\n\t\t\t\tjl[v[i]]=jl[u]+1;\n\t\t\t\tdl[ta++]=v[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn jl[T]<inf;\n}\nint dfs(int u,int z)\n{\n\tif(u==T)\n\t\treturn z;\n\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t{\n\t\tif(w[i]>0&&jl[v[i]]==jl[u]+1)\n\t\t{\n\t\t\tint t=dfs(v[i],z<w[i]?z:w[i]);\n\t\t\tif(t!=-1)\n\t\t\t{\n\t\t\t\tw[i]-=t;\n\t\t\t\tw[i^1]+=t;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint dinic()\n{\n\tint jg=0;\n\twhile(bfs())\n\t{\n\t\twhile(1)\n\t\t{\n\t\t\tint t=dfs(S,inf);\n\t\t\tif(t==-1)\n\t\t\t\tbreak;\n\t\t\tjg+=t;\n\t\t}\n\t}\n\treturn jg;\n}\nvector<int> ve[100010],to[100010];\nint pp[100010],fa[100010];\nvoid dfs2(int u,int f)\n{\n\tif(bk[u])return;\n\tfa[u]=f;bk[u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],u);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint s,a;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<s;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tN=n*2+1;S=N-1;T=N;\n\tfor(int i=1;i<=N;i++)\n\t\tfr[i]=-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\taddb(S,i,1);\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t\taddb(i,ve[i][j]+n-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\taddb(i+n-1,T,1);\n\tif(dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbk[i]=false;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=fr[i];j!=-1;j=ne[j])\n\t\t{\n\t\t\tint t=v[j];\n\t\t\tif(t>n-1&&w[j]==0)\n\t\t\t{\n\t\t\t\tpp[i]=t-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t{\n\t\t\tif(ve[i][j]!=pp[i])\n\t\t\t\tto[ve[i][j]].push_back(pp[i]);\n\t\t}\n\t\tbk[pp[i]]=true;\n\t}\n\tint ro=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!bk[i])\n\t\t{\n\t\t\tro=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)bk[i]=false;\n\tdfs2(ro,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=ro&&fa[i]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t\tprintf(\"%d %d\\n\",pp[i],fa[pp[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],min(flow-used,c[i]));\n\t\tif(v)used+=v,c[i]-=v,c[i^1]+=v,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n\n#define N 300005\n#define M 2000005\n\n#define ls (t<<1)\n#define rs ((t<<1)|1)\n#define mid ((l+r)>>1)\n\n#define mk make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nint i,j,m,n,p,k,st,ed,c,x,S[N],T[N],fox[N],k1=1,Q[N];\n\nvector<int>v[N],G[N];\n\nint dis[N];\n\nstruct Node{\n\t\t\tint ed,before,flow;\n}s[M];\n\nvoid add(int x,int y,int flow)\n{\n\t\ts[++k1].ed=y; s[k1].before=fox[x]; fox[x]=k1; s[k1].flow=flow;\n\t\ts[++k1].ed=x; s[k1].before=fox[y]; fox[y]=k1; s[k1].flow=0;\n}\n\nconst int inf=(int)1e9;\n\nint bfs()\n{\n\t\tint i;\n\t\tQ[Q[0]=1]=st; memset(dis,-1,sizeof(dis)); dis[st]=0;\n\t\tfor (int l=1;l<=Q[0]&&dis[ed]==-1;++l)\n\t\t{\n\t\t\t\tint p=Q[l];\n\t\t\t\tfor (i=fox[p];i;i=s[i].before)\n\t\t\t\t{\n\t\t\t\t\t\t\tint k=s[i].ed;\n\t\t\t\t\t\t\tif (dis[k]!=-1||!s[i].flow) continue;\n\t\t\t\t\t\t\tdis[k]=dis[p]+1;\n\t\t\t\t\t\t\tQ[++Q[0]]=k;\n\t\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=-1;\n}\n\nint dfs(int x,int flow)\n{\n\t\tif (x==ed) return flow;\n\t\tint i,nowans=0,a;\n\t\tfor (i=fox[x];i&&flow;i=s[i].before)\n\t\t{\n\t\t\t\tint p=s[i].ed;\n\t\t\t\tif (dis[p]!=dis[x]+1||!s[i].flow) continue;\n\t\t\t\ta=dfs(p,min(flow,s[i].flow));\n\t\t\t\tnowans+=a;\n\t\t\t\tflow-=a;\n\t\t\t\ts[i].flow-=a;\n\t\t\t\ts[i^1].flow+=a; \n\t\t}\n\t\tif (!nowans) dis[x]=-1;\n\t\treturn nowans;\t\n}\n\nint maxflow()\n{\n\t\tint ans=0;\n\t\twhile (bfs()) ans+=dfs(st,inf);\n\t\treturn ans;\n}\n\nint main()\n{\n\t\tscanf(\"%d\",&n); st=n*2+1; ed=st+1;\n\t\tfor (i=1;i<n;++i)\n\t\t{\n\t\t\t\tscanf(\"%d\",&c);\n\t\t\t\tfor (;c--;)\n\t\t\t\t{\n\t\t\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\t\t\tv[i].pb(x); \n\t\t\t\t\t\tif (x>1) add(x,i+n,1);\n\t\t\t\t}\n\t\t}\n\t\tfor (i=2;i<=n;++i) add(st,i,1);\n\t\tfor (i=1;i<n;++i) add(i+n,ed,1);\n\t\tif (maxflow()!=n-1)\n\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (i=2;i<=n;++i)\n\t\t\tfor (j=fox[i];j;j=s[j].before)\n\t\t\t\tif (s[j].ed<=2*n&&s[j].flow==0) T[s[j].ed-n]=i;\n\t\tfor (i=1;i<n;++i)\n\t\t{\n\t\t\t\t for (j=0;j<(int)v[i].size();++j)\n\t\t\t\t {\n\t\t\t\t \t\t\tint p=v[i][j];\n\t\t\t\t \t\t\tif (p==T[i]) continue;\n\t\t\t\t \t\t\tG[p].pb(i); \n\t\t\t\t }\n\t\t}\n\t\tQ[Q[0]=1]=1;\n\t\tfor (int l=1;l<=Q[0];++l)\n\t\t{\n\t\t\t\t\tint p=Q[l];\n\t\t\t\t\tfor (i=0;i<(int)G[p].size();++i)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tint k=G[p][i];\n\t\t\t\t\t\t\tif (S[k]) continue;\n\t\t\t\t\t\t\tS[k]=p; Q[++Q[0]]=T[k];\n\t\t\t\t\t}\n\t\t}\t\n\t\tif (Q[0]!=n) \n\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",S[i],T[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        while ( (f = dfs(s,t,inf) ) > 0 ) ans += f;\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , n;\n\nint main(){\n\t\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i] || sem[i] == apo[i]) return puts(\"-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int i=h[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[u]=v-n;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[N+3];\nvector<pair<int,pii> > ans;\nint mch[N+3];\nbool vis[N+3];\nint que[N+3];\nint n;\n\nbool bfs()\n{\n\tint hd = 1,tl = 1; que[1] = 1; vis[1] = true;\n\twhile(hd<=tl)\n\t{\n\t\tint u = que[hd]; hd++;\n\t\tfor(int o=0; o<adj[u].size(); o++)\n\t\t{\n\t\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\t\tif(vis[mch[v]]) continue;\n\t\t\tque[++tl] = mch[v]; vis[v] = vis[mch[v]] = true;\n\t\t\tans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\t}\n\t}\n\tif(tl<n) {return false;}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tif(!bfs()) {puts(\"-1\"); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\tdsu tmp(n);\n\tvector<int> deg(n+1);\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j, assert(j-1 < n), deg[j-1]++;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching(), res(n-1);\n\tsort(all(matching), [&](auto a, auto b) {\n\t\treturn f[a[0]-1].size() < f[b[0]-1].size();\n\t});\n\tfor(auto [i, x] : matching) {\n\t\t//cout << i << \" \" << x << endl;\n\t\tx -= n-1;\n\t\tsort(all(f[i-1]), [&](auto a, auto b) {\n\t\t\treturn deg[a-1] < deg[b-1];\n\t\t});\n\t\tfor(auto y : f[i-1]) if(!tmp.con(x-1, y-1)) {\n\t\t\ttmp.unite(x-1, y-1);\n\t\t\tres[i-1] = {x, y};\n\t\t\tbreak;\n\t\t}\n\t\tfor(auto y : f[i-1]) deg[y-1]--;\n\t}\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a << \" \" << b << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define M 1000010\n#define inf 1e9\nusing namespace std;\nint n,num,cnt,s,t,h[M],head[M],son[M],vis[M];\nvector<int>S[M],P[M];\nqueue<int>Que;\nstruct node{int x,y,id;}f[M];\nstruct edge{int next,to,dis;}e[M<<1];\nbool cmp(node a,node b) {return a.id<b.id;}\nvoid add(int from,int to,int dis) {\n\te[num]=(edge){head[from],to,dis};\n\thead[from]=num++;\n}\nbool bfs() {\n\tqueue<int>Q;Q.push(s);\n\tmemset(h,0,sizeof(h)),h[s]=1;\n\twhile(!Q.empty()) {\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis>0&&!h[e[i].to])\n\t\t\t\tQ.push(e[i].to),h[e[i].to]=h[x]+1;\n\t}\n\treturn h[t];\n}\nint dfs(int x,int dis) {\n\tif(x==t) return dis;int sum=0;\n\tfor(int i=head[x];i;i=e[i].next) {\n\t\tint to=e[i].to;\n\t\tif(e[i].dis&&h[to]==h[x]+1) {\n\t\t\tint diss=dfs(to,min(e[i].dis,dis));\n\t\t\tdis-=diss;sum+=diss;\n\t\t\te[i].dis-=diss;e[i^1].dis+=diss;\n\t\t\tif(!dis) break;\n\t\t}\n\t}\n\tif(!sum) h[x]=-1;\n\treturn sum;\n}\nint dinic() {\n\tint tot=0;\n\twhile(bfs()) \n\t\ttot+=dfs(s,inf);\n\treturn tot;\n}\nint main() {\n\tscanf(\"%d\",&n);s=0,t=2*n;\n\tfor(int i=1;i<n;i++) {\n\t\tint sum;scanf(\"%d\",&sum);\n\t\tfor(int j=1;j<=sum;j++) {\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tS[i+n].push_back(x);\n\t\t\tadd(i+n,x,0),add(x,i+n,1);\n\t\t\tP[x].push_back(i+n);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) add(i,s,0),add(s,i,1);\n\tfor(int i=n+1;i<n+n;i++) add(t,i,0),add(i,t,1);\n\tint ans=dinic();\n\tif(ans!=n-1) {puts(\"-1\");return 0;}\n\tfor(int x=n+1;x<n+n;x++)\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis&&e[i].to!=t)\n\t\t\t\tson[x]=e[i].to;\n\tQue.push(1);\n\twhile(!Que.empty()) {\n\t\tint x=Que.front();Que.pop();\n\t\tfor(int i=0;i<P[x].size();i++) {\n\t\t\tint to=P[x][i];\n\t\t\tif(!vis[to]) {\n\t\t\t\tvis[to]=true;\n\t\t\t\tQue.push(son[to]);\n\t\t\t\tf[++cnt]=(node){x,son[to],to};\n\t\t\t}\n\t\t}\n\t}\n\tsort(f+1,f+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    vector<pair<int, int>> ee;\n    int pp[maxn];\n    bool viss[maxn];\n\n    inline void getans() {\n        ee.clear();\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee.emplace_back(now, pp[jh]);\n                    q.push(pp[jh]);\n                }\n            }\n        }\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        getans();\n        if ((int) ee.size() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (auto x : ee) {\n            writesp(x.first), writeln(x.second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=5e5+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint to[N<<1],ww[N<<1],nxt[N<<1],h[N],dep[N],cur[N],s,t,tot=1;\nvoid adde(int u,int v,int w) {\n    to[++tot]=v,ww[tot]=w,nxt[tot]=h[u],h[u]=tot;\n    to[++tot]=u,ww[tot]=0,nxt[tot]=h[v],h[v]=tot;\n}\nint bfs() {\n    memset(dep,0,sizeof(dep));\n    queue<int> q;q.push(s);dep[s]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=h[u];i;i=nxt[i]) {\n            int v=to[i];\n            if(!dep[v]&&ww[i]) {\n                dep[v]=dep[u]+1,q.push(v);\n                if(v==t) return 1;\n            }\n        }\n    }\n    return 0;\n}\nint dfs(int u,int flow) {\n    if(u==t) return flow;\n    int ret=0;\n    for(int &i=cur[u];i;i=nxt[i]) {\n        int v=to[i];\n        if(dep[v]==dep[u]+1&&ww[i]) {\n            int d=dfs(v,min(flow,ww[i]));\n            ww[i]-=d,ww[i^1]+=d,ret+=d,flow-=d;\n            if(!flow) break;\n        }\n    }\n    if(!ret) dep[u]=0;\n    return ret;\n}\nint dinic() {\n    int ret=0;\n    while(bfs()) {\n        memcpy(cur,h,sizeof(h));\n        ret+=dfs(s,inf);\n    }\n    return ret;\n}\nint n,mat[N],vis[N],fa[N],cnt=0;\nvector<int> pos[N];\nvoid insert(int u) {\n    vis[u]=1,++cnt;\n    for(int i:pos[u])\n        if(mat[i]&&!vis[mat[i]]) fa[mat[i]]=u,insert(mat[i]);\n}\nint main() {\n    n=gi(),s=0,t=2*n+1;\n    for(int i=1;i<n;i++) {\n        int c=gi(),w;\n        adde(s,i,1);\n        for(int j=1;j<=c;j++) w=gi(),pos[w].pb(i),adde(i,w+n,1);\n    }\n    for(int i=2;i<=n;i++) adde(i+n,t,1);\n    if(dinic()!=n-1) return puts(\"-1\"),0;\n    for(int u=1;u<=n;u++) {\n        for(int i=h[u];i;i=nxt[i]) {\n            int v=to[i];\n            if(n+2<=v&&v<=n+n&&!ww[i]) mat[u]=v-n;\n        }\n    }\n    insert(1);\n    if(cnt!=n) return puts(\"-1\"),0;\n    for(int i=1;i<=n;i++) if(mat[i]) printf(\"%d %d\\n\",fa[mat[i]],mat[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\tconst int N = 2e5 + 5, INF = 0x3f3f3f3f;\n\n\tint n, s, t, Head[N], dep[N], cur[N], mat[N], from[N];\n\tpair<int, int> R[N];\n\tstruct edge { int to, next, w; } E[N << 2];\n\tvector<int> Bel[N >> 1]; \n\n\tinline void add(const int u, const int v)\n\t{\n\t\tstatic int ec = 1;\n\t\tE[++ec] = (edge){v, Head[u], 1};\n\t\tHead[u] = ec;\n\t\tE[++ec] = (edge){u, Head[v], 0};\n\t\tHead[v] = ec;\n\t}\n\n\tbool bfs()\n\t{\n\t\tmemcpy(cur, Head, sizeof(int[t + 1]));\n\t\tmemset(dep, 0, sizeof(int[t + 1]));\n\t\tstatic queue<int> q;\n\t\tq.push(s);\n\t\tdep[s] = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = Head[u], v; i; i = E[i].next)\n\t\t\t\tif (E[i].w && !dep[v = E[i].to])\n\t\t\t\t\tdep[v] = dep[u] + 1, q.push(v);\n\t\t}\n\t\treturn dep[t];\n\t}\n\n\tint dfs(const int u, const int mn)\n\t{\n\t\tif (u == t || !mn)\n\t\t\treturn mn;\n\t\tint v, w, used = 0;\n\t\tfor (int &i = cur[u]; i; i = E[i].next)\n\t\t\tif (E[i].w && dep[v = E[i].to] == dep[u] + 1)\n\t\t\t{\n\t\t\t\tw = dfs(v, min(mn - used, E[i].w));\n\t\t\t\tused += w;\n\t\t\t\tE[i].w -= w;\n\t\t\t\tE[i ^ 1].w += w;\n\t\t\t\tif (used == mn)\n\t\t\t\t\treturn used;\n\t\t\t}\n\t\tif (!used)\n\t\t\tdep[u] = -1;\n\t\treturn used;\n\t}\n\n\tint Dinic()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t\tans += dfs(s, INF);\n\t\treturn ans;\n\t}\n\n\tbool search()\n\t{\n\t\tstatic queue<int> q;\n\t\tq.push(n);\n\t\tfrom[n] = -1;\n\t\tint cnt = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(), p;\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\tfor (int i : Bel[x])\n\t\t\t\tif (!from[p = mat[i]])\n\t\t\t\t{\n\t\t\t\t\tR[i] = make_pair(x, p);\n\t\t\t\t\tfrom[p] = x;\n\t\t\t\t\tq.push(p);\n\t\t\t\t}\n\t\t}\n\t\treturn cnt == n;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1, c, j; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &j);\n\t\t\t\tif (j != n)\n\t\t\t\t\tadd(j, i + n);\n\t\t\t\tBel[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\ts = n + n, t = s + 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tadd(s, i), add(i + n, t);\n\t\tint flow = Dinic();\n\t\tif (flow != n - 1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor (int u = 1; u < n; u++)\n\t\t\t\tfor (int i = Head[u + n]; i; i = E[i].next)\n\t\t\t\t\tif (E[i].w == 1 && E[i].to < n)\n\t\t\t\t\t\tmat[u] = E[i].to;\n\t\t\tif (!search())\n\t\t\t\tputs(\"-1\");\n\t\t\telse\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tprintf(\"%d %d\\n\", R[i].first, R[i].second);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(dep[lb[y]]==dep[o]+1&&c[y])\n\tif(flow(lb[y])){\n\t\tc[y]=0;\n\t\tc[y^1]=1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[re[lb[y]]][0]=o;\n\t\tbb[re[lb[y]]][1]=lb[y];\n\t\t++oo;\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false) returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  ll build(int s, int t) {\n    vector< int > level(n);\n    ll flow = 0;\n    while(bfs(s, level), level[t] > 0) {\n      ll newflow = dfs(s, t, inf, level);\n      if(newflow == 0) break;\n      flow += newflow;\n      if(flow >= inf) return inf;\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] == -1 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e18;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := xを要素に持つグループら\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// メモ：\n// k個のグループにk頂点しか無い場合は自明にループができるので不可\n// よって (k+1) 頂点以上に繋がってていなきゃいけない\n// そのとき k 頂点に必ず繋がっていることになる\n// これは結婚定理と同じ条件なので，必ずn-1本のマッチングが存在することになる\n\n// すると E_i has i を必ず達成できるように番号付けできる\n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} が成り立ってはいけない，と言い換えられる\n// どのような頂点からはじめても，頂点Nにたどり着けなければならない\n// 頂点Nから逆にたどってやって，全てにたどり着けるかだけ調べればいい\n\n// その仮定で，そのDFS木をそのまま構成する木にできる\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v]){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        vector<ll> level(N,inf);\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%lld\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%lld\" , &c);\n        rep(i,0,c){\n            scanf (\"%lld\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%lld %lld\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int N = 200228;\nvector<int> e[N];\nvector<int> erev[N];\n\nint n;\n\nint p[N];\nint pr[N];\n\nint w[N];\nint curv;\n\nint av[N], au[N];\n\nvoid nein() {\n    cout << -1 << \"\\n\";\n    exit(0);\n}\n\nbool dfs(int v) {\n    if (w[v] == curv) {\n        return false;\n    }\n\n    w[v] = curv;\n\n    for (int u: e[v]) {\n        if (p[u] == 0) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    for (int u: e[v]) {\n        if (dfs(u)) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool go[N];\n\nvoid dfsgo(int v) {\n    go[v] = true;\n    for (int u: erev[v]) {\n        if (!go[pr[u]]) {\n            av[u] = v;\n            au[u] = pr[u];\n            dfsgo(pr[u]);\n        }\n    }\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n\n    cin >> n;\n\n    for (curv = 1; curv < n; ++curv) {\n        int s;\n        cin >> s;\n        e[curv].resize(s);\n        for (int& v: e[curv]) {\n            cin >> v;\n            erev[v].push_back(curv);\n        }\n\n        if (!dfs(curv)) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        pr[p[i]] = i;\n    }\n\n    int root = 1;\n    while (p[root]) {\n        ++root;\n    }\n\n    dfsgo(root);\n    for (int i = 1; i <= n; ++i) {\n        if (!go[i]) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        cout << av[i] << \" \" << au[i] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=400000+10,inf=0x3f3f3f3f;\nint n,fa[MAXN],e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<1],to[MAXN<<1],out[MAXN<<1],cap[MAXN<<1],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tfa[mh[v]]=x,vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,n)printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jump, and you will find out how to unfold your wings as you fall.\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=1e5+10,Src=maxn-3,Snk=maxn-2,inf=1e8;\n\nvector<pii>v[maxn];\nvector<int>vid[maxn];\nbool mark[maxn];\npii ans[maxn];\nint n,h[maxn],pt[maxn];\n\nvoid add_edge(int a,int b){\n    vid[a].PB(sz(v[b]));\n    vid[b].PB(sz(v[a]));\n    v[a].PB({b,1});\n    v[b].PB({a,0});\n}\n\nbool bfs(){\n    memset(mark,0,sizeof mark);\n    queue<int>q; q.push(Src); mark[Src]=1;\n    while(sz(q)){\n\tint u=q.front();\n\tif(u==Snk) return 1;\n\tq.pop();\n\tfor(pii p:v[u]){\n\t    if(p.S>0 && mark[p.F]==0){\n\t\th[p.F]=h[u]+1;\n\t\tmark[p.F]=1;\n\t\tq.push(p.F);\n\t    }\n\t}\n    }\n    return 0;\n}\nint dfs(int u,int flw=inf){\n    if(u==Snk) return flw;\n    int ans=0,&i=pt[u];\n    while(i<sz(v[u])){\n\tint y=v[u][i].F,&w=v[u][i].S,&w2=v[y][vid[u][i]].S;\n\tif(w>0 && h[u]+1==h[y]){\n\t    int num=dfs(y,min(flw-ans,w));\n\t    w-=num,w2+=num,ans+=num;\n\t    if(ans==flw) return ans;\n\t}\n\t++i;\n    }\n    return ans;\n}\nint flow(){\n    int ans=0;\n    while(bfs()){\n\tmemset(pt,0,sizeof pt);\n\tans+=dfs(Src);\n    }\n    return ans;\n}\n\nvoid go(int u,int par=-1){\n    mark[u]=1;\n    if(u>=n && u!=Src && u!=Snk){\n\tint y=-1;\n\tfor(pii p:v[u]){\n\t    if(p.S!=0)\n\t\ty=p.F;\n\t}\n\tans[u-n]={par+1,y+1};\n    }\n    for(pii p:v[u]){\n\tif(p.S!=0 && mark[p.F]==0)\n\t    go(p.F,u);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie();\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n\tint N;cin>>N;\n\twhile(N--){\n\t    int x;cin>>x;\n\t    add_edge(--x,i+n);\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tadd_edge(Src,i);\n    }\n    for(int i=n;i<2*n-1;i++){\n\tadd_edge(i,Snk);\n    }\n    int num=flow();\n    if(num!=n-1) return cout<<-1<<endl,0;\n    memset(mark,0,sizeof mark);\n    go(Src);\n    for(int i=0;i<n-1;i++){\n\tif(ans[i].F==0)\n\t    return cout<<-1<<endl,0;\n    }\n    for(int i=0;i<n-1;i++){\n\tcout<<ans[i].F<<\" \"<<ans[i].S<<\"\\n\";\n    }\n}\n\n// Deathly mistakes:\n//  * Read the problem curfully.\n//  * Check maxn.\n//  * Overflows.\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = lis[i - 1], v = pre[u];\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint n;\nstruct data{\n    int to,nxt,c;\n}mp[1000100];\nint head[500500],cnt=1;\nint cur[500500];\nvoid link(int x,int y,int c)\n{\n    mp[++cnt].to=y;\n    mp[cnt].nxt=head[x];\n    mp[cnt].c=c;\n    head[x]=cnt;\n}\nvoid add(int x,int y,int c){link(x,y,c);link(y,x,0);}\nint s,t;\nint dis[500500];\nqueue<int>q;\nbool BFS()\n{\n    for(int i=0;i<=t;++i)dis[i]=0;\n    dis[s]=1;q.push(s);\n    int u,v;\n    while(!q.empty())\n    {\n        u=q.front();q.pop();\n        for(int i=head[u];i;i=mp[i].nxt)\n            if(mp[i].c&&!dis[mp[i].to])\n            {\n                v=mp[i].to;\n                q.push(v);\n                dis[v]=dis[u]+1;\n            }\n    }\n    return dis[t];\n}\nint dfs(int x,int f)\n{\n    if(x==t)return f;\n    int rf=0,fl;\n    for(int& i=cur[x];i;i=mp[i].nxt)\n        if(mp[i].c&&dis[mp[i].to]==dis[x]+1)\n        {\n            fl=dfs(mp[i].to,min(mp[i].c,f));\n            if(fl)\n            {\n                f-=fl;\n                rf+=fl;\n                mp[i].c-=fl;\n                mp[i^1].c+=fl;\n                if(!f)break;\n            }\n        }\n    return rf;\n}\nint Dinic()\n{\n    int maxflow=0,flow;\n    while(BFS())\n    {\n        for(int i=1;i<=t;++i)cur[i]=head[i];\n        while(flow=dfs(s,inf))maxflow+=flow;\n    }\n    return maxflow;\n}\n\nvector<int>bel[100100];\nint par[100100];\nbool book[100100];\nint ed[100100][2],ted;\nvoid solve()\n{\n    int x,v;\n    for(x=2;x<=n;++x)\n    {\n        for(int i=head[x];i;i=mp[i].nxt)\n            if(mp[i].to>n&&mp[i].to<n*2&&!mp[i].c)\n                par[mp[i].to-n]=x;\n    }\n    q.push(1);\n    int siz;\n    while(!q.empty())\n    {\n        x=q.front();q.pop();\n        siz=bel[x].size();\n        for(int i=0;i<siz;++i)\n            if(!book[par[bel[x][i]]])\n            {\n                v=par[bel[x][i]];\n                book[v]=1;\n                q.push(v);\n                ed[bel[x][i]][0]=x;\n                ed[bel[x][i]][1]=v;\n                ted++;\n            }\n    }\n    if(ted!=n-1)puts(\"-1\"),exit(0);\n    for(int i=1;i<n;++i)printf(\"%d %d\\n\",ed[i][0],ed[i][1]);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    s=n*2;t=s+1;\n    int siz,xx;\n    for(int i=1;i<n;++i)\n    {\n        add(i+n,t,1);\n        scanf(\"%d\",&siz);\n        for(int j=1;j<=siz;++j)\n        {\n            scanf(\"%d\",&xx);\n            bel[xx].push_back(i);\n            if(xx!=1) add(xx,i+n,1);\n        }\n    }\n    for(int i=1;i<=n;++i)add(s,i,1);\n    int flow=Dinic();\n    if(flow!=n-1)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nnamespace MF{\n\t#define MAXN 252521\n\t#define MAXM 364364//実際の辺の2倍必要！！\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//フローを流した後の残余グラフからカットでS側に属する辺を求める\n\t//この後levの中身が非負な点がS側の点っぽい？(AOJ2396でverify済み？)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//マッチング相手\nbool used[200100];//マッチング相手として使われたか\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111],u[111111],v[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n)\n\t{\n\t\t::u[pa-n]=gp;\n\t\t::v[pa-n]=u;\n\t}\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=2;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=1;i<n;++i)if(!u[i])return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],pre[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t\tpre[y]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tflow++;\n\t\t\tfor (int x=T;x!=S;x=e[pre[x]].x){\n\t\t\t\te[pre[x]].cap^=1;\n\t\t\t\te[pre[x]^1].cap^=1;\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int INF = 1e9;\n\nstruct Edge {\n  int u, v, cap, flow;\n};\n\nnamespace Max_flow {\n\nvector<Edge> E;\nvector<int> G[N];\n\nint S, T, n, d[N];\n\nvoid init(int _n, int _s, int _t) {\n  n = _n, S = _s, T = _t;\n  for (int i = 0; i <= n; i++) G[i].clear();\n  E.clear();\n}\n\nvoid addedge(int u, int v, int cap) {\n  E.push_back((Edge) {u, v, cap, 0});\n  E.push_back((Edge) {v, u, 0, 0});\n  int m = E.size();\n  G[u].push_back(m - 2);\n  G[v].push_back(m - 1);\n}\n\nbool bfs() {\n  for (int i = 0; i <= n; i++) d[i] = 0;\n  d[S] = 1;\n  queue<int> q;\n  q.push(S);\n  while (q.size()) {\n    int u = q.front(); q.pop();\n    for (int i : G[u]) {\n      if (E[i].cap > E[i].flow && !d[E[i].v]) {\n        d[E[i].v] = d[u] + 1;\n        q.push(E[i].v);\n      }\n    }\n  }\n  return d[T];\n}\n\nint dfs(int u, int a) {\n  if (!a || u == T) return a;\n  int flow = 0;\n  for (int i : G[u]) {\n    if (d[E[i].v] != d[u] + 1) continue;\n    int f = dfs(E[i].v, min(E[i].cap - E[i].flow, a));\n    flow += f;\n    a -= f;\n    E[i].flow += f;\n    E[i ^ 1].flow -= f;\n  }\n  if (!flow) d[u] = 0;\n  return flow;\n}\n\nint max_flow() {\n  int flow = 0;\n  while (bfs()) {\n    flow += dfs(S, INF);\n  }\n  return flow;\n}\n\n}\n\nint n, c[N], p[N], q[N], vis[N];\nvector<int> g[N], bel[N];\n\nint main() {\n  scanf(\"%d\", &n);\n  Max_flow::init(2 * n + 1, 0, 2 * n + 1);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d\", &c[i]);\n    g[i].resize(c[i]);\n    Max_flow::addedge(0, i, 1);\n    for (int j = 0; j < c[i]; j++) {\n      scanf(\"%d\", &g[i][j]);\n      bel[g[i][j]].push_back(i);\n      Max_flow::addedge(i, g[i][j] + n, 1);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    Max_flow::addedge(i + n, 2 * n + 1, 1);\n  }\n  if (Max_flow::max_flow() != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (Edge e : Max_flow::E) {\n    if (e.u <= n && e.v > n && e.cap == e.flow) {\n      p[e.u] = e.v - n;\n      vis[e.v - n] = 1;\n    }\n  }\n  queue<int> tmp;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) tmp.push(i);\n    vis[i] = 0;\n  }\n  int cnt = 0;\n  while (tmp.size()) {\n    cnt++;\n    int u = tmp.front(); tmp.pop();\n    for (int i : bel[u]) if (!vis[i]) {\n      vis[i] = 1;\n      q[i] = u;\n      tmp.push(p[i]);\n    }\n  }\n  if (cnt != n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", p[i], q[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 200000;\nconst int M = N << 4;\n\nint S, T;\n\nstruct edge {\n    int to, nxt, cap;\n};\n\nedge e[M + 5];\nint st[N + 5], ecnt = 1;\n\nvoid addedge(int u, int v, int c) {\n    e[++ ecnt] = (edge) { v, st[u], c }, st[u] = ecnt;\n    e[++ ecnt] = (edge) { u, st[v], 0 }, st[v] = ecnt;\n}\n\nint cur[N + 5], dis[N + 5];\n\nbool bfs() {\n    static int que[N + 5];\n    int head = 0, tail = 0;\n\n    memset(dis, 0xff, sizeof dis);\n    dis[que[tail ++] = S] = 0;\n\n    while(head < tail) {\n        int x = que[head ++];\n        for(int i = st[x]; i; i = e[i].nxt) if(e[i].cap) {\n            int y = e[i].to;\n            if(dis[y] == -1) {\n                dis[y] = dis[x] + 1;\n                que[tail ++] = y;\n            }\n        }\n    }\n    return ~dis[T];\n}\n\nint dfs(int x, int flow) {\n    if(x == T || !flow) {\n        return flow;\n    }\n\n    int res = 0;\n    for(int &i = cur[x]; i; i = e[i].nxt) {\n        int y = e[i].to, aug;\n        if(dis[y] == dis[x] + 1 && (aug = dfs(y, std::min(e[i].cap, flow)))) {\n            res += aug;\n            flow -= aug;\n            e[i].cap -= aug;\n            e[i ^ 1].cap += aug;\n            if(!flow) break;\n        }\n    }\n    return res;\n}\n\nint max_flow() {\n    int ans = 0;\n    while(bfs()) {\n        memcpy(cur, st, sizeof (int) * (T + 1));\n        ans += dfs(S, oo);\n    }\n    return ans;\n}\n\nint n, cnt;\npii ans[N + 5];\nint mat[N + 5];\nbool vis[N + 5];\nvector<int> g[N + 5];\n\nvoid dfs(int u) {\n    for(auto v : g[u]) if(!vis[v]) {\n        ++ cnt;\n        vis[v] = true;\n        ans[v - n] = mp(u, mat[v]);\n        dfs(mat[v]);\n    }\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    S = n << 1, T = S + 1;\n    for(int i = 2; i <= n; ++i) {\n        addedge(S, i, 1);\n    }\n\n    for(int i = 1; i < n; ++i) {\n        static int c, x;\n\n        for(read(c); c--; ) {\n            read(x);\n            g[x].pb(i + n);\n            addedge(x, i + n, 1);\n        }\n        addedge(i + n, T, 1);\n    }\n\n    int mf = max_flow();\n\n    if(mf < n - 1) return !puts(\"-1\");\n\n    for(int i = 2; i <= n; ++i) {\n        for(int j = st[i]; j; j = e[j].nxt) {\n            int t = e[j].to;\n            if(!e[j].cap && t > n && t < 2*n) {\n                mat[t] = i;\n                break;\n            }\n        }\n    }\n\n    dfs(1);\n\n    if(cnt < n - 1) {\n        puts(\"-1\");\n    } else {\n        for(int i = 1; i < n; ++i) {\n            printf(\"%d %d\\n\", ans[i].fst, ans[i].snd);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int i=head[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()) {\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e6, inf = 1e9;\nint n, tot, ter[maxn + 3], wei[maxn + 3], nxt[maxn + 3], lnk[maxn + 3];\nint cur[maxn + 3], dep[maxn + 3], num[maxn + 3], ans[maxn + 3];\nbool vis[maxn + 3];\nvector<int> S[maxn + 3], V[maxn + 3], G[maxn + 3];\n\nint adj(int x) {\n\treturn x & 1 ? x + 1 : x - 1;\n}\n\nint add(int u, int v, int w) {\n\tter[++tot] = v, wei[tot] = w;\n\tnxt[tot] = lnk[u], lnk[u] = tot;\n\treturn tot;\n}\n\nint add_f(int u, int v) {\n\tint t = add(u, v, 1);\n\treturn add(v, u, 0), t;\n}\n\nbool bfs() {\n\tqueue<int> Q;\n\tQ.push(1);\n\tmemset(dep, -1, sizeof(dep));\n\tdep[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = lnk[u], v, w; i; i = nxt[i]) {\n\t\t\tv = ter[i], w = wei[i];\n\t\t\tif ((~dep[v]) || !w) continue;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tQ.push(v);\n\t\t}\n\t}\n\treturn ~dep[n * 2];\n}\n\nint dfs(int u, int t, int lft) {\n\tif (u == t) {\n\t\treturn lft;\n\t}\n\tint ret = 0;\n\tfor (int &i = cur[u], v, w; i && ret < lft; i = nxt[i]) {\n\t\tv = ter[i], w = wei[i];\n\t\tif (w && dep[u] + 1 == dep[v]) {\n\t\t\tint x = dfs(v, t, min(lft - ret, w));\n\t\t\twei[i] -= x, wei[adj(i)] += x, ret += x;\n\t\t}\n\t}\n\tif (ret < lft) {\n\t\tdep[u] = -1;\n\t}\n\treturn ret;\n}\n\nint flow() {\n\tint ret = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur, lnk, sizeof(cur));\n\t\tret += dfs(1, n * 2, inf);\n\t}\n\treturn ret;\n}\n\nvoid dfs(int u) {\n\tvis[u] = true;\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tv = G[u][i];\n\t\tif (vis[v]) continue;\n\t\tans[v] = u;\n\t\tdfs(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, m; i <= n - 1; i++) {\n\t\tscanf(\"%d\", &m);\n\t\tS[i].resize(m), V[i].resize(m);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &S[i][j]);\n\t\t\tif (S[i][j] != 1) {\n\t\t\t\tV[i][j] = add_f(S[i][j], i + n);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tadd_f(1, i);\n\t}\n\tfor (int i = n + 1; i < n * 2; i++) {\n\t\tadd_f(i, n * 2);\n\t}\n\tif (flow() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint x = 0;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != 1 && !wei[V[i][j]]) {\n\t\t\t\tx = S[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum[i] = x;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != x) {\n\t\t\t\tG[S[i][j]].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tputs(\"-1\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tprintf(\"%d %d\\n\", ans[num[i]], num[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,\n\t\t\tvi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\n\nvector<vector<int> > g;\nvector<int> btoa;\n\nvector<vector<pair<int,int> > > edges;\nint main(){\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tbtoa.resize(n, -1);\n\tfor(int i = 1; i < n; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tfor(int a = 0; a < c; a++){\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\td--;\n\t\t\tg[i].push_back(d);\n\t\t}\n\t}\n\tg[0].push_back(0);\n\tif(hopcroftKarp(g, btoa) < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> a(n);\n\tvector<int> b(n);\n\tfor(int i = 0; i < n; i++){\n\t\ta[btoa[i]] = i;\n\t}\n\n\tedges.resize(n);\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int r : g[i]){\n\t\t\tedges[r].push_back({a[i], i});\n\t\t}\n\t}\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint s = 0;\n\tvector<int> vis(n, 0);\n\tvis[0] = 1;\n\tint cnt = 1;\n\twhile(s < bfs.size()){\n\t\tint x = bfs[s];\n\t\ts++;\n\t\tfor(auto r : edges[x]){\n\t\t\tif(vis[r.first]) continue;\n\t\t\tvis[r.first] = 1;\n\t\t\tcnt++;\n\t\t\tb[r.second] = x;\n\t\t\tbfs.push_back(r.first);\n\t\t}\n\t}\n\tif(cnt < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tcout << a[i] + 1 << \" \" << b[i] + 1 << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace IO {\n\tconst int SIZE = 1 << 20;\n\tchar buf[SIZE + 10], *iS, *iT;\n\tinline char Getc() {\n\t\treturn iS == iT && (iT = (iS = buf) + fread(buf, 1, SIZE, stdin), iS == iT) ? EOF : *iS++;\n\t}\n\ttemplate <class TT>\n\tinline void Read(TT &x) {\n\t\tx = 0; register char cc = '\\0'; TT fff = 1;\n\t\tfor (; cc < '0' || cc > '9'; cc = Getc())\n\t\t\tif (cc == '-') fff = -1;\n\t\tfor (; cc >= '0' && cc <= '9'; cc = Getc())\n\t\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\t\tx *= fff;\n\t}\n}\nusing IO::Read;\n\nconst int N = 2e5 + 10, M = 1e6 + 10;\n\nvector<int> bel[N];\nvector<pair<int, int> > bufans; int Connect[N]; bool vis[N];\nint n, tot, stp, edp, hd, tl, fans, Q[N + 10], dep[N], Cur[N], Head[N], Next[M], Adj[M], W[M];\n\ninline void Addedge(int x, int y, int z) {\n/*\n\tprintf(\"%d %d %d\\n\", x, y, z);\n*/\n\tNext[++tot] = Head[x]; Head[x] = tot; Adj[tot] = y; W[tot] = z;\n\tNext[++tot] = Head[y]; Head[y] = tot; Adj[tot] = x; W[tot] = 0;\n}\n\ninline bool BFS() {\n\tfill(dep, dep + 1 + edp, -1), hd = tl = 0;\n\tQ[++tl] = stp, dep[stp] = 0;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\tfor (int e = Head[x]; e; e = Next[e])\n\t\t\tif (W[e] > 0 && dep[Adj[e]] == -1) {\n\t\t\t\tdep[Adj[e]] = dep[x] + 1;\n\t\t\t\tQ[++tl] = Adj[e];\n\t\t\t}\n\t}\n\treturn dep[edp] != -1;\n}\n\nint DFS(int x, int mxflow) {\n\tif (x == edp || !mxflow) return mxflow;\n\tfor (int &e = Cur[x]; e; e = Next[e])\n\t\tif (W[e] > 0 && dep[Adj[e]] == dep[x] + 1) {\n\t\t\tint ntflow = DFS(Adj[e], min(mxflow, W[e]));\n\t\t\tif (ntflow > 0) {\n\t\t\t\tW[e] -= ntflow;\n\t\t\t\tW[e ^ 1] += ntflow;\n\t\t\t\treturn ntflow;\n\t\t\t}\n\t\t}\n\treturn 0; /* star! */\n}\n\ninline void Dinic() {\n\tfans = 0;\n\twhile (BFS()) {\n\t\tint nflow = 0;\n\t\tcopy(Head, Head + 1 + edp, Cur);\n\t\twhile ((nflow = DFS(stp, 0x3f3f3f3f)) != 0)\n\t\t\tfans += nflow;\n\t}\n}\n\ninline void Extend(int x) {\n\tfor (int j = 0; j < (int)bel[x].size(); ++j)\n\t\tif (!vis[bel[x][j]]) {\n\t\t\tbufans.push_back(make_pair(x, Connect[bel[x][j]]));\n\t\t\tvis[bel[x][j]] = true, Q[++tl] = Connect[bel[x][j]];\n\t\t}\n}\n\ninline void Solve() {\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int e = Head[n + i]; e; e = Next[e])\n\t\t\tif (Adj[e] <= n && W[e] > 0)\n\t\t\t\tConnect[n + i] = Adj[e];\n\thd = tl = 0;\n\tQ[++tl] = 1;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\tExtend(x);\n\t}\n}\n\nint main()\n{\n\tRead(n), tot = 1 /* !!! */;\n\tstp = 2 * n, edp = 2 * n + 1;\n\tfor (int i = 2; i <= n; ++i) Addedge(stp, i, 1);\n\tfor (int i = 1; i < n; ++i) Addedge(n + i, edp, 1);\n\tfor (int i = 1, ilen; i < n; ++i) {\n\t\tRead(ilen);\n\t\tfor (int j = 1, x; j <= ilen; ++j) {\n\t\t\tRead(x);\n\t\t\tbel[x].push_back(n + i);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i)\n\t\tfor (int j = 0; j < (int)bel[i].size(); ++j /* not i */)\n\t\t\tAddedge(i, bel[i][j], 1);\n\tDinic();\n\tif (fans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tSolve();\n\tif ((int)bufans.size() < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int j = 0; j < (int)bufans.size(); ++j)\n\t\tprintf(\"%d %d\\n\", bufans[j].first, bufans[j].second);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, M = 8e5 + 5;\n\nstruct edge_t { int u, v, next, cap, flow; } G[M];\n\nvector <int> adj[N];\nqueue <int> q;\nint head[N], nowhead[N], d[N];\nint n, m, s, t, tot = 1;\n\ninline void addedge(int u, int v, int cap) {\n\tG[++tot] = (edge_t) {u, v, head[u], cap, 0}, head[u] = tot;\n\tG[++tot] = (edge_t) {v, u, head[v], 0, 0}, head[v] = tot;\n}\n\nint bfs() {\n\tmemset(d, 0, sizeof(d));\n\td[s] = 1; q.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (!d[v] && G[i].cap > G[i].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\n\nint dfs(int u, int Flow) {\n\tif (u == t || !Flow) return Flow;\n\tint f, flow = 0;\n\tfor (int &i = nowhead[u]; i; i = G[i].next) {\n\t\tint v = G[i].v;\n\t\tif (d[v] == d[u] + 1 && (f = dfs(v, min(Flow, G[i].cap - G[i].flow))) > 0) {\n\t\t\tG[i].flow += f; G[i ^ 1].flow -= f;\n\t\t\tflow += f; Flow -= f;\n\t\t\tif (!Flow) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint dinic() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemcpy(nowhead, head, sizeof(nowhead));\n\t\tans += dfs(s, 0x7fffffff);\n\t}\n\treturn ans;\n}\n\nint fa[N], vis[N], match[N], cnt;\n\nint main() {\n\tread(n); s = 0; t = 2 * n;\n\tfor (int i = 1; i < n; i++) {\n\t\tread(m);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x; read(x);\n\t\t\tadj[i].push_back(x + n - 1);\n\t\t\tadj[x + n - 1].push_back(i);\n\t\t\taddedge(i, x + n - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) addedge(s, i, 1);\n\tfor (int i = n; i < 2 * n; i++) addedge(i, t, 1);\n\tif (dinic() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint rt = 0;\n\tfor (int i = head[n * 2]; i; i = G[i].next) {\n\t\tif (G[i].flow == 0) {\n\t\t\trt = G[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int u = 1; u < n; u++) {\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (n <= v && v < n * 2 && G[i].flow) match[u] = v;\n\t\t}\n\t}\n\tq.push(rt); vis[rt] = 1;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (auto v : adj[u]) {\n\t\t\tif (!vis[match[v]]) {\n\t\t\t\tvis[match[v]] = 1;\n\t\t\t\tfa[match[v]] = u;\n\t\t\t\t++cnt;\n\t\t\t\tq.push(match[v]);\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tprint(match[i] - n + 1, ' ');\n\t\tprint(fa[match[i]] - n + 1, '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nvector<int> E[N],in[N];\nnamespace Graph{\n\tconst int inf = 1e9;\n\tvector<pair<int,int> > ans;\n\tint n,tot,t,head[N],b[N],vis[N],cur[N];\n\tstruct edge{int v,nxt,f;}e[N*2];\n\tvoid init(int m){\n\t\tn=m;t=2*n+1;tot=1;\n\t}\n\tvoid add(int x,int y,int z){\n\t\te[++tot]={y,head[x],z};\n\t\thead[x]=tot;\n\t\te[++tot]={x,head[y],0};\n\t\thead[y]=tot;\n\t}\n\tbool bfs(){\n\t\tmemset(b,0,sizeof(b));b[0]=1;\n\t\tqueue<int> q;q.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&!b[e[i].v]){\n\t\t\t\t\tb[e[i].v]=b[u]+1;\n\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t}\n\t\t}\n\t\treturn b[t];\n\t}\n\tint dfs(int x,int flow){\n\t\tif(!flow||x==t) return flow;\n\t\tint f=flow,tmp;\n\t\tfor(int &i=cur[x];i;i=e[i].nxt)\n\t\t\tif(b[e[i].v]==b[x]+1&&(tmp=dfs(e[i].v,min(e[i].f,f)))){\n\t\t\t\tf-=tmp;e[i].f-=tmp;e[i^1].f+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\treturn flow-f;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tans+=dfs(0,inf);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(int x){\n\t\tvis[x]=1;\n\t\tvector<int> v;\n\t\tfor(int p:in[x])\n\t\t\tfor(int i=head[p+n];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&e[i].v!=t) v.push_back(e[i].v);\n\t\tfor(int p:v) if(!vis[p]){\n\t\t\tans.emplace_back(x,p);\n\t\t\tsolve(p);\n\t\t}\n\t}\n\tvoid print(){\n\t\tif(ans.size()!=n-1){puts(\"-1\");return;}\n\t\tfor(auto&pr:ans)\n\t\t\tprintf(\"%d %d\\n\",pr.first,pr.second);\n\t}\n}\nint n;\nint main(){\n\tread(n);\n\tGraph::init(n);\n\tfor(int i=1;i<n;i++){\n\t\tint k;read(k);\n\t\twhile(k--){\n\t\t\tint x;read(x);\n\t\t\tE[i].push_back(x);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int x:in[i]) Graph::add(i,x+n,1);\n\t\tGraph::add(0,i,1);\n\t}\n\tfor(int i=1;i<n;i++) Graph::add(i+n,Graph::t,1);\n\tif(Graph::Dinic()<n-1){puts(\"-1\");return 0;}\n\tGraph::solve(1);\n\tGraph::print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        ans += dfs(s,t,inf);\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , bel[N] , n;\n\nint main(){\n//\tfreopen(\"in04.txt\",\"r\",stdin);\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1 && e[j].to != 1){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t\tbel[e[j].to] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"_-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nint cur;\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v] == cur) {\n        return false;\n    }\n    used[v] = cur;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (p[to] == -1) {\n                p[to] = i;\n                nxt[i] = to;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            ++cur;\n            dfs(i);\n        }\n    }\n    /*for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }*/\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 100010\n#define T n+n+1\n#define add(x,y,z) addedge(x,y,z),addedge(y,x,0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nint head[N],tot=1,cur[N],vis[N],dis[N],n,p[N],fa[N],s; vector<int> v[N];\nstruct Edge{int v,next,f,w;}edge[N*10]; queue<int> q;\ninline void addedge(int x,int y,int z){edge[++tot]=Edge{y,head[x],0,z};head[x]=tot;}\ninline int bfs()\n{\tmemset(vis,0,sizeof(vis)); memcpy(cur,head,sizeof(cur)); q.push(0); vis[0]=1;\n\twhile(!q.empty())\n\t{\tint x=q.front(); q.pop();\n\t\tfor(rint i=head[x];i;i=edge[i].next)\n\t\tif(!vis[to]&&edge[i].f<edge[i].w) dis[to]=dis[x]+1,vis[to]=1,q.push(to);\n\t}\n\treturn vis[T];\n}\nint dfs(int x,int res)\n{\tif(x==T||!res) return res; int flow=0,f;\n\tfor(rint &i=cur[x];i;i=edge[i].next)\n\tif(dis[to]==dis[x]+1&&(f=dfs(to,min(res,edge[i].w-edge[i].f))))\n\t{edge[i].f+=f;edge[i^1].f-=f;res-=f;flow+=f;if(!res)break;}\n\treturn flow;\n}\ninline int dinic(){int A=0;while(bfs())A+=dfs(0,INT_MAX);return A;}\nvoid dfs(int x){vis[x]=1;s++;for(auto y:v[x])if(!vis[p[y]])fa[y]=x,dfs(p[y]);}\nint main()\n{\tint m,x; cin>>n; for(rint i=1;i<=n;i++) add(n+i,T,1);\n\tfor(rint i=1;i<n;add(0,i,1),i++)\n\tfor(scanf(\"%d\",&m);m--;){scanf(\"%d\",&x),v[x].push_back(i);if(x!=1)add(i,n+x,1);}\n\tif(dinic()!=n-1) return !printf(\"-1\");\n\tfor(rint j=1;j<n;j++)\n\tfor(rint i=head[j];i;i=edge[i].next) if(n<to&&to<=n+n&&edge[i].f) p[j]=to-n;\n\tdfs(1); if(s!=n) return !printf(\"-1\");\n\tfor(rint i=1;i<n;i++) printf(\"%d %d\\n\",fa[i],p[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 200010\n#define left _left\n#define right _right\nvector <int> adj[maxn];\nset <int> st[maxn];\nint left[maxn], right[maxn], vis[maxn], n;\n\n\nbool dfs (int v){\n\tif (vis[v]) return 0;\n\tvis[v]=1;\n\tfor (int i=0; i<adj[v].size(); i++){\n\t\tint nt= adj[v][i];\n\t\tif (right[nt]==-1 or dfs(right[nt])){\n\t\t\tright[nt]=v;\n\t\t\tleft[v]=nt;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint match (){\n\tmemset(left, -1, sizeof(left));\n\tmemset(right, -1, sizeof(right));\n\tint res=0;\n\twhile(1){\n\t\tint ok= 0;\n\t\tfor (int i=1; i<=n; i++) vis[i]=0;\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tif (left[i]==-1 and !vis[i] and dfs(i)){\n\t\t\t\tres++;\n\t\t\t\tok=1;\n\t\t\t}\n\t\t}\n\t\tif (!ok) break;\n\t}\n\treturn res;\n}\n\nint par[maxn], tk[maxn];\n\nint U[maxn], V[maxn];\n\nint main(){\n\tint x, y;\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tcin>>x;\n\t\twhile (x--){\n\t\t\tcin>>y;\n\t\t\tst[i].insert(y);\n\t\t\tadj[y].push_back(i);\n\n\t\t}\n\t}\n\tif(match()<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tint root;\n\tfor (int i=1; i<=n; i++){\n\t\tif (left[i]==-1) root=i;\n\t}\n\ttk[root]=1;\n\tqueue <int> Q;\n\tmemset(par, -1, sizeof(par));\n\tpar[root]=root;\n\tQ.push(root);\n\tfor (int i=0; i<adj[root].size(); i++){\n\t\tint nst= adj[root][i];\n\t\tst[nst].erase(st[nst].find(root));\n\t}\n\twhile(!Q.empty()){\n\t\tint v= Q.front(), ok=0;\n\t\tfor (int i=0; i<adj[v].size(); i++){\n\t\t\tint nst= adj[v][i], nt= right[nst];\n\t\t\tif (tk[nt]) continue;\n\t\t\tok=1;\n\t\t\tpar[nt]= v;\n\t\t\ttk[nt]=1;\n\t\t\tU[nst]= nt;\n\t\t\tV[nst]= v;\n\t\t\tQ.push(nt);\n\t\t}\n\t\tif (!ok) Q.pop();\n\t}\n\tfor (int i=1; i<=n; i++){\n\t\tif (par[i]<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1; i<n; i++) cout<<U[i]<<\" \"<<V[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n \n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n \ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n \n// ========================================================================= //\n \nint main() {\n    ios::sync_with_stdio(false);\n \n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n \n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n \n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n \n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i)) {\n                    was = 1; pv[i] = 1; }\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n \n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n \n    vector<ipair> es(n - 1);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es[s] = {v, nv};\n            ++cnt;\n            dfs(nv);\n        }\n    };\n    dfs(root);\n \n    if (cnt != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:134217728\")\n\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <memory>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\ntypedef long long Int;\ntypedef pair<int,int> PII;\ntypedef vector<int> VInt;\n\n#define FOR(i, a, b) for(i = (a); i < (b); ++i)\n#define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i)\n#define CLEAR(a, b) memset(a, b, sizeof(a))\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define PB push_back\n#define MP make_pair\n\nVInt EV[1 << 18];\nVInt ES[1 << 18];\nint PV[1 << 18];\nint PS[1 << 18];\nint B[1 << 18];\nPII R[1 << 18];\nint gMark;\n\nint dfs(int s)\n{\n\tif (B[s] == gMark) return 0;\n\tB[s] = gMark;\n\tfor (auto it = ES[s].begin(); it != ES[s].end(); ++it)\n\t{\n\t\tif(PV[*it] == -1 || dfs(PV[*it]) != 0)\n\t\t{\n\t\t\tPV[*it] = s;\n\t\t\tPS[s] = *it;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint f(int n)\n{\n\tgMark = 0;\n\tCLEAR(B, -1);\n\tCLEAR(PV, -1);\n\tCLEAR(PS, -1);\n\tint i, j;\n\tFOR(i, 0, n - 1)\n\t\tif(PS[i] == -1)\n\t\t{\n\t\t\t++gMark;\n\t\t\tif (dfs(i) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\n\n\tVInt bv(n, 0);\n\tVInt bs(n, 0);\n\tFOR(i, 0, n)\n\t\tif (PV[i] == -1)\n\t\t\tbreak;\n\n\tbv[i] = 1;\n\tqueue<PII> q;\n\tfor (auto it = EV[i].begin(); it != EV[i].end(); ++it) q.push(PII(i, *it));\n\tFOR(i, 1, n)\n\t{\n\t\twhile (!q.empty() && bs[q.front().second] != 0) q.pop();\n\t\tif (q.empty()) return 0;\n\t\tint v = q.front().first;\n\t\tint s = q.front().second;\n\t\tint w = PS[s];\n\t\tbs[s] = 1;\n\t\tbv[w] = 1;\n\t\tR[s] = PII(v, w);\n\t\tfor (auto it = EV[w].begin(); it != EV[w].end(); ++it) q.push(PII(w, *it));\n\t}\n\n\treturn 1;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tint i, j;\n\tFOR(i, 0, n - 1)\n\t{\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tFOR(j, 0, m)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\t--a;\n\t\t\tEV[a].push_back(i);\n\t\t\tES[i].push_back(a);\n\t\t}\n\t}\n\n\tif(f(n) == 0) printf(\"-1\\n\");\n\telse FOR(i, 0, n - 1) printf(\"%d %d\\n\", R[i].first + 1, R[i].second + 1);\n\treturn 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=z,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||!c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    puts(\"-1\");exit(0);\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int INF=0x3f3f3f3f;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\ninline int read() {\n\tint x=0; char ch;\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+2*NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tinline void AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int Aug(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tint sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min(e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tint Flow;\n\tint ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tn=read();\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c,u;i<n;i++) {\n\t\tc=read();\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1;j<=c;j++) {\n\t\t\tu=read();\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e_orig[a].PB(Edge{b, cap, SZ(e_orig[b])});\n    e_orig[b].PB(Edge{a, bi_dir * cap, SZ(e_orig[a]) - 1});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n\n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n    for (int i = 0; i <= n; i++) {\n      dis[i] = n + 1;\n    }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e_orig.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<int> halko;\n    for (auto edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        halko.PB(edge.v - n);\n      }\n    }\n    assert(SZ(halko) == 2);\n    for (auto x : halko) {\n      cout<<x<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\nvector<int> r;\nvector<int> z;\n\nint ccc = 0;\n\nbool dfs(int x) {\n//    cout << x << \"\\n\";\n    if (z[x] == ccc) return false;\n    z[x] = ccc;\n    for (int y : g[x]) {\n        if (r[y] == -1 || dfs(r[y])) {\n            r[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    g.resize(n);\n    r.assign(n, -1);\n    z.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x;\n            x--;\n            g[x].push_back(i);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::random_shuffle(g[i].begin(), g[i].end());\n    }\n\n    int ff = -1;\n    for (int i = 0; i < n; i++) {\n        ccc++;\n        bool ok = false;\n        for (int y : g[i]) {\n            if (r[y] == -1) {\n                r[y] = i;\n                ok = true;\n            }\n        }\n        if (!ok) {\n            if (!dfs(i)) {\n                if (ff == -1) {\n                    ff = i;\n                } else {\n                    cout << -1 << \"\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n\n//    for (int i = 0; i < n - 1; i++) {\n//        cout << r[i] << \"\\n\";\n//    }\n\n    vector<int> q;\n    vector<bool> zz(n);\n    q.push_back(ff);\n    vector<pair<int, int>> res(n - 1);\n    for (int i = 0; i < q.size(); i++) {\n        int x = q[i];\n        for (int c : g[x]) {\n            if (!zz[c]) {\n                zz[c] = true;\n                q.push_back(r[c]);\n                res[c] = {r[c], x};\n            }\n        }\n    }\n\n    if (q.size() < n) {\n        cout << \"-1\\n\";\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            cout << res[i].first + 1 << \" \" << res[i].second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=2147483647;\nstruct Edge\n{\n\tint to;\n\tint next;\n\tint flow;\n}e[1000005];\nint n,m,s,t,edgenum=1,head[1000005],dep[1000005],cur[1000005],match[100005],pa[100005];\nbool flag[100005];\nvector<int>root[100005];\nqueue<int>q;\nvoid add(int u,int v,int f)\n{\n\te[++edgenum].flow=f;\n\te[edgenum].to=v;\n\te[edgenum].next=head[u];\n\thead[u]=edgenum;\n}\nbool bfs()\n{\n\twhile(!q.empty())q.pop();\n\tmemset(dep,0,sizeof(dep));\n\tdep[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int hd=head[node];hd;hd=e[hd].next)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(e[hd].flow==0)continue;\n\t\t\tif(!dep[to])\n\t\t\t{\n\t\t\t\tdep[to]=dep[node]+1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\tif(dep[t])return 1;\n\t}\n\treturn 0;\n}\nint dfs(int node,int nowf)\n{\n\tif(node==t)return nowf;\n\tif(nowf==0)return 0;\n\tfor(int&hd=cur[node];hd;hd=e[hd].next)\n\t{\n\t\tint to=e[hd].to;\n\t\tif(e[hd].flow==0)continue;\n\t\tif(dep[to]==dep[node]+1)\n\t\t{\n\t\t\tint d=dfs(to,min(nowf,e[hd].flow));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te[hd].flow-=d;\n\t\t\t\te[hd^1].flow+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic()\n{\n\tint ans=0,d;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;i++)\n\t\t  cur[i]=head[i];\n\t\twhile(d=dfs(s,INF))\n\t\t  ans+=d;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=1,t=2*n;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tfor(int i=n+1;i<2*n;i++)\n\t{\n\t\tadd(i,t,1);\n\t\tadd(t,i,0);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint size;\n\t\tscanf(\"%d\",&size);\n\t\twhile(size--)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\troot[x].push_back(i);\n\t\t\tx--;\n\t\t\tif(x==0)continue;\n\t\t\tadd(i,x+n,1);\n\t\t\tadd(x+n,i,0);\n\t\t}\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  for(int hd=head[i];hd;hd=e[hd].next)\n\t\tif(e[hd].flow==0)\n\t\t  match[i]=e[hd].to-n+1;\n\twhile(!q.empty())q.pop();\n\tq.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<root[node].size();i++)\n\t\t{\n\t\t\tif(flag[root[node][i]])continue;\n\t\t\tflag[root[node][i]]=1;\n\t\t\tpa[match[root[node][i]]]=node;\n\t\t\tq.push(match[root[node][i]]);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\tif(!pa[i])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  printf(\"%d %d\\n\",pa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst int N = 202020;\n\n// bpm forked from 'https://atcoder.jp/contests/agc029/submissions/3802895'\nstruct bpm{\n\tvector<int> gph[N];\n\tint dis[N], l[N], r[N], vis[N];\n\tvoid clear(){ for(int i=0; i<N; i++) gph[i].clear();\t}\n\tvoid add_edge(int l, int r){ gph[l].push_back(r); }\n\tbool bfs(int n){\n\t\tqueue<int> que;\n\t\tbool ok = 0;\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(l[i] == -1 && !dis[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdis[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &i : gph[x]){\n\t\t\t\tif(r[i] == -1) ok = 1;\n\t\t\t\telse if(!dis[r[i]]){\n\t\t\t\t\tdis[r[i]] = dis[x] + 1;\n\t\t\t\t\tque.push(r[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tbool dfs(int x){\n\t\tif(vis[x]) return 0;\n\t\tvis[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(r[i] == -1 || (!vis[r[i]] && dis[r[i]] == dis[x] + 1 && dfs(r[i]))){\n\t\t\t\tl[x] = i; r[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match(int n){\n\t\tmemset(l, -1, sizeof(l));\n\t\tmemset(r, -1, sizeof(r));\n\t\tint ret = 0;\n\t\twhile(bfs(n)){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tfor(int i=0; i<n; i++) if(l[i] == -1 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool chk[N + N];\n\tvoid rdfs(int x, int n){\n\t\tif(chk[x]) return;\n\t\tchk[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tchk[i + n] = 1;\n\t\t\trdfs(r[i], n);\n\t\t}\n\t}\n\tvector<int> getcover(int n, int m){ // solve min. vertex cover\n\t\tmatch(n);\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor(int i=0; i<n; i++) if(l[i] == -1) rdfs(i, n);\n\t\tvector<int> v;\n\t\tfor(int i=0; i<n; i++) if(!chk[i]) v.push_back(i);\n\t\tfor(int i=n; i<n+m; i++) if(chk[i]) v.push_back(i);\n\t\treturn v;\n\t}\n \n}bpm;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) bpm.add_edge(i, u);\n                }\n        }\n        int cnt = bpm.match(n);\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(bpm.l[en], u);\n                        que.push(bpm.l[en]);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=200010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tvector<pair<int,int> >ans;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans.push_back(make_pair(u,link[v]));\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,0,SZ(ans)-1)cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=400010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N],ans[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans[link[v]]=u;\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,1,n-1)cout<<ans[link[i]]<<\" \"<<link[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\tdsu tmp(n);\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching(), res(n-1);\n\tfor(auto [i, x] : matching) {\n\t\t//cout << i << \" \" << x << endl;\n\t\tx -= n-1;\n\t\tfor(auto y : f[i-1]) if(!tmp.con(x-1, y-1)) {\n\t\t\ttmp.unite(x-1, y-1);\n\t\t\tres[i-1] = {x, y};\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a << \" \" << b << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int inf=1000000000;\nint n,m,cnt,id[100001],p[100001],P[100001],hd[200101],cur[200101],dis[200101],q[200101],l,r,K,x,fa[100001],ans,nw;\nstruct node{int to,next,c;}e[1000001];\nvector<int> v[100001];\nbool bo[200101];\n\nint ask(int x) {return fa[x]==x?x:fa[x]=ask(fa[x]);}\nbool cmp(int a,int b) {return v[a].size()<v[b].size();}\n\nvoid addedge(int x,int y,int c) \n{\n\te[++cnt]=(node){y,hd[x],c},hd[x]=cnt;\n\te[++cnt]=(node){x,hd[y],0},hd[y]=cnt;\n}\n\nbool bfs()\n{\n\tfor (int i=1; i<=n+n+1; i++) dis[i]=inf;\n\tq[l=r=1]=1,dis[1]=0,memset(bo,0,sizeof(bo)),bo[1]=1;\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\tif (e[i].c&&!bo[e[i].to]) bo[e[i].to]=1,q[++r]=e[i].to,dis[e[i].to]=dis[x]+1;\n\t\tl++;\n\t}\n\treturn dis[n+n+1]<inf;\n}\n\nbool dinic(int x)\n{\n\tif (x==n+n+1) return 1;\n\tfor (int &i=cur[x]; i; i=e[i].next)\n\t\tif (e[i].c&&dis[e[i].to]==dis[x]+1&&dinic(e[i].to)) \n\t\t\treturn e[i].c--,e[i^1].c++,1;\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),cnt=1;\n\tmemset(hd,0,sizeof(hd));\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&K),v[i].clear(),id[i]=i;\n\t\tfor (int j=1; j<=K; j++) scanf(\"%d\",&x),v[i].push_back(x);\n\t}\n\tsort(id+1,id+n,cmp);\n\tfor (int i=1; i<n; i++) addedge(1,i+1,1);\n\tfor (int i=1; i<=n; i++) addedge(i+n,n+n+1,1);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int siz=v[i].size(),j=0; j<siz; j++) \n\t\t\taddedge(i+1,v[i][j]+n,1);\n\tans=0;\n\twhile (bfs())\n\t{\n\t\tfor (int i=1; i<=n+n+1; i++) cur[i]=hd[i];\n\t\twhile (dinic(1)) ans++;\n\t}\n\tif (ans!=n-1) return puts(\"-1\"),0;\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=hd[i+1]; j; j=e[j].next)\n\t\t\tif (!e[j].c) {p[i]=e[j].to-n; break;}\n\tfor (int i=1; i<=n; i++) fa[i]=i;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tP[id[i]]=0;\n\t\tfor (int j=0,siz=v[id[i]].size(); j<siz; j++)\n\t\t\tif (ask(v[id[i]][j])!=ask(p[id[i]])) {P[id[i]]=v[id[i]][j]; break;}\n\t\tif (!P[id[i]]) return puts(\"-1\"),0;\n\t\tfa[ask(P[id[i]])]=ask(p[id[i]]);\n\t}\n\tfor (int i=1; i<n; i++) printf(\"%d %d\\n\",p[i],P[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n, s, t;\nint hd[400005], nx[1000006], to[1000006], c[1000006], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid fadd(int f, int t, int c) { add(f, t, c), add(t, f, 0); }\n\nint dep[400005];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= t; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i]) {\n            if (!c[i] || dep[v = to[i]]) continue;\n            dep[v] = dep[u] + 1, q.push(v);\n        }\n    }\n    return dep[t];\n}\n\nint iter[400005];\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v, d; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        if (d = dfs(v, min(dist, c[i]))) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= t; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\n\nvector<int> e[400005];\nint p[400005];\nstruct Res {\n    int u, v;\n} res[400005];\nbool get_res() {\n    for (int u = 1; u < n; ++u) {\n        for (int i = hd[u]; i; i = nx[i])\n            if (to[i] != s && c[i] == 0) p[u] = to[i] - n + 1;\n        cerr << \"#\" << u << ' ' << p[u] << endl;\n    }\n\n    int sum = 0;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        ++sum, q.pop();\n        for (int i = 0, v; i < e[u].size(); ++i)\n            if (p[v = e[u][i]]) res[v] = (Res){u, p[v]}, q.push(p[v]), p[v] = 0;\n    }\n    return sum == n;\n}\n\nint main() {\n    n = read(), s = 2 * n - 1, t = 2 * n, cnt = 1;\n    for (int i = 1; i < n; ++i) fadd(i + n - 1, t, 1);\n    for (int i = 1, c, u; i < n; ++i) {\n        c = read(), fadd(s, i, 1);\n        while (c--) {\n            if ((u = read()) != n) fadd(i, u + n - 1, 1);\n            e[u].push_back(i);\n        }\n    }\n    if (Dinic() < n - 1) return puts(\"-1\"), 0;\n    if (!get_res()) return puts(\"-1\"), 0;\n\n    for (int i = 1; i < n; ++i) printf(\"%d %d\\n\", res[i].u, res[i].v);\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]),g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),1;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=5e5+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nint p[N],fa[N];\nint get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}\npii ans[N];\nint la;\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n)fa[i]=i;\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(get(x)!=p[i]){\n                ans[++la]={x,p[i]},fa[p[i]]=x;\n                //printf(\"x=%d\\n\",x);\n                break;\n            }\n        }\n    }\n    if(la<n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tlong long int ans=0;\n\tint B_start=-1;\n\tint B_serch=-1;\n\tfor(int i=0;i<s.size()-1;i++){\n\t\tif(s[i]=='B'){\n\t\t\tB_start=i;\n\t\t\tB_serch=i;\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t}\n\tif(B_start==-1){\n\t\tcout << \"0\" <<endl;\n\t\treturn 0;\n\t}else{\n\t\tfor(int i=B_serch;i<s.size()-1;i++){\n\t\t\tif(s[i]=='W'){\n\t\t\t\tans+=(i-B_start);\n\t\t\t\tB_start++;\n\t\t\t\tB_serch=i;\n\t\t\t\ts[i]='B';\n\t\t\t\ts[B_start]='W';\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i]);\n    }\n    queue < int > q;\n    q.push(1);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 2; i <= n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 2; i <= n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);h=t=0;q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F> struct dinic {\n    static constexpr F inf = numeric_limits<F>::has_infinity ?\n        numeric_limits<F>::infinity() : numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return make_tuple(res, flow);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    int src = 0, snk = 2 * N;\n    dinic<int> g(2 * N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        g.arc(src, i, 1);\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        g.arc(N + i, snk, 1);\n\n        int sz, w;\n        cin >> sz;\n        for (int j = 0; j < sz; j++) {\n            cin >> w;\n            g.arc(w, N + i, 1);\n        }\n    }\n\n    auto max_flow = g.max_flow(src, snk);\n    int F = get<0>(max_flow);\n    vi flow = get<1>(max_flow);\n\n    if (F != N - 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int root;\n    for (int e : g.adj[src]) {\n        if (flow[e] == 0) {\n            root = g.dest[e];\n            break;\n        }\n    }\n\n    vi vis(g.V);\n    vis[src] = -1;\n    vis[snk] = -1;\n    vis[root] = root;\n\n    queue<int> bfs({ root });\n    while (!bfs.empty()) {\n        int loc = bfs.front();\n        bfs.pop();\n        for (int e : g.adj[loc]) {\n            if (!vis[g.dest[e]] && (loc > N && flow[e] == -1 || loc <= N && flow[e] == 0)) {\n                vis[g.dest[e]] = loc;\n                bfs.push(g.dest[e]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> res(N - 1);\n    for (int i = 1; i <= N; i++) {\n        if (i == root) continue;\n        if (!vis[i]) { cout << -1 << endl; return 0; }\n        res[vis[i] - N - 1] = { i, vis[vis[i]] };\n    }\n\n    for (auto e : res) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Q=1<<17;\nint link[Q],q[Q],hd=1,tl=0;\nint pt[Q],vis[Q];\nvector<int> g[Q];\nbool Find(int x,int tim)\n{\n\tif(vis[x]==tim)return 0;\n\tvis[x]=tim;\n\tfor(int t=0;t<g[x].size();t++){\n\t\tint y=g[x][t];\n\t\tif((!link[y])||Find(link[y],tim)){\n\t\t\tlink[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint tmp,x;\n\t\tscanf(\"%d\",&tmp);\n\t\twhile(tmp--)scanf(\"%d\",&x),g[x].push_back(i);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\tif(!Find(i,i))return puts(\"-1\")&0;\n\tq[++tl]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(hd>tl)return puts(\"-1\")&0;\n\t\tint x=q[hd++];\n\t\tfor(int t=0;t<g[x].size();t++){\n\t\t\tint st=g[x][t];\n\t\t\tif(pt[st])continue;\n\t\t\tpt[st]=x;\n\t\t\tq[++tl]=link[st];\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",min(pt[i],link[i]),max(pt[i],link[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_];\nvector<int>A[N_], B[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", A[i][0], A[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[N],maxflow;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tprintf(\"%d %d\\n\",x,ma[v2[x][i]]);\n\t\tvis[v2[x][i]]=1;\n\t\tdfs(ma[v2[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=2;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tif(x!=1)add(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=2;x<=n;x++)\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz)ma[w[i].to-n]=x;\n\tdfs(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[v-n]=u;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V> class MaxFlow_dinic {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 404040;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tvoid bfs(int cur) {\n\t\tMINUS(lev);\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()) {\n\t\t\tint v=q.front(); q.pop();\n\t\t\tITR(e,E[v]) if(e->cap>0 && lev[e->to]<0) lev[e->to]=lev[v]+1, q.push(e->to);\n\t\t}\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tif(from==to) return cf;\n\t\tfor(;itr[from]<E[from].size();itr[from]++) {\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0 && lev[from]<lev[e->to]) {\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0) {\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tZERO(itr);\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl+=tf;\n\t\t}\n\t}\n};\n\nint N;\nvector<int> E[202020];\nvector<int> F[202020];\nint repv[202020];\nMaxFlow_dinic<int> mf;\nint did[303030];\npair<int,int> R[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x;\n\t\tmf.add_edge(0,1+i,1);\n\t\twhile(x--) {\n\t\t\tcin>>y;\n\t\t\tE[i].push_back(y);\n\t\t\tF[y].push_back(i);\n\t\t\tmf.add_edge(1+i,y+101010,1);\n\t\t}\n\t}\n\tfor(i=2;i<=N;i++) mf.add_edge(i+101010,303030,1);\n\t\n\tif(F[1].empty() || mf.maxflow(0,303030)!=N-1) return _P(\"-1\\n\");\n\tfor(i=2;i<=N;i++) {\n\t\tFORR(e,mf.E[i+101010]) if(e.cap && e.to<101010) {\n\t\t\trepv[e.to-1]=i;\n\t\t}\n\t}\n\t\n\tqueue<int> Q;\n\tQ.push(1);\n\twhile(Q.size()) {\n\t\tx=Q.front();\n\t\tQ.pop();\n\t\tFORR(f,F[x]) if(did[f]==0) {\n\t\t\tdid[f]=x;\n\t\t\tR[f].first=x;\n\t\t\tR[f].second=repv[f];\n\t\t\tQ.push(repv[f]);\n\t\t}\n\t}\n\tFOR(i,N-1) cout<<R[i].first<<\" \"<<R[i].second<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=(1e9);\nconst int maxn=200010;\nint n,m[maxn],s,t,cur[maxn];\nint level[maxn],tot;\nint ans,flow[maxn*4];\nint head[maxn],nxt[maxn*4];\nint to[maxn*4];\nqueue<int> q;\nvector<int> g[maxn];\nvoid Add_edge(int a,int b,int c) {\n\ttot++; nxt[tot]=head[a];\n\thead[a]=tot; to[tot]=b; flow[tot]=c;\n}\nvoid add_edge(int a,int b,int c) {\n\tAdd_edge(a,b,c);\n\tAdd_edge(b,a,0);\n}\nbool bfs() {\n\tq=queue<int>();\n\tmemset(level,-1,sizeof(level));\n\tfor (int i=1;i<=t;i++) cur[i]=head[i];\n\tq.push(s);\n\tlevel[s]=0;\n\twhile (!q.empty()) {\n\t\tint a=q.front(),b; q.pop();\n\t\tfor (register int i=head[a];i;i=nxt[i]) {\n\t\t\tb=to[i];\n\t\t\tif (flow[i]>0&&level[b]==-1) {\n\t\t\t\tlevel[b]=level[a]+1;\n\t\t\t\tq.push(b);\n\t\t\t}\n\t\t}\n\t}\n\treturn level[t]!=-1;\n}\nint dfs(int x,int rest) {\n\tif (x==t) return rest;\n\tint used=0;\n\tfor (register int i=cur[x];i;i=nxt[i]) {\n\t\tcur[x]=i;\n\t\tint y=to[i];\n\t\tif (flow[i]>0&&level[y]==level[x]+1) {\n\t\t\tint tflow=dfs(y,min(flow[i],rest-used));\n\t\t\tused+=tflow;\n\t\t\tflow[i]-=tflow;\n\t\t\tflow[i^1]+=tflow;\n\t\t\tif (rest-used==0) break;\n\t\t}\n\t}\n\tif (!used) level[x]=-1;\n\treturn used;\n}\nbool vis[maxn];\npair<int,int> Ans[maxn];\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (!vis[m[v]]) Ans[v]=make_pair(u,m[v]),dfs(m[v]);\n\t}\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); tot=1;\n\ts=n*2+1,t=n*2+2;\n\tint x,y;\n\tfor (int i=1;i<n;i++) {\n\t\tadd_edge(s,i,1);\n\t\tread(x);\n\t\twhile (x--) {\n\t\t\tread(y);\n\t\t\tg[y].push_back(i);\n\t\t\tif (y>1) add_edge(i,y+n,1);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) add_edge(i+n,t,1);\n\twhile (bfs()) ans+=dfs(s,INF);\n\tif (ans!=n-1) { printf(\"-1\\n\"); return 0; }\n\tfor (int i=1;i<n;i++)\n\tfor (int j=head[i];j;j=nxt[j])\n\t\tif (!flow[j]&&to[j]!=s) {\n\t\t\tm[i]=to[j]-n; break;\n\t\t}\n\tdfs(1);\n\tfor (int i=1;i<n;i++) if (!Ans[i].first) { printf(\"-1\\n\"); return 0; }\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",Ans[i].first,Ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tint N;\n\tcin>>N;\n\tVV<int> A(N-1);\n\tVV<int> v2as(N);\n\trep(i,N-1){\n\t\tint K;\n\t\tcin>>K;\n\t\trep(j,K){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tx--;\n\t\t\tA[i].pb(x);\n\t\t\tv2as[x].pb(i);\n\t\t}\n\t}\n\tMaxFlow MF(N-1+N+2);\n\trep(i,N-1){\n\t\tfor(int v:A[i]) MF.add_edge(i,v+N-1,1);\n\t}\n\tint S = N-1+N;\n\tint T = S+1;\n\trep(i,N-1) MF.add_edge(S,i,1);\n\trep(i,N) MF.add_edge(i+N-1,T,1);\n\tint f = MF.max_flow(S,T);\n\tif(f != N-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tV<int> match(N-1);\n\trep(i,N-1){\n\t\tfor(auto e: MF.G[i]) if(N-1 <= e.to && e.to < N-1+N && e.cap == 0){\n\t\t\tmatch[i] = e.to - (N-1);\n\t\t}\n\t}\n\n\t\n\tVV<int> ans(N-1,V<int>(2,-1));\n\trep(i,N-1) ans[i][0] = match[i];\n\n\tint r = 0;\n\trep(i,N) r ^= i;\n\trep(i,N-1) r ^= match[i];\n\tqueue<int> que;\n\tque.push(r);\n\t\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i: v2as[v]) if(ans[i][0] != v && ans[i][1] == -1){\n\t\t\tans[i][1] = v;\n\t\t\tque.push(ans[i][0]);\n\t\t}\n\t}\n\trep(i,N-1) if(ans[i][1] == -1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,N-1) cout<<ans[i][0]+1<<\" \"<<ans[i][1]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint father[N],getsp[N];\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][15];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n//\tif(total2%2==1)\n//\tprintf(\"%d %d %d\\n\",x,y,z);\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n//\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (y>TT) continue;\n\t\t\tif (v[i]>0&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{ \n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y>TT) continue;\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tif (i==6&&y==11)\n\t\t\t{\n\t\t\t\tT++;T--;\n\t\t\t}\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic(int start)\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(start,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nvoid dfs2(int k,int fa)\n{\n\tfor (int i=head2[k+n];i;i=nexts2[i])\n\t{\n\t\tint y=edge2[i];\n\t\tif (father[y]==0)\n\t\t{\n\t\t\tfather[y]=k;\n\t\t\tdfs2(getsp[y],k);\n\t\t}\n\t}\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic(SS);\n\tif (maxflow==sum)\n\t{\n\t\ttotal1=1;\n\t\tSS=S=0;TT=T=2*n+1;\n\t\tmemset(head,0,sizeof(head));\n\t\tmemset(nexts,0,sizeof(nexts));\n\t\tmemset(edge,0,sizeof(edge));\n\t\tmemset(v,0,sizeof(v));\n\t\ttotal2=1;\n\t\tmemset(head2,0,sizeof(head2));\n\t\tmemset(edge2,0,sizeof(edge2));\n\t\tmemset(nexts2,0,sizeof(nexts2));\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tinsert(SS,i,1);\n\t\t\tinsert(i,SS,0);\n\t\t//\tprintf(\"%d %d %d\\n\",SS,i,1); \n\t\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t\t{\n\t\t\t\tinsert2(s[i][j]+n,i,0,0);\n\t\t\t\tif (s[i][j]==1) continue;\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,s[i][j]+n,1);\n\t\t\t\tinsert(i,s[i][j]+n,1);\n\t\t\t\tinsert(s[i][j]+n,i,0);\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tinsert(i+n,TT,1);\n\t\t\tinsert(TT,i+n,0);\n\t\t//\tprintf(\"%d %d %d\\n\",i+n,TT,1);\n\t\t}\n\t\tmaxflow=re_dinic(SS);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tfor (int j=head[i];j;j=nexts[j])\n\t\t\t{\n\t\t\t\tint y=edge[j];\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,y,v[j^1]);\n\t\t\t\tif (j%2==0&&v[j]==0)\n\t\t\t\t{\n\t\t\t\t\tgetsp[i]=y-n;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tmemset(father,0,sizeof(father));\n\t\t//stotal=0;\n\t\tdfs2(1,0);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",getsp[i],father[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=2*::Maxn,Maxm=4*::Maxn;\n\tint S,T,cnt,h[Maxn],cur[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T||!Maxflow)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int&p=cur[x];p;p=e[p].next){\n\t\t\tif(!Maxflow)break;\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,h,sizeof(h));\n\t\t\tans+=dfs(S,INT_MAX);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\n//struct Edge{int to,next,w;}edges[MAXM];\n//int cnt=1,head[MAXN],cur[MAXN],d[MAXN],S,T;\n//inline void add(int x,int y,int w){\n//\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n//\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n//}inline bool BFS(){\n//\tmemset(d,0,sizeof(d)),d[S]=1;queue<int>q;q.push(S);\n//\tfor(int x;!q.empty();){\n//\t\tx=q.front(),q.pop();\n//\t\tfor(int i=head[x],y;i;i=edges[i].next)\n//\t\t\tif(!d[y=edges[i].to]&&edges[i].w)d[y]=d[x]+1,q.push(y);\n//\t}return d[T];\n//}int DFS(int x,int dist){\n//\tif(x==T||!dist)return dist;int z=0;\n//\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(d[y=edges[i].to]==d[x]+1&&edges[i].w){\n//\t\tk=DFS(y,min(dist,edges[i].w)),edges[i].w-=k,edges[i^1].w+=k,z+=k,dist-=k;\n//\t\tif(!dist)break;\n//\t}return z;\n//}inline int Dinic(){int ans=0;while(BFS())memcpy(cur,head,sizeof(head)),ans+=DFS(S,1e9);return ans;}\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head)),d[S]=1;\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200100;\nstruct T {\n\tint to, nxt, v;\n} way[maxn << 4];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n\tway[++num] = {y, h[x], v}, h[x] = num;\n\tway[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n\tstd::queue<int> q;\n\tfor(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n\tfor(q.push(s), dis[s] = 0;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n\t\t\tdis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n\t}\n\treturn dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n\tif(s == t || !lim) return lim;\n\tint ans = 0, mn;\n\tfor(int & i = head[s];i;i = way[i].nxt)\n\t\tif(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n\t\t\tway[i].v -= mn;\n\t\t\tway[i ^ 1].v += mn;\n\t\t\tans += mn; lim -= mn;\n\t\t\tif(!lim) break;\n\t\t}\n\treturn ans;\n}\ninline int dinic(int s,int t) {\n\tint ans = 0;\n\tfor(;bfs(s,t);) ans += dfs(s,t,1e9);\n\treturn ans;\n}\nint n;\nstd::vector<int> v[maxn];\nstd::vector<int> to[maxn];\nint id[maxn], fa[maxn];\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1,x,a;i < n;++i) {\n\t\tstd::cin >> x, adde(0, i, 1);\n\t\tfor(;x--;) {\n\t\t\tstd::cin >> a, v[i].push_back(a);\n\t\t\tif(a != n) adde(i, a + n, 1);\n\t\t}\n\t}\n\tfor(int i = 1;i < n;++i) adde(i + n,n + n + 1,1);\n\tif(dinic(0,n + n + 1) != n - 1) {\n\t\tstd::cout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i <= n;++i) for(int j = h[i + n];j;j=way[j].nxt) if(way[j].v == 1 && way[j].to < n)\n\t\tid[way[j].to] = i;\n\tfor(int i = 1;i < n;++i) for(int j : v[i])\n\t\tto[j].push_back(id[i]);\n\tstd::queue<int> q; \n\tfor(q.push(n), fa[n] = 1;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i : to[t]) if(!fa[i])\n\t\t\tq.push(i), fa[i] = t;\n\t}\n\tif(std::count(fa + 1,fa + n + 1,0)) {\n\t\tstd::cout << - 1 << '\\n';\n\t} else {\n\t\tfor(int i = 1;i < n;++i) std::cout << fa[i] << ' ' << i << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nint n,S,T,d[200010],ans,a[100010],b[100010];\nvector<int> v[100010];\nint cnt=1,head[200010],to[800010],nxt[800010],w[800010];\nbool used[100010];\nvoid add(int x,int y,int z)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n\tw[cnt]=z;\n}\nvoid ins(int x,int y,int z)\n{\n\tadd(x,y,z);\n\tadd(y,x,0);\n}\nbool bfs()\n{\n\tfor (int i=S;i<=T;i++)\n\t{\n\t\td[i]=-1;\n\t}\n\tqueue<int> q;\n\td[S]=0;\n\tq.push(S);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tif (x==T)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif (w[i] && d[y]==-1)\n\t\t\t{\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x,int f)\n{\n\tint res=0;\n\tif (x==T)\n\t{\n\t\treturn f;\n\t}\n\tfor (int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif (w[i] && d[y]==d[x]+1)\n\t\t{\n\t\t\tint tmp=dfs(y,min(f-res,w[i]));\n\t\t\tw[i]-=tmp;\n\t\t\tw[i^1]+=tmp;\n\t\t\tres+=tmp;\n\t\t\tif (res==f)\n\t\t\t{\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\tif (!res)\n\t{\n\t\td[x]=-1;\n\t}\n\treturn res;\n}\nvoid dinic()\n{\n\twhile (bfs())\n\t{\n\t\tans+=dfs(S,inf);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tS=1;\n\tT=2*n;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tif (x!=1)\n\t\t\t{\n\t\t\t\tins(x,n+i,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tins(S,i,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tins(n+i,T,1);\n\t}\n\tdinic();\n\tif (ans!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=n+1;i<2*n;i++)\n\t{\n\t\tfor (int j=head[i];j;j=nxt[j])\n\t\t{\n\t\t\tif (!w[j])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i-n]=to[j];\n\t\t}\n\t}\n\tqueue<int> q;\n\tused[1]=true;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=0;i<v[x].size();i++)\n\t\t{\n\t\t\tint y=v[x][i];\n\t\t\tif (!used[a[y]])\n\t\t\t{\n\t\t\t\tused[a[y]]=true;\n\t\t\t\tq.push(a[y]);\n\t\t\t\tb[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tbool f=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tf&=used[i];\n\t}\n\tif (!f)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",a[i],b[i]);\n\t}\n\treturn 0;\n}\n//霓为衣兮风为马，云之君兮纷纷而来下。\n//——李白《梦游天姥吟留别》"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nvector<pair<int,int> > Ans;\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tAns.push_back(make_pair(u,ma[s]));\n\t\t}\n\t}\n\tif((int)Ans.size()!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=0;i<n-1;i++)\n\t\tprintf(\"%d %d\\n\",Ans[i].first,Ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nnamespace DinicFlows {\n\ttypedef long long LL;\n\tconst LL Inf = 0x3f3f3f3f3f3f3f3f;\n\tconst int MN = 200005, MM = 400005;\n\t\n\tint N, S, T;\n\tint h[MN], iter[MN], nxt[MM * 2], to[MM * 2], tot; LL w[MM * 2];\n\t\n\tinline void SetST(int, int);\n\tinline void Init(int _N) {\n\t\tN = _N, tot = 1;\n\t\tfor (int i = 1; i <= N; ++i) h[i] = 0;\n\t\tSetST(_N - 1, _N);\n\t}\n\tinline void SetST(int _S, int _T) { S = _S, T = _T; }\n\t\n\tinline void ins(int u, int v, LL x) { nxt[++tot] = h[u], to[tot] = v, w[tot] = x, h[u] = tot; }\n\tinline void insw(int u, int v, LL w1 = Inf, LL w2 = 0) {\n\t\tif (!u) u = S; if (!v) v = T;\n\t\tins(u, v, w1), ins(v, u, w2);\n\t}\n\t\n\tint lv[MN], que[MN], l, r;\n\t\n\tinline bool Lvl() {\n\t\tfor (int i = 1; i <= N; ++i) lv[i] = 0;\n\t\tlv[S] = 1;\n\t\tque[l = r = 1] = S;\n\t\twhile (l <= r) {\n\t\t\tint u = que[l++];\n\t\t\tfor (int i = h[u]; i; i = nxt[i])\n\t\t\t\tif (w[i] && !lv[to[i]]) {\n\t\t\t\t\tlv[to[i]] = lv[u] + 1;\n\t\t\t\t\tque[++r] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn lv[T] != 0;\n\t}\n\t\n\tLL Flow(int u, LL f) {\n\t\tif (u == T) return f;\n\t\tLL d = 0, s = 0;\n\t\tfor (int &i = iter[u]; i; i = nxt[i])\n\t\t\tif (w[i] && lv[to[i]] == lv[u] + 1) {\n\t\t\t\td = Flow(to[i], std::min(f, w[i]));\n\t\t\t\tf -= d, s += d;\n\t\t\t\tw[i] -= d, w[i ^ 1] += d;\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\treturn s;\n\t}\n\t\n\tinline LL Dinic() {\n\t\tLL Ans = 0;\n\t\twhile (Lvl()) {\n\t\t\tfor (int i = 1; i <= N; ++i) iter[i] = h[i];\n\t\t\tAns += Flow(S, Inf);\n\t\t}\n\t\treturn Ans;\n\t}\n}\nusing DinicFlows::h;\nusing DinicFlows::to;\nusing DinicFlows::nxt;\nusing DinicFlows::w;\nusing DinicFlows::insw;\n\nconst int MN = 100005;\n\nint N, mch[MN], vis[MN];\nint eu[MN], ev[MN], M;\n\nvoid DFS(int u) {\n\tfor (int j = h[u]; j; j = nxt[j]) {\n\t\tif (to[j] == N + N || vis[to[j] - N]) continue;\n\t\tvis[to[j] - N] = 1;\n\t\tfor (int k = h[to[j]]; k; k = nxt[k]) if(w[k])\n\t\t\teu[++M] = u, ev[M] = to[k], DFS(to[k]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tDinicFlows::Init(N + N + 1);\n\tfor (int i = 1; i <= N; ++i) insw(0, i, 1);\n\tfor (int i = 1, c, x; i < N; ++i) {\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) scanf(\"%d\", &x), insw(x, N + i, 1);\n\t\tinsw(N + i, 0, 1);\n\t}\n\tif (DinicFlows::Dinic() != N - 1) return puts(\"-1\"), 0;\n\tint Root = 0;\n\tfor (int i = h[N + N]; i; i = nxt[i]) if (w[i]) Root = to[i];\n\tDFS(Root);\n\tif (M != N - 1) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < N; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) {\n\t\t\t\twrite(i), putchar(' ');\n\t\t\t\twrite(par[par[i]]), putchar('\\n');\n\t\t\t} \n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 1000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nvector<int> vis, deg, match, lmatch;\nvector<array<int, 2>> res;\nvector<int> adj[1<<17];\ndsu tmp(0);\nvoid process(int v) {\n\tvis[v] = 1;\n\tfor(auto u : adj[v]) if(match[u] != -1 && !vis[match[u]]) {\n\t\ttmp.unite(match[u], v);\n\t\tres[u] = {match[u], v};\n\t\tprocess(match[u]);\n\t}\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\ttmp = (n);\n\tdeg = vector<int>(n);\n\tmatch.resize(n, -1);\n\tlmatch.resize(n, -1);\n\tvis.resize(n);\n\tint kk = 0;\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j, assert(j-1 < n), deg[j-1]++, adj[j-1].push_back(kk);\n\t\tkk++;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching();\n\tres.resize(n-1);\n\tset<int> q;\n\tfor(int i = 0; i < n; i++) q.insert(i);\n\tfor(auto [i, x] : matching) {\n\t\tmatch[i-1] = x-n;\n\t\tlmatch[x-n] = i-1;\n\t\tq.erase(match[i-1]);\n\t}\n\tprocess(*q.begin());\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a+1 << \" \" << b+1 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 202000, M = 1020000, inf = 0x3f3f3f3f;\nint n,m,S,T,head[N],to[M],nxt[M],cap[M],edgenum=1;\nVi a[N],b[N];\nvoid addedge(int u, int v, int c){\n\tto[++edgenum]=v;cap[edgenum]=c;\n\tnxt[edgenum]=head[u];head[u]=edgenum;\n}\ninline void add(int u, int v, int c){addedge(u,v,c);addedge(v,u,0);}\nint q[N],dis[N],cur[N],match[N],ans[N];\ninline bool bfs(){\n\tmemset(dis,inf,4*(T+2));dis[T]=0;\n\tint f=0,r=1;q[f]=T;\n\twhile(f!=r){\n\t\tint u=q[f++];\n\t\tL(i,u)if(cap[i^1]&&dis[to[i]]==inf){\n\t\t\tdis[to[i]]=dis[u]+1;q[r++]=to[i];if(to[i]==S)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(int u, int flow){\n\tif(u==T||!flow)return flow;\n\tint res=0;\n\tfor(register int &i=cur[u];i;i=nxt[i])if(cap[i]&&dis[u]==dis[to[i]]+1){\n\t\tint tmp=dfs(to[i],min(flow,cap[i]));\n\t\tres+=tmp;flow-=tmp;cap[i]-=tmp;cap[i^1]+=tmp;if(!flow)break;\n\t}\n\treturn res;\n}\ninline int dinic(){\n\tint res=0;\n\twhile(bfs()){\n\t\tmemcpy(cur,head,4*(T+2));res+=dfs(S,inf);\n\t}\n\treturn res;\n}\nvoid GG(){puts(\"-1\");exit(0);}\nbool vis[N];\nvoid solve(){\n\tvis[1]=1;int f=0,r=1;q[f]=1;\n\twhile(f!=r){\n\t\tint u=q[f++];\n\t\trep(t,0,SZ(b[u])-1)if(!vis[match[b[u][t]]]){\n\t\t\tans[b[u][t]]=u;vis[match[b[u][t]]]=1;q[r++]=match[b[u][t]];\n\t\t}\n\t}\n}\nint main() {\n\tread(n);S=2*n+1;T=S+1;\n\trep(i,1,n-1){\n\t\tadd(S,n+i,1);\n\t\tint l;read(l);rep(j,1,l){\n\t\t\tint x;read(x);a[i].pb(x);if(x>1)add(n+i,x,1);\n\t\t\tb[x].pb(i);\n\t\t}\n\t}\n\trep(i,2,n)add(i,T,1);if(dinic()!=n-1)GG();\n\trep(u,1,n-1)L(i,n+u)if(!cap[i]&&to[i]>=2&&to[i]<=n)match[u]=to[i];\n\tsolve();\n\trep(i,1,n)if(!vis[i])GG();\n\trep(i,1,n-1)printf(\"%d %d\\n\",match[i],ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num,ans[N];\nconst int inf=0x3f3f3f3f;\nvector<int>v[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1,ans[v[x][i]]=x;\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&n+1<=w[i].to&&w[i].to<=n+n-1)\n\t\t\t\tma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",ans[i],ma[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, hed[N + N], to[N + N], nxt[N + N], val[N + N];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = hed[u]; i; i = nxt[i])\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = hed[u]; i; i = nxt[i])\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\treturn 0;\n}\nint Dinic() {\n\tint flow = 0;\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n;\n\trep(i, 1, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != 1) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tif(Dinic() != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(1);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; bl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) {\n\t\t\tif(!vis[bl[v]]) {\n\t\t\t\tvis[bl[v]] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t\t}\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 400050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn];\nint cur[maxn];\n\nqueue<int> q;\n\nbool bfs()\n{\n    memset(d,0x3f,sizeof(d));\n    d[vs]=1;\n    q.push(vs);\n    while (!q.empty())\n    {\n        int i=q.front();    q.pop();\n        for (int k=head[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (!cost[k]||d[j]<=d[i]+1)   continue;\n            d[j]=d[i]+1;\n            q.push(j);\n        }\n    }\n    return d[vt]<=vt;\n}\n\nint dfs(int i,int f)\n{\n    // cout<<\"dfs:\"<<i<<\"(\"<<d[i]<<\")\"<<f<<endl;\n    if (i==vt)  return f;\n    int tf=0;\n    for (int &k=cur[i];~k;k=nxt[k])\n    {\n        int j=edge[k];\n        if (!cost[k]||d[j]!=d[i]+1) continue;\n        int t=dfs(j,1);\n        cost[k]-=t,cost[k^1]+=t;\n        f-=t,tf+=t;\n        if (!f) break;\n    }\n    return tf;\n}\n\nint isap()\n{\n    int ans=0;\n    while (bfs())\n    {\n        for (int i=1;i<=vt;++i)\n            cur[i]=head[i];\n        ans+=dfs(vs,maxn);\n    }\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nbool init(){\n\tqueue<int> Q;\n\tmemset(d,0,sizeof d);\n\td[s]=1;Q.push(s);\n\twhile(!Q.empty()){\n\t\tint x=Q.front();Q.pop();\n\t\tcur[x]=fr[x];\n\t\tfor(int i=fr[x];i;i=nex[i])if(wi[i]&&!d[vi[i]]){\n\t\t\td[vi[i]]=d[x]+1;Q.push(vi[i]);\n\t\t}\n\t}\n\treturn d[t]!=0;\n}\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]+1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}return fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;;\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(init())res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201000;\n\nint chosen[N];\n\nnamespace MF {\n  struct Edge {\n    int v, flow, ne;\n  }e[N << 3];\n\n  int fi[N], tot, S, T, V, cur[N], dis[N], q[N];\n\n  void Init(int s, int t, int v) {\n    S = s; T = t; V = v;\n    tot = 1;\n    for(int i = 0; i < V; i++) {\n      fi[i] = 0;\n    }\n  }\n\n  void Add(int x, int y, int w) {\n    e[++tot] = {y, w, fi[x]};\n    fi[x] = tot;\n    e[++tot] = {x, 0, fi[y]};\n    fi[y] = tot;\n  }\n  \n  bool Bfs(void) {\n    for(int i = 0; i < V; i++) {\n      dis[i] = 0;\n    }\n    int h = 1, t = 0;\n    q[++t] = S;\n    dis[S] = 1;\n    while(h <= t) {\n      int x = q[h++];\n      for(int i = fi[x]; i; i = e[i].ne) {\n\tif(e[i].flow && !dis[e[i].v]) {\n\t  dis[e[i].v] = dis[x] + 1;\n\t  q[++t] = e[i].v;\n\t}\n      }\n    }\n    return dis[T];\n  }\n\n  int Dfs(int x, int f) {\n    if(x == T) {\n      return f;\n    }\n    int used = 0;\n    for(int &i = cur[x]; i; i = e[i].ne) {\n      if(e[i].flow && dis[e[i].v] == dis[x] + 1) {\n\tint t = Dfs(e[i].v, min(f - used, e[i].flow));\n\tused += t;\n\te[i].flow -= t;\n\te[i ^ 1].flow += t;\n\tif(used == f) {\n\t  return used;\n\t}\n      }\n    }\n    dis[x] = -1;\n    return used;\n  }\n\n  int Solve(void) {\n    int ans = 0;\n    while(Bfs()) {\n      for(int i = 0; i < V; i++) {\n\tcur[i] = fi[i];\n      }\n      ans += Dfs(S, 1e9);\n    }\n    for(int i = 1; i < (V >> 1); i++) {\n      for(int j = fi[i]; j; j = e[j].ne) {\n\tif(!e[j].flow) {\n\t  ::chosen[i] = e[j].v - (V >> 1) + 1;\n\t}\n      }\n    }\n    return ans;\n  }\n}\n\nint n, q[N], full[N];\npair<int, int> ans[N];\nvector<int> in[N];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  MF::Init(0, n << 1 ^ 3, n << 1);\n  for(int i = 1, k; i < n; i++) {\n    scanf(\"%d\", &k);\n    for(int j = 0, x; j < k; j++) {\n      scanf(\"%d\", &x);\n      x--;\n      if(x) {\n\tMF::Add(i, x + n - 1, 1);\n      }\n      in[x].push_back(i);\n    }\n  }\n  for(int i = 1; i < n; i++) {\n    MF::Add(MF::S, i, 1);\n    MF::Add(i + n - 1, MF::T, 1);\n  }\n  if(MF::Solve() < n - 1) {\n    return puts(\"-1\"), 0;\n  }\n  int h = 1, t = 0;\n  q[++t] = 0;\n  while(h <= t) {\n    int x = q[h++];\n    for(int y : in[x]) {\n      if(full[y]) {\n\tcontinue;\n      }\n      full[y] = 1;\n      q[++t] = chosen[y];\n      ans[y] = {x, chosen[y]};\n    }\n  }\n  if(t < n) {\n    puts(\"-1\");\n  } else {\n    for(int i = 1; i < n; i++) {\n      printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db long double\n#define pii pair<ll,int>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline ll rd()\n{\n\tll x=0;char c=gc();while(!isdigit(c))c=gc();\n\twhile(isdigit(c))x=x*10+c-48,c=gc();return x;\n}\nconst int N=200005,inf=1e9+7;\nint n,S,T,tt,cc,nn,hd[N],q[N],d[N],iter[N],a[N],vis[N];pii ans[N];\nstruct E{int v,nxt,w;}e[N*8];\ninline void add(int u,int v,int w){e[++cc]=(E){v,hd[u],w};hd[u]=cc;e[++cc]=(E){u,hd[v],0};hd[v]=cc;}\ninline bool bfs(int S)\n{\n\trep(i,1,tt)d[i]=inf,iter[i]=hd[i];\n\tint ql=0,qr=0;q[++qr]=S;d[S]=0;\n\twhile(ql<qr)\n\t{\n\t\tint x=q[++ql];\n\t\tfor(int i=hd[x],y;i;i=e[i].nxt)if(e[i].w&&d[y=e[i].v]==inf){d[y]=d[x]+1;q[++qr]=y;}\n\t} \n\treturn d[T]<inf;\n}\nint dfs(int x,int f)\n{\n\tif(x==T||!f)return f;int sf=0;\n\tfor(int&i=iter[x];i;i=e[i].nxt)if(e[i].w&&d[e[i].v]==d[x]+1)\n\t{\n\t\tint w=dfs(e[i].v,min(f,e[i].w));\n\t\tif(w)\n\t\t{\n\t\t\te[i].w-=w;e[i^1].w+=w;\n\t\t\tf-=w;sf+=w;if(!f)break;\n\t\t}\n\t} \n\treturn sf;\n}\nvoid dfs(int x)\n{\n\tfor(int i=hd[x];i;i=e[i].nxt)if(e[i].v!=S&&!vis[e[i].v-n])\n\t{\n\t\tnn++;int t=e[i].v-n;vis[t]=1;\n\t\tans[t]=mp(x,a[t]);dfs(a[t]);\n\t} \n}\nint main()\n{\n\tn=rd();S=n+n;T=n+n+1;tt=T;cc=1;\n\trep(i,1,n-1)\n\t{\n\t\tint m=rd();\n\t\trep(j,1,m)add(rd(),n+i,1);\n\t\tadd(S,i+1,1);add(n+i,T,1);\n\t}\n\tint f=0;\n\twhile(bfs(S))f+=dfs(S,inf);\n\tif(f!=n-1){puts(\"-1\");return 0;}\n\tfor(int i=n+1;i<n+n;i++)for(int j=hd[i];j;j=e[j].nxt)if(e[j].w&&e[j].v<=n)a[i-n]=e[j].v;\n\tdfs(1);\n\tif(nn<n-1){puts(\"-1\");return 0;}\n\trep(i,1,n-1)printf(\"%d %d\\n\",ans[i].X,ans[i].Y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\t//dmp(s);\n\t\tfor(auto t:adj[s]){\n\t\t\tif(t.fs<=0)return;\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\ta[t.sc]=t.fs;\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\nfor(int i=1;i<=n-1;i++){\n\tmatch[btoa[i]]=i;\n}\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\t//match[btoa[i]]=i;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({match[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\n//dmp(sum);\n//assert(sum>=n);\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << a[i] << \" \" << b[i] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct vertex {\n\tint estart;\n\tint ecur;\n\tint dist;\n} v[300003];\nstruct edge {\n\tint enext,to;\n\tint cap;\n} e[1000003];int en;\nvoid addedge(int a,int b,int cap)\n{\n\te[en].enext = v[a].estart;e[en].to = b;e[en].cap = cap;v[a].estart = en++;\n\te[en].enext = v[b].estart;e[en].to = a;e[en].cap = 0;v[b].estart = en++;\n}\nint start, end;\nint dfs(int i,int cap)\n{\n\tif(i == end) return cap;\n\tint flow = 0;\n\tfor(int &j = v[i].ecur;j != -1;j = e[j].enext) {\n\t\tint to = e[j].to;\n\t\tif(e[j].cap == 0 || v[to].dist != v[i].dist + 1) continue;\n\t\tint val = dfs(to,std::min(cap,e[j].cap));\n\t\tflow += val;cap -= val;e[j].cap -= val;e[j^1].cap += val;\n\t\tif(cap == 0) break;\n\t}\n\treturn flow;\n}\nint n,m;\nstruct vertex2 {\n\tstd::vector<int> inset;\n\tbool vis;\n} v2[100003];\nstd::vector<std::pair<int,int> > ans;\nint match[100003];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < 2*n+1;++i) {\n\t\tv[i].estart = -1;\n\t}\n\tstart = 2*n-1, end = 2*n;\n\t// root = 0\n\tfor(int i = 1;i < n;++i) {\n\t\taddedge(start,i,1);\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j = 0;j < c;++j) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);--k;\n\t\t\tv2[k].inset.push_back(i);\n\t\t\tif(k != 0) addedge(k,n+i,1);\n\t\t}\n\t\taddedge(n+i,end,1);\n\t}\n\tint flow = 0;\n\tfor(;;) {\n\t\tfor(int i = 0;i < 2*n+1;++i) {\n\t\t\tv[i].dist = -1;\n\t\t\tv[i].ecur = v[i].estart;\n\t\t}\n\t\tv[start].dist = 0;\n\t\tstd::queue<int> q;\n\t\tq.push(start);\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = v[cur].estart;j != -1;j = e[j].enext) {\n\t\t\t\tif(e[j].cap == 0) continue;\n\t\t\t\tint to = e[j].to;\n\t\t\t\tif(v[to].dist == -1) {\n\t\t\t\t\tv[to].dist = v[cur].dist + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v[end].dist == -1) break;\n\t\tflow += dfs(start,999999);\n\t}\n\tif(flow != n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint x = n+i;\n\t\tmatch[i] = -1;\n\t\tfor(int j = v[x].estart;j != -1;j = e[j].enext) {\n\t\t\tif(e[j].to >= 1 && e[j].to < n && e[j].cap == 1) {\n\t\t\t\tmatch[i] = e[j].to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(match[i] != -1);\n\t}\n\t\n\t{\n\t\tstd::queue<int> q;\n\t\tq.push(0);v2[0].vis = true;\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = 0;j < v2[cur].inset.size();++j) {\n\t\t\t\tint to = v2[cur].inset[j];\n\t\t\t\tif(!v2[match[to]].vis) {\n\t\t\t\t\tans.emplace_back(cur,match[to]);\n\t\t\t\t\tv2[match[to]].vis = true;\n\t\t\t\t\tq.push(match[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.size() == n-1) {\n\t\t\tfor(int i = 0;i < n-1;++i) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t\t} else {\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false) returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  ll build(int s, int t) {\n    vector< int > level(n);\n    ll flow = 0;\n    while(bfs(s, level), level[t] >= 0) {\n      ll newflow;\n      while((newflow = dfs(s, t, inf, level)) > 0) {\n        flow += newflow;\n        if(flow >= inf) return inf;\n      }\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] < 0 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e18;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := xを要素に持つグループら\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// メモ：\n// k個のグループにk頂点しか無い場合は自明にループができるので不可\n// よって (k+1) 頂点以上に繋がってていなきゃいけない\n// そのとき k 頂点に必ず繋がっていることになる\n// これは結婚定理と同じ条件なので，必ずn-1本のマッチングが存在することになる\n\n// すると E_i has i を必ず達成できるように番号付けできる\n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} が成り立ってはいけない，と言い換えられる\n// どのような頂点からはじめても，頂点Nにたどり着けなければならない\n// 頂点Nから逆にたどってやって，全てにたどり着けるかだけ調べればいい\n\n// その仮定で，そのDFS木をそのまま構成する木にできる\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace max_flow {\n\nconst int max_v = 200222, inf = 1000111222;\n\nstruct edge {\n    int to, residual_capacity;\n\n    edge(int to, int residual_capacity): to(to), residual_capacity(residual_capacity) {\n    }\n};\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid add_edge(int u, int v, int capacity) {\n    g[u].push_back(edges.size());\n    edges.push_back({v, capacity});\n    g[v].push_back(edges.size());\n    edges.push_back({u, 0});\n}\n\nint h[max_v];\n\nbool bfs(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        h[i] = -1;\n    }\n    h[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int id : g[v]) {\n            if (edges[id].residual_capacity && h[edges[id].to] == -1) {\n                h[edges[id].to] = h[v] + 1;\n                q.push(edges[id].to);\n            }\n        }\n    }\n    return h[t] != -1;\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) {\n        return f;\n    }\n    for (int id : g[v]) {\n        if (edges[id].residual_capacity  && h[v] + 1 == h[edges[id].to]) {\n            int res = dfs(edges[id].to, t, min(f, edges[id].residual_capacity));\n            if (res) {\n                edges[id].residual_capacity -= res;\n                edges[id ^ 1].residual_capacity += res;\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(int s, int t) {\n    int res = 0;\n    while (bfs(s, t)) {\n        while (int f = dfs(s, t, inf)) {\n            res += f;\n        }\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], ans[max_n], used[max_n];\nvector<int> g[max_n], g2[max_n];\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    int s = 2 * n - 1, t = 2 * n;\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        max_flow::add_edge(s, i, 1);\n        for (int to : g[i]) {\n            max_flow::add_edge(i, n - 1 + to, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        max_flow::add_edge(n - 1 + i, t, 1);\n    }\n    int f = max_flow::dinic(s, t);\n    memset(p, -1, sizeof(p));\n    memset(nxt, -1, sizeof(nxt));\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int id : max_flow::g[i]) {\n            const auto &e = max_flow::edges[id];\n            if (e.to != s && e.residual_capacity == 0) {\n                nxt[i] = e.to - n + 1;\n                p[nxt[i]] = i;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv, is_forb;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e[a].PB(Edge{b, cap, SZ(e[b]), 0});\n    e[b].PB(Edge{a, bi_dir * cap, SZ(e[a]) - 1, 0});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    //e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n\n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n    for (int i = 0; i <= n; i++) {\n      dis[i] = n + 1;\n    }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        if (edge.is_forb) { continue; }\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      if (e[v][i].is_forb) { continue; }\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<int> halko;\n    for (int ii = 0; ii < SZ(gr.e[i]); ii++) {\n      auto edge = gr.e[i][ii];\n    //for (auto& edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        debug(i, edge.v);\n        int poszlo = Dinic::kInf - edge.c;\n        gr.e[i][ii].c = 0;\n        gr.e[edge.v][edge.inv].c = 0;\n        assert(gr.e[source][i - 1].v == i);\n        gr.e[source][i - 1].c += poszlo;\n        assert(gr.e[i][0].v == source);\n        gr.e[i][0].c -= poszlo;\n        assert(gr.e[edge.v][0].v == sink);\n        gr.e[edge.v][0].c += poszlo;\n        assert(gr.e[sink][edge.v - n - 1].v == edge.v);\n        gr.e[sink][edge.v - n - 1].c -= poszlo;\n        int new_flow = gr.MaxFlow(source, sink);\n        if (new_flow == poszlo) {\n          debug(\"wywal\");\n        } else {\n          halko.PB(edge.v - n);\n          gr.e[i][ii].c = Dinic::kInf;\n          gr.e[edge.v][edge.inv].c = 0;\n          int newer_flow = gr.MaxFlow(source, sink);\n          //debug(new_flow, new_flow, poszlo);\n          assert(new_flow + newer_flow == poszlo);\n        }\n        //halko.PB({edge.v - n, );\n      } else {\n        gr.e[i][ii].c = 0;\n      } \n    }\n//     vector<int> filter;\n//     for (auto v : halko) {\n//       \n//       \n//     }\n    debug(halko);\n    assert(SZ(halko) == 2);\n    for (auto x : halko) {\n      cout<<x<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n, s, t;\nint hd[400005], nx[1000006], to[1000006], c[1000006], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid fadd(int f, int t, int c) { add(f, t, c), add(t, f, 0); }\n\nint dep[400005];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= t; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i]) {\n            if (!c[i] || dep[v = to[i]]) continue;\n            dep[v] = dep[u] + 1, q.push(v);\n        }\n    }\n    return dep[t];\n}\n\nint iter[400005];\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v, d; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        if (d = dfs(v, min(dist, c[i]))) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= t; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\n\nvector<int> e[400005];\nint p[400005];\nstruct Res {\n    int u, v;\n} res[400005];\nbool get_res() {\n    for (int u = 1; u < n; ++u)\n        for (int i = hd[u]; i; i = nx[i])\n            if (to[i] != s && c[i] == 0) p[u] = to[i] - n + 1;\n\n    int sum = 0;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        ++sum, q.pop();\n        for (int i = 0, v; i < e[u].size(); ++i)\n            if (p[v = e[u][i]]) res[v] = (Res){u, p[v]}, q.push(p[v]), p[v] = 0;\n    }\n    return sum == n;\n}\n\nint main() {\n    n = read(), s = 2 * n - 1, t = 2 * n, cnt = 1;\n    for (int i = 1; i < n; ++i) fadd(i + n - 1, t, 1);\n    for (int i = 1, c, u; i < n; ++i) {\n        c = read(), fadd(s, i, 1);\n        while (c--) {\n            if ((u = read()) != n) fadd(i, u + n - 1, 1);\n            e[u].push_back(i);\n        }\n    }\n    if (Dinic() < n - 1) return puts(\"-1\"), 0;\n    if (!get_res()) return puts(\"-1\"), 0;\n\n    for (int i = 1; i < n; ++i) printf(\"%d %d\\n\", res[i].u, res[i].v);\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G2;\nint n, Deg[N_], UF[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nvector<int>TP[N_];\nint Num[N_], Q[N_], head, tail, vis[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG2.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\n\t\tG2.Add_Edge(G2.source, i, 1);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tTP[a].push_back(i);\n\t\t\tif (a != 1) {\n\t\t\t\tG2.Add_Edge(i, n - 1 + a, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif(i!=1)G2.Add_Edge(n - 1 + i, G2.sink, 1);\n\t}\n\tG2.Dinic();\n\tif (G2.flow != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 2; i <= n; i++) {\n\t\tfor (auto &x : G2.G[n - 1 + i]) {\n\t\t\tEdge tp = G2.E[x];\n\t\t\tif (tp.f) {\n\t\t\t\tNum[tp.e] = i;\n\t\t\t}\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : TP[x]) {\n\t\t\tif (!vis[t]) {\n\t\t\t\tRes[t][0] = x;\n\t\t\t\tRes[t][1] = Num[t];\n\t\t\t\tQ[++tail] = Num[t];\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (tail!=n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 210000;\nconst int INF = 1000000000;\n \nstruct edge {\n    int a, b, cap, flow;\n};\n \nint nv, s, t, d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n \nvoid addEdge (int a, int b, int cap) {\n    edge e1 = { a, b, cap, 0 };\n    edge e2 = { b, a, 0, 0 };\n    g[a].push_back ((int) e.size());\n    e.push_back (e1);\n    g[b].push_back ((int) e.size());\n    e.push_back (e2);\n}\n \nbool bfs() {\n    int qh=0, qt=0;\n    q[qt++] = s;\n    memset (d, -1, nv * sizeof d[0]);\n    d[s] = 0;\n    while (qh < qt && d[t] == -1) {\n        int v = q[qh++];\n        for (size_t i=0; i<g[v].size(); ++i) {\n            int id = g[v][i],\n                to = e[id].b;\n            if (d[to] == -1 && e[id].flow < e[id].cap) {\n                q[qt++] = to;\n                d[to] = d[v] + 1;\n            }\n        }\n    }\n    return d[t] != -1;\n}\n \nint dfs (int v, int flow) {\n    if (!flow)  return 0;\n    if (v == t)  return flow;\n    for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n        int id = g[v][ptr[v]],\n            to = e[id].b;\n        if (d[to] != d[v] + 1)  continue;\n        int pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n        if (pushed) {\n            e[id].flow += pushed;\n            e[id^1].flow -= pushed;\n            return pushed;\n        }\n    }\n    return 0;\n}\n\nvector<bool> visited;\nvector<int> via;\n\nvoid dfs2(int v) {\n  visited[v] = true;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    int id = g[v][i];\n    int to = e[id].b;\n    if (!visited[to] && e[id].flow < e[id].cap) {\n      via[to] = v;\n      dfs2(to);\n    }\n  }\n}\n \nint dinic() {\n    int flow = 0;\n    for (;;) {\n        if (!bfs())  break;\n        memset (ptr, 0, nv * sizeof ptr[0]);\n        while (int pushed = dfs (s, INF))\n            flow += pushed;\n    }\n    return flow;\n}\n\nint main() {\n        int n; scanf(\"%d\", &n);\n        nv = 2 * n + 1;\n        s = nv - 2;\n        t = nv - 1;\n        vector<int> left(n);\n        for (int i = 0; i < n; ++i) {\n            left[i] = i;\n            addEdge(s, left[i], 1);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int cur = n + i;\n            int count; scanf(\"%d\", &count);\n            addEdge(cur, t, 1);\n            for (int j = 0; j < count; ++j) {\n                int a; scanf(\"%d\", &a);\n                addEdge(left[a - 1], cur, 1);\n            }\n        }\n        int flow = dinic();\n        if (flow != n - 1) {\n            \n                printf(\"-1\\n\");\n                return 0;\n        }\n        visited = vector<bool>(nv);\n        via = vector<int>(nv);\n        dfs2(s);\n        for (int v : left) {\n            if (!visited[v]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n        vector<int> first(n - 1);\n        vector<int> second(n - 1);\n        for (int v : left) {\n            if (via[v] == s) continue;\n            int u = via[via[v]];\n            first[via[v] - n] = v + 1;\n            second[via[v] - n] = u + 1;\n        }\n        for (int i = 0; i < n - 1; ++i)           {\n            printf(\"%d %d\\n\", first[i], second[i]);\n        }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x7fffffffffffffff;\nconst double eps=1e-10;\n\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline bool _cmp(const _Tp &a,const _Tp &b){return abs(a-b)<=eps;}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tregister char ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args)\n{\n\tread(t);read(args...);\n}\nFinline int read_str(char *s)\n{\n\tregister char ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tregister char *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=200015;\ntemplate<typename _Tp>\nclass flow{\npublic:\n\tstruct edge{\n\t\tint v,nxt;\n\t\t_Tp w;\n\t}c[N<<3];\n\tint front[N],edge_cnt;\n\tFinline flow(){memset(front,255,sizeof(front)),edge_cnt=-1;}\n\tint cur[N],dep[N],S,T;\n\tint _q[N],_l,_r;\n\tint node_cnt;\n\tFinline void add(int u,int v,_Tp w)\n\t{\n\t\tc[++edge_cnt]=(edge){v,front[u],w},front[u]=edge_cnt;\n\t\tc[++edge_cnt]=(edge){u,front[v],0},front[v]=edge_cnt;\n\t}\n\tbool bfs()\n\t{\n\t\tmemset(dep,255,(node_cnt+3)<<2);\n\t\tmemcpy(cur,front,(node_cnt+3)<<2);\n\t\tdep[S]=0;\n\t\t_q[_l=_r=1]=S;\n\t\twhile(_l!=_r+1)\n\t\t{\n\t\t\tint x=_q[_l++];\n\t\t\tfor(int i=front[x];~i;i=c[i].nxt)\n\t\t\t{\n\t\t\t\tif(c[i].w&&!~dep[c[i].v])\n\t\t\t\t{\n\t\t\t\t\tdep[c[i].v]=dep[x]+1;\n\t\t\t\t\t_q[++_r]=c[i].v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ~dep[T];\n\t}\n\t_Tp dfs(int x,int flow)\n\t{\n\t\tif(x==T||!flow) return flow;\n\t\t_Tp f=0,rf;\n\t\tfor(int &i=cur[x];~i;i=c[i].nxt)\n\t\t{\n\t\t\tif(dep[c[i].v]==dep[x]+1&&(rf=dfs(c[i].v,min(flow,c[i].w))))\n\t\t\t{\n\t\t\t\tflow-=rf,f+=rf;\n\t\t\t\tc[i].w-=rf,c[i^1].w+=rf;\n\t\t\t\tif(!flow) return f;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\t_Tp dinic()\n\t{\n\t\t_Tp ans=0;\n\t\twhile(bfs()) ans+=dfs(S,inf);\n\t\t// inf changes when _Tp != int\n\t\treturn ans;\n\t}\n\tbool vis[N];\n\tint to[N];\n\tint n;\n\tstd::pair<int,int> ans[N];\n\tint cnt=0;\n\tvoid dfs(int x)\n\t{\n\t\tfor(int i=front[x];~i;i=c[i].nxt)\n\t\t{\n\t\t\tif(c[i].v<n+n&&!vis[c[i].v-n])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tans[c[i].v-n]=std::make_pair(x,to[c[i].v-n]);\n\t\t\t\tvis[c[i].v-n]=true;\n\t\t\t\tdfs(to[c[i].v-n]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid solve(int _n)\n\t{\n\t\tn=_n;\n\t\tint root=0;\n\t\tfor(int i=front[S];~i;i=c[i].nxt)\n\t\t{\n\t\t\tif(c[i].w)\n\t\t\t{\n\t\t\t\troot=c[i].v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tfor(int _=front[i+n];~_;_=c[_].nxt)\n\t\t\t{\n\t\t\t\tif(c[_].v<=n&&c[_].w)\n\t\t\t\t{\n\t\t\t\t\tto[i]=c[_].v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(root);\n\t\tif(cnt!=n-1)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=1;i<n;++i) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\t}\n\t}\n};\nflow<int> F;\nint main()\n{\n\tint n;\n\tread(n);\n\tint x,y;\n\tF.S=n+n,F.T=n+n+1;\n\tF.node_cnt=n+n+1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tread(x);\n\t\tfor(int j=1;j<=x;++j)\n\t\t{\n\t\t\tread(y);\n\t\t\tF.add(y,i+n,1);\n\t\t}\n\t\tF.add(i+n,F.T,1);\n\t\tF.add(F.S,i,1);\n\t}\n\tF.add(F.S,n,1);\n\tint ans=F.dinic();\n\tif(ans!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tF.solve(n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define pb push_back\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define MEM(i,j) memset(i,j,sizeof i)\n#define ALL(v) v.begin(),v.end()\n#define DB(a,s,e) {for(int i=s;i<e;++i) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int MAXN=2e5+50,INF=1e9;\nstruct Maxflow{\n\tstruct edge{\n\t\tint to,cap,flow,rev;\n\t};\n\tvector<edge> G[MAXN];\n\tint dis[MAXN],cur[MAXN],s,t;\n\tint dfs(int u,int cap){\n\t\tif(u==t||!cap) return cap;\n\t\tfor(int &i=cur[u];i<G[u].size();++i){\n\t\t\tauto &e=G[u][i];\n\t\t\tif(dis[e.to]==dis[u]+1&&e.flow!=e.cap){\n\t\t\t\tint df=dfs(e.to,min(cap,e.cap-e.flow));\n\t\t\t\tif(df){\n\t\t\t\t\te.flow+=df,G[e.to][e.rev].flow-=df;\n\t\t\t\t\treturn df;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[u]=-1;\n\t\treturn 0;\n\t}\n\tbool bfs(){\n\t\tMEM(dis,-1);\n\t\tqueue<int> q;\n\t\tq.push(s),dis[s]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto e:G[u])\n\t\t\t\tif(!~dis[e.to]&&e.flow!=e.cap)\n\t\t\t\t\tq.push(e.to),dis[e.to]=dis[u]+1;\n\t\t}\n\t\treturn dis[t]!=-1;\n\t}\n\tint maxflow(int _s,int _t){\n\t\ts=_s,t=_t;\n\t\tint flow=0,df;\n\t\twhile(bfs()){\n\t\t\tMEM(cur,0);\n\t\t\twhile(df=dfs(s,INF)) flow+=df;\n\t\t}\n\t\treturn flow;\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;++i) G[i].clear();\n\t}\n\tvoid add_edge(int a,int b,int cap){\n\t\tG[a].pb(edge{b,cap,0,G[b].size()});\n\t\tG[b].pb(edge{a,0,0,G[a].size()-1});\n\t}\n}Dinic;\n\nint match[200005],n,ans[100005];\nvector<int> G[100005];\nbitset<100005> vis;\n\nvoid dfs(int u,int f)\n{\n\tvis[u]=1,ans[u]=f;\n\tfor(int i:G[u])\n\t\tif(!vis[i])\n\t\t\tdfs(i,u);\n}\n\nint main()\n{jizz\n\tint t,x,s;\n\tcin >> n,Dinic.init(2*n+1);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tcin >> t;\n\t\twhile(t--)\n\t\t\tcin >> x,Dinic.add_edge(i+n,x,1);\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tDinic.add_edge(2*n,i+n,1);\n\tfor(int i=1;i<=n;++i)\n\t\tDinic.add_edge(i,0,1);\n\tif(Dinic.maxflow(2*n,0)!=n-1)\n\t\treturn cout << \"-1\\n\",0;\n\tfor(int i=1;i<n;++i)\n\t\tfor(auto e:Dinic.G[i+n])\n\t\t\tif(e.cap==e.flow&&e.to<=n)\n\t\t\t{\n\t\t\t\tmatch[i+n]=e.to,match[e.to]=i;\n\t\t\t\t//cout << i << \"-\" << e.to << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(!match[i])\n\t\t{\n\t\t\ts=i,match[i]=n,match[n+n]=i;\n\t\t\tbreak;\n\t\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(auto e:Dinic.G[i+n])\n\t\tif(e.to<=n&&match[e.to]!=i)\n\t\t\t\tG[match[e.to]].pb(i);//,cout << \"add edge \" << match[e.to] << \"->\" << i << \"\\n\";\n\tdfs(n,-1);\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i])\n\t\t\treturn cout << \"-1\\n\",0;\n\tfor(int i=1;i<n;++i)\n\t\tcout << match[i+n] << \" \" << match[ans[i]+n] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\nconst int N=1e5+1, V=2e5, E=8e5;\nint n, m, to[E], cap[E], head[V], next[E], cur[V], queue[V], dis[V], u[N], v[N], tot;\nbool vis[N];\nstd::vector<int> in[N];\nvoid add_edge(int u, int v, int w) {\n\tto[m]=v, cap[m]=w, next[m]=head[u], head[u]=m++;\n\tto[m]=u, cap[m]=0, next[m]=head[v], head[v]=m++;\n}\nbool bfs() {\n\tint *qhead=queue, *qtail=queue;\n\tmemset(dis, -1, 2*n*sizeof(int));\n\tdis[*qtail++=n]=true;\n\twhile(qhead!=qtail) {\n\t\tint u=*qhead++;\n\t\tfor(int i=head[u]; ~i; i=next[i])\n\t\t\tif(dis[to[i]]==-1&&cap[i^1]) {\n\t\t\t\tdis[*qtail++=to[i]]=dis[u]+1;\n\t\t\t\tif(to[i]==0) return true;\n\t\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x, int lim) {\n\tif(x==n) return lim;\n\tint rem=lim;\n\tfor(int &i=cur[x]; ~i; i=next[i])\n\t\tif(cap[i]&&dis[to[i]]==dis[x]-1) {\n\t\t\tint t=dfs(to[i], std::min(lim, cap[i]));\n\t\t\tcap[i]-=t, cap[i^1]+=t;\n\t\t\tif((rem-=t)==0) return lim;\n\t\t}\n\treturn lim-rem;\n}\nvoid sol(int x) {\n\tvis[x]=true;\n\t++tot;\n\tfor(int y: in[x]) {\n\t\tint z=u[y];\n\t\tif(z!=x&&!vis[z]) v[y]=x, sol(z);\n\t}\n}\nint main() {\n\tn=rd();\n\tmemset(head, -1, 2*n*sizeof(int));\n\tfor(int i=1; i<n; ++i) add_edge(0, i, 1), add_edge(n+i, n, 1);\n\tfor(int i=1; i<n; ++i) {\n\t\tint c=rd();\n\t\twhile(c--) {\n\t\t\tint j=rd();\n\t\t\tin[j].emplace_back(i);\n\t\t\tif(j!=n) add_edge(j, n+i, 1);\n\t\t}\n\t}\n\tint flow=0;\n\twhile(bfs()) {\n\t\tmemcpy(cur, head, 2*n*sizeof(int));\n\t\tflow+=dfs(0, 1e9);\n\t}\n\tif(flow!=n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i)\n\t\tfor(int j=head[n+i]; ~j; j=next[j])\n\t\t\tif(cap[j]) u[i]=to[j];\n\tsol(n);\n\tif(tot<n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i) printf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <set>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100]; set<int> W[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tif (N == 2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t\tW[x].insert(i);\n\t\t}\n\t}\n\n\tfor (int i=1;i<=N;i++){\n\t\tif (W[i].size() == 0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstack<int> s;\n\tfor (int i=0;i<N-1;i++){\n\t\tint c = 0;\n\t\tfor (int x : G[i]) if (W[x].size() == 1) c++;\n\t\tif (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if (c == 1){\n\t\t\ts.push(i);\n\t\t}\n\t}\n\n\twhile (!s.empty()){\n\t\tint i = s.top(), v = 0, c = 0; s.pop();\n\t\tfor (int x : G[i]){\n\t\t\tif (W[x].size() == 1) v = x, c++;\n\t\t\tW[x].erase(i);\n\t\t\tif (W[x].size() == 1) s.push(*W[x].begin());\n\t\t}\n\t\tif (c == 1){\n\t\t\tint x = v;\n\t\t\tint y = G[i][0]==v?G[i][1]:G[i][0];\n\t\t\tX[i] = x; Y[i] = y;\n\t\t}\n\t\telse if (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[i].clear();\n\t}\n\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++) if (!G[i].empty()){\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsrand(time(NULL));\n\tfor (int t=0;t<1000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi E[N],e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\tE[i].pb(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\");\n\trep(i,1,n-1){\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\t}\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n-1)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,\n\t\t\tvi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\n\nvector<vector<int> > g;\nvector<int> btoa;\n\nvector<vector<pair<int,int> > > edges;\nint main(){\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tbtoa.resize(n, -1);\n\tfor(int i = 1; i < n; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tfor(int a = 0; a < c; a++){\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\td--;\n\t\t\tg[i].push_back(d);\n\t\t}\n\t}\n\tg[0].push_back(0);\n\tif(hopcroftKarp(g, btoa) < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> a(n);\n\tvector<int> b(n);\n\ta = btoa;\n\n\tedges.resize(n);\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int r : g[i]){\n\t\t\tedges[r].push_back({a[i], i});\n\t\t}\n\t}\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint s = 0;\n\tvector<int> vis(n, 0);\n\tvis[0] = 1;\n\tint cnt = 1;\n\twhile(s < bfs.size()){\n\t\tint x = bfs[s];\n\t\ts++;\n\t\tfor(auto r : edges[x]){\n\t\t\tif(vis[r.first]) continue;\n\t\t\tvis[r.first] = 1;\n\t\t\tcnt++;\n\t\t\tb[r.second] = x;\n\t\t\tbfs.push_back(r.first);\n\t\t}\n\t}\n\tif(cnt < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tcout << a[i] + 1 << \" \" << b[i] + 1 << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0&&di[a[y].nu]==di[x]+1){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)  cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tcout<<i<<' '<<i+1<<endl;\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005, Inf = 1 << 30;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nint n;\nqueue<int> q;\nvector<int> vec[maxn];\nint eu[maxn], ev[maxn], vis[maxn];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn << 3];\nint s, t, h[maxn << 1], cur[maxn << 1], dis[maxn << 1], mat[maxn << 1], tot = 1;\n\ninline void add(int u, int v, int w)\n{\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nbool bfs()\n{\n\tstatic int l, r, q[maxn << 1];\n\tmemset(dis + 1, 0, sizeof(int) * t);\n\tl = 0; q[r = 1] = s; dis[s] = 1;\n\twhile (l < r) {\n\t\tint u = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!dis[v] && e[i].cap) dis[v] = dis[u] + 1, q[++r] = v;\n\t}\n\treturn dis[t];\n}\n\nint dfs(int u, int a)\n{\n\tif (u == t || !a) return a;\n\tint f, flow = 0;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (dis[v] == dis[u] + 1 && (f = dfs(v, min(a, e[i].cap)))) {\n\t\t\tflow += f; a -= f;\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint max_flow()\n{\n\tint res = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * t);\n\t\tres += dfs(s, Inf);\n\t}\n\tfor (int u = 1; u < n; ++u)\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!e[i].cap && v != s) {mat[u] = v; mat[v] = u; break;}\n\treturn res;\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int c, w, i = 1; i < n; ++i) {\n\t\tc = gi();\n\t\twhile (c--) {\n\t\t\tw = gi(); vec[w].push_back(i);\n\t\t\tif (w != n) add(w, i + n - 1, 1);\n\t\t}\n\t}\n\ts = n * 2 - 1; t = s + 1;\n\tfor (int i = 1; i < n; ++i) add(s, i, 1), add(i + n - 1, t, 1);\n\t\n\tif (max_flow() != n - 1) return puts(\"-1\"), 0;\n\tint cnt = 0; q.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); ++cnt;\n\t\tfor (int e : vec[u])\n\t\t\tif (!vis[e]) vis[e] = 1, q.push(mat[e + n - 1]), eu[e] = u, ev[e] = mat[e + n - 1];\n\t}\n\tif (cnt != n) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 200003, M = N << 2, INF = 0x3f3f3f3f;\nint n, S, T, head[N], to[M], nxt[M], w[M], dep[N], cur[N], q[N], f, r, ans[2][N], m;\nbool vis[N];\ntemplate<typename T>\ninline void read(T &x){\n    int ch = getchar(); x = 0;\n    for(;ch < '0' || ch > '9';ch = getchar());\n    for(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n}\ninline void add(int a, int b, int c){\n    static int cnt = 1;\n    to[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt; w[cnt] = c;\n    to[++ cnt] = a; nxt[cnt] = head[b]; head[b] = cnt; w[cnt] = 0;\n}\ninline bool bfs(){\n    memset(dep, -1, sizeof dep);\n    memcpy(cur, head, sizeof cur);\n    dep[S] = f = r = 0; q[r ++] = S;\n    while(f < r){\n        int u = q[f ++];\n        for(Rint i = head[u];i;i = nxt[i])\n            if(dep[to[i]] == -1 && w[i]){\n                dep[to[i]] = dep[u] + 1; q[r ++] = to[i];\n            }\n    }\n    return ~dep[T];\n}\ninline int dfs(int x, int lim){\n    if(!lim || x == T) return lim;\n    int flow = 0, f;\n    for(Rint i = cur[x];i;i = nxt[i]){\n        cur[x] = i;\n        if(dep[to[i]] == dep[x] + 1 && (f = dfs(to[i], min(lim, w[i])))){\n            flow += f; lim -= f; w[i] -= f; w[i ^ 1] += f;\n            if(!lim) break;\n        }\n    }\n    return flow;\n}\ninline int dinic(){\n    int ans = 0;\n    while(bfs()) ans += dfs(S, INF);\n    return ans;\n}\ninline void dfs(int x){\n    for(Rint i = head[x];i;i = nxt[i]) if(to[i] != S && !vis[to[i] - n]){\n        int u = to[i] - n; vis[u] = true;\n        for(Rint j = head[to[i]];j;j = nxt[j]) if(w[j]){\n            ++ m; ans[0][u] = x; ans[1][u] = to[j]; dfs(to[j]); break;\n        }\n    }\n}\nint main(){\n    read(n); S = n << 1; T = S + 1;\n    for(Rint i = 1;i <= n;++ i) add(S, i, 1);\n    for(Rint i = 1, x, u;i < n;++ i){\n        read(x); add(n + i, T, 1);\n        while(x --){read(u); add(u, n + i, 1);}\n    }\n    if(dinic() != n - 1) return puts(\"-1\"), 0;\n    for(Rint i = head[S];i;i = nxt[i]) if(w[i]){dfs(to[i]); break;}\n    if(m != n - 1) return puts(\"-1\"), 0;\n    for(Rint i = 1;i < n;++ i) printf(\"%d %d\\n\", ans[0][i], ans[1][i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\nint sum;\n\nint dg(int x, int flow) {\n\tif(x == T) {\n\t\tsum += flow;\n\t\treturn flow;\n\t}\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] == d[to[i]] + 1 && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(sum == n - 1 || use == flow) return use;\n\t\t}\n\tcur[x] = fi[x];\n\tif(!(-- co[d[x]])) d[S] = T;\n\t++ co[++ d[x]];\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tsum = 0;\n\tco[0] = T; while(d[S] < T) dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nvector<int> E[N],in[N];\nnamespace Graph{\n\tconst int inf = 1e9;\n\tvector<pair<int,int> > ans;\n\tint n,tot,t,head[N],b[N],vis[N],cur[N];\n\tstruct edge{int v,nxt,f;}e[N*4];\n\tvoid init(int m){\n\t\tn=m;t=2*n+1;tot=1;\n\t\tans.resize(n);\n\t}\n\tvoid add(int x,int y,int z){\n\t\te[++tot]={y,head[x],z};\n\t\thead[x]=tot;\n\t\te[++tot]={x,head[y],0};\n\t\thead[y]=tot;\n\t}\n\tbool bfs(){\n\t\tmemset(b,0,sizeof(b));b[0]=1;\n\t\tqueue<int> q;q.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&!b[e[i].v]){\n\t\t\t\t\tb[e[i].v]=b[u]+1;\n\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t}\n\t\t}\n\t\treturn b[t];\n\t}\n\tint dfs(int x,int flow){\n\t\tif(!flow||x==t) return flow;\n\t\tint f=flow,tmp;\n\t\tfor(int &i=cur[x];i;i=e[i].nxt)\n\t\t\tif(b[e[i].v]==b[x]+1&&(tmp=dfs(e[i].v,min(e[i].f,f)))){\n\t\t\t\tf-=tmp;e[i].f-=tmp;e[i^1].f+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\treturn flow-f;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tans+=dfs(0,inf);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(int x){\n\t\tvis[x]=1;\n\t\tfor(int p:in[x])\n\t\t\tfor(int i=head[p+n];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&e[i].v!=t){\n\t\t\t\t\tif(vis[e[i].v]) continue;\n\t\t\t\t\tans[p]=make_pair(x,e[i].v);\n\t\t\t\t\tsolve(e[i].v);\n\t\t\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i=1;i<n;i++) if(!ans[i].first){puts(\"-1\");return;}\n\t\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint n;\nint main(){\n\tread(n);\n\tGraph::init(n);\n\tfor(int i=1;i<n;i++){\n\t\tint k;read(k);\n\t\twhile(k--){\n\t\t\tint x;read(x);\n\t\t\tE[i].push_back(x);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int x:in[i]) Graph::add(i,x+n,1);\n\t\tGraph::add(0,i,1);\n\t}\n\tfor(int i=1;i<n;i++) Graph::add(i+n,Graph::t,1);\n\tif(Graph::Dinic()<n-1){puts(\"-1\");return 0;}\n\tGraph::solve(1);\n\tGraph::print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, c, u;\n\nvector<int> edge[108000];\nvector<int> ans[216000];\nbool come[216000];\n\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tedge[i].push_back(n + u);\n\t\t\tedge[n+u].push_back(i);\n\t\t}\t\n\t}\n\tdfs(n+1);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 3e5 + 50, M = 2e6 + 50;\ncs int INF = 1e9 + 7;\nint n, S, T, fi[N], nxt[M], to[M], w[M], ec=1;\nvoid adde(int x, int y, int z){\n\tnxt[++ec]=fi[x], fi[x]=ec, to[ec]=y, w[ec]=z;\n\tnxt[++ec]=fi[y], fi[y]=ec, to[ec]=x, w[ec]=0;\n} int eu[N], ev[N], ct, d[N];\nbool bfs(){\n\tqueue<int> q; q.push(S); \n\tmemset(d,-1,sizeof(d)); d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x],v;e;e=nxt[e]) if(w[e]){\n\t\t\tv=to[e]; if(d[v]==-1){\n\t\t\t\td[v]=d[x]+1; q.push(v);\n\t\t\t\tif(v==T) return true;\n\t\t\t}\n\t\t}\n\t} return false;\n}\nint dfs(int u, int flw){\n\tif(u==T) return flw; int ans = 0;\n\tfor(int e=fi[u],v;e;e=nxt[e])\n\tif(d[v=to[e]]==d[u]+1){\n\t\tint dt=dfs(v,min(w[e],flw));\n\t\tans+=dt; flw-=dt;\n\t\tw[e]-=dt; w[e^1]+=dt; if(!flw) break;\n\t} if(flw) d[u]=-1; return ans;\n}\nint dinic(){ int flw = 0; while(bfs()) flw += dfs(S,INF); return flw; }\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1,k,x; i<n; i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1; j<=k; j++) \n\t\tscanf(\"%d\",&x), adde(x,i+n,1);\n\t} S=0, T=n+n;\n\tfor(int i=1; i<=n; i++) adde(S,i,1);\n\tfor(int i=1; i<n; i++) adde(i+n,T,1);\n\tint flw = dinic();\n\tif(flw < n-1) return puts(\"-1\"),0;\n\t\n\tstatic int tr[N];\n\tfor(int i=n+1; i<n+n; i++)\n\tfor(int e=fi[i];e;e=nxt[e]) \n\tif(to[e]!=T&&w[e]) tr[i]=to[e];\n\t\n\tqueue<int> q;\n\tfor(int e=fi[S];e;e=nxt[e])\n\tif(w[e]) q.push(to[e]);\n\t\n\tstatic bool ban[N];\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x];e;e=nxt[e]) \n\t\tif(to[e]!=S&&!ban[to[e]]){\n\t\t\teu[++ct]=x; ev[ct]=tr[to[e]];\n\t\t\tq.push(tr[to[e]]); ban[to[e]]=true;\n\t\t}\n\t} if(ct<n-1) return puts(\"-1\"),0;\n\tfor(int i=1; i<n; i++) cout<<eu[i]<<\" \"<<ev[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    for (int it = 0; it < n - 1; it++) {\n      assert(!q.empty());\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v, done);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tcout<<i<<' '<<i+1<<endl;\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int i=h[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[u]=v-n;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define M 400010\n#define inf 1e9\nusing namespace std;\nint n,num,cnt,s,t,h[M],head[M],son[M],vis[M];\nvector<int>S[M],P[M];\nqueue<int>Que;\nstruct node{int x,y;}f[M];\nstruct edge{int next,to,dis;}e[M<<1];\nvoid add(int from,int to,int dis) {\n\te[num]=(edge){head[from],to,dis};\n\thead[from]=num++;\n}\nbool bfs() {\n\tqueue<int>Q;Q.push(s);\n\tmemset(h,0,sizeof(h)),h[s]=1;\n\twhile(!Q.empty()) {\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis>0&&!h[e[i].to])\n\t\t\t\tQ.push(e[i].to),h[e[i].to]=h[x]+1;\n\t}\n\treturn h[t];\n}\nint dfs(int x,int dis) {\n\tif(x==t) return dis;int sum=0;\n\tfor(int i=head[x];i;i=e[i].next) {\n\t\tint to=e[i].to;\n\t\tif(e[i].dis&&h[to]==h[x]+1) {\n\t\t\tint diss=dfs(to,min(e[i].dis,dis));\n\t\t\tdis-=diss;sum+=diss;\n\t\t\te[i].dis-=diss;e[i^1].dis+=diss;\n\t\t\tif(!dis) break;\n\t\t}\n\t}\n\tif(!sum) h[x]=-1;\n\treturn sum;\n}\nint dinic() {\n\tint tot=0;\n\twhile(bfs()) \n\t\ttot+=dfs(s,inf);\n\treturn tot;\n}\nint main() {\n\tscanf(\"%d\",&n);s=0,t=2*n;\n\tfor(int i=1;i<n;i++) {\n\t\tint sum;scanf(\"%d\",&sum);\n\t\tfor(int j=1;j<=sum;j++) {\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tS[i+n].push_back(x);\n\t\t\tadd(i+n,x,0),add(x,i+n,1);\n\t\t\tP[x].push_back(i+n);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) add(i,s,0),add(s,i,1);\n\tfor(int i=n+1;i<n+n;i++) add(t,i,0),add(i,t,1);\n\tint ans=dinic();\n\tif(ans!=n-1) {puts(\"-1\");return 0;}\n\tfor(int x=n+1;x<n+n;x++)\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis&&e[i].to!=t)\n\t\t\t\tson[x]=e[i].to;\n\tQue.push(1);\n\twhile(!Que.empty()) {\n\t\tint x=Que.front();Que.pop();\n\t\tfor(int i=0;i<P[x].size();i++) {\n\t\t\tint to=P[x][i];\n\t\t\tif(!vis[to]) {\n\t\t\t\tvis[to]=true;\n\t\t\t\tQue.push(son[to]);\n\t\t\t\tf[++cnt]=(node){x,son[to]};\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t}\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsort(v.begin(),v.end());\n\n\tsrand(time(NULL));\n\tfor (int t=0;t<3000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5,INF=(1<<29),SZ=2*N+10;\n\nstruct EDGE{\n    int to,cap;\n    EDGE *nxt,*rev;\n    EDGE(){}\n    EDGE(int _t,int _c,EDGE *_n,EDGE *_r):to(_t),cap(_c),nxt(_n),rev(_r){}\n};\nstruct GRAPH{\n    EDGE edg[4*N*2+10],*head[SZ],*ncnt;\n    GRAPH(){ncnt=edg;}\n    void AddEdge(int u,int v,int cap){\n        EDGE *p=++ncnt,*q=++ncnt;\n        *p=EDGE(v,cap,head[u],q);head[u]=p;\n        *q=EDGE(u,  0,head[v],p);head[v]=q;\n    }\n    EDGE* operator [](int id){return head[id];}\n};\nGRAPH Gr;\nEDGE *cop[SZ];\nint dis[SZ];\nvector< pair<int,int> > lnk[N+3];\nint n,S,T,tot;\nvector<int> tset[N+3];\nint ans[N+3][2];\nbool vis[N+3];\n\nint Aug(int u,int in){\n    if(u==T) return in;\n    int out=0;\n    while(cop[u]){\n        EDGE *it=cop[u];cop[u]=cop[u]->nxt;\n        int v=it->to;\n        if(dis[v]!=dis[u]+1 || it->cap<=0) continue;\n        int tov=Aug(v,min(in-out,it->cap));\n        it->cap-=tov;it->rev->cap+=tov;\n        out+=tov;\n        if(out==in) break;\n    }\n    return out;\n}\nbool BFS(){\n    for(int i=1;i<=T;i++) dis[i]=-1,cop[i]=Gr[i];\n    queue<int> que;que.push(S);dis[S]=0;\n    while(!que.empty()){\n        int u=que.front();que.pop();\n        for(EDGE *it=Gr[u];it;it=it->nxt){\n            int v=it->to;\n            if(dis[v]!=-1 || it->cap<=0) continue;\n            dis[v]=dis[u]+1;\n            if(v==T) return true;\n            que.push(v);\n        }\n    }\n    return false;\n}\nint Dinic(){\n    int res=0;\n    while(BFS())\n        res+=Aug(S,INF);\n    return res;\n}\nvoid DFS(int u){\n    vis[u]=true;tot++;\n    for(int i=(int)lnk[u].size()-1;i>=0;i--){\n        int v=lnk[u][i].first,id=lnk[u][i].second;\n        if(ans[id][0] || vis[v]) continue;\n        ans[id][0]=u;ans[id][1]=v;\n        DFS(v);\n    }\n}\nint main(){\n    // freopen(\"input.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    S=n*2;T=S+1;\n    for(int i=2;i<=n;i++) Gr.AddEdge(S,i,1);\n    for(int i=1;i<n;i++) Gr.AddEdge(i+n,T,1);\n    for(int i=1;i<n;i++){\n        int num;scanf(\"%d\",&num);\n        while(num--){\n            int u;scanf(\"%d\",&u);\n            Gr.AddEdge(u,n+i,1);\n            tset[i].push_back(u);\n        }\n    }\n    int res=Dinic();\n    if(res<n-1) printf(\"-1\\n\");\n    else{\n        for(int i=1;i<n;i++){\n            int E=i+n,u=-1;\n            for(EDGE *it=Gr[E];it && u==-1;it=it->nxt)\n                if(it->cap)\n                    u=it->to;\n            for(int j=(int)tset[i].size()-1;j>=0;j--)\n                if(tset[i][j]!=u){\n                    int v=tset[i][j];\n                    lnk[u].emplace_back(v,i);\n                    lnk[v].emplace_back(u,i);\n                }\n        }\n        DFS(1);\n        if(tot<n) printf(\"-1\\n\");\n        else\n            for(int i=1;i<n;i++)\n                printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],min(flow-used,c[i]));\n\t\tif(v)used+=v,c[i]-=v,c[i^1]+=v,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,print(x,num[i]),q[++t]=num[i];\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n)p[u]=gp;\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=1;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=2;i<=n;++i)if(!p[i])return puts(\"-1\"),0;\n\tfor(int i=2;i<=n;++i)printf(\"%d %d\\n\",p[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=4e5+9,inf=1e8;\n\tint head[N],nex[N],to[N],fl[N],cnt=1;\n\tinline void add(int u,int v,int flow){\n\t//\tcout<<u<<\" \"<<v<<\" \"<<flow<<endl;\n\t\tnex[++cnt]=head[u],head[u]=cnt,to[cnt]=v,fl[cnt]=flow;\n\t\tnex[++cnt]=head[v],head[v]=cnt,to[cnt]=u,fl[cnt]=0;\n\t}\n\tint S,T,dist[N],cur[N];\n\tqueue<int> q;\n\tinline bool bfs(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=T;i++) dist[i]=inf;\n\t\tq.push(S),dist[S]=0;\n\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tif(u==T) return 1;\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(fl[i] && dist[to[i]]==inf){\n\t\t\t\t\tdist[to[i]]=dist[u]+1;\n\t\t\t\t\tq.push(to[i]);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tinline int dfs(int u,int flow){\n\t\tif(u==T) return flow;\n\t\tint rest=flow,k;\n\t\tfor(int &i=cur[u];rest && i;i=nex[i])\n\t\t\tif(fl[i] && dist[to[i]]==dist[u]+1){\n\t\t\t\tk=dfs(to[i],min(fl[i],flow));\n\t\t\t\tfl[i]-=k,fl[i^1]+=k,rest-=k;\n\t\t\t}\n\t\treturn flow-rest;\n\t}\n\n\tint n,mat[N],vis[N];\n\tvector<int> pos[N],E[N],ans[N];\n\tinline bool fortry(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!mat[i+n-1]){q.push(i);break;}\n\n\t\tint tot=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();tot++;\n\t\t\tfor(int i=0;i<pos[u].size();i++) if(!vis[pos[u][i]]){\n\t\t\t\tint id=pos[u][i];\n\t\t\t\tvis[pos[u][i]]=1,ans[id].push_back(mat[id]-n+1),ans[id].push_back(u);\n\t\t\t\tq.push(mat[id]-n+1);\n\t\t\t}\n\t\t}\n\t\tif(tot!=n) return 0;\n\t\treturn 1;\n\t}\n\tint main(){\n\t\tn=read<int>();\n\t\tS=n-1+n+1,T=S+1;\n\t\tfor(int t=1;t<n;t++){\n\t\t\tint k=read<int>();\n\t\t\tfor(int i=1;i<=k;i++){\n\t\t\t\tint u=read<int>();\n\t\t\t\tE[t].push_back(u),pos[u].push_back(t);\n\t\t\t\tadd(t,u+n-1,1);\n\t\t\t}\n\t\t\tadd(S,t,1);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+n-1,T,1);\n\t\tint mxfl=0;\n\t\twhile(bfs()){\n\t\t\tfor(int i=1;i<=T;i++) cur[i]=head[i];\n\t\t\tint d;\n\t\t\tdo{d=dfs(S,inf),mxfl+=d;}while(d);\n\t\t}\n\t\tif(mxfl!=n-1) puts(\"-1\"),exit(0);\n\t\tfor(int u=1;u<n;u++)\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(!fl[i]){mat[u]=to[i],mat[to[i]]=u;break;}\n\t\tif(!fortry()) puts(\"-1\"),exit(0);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][0]);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &i : x) cin >> i;\n\t\ta.pb({x, i});\n\t}\n\tsort(all(a), [](auto i, auto j) {\n\t\treturn i.first.size() < j.first.size();\n\t});\n\trans.resize(n-1);\n\tdsu d(n);\n\tfor(auto [i, idx] : a) {\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tif(d.r[d.par(1)] != n) return cout << -1, 0;\n\texit(-1);\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=z,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint y=mat[to[i]];\n\tif(!y||v[y]||!c[i]) continue;\n\tan[++ta][0]=x,an[ta][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5,INF=(1<<29),SZ=2*N+10;\n\nstruct EDGE{\n    int to,cap;\n    EDGE *nxt,*rev;\n    EDGE(){}\n    EDGE(int _t,int _c,EDGE *_n,EDGE *_r):to(_t),cap(_c),nxt(_n),rev(_r){}\n};\nstruct GRAPH{\n    EDGE edg[4*N*2+10],*head[SZ],*ncnt;\n    GRAPH(){ncnt=edg;}\n    void AddEdge(int u,int v,int cap){\n        EDGE *p=++ncnt,*q=++ncnt;\n        *p=EDGE(v,cap,head[u],q);head[u]=p;\n        *q=EDGE(u,  0,head[v],p);head[v]=q;\n    }\n    EDGE* operator [](int id){return head[id];}\n};\nGRAPH Gr;\nEDGE *cop[SZ];\nint dis[SZ];\nvector< pair<int,int> > lnk[N+3];\nint n,S,T,tot;\nvector<int> tset[N+3];\nint ans[N+3][2];\nbool vis[N+3];\n\nint Aug(int u,int in){\n    if(u==T) return in;\n    int out=0;\n    while(cop[u]){\n        EDGE *it=cop[u];cop[u]=cop[u]->nxt;\n        int v=it->to;\n        if(dis[v]!=dis[u]+1 || it->cap<=0) continue;\n        int tov=Aug(v,min(in-out,it->cap));\n        it->cap-=tov;it->rev->cap+=tov;\n        out+=tov;\n        if(out==in) break;\n    }\n    return out;\n}\nbool BFS(){\n    for(int i=1;i<=T;i++) dis[i]=-1,cop[i]=Gr[i];\n    queue<int> que;que.push(S);dis[S]=0;\n    while(!que.empty()){\n        int u=que.front();que.pop();\n        for(EDGE *it=Gr[u];it;it=it->nxt){\n            int v=it->to;\n            if(dis[v]!=-1 || it->cap<=0) continue;\n            dis[v]=dis[u]+1;\n            if(v==T) return true;\n            que.push(v);\n        }\n    }\n    return false;\n}\nint Dinic(){\n    int res=0;\n    while(BFS())\n        res+=Aug(S,INF);\n    return res;\n}\nvoid DFS(int u){\n    vis[u]=true;tot++;\n    for(int i=(int)lnk[u].size()-1;i>=0;i--){\n        int v=lnk[u][i].first,id=lnk[u][i].second;\n        if(ans[id][0] || vis[v]) continue;\n        ans[id][0]=u;ans[id][1]=v;\n        DFS(v);\n    }\n}\nint main(){\n    // freopen(\"input.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    S=n*2;T=S+1;\n    for(int i=2;i<=n;i++) Gr.AddEdge(S,i,1);\n    for(int i=1;i<n;i++) Gr.AddEdge(i+n,T,1);\n    for(int i=1;i<n;i++){\n        int num;scanf(\"%d\",&num);\n        while(num--){\n            int u;scanf(\"%d\",&u);\n            Gr.AddEdge(u,n+i,1);\n            tset[i].push_back(u);\n        }\n    }\n    int res=Dinic();\n    if(res<n-1) printf(\"-1\\n\");\n    else{\n        for(int i=1;i<n;i++){\n            int E=i+n,u=-1;\n            for(EDGE *it=Gr[E];it && u==-1;it=it->nxt)\n                if(it->cap)\n                    u=it->to;\n            for(int j=(int)tset[i].size()-1;j>=0;j--)\n                if(tset[i][j]!=u){\n                    int v=tset[i][j];\n                    lnk[u].emplace_back(v,i);\n                    lnk[v].emplace_back(u,i);\n                }\n        }\n        DFS(1);\n        if(tot<n) printf(\"-1\\n\");\n        else\n            for(int i=1;i<n;i++)\n                printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=100010,inf=1<<30;\nint N;\nstruct edge{int to,cap;edge*rev,*next;}E[MaxN*8],*ne=E,*fir[MaxN*2],*cur[MaxN*2];\nvoid link(int a,int b,int c){\n\t*ne=(edge){b,c,ne+1,fir[a]};fir[a]=ne++;\n\t*ne=(edge){a,0,ne-1,fir[b]};fir[b]=ne++;\n}\nint Q[MaxN*2],D[MaxN*2];\nint dfs(int i,int c){\n\tif(i==1||!c)return c;\n\tint fl=0,f;\n\tfor(edge*&e=cur[i];e&&c;e=e->next)\n\t\tif(e->cap&&D[e->to]==D[i]-1&&(f=dfs(e->to,c<e->cap?c:e->cap)))\n\t\t\tfl+=f,e->cap-=f,e->rev->cap+=f,c-=f;\n\treturn fl;\n}\nint u[MaxN],v[MaxN];\nint mf(){\n\tfor(int f=0;;f+=dfs(0,inf)){\n\t\tfor(int i=0;i<=N*2;i++)D[i]=0,cur[i]=fir[i];\n\t\tfor(int*h=Q,*t=Q+(D[*h=1]=1);h<t;h++)\n\t\t\tfor(edge*e=fir[*h];e;e=e->next)\n\t\t\t\tif(e->rev->cap&&!D[e->to]){\n\t\t\t\t\tD[*t++=e->to]=D[*h]+1;\n\t\t\t\t\tif(f==N-1)*h<=N?u[*h]=e->to-N:v[e->to]=*h-N;\n\t\t\t\t} \n\t\tif(!*D)return f;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=2;i<=N;i++){\n\t\tint c,w;\n\t\tscanf(\"%d\",&c);\n\t\tlink(0,i,1);\n\t\twhile(c--)scanf(\"%d\",&w),link(i,N+w,inf);\n\t}\n\tfor(int i=N+1;i<=N*2;i++)link(i,1,1);\n\tif(mf()<N-1)return puts(\"-1\"),0;\n\tfor(int i=2;i<=N;i++)if(!D[i])return puts(\"-1\"),0;\n\tfor(int i=2;i<=N;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500015;\nconst int INF = (int) 1e9;\nint e_num = 1, S, T;\nint hed[maxn], dep[maxn];\nstruct Edge {\n  int from, to, nxt, c;\n} edge[maxn * 4];\nvoid addedge(int from, int to, int c) {\n  edge[++e_num] = (Edge){from, to, hed[from], c};\n  hed[from] = e_num;\n}\nvoid adde(int from, int to, int c) {\n  addedge(from, to, c);\n  addedge(to, from, 0);\n}\nint que[maxn + 5], head = 0, tail = 0;\nbool bfs() {\n  head = tail = 0;\n  que[tail++] = S;\n  for (int i = S; i <= T; i++) dep[i] = 0;\n  dep[S] = 1;\n  while (head != tail) {\n    int cur = que[head++]; head %= maxn;\n    for (int i = hed[cur]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (!dep[to] && edge[i].c) {\n        dep[to] = dep[cur] + 1;\n        que[tail++] = to; tail %= maxn;\n      }\n    }\n  }\n  return dep[T];\n}\nint dfs(int x, int flow) {\n  if (x == T) return flow;\n  int ret = 0;\n  for (int i = hed[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (dep[to] == dep[x] + 1 && edge[i].c) {\n      int tmp = dfs(to, std::min(flow, edge[i].c));\n      edge[i].c -= tmp;\n      edge[i ^ 1].c += tmp;\n      flow -= tmp;\n      ret += tmp;\n      if (!flow) {\n        break;\n      }\n    }\n  }\n  if (!ret) dep[x] = 0;\n  return ret;\n}\nint dinic() {\n  int ret = 0;\n  while (bfs()) {\n    ret += dfs(S, INF);\n  }\n  return ret;\n}\n\nconst int N = 100233;\nint n, visit[N], son[N], fa[N];\nvector<int> e[N], g[N];\nint main() {\n  scanf(\"%d\", &n);\n  S = 0, T = n * 2 + 1;\n  for (int i = 1, t, x; i < n; i++) {\n    adde(S, i, 1);\n    scanf(\"%d\", &t);\n    while (t--) {\n      scanf(\"%d\", &x);\n      e[i].push_back(x);\n      g[x].push_back(i);\n      if (x > 1) adde(i, x + n, 1);\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    adde(i + n, T, 1);\n  }\n  int p = dinic();\n  if (p < n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    for (int e = hed[i]; e; e = edge[e].nxt) {\n      if (edge[e].to > n && !edge[e].c) {\n        son[i] = edge[e].to - n;\n      }\n    }\n  }\n  queue<int> q;\n  for (auto x : g[1]) {\n    q.push(x);\n    visit[x] = 1;\n    fa[x] = 1;\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto y : g[son[x]]) {\n      if (!visit[y]) {\n        q.push(y);\n        visit[y] = 1;\n        fa[y] = son[x];\n      }\n    }\n  }\n  if (accumulate(visit + 1, visit + n, 0) != n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", fa[i], son[i]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\t//dmp(s);\n\t\tfor(auto t:adj[s]){\n\t\t\t//if(t.fs<=0)return;\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t\t\t//b[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\tx--;\n\t\tg[i].pb(x);\n\t}\n}\ng[0].pb(0);\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\nfor(int i=1;i<=n-1;i++){\n\tmatch[btoa[i]]=i;\n}\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\t//match[btoa[i]]=i;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({match[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s=1;\nbfstree(0);\nfor(int i=0;i<n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\n//dmp(sum);\n//assert(sum>=n);\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << match[i]+1 << \" \" << b[i]+1 << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\treturn 0;\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1, G2;\nint n, Deg[N_], UF[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nvector<int>TP[N_];\nint Num[N_], Q[N_], head, tail, vis[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tG2.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tG2.Add_Edge(G2.source, i, 1);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tTP[a].push_back(i);\n\t\t\tif (a != 1) {\n\t\t\t\tG2.Add_Edge(i, n - 1 + a, 1);\n\t\t\t}\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tG1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\t\tif(i!=1)G2.Add_Edge(n - 1 + i, G2.sink, 1);\n\t}\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tG2.Dinic();\n\tfor (i = 2; i <= n; i++) {\n\t\tfor (auto &x : G2.G[n - 1 + i]) {\n\t\t\tEdge tp = G2.E[x];\n\t\t\tif (tp.f) {\n\t\t\t\tNum[tp.e] = i;\n\t\t\t}\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : TP[x]) {\n\t\t\tif (!vis[t]) {\n\t\t\t\tRes[t][0] = x;\n\t\t\t\tRes[t][1] = Num[t];\n\t\t\t\tQ[++tail] = Num[t];\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false)\n//   - returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  vector< int > level;\n  vector<size_t> itr;\n  ll build(int s, int t) {\n    level.resize(n);\n    itr.resize(n);\n    ll flow = 0, newflow;\n    while(bfs(s), level[t] >= 0) {\n      itr.assign(n, 0);\n      while((newflow = dfs(s, t, inf)) > 0) {\n        flow += newflow;\n        if(flow >= inf) return inf;\n      }\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] < 0 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int v, int t, ll flow) {\n    if(v == t) return flow;\n    for(size_t &i = itr[v]; i < g[v].size(); ++i) {\n      Edge& edge = edges[g[v][i]];\n      if(edge.Cap(v) > 0 && level[edge.To(v)] > level[v]) {\n        ll newflow = dfs(edge.To(v), t, min(flow, edge.Cap(v)));\n        if(newflow == 0) continue;\n        edge.Cap(v) -= newflow;\n        edge.Rev(v) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e9;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := xを要素に持つグループら\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// メモ：\n// k個のグループにk頂点しか無い場合は自明にループができるので不可\n// よって (k+1) 頂点以上に繋がってていなきゃいけない\n// そのとき k 頂点に必ず繋がっていることになる\n// これは結婚定理と同じ条件なので，必ずn-1本のマッチングが存在することになる\n\n// すると E_i has i を必ず達成できるように番号付けできる\n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} が成り立ってはいけない，と言い換えられる\n// どのような頂点からはじめても，頂点Nにたどり着けなければならない\n// 頂点Nから逆にたどってやって，全てにたどり着けるかだけ調べればいい\n\n// その仮定で，そのDFS木をそのまま構成する木にできる\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I need some holiday\n// But I don't wish that everyday is holiday\n// Because I didn't bear the pain\n// Because it wasn't a true freedom\n//         ——『イヤホンと蝉時雨』·Orangestar\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return cur == ed && (ed = (cur = buffer) + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur == ed) ? EOF : *cur++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ninline char *read_str(char *s)\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\tfor(; isgraph(ch); ch = getc()) *s++ = ch;\n\t*s = '\\0';\n\treturn s;\n}\n\n// END tpl.\n\nconst int MAXN = (int) 1e5;\n\nnamespace FLOW\n{\n\tconst int INF = (int) 1e9;\n\tconst int MAXV = MAXN * 2, MAXE = MAXN * 8;\n\n\tint cnt;\n\n\tinline int new_node() { return ++cnt; }\n\n\tstruct edge\n\t{\n\t\tint v, c, nxt;\n\n\t\tedge() { }\n\t\tedge(int _v, int _c, int _nxt): v(_v), c(_c), nxt(_nxt) { }\n\t};\n\n\tedge e[MAXE * 2 + 5];\n\tint st[MAXV + 5], edge_cnt;\n\n\tinline void init() { cnt = 0, memset(st, -1, sizeof st), edge_cnt = 0; }\n\tinline int add_edge(int u, int v, int c, int type = 1)\n\t{\n\t\te[edge_cnt] = edge(v, c, st[u]), st[u] = edge_cnt++;\n\t\tif(type) add_edge(v, u, 0, 0);\n\t\treturn st[u];\n\t}\n\n\tint d[MAXV + 5];\n\n\tinline int BFS(int S, int T)\n\t{\n\t\tstatic queue<int> q;\n\t\tfor(int i = 1; i <= cnt; ++i) d[i] = -1;\n\n\t\td[S] = 0, q.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor(int i = st[u]; ~i; i = e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].c > 0 && d[v] == -1) d[v] = d[u] + 1, q.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn d[T] != -1;\n\t}\n\n\tint cur[MAXV + 5];\n\n\tinline int dfs(int u, int low, int T)\n\t{\n\t\tif(u == T) return low;\n\n\t\tint sum = 0;\n\t\tfor(int &i = cur[u]; ~i; i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v, k = 0;\n\t\t\tif(e[i].c > 0 && d[v] == d[u] + 1 && (k = dfs(v, min(low, e[i].c), T)) > 0)\n\t\t\t{\n\t\t\t\te[i].c -= k, e[i ^ 1].c += k;\n\t\t\t\tsum += k, low -= k;\n\t\t\t\tif(low == 0) break;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tinline int solve(int S, int T)\n\t{\n\t\tint flow = 0;\n\t\twhile(BFS(S, T))\n\t\t{\n\t\t\tfor(int i = 1; i <= cnt; ++i) cur[i] = st[i];\n\t\t\tfor(int k = dfs(S, INF, T); k > 0; k = dfs(S, INF, T)) flow += k;\n\t\t}\n\t\treturn flow;\n\t}\n}\n\nint n;\n\nvector<int> E[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i < n; ++i) for(int N = read<int>(); N--; ) E[i].push_back(read<int>());\n}\n\nint d[MAXN + 5], id[MAXN + 5];\nvector<int> ids[MAXN + 5];\n\nint fa[MAXN + 5];\n\ninline int dfs(int u)\n{\n\tint res = 1;\n\tfor(auto v0 : ids[u]) if(!fa[v0])\n\t{\n\t\tint v = d[v0];\n\t\tfa[v0] = u;\n\t\tres += dfs(v);\n\t}\n\treturn res;\n}\n\ninline void solve()\n{\n\tFLOW::init();\n\n\tstatic unordered_map<int, int> eid[MAXN + 5];\n\tstatic int X[MAXN + 5], Y[MAXN + 5];\n\n\tconst int S = FLOW::new_node(), T = FLOW::new_node();\n\tfor(int i = 1; i < n; ++i) FLOW::add_edge(S, X[i] = FLOW::new_node(), 1);\n\tfor(int i = 1; i < n; ++i) FLOW::add_edge(Y[i] = FLOW::new_node(), T, 1);\n\n\tfor(int i = 1; i < n; ++i) for(auto j : E[i]) if(j != n)\n\t\teid[i][j] = FLOW::add_edge(X[i], Y[j], 1);\n\n\tif(FLOW::solve(S, T) != n - 1) { puts(\"-1\"); return; }\n\n\tfor(int i = 1; i < n; ++i)\n\t\tfor(auto j : E[i]) if(eid[i].count(j) && FLOW::e[eid[i][j]].c == 0)\n\t\t{\n\t\t\td[i] = j, id[j] = i;\n\t\t\tbreak;\n\t\t}\n\n\tfor(int i = 1; i < n; ++i) for(auto j : E[i]) ids[j].push_back(i);\n\tif(dfs(n) != n) { puts(\"-1\"); return; }\n\tfor(int i = 1; i < n; ++i) printf(\"%d %d\\n\", d[i], fa[i]);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 200002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[5*MAX_N], visited[MAX_N], rev[MAX_N];\nint source, target, d[MAX_N], f[5*MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    queue<int> qu;\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=4e5+5,M=1.2e6+5;\nint n,m,d,e,s,t,he[N],nh[N],to[N],nx[N],le[N],\ntd[N],qu[N],hd,tl,ds[N],a;\ninline void wk(int x,int y)\n{\n\t++e,to[e]=y,le[e]=1,nx[e]=he[x],he[x]=e;\n\t++e,to[e]=x,le[e]=0,nx[e]=he[y],he[y]=e;\n}\ninline int bfs()\n{\n\tmemset(ds,0,16*n+4),memcpy(nh,he,16*n+4),ds[s]=1,qu[hd=tl=1]=s;\n\tfor(;hd<=tl;++hd)for(int x=qu[hd],i=he[x],y;i;i=nx[i])if(le[i]&&!ds[y=to[i]])\n\t\tds[y]=ds[x]+1,qu[++tl]=y;\n\treturn ds[t];\n}\nint dfs(int x,int z)\n{\n\tif(x==t)return 1;\n\tfor(int&i=nh[x],y,g;i;i=nx[i])\n\t\tif(ds[y=to[i]]==ds[x]+1&&le[i]&&(i&1||x&1||x<=t||y-n!=z)&&dfs(y,!(i&1)&&y&1&&y>t?x:z))\n\t\t{\n\t\t\tle[i]=0,le[i^1]=1;\n\t\t\tif(!(i&1)&&!(x&1)&&x>t)td[x]=y;\n\t\t\tif(!(i&1)&&y&1&&y>t)td[y]=x;\n\t\t\tif(x!=s)return 1;\n\t\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n),d=2*n+2,e=1,s=2*n+1,t=2*n+2;\n\tfor(int i=1;i<=n;++i)wk(s,i),wk(n+i,t);\n\tfor(int i=1,x;i<n;++i)\n\t{\n\t\tscanf(\"%d\",&x),++d,++d,wk(d-1,d);\n\t\tfor(int i=1,y;i<=x;++i)\n\t\t\tscanf(\"%d\",&y),wk(y,d-1),wk(d,n+y);\n\t}\n\twhile(bfs())\n\t\tdfs(2*n+1,0);\n\tfor(int i=1;i<n;++i)\n\t\tif(!td[t+2*i-1]||!td[t+2*i])\n\t\t\treturn printf(\"-1\"),0;\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",td[t+2*i-1],td[t+2*i]-n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n//\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;struct edge{int to,next,rem;}e[1000005];\nqueue<int> q;pair<int,int> p[100005];vector<int> bel[100005];\nint tot=1,s,t,n,last[1000005],dep[1000005],nxt[1000005],lst[1000005];\ninline void adde(int u,int v,int d) {e[++tot]=(edge){v,last[u],d},last[u]=tot;return;}\ninline void inse(int u,int v) {return adde(u,v,1),adde(v,u,0);}\ninline bool bfs(void) {\n\tmemset(dep,0,sizeof dep),dep[s]=1;\n\twhile (!q.empty()) q.pop();q.push(s);\n\twhile (!q.empty()) {int cur=q.front();q.pop();\n\t\tfor (int i=last[cur];i;i=e[i].next) {int ot=e[i].to;\n\t\t\tif (e[i].rem&&!dep[ot]) dep[ot]=dep[cur]+1,q.push(ot);\n\t\t}\n\t}return dep[t];\n}int dfs(int u,int lim) {int rtv=0,d;if (u==t) return lim;\n\tfor (int&i=lst[u];i&&rtv<lim;i=e[i].next) {int ot=e[i].to;\n\t\tif (e[i].rem&&dep[ot]==dep[u]+1) {\n\t\t\td=dfs(ot,min(e[i].rem,lim-rtv));\n\t\t\te[i].rem-=d,e[i^1].rem+=d,rtv+=d;\n\t\t}\n\t}if (!rtv) dep[u]=0;return rtv;\n}inline int prt(void) {int cnt=n;\n\tfor (int i=1;i<n;++i) for (int j=last[i];j;j=e[j].next) {\n\t\tint ot=e[j].to;if (ot&&!e[j].rem) nxt[i]=ot-n;\n\t}while (!q.empty()) q.pop();q.push(n);\n\twhile (!q.empty()) {int cur=q.front();q.pop(),--cnt;\n\t\tfor (int i:bel[cur]) if (nxt[i])\n\t\t\tp[i]=make_pair(cur,nxt[i]),q.push(nxt[i]),nxt[i]=0;\n\t}return cnt;\n}int main() {int m,u,fl=0;scanf(\"%d\",&n),s=0,t=n<<1;\n\tfor (int i=1;i<n;++i) inse(s,i),inse(n+i,t);\n\tfor (int i=1;i<n;++i) {scanf(\"%d\",&m);\n\t\twhile (m--) {scanf(\"%d\",&u);\n\t\t\tif (u^n) inse(i,n+u);bel[u].push_back(i);\n\t\t}\n\t}while (bfs()) memcpy(lst,last,sizeof last),fl+=dfs(s,0x3f3f3f3f);\n\tif (fl^(n-1)) return 0*puts(\"-1\");if (prt()) return 0*puts(\"-1\");\n\tfor (int i=1;i<n;++i) printf(\"%d %d\\n\",p[i].first,p[i].second);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nconst int N=1e5+6,V=2e5+6;\nstruct edge{int v,c,nxt;}g[800003];\nint n,m,head[V],k,iter[V],S,T,d[V],q[V],l,r,f[N],x[N],vis[N];\nstd::vector<int>e[N];\ninline void Insert(int u,int v){\n\tg[k]=(edge){v,1,head[u]},head[u]=k++;\n\tg[k]=(edge){u,0,head[v]},head[v]=k++;\n}\ninline bool Bfs(){\n\tint u,v;\n\tfor(u=1;u<=T;u++)d[u]=0;\n\td[q[l=r=0]=S]=1;\n\tfor(;l<=r;){\n\t  u=q[l++];\n\t  for(int i=head[u];~i;i=g[i].nxt)if(g[i].c&&!d[v=g[i].v])\n\t\td[v]=d[u]+1,q[++r]=v;\n\t}return d[T];\n}\nint Dfs(int u,int f){\n\tif(!f||u==T)return f;\n\tint v,res=0,tmp;\n\tfor(int&i=iter[u];~i;i=g[i].nxt)\n\t  if(g[i].c&&d[v=g[i].v]>d[u]&&(tmp=Dfs(v,std::min(f,g[i].c)))){\n\t\tg[i].c-=tmp,g[i^1].c+=tmp;\n\t\tf-=tmp,res+=tmp;\n\t\tif(!f)return res;\n\t  }\n\treturn res;\n}\ninline int Maxflow(){\n\tint res=0;\n\tfor(;;){\n\t  if(!Bfs())return res;\n\t  for(int u=1;u<=T;u++)iter[u]=head[u];\n\t  res+=Dfs(S,n-1);\n\t}\n}\nvoid Ans(int u){\n\tvis[u]=1;\n\tfor(int i=0;i<e[u].size();i++)if(!vis[f[e[u][i]]])\n\t  x[e[u][i]]=u,Ans(f[e[u][i]]);\n}\nint main(){\n\tint u;\n\tscanf(\"%d\",&n);\n\tS=n+n-1,T=n+n;\n\tfor(u=1;u<=T;u++)head[u]=-1;\n\tfor(int i=1;i<n;i++){\n\t  scanf(\"%d\",&m);\n\t  for(;m--;){\n\t\tscanf(\"%d\",&u);\n\t\tif(u<n)Insert(u,i+n-1);\n\t\te[u].push_back(i);\n\t  }\n\t  Insert(i+n-1,T);\n\t}\n\tfor(u=1;u<n;u++)Insert(S,u);\n\tif(Maxflow()!=n-1)return 0*puts(\"-1\");\n\tfor(int u=1;u<n;u++)\n\t  for(int i=head[u];~i;i=g[i].nxt)if(!g[i].c)\n\t\tf[g[i].v-n+1]=u;\n\tAns(n);\n\tfor(int u=1;u<=n;u++)if(!vis[u])return 0*puts(\"-1\");\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",x[i],f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tputs(\"-1\"); return 0;\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    if(flow.used[i] == -1 || flow.used[p[i]] == -1) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1)/*,bel[x].push_back(i)*/;\n\t}Rep(i,1,n)add(i,T,1);\n\treturn 0;\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=400005;\nvector<int> bel[N];\nint cur[N],from[N],S,T,ne[N],a[N],b[N],dis[N],flag[N],x,y,n,m,fi[N],tot,zz[N],sl[N];\nqueue<int>Q;\nvoid jb(int x,int y,int z){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n\tsl[tot]=z;\n\tne[++tot]=fi[y];\n\tfi[y]=tot;\n\tzz[tot]=x;\n\tsl[tot]=0;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,-1,sizeof dis);\n\tdis[S]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]==-1){\n\t\t\t\tdis[zz[i]]=dis[now]+1;\n\t\t\t\tQ.push(zz[i]);\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&dis[zz[i]]==dis[x]+1&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\ty-=b;\n\t\t\ts+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=0;T=2*n;\n\ttot=1;\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tjb(S,i+n,1);\n\t\twhile (x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tjb(i+n,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)jb(i,T,1);\n\tint ans=0;\n\twhile (bfs()){\n\t\tfor (int i=S;i<=T;i++)cur[i]=fi[i];\n\t\tans+=dfs(S,1e9);\n\t}\n\tif (ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=fi[i+n];j;j=ne[j])\n\t\t\tif (zz[j]&&!sl[j]){\n\t\t\t\tflag[zz[j]]=1;\n\t\t\t\tb[i]=zz[j];\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])Q.push(i);\n\tans=0;\n\tmemset(flag,0,sizeof flag);\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tans++;\n\t\tfor (int i=0;i<bel[now].size();i++)\n\t\t\tif (!flag[bel[now][i]]){\n\t\t\t\tflag[bel[now][i]]=1;\n\t\t\t\ta[bel[now][i]]=now;\n\t\t\t\tQ.push(b[bel[now][i]]);\n\t\t\t}\n\t}\n\tif (ans!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nint read(){\n\tint g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nconst int INF=1e9;\nstruct Edge{\n\tint to,ne,c;\n}e[N<<4];\nstruct Line{\n\tint x,y;\n}line[N];\nint h[N<<1],cnt=1,dis[N<<1],n,S,T,id[N];\nvint G[N];\nvoid add(int x,int y,int c){\n\te[++cnt]=Edge{y,h[x],c};\n\th[x]=cnt;\n\te[++cnt]=Edge{x,h[y],0};\n\th[y]=cnt;\n}\nbool bfs(int S,int T){\n\tqueue<int>q;\n\tfor(int i=1;i<=T;i++)dis[i]=0;\n\tdis[S]=1;q.push(S);\n\twhile(q.size()){\n\t\tint x=q.front();q.pop();\n\t\tif(x==T)return true;\n\t\tfor(int i=h[x];i;i=e[i].ne){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]||!e[i].c)continue;\n\t\t\tdis[y]=dis[x]+1;\n\t\t\tq.push(y);\n\t\t}\n\t}return false;\n}\nint dfs(int x,int maxn,int T){\n\tif(x==T||!maxn)return maxn;\n\tint dt=0,re=0;\n\tfor(int i=h[x];i;i=e[i].ne){\n\t\tint y=e[i].to;\n\t\tif(dis[y]!=dis[x]+1||!e[i].c)continue;\n\t\tdt=dfs(y,min(maxn,e[i].c),T);\n\t\tif(!dt)dis[y]=0;\n\t\te[i].c-=dt,e[i^1].c+=dt;\n\t\tmaxn-=dt,re+=dt;\n\t\tif(!maxn)return re;\n\t}return re;\n}\nint dinic(int S,int T){\n\tint re=0;\n\twhile(bfs(S,T))re+=dfs(S,INF,T);\n\treturn re;\n}\nbool solve(){\n\tfor(int x=1;x<n;x++)for(int i=h[x];i;i=e[i].ne){\n\t\tint y=e[i].to;\n\t\tif(y==S||e[i].c)continue;\n\t\tid[x]=y-n+1;\n\t}int su=0;\n\tqueue<int>q;q.push(n);\n\twhile(q.size()){\n\t\tint x=q.front();\n\t\tsu++;q.pop();\n\t\tint siz=G[x].size();\n\t\tfor(int i=0;i<siz;i++){\n\t\t\tint t=G[x][i];\n\t\t\tif(id[t])line[t]=Line{x,id[t]},q.push(id[t]),id[t]=0;\n\t\t}\n\t}return su==n;\n}\nsigned main(){\n\tn=read(),S=(n<<1)-1,T=S+1;\n\tfor(int i=1;i<n;i++)add(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint nu=read();\n\t\tadd(S,i,1);\n\t\tfor(int j=1;j<=nu;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n)add(i,x+n-1,1);\n\t\t\tG[x].pb(i);\n\t\t}\n\t}\n\tif(dinic(S,T)!=n-1)return puts(\"-1\"),signed();\n\tif(!solve())return puts(\"-1\"),signed();\n\tfor(int i=1;i<n;i++)cout<<line[i].x<<' '<<line[i].y<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct edge\n{\n    int a, b, cap, ind;\n};\n\nconst int N = 4e5 + 7;\n\nvector <int> g[N];\nvector <edge> e;\n\nvoid add(int a, int b, int c, int ind)\n{\n    g[a].push_back(e.size());\n    e.push_back({a, b, c, ind});\n}\n\nvoid add_edge(int a, int b, int c, int ind)\n{\n    add(a, b, c, ind);\n    add(b, a, 0, -1);\n}\n\nint dist[N];\nint ptr[N];\n\nint s, t;\n\nint dfs(int v, int fl = 1e9)\n{\n    if (v == t)\n    {\n        return fl;\n    }\n    for (int &i = ptr[v]; i < (int) g[v].size(); i++)\n    {\n        int ind = g[v][i];\n        if (dist[e[ind].b] == dist[v] + 1 && e[ind].cap > 0)\n        {\n            int go = dfs(e[ind].b, min(fl, e[ind].cap));\n            if (go)\n            {\n                e[ind].cap -= go;\n                e[ind ^ 1].cap += go;\n                return go;\n            }\n        }\n    }\n    return 0;\n}\n\nbool bfs()\n{\n    for (int i = 0; i <= t; i++)\n    {\n        dist[i] = -1;\n        ptr[i] = 0;\n    }\n    queue <int> q;\n    q.push(s);\n    dist[s] = 0;\n    while (!q.empty())\n    {\n        int v = q.front();\n        q.pop();\n        for (int ind : g[v])\n        {\n            if (e[ind].cap > 0 && dist[e[ind].b] == -1)\n            {\n                dist[e[ind].b] = dist[v] + 1;\n                q.push(e[ind].b);\n            }\n        }\n    }\n    return dist[t] != -1;\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    s = n + n;\n    t = n + n + 1;\n    int edg = 0;\n    vector <vector <int> > g(n);\n    vector <vector <int> > gr(n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        add_edge(s, i, 1, -1);\n        int e;\n        cin >> e;\n        while (e--)\n        {\n            int v;\n            cin >> v;\n            v--;\n            g[i].push_back(v);\n            gr[v].push_back(i);\n            add_edge(i, n - 1 + v, 1, edg++);\n        }\n    }\n    for (int i = 0; i < n; i++) add_edge(n - 1 +  i, t, 1, -1);\n    int ans = 0;\n    while (bfs())\n    {\n        while (int x = dfs(s, 1e9))\n        {\n            ans += x;\n        }\n    }\n    if (ans != n - 1)\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    vector <int> mt(n - 1, -1);\n    vector <int> rmt(n, -1);\n    vector <int> op(n - 1, -1);\n    for (auto c : e)\n    {\n        if (c.ind != -1 && c.cap == 0)\n        {\n            int a = c.a, b = c.b - (n - 1);\n            mt[a] = b;\n            rmt[b] = a;\n        }\n    }\n    set <int> q;\n    for (int i = 0; i < n; i++) if (rmt[i] == -1) q.insert(i);\n    set <int> t;\n    for (int i = 0; i < n - 1; i++) t.insert(i);\n    while (!q.empty())\n    {\n        int who = *q.begin();\n        q.erase(who);\n        vector <int> del;\n        for (int ok : gr[who])\n        {\n            if (t.count(ok))\n            {\n                q.insert(mt[ok]);\n                op[ok] = who;\n                del.push_back(ok);\n            }\n        }\n        for (int x : del) t.erase(x);\n    }\n    if (*min_element(op.begin(), op.end()) == -1)\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        cout << mt[i] + 1 << ' ' << op[i] + 1 << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=100005;\nstruct edge\n{\n\tint to,nxt;\n}e[N]; int n,x,y,cnt,head[N],frm[N],tim[N],pre[N],q[N];\ninline void addedge(CI x,CI y)\n{\n\te[++cnt]=(edge){y,head[x]}; head[x]=cnt;\n}\n#define to e[i].to\ninline bool find(CI now,CI t)\n{\n\tfor (RI i=head[now];i;i=e[i].nxt) if (tim[to]!=t)\n\tif (tim[to]=t,!frm[to]||find(frm[to],t)) return frm[to]=now,1; return 0;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),i=1;i<n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=x;++j) scanf(\"%d\",&y),addedge(y,i);\n\tfor (i=2;i<=n;++i) if (!find(i,i)) return puts(\"-1\"),0;\n\tRI H=0,T=1; q[1]=1; while (H<T)\n\t{\n\t\tint now=q[++H]; for (i=head[now];i;i=e[i].nxt)\n\t\tif (!pre[to]) pre[to]=now,q[++T]=frm[to];\n\t}\n\tif (T!=n) return puts(\"-1\"),0;\n\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",pre[i],frm[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define N 500001\nusing namespace std;\nint n,du[N];\nvector<int>point[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tpoint[i].resize(p+1);\n\t\tpoint[i][0]=p;\n\t\tfor (int j=1;j<=p;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpoint[i][j]=x;\n\t\t\tdu[x]++;\n\t\t}\n\t}\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint times=0;\n\t\tfor (int j=1;j<=point[i][0];j++)\n\t\t{\n\t\t\tif (du[point[i][j]]==1) times++;\n\t\t}\n\t\tif (times>1)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (du[i]==0){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\n\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] == d[to[i]] + 1 && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\tcur[x] = fi[x];\n\tif(!(-- co[d[x]])) d[S] = T;\n\t++ co[++ d[x]];\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\tco[0] = T; while(d[S] < T) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nset<int> E[N],app[N];\nint A[N],B[N];\nset<pii> s;\nint n,c,w;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tread(c);\n\t\trep(j,1,c){\n\t\t\tread(w);\n\t\t\tE[i].insert(w);\n\t\t\tapp[w].insert(i);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts.insert(mp(app[i].size(),i));\n\t}\n\twhile(s.size()>=2){\n\t\tint x=s.begin()->se;\n\t\ts.erase(s.begin());\n\t\tif(!app[x].size())GG();\n\t\tint k=*app[x].begin();\n\t\tfor(auto t:app[x])\n\t\t\tif(E[t].size()<E[k].size())k=t;\n\t\tif(E[k].size()<app[x].size())GG();\n\t\tif(E[k].size()<2)GG();\n\t\tint U=*E[k].begin();\n\t\tint V=*(--E[k].end());\n\t\tif(x==U)A[k]=x,B[k]=V;\n\t\telse A[k]=x,B[k]=U;\n\t\tE[k].erase(x);\n\t\tapp[x].erase(k);\n\t\tfor(auto y:E[k]){\n\t\t\ts.erase(mp(app[y].size(),y));\n\t\t\tapp[y].erase(k);\n\t\t\ts.insert(mp(app[y].size(),y));\n\t\t}\n\t\tfor(auto t:app[x])\n\t\t\tE[t].erase(x);\n\t}\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",A[i],B[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--, q[a[i][j]].insert(i);\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.FF(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n2020.03.15\n\n钦定根节点，然后把剩下的点和集合做一个匹配，\n也就是在在每个集合选一个代表点，然后要求代表点两两不同。\n构造方案时只需要从根开始 bfs 加边，每次从当前节点中选一个未考虑过的集合，\n并对该集合的关键点连边。\n#endif\n#include <cstdio>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nint head[maxn << 1], nxt[maxn << 3], to[maxn << 3], cap[maxn << 3], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f;\n\t\twhile((f = dinic(s, t)))\n\t\t\tflow += f;\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[to[i] - n] = u;\n\t\t\t\tansy[to[i] - n] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back(make_tuple(x,i,mxfl::adde(x,i+n,1)));\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=2*::Maxn,Maxm=4*::Maxn;\n\tint S,T,cnt,h[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs())ans+=dfs(S,INT_MAX);\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 222222\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint E = MAX_V / 2;\nint s = MAX_V - 2;\nint g = MAX_V - 1;\nint mp[MAX_V/2];\nint rmp[MAX_V/2];\nbool used[MAX_V/2];\nbool visited[MAX_V/2];\n\nvector<vector<int>> v(MAX_V / 2);\nvector<vector<int>> nv(MAX_V / 2);\nvector<pair<int,pair<int,int>>> ans;\n\nvoid dfs(int num){\n\tvisited[num] = true;\n\tREP(i,nv[num].size()){\n\t\tif(!visited[nv[num][i]]){\n\t\t\tans.PB(MP(rmp[nv[num][i]], MP(num, nv[num][i])));\n\t\t\tdfs(nv[num][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tREP(i,n) {\n\t\tif(i != n -1)add_edge(s,i,1);\n\t\tadd_edge(E+i,g,1);\n\t}\n\t\t\n\tREP(i,n-1){\n\t\t\n\t\tint e;cin >> e;\n\t\tREP(j,e){\n\t\t\tint tmp;cin >> tmp;tmp--;\n\t\t\tv[i].EB(tmp);\n\t\t\tadd_edge(i, E+tmp, 1);\n\t\t}\n\t}\n\t\n\tint seica = Dinic(s, g);\n\t//cout << \"seica is \" << seica << endl;\n\tif(seica != n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,n-1) {\n\t\tREP(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0){\n\t\t\t\tmp[i] = G[i][j].to - E;\n\t\t\t\trmp[mp[i]] = i;\n\t\t\t\tused[mp[i]] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n-1){\n\t\tREP(j,v[i].size()){\n\t\t\tif(v[i][j] != mp[i])nv[v[i][j]].EB(mp[i]);\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(!used[i])dfs(i);\n\t}\n\t\n\t//cout << \"ans is \" << ans.size() << endl;\n\t//SHOW1d(used,n);\n\t//SHOW1d(mp,n);\n\t//SHOW1d(rmp,n);\n\tif(ans.size() == n-1){\n\t\tsort(ALL(ans));\n\t\tREP(i,ans.size()){\n\t\t\tcout << ans[i].SE.FI + 1 << \" \" << ans[i].SE.SE + 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nvector<int>rev[110000];\nint ans[110000];\nint fr[110000];\nint t[210000];\nint n;\nvoid dfs(int a){\n\tt[a]=1;\n\tif(a<n-1){\n\t\tfor(int i=0;i<v[a].size();i++){\n\t\t\tint to=v[a][i]+n-1;\n\t\t\tif(t[to])continue;\n\t\t\tdfs(to);\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<rev[a-n+1].size();i++){\n\t\t\tint to=rev[a-n+1][i];\n\t\t\tif(t[to])continue;\n\t\t\tfr[to]=a-n+1;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t\trev[c].push_back(i);\n\t\t}\n\t}\n\tdfs(a);\n\tfor(int i=0;i<a-1;i++){\n\t\t// std::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tif(fr[i]==v[i][j])continue;\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\tans[i]=to-(a-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",fr[i]+1,ans[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nbool vis[MAXN];\nint n, f[MAXN], size[MAXN]; vector <int> a[MAXN];\nset <int> b[MAXN]; set <pair <int, int>> st;\npair <int, int> ans[MAXN];\nint find(int x) {\n\tif (f[x] == x) return x;\n\telse return f[x] = find(f[x]);\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint k; read(k); size[i] = k;\n\t\tst.insert(make_pair(k, i));\n\t\twhile (k--) {\n\t\t\tint x; read(x);\n\t\t\ta[i].push_back(x);\n\t\t\tb[x].insert(i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = i;\n\twhile (!st.empty()) {\n\t\tif ((*st.begin()).first == 1) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint tmp = (*st.begin()).second, tx = 0, ty = 0;\n\t\tvis[tmp] = true, st.erase(st.begin());\n\t\tfor (auto x : a[tmp])\n\t\t\tif (find(x) != find(a[tmp][0])) {\n\t\t\t\ttx = x, ty = a[tmp][0];\n\t\t\t\tans[tmp] = make_pair(tx, ty);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x = find(tx), y = find(ty);\n\t\tif (b[x].size() < b[y].size()) swap(x, y); f[y] = x;\n\t\tfor (auto v : b[y]) {\n\t\t\tif (b[x].count(v)) {\n\t\t\t\tif (!vis[v]) {\n\t\t\t\t\tst.erase(make_pair(size[v], v));\n\t\t\t\t\tst.insert(make_pair(--size[v], v));\n\t\t\t\t}\n\t\t\t} else b[x].insert(v);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\nint n,S,T;\nint fa[N],match[N];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\tscanf(\"%d\",&m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\tscanf(\"%d\",&k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tgap[0]=T;\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,2,n){\n\t\tprintf(\"%d %d\\n\",fa[i],i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[orig[1]]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\tfor(auto t : occ[orig[0]]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\n\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] == d[to[i]] + 1 && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\tcur[x] = fi[x];\n\tif(!(-- co[d[x]])) d[S] = T;\n\t++ co[++ d[x]];\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\trandom_shuffle(e[i].begin(), e[i].end());\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\tco[0] = T; while(d[S] < T) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\ntypedef unsigned long long lu;\ntypedef long long li;\ntypedef pair<int, int> pii;\nconst int mod = 1e9 + 7;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x = Sub(x - y); }\ninline int Mul(int x, int y) { return (int)((lu)x * y % mod); }\ninline int Mul(int x, int y, int z) { return (int)((lu)x * y % mod * z % mod); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) { return Pow(x, mod - 2); }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\n\n// ----------------------------------------\n\nnamespace dinic {\n  const int maxn = 1e5, maxm = 1e6;\n  typedef int FlowType;\n  const FlowType inf_f = ~0U >> 1;\n\n  void Init(int n);\n  void AddEdge(int u, int v, FlowType cap, li id);\n  FlowType Solve(int s, int t);\n  vector< pair<li, FlowType> > Result(void);\n}\n\nnamespace dinic {\n  struct Edge {\n    int v;\n    li id;\n    FlowType cap, cap0;\n  } edge[maxm << 1];\n\n  int n, m, s, t;\n  vector<int> g[maxn];\n\n  void Init(int _n) {\n    n = _n, m = 0;\n    for (int i = 0; i < n; ++i) g[i].clear();\n  }\n\n  void AddEdge(int u, int v, FlowType c, li id = -1) {\n    g[u].push_back(m);\n    edge[m++] = (Edge){v, id, c, c};\n    g[v].push_back(m);\n    edge[m++] = (Edge){u, id, 0, 0};\n  }\n\n  int iter[maxn], dist[maxn];\n\n  bool Bfs(void) {\n    queue<int> que;\n    que.push(s);\n    FILL(dist, n, -1);\n    dist[s] = 0;\n    while (!que.empty()) {\n      int u = que.front(); que.pop();\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap && dist[e.v] == -1) {\n          dist[e.v] = dist[u] + 1;\n          que.push(e.v);\n        }\n      }\n    }\n    return dist[t] >= 0;\n  }\n\n  FlowType Dfs(int u, FlowType f) {\n    if (u == t) return f;\n    FlowType sum = 0;\n    for (int &i = iter[u]; i < g[u].size(); ++i) {\n      Edge &e = edge[g[u][i]], &rev = edge[g[u][i] ^ 1];\n      if (e.cap && dist[e.v] == dist[u] + 1) {\n        FlowType res = Dfs(e.v, min(f - sum, e.cap));\n        e.cap -= res;\n        rev.cap += res;\n        if ((sum += res) == f) break;\n      }\n    }\n    return sum;\n  }\n\n  FlowType Solve(int _s, int _t) {\n    s = _s, t = _t;\n    FlowType ans = 0;\n    while (Bfs()) {\n      FILL(iter, n, 0);\n      ans += Dfs(s, inf_f);\n    }\n    return ans;\n  }\n\n  vector< pair<li, FlowType> > Result(void) {\n    vector< pair<li, FlowType> > ans;\n    for (int u = 0; u < n; ++u) {\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap < e.cap0 && e.id != -1) {\n          ans.push_back(make_pair(e.id, e.cap0 - e.cap));\n        }\n      }\n    }\n    return ans;\n  }\n}\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\nint n;\nvector<int> E[maxn];\nvector<int> F[maxn];\n\nint match[maxn], par[maxn];\nint A[maxn], B[maxn];\n\nvoid NoSolution(void) {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    while (c--) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      E[i].push_back(x);\n      F[x].push_back(i);\n    }\n  }\n\n  // root = 0\n  int L = 0, R = n, S = R + n - 1, T = S + 1, N = T + 1;\n  dinic::Init(N);\n  for (int i = 1; i < n; ++i) {\n    dinic::AddEdge(S, L + i, 1, -1);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    dinic::AddEdge(R + i, T, 1, -1);\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j : F[i]) {\n      dinic::AddEdge(L + i, R + j, 1, (li)i * n + j);\n    }\n  }\n  int flow = dinic::Solve(S, T);\n  if (flow < n - 1) NoSolution();\n\n  vector< pair<li, int> > way = dinic::Result();\n  for (pair<li, int> p : way) {\n    int x = (int)(p.first / n), y = (int)(p.first % n);\n    match[y] = x;\n  }\n\n  queue<int> que;\n  que.push(0);\n  FILL(par, n, -1);\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (int j : F[u]) {\n      int i = match[j];\n      if (par[i] == -1) {\n        par[i] = u;\n        A[j] = i;\n        B[j] = u;\n        que.push(i);\n      }\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    if (par[i] == -1) NoSolution();\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    printf(\"%d %d\\n\", A[i] + 1, B[i] + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nconst int N=500010;\nint n,m,i,j,k,ans[N][2],d[N],head,tail,cnt,x,fa[N];\nvector<int> a[N];\nset<int> b[N],c,e[N];\nbool ok[N];\nint find(int x){\n\tif (x==fa[x]) return x; else {fa[x]=find(fa[x]);return fa[x];}\n}\nvoid pp(int x,int y){\n\tint i=find(x),j=find(y);fa[i]=j;\n}\nvoid doit(int x){ans[++cnt][0]=x;ok[x]=true;set<int>::iterator it=b[x].begin();c.erase(x);\n\tfor (int i=0;i<a[*it].size();i++) if (find(a[*it][i])!=find(x)){ans[cnt][1]=a[*it][i];break;}int xx=*it;\n\tfor (int i=0;i<a[xx].size();i++){b[a[xx][i]].erase(xx);\n\tif (b[a[xx][i]].size()==1&&!ok[a[xx][i]]) d[++tail]=a[xx][i],\n\tc.erase(a[xx][i]);}pp(ans[cnt][0],ans[cnt][1]);\n}\nint main(){\n\tscanf(\"%d\",&n);for (i=1;i<=n-1;i++){scanf(\"%d\",&m);for (j=1;j<=m;j++) scanf(\"%d\",&x),a[i].push_back(x),b[x].insert(i);}\n\tfor (i=1;i<=n;i++) c.insert(i);for (i=1;i<=n;i++) fa[i]=i;\n\thead=1;tail=0;for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) d[++tail]=i,c.erase(i);\n\t//for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) doit(i);\n\twhile (cnt!=n-1){\n\t\twhile (head<=tail&&cnt!=n-1){\n\t\t\tx=d[head];if (b[x].size()==0){printf(\"-1\\n\");return 0;} else doit(x);head++;\n\t\t}\n\t\tif (cnt!=n-1) doit(*c.begin());\n\t}for (i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans[i][0],ans[i][1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\n\nstruct UnionFind // UnionFind Tree (0-indexed)\n{\n    vector<int> par, rank;\n    UnionFind(int N) : par(N), rank(N) { REP(i, N) par[i] = i; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (rank[x] < rank[y]) par[x] = y; else par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    vector<set<int>> ves(N);\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        for (auto v : w) ves[i].insert(v);\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        UnionFind uf(N + 1);\n        for (auto pa : ans) uf.unite(pa.first, pa.second);\n        REP(i, N) if (!uf.same(1, i + 1)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].first)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].second)) exit(1);\n\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size();i<len;i++)if(!vis2[bel[x][i]]){\n\t\t\tvis2[bel[x][i]]=1,nxt[bel[x][i]]=x,q.push(id[bel[x][i]]);\n\t\t}\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    ////////\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\twhile(d[s]<t+2)copy(fr+1,fr+t+1,cur+1),res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tclr(vis),flow+=dfs(S,INF);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nvector<int> hv[200005];\nstruct edge\n{\n\tint to, cap, rev;\n}E[400005];\nvector<int> G[200005];\n\nvoid add_edge(int u, int v, int c)\n{\n\tE[m].to = v;\n\tE[m].cap = c;\n\tE[m].rev = m ^ 1;\n\tG[u].push_back(m ++);\n\tE[m].to = u;\n\tE[m].cap = 0;\n\tE[m].rev = m ^ 1;\n\tG[v].push_back(m ++);\n}\n\nint dis[200005], cur[200005];\nbool bfs()\n{\n\trep1(i, 2 * n) dis[i] = -1;\n\tqueue<int> que;\n\tque.push(0);\n\tdis[0] = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i, G[v].size()) {\n\t\t\tint ce = G[v][i];\n\t\t\tif(E[ce].cap > 0 && dis[E[ce].to] == -1) {\n\t\t\t\tque.push(E[ce].to);\n\t\t\t\tdis[E[ce].to] = dis[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2 * n] == -1) return false;\n\trep(i, 2 * n + 1) cur[i] = 0;\n\treturn true;\n}\n\nint dfs(int v, int maxf)\n{\n\tif(v == 2 * n) return maxf;\n\tif(maxf == 0) return 0;\n\tint ret = 0;\n\tfor(; cur[v] < G[v].size(); cur[v] ++) {\n\t\tint ce = G[v][cur[v]];\n\t\tif(dis[E[ce].to] == dis[v] + 1 && E[ce].cap > 0) {\n\t\t\tint cf = dfs(E[ce].to, min(maxf - ret, E[ce].cap));\n\t\t\tE[ce].cap -= cf;\n\t\t\tE[E[ce].rev].cap += cf;\n\t\t\tret += cf;\n\t\t\tif(ret == maxf) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint lp[200005], par[200005];\n\nint dinic()\n{\n\tint ret = 0;\n\twhile(bfs()) ret += dfs(0, INF);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n - 1) {\n\t\tint cs;\n\t\tscanf(\"%d\", &cs);\n\t\thv[i].resize(cs);\n\t\trep(j, cs) {\n\t\t\tscanf(\"%d\", &hv[i][j]);\n\t\t\tadd_edge(hv[i][j], i + n, 1);\n\t\t}\n\t\tadd_edge(i + n, n * 2, 1);\n\t}\n\trep1(i, n) add_edge(0, i, 1);\n\tif(dinic() != n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\trep1(i, n) if(dis[i] == -1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\t\n\trep1(i, 2 * n - 1) rep(j, G[i].size()) {\n\t\tint ce = G[i][j];\n\t\tif(E[ce].cap == 0 && dis[E[ce].to] == dis[i] - 1) {\n\t\t\tpar[i] = E[ce].to;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\trep1(i, n) if(par[i] != 0) lp[par[i] - n] = i;\n\trep1(i, n - 1) printf(\"%d %d\\n\", par[i + n], lp[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, M = 8e5 + 5;\n\nstruct edge_t { int u, v, next, cap, flow; } G[M];\n\nvector <int> adj[N];\nqueue <int> q;\nint head[N], nowhead[N], d[N];\nint n, m, s, t, tot = 1;\n\ninline void addedge(int u, int v, int cap) {\n\tG[++tot] = (edge_t) {u, v, head[u], cap, 0}, head[u] = tot;\n\tG[++tot] = (edge_t) {v, u, head[v], 0, 0}, head[v] = tot;\n}\n\nint bfs() {\n\tmemset(d, 0, sizeof(d));\n\td[s] = 1; q.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (!d[v] && G[i].cap > G[i].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\n\nint dfs(int u, int Flow) {\n\tif (u == t || !Flow) return Flow;\n\tint f, flow = 0;\n\tfor (int &i = nowhead[u]; i; i = G[i].next) {\n\t\tint v = G[i].v;\n\t\tif (d[v] == d[u] + 1 && (f = dfs(v, min(Flow, G[i].cap - G[i].flow))) > 0) {\n\t\t\tG[i].flow += f; G[i ^ 1].flow -= f;\n\t\t\tflow += f; Flow -= f;\n\t\t\tif (!Flow) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint dinic() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemcpy(nowhead, head, sizeof(nowhead));\n\t\tans += dfs(s, 0x7fffffff);\n\t}\n\treturn ans;\n}\n\nint fa[N], vis[N], match[N], cnt;\n\nint main() {\n\tread(n); s = 0; t = 2 * n;\n\tfor (int i = 1; i < n; i++) {\n\t\tread(m);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x; read(x);\n\t\t\tadj[i].push_back(x + n - 1);\n\t\t\tadj[x + n - 1].push_back(i);\n\t\t\taddedge(i, x + n - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) addedge(s, i, 1);\n\tfor (int i = n; i < 2 * n; i++) addedge(i, t, 1);\n\tif (dinic() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint rt = 0;\n\tfor (int i = head[n * 2]; i; i = G[i].next) {\n\t\tif (G[i].flow == 0) {\n\t\t\trt = G[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int u = 1; u < n; u++) {\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (n <= v && v < n * 2 && G[i].flow) match[u] = v;\n\t\t}\n\t}\n\tq.push(rt); vis[rt] = 1;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (auto v : adj[u]) {\n\t\t\tif (!vis[match[v]]) {\n\t\t\t\tvis[match[v]] = 1;\n\t\t\t\tfa[match[v]] = u;\n\t\t\t\t++cnt;\n\t\t\t\tq.push(match[v]);\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = n; i < 2 * n; i++) {\n\t\tif (fa[i]) {\n\t\t\tprint(fa[i] - n + 1, ' ');\n\t\t\tprint(i - n + 1, '\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2+N*4];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N*2],BZ,dis[N*2];\nEDGE *cur[N*2];\n#define rev(ei) (e+(int((ei)-e)^1))\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]+1==dis[x]){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\tif (!--gap[dis[x]])\n\t\tBZ=0;\n\t++dis[x];\n\t++gap[dis[x]];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (BZ)\n\t\tr+=dfs(S,INF);\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nconst int N = 100179;\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es(n - 1);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es[s] = {v, nv};\n            ++cnt;\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (cnt != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi E[N],e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\tE[i].pb(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\");\n\trep(i,1,n-1)\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<int> a(2 * N + 2);\n\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf < N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\n\nbool bfs(){\n\tfo(i,1,ed)dis[i]=-1;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (dis[e[p].x]==-1&&e[p].f){\n\t\t\tdis[e[p].x]=dis[x]+1;\n\t\t\tque[++ta]=e[p].x;\n\t\t}\n\t}\n\treturn dis[ed]!=-1;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs())ret+=aug(st,INF);\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\tscanf(\"%d\",&m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\tscanf(\"%d\",&k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tgap[0]=T;\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\tconst int N = 2e5 + 5, INF = 0x3f3f3f3f;\n\n\tint n, s, t, Head[N], dep[N], cur[N], mat[N], from[N];\n\tstruct edge { int to, next, w; } E[N << 2];\n\tvector<int> Bel[N >> 1]; \n\n\tinline void add(const int u, const int v)\n\t{\n\t\tstatic int ec = 1;\n\t\tE[++ec] = (edge){v, Head[u], 1};\n\t\tHead[u] = ec;\n\t\tE[++ec] = (edge){u, Head[v], 0};\n\t\tHead[v] = ec;\n\t}\n\n\tbool bfs()\n\t{\n\t\tmemcpy(cur, Head, sizeof(int[t + 1]));\n\t\tmemset(dep, 0, sizeof(int[t + 1]));\n\t\tstatic queue<int> q;\n\t\tq.push(s);\n\t\tdep[s] = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = Head[u], v; i; i = E[i].next)\n\t\t\t\tif (E[i].w && !dep[v = E[i].to])\n\t\t\t\t\tdep[v] = dep[u] + 1, q.push(v);\n\t\t}\n\t\treturn dep[t];\n\t}\n\n\tint dfs(const int u, const int mn)\n\t{\n\t\tif (u == t || !mn)\n\t\t\treturn mn;\n\t\tint v, w, used = 0;\n\t\tfor (int &i = cur[u]; i; i = E[i].next)\n\t\t\tif (E[i].w && dep[v = E[i].to] == dep[u] + 1)\n\t\t\t{\n\t\t\t\tw = dfs(v, min(mn - used, E[i].w));\n\t\t\t\tused += w;\n\t\t\t\tE[i].w -= w;\n\t\t\t\tE[i ^ 1].w += w;\n\t\t\t\tif (used == mn)\n\t\t\t\t\treturn used;\n\t\t\t}\n\t\tif (!used)\n\t\t\tdep[u] = -1;\n\t\treturn used;\n\t}\n\n\tint Dinic()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t\tans += dfs(s, INF);\n\t\treturn ans;\n\t}\n\n\tbool search()\n\t{\n\t\tstatic queue<int> q;\n\t\tq.push(n);\n\t\tint cnt = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(), p;\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\tfor (int i : Bel[x])\n\t\t\t\tif (!from[p = mat[i]])\n\t\t\t\t\tfrom[p] = x, q.push(p);\n\t\t}\n\t\treturn cnt == n;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1, c, j; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &j);\n\t\t\t\tif (j != n)\n\t\t\t\t\tadd(j, i + n);\n\t\t\t\tBel[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\ts = n + n, t = s + 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tadd(s, i), add(i + n, t);\n\t\tint flow = Dinic();\n\t\tif (flow != n - 1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor (int u = 1; u < n; u++)\n\t\t\t\tfor (int i = Head[u + n]; i; i = E[i].next)\n\t\t\t\t\tif (E[i].w && E[i].to <= n)\n\t\t\t\t\t{\n\t\t\t\t\t\tmat[u] = E[i].to;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!search())\n\t\t\t\tputs(\"-1\");\n\t\t\telse\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tprintf(\"%d %d\\n\", i, from[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //不能直接判f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(val[i]*e[i][j-1]>=mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,inf=1e9;\nint n,c,p[N],q[N],id[N],x;vector<int> a[N];\nstruct edge{int u,v,c,f;};\nstruct Dinic{\n    vector<edge> e;\n    vector<int> G[N];queue<int> q;\n    int cur[N],d[N],n,m,s,t,ma[N],cnt,p[N],_n;bool vis[N];\n    inline void add(int u,int v,int c){\n        //printf(\"%d %d %d\\n\",u,v,c);\n        e.pb((edge){u,v,c,0});e.pb((edge){v,u,0,0});\n        m=e.size();G[u].pb(m-2);G[v].pb(m-1);\n    }\n    bool bfs(){\n        memset(d,0,sizeof(d));memset(vis,0,sizeof(vis));vis[s]=1;q.push(s);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int &x:G[u]){\n                edge &E=e[x];\n                if(E.c>E.f&&!vis[E.v]) d[E.v]=d[u]+1,vis[E.v]=1,q.push(E.v);\n            }\n        }\n        return vis[t];\n    }\n    int dfs(int u,int a){\n        if(u==t||!a) return a;\n        int flow=0,f;\n        for(int &i=cur[u];i<(int)G[u].size();++i){\n            edge &E=e[G[u][i]];\n            if(d[E.v]==d[u]+1&&(f=dfs(E.v,min(a,E.c-E.f)))){\n                E.f+=f;e[G[u][i]^1].f-=f;\n                flow+=f;a-=f;if(!a) break;\n            }\n        }\n        return flow;\n    }\n    int max_flow(int s,int t){\n        this->s=s;this->t=t;\n        int flow=0;\n        while(bfs()){memset(cur,0,sizeof(cur));flow+=dfs(s,inf);}\n        return flow;\n    }\n    void DFS(int u){\n        ++cnt;vis[u]=1;\n        for(int &x:G[u]){\n            edge &E=e[x];\n            if(E.v!=t&&!vis[ma[E.v]]) p[ma[E.v]-_n]=u-_n,DFS(ma[E.v]);\n        }\n    }\n    void solve(int n){\n        memset(vis,0,sizeof(vis));_n=n;\n        rep(i,2,n){\n            for(int &x:G[i]){\n                edge &E=e[x];\n                if(E.v!=s&&E.f) ma[i]=E.v;\n            }\n        }\n        DFS(n+n);\n        if(cnt!=n) puts(\"-1\");\n        else rep(i,1,n-1) printf(\"%d %d\\n\",i,p[i]);\n    }\n}G;\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);int S=1,T=2*n+1;G.n=T;\n    rep(i,1,n-1) G.add(1,i+1,1);\n    rep(i,1,n-1){\n        scanf(\"%d\",&c);\n        rep(j,0,c-1) scanf(\"%d\",&x),G.add(i+1,x+n,1);\n    }\n    rep(i,1,n-1) G.add(i+n,T,1);\n    int t=G.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    G.solve(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i&&flow;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, M = 200005, inf = 0x3f3f3f3f;\nint n, p[N], fa[N];\nvector<int> E[N], F[N];\n\nnamespace flow {\n\tconst int V = 2 * N, E = 2 * M;\n\tint ans, S, T, tot = 1, nxt[E], fst[V], to[E], f[E], cur[V], d[V];\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; f[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; f[tot] = 0;\n\t}\n\tbool bfs() {\n\t\tstatic int q[E];\n\t\tint st = 0, ed = 0;\n\t\tq[ed++] = S;\n\t\tfor (int i = 1; i <= T; i++) d[i] = -1, cur[i] = fst[i];\n\t\td[S] = 0;\n\t\twhile (st < ed) {\n\t\t\tint u = q[st++];\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (f[i] && d[to[i]] == -1) {\n\t\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\t\tif (to[i] == T) return true;\n\t\t\t\t\tq[ed++] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint aug(int u, int flow) {\n\t\tif (u == T || !flow) return flow;\n\t\tint used = 0;\n\t\tfor (int &i = cur[u], w; i; i = nxt[i])\n\t\t\tif (d[to[i]] == d[u] + 1 && (w = aug(to[i], min(f[i], flow - used)))) {\n\t\t\t\tf[i] -= w, f[i ^ 1] += w;\n\t\t\t\tif ((used += w) == flow) break;\n\t\t\t}\n\t\tif (!used) d[u] = -1;\n\t\treturn used;\n\t}\n\tint dinic() {\n\t\twhile (bfs()) ans += aug(S, inf);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs(int u) {\n\tfor (int v : F[u])\n\t\tif (!fa[p[v]]) {\n\t\t\tfa[p[v]] = u;\n\t\t\tdfs(p[v]);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tflow::S = 2 * (n - 1) + 1, flow::T = 2 * (n - 1) + 2;\n\tfor (int i = 1, k; i < n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tE[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tscanf(\"%d\", &E[i][j]);\n\t\t\tif (E[i][j] != n)\n\t\t\t\tflow::addedge(E[i][j], n - 1 + i, 1);\n\t\t\tF[E[i][j]].push_back(i);\n\t\t}\n\t\tflow::addedge(flow::S, i, 1);\n\t\tflow::addedge(n - 1 + i, flow::T, 1);\n\t}\n\tint x = flow::dinic();\n\tif (x != n - 1) return !puts(\"-1\");\n\tfor (int i = 2; i <= flow::tot; i += 2)\n\t\tif (!flow::f[i] && flow::to[i] != flow::T && flow::to[i ^ 1] != flow::S)\n\t\t\tp[flow::to[i] - n + 1] = flow::to[i ^ 1];\n\tfa[n] = -1, dfs(n);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!fa[i]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x){\n\t\tif (x==T)\n\t\t\treturn 1;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tif (dfs(y)){\n\t\t\t\t\te[i].cap^=1,e[i^1].cap^=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tclr(vis),flow+=dfs(S);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define PRINT(x...) TRACE(printf(x))\n#define WATCHR(a, b) TRACE(for (auto c=a; c!=b;) cout << *(c++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define FU(i, a, b) for (auto i = a; i < b; ++i)\n#define fu(i, b) FU(i, 0, b)\n#define FD(i, a, b) for (auto i = (b) - 1; i >= a; --i)\n#define fd(i, b) FD(i, 0, b)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nll mod(ll a, ll b) {\n  return ((a%b)+b)%b;\n}\n\nint cmp(double x, double y = 0, double tol = 1.e-7) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\nstruct graph {\n  vi dest;  // use sz(dest) as number of arcs\n  vvi adj;  // use sz(adj) as number of vertices\n  int inv(int a) { return a ^ 0x1; }\n  graph(int n = 0) {\n    adj.resize(n);\n  }\n  // Adds an arc to the graph. u is capacity, c is cost.\n  // u is only needed on flows, and c only on min-cost-flow\n  int arc(int i, int j, ll u = 1) {\n    dest.pb(j);\n    adj[i].pb(sz(dest)-1);\n    dest.pb(i);\n    adj[j].pb(sz(dest)-1);\n    cap.pb(u); // For both flows\n    cap.pb(0);\n    return sz(dest)-2;\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  // For both flows!!\n  //\n\n  vll cap, flow;\n\n  int orig(int a) { return dest[inv(a)]; }\n  ll capres(int a) { return cap[a] - flow[a]; }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Max Flow! - Dinic O(n^2 * m)\n  // don't call maxflow with ini == end\n  //\n\n  vi curAdj, d;\n\n  bool MFbfs(int s, int t) {\n    d.assign(sz(adj), INT_MAX/2);\n    curAdj = vi(sz(adj));\n    d[s] = 0;\n    queue<int> Q; Q.push(s);\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (auto i : adj[u]) {\n        int v = dest[i];\n        if (capres(i) > 0 && d[v] == INT_MAX/2) {\n          d[v] = d[u] + 1; Q.push(v);\n        }\n      }\n    }\n    return d[t] != INT_MAX/2;\n  }\n\n  ll MFdfs(int u, int t, ll f) {\n    if (u == t) return f;\n    for(int &i = curAdj[u]; i < adj[u].size(); ++i) {\n      int ar = adj[u][i], v = dest[ar];\n      if (d[v] != d[u]+1 || capres(ar) == 0) continue;\n      ll tmpF = MFdfs(v, t, min(f, capres(ar)));\n      if (tmpF) {\n        flow[ar] += tmpF;\n        flow[inv(ar)] -= tmpF;\n        return tmpF;\n      }\n    }\n    return 0;\n  }\n\n  ll maxflow(int ini, int end) {\n    flow.assign(sz(dest), 0);\n    while (MFbfs(ini, end))\n      while (MFdfs(ini, end, LLONG_MAX/2));\n    ll F = 0;\n    for (int a : adj[ini]) F += flow[a];\n    return F;\n  }\n};\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tgraph G(2 * N + 1);\n\tfu(i, N-1) G.arc(0, 1 + i, 1);\n\tfu(i, N) G.arc(N + i, 2 * N, 1);\n\n\tvvi inc(N);\n\tfu(i, N-1) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x); x--;\n\t\t\tG.arc(1 + i, N + x, 1);\n\t\t\tinc[x].push_back(i);\n\t\t}\n\t}\n\n\tif (G.maxflow(0, 2*N) != (N - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\t// find the match of each set\n\tvi match(N-1);\n\tll root = 0;\n\tfu(i, N) root += i;\n\n\tfu(i, N-1) {\n\t\tfor (int a : G.adj[1 + i])\n\t\t\tif (G.flow[a] == 1) {\n\t\t\t\tmatch[i] = G.dest[a] - N;\n\t\t\t\troot -= G.dest[a] - N;\n\t\t\t}\n\t}\n\n\tif (G.flow[2 * (N - 1) + 2 * root] != 0) while (true);\n\n\tqueue<int> Q;\n\tQ.push(root);\n\tvb mark(N, false);\n\tmark[root] = true;\n\n\tvector<pair<int, int>> ans;\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\n\t\tfor (int s : inc[x]) {\n\t\t\tint y = match[s];\n\t\t\tif (mark[y]) continue;\n\t\t\tmark[y] = true;\n\t\t\tQ.push(y);\n\t\t\tans.emplace_back(x, y);\n\t\t}\n\t}\n\n\tif (ans.size() != N - 1) printf(\"-1\\n\");\n\telse for (auto p : ans) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<ll, ll>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vii = vector<ii>;\nusing vvii = vector<vii>;\nusing vd = vector<ld>;\n\ntemplate<class T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class TIn, class TOut = null_type>\nusing order_tree = tree<TIn, TOut, less<TIn>, rb_tree_tag,\n\ttree_order_statistics_node_update>;\n// .find_by_order(int r) and .order_of_key(TIn v)\n\nconstexpr int INF = 2000000010;\nconstexpr ll LLINF = 9000000000000000010LL;\nconstexpr ld PI = acos(-1);\n\nauto now(){ return chrono::high_resolution_clock::now(); }\nusing TP = decltype(now());\t// time point\nauto duration(TP t1, TP t2){\n\treturn chrono::duration_cast<chrono::microseconds>(t2-t1).count();\n}\n\nstruct UnionFind {\n\tvi par, rank, size; int c;\n\tUnionFind(int n) : par(n), rank(n,0), size(n,1), c(n) {\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }\n\tbool same(int i, int j) { return find(i) == find(j); }\n\tint get_size(int i) { return size[find(i)]; }\n\tint count() { return c; }\n\tint merge(int i, int j) {\n\t\tif ((i = find(i)) == (j = find(j))) return -1; else --c;\n\t\tif (rank[i] > rank[j]) swap(i, j);\n\t\tpar[i] = j; size[j] += size[i];\n\t\tif (rank[i] == rank[j]) rank[j]++;\n\t\treturn j;\n\t}\n};\n\nvoid solve() {\n\tauto start = now();\n\tint N;\n\tcin >> N;\n\tvvi E(N-1);\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tint c;\n\t\tcin >> c;\n\t\tE[i].resize(c);\n\t\tfor (ll &id : E[i]) cin >> id, --id;\n\t}\n\tvi inds(N-1);\n\tiota(inds.begin(), inds.end(), 0);\n\tsort(inds.begin(), inds.end(), [&E](int l, int r) { return E[l].size() < E[r].size(); });\n\n\twhile (duration(start, now()) < 1500000) {\n\t\tbool ok = true;\n\t\tvii edges(N-1);\n\t\tUnionFind uf(N);\n\t\tfor (size_t l = 0, r = 0; ok && l < inds.size(); l = r) {\n\t\t\twhile (r < inds.size() && E[inds[l]].size() == E[inds[r]].size()) ++r;\n\t\t\tshuffle(inds.begin()+l, inds.begin()+r, mt19937(0x94949));\n\n\t\t\tfor (size_t i = l; i < r; ++i) {\n\t\t\t\tint x = inds[i];\n\t\t\t\tunordered_set<int> sn;\n\t\t\t\tvi vec;\n//\t\t\t\tcerr << \"Trying E[\" << x << \"] = {\";\n\t\t\t\tfor (int v : E[x]) {\n\t\t\t\t\tint id = uf.find(v);\n//\t\t\t\t\tcerr << \"(\"<<v<<\", \"<<id<<\") \";\n\t\t\t\t\tif (sn.find(id) != sn.end()) continue;\n\t\t\t\t\tsn.insert(id);\n\t\t\t\t\tvec.push_back(v);\n\t\t\t\t}\n//\t\t\t\tcerr << \"}\" << endl;\n\t\t\t\tif (sn.size() == 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tcerr << \"Final vec:\"; for (int k : vec) cerr << ' ' << k; cerr << endl;\n\t\t\t\tint a = rand() % vec.size(), b;\n\t\t\t\tdo { b = rand() % vec.size(); } while (a == b);\n\t\t\t\ta = vec[a], b = vec[b];\n\t\t\t\tif (a > b) swap(a, b);\n\t\t\t\tuf.merge(a, b);\n\t\t\t\tedges[x] = {a, b};\n\t\t\t}\n\t\t}\n\t\tif (!ok) continue;\n\t\tfor (int i = 0; i < N-1; ++i)\n\t\t\tcout << 1+edges[i].first << ' ' << 1+edges[i].second << '\\n';\n\t\treturn;\n\t}\n\n\tcout << -1 << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(12);\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: wxyww\n* @Date: 2020-04-01 11:25:14\n* @Last Modified time: 2020-04-01 11:49:33\n*/\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1000010;\nll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nvector<int>t[N];\nqueue<int>q;\nint V[N],U[N];\nvector<int>::iterator it;\nstruct node {\n\tint v,nxt,w;\n}e[N << 1];\nint head[N],ejs = 1,cur[N];\nvoid add(int u,int v,int w) {\n\te[++ejs].v = v;e[ejs].nxt = head[u];head[u] = ejs;e[ejs].w = w;\n\te[++ejs].v = u;e[ejs].nxt = head[v];head[v] = ejs;e[ejs].w = 0;\n}\nint dep[N],S,T;\nint bfs() {\n\tq.push(S);\n\tmemset(dep,0,sizeof(dep));\n\tdep[S] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!dep[v] && e[i].w) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T];\n}\nint dfs(int u,int now) {\n\tif(u == T) return now;\n\tint ret = 0;\n\tfor(int &i = cur[u];i;i = e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif(dep[v] == dep[u] + 1 && e[i].w) {\n\t\t\tint k = dfs(v,min(now - ret,e[i].w));\n\t\t\te[i].w -= k;\n\t\t\te[i ^ 1].w += k;\n\t\t\tret += k;\n\t\t\tif(ret == now) return ret;\n\t\t}\n\t}\n\treturn ret;\n}\nint dinic() {\n\tint ret = 0;\n\twhile(bfs()) {\n\t// puts(\"!!!!\");\n\t\tmemcpy(cur,head,sizeof(cur));\n\t\tret += dfs(S,10000000);\n\t}\n\treturn ret;\n}\nint flag[N];\nint main() {\n\tint n = read();\n\tS = 1,T = n + n;\n\tfor(int i = 2;i <= n;++i)\n\t\tadd(S,i,1);\n\tfor(int i = n + 1;i < n + n;++i)\n\t\tadd(i,T,1);\n\tfor(int i = 2;i <= n;++i) {\n\t\tint tot = read();\n\t\tfor(int j = 1;j <= tot;++j) {\n\t\t\tint x = read();\n\t\t\tt[x].push_back(i);\n\t\t\tif(x == 1) continue;\n\t\t\tadd(i,x + n - 1,1);\n\t\t}\n\t}\n\n\tif(dinic() != n - 1) {\n\t\tputs(\"-1\");return 0;\n\t}\n\n\n\tfor(int u = 2;u <= n;++u)\n\t\tfor(int i = head[u];i;i = e[i].nxt)\n\t\t\tif(!e[i].w)\n\t\t\t\tV[u] = e[i].v - n + 1;\n\n\t// for(int i = 2;i <= n;++i) printf(\"%d \",V[i]);\n\t// puts(\"\");\n\n\tq.push(S);\n\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tfor(it = t[u].begin();it != t[u].end();++it) {\n\t\t\t\tif(flag[*it]) continue;\n\t\t\t\tflag[*it] = 1;\n\t\t\t\tU[*it] = u;\n\t\t\t\tq.push(V[*it]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tif(!U[i]) {\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=S; dis[S]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[T]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]+1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nconst int N=500010;\nint n,m,i,j,k,ans[N][2],d[N],head,tail,cnt,x;\nvector<int> a[N];\nset<int> b[N],c;\nbool ok[N];\nvoid doit(int x){ans[++cnt][0]=x;ok[x]=true;set<int>::iterator it=b[x].begin();c.erase(x);\n\tfor (int i=0;i<a[*it].size();i++) if (!ok[a[*it][i]]){ans[cnt][1]=a[*it][i];break;}int xx=*it;\n\tfor (int i=0;i<a[xx].size();i++){b[a[xx][i]].erase(xx);\n\tif (b[a[xx][i]].size()==1&&!ok[a[xx][i]]) d[++tail]=a[xx][i],\n\tc.erase(a[xx][i]);}\n}\nint main(){\n\tscanf(\"%d\",&n);for (i=1;i<=n-1;i++){scanf(\"%d\",&m);for (j=1;j<=m;j++) scanf(\"%d\",&x),a[i].push_back(x),b[x].insert(i);}\n\tfor (i=1;i<=n;i++) c.insert(i);\n\thead=1;tail=0;for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) d[++tail]=i,c.erase(i);\n\t//for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) doit(i);\n\twhile (cnt!=n-1){\n\t\twhile (head<=tail&&cnt!=n-1){\n\t\t\tx=d[head];if (b[x].size()==0){printf(\"-1\\n\");return 0;} else doit(x);head++;\n\t\t}\n\t\tif (cnt!=n-1) doit(*c.begin());\n\t}for (i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans[i][0],ans[i][1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N],BZ,dis[N];\nEDGE *cur[N];\n#define rev(ei) (e+(int((ei)-e)^1))\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]+1==dis[x]){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\tif (!--gap[dis[x]])\n\t\tBZ=0;\n\t++dis[x];\n\t++gap[dis[x]];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (BZ)\n\t\tr+=dfs(S,INF);\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200100;\nstruct T {\n\tint to, nxt, v;\n} way[maxn << 4];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n\tway[++num] = {y, h[x], v}, h[x] = num;\n\tway[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n\tstd::queue<int> q;\n\tfor(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n\tfor(q.push(s), dis[s] = 0;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n\t\t\tdis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n\t}\n\treturn dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n\tif(s == t || !lim) return lim;\n\tint ans = 0, mn;\n\tfor(int & i = head[s];i;i = way[i].nxt)\n\t\tif(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n\t\t\tway[i].v -= mn;\n\t\t\tway[i ^ 1].v += mn;\n\t\t\tans += mn; lim -= mn;\n\t\t\tif(!lim) break;\n\t\t}\n\treturn ans;\n}\ninline int dinic(int s,int t) {\n\tint ans = 0;\n\tfor(;bfs(s,t);) ans += dfs(s,t,1e9);\n\treturn ans;\n}\nint n;\nstd::vector<int> v[maxn];\nstd::vector<int> to[maxn];\nstd::pair<int,int> ans[maxn];\nint id[maxn], fa[maxn], idx[maxn];\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1,x,a;i < n;++i) {\n\t\tstd::cin >> x, adde(0, i, 1);\n\t\tfor(;x--;) {\n\t\t\tstd::cin >> a, v[i].push_back(a);\n\t\t\tif(a != n) adde(i, a + n, 1);\n\t\t}\n\t}\n\tfor(int i = 1;i < n;++i) adde(i + n,n + n + 1,1);\n\tif(dinic(0,n + n + 1) != n - 1) {\n\t\tstd::cout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i < n;++i) for(int j = h[i + n];j;j=way[j].nxt) if(way[j].v == 1 && way[j].to < n) {\n\t\tid[way[j].to] = i;\n\t\tidx[i] = way[j].to;\n\t}\n\tfor(int i = 1;i < n;++i) for(int j : v[i])\n\t\tto[j].push_back(id[i]);\n\tstd::queue<int> q; \n\tfor(q.push(n), fa[n] = 1;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i : to[t]) if(!fa[i]) {\n\t\t\tq.push(i), fa[i] = t;\n\t\t\tans[idx[i]] = {i, t};\n\t\t}\n\t}\n\tif(std::count(fa + 1,fa + n + 1,0)) {\n\t\tstd::cout << - 1 << '\\n';\n\t} else {\n\t\tfor(int i = 1;i < n;++i) std::cout << ans[i].first << ' ' << ans[i].second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint main()\n{\n\tprintf(\"-1\\n\");\t\n} "
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nint head[maxn << 1], nxt[maxn << 3], to[maxn << 3], cap[maxn << 3], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f;\n\t\twhile((f = dinic(s, t)))\n\t\t\tflow += f;\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[to[i] - n] = u;\n\t\t\t\tansy[to[i] - n] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\nint y[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n\tfo(i,1,T)y[i]=la[i];\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(;y[o];y[o]=ne[y[o]])\n\tif(dep[lb[y[o]]]==dep[o]+1&&c[y[o]])\n\tif(flow(lb[y[o]])){\n\t\tc[y[o]]=0;\n\t\tc[y[o]^1]=1;\n\t\treturn 1;\n\t}\n\tdep[o]=-1;\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[re[lb[y]]][0]=o;\n\t\tbb[re[lb[y]]][1]=lb[y];\n\t\t++oo;\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nvoid cl(int i) {\n    set<int> o;\n    swap(o, q[i]);\n}\n\nvoid cel() {\n    set<pair<int, int> > o;\n    swap(g, o);\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++)\n        p[i] = i, r[i] = 0, cl(i);\n    cel();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < a[i].size(); j++)\n            q[a[i][j]].insert(i);\n        d[i] = a[i].size();\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            return;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n    exit(0);\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    double ts = clock();\n    cin >> n;\n    if (n > 10)\n        exit(1);\n    return 0;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n    }\n    while ((clock() - ts) / CLOCKS_PER_SEC < 3.7) {\n        solve();\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < a[i].size(); j++)\n                swap(a[i][j], a[i][rnd() % (j + 1)]);\n    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int Nmax=100010;\n\nnamespace MaxFlow{\n\tusing CapType=int;\n\tstruct Edge{\n\t\tint to,rev;\n\t\tCapType cap;\n\t};\n\tvector<vector<Edge>> g;\n\tvi itr,level;\n\tvoid Init(int n){\n\t\tg.assign(n,vector<Edge>());\n\t\titr.assign(n,0);\n\t\tlevel.assign(n,0);\n\t}\n\tvoid AddEdge(int from,int to,CapType cap){\n\t\tg[from].PB({to,(int)g[to].size(),cap});\n\t\tg[to].PB({from,(int)g[from].size()-1,0});\n\t}\n\tvoid bfs(int s){\n\t\tfill(level.begin(),level.end(),-1);\n\t\tlevel[s]=0;\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();q.pop();\n\t\t\tfor(auto e:g[v])if(e.cap>0&&level[e.to]==-1){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\tCapType dfs(int v,int t,CapType f){\n\t\tif(v==t)\n\t\t\treturn f;\n\t\tCapType res=0;\n\t\tfor(int&i=itr[v];i<(int)g[v].size();i++){\n\t\t\tEdge& e=g[v][i];\n\t\t\tif(e.cap>0&&level[e.to]==level[v]+1){\n\t\t\t\tCapType d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\tres+=d;\n\t\t\t\t\tf-=d;\n\t\t\t\t\tif(f<=0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tCapType Calc(int s,int t){\n\t\tCapType flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]==-1)\n\t\t\t\treturn flow;\n\t\t\tfill(itr.begin(),itr.end(),0);\n\t\t\tflow+=dfs(s,t,inf);\n\t\t}\n\t}\n\tvi Get(){\n\t\tint s=(int(g.size())-2)/2;\n\t\tvi res(s);\n\t\tREP(i,s){\n\t\t\tfor(auto e:g[1+i]){\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tres[i]=e.to-1-s;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nvoid Impossible(){\n\tprint(-1);\n\texit(0);\n}\n\nvi g[Nmax];\nint par[Nmax];\nbool vis[Nmax];\nvoid dfs(int v,int p){\n\tif(vis[v])return;\n\tvis[v]=true;\n\tpar[v]=p;\n\tfor(auto to:g[v])\n\t\tdfs(to,v);\n}\n\nsigned main(){\n\tint n=read();\n\tvector<vi> e(n-1);\n\tREP(i,n-1){\n\t\tint c=read();\n\t\te[i].resize(c);\n\t\tREP(j,c)\n\t\t\te[i][j]=read()-1;\n\t}\n\t\n\tMaxFlow::Init(1+n-1+n-1+1);\n\tREP(i,n-1){\n\t\tMaxFlow::AddEdge(0,1+i,1);\n\t}\n\tREP(i,n-1){\n\t\tMaxFlow::AddEdge(1+n-1+i,1+n-1+n-1,1);\n\t}\n\tREP(i,n-1){\n\t\tREP(j,e[i].size())if(e[i][j]>0){\n\t\t\tMaxFlow::AddEdge(1+e[i][j]-1,1+n-1+i,1);\n\t\t}\n\t}\n\tint f=MaxFlow::Calc(0,1+n-1+n-1);\n\tcerr<<f<<endl;\n\tif(f<n-1){\n\t\tImpossible();\n\t}\n\t\n\tvi match=MaxFlow::Get();\n\tcerr<<match<<endl;\n\tREP(i,n-1){\n\t\tfor(auto v:e[match[i]])\n\t\t\tif(i+1!=v)\n\t\t\t\tg[v].PB(i+1);\n\t}\n\t\n\tdfs(0,-1);\n\tREP(i,n)if(!vis[i])\n\t\tImpossible();\n\t\n\tvector<pi> ans(n-1);\n\tREP(i,n-1){\n\t\tans[match[i]]=pi(i+1,par[i+1]);\n\t}\n\t\n\tREP(i,n-1){\n\t\tprint(ans[i].first+1,2);\n\t\tprint(ans[i].second+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, cur, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v] == cur) {\n        return false;\n    }\n    used[v] = cur;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        ++cur;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nvector<pii> g[N];\npii ans[N];\nint p[N],vis[N],use[N],la;\nvoid dfs(int u){\n    vis[u]=1;\n    for(pii v:g[u])if(!vis[v.fi]&&!use[v.se]){\n        use[v.se]=1;\n        ans[v.se]={u,v.fi};\n        ++la;\n        dfs(v.fi);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb({p[i],i});//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(la!=n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v]){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        vector<ll> level(N,inf);\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200005;\nconst int MAXM = 400005;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint S, T, level[MAXN], q[MAXN], head, tail;\n\nstruct Edge {\n\tint v, w, nxt;\n} e[MAXM << 1];\nint first[MAXN], eCnt;\n\ninline void AddEdge(int u, int v, int w) {\n\te[++eCnt].v = v;\n\te[eCnt].w = w;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\ninline void Add(int u, int v, int w) {\n\tAddEdge(u, v, w);\n\tAddEdge(v, u, 0);\n}\n\ninline int Match(int u) {\n\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\tif (e[i].v != T && e[i].w) return e[i].v;\n\t}\n\treturn 0;\n}\n\nbool BFS() {\n\tfor (int i = 1; i <= T; ++i) {\n\t\tlevel[i] = -1;\n\t}\n\tlevel[S] = 0;\n\tq[head = tail = 1] = S;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tif (u == T) return 1;\n\t\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && level[v] == -1) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++tail] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint DFS(int u, int flow) {\n\tif (u == T) return flow;\n\tint ret = 0;\n\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif (e[i].w && level[v] == level[u] + 1) {\n\t\t\tint tmp = DFS(v, min(flow, e[i].w));\n\t\t\te[i].w -= tmp;\n\t\t\te[i ^ 1].w += tmp;\n\t\t\tflow -= tmp;\n\t\t\tret += tmp;\n\t\t\tif (!flow) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Dinic() {\n\tint ret = 0;\n\twhile (BFS()) {\n\t\tret += DFS(S, INF);\n\t}\n\treturn ret;\n}\n\nint n, son[MAXN], fa[MAXN];\nvector<int> ine[MAXN];\n\nvoid init() {\n\tread(n);\n\teCnt = S = 1, T = n * 2;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint siz; read(siz);\n\t\tAdd(S, n + i, 1);\n\t\tfor (int j = 1; j <= siz; ++j) {\n\t\t\tint x; read(x);\n\t\t\tine[x].push_back(i);\n\t\t\tif (x == 1) continue;\n\t\t\tAdd(n + i, x, 1);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tAdd(i, T, 1);\n\t}\n}\n\nvoid solve() {\n\tif (Dinic() < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tson[Match(i) - n] = i;\n\t}\n\tq[head = tail = 1] = 1;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tfor (auto v : ine[u]) {\n\t\t\tif (fa[v]) continue;\n\t\t\tfa[v] = u;\n\t\t\tq[++tail] = son[v];\n\t\t}\n\t}\n\tif (tail < n) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tprintf(\"%d %d\\n\", fa[i], son[i]);\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint n;\nvector<edge> G[200005];\nint S, T;\nllint level[200005], iter[200005];\n\nvector<llint> revG[200005];\nllint pred[200005], succ[200005];\nbool used[200005];\nvector<P> avec;\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nvoid dfs2(int v)\n{\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tpred[revG[v][i]] = v;\n\t\tused[revG[v][i]] = true;\n\t\tdfs2(succ[revG[v][i]]);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint c, w;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> w;\n\t\t\tadd_edge(i, n+w, 1);\n\t\t\trevG[w].push_back(i);\n\t\t}\n\t}\n\tS = 2*n+1, T = 2*n+2;\n\t\n\tfor(int i = 1; i <= n-1; i++) add_edge(S, i, 1);\n\tfor(int i = 1; i <= n; i++) add_edge(n+i, T, 1);\n\t\n\tllint ans = 0, flow;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(level[T] >= inf) break;\n\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\twhile(1){\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t}\n\tif(ans < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].to == S) continue;\n\t\t\tif(G[i][j].cap == 0) succ[i] = G[i][j].to-n;\n\t\t}\n\t}\n\tint r;\n\tfor(int i = 0; i < G[T].size(); i++){\n\t\tif(G[T][i].cap == 0){\n\t\t\tr = G[T][i].to-n;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdfs2(r);\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tif(pred[i] == 0 || succ[i] == 0){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcout << pred[i] << \" \" << succ[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint next[N],head[N],edge[N],v[N],next2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnext[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnext2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=next[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=next2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=200005,INF=1e9;\nstruct edge\n{\n\tint to,nxt,v;\n}e[N<<2]; int n,x,y,cnt=1,head[N],frm[N],pre[N],q[N],s,t;\ninline void addedge(CI x,CI y,CI z)\n{\n    e[++cnt]=(edge){y,head[x],z}; head[x]=cnt;\n    e[++cnt]=(edge){x,head[y],0}; head[y]=cnt;\n}\n#define to e[i].to\nnamespace NF //Network Flow\n{\n    int cur[N],q[N],dep[N];\n    inline bool BFS(CI s,CI t)\n    {\n        RI H=0,T=1; memset(dep,0,t+1<<2); q[dep[s]=1]=s;\n        while (H<T)\n        {\n            int now=q[++H]; for (RI i=head[now];i;i=e[i].nxt)\n            if (to!=1&&e[i].v&&!dep[to]) dep[to]=dep[now]+1,q[++T]=to;\n        }\n        return dep[t];\n    }\n    inline int DFS(CI now,CI tar,int dis)\n    {\n        if (now==tar) return dis; int ret=0;\n        for (RI& i=cur[now];i&&dis;i=e[i].nxt)\n        if (to!=1&&e[i].v&&dep[to]==dep[now]+1)\n        {\n            int dist=DFS(to,tar,min(dis,e[i].v));\n            dis-=dist; ret+=dist; e[i].v-=dist; e[i^1].v+=dist;\n        }\n        if (!ret) dep[now]=0; return ret;\n    }\n    inline int Dinic(CI s,CI t,int ret=0)\n    {\n        while (BFS(s,t)) memcpy(cur,head,t+1<<2),ret+=DFS(s,t,INF);\treturn ret;\n    }\n};\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),i=1;i<n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=x;++j) scanf(\"%d\",&y),addedge(y,n+i,1);\n\tfor (s=0,t=n<<1,i=1;i<=n;++i) addedge(s,i,1); for (i=1;i<n;++i) addedge(n+i,t,1);\n\tif (NF::Dinic(s,t)!=n-1) return puts(\"-1\"),0;\n\tfor (j=2;j<=n;++j) for (i=head[j];i;i=e[i].nxt) if (to>n&&!e[i].v) frm[to-n]=j;\n\tRI H=0,T=1; q[1]=1; while (H<T)\n\t{\n\t\tint now=q[++H]; for (i=head[now];i;i=e[i].nxt)\n\t\tif (to>n&&!pre[to-n]) pre[to-n]=now,q[++T]=frm[to-n];\n\t}\n\tif (T!=n) return puts(\"-1\"),0;\n\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",pre[i],frm[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,M=800005,oo=1e9;\nstruct edge{\n\tint di,nxt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N];\ninline void aedge(int a,int b,int c){\n\te[++nedge].nxt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void ins(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=0;i<N;i++)deep[i]=oo;\n    for(int i=0;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nxt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nxt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\nint dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nvector<int> v[N>>1];\nint match[N>>1];\nvector<PI> an;\nint main(){\n\tint n=read(),s=n,t=n+1;\n\tFor(i,1,n-1){\n\t\tint c=read();\n\t\tFor(j,1,c){int t=read(); v[t].pb(i); if(t>1)ins(i,t+n,1);}\n\t\tins(s,i,1); ins(n+i+1,t,1);\n\t}\n\tint ans=dinic(s,t); \n\tif(ans!=n-1)GG();\n\tFor(i,1,n-1)for(int j=son[i];j;j=e[j].nxt)if(!e[j].di){match[i]=e[j].ed-n; break;}\n\tqueue<int> q; q.push(1);\n\twhile(q.size()){\n\t\tint t=q.front(); q.pop();\n\t\tfor(auto i:v[t])if(match[i]){\n\t\t\tq.push(match[i]); \n\t\t\tan.pb(mp(t,match[i]));\n\t\t\tmatch[i]=0;\n\t\t}\n\t}\n\tif(an.size()<n-1)GG();\n\tfor(auto i:an){wri(i.fi);writeln(i.se);}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]),g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\n\nvoid failure(){cout<<-1<<lf;exit(0);}\n\nvector<int> e[_];\nint n,ed[_]={0},via[_]={0};\n\nint dfs(int x,int who)\n{\n\tif(ed[x]==who)return 0;\n\ted[x]=who;\n\tfor(auto b:e[x])if(!via[b] || dfs(via[b],who)){via[b]=x;return 1;}\n\treturn 0;\n}\n\nint es[_]={0};\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<n;i++)for(int j=ty();j>=1;j--)e[ty()].emplace_back(i);\n\tfor(int i=2;i<=n;i++)if(!dfs(i,i))failure();\n\n\tqueue<int> q;\n\tq.emplace(1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(q.empty())failure();\n\t\tint a=q.front();q.pop();\n\t\tfor(auto b:e[a])if(!es[b])es[b]=a,q.emplace(via[b]);\n\t}\n\tfor(int i=1;i<n;i++)cout<<es[i]<<' '<<via[i]<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct Edge {\n\tint t,f,next;\n\tEdge() {}\n\tEdge(int a,int b,int c):t(a),f(b),next(c) {}\n};\n\nEdge e[1000000];\nint head[200005],vs,vt,tot=-1;\n\ninline void addEdge(int x,int y,int z) {\n\te[++tot]=Edge(y,z,head[x]);\n\thead[x]=tot;\n\te[++tot]=Edge(x,0,head[y]);\n\thead[y]=tot;\n}\n\nnamespace Flow {\n\n\tint d[200005],cur[200005];\n\tqueue <int> q;\n\n\tbool bfs() {\n\t\twhile (!q.empty()) q.pop();\n\t\tmemset(d,255,sizeof(d));\n\t\td[vs]=0;\n\t\tcur[vs]=head[vs];\n\t\tq.push(vs);\n\t\twhile (!q.empty()) {\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=head[x]; i!=-1; i=e[i].next)\n\t\t\t\tif (e[i].f&&d[e[i].t]==-1) {\n\t\t\t\t\tint u=e[i].t;\n\t\t\t\t\td[u]=d[x]+1;\n\t\t\t\t\tcur[u]=head[u];\n\t\t\t\t\tif (u==vt) return 1;\n\t\t\t\t\tq.push(u);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dfs(int x,int a) {\n\t\tif (x==vt||!a) return a;\n\t\tint ans=0;\n\t\tfor(int &i=cur[x]; i!=-1; i=e[i].next)\n\t\t\tif (e[i].f&&d[e[i].t]==d[x]+1) {\n\t\t\t\tint u=e[i].t;\n\t\t\t\tint f=dfs(u,min(a,e[i].f));\n\t\t\t\tif (f) {\n\t\t\t\t\te[i].f-=f;\n\t\t\t\t\te[i^1].f+=f;\n\t\t\t\t\tans+=f;\n\t\t\t\t\ta-=f;\n\t\t\t\t\tif (!a) break;\n\t\t\t\t}\n\t\t\t}\n\t\treturn ans;\n\t}\n\n\tint maxflow() {\n\t\tint ans=0;\n\t\twhile (bfs())\n\t\t\tans+=dfs(vs,inf);\n\t\treturn ans;\n\t}\n\n}\n\nvector <int> bel[100005];\nbool vis1[100005],vis2[100005];\nint id[100005],nxt[100005];\n\nqueue <int> q;\n\nbool solve(int n) {\n\tfor(int i=1; i<n; i++)\n\t\tfor(int j=head[n+i]; j!=-1; j=e[j].next)\n\t\t\tif (e[j].t&&!e[j].f) {\n\t\t\t\tint u=e[j].t;\n\t\t\t\tid[i]=u;\n\t\t\t\tvis1[u]=1;\n\t\t\t}\n\tfor(int i=1; i<=n; i++)\n\t\tif (!vis1[i]) q.push(i);\n\tint cnt=0;\n\twhile (!q.empty()) {\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tcnt++;\n\t\tfor(int i=0; i<bel[x].size(); i++)\n\t\t\tif (!vis2[bel[x][i]]) {\n\t\t\t\tint u=bel[x][i];\n\t\t\t\tvis2[u]=1;\n\t\t\t\tnxt[u]=x;\n\t\t\t\tq.push(id[u]);\n\t\t\t}\n\t}\n\treturn cnt==n;\n}\n\nint main() {\n\tmemset(head,255,sizeof(head));\n\tint n;\n\tscanf(\"%d\",&n);\n\tvs=0;\n\tvt=2*n;\n\tfor(int i=1; i<n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\taddEdge(vs,n+i,1);\n\t\tfor(int j=1; j<=x; j++) {\n\t\t\tint y;\n\t\t\tscanf(\"%d\",&y);\n\t\t\taddEdge(n+i,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) addEdge(i,vt,1);\n\tif (Flow::maxflow()<n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif (!solve(n)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; i++) printf(\"%d %d\\n\",id[i],nxt[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<ll>& cap){\n\n    if (v == g) return maxflow;\n    cap[v] = 0;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.emplace_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[nex] == 1)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n    vector<ll> level(N,inf);\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.emplace_back(s);\n        rep(i,0,N) level[i] = inf;\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.emplace_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<ll> cap(N,1);\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].emplace_back(wtmp);\n            vtoc[wtmp].emplace_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.emplace_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.emplace_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la, fr[N], id[N]; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\ninline bool cmp(const int &x, const int &y) { return fr[x] < fr[y]; }\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v], fr[la] = v, id[la] = la;\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\tsort(id + 1, id + la + 1, cmp);\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[id[i]], ay[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 200050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn],gap[maxn];\nint cur[maxn],prt[maxn];\n\nint isap()\n{\n    for (int i=1;i<=vt;++i) cur[i]=head[i],++gap[d[i]=0];\n    int i=vs,ans=0;\n    while (d[vs]<vt)\n    {\n        if (i==vt)\n        {\n            for (++ans;i!=vs;i=edge[prt[i]^1])\n                // cout<<\"path:\"<<i<<endl,\n                --cost[prt[i]],++cost[prt[i]^1];\n            // cout<<\"path:\"<<vs<<endl<<endl;\n        }\n\n        bool flag=0;\n        for (int k=cur[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (cost[k]&&d[i]==d[j]+1)\n            {\n                flag=1;\n                cur[i]=prt[j]=k;\n                i=j;\n                break;\n            }\n        }\n\n        if (flag)   continue;\n\n        if (--gap[d[i]]==0) break;\n        d[i]=vt;\n        for (int k=head[i];~k;k=nxt[k])\n            if (cost[k])\n                d[i]=min(d[i],d[edge[k]]+1);\n        ++gap[d[i]];\n        cur[i]=head[i];\n        if (i!=vs)\n            i=edge[prt[i]^1];\n    }\n    // cout<<\"isap:\"<<ans<<endl;\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nstd::vector<int> set[maxn];\n\nint head[maxn << 1], nxt[maxn << 2], to[maxn << 2], cap[maxn << 2], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f = dinic(s, t);\n\t\twhile(f) {\n\t\t\tflow += f;\n\t\t\tf = dinic(s, t);\n\t\t}\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\tprintf(\"%d %d\\n\", u, match[to[i] - n]);\n\t\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint n,s,t;\nint tot,rd[200005],sz[200005],bg[200005],ed[200005];\nint h[200005],fr[1000005],to[1000005],f[1000005],cnt=1;\nvoid add(int x,int y,int z)\n{\n\tfr[++cnt]=h[x];\n\th[x]=cnt;\n\tto[cnt]=y;\n\tf[cnt]=z;\n}\nint dis[200005];\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[now];i;i=fr[i])\n\t\t{\n\t\t\tif(f[i]&&dis[to[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[now]+1;\n\t\t\t\tif(to[i]==t)return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now)\n{\n\tif(now==t)return 1;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(dis[to[i]]==dis[now]+1&&f[i])\n\t\t{\n\t\t\tint r=dfs(to[i]);\n\t\t\tif(!r)dis[to[i]]=-1;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\t//cout<<now<<' '<<to[i]<<endl;\n\t\t\t\tf[i]=0;\n\t\t\t\tf[i^1]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\twhile(dfs(s))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nint bel[100005],rt,g[100005][2],fa[100005];\nvoid dfs1(int now)\n{\n\tcnt++;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(!fa[to[i]])\n\t\t{\n\t\t\tfa[to[i]]=now;\n\t\t\tg[bel[to[i]]][0]=now;g[bel[to[i]]][1]=to[i];\n\t\t\tdfs1(to[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&sz[i]);\n\t\tbg[i]=tot+1;\n\t\tfor(int j=1;j<=sz[i];j++)\n\t\t{\n\t\t\tscanf(\"%d\",&rd[tot+1]);\n\t\t\ttot++;\n\t\t}\n\t\ted[i]=tot;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tt=2*n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t\tfor(int j=bg[i];j<=ed[i];j++)\n\t\t{\n\t\t\tadd(rd[j],i+n,1);\n\t\t\tadd(i+n,rd[j],0);\n\t\t}\n\t}\n\tint flow=dinic();\n\t//cout<<flow<<endl;\n\tif(flow!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=h[i];j;j=fr[j])\n\t\t{\n\t\t\t//cout<<i<<' '<<to[j]<<endl;\n\t\t\tif(to[j]!=s&&f[j]==0)\n\t\t\t{\n\t\t\t\tbel[i]=to[j]-n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!bel[i])rt=i;\n\t\t//cout<<i<<' '<<bel[i]<<endl;\n\t}\n\tmemset(h,0,sizeof(h));\n\tcnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=rt)\n\t\t{\n\t\t\tfor(int j=bg[bel[i]];j<=ed[bel[i]];j++)\n\t\t\t{\n\t\t\t\tif(rd[j]!=i)add(rd[j],i,0);\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tdfs1(rt);\n\t//cout<<cnt<<endl;\n\tif(cnt!=n)printf(\"-1\");\n\telse\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",g[i][0],g[i][1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n  if(x<0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1e5+10;\nint n,id_node[N],id_set[N],match[N],used[N];\nstd::queue<int> q;\nstd::vector<int> a[N],e[N];\nstd::vector<std::pair<int,int>> ans;\ninline void no_solution(){puts(\"-1\"),exit(0);}\ntemplate<int N,int M> struct Dinic{\n  int s/*起点*/,t/*点数&&终点*/,tot/*边数*/,cur[N],hed[N],dep[N],to[M<<1],val[M<<1],nxt[M<<1];\n  Dinic(){tot=0,memset(hed,-1,sizeof(hed));}\n  inline void add(int u,int v,int w){\n    // printf(\"%d %d %d\\n\",u,v,w);\n    nxt[tot]=hed[u],to[tot]=v,val[tot]=w,hed[u]=tot++;\n    nxt[tot]=hed[v],to[tot]=u,val[tot]=0,hed[v]=tot++;\n  }\n  bool bfs(){\n    static int u,l,r,q[N]; memset(dep+1,0,t<<2),l=r=dep[s]=1,q[1]=s;\n    while(l<=r&&(u=q[l++]))for(int i=hed[u];~i;i=nxt[i])\n      if(val[i]&&!dep[to[i]])dep[to[i]]=dep[u]+1,q[++r]=to[i];\n    return dep[t];\n  }\n  int dfs(int u,int d){\n    if(u==t)return d; int s=0;\n    for(int &i=cur[u];~i;i=nxt[i])if(val[i]&&dep[to[i]]==dep[u]+1)\n      if(int e=dfs(to[i],std::min(d-s,val[i]))){s+=e,val[i]-=e,val[i^1]+=e;if(s==d)return s;}\n    return s?s:dep[s]=0;\n  }\n  int dinic(){int r=0;while(bfs())memcpy(cur+1,hed+1,t<<2),r+=dfs(s,1e9);return r;}\n  int findout(int u){for(int i=hed[u];~i;i=nxt[i])if(!val[i]&&to[i]!=s&&to[i]!=t)return to[i];return -1;}\n};\nDinic<N,N*2> flow;\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read(n);\n  for(int i=1,m;i<n;i++){\n    read(m),a[i].resize(m);\n    for(int j=0,x;j<m;j++)read(a[i][j]),e[a[i][j]].push_back(i);\n  }\n  for(int i=1;i<=n;i++)id_node[i]=++flow.t;\n  for(int i=1;i<n;i++)id_set[i]=++flow.t;\n  flow.s=++flow.t,++flow.t;\n  for(int i=2;i<=n;i++){\n    flow.add(flow.s,id_node[i],1);\n  }\n  for(int i=1;i<n;i++){\n    flow.add(id_set[i],flow.t,1);\n    for(int u:a[i])flow.add(id_node[u],id_set[i],1);\n  }\n  if(flow.dinic()!=n-1)no_solution();\n  // for(int i=2;i<=n;i++)printf(\"%d > %d\\n\",i,flow.findout(i));\n  for(int i=2;i<=n;i++)match[flow.findout(i)-n]=i;\n  q.push(1);\n  while(q.size()){\n    int u=q.front(); q.pop();\n    for(int v:e[u])if(!used[v]){\n      ans.push_back(std::make_pair(u,match[v]));\n      used[v]=1,q.push(match[v]);\n    }\n  }\n  if(ans.size()!=n-1)no_solution();\n  for(int i=0;i<n-1;i++)print(ans[i].first,' '),print(ans[i].second,'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const inf=1e8;\nint n,target[800005],pre[800005],last[200005],cap[800005],tot=1,maxflow,\ncur[200005],s,t,dis[200005],ans[200005],ans2[200005];\nbool visited[200005];\nqueue<int>q;\nvoid add(int x,int y,int z)\n{\n\ttarget[++tot]=y;\n\tpre[tot]=last[x];\n\tlast[x]=tot;\n\tcap[tot]=z;\n\ttarget[++tot]=x;\n\tpre[tot]=last[y];\n\tlast[y]=tot;\n}\nbool bfs()\n{\n\tfor(int i=1;i<=t;i++)dis[i]=inf,cur[i]=last[i];\n\tcur[0]=last[0];\n\tq.push(0);\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=last[now];i;i=pre[i])\n\t\t{\n\t\t\tif(cap[i]&&dis[target[i]]==inf)\n\t\t\t{\n\t\t\t\tdis[target[i]]=dis[now]+1;\n\t\t\t\tq.push(target[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=inf;\n}\nint dfs(int x,int lim)\n{\n\tif((!lim)||x==t)return lim;\n\tint flow=0;\n\tfor(int i=cur[x];i;cur[x]=i,i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(cap[i]&&dis[target[i]]==dis[x]+1)\n\t\t{\n\t\t\tint d=dfs(target[i],min(lim,cap[i]));\n\t\t\tcap[i]-=d;\n\t\t\tcap[i^1]+=d;\n\t\t\tflow+=d;\n\t\t\tlim-=d;\n\t\t\tif(!lim)return flow;\n\t\t}\n\t}\n\treturn flow;\n}\nvoid dinic()\n{\n\twhile(bfs())maxflow+=dfs(s,inf);\n}\nvoid getans(int x,int fa)\n{\n\t//cout<<x<<endl;\n\tvisited[x]=1;\n\tfor(int i=last[x];i;i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(x<=n)\n\t\t{\n\t\t\tif(tar==s||tar==t)continue;\n\t\t\tif(!visited[tar])\n\t\t\t{\n\t\t\t\tgetans(tar,x);\n\t\t\t\t//return;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tar==t||(!cap[i]))continue;\n\t\t\t++ans[0];\n\t\t\tans[x-n]=fa;\n\t\t\tans2[x-n]=tar;\n\t\t\tgetans(tar,tar);\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main()\n{\n\tint x,T;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&T);\n\t\twhile(T--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tadd(x,i+n,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)add(0,i,1);\n\tfor(int i=n+1;i<n*2;i++)add(i,n*2,1);\n\tt=n*2,s=0;\n\tdinic();\n\tif(maxflow<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint st;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor(int j=last[i];j;j=pre[j])\n\t\t{\n\t\t\t//cout<<i<<\" \"<<target[j]<<\" \"<<cap[j]<<endl;\n\t\t\tif(target[j]>n&&(!cap[j]))\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgetans(st,st);\n\tif(ans[0]!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=ans[0];i++)printf(\"%d %d\\n\",ans[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\nusing namespace std;\nconst int N=2e5+5,M=2e6;\n\nint n,m,e,S,T,h,t,q[N],lev[N],ax[N],ay[N],o[N];\nint to[M],nx[M],cap[M],hd[N],it[N],sze=1;\nstd::vector<int> g[N];\n\nil void add(int u,int v,int c){to[++sze]=v,nx[sze]=hd[u],cap[sze]=c,hd[u]=sze;}\n\nil void ins(int u,int v,int c){add(u,v,c),add(v,u,0);}\n\nil int bfs()\n{\n\tmemset(lev,0,4*T+4); int i,u,v; q[h=t=lev[S]=1]=S;\n\twhile (h<=t) for (i=hd[u=q[h++]]; i; i=nx[i])\n        if (cap[i]&&!lev[v=to[i]]) lev[v]=lev[u]+1,q[++t]=v;\n\treturn lev[T];\n}\n\nil int dfs(int u,int f)\n{\n\tif (u==T) return f; int z,v,res=0;\n\tfor (int &i=it[u]; i; i=nx[i])\n\t\tif (lev[v=to[i]]==lev[u]+1&&cap[i]&&(z=dfs(v,min(f-res,cap[i]))))\n\t\t{\n\t\t\tcap[i]-=z,cap[i^1]+=z,res+=z;\n\t\t\tif (res==f) break;\n\t\t}\n\treturn res;\n}\n\nil int dinic()\n{\n\tint i,f,res=0;\n\twhile (bfs())\n    {\n        for (i=1; i<=T; i++) it[i]=hd[i];\n        while (f=dfs(S,1e9)) res+=f;\n    }\n\treturn res;\n}\n\nil int work()\n{\n    int i,u,v,s=0;\n    for (u=1; u<n; u++) for (i=hd[u]; i; i=nx[i])\n        if ((v=to[i])!=S&&!cap[i]) o[u]=v-n+1;\n    for (q[++t]=n; h<=t; )\n    {\n        u=q[h++],s++;\n        for (int v:g[u]) if (o[v])\n            ax[v]=u,ay[v]=o[v],q[++t]=o[v],o[v]=0; \n    }\n    return s==n;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),S=n+n-1,T=n+n; int i,c,x;\n    for (i=1; i<n; i++) ins(i+n-1,T,1);\n    for (i=1; i<n; i++)\n    {\n        scanf(\"%d\",&c),ins(S,i,1);\n        while (c--)\n        {\n            scanf(\"%d\",&x);\n            if (x!=n) ins(i,x+n-1,1);\n            g[x].push_back(i);\n        }\n    }\n\n    if (dinic()<n-1) return puts(\"-1\"),0;\n    if (!work()) return puts(\"-1\"),0;\n\tfor (i=1; i<n; i++) printf(\"%d %d\\n\",ax[i],ay[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e6+5;\nconst int INF = 1e9;\n\nint n;\nint fa[N];\nvector<int>pt[N],g[N];\nbool used[N];\nint he,ta;\nint que[N];\nstruct edge{\n\tint x,f,nxt;\n}e[N*10];\nint h[N],tot;\nint vis[N],tim;\nint st,ed,k;\nint id[N][2];\nint key[N],m;\nint vt[N];\nint d[N][2];\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N];\nint deq[N];\nint pu[N],t;\n\nbool bfs(){\n\tfo(i,1,t)dis[pu[i]]=-1;\n\tint he=0,ta=1;\n\tdis[deq[1]=st]=0;\n\tfor(;he<ta;){\n\t\tint x=deq[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (e[p].f&&dis[e[p].x]==-1){\n\t\t\tdis[e[p].x]=dis[x]+1;\n\t\t\tdeq[++ta]=e[p].x;\n\t\t}\n\t}\n\treturn dis[ed]!=-1;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint main(){\nprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long double ld;\n\nvi g[100009];\nvi g2[100009];\nint gsz[100009];\nint g2sz[100009];\n\nvi match;\nvi match1;\nvector<bool> seen;\nbool find(int j){\n    if (match[j] == -1) return 1;\n    seen[j] = 1; int di = match[j];\n    rep(i,0,gsz[di])\n        if (!seen[g[di][i]] && find(g[di][i])) {\n            match[g[di][i]] = di;\n            return 1;\n        }\n    return 0;\n}\nint dfs_matching(int n, int m) {\n    match.assign(m, -1);\n    rep(i,0,n) {\n        seen.assign(m, 0);\n        rep(k,0,gsz[i]){\n            if (find(g[i][k])) {\n                match[g[i][k]] = i;\n                break;\n            }\n        }\n    }\n    return m - (int)count(all(match), -1);\n}\n\nvi match2;\n\nint dfs(int v){\n    int ans = 1;\n    rep(i,0,g2sz[v]){\n        int v2 = g2[v][i];\n        if(match2[v2] == -1){\n            match2[v2] = v;\n            ans += dfs(match1[v2]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    int n;\n    cin >> n;\n    int x,y,c;\n    rep(i,0,n-1){\n        cin >> c;\n        rep(j,0,c){\n            cin >> x;\n            x--;\n            g[i].push_back(x);\n            g2[x].push_back(i);\n        }\n    }\n    rep(i,0,n-1){\n        gsz[i] = sz(g[i]);\n    }\n    rep(i,0,n){\n        g2sz[i] = sz(g2[i]);\n    }\n\n    int mat = dfs_matching(n-1, n);\n    if(mat < n-1){\n        cout << -1 << endl;\n    }else{\n        match1.assign(n-1, -1);\n        match2.assign(n-1, -1);\n        int unm;\n        rep(i,0,n){\n            if(match[i] == -1){\n                unm = i;\n            }else{\n                match1[match[i]] = i;\n            }\n        }\n        int k = dfs(unm);\n        if(k < n){\n            cout << -1 << endl;\n        }else{\n            rep(i,0,n-1){\n                printf(\"%d %d\\n\", match1[i]+1, match2[i]+1);\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200100,MAXM=1000100,INF=0x3f3f3f3f;\nstruct Edge\n{\n\tint to,val,nxt;\n\tinline Edge() {}\n\tinline Edge(register int to,register int val,register int nxt):to(to),val(val),nxt(nxt) {}\n};\nEdge e[MAXM];\nint head[MAXN],S,T,cnt;\nint d[MAXN],cur[MAXN];\nint vis1[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];\nint N;\nqueue<int> q,q_;\nvector<int> bel[MAXN];\ninline void Addedge(register int x,register int y,register int z)\n{\n\te[++cnt]=Edge(y,z,head[x]),head[x]=cnt;\n\te[++cnt]=Edge(x,0,head[y]),head[y]=cnt;\n\treturn;\n}\ninline bool bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tmemset(d,-1,sizeof(d));\n\td[S]=0,cur[S]=head[S],q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tregister int now=q.front(); q.pop();\n\t\tfor(register int i=head[now];~i;i=e[i].nxt)\n\t\t\tif(e[i].val&&(!(~d[e[i].to])))\n\t\t\t{\n\t\t\t\tregister int to=e[i].to;\n\t\t\t\td[to]=d[now]+1,cur[to]=head[to];\n\t\t\t\tif(to==T) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(register int now,register int num)\n{\n\tif(now==T||!num) return num;\n\tregister int ans=0;\n\tfor(register int &i=cur[now];~i;i=e[i].nxt)\n\t\tif(e[i].val&&d[e[i].to]==d[now]+1)\n\t\t{\n\t\t\tregister int to=e[i].to;\n\t\t\tregister int f=dfs(to,min(num,e[i].val));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\te[i].val-=f,e[i^1].val+=f;\n\t\t\t\tans+=f,num-=f;\n\t\t\t\tif(!num) break;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\ninline int maxflow()\n{\n\tregister int ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\ninline bool solve(register int n)\n{\n\tfor(register int i=1;i<n;i++)\n\t\tfor(register int j=head[n+i];~j;j=e[j].nxt)\n\t\t\tif(e[j].to&&!e[j].val) id[i]=e[j].to,vis1[e[j].to]=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis1[i]) q_.push(i);\n\tregister int cnt_=0;\n\twhile(!q_.empty())\n\t{\n\t\tregister int now=q_.front(); q_.pop();\n\t\tcnt_++;\n\t\tfor(register int i=0;i<(int)bel[now].size();i++)\n\t\t\tif(!vis2[bel[now][i]])\n\t\t\t{\n\t\t\t\tregister int to=bel[now][i];\n\t\t\t\tvis2[to]=1,nxt[to]=now,q_.push(id[to]);\n\t\t\t}\n\t}\n\treturn cnt_==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tmemset(head,-1,sizeof(head));\n\tcin>>N;\n\tS=0,T=N<<1;\n\tfor(register int i=1,x,y;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\tAddedge(S,N+i,1);\n\t\tfor(register int j=1;j<=x;j++) cin>>y,Addedge(N+i,y,1),bel[y].push_back(i);\n\t}\n\tfor(register int i=1;i<=N;i++) Addedge(i,T,1);\n\tif(maxflow()<N-1) return puts(\"-1\"),0;\n\tif(!solve(N)) return puts(\"-1\"),0;\n\tfor(register int i=1;i<N;i++) cout<<id[i]<<\" \"<<nxt[i]<<\"\\n\";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);q[++t]=S;dis[S]=1;\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,M=800005,oo=1e9;\nstruct edge{\n\tint di,nxt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N];\ninline void aedge(int a,int b,int c){\n\te[++nedge].nxt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void ins(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=0;i<N;i++)deep[i]=oo;\n    for(int i=0;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nxt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nxt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\nint dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nvector<int> v[N>>1];\nint match[N>>1];\nvector<PI> an;\nint main(){\n\tint n=read(),s=n,t=n+1;\n\tFor(i,1,n-1){\n\t\tint c=read();\n\t\tins(s,i,1); ins(n+i+1,t,1);\n\t\tFor(j,1,c){int t=read(); v[t].pb(i); if(t>1)ins(i,t+n,1);}\n\t}\n\tint ans=dinic(s,t); \n\tif(ans!=n-1)GG();\n\tFor(i,1,n-1)for(int j=son[i];j;j=e[j].nxt)if(!e[j].di){match[i]=e[j].ed-n; break;}\n\tqueue<int> q; q.push(1);\n\twhile(q.size()){\n\t\tint t=q.front(); q.pop();\n\t\tfor(auto i:v[t])if(match[i]){\n\t\t\tq.push(match[i]); \n\t\t\tan.pb(mp(t,match[i]));\n\t\t\tmatch[i]=0;\n\t\t}\n\t}\n\tif(an.size()<n-1)GG();\n\tfor(auto i:an){wri(i.fi);writeln(i.se);}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FO(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define fo(i,j,k) for(int i=(j),end_i=(k);i<=end_i;i++)\n#define ff(i,j,k) for(int i=(j),end_i=(k);i< end_i;i++)\n#define fd(i,j,k) for(int i=(j),end_i=(k);i>=end_i;i--)\n#define DEBUG(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(x) (x).begin(),(x).end()\n#define cle(x) memset(x,0,sizeof(x))\n#define lowbit(x) ((x)&-(x))\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define lb long db\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ninline int read()\n{\n\tint x=0; char ch=getchar(); bool f=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\n#define CASET fo(___,1,read())\n\nconst int N=200010;\nconst int M=2000000;\nnamespace Dinic{\n\tconst int inf=2e9;\n\tint s,t;\n\tint head[N],cur[N],ne[M],ver[M],val[M],tot=1;\n\tint d[N];\n\tqueue<int> q;\n\tinline void add(int x,int y,int v)\n\t{\n\t\tver[++tot]=y; val[tot]=v; ne[tot]=head[x]; head[x]=tot;\n\t\tver[++tot]=x; val[tot]=0; ne[tot]=head[y]; head[y]=tot;\n\t}\n\tinline bool bfs()\n\t{\n\t\tfo(i,0,t) cur[i]=head[i];\n\t\tfor(;!q.empty();q.pop());\n\t\tfo(i,0,t) d[i]=-1; q.push(s); d[s]=0;\n\t\tfor(int u,v;!q.empty();)\n\t\t{\n\t\t\tu=q.front(); q.pop();\n\t\t\tfor(int i=head[u];i;i=ne[i])\n\t\t\t\tif(val[i]&&d[v=ver[i]]==-1)\n\t\t\t\t{\n\t\t\t\t\td[v]=d[u]+1,q.push(v);\n\t\t\t\t\tif(v==t) return 1;\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int flow)\n\t{\n\t\tif(!flow||u==t) return flow;\n\t\tint res=flow,r,v;\n\t\tfor(int &i=cur[u];i;i=ne[i])\n\t\t\tif(val[i]&&d[v=ver[i]]==d[u]+1)\n\t\t\t{\n\t\t\t\tr=dfs(v,min(res,val[i]));\n\t\t\t\tif(!r) continue;\n\t\t\t\tval[i]-=r; val[i^1]+=r;\n\t\t\t\tres-=r; if(!res) break;\n\t\t\t}\n\t\treturn flow-res;\n\t}\n\tint dinic()\n\t{\n\t\tint flow=0;\n\t\twhile(bfs()) flow+=dfs(s,inf);\n\t\treturn flow;\n\t}\n}\nusing namespace Dinic;\nint n;\nvector<pair<int,int>> ans;\nbool vis[N];\nvoid dfs(int u)\n{\n\tfor(int i=head[u],v;i;i=ne[i])\n\t\tif((v=ver[i])!=s&&!vis[v-n])\n\t\t{\n\t\t\tvis[v-n]=1;\n\t\t\tfor(int j=head[v];j;j=ne[j])\n\t\t\t\tif(val[j])\n\t\t\t\t\tans.pb(mp(u,ver[j])),dfs(ver[j]);\n\t\t}\n}\nint main()\n{\n\tn=read();\n\tDinic::t=2*n;\n\ts=0; t=2*n;\n\tff(i,n+1,2*n) CASET add(read(),i,1);\n\tfo(i,1,n) add(s,i,1);\n\tff(i,n+1,2*n) add(i,t,1);\n\tif(dinic()!=n-1) return puts(\"-1\")&0;\n\tint root;\n\tfor(int i=head[0];i;i=ne[i]) if(val[i]) root=ver[i];\n\tdfs(root);\n\tif(ans.size()!=n-1) return puts(\"-1\")&0;\n\tfor(auto v:ans) printf(\"%d %d\\n\",v.fi,v.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2], Q[Max_N], U[Max_N * 2], V[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tQ[Q[0] = 1] = 1;\n\t\tfor (int u, ft = 1;ft <= Q[0];)\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = 0, t;i < In[u].size();++i)\n\t\t\t\tif (!done[t = In[u][i]])\n\t\t\t\t{\n\t\t\t\t\tdone[t] = true;\n\t\t\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\t\t\tU[t] = u, V[t] = v, Q[++Q[0]] = v;\n\t\t\t\t}\n\t\t}\n\t\tfor (int i = N + 1;i <= N + (N - 1);++i)\n\t\t\tprint(U[i]), putc(' '), print(V[i]), putc('\\n');\n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0),dis[i]=2,Gap[2]++;\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0),dis[i]=1,Gap[1]++;\n\tn<<=1;int ans=0;dis[S]=3;Gap[0]=Gap[3]=1;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nvector<pair<int, int> > e;\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\te = vector<pair<int, int> > (n);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) e[par[i] - n] = make_pair(i, par[par[i]]);\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\twrite(e[i].first), putchar(' ');\n\t\t\twrite(e[i].second), putchar('\\n');\n\t\t}\n\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=2e5+5;\nstruct edge{int to,nxt,w;}a[N<<2];\nint n,S,T,head[N],cnt=1,dep[N],q[N],hd,tl,cur[N],fa[N],son[N];\nvector<int>E[N];\nvoid link(int u,int v){\n\ta[++cnt]=(edge){v,head[u],1};head[u]=cnt;\n\ta[++cnt]=(edge){u,head[v],0};head[v]=cnt;\n}\nbool bfs(){\n\tmemset(dep,0,sizeof(dep));\n\tdep[q[hd=tl=1]=S]=1;\n\twhile(hd<=tl)\n\t\tfor(int u=q[hd++],e=head[u];e;e=a[e].nxt)\n\t\t\tif(a[e].w&&!dep[a[e].to]){\n\t\t\t\tdep[q[++tl]=a[e].to]=dep[u]+1;\n\t\t\t\tif(a[e].to==T)return true;\n\t\t\t}\n\treturn false;\n}\nint dfs(int u,int f){\n\tif(u==T)return f;int res=0;\n\tfor(int &e=cur[u];e;e=a[e].nxt)\n\t\tif(a[e].w&&dep[a[e].to]==dep[u]+1){\n\t\t\tint d=dfs(a[e].to,min(a[e].w,f));\n\t\t\ta[e].w-=d;a[e^1].w+=d;f-=d;res+=d;\n\t\t\tif(!f)break;\n\t\t}\n\tif(!res)dep[u]=0;return res;\n}\nint dinic(){\n\tint res=0;\n\twhile(bfs())memcpy(cur,head,sizeof(cur)),res+=dfs(S,1<<30);\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);S=n+n-1;T=S+1;\n\tfor(int i=1,x,y;i<n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tlink(S,i);link(i+n-1,T);\n\t\twhile(x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tif(y>1)link(i,y+n-2);\n\t\t\tE[y].push_back(i);\n\t\t}\n\t}\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)\n\t\tfor(int e=head[i];e;e=a[e].nxt)\n\t\t\tif(!a[e].w)\n\t\t\t\tson[i]=a[e].to-n+2;\n\tq[hd=tl=1]=1;\n\twhile(hd<=tl){\n\t\tint u=q[hd++];\n\t\tfor(int i:E[u])\n\t\t\tif(!fa[i])\n\t\t\t\tfa[i]=u,q[++tl]=son[i];\n\t}\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",fa[i],son[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 1e5 + 10;\n\nvector<int> E[maxn], has[maxn];\nint ord[maxn], u[maxn], v[maxn], par[maxn];\n\nint F(int u) { return par[u] == u ? u : par[u] = F(par[u]); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tauto BEG = clock();\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tord[i] = i;\n\t\tint sz;\n\t\tcin >> sz;\n\t\tE[i].resize(sz);\n\t\tfor (int j = 0; j < sz; ++j) cin >> E[i][j], --E[i][j];\n\t}\n\trandom_shuffle(ord, ord + n - 1);\n\tfor (int i = 0; i < n; ++i) par[i] = i;\n\tfor (int _i = 0; _i < n - 1; ++_i) {\n\t\tint i = ord[_i];\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tint u = E[i][0], anc = F(u), rem = -1;\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tfor (int v: E[i]) {\n\t\t\tif(F(v) != anc) {\n\t\t\t\trem = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(~rem) {\n\t\t\t::u[i] = u;\n\t\t\t::v[i] = rem;\n\t\t\tint fa = F(u), fb = F(rem);\n\t\t\tif(has[fa].size() < has[fb].size()) swap(fa, fb);\n\t\t\thas[fa].insert(has[fa].end(), has[fb].begin(), has[fb].end());\n\t\t\tpar[fb] = fa;\n\t\t\thas[fa].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tif(1. * (clock() - BEG) > 3.6 * CLOCKS_PER_SEC) { puts(\"-1\"); return 0; }\n\t\t\tbool flag = 0;\n\t\t\tfor (int j: has[anc]) if(F(::u[j]) == anc) {\n\t\t\t\tint nrem = -1;\n\t\t\t\tfor (int v: E[j]) if(F(v) != anc) { nrem = v; break; }\n\t\t\t\tif(~nrem) {\n\t\t\t\t\t::v[j] = nrem;\n\t\t\t\t\tint fa = F(::u[j]), fb = F(::v[j]);\n#ifdef DEBUG\n\t\t\t\t\tcout << \"j = \" << j << endl;\n\t\t\t\t\tcout << ::u[j] + 1 << ' ' << ::v[j] + 1 << '\\t' << fa + 1 << ' ' << fb + 1 << endl;\n#endif\n\t\t\t\t\tif(has[fa].size() < has[fb].size()) swap(fa, fb);\n\t\t\t\t\thas[fa].insert(has[fa].end(), has[fb].begin(), has[fb].end());\n\t\t\t\t\tpar[fb] = fa;\n\t\t\t\t\thas[fa].push_back(i);\n\t\t\t\t\t::u[i] = E[i][0];\n\t\t\t\t\t::v[i] = E[i][1];\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) { puts(\"-1\"); return 0; }\n\t\t}\n#ifdef DEBUG\n\t\tcout << \"i = \" << i << endl;\n\t\tfor (int i = 0; i < n - 1; ++i) cout << ::u[i] + 1 << ' ' << v[i] + 1 << endl;\n\t\tfor (int u = 0; u < n; ++u) cout << F(u) + 1 << ' '; cout << endl;\n\t\tcout << endl;\n#endif\n\t}\n\tfor (int i = 0; i < n - 1; ++i) cout << u[i] + 1 << ' ' << v[i] + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  vector< int > rev[200000];\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n      rev[x].emplace_back(i);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0)\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> chosen(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0 && eref[i][j].get())\n        chosen[i] = e[i][j];\n  }\n  vector<bool> vis(n);\n  vector<pair<int, int>> ans;\n  ans.reserve(n - 1);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = true;\n    for (int id : fnd[u])\n      if (chosen[id] != -1) {\n        int v = chosen[id];\n        chosen[id] = -1;\n        ans.emplace_back(u + 1, v + 1);\n        dfs(v);\n      }\n  };\n  dfs(0);\n  if (ans.size() != n - 1)\n    cout << \"-1\\n\";\n  else\n    for (const auto& pr : ans)\n      cout << pr.first << ' ' << pr.second << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201000;\n\nint chosen[N];\n\nnamespace MF {\n  struct Edge {\n    int v, flow, ne;\n  }e[N << 3];\n\n  int fi[N], tot, S, T, V, cur[N], dis[N], q[N];\n\n  void Init(int s, int t, int v) {\n    S = s; T = t; V = v;\n    tot = 1;\n    for(int i = 0; i < V; i++) {\n      fi[i] = 0;\n    }\n  }\n\n  void Add(int x, int y, int w) {\n    e[++tot] = {y, w, fi[x]};\n    fi[x] = tot;\n    e[++tot] = {x, 0, fi[y]};\n    fi[y] = tot;\n  }\n  \n  bool Bfs(void) {\n    for(int i = 0; i < V; i++) {\n      dis[i] = 0;\n    }\n    int h = 1, t = 0;\n    q[++t] = S;\n    dis[S] = 1;\n    while(h <= t) {\n      int x = q[h++];\n      for(int i = fi[x]; i; i = e[i].ne) {\n\tif(e[i].flow && !dis[e[i].v]) {\n\t  dis[e[i].v] = dis[x] + 1;\n\t  q[++t] = e[i].v;\n\t}\n      }\n    }\n    return dis[T];\n  }\n\n  int Dfs(int x, int f) {\n    if(x == T) {\n      return f;\n    }\n    int used = 0;\n    for(int &i = cur[x]; i; i = e[i].ne) {\n      if(e[i].flow && dis[e[i].v] == dis[x] + 1) {\n\tint t = Dfs(e[i].v, min(f - used, e[i].flow));\n\tused += t;\n\te[i].flow -= t;\n\te[i ^ 1].flow += t;\n\tif(used == f) {\n\t  return used;\n\t}\n      }\n    }\n    dis[x] = -1;\n    return used;\n  }\n\n  int Solve(void) {\n    int ans = 0;\n    while(Bfs()) {\n      for(int i = 0; i < V; i++) {\n\tcur[i] = fi[i];\n      }\n      ans += Dfs(S, 1e9);\n    }\n    for(int i = 1; i < (V >> 1); i++) {\n      for(int j = fi[i]; j; j = e[j].ne) {\n\tif(!e[j].flow) {\n\t  ::chosen[i] = e[j].v - (V >> 1) + 1;\n\t}\n      }\n    }\n    return ans;\n  }\n}\n\nint n, q[N], full[N];\npair<int, int> ans[N];\nvector<int> in[N];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  MF::Init(0, n * 2 - 1, n << 1);\n  for(int i = 1, k; i < n; i++) {\n    scanf(\"%d\", &k);\n    for(int j = 0, x; j < k; j++) {\n      scanf(\"%d\", &x);\n      x--;\n      if(x) {\n\tMF::Add(i, x + n - 1, 1);\n      }\n      in[x].push_back(i);\n    }\n  }\n  for(int i = 1; i < n; i++) {\n    MF::Add(MF::S, i, 1);\n    MF::Add(i + n - 1, MF::T, 1);\n  }\n  if(MF::Solve() < n - 1) {\n    return puts(\"-1\"), 0;\n  }\n  int h = 1, t = 0;\n  q[++t] = 0;\n  while(h <= t) {\n    int x = q[h++];\n    for(int y : in[x]) {\n      if(full[y]) {\n\tcontinue;\n      }\n      full[y] = 1;\n      q[++t] = chosen[y];\n      ans[y] = {x, chosen[y]};\n    }\n  }\n  if(t < n) {\n    puts(\"-1\");\n  } else {\n    for(int i = 1; i < n; i++) {\n      printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n\n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n\n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n\n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i))\n                    was = 1;\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 100000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 300000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_], vis[N_], UF[N_], vv[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)UF[i] = i;\n\tfor (i = 1; i < n; i++) {\n\t\tw[i] = { Deg[i],i };\n\t}\n\tsort(w + 1, w + n);\n\tint s = 0;\n\twhile (s!=n-1) {\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tint a = w[i].num, c = 0, u[4];\n\t\t\tif (vis[a])continue;\n\t\t\tfor (auto &t : A[a]) {\n\t\t\t\tif (!vv[Find(t)]) {\n\t\t\t\t\tvv[Find(t)] = 1;\n\t\t\t\t\tu[c++] = t;\n\t\t\t\t\tif (c > 2)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < c; j++)vv[Find(u[j])] = 0;\n\t\t\tif (c == 2) {\n\t\t\t\ts++;\n\t\t\t\tvis[a] = 1;\n\t\t\t\tRes[a][0] = u[0], Res[a][1] = u[1];\n\t\t\t\tMerge(u[0], u[1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; cin >> x;\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; cin >> y; y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tvector<int> seen(n, -2);\n\tqueue<int> q;\n\tint st = -1;\n\tfor(int i = 0; i < n; i++) if(hop.pair_l[i] == -1) st = i;\n\tif(st == -1) bad();\n\tq.push(st); seen[st] = -1;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v : hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq.push(nv);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) cout << pu[i] + 1 << \" \" << pv[i] + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200010\n#define M 1000010\n#define maxn 200010\n#define INF 2147483647\nusing namespace std;\nvector<int> node[maxn], pos[maxn];\nint res[maxn][2];\nint id[2][maxn], s = 1, t = 2, cnt = 2, head[N], nxt[M], a[M], r[M], level[N];\nint cur[N], edge, sum, ch[maxn], used[maxn], pre[maxn], dl[N];\nvoid create(int u, int v, int t)\n{\n\tedge++; a[edge] = v; nxt[edge] = head[u]; head[u] = edge; r[edge] = t;\n}\nvoid build()\n{\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tlevel[i] = 0;\n\t\tcur[i] = head[i];\n\t}\n\tint lef = 1, righ = 1;\n\tlevel[s] = 1;\n\tdl[1] = s;\n\twhile (lef <= righ)\n\t{\n\t\tint u = dl[lef];\n\t\tfor (int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = a[i];\n\t\t\tif (r[i] && level[v] == 0)\n\t\t\t{\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tdl[++righ] = v;\n\t\t\t}\n\t\t}\n\t\tlef++;\n\t}\n}\nint dinic(int u, int flow)\n{\n\tif (u == t) return flow;\n\tint ans = 0;\n\tfor (int i = cur[u]; i; i = nxt[i])\n\t{\n\t\tint v = a[i];\n\t\tif (r[i] && level[v] == level[u] + 1)\n\t\t{\n\t\t\tint low = dinic(v, min(flow, r[i]));\n\t\t\tans += low; flow -= low;\n\t\t\tr[i] -= low; if (i % 2) r[i + 1] += low; else r[i - 1] += low;\n\t\t}\n\t}\n\tif (ans == 0) level[u] = -1;\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tid[1][i] = ++cnt;\n\t\tcreate(cnt, t, 1); create(t, cnt, 0);\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tid[0][i] = ++cnt;\n\t\tcreate(s, cnt, 1); create(cnt, s, 0);\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tnode[i].push_back(x);\n\t\t\tpos[x].push_back(i);\n\t\t\tif (x != 1)\n\t\t\t{\n\t\t\t\tcreate(id[0][i], id[1][x], 1);\n\t\t\t\tcreate(id[1][x], id[0][i], 0);\n\t\t\t}\n\t\t}\n\t}\n\tbuild();\n\twhile (level[t])\n\t{\n\t\tsum += dinic(s, INF);\n\t\tbuild();\n\t}\n\tif (sum != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u = id[0][i];\n\t\tfor (int j = head[u]; j; j = nxt[j])\n\t\t{\n\t\t\tint v = a[j];\n\t\t\tif (v >= id[1][1] && r[j] == 0) {ch[i] = v - id[1][1] + 1; break;}\n\t\t}\n\t}\n\tint cnt = 1;\n\tpre[1] = 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tint u = pre[i], len = pos[u].size();\n\t\tfor (int j = 0; j <= len - 1; j++)\n\t\t{\n\t\t\tint x = pos[u][j];\n\t\t\tif (used[x] == 0)\n\t\t\t{\n\t\t\t\tused[x] = 1;\n\t\t\t\tres[x][0] = u; res[x][1] = ch[x];\n\t\t\t\tpre[++cnt] = ch[x];\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n) puts(\"-1\");\n\telse\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tprintf(\"%d %d\\n\", res[i][0], res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 210000;\nconst int INF = 1000000000;\n \nstruct edge {\n    int a, b, cap, flow;\n};\n \nint nv, s, t, d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n \nvoid addEdge (int a, int b, int cap) {\n    edge e1 = { a, b, cap, 0 };\n    edge e2 = { b, a, 0, 0 };\n    g[a].push_back ((int) e.size());\n    e.push_back (e1);\n    g[b].push_back ((int) e.size());\n    e.push_back (e2);\n}\n \nbool bfs() {\n    int qh=0, qt=0;\n    q[qt++] = s;\n    memset (d, -1, nv * sizeof d[0]);\n    d[s] = 0;\n    while (qh < qt && d[t] == -1) {\n        int v = q[qh++];\n        for (size_t i=0; i<g[v].size(); ++i) {\n            int id = g[v][i],\n                to = e[id].b;\n            if (d[to] == -1 && e[id].flow < e[id].cap) {\n                q[qt++] = to;\n                d[to] = d[v] + 1;\n            }\n        }\n    }\n    return d[t] != -1;\n}\n \nint dfs (int v, int flow) {\n    if (!flow)  return 0;\n    if (v == t)  return flow;\n    for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n        int id = g[v][ptr[v]],\n            to = e[id].b;\n        if (d[to] != d[v] + 1)  continue;\n        int pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n        if (pushed) {\n            e[id].flow += pushed;\n            e[id^1].flow -= pushed;\n            return pushed;\n        }\n    }\n    return 0;\n}\n\nvector<bool> visited;\nvector<int> via;\n\nvoid dfs2(int v) {\n  visited[v] = true;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    int id = g[v][i];\n    int to = e[id].b;\n    if (!visited[to] && e[id].flow < e[id].cap) {\n      via[to] = v;\n      dfs2(to);\n    }\n  }\n}\n \nint dinic() {\n    int flow = 0;\n    for (;;) {\n        if (!bfs())  break;\n        memset (ptr, 0, nv * sizeof ptr[0]);\n        while (int pushed = dfs (s, INF))\n            flow += pushed;\n    }\n    return flow;\n}\n\nint main() {\n        int n; scanf(\"%d\", &n);\n        nv = 2 * n + 1;\n        s = nv - 2;\n        t = nv - 1;\n        vector<int> left(n);\n        for (int i = 0; i < n; ++i) {\n            left[i] = i;\n            addEdge(s, left[i], 1);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int cur = n + i;\n            int count; scanf(\"%d\", &count);\n            addEdge(cur, t, 1);\n            for (int j = 0; j < count; ++j) {\n                int a; scanf(\"%d\", &a);\n                addEdge(left[a - 1], cur, 1);\n            }\n        }\n        int flow = dinic();\n        if (flow != n - 1) {\n            \n                printf(\"-1\\n\");\n                return 0;\n        }\n        visited = vector<bool>(nv);\n        via = vector<int>(nv);\n        dfs2(s);\n        for (int v : left) {\n            if (!visited[v]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n        vector<int> first(n - 1);\n        vector<int> second(n - 1);\n        for (int v : left) {\n            if (via[v] == s) continue;\n            int u = via[via[v]];\n            first[via[v] - n] = v + 1;\n            second[via[v] - n] = u + 1;\n        }\n        for (int i = 0; i < n - 1; ++i)           {\n            printf(\"%d %d\\n\", first[i], second[i]);\n        }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP1(u) for(int i=hd[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)  \n#define REP2(u) for(int&i=cr[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)  \nusing namespace std;\nconst int N=200200,M=1000100,INF=1000010000;\nint n,m,x,S,T,mxf,fl=1;\nint hd[N],cr[N],lk[N],vi[N],fa[N],X[N],Y[N],dep[N];\nqueue<int>q;\nvector<int>ve[N];\nstruct edge{int n,v,c;}e[M];\nvoid add_(int u,int v,int c){e[++fl]=(edge){hd[u],v,c};hd[u]=fl;}\nvoid adde(int u,int v){add_(u,v,1),add_(v,u,0);}\nbool bfs(){\n\tFOR(i,S,T) dep[i]=-1,cr[i]=hd[i];\n\tq.push(S);dep[S]=0;\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tREP1(u)if(c && dep[v]<0)\n\t\t\tdep[v]=dep[u]+1,q.push(v);\n\t}\n\treturn dep[T]>0;\n}\nint dfs(int u,int E){\n\tif(u==T) return E;\n\tint F=0;\n\tREP2(u)if(c && dep[v]==dep[u]+1){\n\t\tint t=dfs(v,min(E,c));\n\t\tF+=t,e[i^1].c+=t;\n\t\tE-=t,e[i^0].c-=t;\n\t\tif(!E) break;\n\t}\n\treturn F;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tve[x].push_back(i+n-1);\n\t\t\tif(x>1) adde(x,i+n-1);\n\t\t}\n\t}\n\tS=1;T=n<<1;\n\tFOR(i,2,n) adde(S,i),adde(i+n-1,T);\n\twhile(bfs()) mxf+=dfs(S,INF);\n\tif(mxf<n-1) return puts(\"-1\"),0;\n\tFOR(x,2,n)REP1(x)if(v>S && !c) lk[v]=x;\n\tq.push(1);\n\twhile(q.size()){\n\t\tint u=q.front(),w;q.pop();\n\t\tfor(int v:ve[u])if(!vi[w=lk[v]])\n\t\t\tvi[w]=1,fa[w]=u,X[v]=u,Y[v]=w,q.push(w);\n\t}\n\tFOR(i,2,n)if(!fa[i]) return puts(\"-1\"),0;\n\tFOR(i,2,n) cout<<X[i+n-1]<<' '<<Y[i+n-1]<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201000;\n\nint chosen[N];\n\nnamespace MF {\n  struct Edge {\n    int v, flow, ne;\n  }e[N << 3];\n\n  int fi[N], tot, S, T, V, cur[N], dis[N], q[N];\n\n  void Init(int s, int t, int v) {\n    S = s; T = t; V = v;\n    tot = 1;\n    for(int i = 0; i < V; i++) {\n      fi[i] = 0;\n    }\n  }\n\n  void Add(int x, int y, int w) {\n    e[++tot] = {y, w, fi[x]};\n    fi[x] = tot;\n    e[++tot] = {x, 0, fi[y]};\n    fi[y] = tot;\n  }\n  \n  bool Bfs(void) {\n    for(int i = 0; i < V; i++) {\n      dis[i] = 0;\n    }\n    int h = 1, t = 0;\n    q[++t] = S;\n    dis[S] = 1;\n    while(h <= t) {\n      int x = q[h++];\n      for(int i = fi[x]; i; i = e[i].ne) {\n\tif(e[i].flow && !dis[e[i].v]) {\n\t  dis[e[i].v] = dis[x] + 1;\n\t  q[++t] = e[i].v;\n\t}\n      }\n    }\n    return dis[T];\n  }\n\n  int Dfs(int x, int f) {\n    if(x == T) {\n      return f;\n    }\n    int used = 0;\n    for(int &i = cur[x]; i; i = e[i].ne) {\n      if(e[i].flow && dis[e[i].v] == dis[x] + 1) {\n\tint t = Dfs(e[i].v, min(f - used, e[i].flow));\n\tused += t;\n\te[i].flow -= t;\n\te[i ^ 1].flow -= t;\n\tif(used == f) {\n\t  return used;\n\t}\n      }\n    }\n    dis[x] = -1;\n    return used;\n  }\n\n  int Solve(void) {\n    int ans = 0;\n    while(Bfs()) {\n      for(int i = 0; i < V; i++) {\n\tcur[i] = fi[i];\n      }\n      ans += Dfs(S, 1e9);\n    }\n    for(int i = 1; i < (V >> 1); i++) {\n      for(int j = fi[i]; j; j = e[j].ne) {\n\tif(!e[j].flow) {\n\t  ::chosen[i] = e[j].v - (V >> 1);\n\t}\n      }\n    }\n    return ans;\n  }\n}\n\nint n, q[N], full[N];\npair<int, int> ans[N];\nvector<int> in[N];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  MF::Init(0, n << 1, n << 1 | 1);\n  for(int i = 1, k; i < n; i++) {\n    scanf(\"%d\", &k);\n    for(int j = 0, x; j < k; j++) {\n      scanf(\"%d\", &x);\n      x--;\n      if(x) {\n\tMF::Add(i, x + n, 1);\n      }\n      in[x].push_back(i);\n    }\n  }\n  for(int i = 1; i < n; i++) {\n    MF::Add(MF::S, i, 1);\n    MF::Add(i + n, MF::T, 1);\n  }\n  if(MF::Solve() < n - 1) {\n    return puts(\"-1\"), 0;\n  }\n  int h = 1, t = 0;\n  q[++t] = 0;\n  while(h <= t) {\n    int x = q[h++];\n    for(int y : in[x]) {\n      if(full[y]) {\n\tcontinue;\n      }\n      full[y] = 1;\n      q[++t] = chosen[y];\n      ans[y] = {x, chosen[y]};\n    }\n  }\n  if(t < n) {\n    puts(\"-1\");\n  } else {\n    for(int i = 1; i < n; i++) {\n      printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jump, and you will find out how to unfold your wings as you fall.\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=2e5+10,Src=maxn-3,Snk=maxn-2,inf=1e8;\n\nvector<pii>v[maxn];\nvector<int>vid[maxn];\nbool mark[maxn];\npii ans[maxn];\nint n,h[maxn],pt[maxn];\n\nvoid add_edge(int a,int b){\n    vid[a].PB(sz(v[b]));\n    vid[b].PB(sz(v[a]));\n    v[a].PB({b,1});\n    v[b].PB({a,0});\n}\n\nbool bfs(){\n    memset(mark,0,sizeof mark);\n    queue<int>q; q.push(Src); mark[Src]=1;\n    while(sz(q)){\n\tint u=q.front();\n\tif(u==Snk) return 1;\n\tq.pop();\n\tfor(pii p:v[u]){\n\t    if(p.S>0 && mark[p.F]==0){\n\t\th[p.F]=h[u]+1;\n\t\tmark[p.F]=1;\n\t\tq.push(p.F);\n\t    }\n\t}\n    }\n    return 0;\n}\nint dfs(int u,int flw=inf){\n    if(u==Snk) return flw;\n    int ans=0,&i=pt[u];\n    while(i<sz(v[u])){\n\tint y=v[u][i].F,&w=v[u][i].S,&w2=v[y][vid[u][i]].S;\n\tif(w>0 && h[u]+1==h[y]){\n\t    int num=dfs(y,min(flw-ans,w));\n\t    w-=num,w2+=num,ans+=num;\n\t    if(ans==flw) return ans;\n\t}\n\t++i;\n    }\n    return ans;\n}\nint flow(){\n    int ans=0;\n    while(bfs()){\n\tmemset(pt,0,sizeof pt);\n\tans+=dfs(Src);\n    }\n    return ans;\n}\n\nvoid go(int u,int par=-1){\n    mark[u]=1;\n    if(u>=n && u!=Src && u!=Snk){\n\tint y=-1;\n\tfor(pii p:v[u]){\n\t    if(p.S!=0)\n\t\ty=p.F;\n\t}\n\tans[u-n]={par+1,y+1};\n    }\n    for(pii p:v[u]){\n\tif(p.S!=0 && mark[p.F]==0)\n\t    go(p.F,u);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie();\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n\tint N;cin>>N;\n\twhile(N--){\n\t    int x;cin>>x;\n\t    add_edge(--x,i+n);\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tadd_edge(Src,i);\n    }\n    for(int i=n;i<2*n-1;i++){\n\tadd_edge(i,Snk);\n    }\n    int num=flow();\n    if(num!=n-1) return cout<<-1<<endl,0;\n    memset(mark,0,sizeof mark);\n    go(Src);\n    for(int i=0;i<n-1;i++){\n\tif(ans[i].F==0)\n\t    return cout<<-1<<endl,0;\n    }\n    for(int i=0;i<n-1;i++){\n\tcout<<ans[i].F<<\" \"<<ans[i].S<<\"\\n\";\n    }\n}\n\n// Deathly mistakes:\n//  * Read the problem curfully.\n//  * Check maxn.\n//  * Overflows.\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    vector<pair<int, int>> ans(n - 1);\n    for (int it = 0; it < n - 1; it++) {\n      assert(!q.empty());\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      ans[i] = {v + 1, done + 1};\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n    for (auto x : ans) {\n      printf(\"%d %d\\n\", x.first, x.second);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], fa[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i] < n);\n    }\n    queue < int > q;\n    q.push(n);\n    int cnt = 0;\n    while (!q.empty()) {\n        cnt++;\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!fa[e[i].v]) {\n                q.push(to[e[i].v]);\n                fa[e[i].v] = now;\n            }\n        }\n    }\n    if (cnt != n) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", fa[i], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\nstruct Bipartite_matching{\n\tint V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\tBipartite_matching(int N){\n\t\tV=N;\n\t\tG.assign(V,vector<int>());\n\t\tmatch.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\tvoid add_edge(int v,int u){\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tbool dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res=0;\n\t\tfill(all(match),-1);\n\t\trep(v,V){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(all(used),false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\t\n\tint N;\n\tcin>>N;\n\tVV<int> A(N-1);\n\tVV<int> v2as(N);\n\trep(i,N-1){\n\t\tint K;\n\t\tcin>>K;\n\t\trep(j,K){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tx--;\n\t\t\tA[i].pb(x);\n\t\t\tv2as[x].pb(i);\n\t\t}\n\t}\n\tBipartite_matching BM(N-1+N);\n\trep(i,N-1){\n\t\tfor(int v:A[i]) BM.add_edge(i,v+N-1);\n\t}\n\tint f = BM.max_matching();\n\tif(f != N-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tV<int> match(N-1);\n\trep(i,N-1) match[i] = BM.match[i] - (N-1);\n\n\t\n\tVV<int> ans(N-1,V<int>(2,-1));\n\trep(i,N-1) ans[i][0] = match[i];\n\n\tint r = 0;\n\trep(i,N) r ^= i;\n\trep(i,N-1) r ^= match[i];\n\tqueue<int> que;\n\tque.push(r);\n\t\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i: v2as[v]) if(ans[i][0] != v && ans[i][1] == -1){\n\t\t\tans[i][1] = v;\n\t\t\tque.push(ans[i][0]);\n\t\t}\n\t}\n\trep(i,N-1) if(ans[i][1] == -1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\trep(i,N-1) cout<<ans[i][0]+1<<\" \"<<ans[i][1]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint n,s,t;\nint tot,rd[200005],sz[100005],bg[100005],ed[100005];\nint h[200005],fr[1000005],to[1000005],f[1000005],cnt=1;\nvoid add(int x,int y,int z)\n{\n\tfr[++cnt]=h[x];\n\th[x]=cnt;\n\tto[cnt]=y;\n\tf[cnt]=z;\n}\nint dis[200005];\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[now];i;i=fr[i])\n\t\t{\n\t\t\tif(f[i]&&dis[to[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[now]+1;\n\t\t\t\tif(to[i]==t)return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now)\n{\n\tif(now==t)return 1;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(dis[to[i]]==dis[now]+1&&f[i])\n\t\t{\n\t\t\tint r=dfs(to[i]);\n\t\t\tif(!r)dis[to[i]]=-1;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\t//cout<<now<<' '<<to[i]<<endl;\n\t\t\t\tf[i]=0;\n\t\t\t\tf[i^1]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\twhile(dfs(s))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nint bel[100005],rt,g[100005][2],fa[100005];\nvoid dfs1(int now)\n{\n\tcnt++;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(!fa[to[i]])\n\t\t{\n\t\t\tfa[to[i]]=now;\n\t\t\tg[bel[to[i]]][0]=now;g[bel[to[i]]][1]=to[i];\n\t\t\tdfs1(to[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&sz[i]);\n\t\tbg[i]=tot+1;\n\t\tfor(int j=1;j<=sz[i];j++)\n\t\t{\n\t\t\tscanf(\"%d\",&rd[tot+1]);\n\t\t\ttot++;\n\t\t}\n\t\ted[i]=tot;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tt=2*n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t\tfor(int j=bg[i];j<=ed[i];j++)\n\t\t{\n\t\t\tadd(rd[j],i+n,1);\n\t\t\tadd(i+n,rd[j],0);\n\t\t}\n\t}\n\tint flow=dinic();\n\t//cout<<flow<<endl;\n\tif(flow!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=h[i];j;j=fr[j])\n\t\t{\n\t\t\t//cout<<i<<' '<<to[j]<<endl;\n\t\t\tif(to[j]!=s&&f[j]==0)\n\t\t\t{\n\t\t\t\tbel[i]=to[j]-n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!bel[i])rt=i;\n\t\t//cout<<i<<' '<<bel[i]<<endl;\n\t}\n\tmemset(h,0,sizeof(h));\n\tcnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=rt)\n\t\t{\n\t\t\tfor(int j=bg[bel[i]];j<=ed[bel[i]];j++)\n\t\t\t{\n\t\t\t\tif(rd[j]!=i)add(rd[j],i,0);\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tdfs1(rt);\n\t//cout<<cnt<<endl;\n\tif(cnt!=n)printf(\"-1\");\n\telse\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",g[i][0],g[i][1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tw[i]-=f; w[i^1]+=f; return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs())\n\t\t{\n\t\t\tfr(i,1,n) cur[i]=begin[i];\n\t\t\twhile(dfs(S,n)) ;\n\t\t}\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1;\n\t\tson[x].push_back(ma[v[x][i]]);\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&n+1<=w[i].to&&w[i].to<=n+n-1)\n\t\t\t\tma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 2e5+5;\n\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,\n\t\t\tvi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\n\nint n, m[MAXN], r[MAXN];\nvector<int> g[MAXN];\nvector<vector<int> > e;\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\te.resize(n-1);\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tvi ba(n, -1);\n\tint fl = hopcroftKarp(e, ba);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ba[i] == -1)\n\t\t\ts = i;\n\t\telse {\n\t\t\tr[i] = ba[i];\n\t\t\tm[ba[i]] = i;\n\t\t\t// cout << ba[i] << ' ' << i << endl;\n\t\t}\n\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tif (m[i] != x) {\n\t\t\t\tg[x].push_back(m[i]);\n\t\t\t\t// cout << x << ' ' << m[i] << endl;\n\t\t\t}\n\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=2e5+5,M=N<<3;\nint n,q[N],tmp[N],ansx[N],ansy[N];\ninline int min(ri x,ri y){\n\treturn x<y ? x:y;\n}\nstruct flow{\n\tint tot=1,head[N],nxt[M],adj[M],w[M],dep[N],q[N],cur[N],size,s,t;\n\tinline void addedge(ri x,ri y,ri z){\n\t\tnxt[++tot]=head[x];\n\t\tadj[head[x]=tot]=y;\n\t\tw[tot]=z;\n\t}\n\tinline void add(ri x,ri y,ri z){\n\t\taddedge(x,y,z);\n\t\taddedge(y,x,0);\n\t}\n\tinline bool bfs(){\n\t\tri i,l,r,x,y;\n\t\tfor(i=1;i<=size;++i) dep[i]=0;\n\t\tdep[s]=1;\n\t\tq[l=r=1]=s;\n\t\twhile(l<=r){\n\t\t\tx=q[l++];\n\t\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\t\tif(w[i]&&!dep[y=adj[i]])\n\t\t\t\t\tq[++r]=y,\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t}\n\t\treturn dep[t];\n\t}\n\tinline int dfs(ri x,ri now){\n\t\tif(x==t) return now;\n\t\tri y,tmp,res=0;\n\t\tfor(int &i=cur[x];i;i=nxt[i])\n\t\t\tif(w[i]&&dep[y=adj[i]]==dep[x]+1&&(tmp=dfs(y,min(now,w[i])))){\n\t\t\t\tres+=tmp;\n\t\t\t\tw[i]-=tmp;\n\t\t\t\tw[i^1]+=tmp;\n\t\t\t\tif(!(now-=tmp)) return res;\n\t\t\t}\n\t\treturn res;\n\t}\n\tinline long long maxflow(){\n\t\tri i;\n\t\tregister long long res=0;\n\t\twhile(bfs()){\n\t\t\tfor(i=1;i<=size;++i) cur[i]=head[i];\n\t\t\tres+=dfs(s,2147483647);\n\t\t} \n\t\treturn res;\n\t}\n}flow;\nvector<pair<int,int> > v[N];\nvector<int> h[N];\ninline void bfs(){\n\tri i,l,r,x,m=0;\n\tq[l=r=1]=1;\n\twhile(l<=r){\n\t\tx=q[l++];\n\t\tfor(auto o:h[x])\n\t\t\tif(tmp[o]) ++m,ansx[o]=x,ansy[o]=tmp[o],q[++r]=tmp[o],tmp[o]=0;\n\t}\n\tif(m!=n-1) puts(\"-1\");\n\telse\n\t\tfor(i=1;i^n;++i) print(ansx[i]),putc(' '),print(ansy[i]),putc('\\n');\n}\nint main(){\n\tri c,x,i;\n\tgi(n);\n\tfor(i=1;i^n;++i){\n\t\tgi(c);\n\t\twhile(c--){\n\t\t\tgi(x);h[x].push_back(i);\n\t\t\tif(x!=1) flow.add(x,i+n,1),v[i].push_back(make_pair(x,flow.tot));\n\t\t}\n\t}\n\tflow.s=n<<1;\n\tflow.size=flow.t=n<<1|1;\n\tfor(i=2;i<=n;++i) flow.add(flow.s,i,1);\n\tfor(i=n+1;i<flow.s;++i) flow.add(i,flow.t,1);\n\tflow.maxflow();\n\tfor(i=1;i^n;++i)\n\t\tfor(auto o:v[i])\n\t\t\tif(flow.w[o.second]){\n\t\t\t\ttmp[i]=o.first;\n\t\t//\t\tprintf(\"%d %d\\n\",i,o.first);\n\t\t\t\tbreak;\n\t\t\t}\n\tbfs();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        ans += dfs(s,t,inf);\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , bel[N] , n , root;\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1 ){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t\tbel[e[j].to] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tif (!bel[i]) root = i;\n\t}\n\t\n\tq.push(root);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N*2],BZ,dis[N*2];\nEDGE *cur[N*2];\n#define rev(ei) (e+(int((ei)-e)^1))\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]+1==dis[x]){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\tif (!--gap[dis[x]])\n\t\tBZ=0;\n\t++dis[x];\n\t++gap[dis[x]];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (BZ)\n\t\tr+=dfs(S,INF);\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[N],got[N],tak[N];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[tot]=x,b[tot]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  vector< int > rev[200000];\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n      rev[x].emplace_back(i);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N - 1; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\treturn 0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int maxn = 100100;\nint seen[maxn], q[maxn];\nint main(){\n\tint n; scanf(\"%d\", &n);\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; scanf(\"%d\", &x);\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; scanf(\"%d\", &y); y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tint st = n - 1, tp = 0;\n\tfor(int i = 0; i < n; i++) seen[i] = -2;\n\tq[tp++] = st; seen[st] = -1;\n\tfor(int tu = 0; tu < tp; tu++){\n\t\tint u = q[tu];;\n\t\tfor(int v : hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq[tp++] = nv;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) \n\t\tprintf(\"%d %d\\n\", pu[i] + 1, pv[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &i : x) cin >> i;\n\t\ta.pb({x, i});\n\t}\n\tsort(all(a), [](auto i, auto j) {\n\t\treturn i.first.size() < j.first.size();\n\t});\n\trans.resize(n-1);\n\tdsu d(n);\n\tfor(auto [i, idx] : a) {\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tif(d.r[d.par(1)] != n) return cout << -1, 0;\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],gap[N << 1],dis[N << 1],pos[N],vis[N];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline int isap(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = isap(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]];\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tfor(gap[0] = T;dis[S] < T;) ans += isap(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=400010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tvector<pair<int,int> >ans;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans.push_back(make_pair(u,link[v]));\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,0,SZ(ans)-1)cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_];\nvector<int>A[N_], B[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", A[i][0], A[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace flow{\n\tconst int _ = 1e6 + 7 , __ = 1e7 + 7;\n\tstruct Edge{int end , upEd , f;}Ed[__];\n\tint head[_] , dep[_] , cur[_] , cntEd = 1 , S , T;\n\n\tvoid addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}\n\tvoid addE(int a , int b , int c){addEd(a , b , c); addEd(b , a , 0);}\n\t\n\tqueue < int > q;\n\tbool bfs(){\n\t\tmemset(dep , 0 , sizeof(int) * (T + 1)); while(!q.empty()) q.pop();\n\t\tdep[S] = 1; q.push(S);\n\t\twhile(!q.empty()){\n\t\t\tint t = q.front(); q.pop();\n\t\t\tfor(int i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && !dep[Ed[i].end]){\n\t\t\t\t\tdep[Ed[i].end] = dep[t] + 1;\n\t\t\t\t\tif(Ed[i].end == T){memcpy(cur , head , sizeof(int) * (T + 1)); return 1;}\n\t\t\t\t\tq.push(Ed[i].end);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dfs(int x , int mn){\n\t\tif(x == T) return mn;\n\t\tint sum = 0;\n\t\tfor(int &i = cur[x] ; i ; i = Ed[i].upEd)\n\t\t\tif(Ed[i].f && dep[Ed[i].end] == dep[x] + 1){\n\t\t\t\tint t = dfs(Ed[i].end , min(mn - sum , Ed[i].f));\n\t\t\t\tsum += t; Ed[i].f -= t; Ed[i ^ 1].f += t;\n\t\t\t\tif(sum == mn) break;\n\t\t\t}\n\t\treturn sum;\n\t}\n\n\tint Dinic(int s , int t){int sum = 0; S = s; T = t; while(bfs()) sum += dfs(s , 1e9); return sum;}\n}using namespace flow;\n\nint read(){\n\tint a = 0; char c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();}\n\treturn a;\n}\n\nint N , pos[200003] , E[200003][2]; vector < int > id[200003];\n\nint main(){\n\tN = read();\n\tfor(int i = 2 ; i <= N ; ++i) addE(0 , i , 1);\n\tfor(int i = 1 ; i < N ; ++i){\n\t\taddE(N + i , N + N , 1);\n\t\tfor(int p , x = read() ; x ; --x){addE(p = read() , i + N , 1); id[p].push_back(i);}\n\t}\n\tif(Dinic(0 , N + N) != N - 1){puts(\"-1\"); return 0;}\n\tfor(int i = 2 ; i <= N ; ++i)\n\t\tfor(int j = head[i] ; j ; j = Ed[j].upEd)\n\t\t\tif(Ed[j].end > N && !Ed[j].f){pos[Ed[j].end - N] = i; break;}\n\tqueue < int > q; q.push(1);\n\twhile(!q.empty()){\n\t\tint t = q.front(); q.pop();\n\t\tfor(auto x : id[t]) if(pos[x]){E[x][0] = t; E[x][1] = pos[x]; q.push(pos[x]); pos[x] = 0;}\n\t}\n\tfor(int i = 1 ; i < N ; ++i) printf(\"%d %d\\n\" , E[i][0] , E[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nstruct Unfo{int nu,we;}d[N];\nint n,p,num=1,b[N],s,t,di[N],li[N],ansn,nu,cur[N],no[N],an[N];\nbool vi[N];\nbool comp(const Unfo &a,const Unfo &b){return a.nu<b.nu;}\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0&&di[a[y].nu]==di[x]+1){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<n;i++){\n\t\tread(p);\n\t\twhile(p--){read(d[++nu].nu);d[nu].we=i;if(d[nu].nu!=1){jb(i,d[nu].nu+n,1);}}\n\t}\n\tsort(d+1,d+nu+1,comp);\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++)jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\tfor (int i=1,j=0;i<=n;i++){f[i].be=j+1;while (d[j+1].nu==i)j++;f[i].en=j;}\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++)\n\t\t\tfor (int j=b[i];j;j=a[j].ne)\n\t\t\t\tif (a[j].nu!=s&&a[j].qu==0)no[i]=a[j].nu-n;\n\t\tfor (int i=1;i<n;i++) vi[i]=true;\n\t\tint l=1,r=1;li[l]=1;\n\t\twhile (l<=r){\n\t\t\tfor (int i=f[li[l]].be;i<=f[li[l]].en;i++){\n\t\t\t\tif (vi[d[i].we]){\n\t\t\t\t\tvi[d[i].we]=false;li[++r]=no[d[i].we];\n\t\t\t\t\tan[d[i].we]=li[l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tif (r!=n)cout<<\"-1\"<<endl;\n\t\telse{\n\t\t\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",an[i],no[i]);\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], cur[M], S, T;\nint q[M], q0;\n\nint bfs() {\n\tfo(i, 1, T) d[i] = 0, cur[i] = fi[i];\n\tq[q0 = 1] = S; d[S] = 1;\n\tfor(int i = 1; i <= q0; i ++) {\n\t\tint x = q[i];\n\t\tfor(int j = fi[x]; j; j = nt[j]) if(r[j])\n\t\t\tif(!d[to[j]]) d[to[j]] = d[x] + 1, q[++ q0] = to[j];\n\t} \n\treturn d[T] > 0;\n}\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] + 1 == d[to[i]] && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\twhile(bfs()) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <set>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100]; set<int> W[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tif (N == 2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t\tW[x].insert(i);\n\t\t}\n\t}\n\n\tfor (int i=1;i<=N;i++){\n\t\tif (W[i].size() == 0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstack<int> s;\n\tfor (int i=0;i<N-1;i++){\n\t\tint c = 0;\n\t\tfor (int x : G[i]) if (W[x].size() == 1) c++;\n\t\tif (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if (c == 1){\n\t\t\ts.push(i);\n\t\t}\n\t}\n\n\twhile (!s.empty()){\n\t\tint i = s.top(), v = 0, c = 0; s.pop();\n\t\tfor (int x : G[i]){\n\t\t\tif (W[x].size() == 1) v = x, c++;\n\t\t\tW[x].erase(i);\n\t\t\tif (W[x].size() == 1) s.push(*W[x].begin());\n\t\t}\n\t\tif (c == 1){\n\t\t\tint x = v;\n\t\t\tint y = G[i][0]==v?G[i][1]:G[i][0];\n\t\t\tX[i] = x; Y[i] = y;\n\t\t}\n\t\telse if (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[i].clear();\n\t}\n\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++) if (!G[i].empty()){\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsort(v.begin(),v.end());\n\tsrand(time(NULL));\n\tfor (int t=0;t<1000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint H, W, N;\nint A[MAX_N], B[MAX_N];\nvi Q[MAX_N];\nvi vx;\n\nint fd(int a) {\n\treturn lower_bound(all(vx), a) - vx.begin();\n}\n\nvoid solve() {\n\tcin >> H >> W >> N;\n\trep(i, 0, N) {\n\t\tcin >> A[i] >> B[i]; A[i]--; B[i]--;\n\t\tvx.pb(B[i]);\n\t}\n\tsort(all(vx));\n\tvx.erase(unique(all(vx)), vx.end());\n\trep(i, 0, N) {\n\t\tint at = fd(B[i]);\n\t\tQ[at].pb(A[i]);\n\t}\n\trep(i, 0, sz(vx)) Q[i].pb(H);\n\tint M = sz(vx);\n\trep(i, 0, M) sort(all(Q[i]));\n\tint x = 0, y = 0;\n\tint res = H;\n\trep(i, 0, M) {\n\t\tif(vx[i] == 0) MIN(res, Q[0][0]);\n\t\telse {\n\t\t\tint pre = vx[i] - 1;\n\t\t\ty += pre - x;\n\t\t\t// debug(pre, y, i, Q[i]);\n\t\t\tint at = upper_bound(all(Q[i]), y) - Q[i].begin();\n\t\t\tint d = H;\n\t\t\tint pat = fd(pre);\n\t\t\tif(pat != M && vx[pat] == pre) {\n\t\t\t\td = *upper_bound(all(Q[pat]), y);\n\t\t\t}\n\t\t\twhile(Q[i][at] == y + 1 && y + 1 < d) {\n\t\t\t\tat++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tMIN(res, d);\n\t\t\tMIN(res, *upper_bound(all(Q[i]), y));\n\t\t\tif(y == d - 1) break;\n\t\t\tx = pre;\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 2123333333\n#define pii pair<int,int>\n\nstruct node { int t,v,op,next; }a[1000010];\n\nvector<int> v[200010];\nqueue<int> q;\n\npii ans[100010];\n\nint level[200010],head[200010],cur[200010],num[200010],to[200010],n,vs,vt,tt,tot;\nbool inq[200010];\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void print(int x)\n{\n\tstatic char s[233];\n\tif (!x) { putchar('0');putchar(' ');return; }\n\tint tot=0;\n\tfor (;x;x/=10) s[++tot]=x%10+'0';\n\tfor (;tot;tot--) putchar(s[tot]);\n\tputchar(' ');\n}\n\ninline void add(int x,int y,int z)\n{\n\ta[++tot].t=y;a[tot].v=z;a[tot].op=tot+1;a[tot].next=head[x];head[x]=tot;\n\ta[++tot].t=x;a[tot].v=0;a[tot].op=tot-1;a[tot].next=head[y];head[y]=tot;\n}\n\ninline bool bfs()\n{\n\twhile (!q.empty()) q.pop();\n\tmemset(level,0,sizeof(level));\n\tq.push(vs);level[vs]=1;cur[vs]=head[vs];\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor (int i=head[x];i;i=a[i].next) if (a[i].v)\n\t\t{\n\t\t\tint t=a[i].t;\n\t\t\tif (level[t]) continue;\n\t\t\tlevel[t]=level[x]+1;cur[t]=head[t];\n\t\t\tif (t==vt) return true;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int y)\n{\n\tif (x==vt||!y) return y;\n\tint res=0;\n\tfor (int &i=cur[x];i;i=a[i].next) if (a[i].v)\n\t{\n\t\tint t=a[i].t;\n\t\tif (level[t]!=level[x]+1) continue;\n\t\tint hh=dfs(t,min(y,a[i].v));\n\t\tif (!hh) continue;\n\t\tres+=hh;y-=hh;\n\t\ta[i].v-=hh;a[a[i].op].v+=hh;\n\t\tif (!y) break;\n\t}\n\treturn res;\n}\n\ninline void insert(int x)\n{\n\tfor (int t:v[x]) num[t]=x,q.push(t);\n}\n\nint main()\n{\n\tn=rd();vs=0;vt=n*2;tot=0;\n\tfor (int i=1;i<=n;i++) add(vs,i,1);\n\tfor (int i=1;i<n;i++) add(n+i,vt,1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint k=rd();\n\t\tfor (int j=1;j<=k;j++)\n\t\t{\n\t\t\tint x=rd();\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\tint sum=0;\n\twhile (bfs()) sum+=dfs(vs,inf);\n\tif (sum<n-1) { puts(\"-1\");return 0; }\n\tint id=0;\n\tfor (int i=head[vs];i;i=a[i].next) if (a[i].v) id=a[i].t;\n\tfor (int i=1;i<=n;i++) for (int j=head[i];j;j=a[j].next) if (a[j].t>n&&!a[j].v) to[a[j].t-n]=i;\n\twhile (!q.empty()) q.pop();\n\tinsert(id);tt=0;\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tif (inq[x]) continue;\n\t\tans[x]=pii(num[x],to[x]);\n\t\tinsert(to[x]);inq[x]=true;tt++;\n\t}\n\tif (tt<n-1) { puts(\"-1\");return 0; }\n\tfor (int i=1;i<=tt;i++) print(ans[i].first),print(ans[i].second),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=1000005;\nint n,i,j,k,l,tot,pt[N],tk[N],head[N],adj[N],nxt[N],flow[N],cap[N],cur[N],d[N],q[N],bg,ed;\nbool v[N];\nvector<int> bl[N];\nvoid addedge(int u,int v,int w)\n{\n\tadj[++l]=v;\n\tnxt[l]=head[u];\n\thead[u]=l;\n\tcap[l]=w;\n\tadj[++l]=u;\n\tnxt[l]=head[v];\n\thead[v]=l;\n\tcap[l]=0;\n}\nbool bfs()\n{\n\tint i;\n\tfor(i=1;i<=tot;++i)\n\t\td[i]=1<<30;\n\td[tot-1]=0;\n\tq[bg=ed=1]=tot-1;\n\twhile(bg<=ed)\n\t{\n\t\tfor(i=head[q[bg]];i;i=nxt[i])\n\t\t\tif(flow[i]<cap[i]&&d[adj[i]]==(1<<30))\n\t\t\t{\n\t\t\t\td[adj[i]]=d[q[bg]]+1;\n\t\t\t\tq[++ed]=adj[i];\n\t\t\t}\n\t\t++bg;\n\t}\n\treturn d[tot]!=(1<<30);\n}\nint dfs(int x,int a)\n{\n\tif(x==tot||a<=0)\n\t\treturn a;\n\tint g,h=0;\n\tfor(;cur[x];cur[x]=nxt[cur[x]])\n\t\tif(d[adj[cur[x]]]==d[x]+1&&(g=dfs(adj[cur[x]],min(a,cap[cur[x]]-flow[cur[x]])))>0)\n\t\t{\n\t\t\tflow[cur[x]]+=g;\n\t\t\tflow[cur[x]&1?cur[x]+1:cur[x]-1]-=g;\n\t\t\ta-=g;\n\t\t\th+=g;\n\t\t\tif(a<=0)\n\t\t\t\tbreak;\n\t\t}\n\treturn h;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ttot=2*n;\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d\",&k);\n\t\twhile(k--)\n\t\t{\n\t\t\tscanf(\"%d\",&j);\n\t\t\tbl[j].push_back(i);\n\t\t\tif(j<n)\n\t\t\t\taddedge(i,n-1+j,1);\n\t\t}\n\t\taddedge(tot-1,i,1);\n\t\taddedge(n-1+i,tot,1);\n\t}\n\tk=0;\n\twhile(bfs())\n\t{\n\t\tfor(i=1;i<=tot;++i)\n\t\t\tcur[i]=head[i];\n\t\tk+=dfs(tot-1,1<<30);\n\t}\n\tif(k<n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<n;++i)\n\t\tfor(j=head[i];j;j=nxt[j])\n\t\t\tif(adj[j]!=tot-1&&flow[j]==cap[j])\n\t\t\t{\n\t\t\t\tpt[i]=adj[j]-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\tq[bg=ed=1]=n;\n\tfor(i=1;i<=n;++i)\n\t\tv[i]=false;\n\tv[n]=true;\n\twhile(bg<=ed)\n\t{\n\t\tfor(i=bl[q[bg]].size()-1;i>=0;--i)\n\t\t\tif(!v[pt[bl[q[bg]][i]]])\n\t\t\t{\n\t\t\t\tq[++ed]=pt[bl[q[bg]][i]];\n\t\t\t\tv[q[ed]]=true;\n\t\t\t\ttk[bl[q[bg]][i]]=q[bg];\n\t\t\t}\n\t\t++bg;\n\t}\n\tfor(i=1;i<n;++i)\n\t\tif(!tk[i])\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",pt[i],tk[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint s[Nmax];\nint n;\nbool unlocked[Nmax];\nvector<int> v[Nmax], w[Nmax];\npair<int, int> edge[Nmax];\n\nclass Graph\n{\n    vector<int> v[Nmax];\n    bool used[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(used[node]) return 0;\n        used[node] = 1;\n\n        for(auto it : v[node])\n            if(!R[it])\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : v[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        v[x].push_back(y);\n    }\n\n    bool cuplaj()\n    {\n        bool done = 1; int i;\n        while(done)\n        {\n            done = 0;\n            for(i=1; i<=n; ++i) used[i] = 0;\n\n            for(i=1; i<=n; ++i)\n                if(!L[i]) done |= cupleaza(i);\n        }\n\n        for(i=1; i<n; ++i)\n        {\n            s[i] = R[i];\n            if(!s[i]) return 0;\n        }\n        return 1;\n    }\n\n} graph;\n\nvoid build_sol()\n{\n    queue<int> q;\n    q.push(n);\n\n    int node, nr = n-1;\n    while(q.size())\n    {\n        node = q.front();\n        q.pop();\n\n        for(auto it : w[node])\n            if(!unlocked[s[it]])\n            {\n                q.push(s[it]);\n                unlocked[s[it]] = 1;\n                edge[it] = {node, s[it]};\n                --nr;\n            }\n    }\n\n    if(nr)\n    {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    int i;\n    for(i=1; i<n; ++i) cout << edge[i].first << ' ' << edge[i].second << '\\n';\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    int i, nr, x;\n    cin >> n;\n    for(i=1; i<n; ++i)\n    {\n        cin >> nr;\n        while(nr--)\n        {\n            cin >> x;\n            v[i].push_back(x);\n            w[x].push_back(i);\n            if(x < n) graph.add_edge(x, i);\n        }\n    }\n\n    if(!graph.cuplaj())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    build_sol();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 120000;\n\nvector<int> eds[MAXN];\n\nint p[MAXN];\nint q[MAXN];\n\nint n;\n\nint was[MAXN];\n\nint dfs1(int v) {\n\twas[v] = 1;\n\tfor (int u: eds[v]) {\n\t\tif (q[u] == -1) {\n\t\t\tq[u] = v;\n\t\t\tp[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor (int u: eds[v]) {\n\t\tif (!was[q[u]]) {\n\t\t\tif (dfs1(q[u])) {\n\t\t\t\tq[u] = v, p[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvector<int> go[MAXN];\nint up[MAXN];\n\nvoid dfs2(int v, int p) {\n\twas[v] = 1;\n\tup[v] = p;\n\tfor (int u: go[v]) {\n\t\tif (!was[u])\n\t\t\tdfs2(u, v);\n\t}\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint c;\n\t\tcin >> c;\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t--x;\n\t\t\teds[i].push_back(x);\n\t\t}\n\t}\n\tfill(p, p + n, -1);\n\tfill(q, q + n, -1);\n\tint ch = 0;\n\tdo {\n\t\tch = 0;\n\t\tmemset(was, 0, sizeof(was));\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tif (was[i] == 0 && p[i] == -1)\n\t\t\t\tch |= dfs1(i);\n\t\t}\n\t} while (ch);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (p[i] == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint st = -1;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (q[i] == -1) {\n\t\t\tst = i;\n\t\t\tq[i] = n - 1;\n\t\t}\n\tp[n - 1] = st;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tfor (int u: eds[i]) {\n\t\t\tif (q[u] != i) {\n\t\t\t\tgo[q[u]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(was, 0, sizeof(was));\n\tdfs2(n - 1, -1);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (!was[i]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcout << p[i] + 1 << \" \" << p[up[i]] + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nstruct Dinic {\n    typedef int Flow;\n    static const Flow INF = 1<<29;\n    struct Edge {\n\tint src, dst;\n\tFlow cap;\n\tint rev;\n    };\n    typedef vector<vector<Edge> > Graph;\n    Graph G;\n    vector<int>len, iter;\n    Dinic(int N) : G(N) {}\n    void add_edge(int u, int v, Flow c) {\n\tG[u].push_back((Edge){ u, v, c, (int)G[v].size() });\n\tG[v].push_back((Edge){ v, u, 0, (int)G[u].size()-1 });\n    }\n    Flow dfs(int v, int s, Flow c) {\n\tif (v == s || c == 0) return c;\n\tFlow ret = 0;\n\tfor (int &i=iter[v]; i<(int)G[v].size(); i++) {\n\t    Edge &e = G[v][i], &re = G[e.dst][e.rev];\n\t    if (re.cap > 0 && len[v] > len[e.dst]) {\n\t\tFlow f = dfs(e.dst, s, min(c-ret, re.cap));\n\t\tret += f;\n\t\te.cap += f; re.cap -= f;\n\t\tif (ret == c) break;\n\t    }\n\t}\n\treturn ret;\n    }\n    void bfs(int s) {\n\tlen.assign(G.size(), -1);\n\tqueue<int>qu;\n\tqu.push(s);\n\tlen[s] = 0;\n\tfor (;!qu.empty();) {\n\t    int v = qu.front(); qu.pop();\n\t    for (int i=0; i<(int)G[v].size(); i++) {\n\t\tconst Edge &e = G[v][i];\n\t\tif (e.cap > 0 && len[e.dst] == -1) {\n\t\t    len[e.dst] = len[v] + 1;\n\t\t    qu.push(e.dst);\n\t\t}\n\t    }\n\t}\n    }\n    Flow _flow;\n    Flow flow(int source, int sink, Flow limit=-1) {\n\tif (limit == -1) limit = INF;\n\tFlow ret = 0;\n\twhile (true) {\n\t    bfs(source);\n\t    if (len[sink] == -1 || limit == 0) return _flow = ret;\n\t    iter.assign(G.size(), 0);\n\t    Flow tmp = dfs(sink, source, limit);\n\t    ret += tmp;\n\t    limit -= tmp;\n\t}\n    }\n};\n\nconst Dinic::Flow Dinic::INF;\nint N;\nVI E[100011];\nVI R[100011];\nVI G[100011];\nbool use[100011];\npair<int, int> ans[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint K;\n\tscanf(\"%d\", &K);\n\tE[i].resize(K);\n\tREP (j, K) scanf(\"%d\", &E[i][j]), E[i][j]--;\n    }\n\n    int RIGHT = N-1;\n    int SRC = RIGHT+N-1, SNK = SRC+1;\n    Dinic D(SNK+1);\n\n    REP (i, N-1) {\n\tG[i] = E[i];\n\tG[i].erase(remove(G[i].begin(), G[i].end(), N-1), G[i].end());\n\tEACH (e, E[i]) {\n\t    R[*e].push_back(i);\n\n\t    if (*e < N-1) D.add_edge(i, *e + RIGHT, 1);\n\t}\n\n\tD.add_edge(SRC, i, 1);\n\tD.add_edge(i+RIGHT, SNK, 1);\n    }\n\n    if (D.flow(SRC, SNK) == N-1) {\n\tVI ord; ord.reserve(N);\n\tord.push_back(N-1);\n\tuse[N-1] = true;\n\tfor (int i=0; i<(int)ord.size(); i++) {\n\t    int v = ord[i];\n\t    EACH (e, R[v]) if (!use[*e]) {\n\t\tint w;\n\t\tEACH (f, D.G[*e]) if (f->dst != SRC && f->cap == 0) {\n\t\t    w = f->dst - RIGHT;\n\t\t}\n\t\tans[*e] = make_pair(v, w);\n\t\tord.push_back(w);\n\t\tuse[*e] = true;\n\t    }\n\t}\n\n\tif ((int)ord.size() == N) {\n\t    REP (i, N-1) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t    return;\n\t}\n    }\n    puts(\"-1\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv, is_forb;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e[a].PB(Edge{b, cap, SZ(e[b]), 0});\n    e[b].PB(Edge{a, bi_dir * cap, SZ(e[a]) - 1, 0});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    //e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n\n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n//     for (int i = 0; i <= n; i++) {\n//       dis[i] = n + 1;\n//     }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        if (edge.is_forb) { continue; }\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      if (e[v][i].is_forb) { continue; }\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<int> halko;\n    for (int ii = 0; ii < SZ(gr.e[i]); ii++) {\n      auto edge = gr.e[i][ii];\n    //for (auto& edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        debug(i, edge.v);\n        int poszlo = Dinic::kInf - edge.c;\n        gr.e[i][ii].c = 0;\n        gr.e[edge.v][edge.inv].c = 0;\n        assert(gr.e[source][i - 1].v == i);\n        gr.e[source][i - 1].c += poszlo;\n        assert(gr.e[i][0].v == source);\n        gr.e[i][0].c -= poszlo;\n        assert(gr.e[edge.v][0].v == sink);\n        gr.e[edge.v][0].c += poszlo;\n        assert(gr.e[sink][edge.v - n - 1].v == edge.v);\n        gr.e[sink][edge.v - n - 1].c -= poszlo;\n        int new_flow = gr.MaxFlow(source, sink);\n        if (new_flow == poszlo) {\n          debug(\"wywal\");\n        } else {\n          halko.PB(edge.v - n);\n          gr.e[i][ii].c = Dinic::kInf;\n          gr.e[edge.v][edge.inv].c = 0;\n          int newer_flow = gr.MaxFlow(source, sink);\n          //debug(new_flow, new_flow, poszlo);\n          assert(new_flow + newer_flow == poszlo);\n        }\n        //halko.PB({edge.v - n, );\n      } else {\n        gr.e[i][ii].c = 0;\n      } \n    }\n//     vector<int> filter;\n//     for (auto v : halko) {\n//       \n//       \n//     }\n    debug(halko);\n    assert(SZ(halko) == 2);\n    for (auto x : halko) {\n      cout<<x<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nint p[N],fa[N];\nint get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}\npii ans[N];\nint la;\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n)fa[i]=i;\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(get(x)!=p[i]){\n                ans[++la]={x,p[i]},fa[p[i]]=x;\n                //printf(\"x=%d\\n\",x);\n                break;\n            }\n        }\n    }\n    if(la<n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],pos[N],vis[N],dis[N << 1];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline bool bfs() {\n\tqueue <int> q;\n\tmemset(dis,0,sizeof(dis));\n\tq.push(S),dis[S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front();q.pop();\n\t\tif(x == T) return true;\n\t\tfor(int i = beg[x];i;i = nex[i])\n\t\t\tif(!dis[to[i]] && flow[i]) {\n\t\t\t\tdis[to[i]] = dis[x] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] + 1 == dis[to[i]]) {\n\t\t\tint val = dfs(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\twhile(bfs()) ans += dfs(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=z,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||!c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\n//maxvの値に注意\nconst int maxv = 512810;\n \nstruct e_t { int to, cap, rev; };\n \nint V, S, T;\nvector<e_t> adj[maxv];\n \nint rej[maxv];\nint red[maxv];\n \nvoid aedge(int i, int j, int c) {\n  adj[i].pb((e_t){j, c, adj[j].size() + (i == j ? 1 : 0)});\n  adj[j].pb((e_t){i, 0, adj[i].size() - 1});\n}\n \nvoid bfs() {\n  memset(rej, -1, sizeof(rej));\n  queue<int> q;\n  rej[S] = 0;\n  q.push(S);\n  while (!q.empty()) {\n    int v = q.front();\n    q.pop();\n    for (int i = 0; i < (int)adj[v].size(); i++) {\n      e_t &e = adj[v][i];\n      if (e.cap <= 0) continue;\n      if (rej[e.to] != -1) continue;\n      q.push(e.to);\n      rej[e.to] = rej[v] + 1;\n    }\n  }\n}\n \nint dfs(int v, int flow) {\n  if (v == T || flow == 0) return flow;\n  for (; red[v] < (int)adj[v].size(); red[v]++) {\n    e_t &e = adj[v][red[v]];\n    if (rej[e.to] <= rej[v]) continue;\n    int f = dfs(e.to, min(flow, e.cap));\n    if (f > 0) {\n      e.cap -= f;\n      adj[e.to][e.rev].cap += f;\n      return f;\n    }\n  }\n  return 0;\n}\n \nint mflow() {\n  int total = 0, fsum, f;\n  do {\n    bfs();\n    memset(red, 0, sizeof(red));\n    fsum = 0;\n    while (0 < (f = dfs(S, 1001001001))) fsum += f;\n    total += fsum;\n  } while (fsum > 0);\n  return total;\n}\n\nint p[200100];//マッチング相手\nbool used[200100];//マッチング相手として使われたか\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tS=2*n-1;T=S+1;V=T+1;\n\t//MF::init(V);\n\trep(i,n-1){\n\t\taedge(S,i,1);\n\t\trep(j,v[i].size()) aedge(i,n-1+v[i][j],1);\n\t\taedge(n-1+i,T,1);\n\t}\n\t//MF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(mflow()<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\t/*rep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}*/\n\trep(i,n-1) rep(j,adj[i].size()){\n\t\tif(adj[i][j].to<S && adj[i][j].to>=n-1 && adj[i][j].cap<1) p[i]=adj[i][j].to-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define M 1000010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[M],got[M],tak[M];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[tot]=x,b[tot]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define debug(x) cerr<<#x<<\" = \"<<x\n#define sp <<\"  \"\n#define el <<endl\n#define fgx cerr<<\" ---------------------------------------------- \"<<endl\n#define uint unsigned int \n#define ULL unsigned long long\n#define DB long double\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define rint register int \ninline int read(){\n\tint nm=0; bool fh=true; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) fh^=(cw=='-');\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn fh?nm:-nm;\n}\n#define pli pair<long long,int>\n#define M 400020\n#define mod 998244353ll\nint fs[M],nt[M<<2],to[M<<2],cur[M],tg[M],tmp,r[M<<2];\nint n,S,T,vis[M],tim,q[M],hd,tl,u[M],v[M],fa[M];\ninline void add(int x,int y){\n\tnt[tmp]=fs[x],fs[x]=tmp,to[tmp]=y,r[tmp++]=1;\n\tnt[tmp]=fs[y],fs[y]=tmp,to[tmp]=x,r[tmp++]=0;\n}\ninline bool bfs(){\n\thd=tl=0,q[tl++]=S,tg[S]=++tim,vis[S]=1,cur[S]=fs[S];\n\tfor(int x=q[hd];hd<tl;x=q[++hd]) for(int y,i=fs[x];i!=-1;i=nt[i]) \n\t\tif(r[i]&&tg[y=to[i]]<tim) vis[q[tl++]=y]=vis[x]+1,tg[y]=tim,cur[y]=fs[y];\n\treturn tg[T]==tim;\n}\ninline int dfs(int x,int mxf=1){\n\tif(x==T||!mxf) return mxf; int temp=0,rc;\n\tfor(int &i=cur[x];i!=-1&&temp<mxf;i=nt[i]) if(r[i]&&vis[to[i]]==vis[x]+1&&tg[to[i]]==tim)\n\t\trc=dfs(to[i]),r[i]-=rc,r[i^1]+=rc,temp+=rc; if(!temp) tg[x]=0; return temp;\n}\ninline void solve(int x,int last){\n\tif(fa[x]>0) return; fa[x]=last;\n\tfor(int i=fs[x];i!=-1;i=nt[i]) if(!r[i]&&to[i]<S) solve(to[i],x);\n}\nint main(){\t\n\tn=read(),memset(fs,-1,sizeof(fs)),S=n+n,T=S+1; for(int i=1;i<=n;i++) add(i,T);\n\tfor(int i=1;i<n;add(S,i+n),i++) for(int ct=read();ct;--ct) add(i+n,read()); int now=0,x;\n\twhile(bfs()) now+=dfs(S,n-1); if(now<n-1){puts(\"-1\");return 0;}\n\tfor(int i=fs[T];i!=-1;i=nt[i]) if(!r[i]) x=to[i]; solve(x,0);\n\tfor(int i=1;i<=n;i++) if(i!=x) u[fa[i]-n]=i;\n\tfor(int i=1;i<n;i++) v[i]=fa[i+n];\n\tfor(int i=1;i<n;i++) if(!u[i]||!v[i]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e6+5;\nconst int INF = 1e9;\n\nint n;\nint fa[N];\nvector<int>pt[N],g[N];\nbool used[N];\nint he,ta;\nint que[N];\nstruct edge{\n\tint x,f,nxt;\n}e[N*10];\nint h[N],tot;\nint vis[N],tim;\nint st,ed,k;\nint id[N][2];\nint key[N],m;\nint vt[N];\nint d[N][2];\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N];\nint deq[N];\nint pu[N],t;\n\nbool bfs(){\n\tfo(i,1,t)dis[pu[i]]=-1;\n\tint he=0,ta=1;\n\tdis[deq[1]=st]=0;\n\tfor(;he<ta;){\n\t\tint x=deq[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (e[p].f&&dis[e[p].x]==-1){\n\t\t\tdis[e[p].x]=dis[x]+1;\n\t\t\tdeq[++ta]=e[p].x;\n\t\t}\n\t}\n\treturn dis[ed]!=-1;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tn=get();\n\tk=n;\n\tfo(i,1,n-1){\n\t\tint c=get();\n\t\tfo(j,1,c){\n\t\t\tint x=get();\n\t\t\tpt[i].push_back(x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tid[i][0]=++k;id[i][1]=++k;\n\t}\n\the=0,ta=1;\n\tque[1]=1;\n\tst=++k;ed=++k;\n\tfor(;he<ta;){\n\t\ttim++;\n\t\ttot=1;\n\t\tm=0;\n\t\tint pre_ta=ta;\n\t\th[st]=h[ed]=0;\n\t\tt=2;\n\t\tpu[1]=st,pu[2]=ed;\n\t\tm=0;\n\t\tfo(i,he+1,pre_ta){\n\t\t\tint x=que[i];\n\t\t\th[x]=0;\n\t\t\tpu[++t]=x;\n\t\t\tinse(st,x,INF);\n\t\t\tfor(auto u:g[x])\n\t\t\tif (!used[u]){\n\t\t\t\tif (vis[u]<tim){\n\t\t\t\t\tpu[++t]=id[u][0],pu[++t]=id[u][1];\n\t\t\t\t\tvis[key[++m]=u]=tim;\n\t\t\t\t\tinse(id[u][0],id[u][1],1);\n\t\t\t\t\tfor(auto y:pt[u])\n\t\t\t\t\tif (y!=1&&!fa[y]){\n\t\t\t\t\t\tif (vt[y]<tim){\n\t\t\t\t\t\t\tpu[++t]=y;\n\t\t\t\t\t\t\th[y]=0;\n\t\t\t\t\t\t\tvt[y]=tim;\n\t\t\t\t\t\t\tinse(y,ed,1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinse(id[u][1],y,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinse(x,id[u][0],1);\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\twhile(bfs())cnt+=aug(st,INF);\n\t\tif (cnt<m)return printf(\"-1\\n\"),0;\n\t\tfo(i,1,m){\n\t\t\tint u=key[i];\n\t\t\tused[u]=1;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int p=h[id[u][0]];p;p=e[p].nxt)\n\t\t\tif (e[p].f&&e[p].x>=1&&e[p].x<=n){x=e[p].x;break;}\n\t\t\tfor(int p=h[id[u][1]];p;p=e[p].nxt)\n\t\t\tif (!e[p].f&&e[p].x!=id[u][0]){y=e[p].x;break;}\n\t\t\tfa[y]=x;\n\t\t\tque[++ta]=y;\n\t\t\td[u][0]=x,d[u][1]=y;\n\t\t}\n\t\the=pre_ta;\n\t}\n\tif (ta<n)return printf(\"-1\\n\"),0;\n\tfo(i,1,n-1)printf(\"%d %d\\n\",d[i][0],d[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=2*::Maxn,Maxm=4*::Maxn;\n\tint S,T,cnt,h[Maxn],cur[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int&p=cur[x];p;p=e[p].next){\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,h,sizeof(h));\n\t\t\tans+=dfs(S,INT_MAX);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 200005\n#define M 800005\n#define inf 0x3f3f3f3f\nint tar[M], nex[M], cap[M], fir[N], cnt = 1;\nint n, m, dis[N], now[N], use[N][2];\nvector<int>A[N];\nset<int>S[N];\nqueue<int>Q;\nvoid add(int a, int b, int c)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tcap[cnt] = c;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nvoid Add(int a, int b)\n{\n\tadd(a, b, 1);\n\tadd(b, a, 0);\n}\nint aug(int s, int b, int e, int g, int augco)\n{\n\tif (s == e)\n\t\treturn augco;\n\tint augc = augco;\n\tfor (int &i = now[s]; i; i = nex[i])\n\t{\n\t\tint v = tar[i];\n\t\tif (cap[i])\n\t\t{\n\t\t\tif (dis[v] == dis[s] + 1)\n\t\t\t{\n\t\t\t\tint delta = aug(v, b, e, g, min(augc, cap[i]));\n\t\t\t\tcap[i] -= delta;\n\t\t\t\tcap[i ^ 1] += delta;\n\t\t\t\taugc -= delta;\n\t\t\t\tif (!augc)\n\t\t\t\t\treturn augco;\n\t\t\t}\n\t\t}\n\t}\n\treturn augco - augc;\n}\nbool Bfs(int s, int t)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tdis[s] = 0;\n\tqueue<int>que;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front();\n\t\tnow[x] = fir[x];\n\t\tque.pop();\n\t\tfor (int i = fir[x]; i; i = nex[i])\n\t\t{\n\t\t\tint v = tar[i];\n\t\t\tif (!cap[i])\n\t\t\t\tcontinue;\n\t\t\tif (dis[x] + 1 < dis[v])\n\t\t\t{\n\t\t\t\tdis[v] = dis[x] + 1;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t] != inf;\n}\nint sap(int b, int e, int g)\n{\n\tint flow = 0;\n\twhile (Bfs(b, e))\n\t\tflow += aug(b, b, e, g, inf);\n\treturn flow;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int j = 1; j <= t; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tS[x].insert(i);\n\t\t\tA[i].push_back(x);\n\t\t\tif (x != 1)\n\t\t\t\tAdd(i, n + x);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tAdd(2 * n + 1, i);\n\t\tAdd(n + i, 2 * n + 2);\n\t}\n\tint ans = sap(2 * n + 1, 2 * n + 2, 2 * n + 2);\n\tif (ans < n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = fir[i]; j; j = nex[j])\n\t\t{\n\t\t\tint v = tar[j];\n\t\t\tif (v > n && !cap[j])\n\t\t\t\tuse[i][0] = v - n;\n\t\t}\n\t}\n\tQ.push(1);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front();\n\t\tm++;\n\t\tQ.pop();\n\t\tset<int>::iterator it = S[x].begin();\n\t\tfor (; it != S[x].end(); it++)\n\t\t{\n\t\t\tif (!use[*it][1])\n\t\t\t{\n\t\t\t\tuse[*it][1] = x;\n\t\t\t\tQ.push(use[*it][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (m < n)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", use[i][0], use[i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,inf=1e9;\nint n,c,p[N],q[N],id[N],x;vector<int> a[N];\nstruct edge{int u,v,c,f;};\nstruct Dinic{\n    vector<edge> e;\n    vector<int> G[N];queue<int> q;\n    int cur[N],d[N],n,m,s,t,ma[N],cnt,p[N],_n;bool vis[N];\n    inline void add(int u,int v,int c){\n        //printf(\"%d %d %d\\n\",u,v,c);\n        e.pb((edge){u,v,c,0});e.pb((edge){v,u,0,0});\n        m=e.size();G[u].pb(m-2);G[v].pb(m-1);\n    }\n    bool bfs(){\n        memset(d,0,sizeof(d));memset(vis,0,sizeof(vis));vis[s]=1;q.push(s);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int &x:G[u]){\n                edge &E=e[x];\n                if(E.c>E.f&&!vis[E.v]) d[E.v]=d[u]+1,vis[E.v]=1,q.push(E.v);\n            }\n        }\n        return vis[t];\n    }\n    int dfs(int u,int a){\n        if(u==t||!a) return a;\n        int flow=0,f;\n        for(int &i=cur[u];i<(int)G[u].size();++i){\n            edge &E=e[G[u][i]];\n            if(d[E.v]==d[u]+1&&(f=dfs(E.v,min(a,E.c-E.f)))){\n                E.f+=f;e[G[u][i]^1].f-=f;\n                flow+=f;a-=f;if(!a) break;\n            }\n        }\n        return flow;\n    }\n    int max_flow(int s,int t){\n        this->s=s;this->t=t;\n        int flow=0;\n        while(bfs()){memset(cur,0,sizeof(cur));flow+=dfs(s,inf);}\n        return flow;\n    }\n    void DFS(int u){\n        ++cnt;vis[u]=1;\n        for(int &x:G[u]){\n            edge &E=e[x];\n            if(E.v!=t&&!vis[ma[E.v]]) p[ma[E.v]-_n]=u-_n,DFS(ma[E.v]);\n        }\n    }\n    void solve(int n){\n        memset(vis,0,sizeof(vis));_n=n;\n        rep(i,2,n){\n            for(int &x:G[i]){\n                edge &E=e[x];\n                if(E.v!=s&&E.f) ma[i]=E.v;\n            }\n        }\n        DFS(n+n);\n        if(cnt!=n) puts(\"-1\");\n        else rep(i,2,n) printf(\"%d %d\\n\",ma[i]-n,p[ma[i]-n]);\n    }\n}G;\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);int S=1,T=2*n+1;G.n=T;\n    rep(i,1,n-1) G.add(1,i+1,1);\n    rep(i,1,n-1){\n        scanf(\"%d\",&c);\n        rep(j,0,c-1) scanf(\"%d\",&x),G.add(i+1,x+n,1);\n    }\n    rep(i,1,n-1) G.add(i+n,T,1);\n    int t=G.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    G.solve(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nint cho1[MAXN+5],cho2[MAXN+5];\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\tint cnt=0;\n\twhile(!Q.empty()){\n\t\tcnt++;\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tcho1[s]=u,cho2[s]=ma[s];\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",cho1[i],cho2[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<int> a(2 * N + 2);\n\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    FOR(i, 1, N + 1) a.add_edge(N + i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    if (mf < N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0)\n            {\n                printf(\"%d %d\\n\", wm[from], ed.to - N);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=2147483647;\nstruct Edge\n{\n\tint to;\n\tint next;\n\tint flow;\n}e[1000005];\nint n,m,s,t,edgenum=1,head[1000005],dep[1000005],cur[1000005],match[100005],from[100005],to[100005];\nbool flag[100005];\nvector<int>root[100005];\nqueue<int>q;\nvoid add(int u,int v,int f)\n{\n\te[++edgenum].flow=f;\n\te[edgenum].to=v;\n\te[edgenum].next=head[u];\n\thead[u]=edgenum;\n}\nbool bfs()\n{\n\twhile(!q.empty())q.pop();\n\tmemset(dep,0,sizeof(dep));\n\tdep[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int hd=head[node];hd;hd=e[hd].next)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(e[hd].flow==0)continue;\n\t\t\tif(!dep[to])\n\t\t\t{\n\t\t\t\tdep[to]=dep[node]+1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\tif(dep[t])return 1;\n\t}\n\treturn 0;\n}\nint dfs(int node,int nowf)\n{\n\tif(node==t)return nowf;\n\tif(nowf==0)return 0;\n\tfor(int&hd=cur[node];hd;hd=e[hd].next)\n\t{\n\t\tint to=e[hd].to;\n\t\tif(e[hd].flow==0)continue;\n\t\tif(dep[to]==dep[node]+1)\n\t\t{\n\t\t\tint d=dfs(to,min(nowf,e[hd].flow));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te[hd].flow-=d;\n\t\t\t\te[hd^1].flow+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic()\n{\n\tint ans=0,d;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;i++)\n\t\t  cur[i]=head[i];\n\t\twhile(d=dfs(s,INF))\n\t\t  ans+=d;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=1,t=2*n;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tfor(int i=n+1;i<2*n;i++)\n\t{\n\t\tadd(i,t,1);\n\t\tadd(t,i,0);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint size;\n\t\tscanf(\"%d\",&size);\n\t\twhile(size--)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\troot[x].push_back(i);\n\t\t\tx--;\n\t\t\tif(x==0)continue;\n\t\t\tadd(i,x+n,1);\n\t\t\tadd(x+n,i,0);\n\t\t}\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  for(int hd=head[i];hd;hd=e[hd].next)\n\t\tif(e[hd].flow==0)\n\t\t  match[i]=e[hd].to-n+1;\n\twhile(!q.empty())q.pop();\n\tq.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<root[node].size();i++)\n\t\t{\n\t\t\tif(flag[root[node][i]])continue;\n\t\t\tflag[root[node][i]]=1;\n\t\t\tfrom[root[node][i]]=node;\n\t\t\tto[root[node][i]]=match[root[node][i]];\n\t\t\tq.push(match[root[node][i]]);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\tif(!from[i])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  printf(\"%d %d\\n\",from[i],to[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],min(flow-used,c[i]));\n\t\tif(v)used+=v,c[i]-=v,c[i^1]+=v,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],gap[N << 1],dis[N << 1],pos[N],vis[N];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline int isap(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = isap(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]];\n\treturn f - res;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"AGC029F.in\",\"r\",stdin);\n\tfreopen(\"AGC029F.out\",\"w\",stdout);\n#endif\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tfor(gap[0] = T;dis[S] < T;) ans += isap(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[++tot] = mp(x,pos[cur]),Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i] < n);\n    }\n    queue < int > q;\n    q.push(n);\n    int cnt = 0;\n    while (!q.empty()) {\n        cnt++;\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    if (cnt != n) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct edge { int to; ll cap; int rev; };\nstruct Dinic {\nprivate:\n\tint n;\n\tvector<vector<edge>> v;\n\tvector<int> dist, iter;\npublic:\n\tDinic(int sz) :n(sz), v(sz), dist(sz), iter(sz) {}\n\n\tvoid addedge(int from, int to, ll cap) {\n\t\tint x = v[to].size(), y = v[from].size();\n\t\tv[from].push_back({ to,cap,x });\n\t\tv[to].push_back({ from,0,y });\n\t}\n\n\tvoid bfs(int s) {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tdist[s] = 0;\n\t\tq.push(s);\n\t\twhile (q.size()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(i, v[x].size()) {\n\t\t\t\tedge& e = v[x][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] < 0) {\n\t\t\t\t\tdist[e.to] = dist[x] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll dfs(int x, int t, ll f) {\n\t\tif (x == t)return f;\n\t\tfor (int& i = iter[x]; i < (int)v[x].size(); ++i) {\n\t\t\tedge& e = v[x][i];\n\t\t\tif (e.cap > 0 && dist[x] < dist[e.to]) {\n\t\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tv[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll max_flow(int s, int t) {\n\t\tll flow = 0;\n\t\twhile (1) {\n\t\t\tbfs(s);\n\t\t\tif (dist[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tll f;\n\t\t\twhile ((f = dfs(s, t, 1LL << 62)) > 0)flow += f;\n\t\t}\n\t}\n\tvector<int> query(int sup) {\n\t\tvector<int> res(sup - 1);\n\t\trep1(i, sup - 1) {\n\t\t\tfor (edge e : v[i]) {\n\t\t\t\tif (e.cap == 0 && e.to < 2 * sup - 1) {\n\t\t\t\t\tres[e.to - sup] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<int>> v(n-1);\n\trep(i, n - 1) {\n\t\tint sz; cin >> sz;\n\t\tv[i].resize(sz);\n\t\trep(j, sz) {\n\t\t\tcin >> v[i][j]; v[i][j]--;\n\t\t}\n\t}\n\tDinic dc(2*n+1);\n\tint s = 2 * n - 1; int t = s + 1;\n\trep1(i, n-1) {\n\t\tdc.addedge(s, i, 1);\n\t}\n\trep(i, n - 1) {\n\t\tdc.addedge(i + n, t, 1);\n\t}\n\t\n\trep(i, n - 1)rep(j, v[i].size()) {\n\t\tif(v[i][j]>0)dc.addedge(v[i][j],i + n, 1);\n\t}\n\tint f = dc.max_flow(s, t);\n\tif (f != n - 1) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tvector<vector<int>> loc(n);\n\trep(i, n - 1)rep(j, v[i].size()) {\n\t\tloc[v[i][j]].push_back(i);\n\t}\n\tvector<int> c = dc.query(n);\n\tvector<bool> used(n - 1, false);\n\tqueue<int> q; q.push(0);\n\tvector<P> ans(n - 1, { -1,-1 });\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tfor (int t : loc[id]) {\n\t\t\tif (used[t])continue;\n\t\t\tans[t] = { id,c[t] };\n\t\t\tused[t] = true;\n\t\t\tq.push(c[t]);\n\t\t}\n\t}\n\trep(i, n - 1)if (ans[i].first < 0) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\t\trep(i, n - 1) {\n\t\t\tcout << ans[i].first + 1 << \" \" << ans[i].second + 1 << \"\\n\";\n\t\t}\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//cout << grandy(2, 3, false, false) << \"\\n\";\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0)\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> chosen(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0 && eref[i][j].get())\n        chosen[i] = e[i][j];\n  }\n  vector<bool> vis(n);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = true;\n    for (int id : fnd[u])\n      if (chosen[id] != -1) {\n        int v = chosen[id];\n        chosen[id] = -1;\n        cout << (u + 1) << ' ' << (v + 1) << '\\n';\n        dfs(v);\n      }\n  };\n  dfs(0);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint n;\nvector<edge> G[200005];\nint S, T;\nllint level[200005], iter[200005];\n\nvector<llint> revG[200005];\nllint pred[200005], succ[200005];\nbool used[200005];\nvector<P> avec;\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nvoid dfs2(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tpred[revG[v][i]] = v;\n\t\tdfs2(succ[revG[v][i]]);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint c, w;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> w;\n\t\t\tadd_edge(i, n+w, 1);\n\t\t\trevG[w].push_back(i);\n\t\t}\n\t}\n\tS = 2*n+1, T = 2*n+2;\n\t\n\tfor(int i = 1; i <= n-1; i++) add_edge(S, i, 1);\n\tfor(int i = 1; i <= n; i++) add_edge(n+i, T, 1);\n\t\n\tllint ans = 0, flow;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(level[T] >= inf) break;\n\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\twhile(1){\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t}\n\tif(ans < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].to == S) continue;\n\t\t\tif(G[i][j].cap == 0) succ[i] = G[i][j].to-n;\n\t\t}\n\t}\n\tint r;\n\tfor(int i = 0; i < G[T].size(); i++){\n\t\tif(G[T][i].cap == 0){\n\t\t\tr = G[T][i].to-n;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdfs2(r);\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tif(pred[i] == 0 || succ[i] == 0){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcout << pred[i] << \" \" << succ[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+99,M=61e4;\ninline int min(const int&a,const int&b){return a<b?a:b;}\nstruct graph{\n\tstruct edge{int to,next,f;}e[M<<1];\n\tint h[N],cur[N],xb;\n\tinline void addedge(int x,int y,int z){\n\t\te[++xb]=(edge){y,h[x],z};h[x]=xb;\n\t\te[++xb]=(edge){x,h[y],0};h[y]=xb;\n\t}\n\tint S,T,d[N],n;\n\tinline bool bfs(){\n\t\tstatic int q[N];int t=0,w=1;q[1]=S;\n\t\tmemset(d+1,0,n<<2);d[S]=1;\n\t\tfor(;t<w;){\n\t\t\tint u=q[++t];\n\t\t\tfor(int i=h[u];i;i=e[i].next)if(e[i].f && !d[e[i].to])\n\t\t\t\td[e[i].to]=d[u]+1,q[++w]=e[i].to;\n\t\t}\n\t\treturn d[T];\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==T)return f;\n\t\tint ans=0,&i=cur[x],t;\n\t\tfor(;i;i=e[i].next)if(e[i].f && d[e[i].to]==d[x]+1){\n\t\t\tif(t=dfs(e[i].to,min(f,e[i].f))){\n\t\t\t\tans+=t,e[i].f-=t;e[i^1].f+=t;f-=t;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tinline int dinic(int s,int t){\n\t\tint ans=0;S=s;T=t;\n\t\tfor(;bfs();ans+=dfs(s,1<<30))memcpy(cur+1,h+1,n<<2);\n\t\treturn ans;\n\t}\n}g;\nint n,i,j,fa[N];\nvector<int>v[N],vv[N];\nvoid dfs(int x){\n\tauto t=v[x];v[x].clear();\n\tfor(int y:t)if(!fa[y])fa[y]=x,dfs(y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tg.n=n*2;g.xb=1;\n\tfor(i=2;i<=n;++i)g.addedge(n-2+i,g.n,1);\n\tfor(i=1;i<n;++i){\n\t\tscanf(\"%d\",&j);vv[i].resize(j);\n\t\tfor(int&x:vv[i]){scanf(\"%d\",&x);if(x>1)g.addedge(i,n-2+x,1);}\n\t\tg.addedge(g.n-1,i,1);\n\t}\n\tif(g.dinic(g.n-1,g.n)<n-1){puts(\"-1\");return 0;}\n\tfor(i=1;i<n;++i){\n\t\tfor(j=g.h[i];g.e[j].f;j=g.e[j].next);\n\t\tint x=g.e[j].to-(n-2);\n\t\tfor(int y:vv[i])if(y!=x)v[y].push_back(x);\n\t}\n\tdfs(1);\n\tfor(i=1,j=0;i<=n;++i)j+=!fa[i];\n\tif(j>1){puts(\"-1\");return 0;}\n\tfor(i=1;i<=n;++i)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\nusing namespace std;\nconst int N=1e5+5,M=2e6;\n\nint n,m,e,S,T,h,t,q[N],lev[N],ax[N],ay[N],o[N];\nint to[M],nx[M],cap[M],hd[N],it[N],sze=1;\nstd::vector<int> g[N];\n\nil void add(int u,int v,int c){to[++sze]=v,nx[sze]=hd[u],cap[sze]=c,hd[u]=sze;}\n\nil void ins(int u,int v,int c){add(u,v,c),add(v,u,0);}\n\nil int bfs()\n{\n\tmemset(lev,0,4*T+4); int i,u,v; q[h=t=lev[S]=1]=S;\n\twhile (h<=t) for (i=hd[u=q[h++]]; i; i=nx[i])\n        if (cap[i]&&!lev[v=to[i]]) lev[v]=lev[u]+1,q[++t]=v;\n\treturn lev[T];\n}\n\nil int dfs(int u,int f)\n{\n\tif (u==T) return f; int z,v,res=0;\n\tfor (int &i=it[u]; i; i=nx[i])\n\t\tif (lev[v=to[i]]==lev[u]+1&&cap[i]&&(z=dfs(v,min(f-res,cap[i]))))\n\t\t{\n\t\t\tcap[i]-=z,cap[i^1]+=z,res+=z;\n\t\t\tif (res==f) break;\n\t\t}\n\treturn res;\n}\n\nil int dinic()\n{\n\tint i,f,res=0;\n\twhile (bfs())\n    {\n        for (i=1; i<=T; i++) it[i]=hd[i];\n        while (f=dfs(S,1e9)) res+=f;\n    }\n\treturn res;\n}\n\nil int work()\n{\n    int i,u,v,s=0;\n    for (u=1; u<n; u++) for (i=hd[u]; i; i=nx[i])\n        if ((v=to[i])!=S&&!cap[i]) o[u]=v-n+1;\n    for (q[++t]=n; h<=t; )\n    {\n        u=q[h++],s++;\n        for (int v:g[u]) if (o[v])\n            ax[v]=u,ay[v]=o[v],q[++t]=o[v],o[v]=0; \n    }\n    return s==n;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),S=n+n-1,T=n+n; int i,c,x;\n    for (i=1; i<n; i++) ins(i+n-1,T,1);\n    for (i=1; i<n; i++)\n    {\n        scanf(\"%d\",&c),ins(S,i,1);\n        while (c--)\n        {\n            scanf(\"%d\",&x);\n            if (x!=n) ins(i,x+n-1,1);\n            g[x].push_back(i);\n        }\n    }\n\n    if (dinic()<n-1) return puts(\"-1\"),0;\n    if (!work()) return puts(\"-1\"),0;\n\tfor (i=1; i<n; i++) printf(\"%d %d\\n\",ax[i],ay[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i&&flow;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=800005;\nvector<int> bel[N];\nint cur[N],from[N],S,T,ne[N],a[N],b[N],dis[N],flag[N],x,y,n,m,fi[N],tot,zz[N],sl[N];\nqueue<int>Q;\nvoid jb(int x,int y,int z){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n\tsl[tot]=z;\n\tne[++tot]=fi[y];\n\tfi[y]=tot;\n\tzz[tot]=x;\n\tsl[tot]=0;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,-1,sizeof dis);\n\tdis[S]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]==-1){\n\t\t\t\tdis[zz[i]]=dis[now]+1;\n\t\t\t\tQ.push(zz[i]);\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&dis[zz[i]]==dis[x]+1&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\ty-=b;\n\t\t\ts+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=0;T=2*n;\n\ttot=1;\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tjb(S,i+n,1);\n\t\twhile (x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tjb(i+n,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)jb(i,T,1);\n\tint ans=0;\n\twhile (bfs()){\n\t\tfor (int i=S;i<=T;i++)cur[i]=fi[i];\n\t\tans+=dfs(S,1e9);\n\t}\n\tif (ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=fi[i+n];j;j=ne[j])\n\t\t\tif (zz[j]&&!sl[j]){\n\t\t\t\tflag[zz[j]]=1;\n\t\t\t\tb[i]=zz[j];\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])Q.push(i);\n\tans=0;\n\tmemset(flag,0,sizeof flag);\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tans++;\n\t\tfor (int i=0;i<bel[now].size();i++)\n\t\t\tif (!flag[bel[now][i]]){\n\t\t\t\tflag[bel[now][i]]=1;\n\t\t\t\ta[bel[now][i]]=now;\n\t\t\t\tQ.push(b[bel[now][i]]);\n\t\t\t}\n\t}\n\tif (ans!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nvoid cl(int i) {\n    set<int> o;\n    swap(o, q[i]);\n}\n\nvoid cel() {\n    set<pair<int, int> > o;\n    swap(g, o);\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++)\n        p[i] = i, r[i] = 0, cl(i);\n    cel();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < a[i].size(); j++)\n            q[a[i][j]].insert(i);\n        d[i] = a[i].size();\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            return;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n    exit(0);\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    double ts = clock();\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n    }\n    while ((clock() - ts) / CLOCKS_PER_SEC < 3.7) {\n        solve();\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < a[i].size(); j++)\n                swap(a[i][j], a[i][rnd() % (j + 1)]);\n    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nconst int inf = 1e9;\n\nstruct edge_t {\n\tint to, cap, flow;\n\tedge_t(int to = 0,int cap = 0) : to(to), cap(cap), flow(0) {}\n};\n\nint n;\nvector<edge_t> ed;\nvector<int> g[N];\nint src, snk;\nint d[N];\nint now[N];\nint par[N], match[N];\nbool visit[N];\nvector<int> has[N];\n\nvoid add(int u,int v,int cap) {\n\tg[u].push_back(ed.size()); ed.push_back(edge_t(v, cap));\n\tg[v].push_back(ed.size()); ed.push_back(edge_t(u, 0));\n}\n\nbool bfs() {\n\tfill(d, d + 2 * n + 5, -1);\n\tfill(now, now + 2 * n + 5, 0);\n\tqueue<int> q;\t \n\td[src] = 0; q.push(src);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int id : g[u]) {\n\t\t\tint v = ed[id].to;\n\t\t\tif (d[v] == -1 && ed[id].cap > ed[id].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[snk] != -1;\n}\n\nint dfs(int u,int flow) {\n\tif (u == snk) return flow;\n\tfor (int& i = now[u]; i < int(g[u].size()); ++i) {\n\t\tint id = g[u][i];\n\t\tint v = ed[id].to;\n\t\tif (d[v] != d[u] + 1 || ed[id].cap <= ed[id].flow) continue;\n\t\tint nxt = dfs(v, min(ed[id].cap - ed[id].flow, flow));\n\t\tif (nxt) {\n\t\t\ted[id].flow += nxt;\n\t\t\ted[id ^ 1].flow -= nxt;\n\t\t\treturn nxt;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\twhile (true) {\n\t\t\tint now = dfs(src, inf);\n\t\t\tif (now) {\n\t\t\t\tans += now;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int u) {\n\tvisit[u] = true;\n\tfor (int v : has[u]) if (visit[match[v]] == false) {\n\t\tpar[v] = u;\n\t\tsolve(match[v]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsrc = 0, snk = n + n + 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint u; scanf(\"%d\", &u);\n\t\twhile (u--) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\thas[v].push_back(i);\n\t\t\tif (v > 1) {\n\t\t\t\tadd(v, i + n, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tadd(src, i, 1);\n\t\tadd(i + n, snk, 1);\n\t}\n\tif (max_flow() != n - 1) {\n\t\tputs(\"-1\"); return 0;\n\t}\n\tfor (int u = 2; u <= n; ++u) {\n\t\tfor (int id : g[u]) {\n\t\t\tint v = ed[id].to;\n\t\t\tif (v && ed[id].cap == ed[id].flow) {\n\t\t\t\tmatch[v - n] = u; \n\t\t\t}\n\t\t}\n\t}\n\tsolve(1);\n\tif (accumulate(visit + 1, visit + n + 1, 0) < n) {\n\t\tputs(\"-1\"); return 0;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tprintf(\"%d %d\\n\", par[i], match[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 3e5 + 50, M = 2e6 + 50;\ncs int INF = 1e9 + 7;\nint n, S, T, fi[N], nxt[M], to[M], w[M], ec=1;\nvoid adde(int x, int y, int z){\n\tnxt[++ec]=fi[x], fi[x]=ec, to[ec]=y, w[ec]=z;\n\tnxt[++ec]=fi[y], fi[y]=ec, to[ec]=x, w[ec]=0;\n} int eu[N], ev[N], ct, d[N];\nbool bfs(){\n\tqueue<int> q; q.push(S); \n\tmemset(d,-1,sizeof(d)); d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x],v;e;e=nxt[e]) if(w[e]){\n\t\t\tv=to[e]; if(d[v]==-1){\n\t\t\t\td[v]=d[x]+1; q.push(v);\n\t\t\t\tif(v==T) return true;\n\t\t\t}\n\t\t}\n\t} return false;\n}\nint dfs(int u, int flw){\n\tif(u==T) return flw; int ans = 0;\n\tfor(int e=fi[u],v;e;e=nxt[e])\n\tif(d[v=to[e]]==d[u]+1){\n\t\tint dt=dfs(v,min(w[e],flw));\n\t\tans+=dt; flw-=dt;\n\t\tw[e]-=dt; w[e^1]+=dt; if(!flw) break;\n\t} if(flw) d[u]=-1; return ans;\n}\nint dinic(){ int flw = 0; while(bfs()) flw += dfs(S,INF); return flw; }\nint main(){\n\tfreopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1,k,x; i<n; i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1; j<=k; j++) \n\t\tscanf(\"%d\",&x), adde(x,i+n,1);\n\t} S=0, T=n+n;\n\tfor(int i=1; i<=n; i++) adde(S,i,1);\n\tfor(int i=1; i<n; i++) adde(i+n,T,1);\n\tint flw = dinic();\n\tif(flw < n-1) return puts(\"-1\"),0;\n\t\n\tstatic int tr[N];\n\tfor(int i=n+1; i<n+n; i++)\n\tfor(int e=fi[i];e;e=nxt[e]) \n\tif(to[e]!=T&&w[e]) tr[i]=to[e];\n\t\n\tqueue<int> q;\n\tfor(int e=fi[S];e;e=nxt[e])\n\tif(w[e]) q.push(to[e]);\n\t\n\tstatic bool ban[N];\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x];e;e=nxt[e]) \n\t\tif(to[e]!=S&&!ban[to[e]]){\n\t\t\teu[++ct]=x; ev[ct]=tr[to[e]];\n\t\t\tq.push(tr[to[e]]); ban[to[e]]=true;\n\t\t}\n\t} if(ct<n-1) return puts(\"-1\"),0;\n\tfor(int i=1; i<n; i++) cout<<eu[i]<<\" \"<<ev[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n    static const int S=1e7;\n    char rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n    fastio() {rpos=len=wpos=0;}\n    inline char Getchar()\n    {\n        if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n        if (!len) return EOF;\n        return rbuf[rpos++];\n    }\n    template <class T> inline void Get(T &x)\n    {\n        char ch;bool f;T res;\n        while (!isdigit(ch=Getchar()) && ch!='-') {}\n        if (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n        while (isdigit(ch=Getchar())) res=res*10+ch-'0';\n        x=(f?res:-res);\n    }\n    inline void getstring(char *s)\n    {\n        char ch;\n        while ((ch=Getchar())<=32) {}\n        for (;ch>32;ch=Getchar()) *s++=ch;\n        *s='\\0';\n    }\n    inline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n    inline void Writechar(char ch)\n    {\n        if (wpos==S) flush();\n        wbuf[wpos++]=ch;\n    }\n    template <class T> inline void Print(T x,char ch)\n    {\n        char s[20];int pt=0;\n        if (x==0) s[++pt]='0';\n        else\n        {\n            if (x<0) Writechar('-'),x=-x;\n            while (x) s[++pt]='0'+x%10,x/=10;\n        }\n        while (pt) Writechar(s[pt--]);\n        Writechar(ch);\n    }\n    inline void printstring(char *s)\n    {\n        int pt=1;\n        while (s[pt]!='\\0') Writechar(s[pt++]);\n    }\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=2e5;\n\nint n;\nvector<int> a[MAXN+48];\nvector<int> v[MAXN+48];\nint u[MAXN+48];\n\nbool inq[MAXN+48];\nint head,tail,q[MAXN+48];\nint ans[MAXN+48];\n\nnamespace flow\n{\n    int head[800048],cur[800048],to[800048],nxt[800048],f[800048],tot,t;\n    inline void init() {memset(head,0,sizeof(head));tot=1;}\n    inline void addedge(int s,int t,int cap)\n    {\n        to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap;\n        to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;\n    }\n    int q[800048],Head,Tail;int depth[800048];\n    inline bool bfs()\n    {\n        for (register int i=0;i<=t;i++) depth[i]=-1;\n        depth[0]=0;q[1]=0;Head=Tail=1;\n        while (Head<=Tail)\n        {\n            int x=q[Head++];\n            for (register int i=head[x];i;i=nxt[i])\n            {\n                int y=to[i];\n                if (depth[y]==-1 && f[i])\n                {\n                    depth[y]=depth[x]+1;\n                    q[++Tail]=y;\n                }\n            }\n        }\n        if (depth[t]==-1) return false; else return true;\n    }\n    inline int dfs(int x,int maxf)\n    {\n        if (x==t || !maxf) return maxf;\n        int y,minf,now,ans=0;\n        for (register int &i=cur[x];i;i=nxt[i])\n        {\n            y=to[i];\n            if (depth[y]==depth[x]+1 && f[i])\n            {\n                minf=min(maxf-ans,f[i]);\n                now=dfs(y,minf);\n                f[i]-=now;f[i^1]+=now;ans+=now;\n            }\n            if (ans>=maxf) return ans;\n        }\n        if (!ans) depth[x]=0;\n        return ans;\n    }\n    inline int dinic()\n    {\n        int ans=0;\n        while (bfs())\n        {\n            for (register int i=0;i<=t;i++) cur[i]=head[i];\n            ans+=dfs(0,INF);\n        }\n        return ans;\n    }\n}\n\nint main ()\n{\n#ifdef LOCAL\n    double TIME=clock();\n    freopen (\"a.in\",\"r\",stdin);\n    freopen (\"a.out\",\"w\",stdout);\n    cerr<<\"Running...\"<<endl;\n#endif\n    scanf(\"%d\",&n);int num,x;\n    for (register int i=1;i<=n-1;i++)\n    {\n        scanf(\"%d\",&num);\n        while (num--)\n        {\n            scanf(\"%d\",&x);\n            a[i].pb(x);v[x].pb(i);\n        }\n    }\n    flow::init();flow::t=n+n+1;\n    for (register int i=1;i<=n-1;i++) flow::addedge(0,i,1);\n    for (register int i=2;i<=n;i++) flow::addedge(n+i,flow::t,1);\n    for (register int i=1;i<=n-1;i++)\n        for (auto to : a[i]) if (to!=1) flow::addedge(i,n+to,1);\n    int res=flow::dinic();\n    if (res!=n-1) {puts(\"-1\");return 0;}\n    for (register int i=1;i<=n-1;i++)\n        for (register int j=flow::head[i];j;j=flow::nxt[j])\n        {\n            int y=flow::to[j];\n            if (n+2<=y && y<=n+n && flow::f[j]==0) {u[i]=y-n;break;}\n        }\n    memset(inq,false,sizeof(inq));head=1;tail=0;\n    for (auto item : v[1]) q[++tail]=item,q[++tail]=1,inq[item]=true;\n    while (head<=tail)\n    {\n        int cur=q[head++],father=q[head++];\n        ans[cur]=father;\n        for (auto item : v[u[cur]]) if (!inq[item]) inq[item]=true,q[++tail]=item,q[++tail]=u[cur];\n    }\n    for (register int i=1;i<=n-1;i++) if (!ans[i]) {puts(\"-1\");return 0;}\n    for (register int i=1;i<=n-1;i++) printf(\"%d %d\\n\",u[i],ans[i]);\n    io.flush();\n#ifdef LOCAL\n    cerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 210000\n#define MAXM 410000\n#define INF 2147483647\nusing namespace std;\ntemplate <typename T> inline void read(T &s)\n{\n\ts = 0;char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) s = ((s+(s<<2))<<1)+ch-'0',ch = getchar();\n}\nint hed[MAXN],ed[MAXM<<1],nxt[MAXM<<1],flow[MAXM<<1],tl=1,s,t,dep[MAXN],cur[MAXN],S,T,n,to[MAXN];\ninline void Line(int u,int v,int F)\n{\n\tnxt[++tl] = hed[u],hed[u] = tl,ed[tl] = v,flow[tl] = F;\n\tnxt[++tl] = hed[v],hed[v] = tl,ed[tl] = u,flow[tl] = 0;\n}\nqueue <int> Q;\nvector <int> In[MAXN];\ninline bool BFS(int s,int t)\n{\n\twhile(!Q.empty()) Q.pop();\n\tQ.push(s),memset(dep,0,sizeof(dep)),dep[s] = 1;\n\twhile(!Q.empty())\n\t{\n\t\tint k = Q.front();Q.pop();\n\t\tif(k == t) return 1;\n\t\tfor(int i = hed[k];i;i=nxt[i]) if(!dep[ed[i]] && flow[i])\n\t\t\tdep[ed[i]] = dep[k] + 1,Q.push(ed[i]);\n\t}\n\treturn 0;\n}\nint DFS(int u,int F,int t)\n{\n\tif(u == t) return F;\n\tfor(int fl,&i = cur[u];i;i=nxt[i]) if(flow[i] && dep[ed[i]] == dep[u] + 1)\n\t{\n\t\tif(fl = DFS(ed[i],min(F,flow[i]),t))\n\t\t\treturn flow[i] -= fl,flow[i^1] += fl,fl;\n\t}\n\treturn 0;\n}\ninline int Dinic(int s,int t)\n{\n\tint Sum = 0,tmp;\n\twhile(BFS(s,t))\n\t{\n\t\tmemcpy(cur,hed,sizeof(cur));\n\t\twhile(tmp = DFS(s,INF,t)) Sum += tmp;\n\t}\n\treturn Sum;\n}\nbool vis[MAXN];\nint fa[MAXN];\ninline void Check()\n{\n\twhile(!Q.empty()) Q.pop();\n\tQ.push(1);\n\tint Cnt = 0;\n\twhile(!Q.empty())\n\t{\n\t\tint k = Q.front();Q.pop(),Cnt++;\n\t\tfor(auto v:In[k]) if(!vis[v]) vis[v] = 1,Q.push(to[v]),fa[v] = k;\n\t}\n\tif(Cnt != n) return (void) (puts(\"-1\"));\n\tfor(int i = 1;i<n;++i) printf(\"%d %d\\n\",fa[i],to[i]);\n}\nint main()\n{\n\tread(n),S = 1,T = n * 2;\n\tfor(int i = 2;i<=n;++i) Line(S,i,1),Line(i+n-1,T,1);\n\tfor(int i = 1,El,X;i<n;++i)\n\t{\n\t\tread(El);\n\t\twhile(El--)\n\t\t{\n\t\t\tread(X),In[X].push_back(i);\n\t\t\tif(X != 1) Line(X,i+n,1);\n\t\t}\n\t}\n\tif(Dinic(S,T) != n-1) return puts(\"-1\"),0;\n\tfor(int i = 2;i<=n;++i) for(int j = hed[i];j;j=nxt[j]) if(flow[j]==0)\n\t\tto[ed[j]-n] = i;\n\tCheck();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nint main(){\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; cin >> x;\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; cin >> y; y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tvector<int> seen(n, -2);\n\tqueue<int> q;\n\tint st = -1;\n\tfor(int i = 0; i < n; i++) if(hop.pair_l[i] == -1) st = i;\n\tif(st == -1) bad();\n\tq.push(st); seen[st] = -1;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v : hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq.push(nv);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) cout << pu[i] + 1 << \" \" << pv[i] + 1 << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(dep[lb[y]]==dep[o]+1&&c[y])\n\tif(flow(lb[y])){\n\t\tc[y]=0;\n\t\tc[y^1]=1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[++oo][0]=o;\n\t\tbb[oo][1]=lb[y];\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cctype>\nconst int N=100007;\nstd::vector<int>e[N];std::queue<int>q;\nint vis[N],mat[N],tam[N];\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nint dfs(int u,int root)\n{\n    for(int v:e[u]) if(vis[v]^root) if(vis[v]=root,!mat[v]||dfs(mat[v],root)) return mat[v]=u;\n    return 0;\n}\nint main()\n{\n    int n=read();\n    for(int i=1;i<n;++i) for(int j=read();j;--j) e[read()].push_back(i);\n    for(int i=2;i<=n;++i) if(!dfs(i,i)) return puts(\"-1\"),0;\n    q.push(1);\n    for(int i=1,u;i<=n;++i)\n    {\n\tif(q.empty()) return puts(\"-1\"),0;\n\tu=q.front(),q.pop();\n\tfor(int v:e[u]) if(!tam[v]) tam[v]=u,q.push(mat[v]);\n    }\n    for(int i=1;i<n;++i) printf(\"%d %d\\n\",tam[i],mat[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nint cho1[MAXN+5],cho2[MAXN+5];\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\tint cnt=0;\n\twhile(!Q.empty()){\n\t\tcnt++;\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tcho1[s]=u,cho2[s]=ma[s];\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",cho1[i],cho2[i]);\n\treturn 0;\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[orig[1]]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int > q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\tfor(auto t:adj[s]){\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\ta[t.sc]=t.fs;\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\tmatch[btoa[i]]=1;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({btoa[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << a[i] << \" \" << b[i] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fa[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[dy[y]]) {\n\t\t\tfa[dy[y]] = x;\n\t\t\tdfs(dy[y]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 1) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline void solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\tsolve();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fa[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[y]) {\n\t\t\tfa[dy[y]] = x;\n\t\t\tdfs(y);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)  cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,maxm=1e6+10,inf=0x3f3f3f3f;\nint S,T,ans;\nstruct MAX_FLOW{\n\tint e,n,Begin[maxn],Next[maxm],to[maxm],w[maxm],d[maxn],cur[maxn];\n\tinline void add_edge(int x,int y,int z){\n\t\tto[++e]=y;\n\t\tNext[e]=Begin[x];\n\t\tBegin[x]=e;\n\t\tw[e]=z;\n\t}\n\tinline void add(int x,int y,int z){\n\t\tadd_edge(x,y,z),add_edge(y,x,0);\n\t}\n\tbool bfs(){\n\t\tREP(i,1,n) d[i]=-1;\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\td[S]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=Begin[u];i;i=Next[i]) if(w[i] && d[to[i]]==-1){\n\t\t\t\td[to[i]]=d[u]+1;\n\t\t\t\tif(to[i]==T) return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int x,int Min){\n\t\tif(!Min || x==T) return Min;\n\t\tint num,Flow=0;\n\t\tfor(int &i=cur[x];i;i=Next[i])\n\t\t\tif(w[i] && d[to[i]]==d[x]+1 && (num=dfs(to[i],min(Min,w[i])))){\n\t\t\t\tFlow+=num,Min-=num;\n\t\t\t\tw[i]-=num,w[i^1]+=num;\n\t\t\t\tif(!Min) break;\n\t\t\t}\n\t\treturn Flow;\n\t}\n\tvoid work(){\n\t\twhile(bfs()){\n\t\t\tREP(i,1,n) cur[i]=Begin[i];\n\t\t\tans+=dfs(S,inf);\n\t\t}\n\t}\n}MF;\nvector<int> ve[maxn],num[maxn];\nint vis[maxn],w[maxn],fr[maxn];\nstruct point{\n\tint x,y;\n}E[maxn];\nint main(){\n\tint n=read();\n\tMF.e=1;\n\tMF.n=2*n-1;\n\tS=++MF.n,T=++MF.n;\n\tREP(i,1,n-1){\n\t\tint m=read();\n\t\twhile(m--){\n\t\t\tint x=read();\n\t\t\tve[x].push_back(i);\n\t\t\tMF.add(i+n,x,1);\n\t\t\tnum[x].push_back(MF.e);\n\t\t}\n\t\tMF.add(S,i+n,1);\n\t}\n\tREP(i,2,n) MF.add(i,T,1);\n\tMF.work();\n\tif(ans!=n-1) return printf(\"-1\\n\"),0;\n\tREP(i,2,n) REP(j,0,ve[i].size()-1) if(MF.w[num[i][j]]) w[ve[i][j]]=i;\n\tqueue<int> q;\n\tint cnt=0;\n\tfor(auto v:ve[1]) vis[v]=1,q.push(v),fr[v]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tE[u]=(point){fr[u],w[u]};\n\t\t++cnt;\n\t\tfor(auto v:ve[w[u]]) if(!vis[v]) q.push(v),vis[v]=1,fr[v]=w[u];\n\t}\n\tif(cnt!=n-1) return printf(\"-1\\n\"),0;\n\tREP(i,1,n-1) printf(\"%d %d\\n\",E[i].x,E[i].y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nint p[N],fa[N];\nint get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}\npii ans[N];\nint la;\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n)fa[i]=i;\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(get(x)!=p[i]){\n                ans[++la]={x,p[i]},fa[p[i]]=x;\n                //printf(\"x=%d\\n\",x);\n                break;\n            }\n        }\n    }\n    if(la<n-1)return puts(\"-1\"),1;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace IO {\n\tconst int SIZE = 1 << 20;\n\tchar buf[SIZE + 10], *iS, *iT;\n\tinline char Getc() {\n\t\treturn iS == iT && (iT = (iS = buf) + fread(buf, 1, SIZE, stdin), iS == iT) ? EOF : *iS++;\n\t}\n\ttemplate <class TT>\n\tinline void Read(TT &x) {\n\t\tx = 0; register char cc = '\\0'; TT fff = 1;\n\t\tfor (; cc < '0' || cc > '9'; cc = Getc())\n\t\t\tif (cc == '-') fff = -1;\n\t\tfor (; cc >= '0' && cc <= '9'; cc = Getc())\n\t\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\t\tx *= fff;\n\t}\n}\nusing IO::Read;\n\nconst int N = 2e5 + 10, M = 1e6 + 10;\n\nvector<int> bel[N];\npair<int, int> bufans[N]; int ctnum, Connect[N]; bool vis[N];\nint n, tot, stp, edp, hd, tl, fans, Q[N + 10], dep[N], Cur[N], Head[N], Next[M], Adj[M], W[M];\n\ninline void Addedge(int x, int y, int z) {\n/*\n\tprintf(\"%d %d %d\\n\", x, y, z);\n*/\n\tNext[++tot] = Head[x]; Head[x] = tot; Adj[tot] = y; W[tot] = z;\n\tNext[++tot] = Head[y]; Head[y] = tot; Adj[tot] = x; W[tot] = 0;\n}\n\ninline bool BFS() {\n\tfill(dep, dep + 1 + edp, -1), hd = tl = 0;\n\tQ[++tl] = stp, dep[stp] = 0;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\tfor (int e = Head[x]; e; e = Next[e])\n\t\t\tif (W[e] > 0 && dep[Adj[e]] == -1) {\n\t\t\t\tdep[Adj[e]] = dep[x] + 1;\n\t\t\t\tQ[++tl] = Adj[e];\n\t\t\t}\n\t}\n\treturn dep[edp] != -1;\n}\n\nint DFS(int x, int mxflow) {\n\tif (x == edp || !mxflow) return mxflow;\n\tfor (int &e = Cur[x]; e; e = Next[e])\n\t\tif (W[e] > 0 && dep[Adj[e]] == dep[x] + 1) {\n\t\t\tint ntflow = DFS(Adj[e], min(mxflow, W[e]));\n\t\t\tif (ntflow > 0) {\n\t\t\t\tW[e] -= ntflow;\n\t\t\t\tW[e ^ 1] += ntflow;\n\t\t\t\treturn ntflow;\n\t\t\t}\n\t\t}\n\treturn 0; /* star! */\n}\n\ninline void Dinic() {\n\tfans = 0;\n\twhile (BFS()) {\n\t\tint nflow = 0;\n\t\tcopy(Head, Head + 1 + edp, Cur);\n\t\twhile ((nflow = DFS(stp, 0x3f3f3f3f)) != 0)\n\t\t\tfans += nflow;\n\t}\n}\n\ninline void Extend(int x) {\n\tfor (int j = 0; j < (int)bel[x].size(); ++j)\n\t\tif (!vis[bel[x][j]]) {\n\t\t\tbufans[bel[x][j] - n] = make_pair(x, Connect[bel[x][j]]);\n\t\t\tvis[bel[x][j]] = true, Q[++tl] = Connect[bel[x][j]];\n\t\t}\n}\n\ninline void Solve() {\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int e = Head[n + i]; e; e = Next[e])\n\t\t\tif (Adj[e] <= n && W[e] > 0)\n\t\t\t\tConnect[n + i] = Adj[e];\n\thd = tl = 0;\n\tQ[++tl] = 1;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\t++ctnum;\n\t\tExtend(x);\n\t}\n}\n\nint main()\n{\n\tRead(n), tot = 1 /* !!! */;\n\tstp = 2 * n, edp = 2 * n + 1;\n\tfor (int i = 2; i <= n; ++i) Addedge(stp, i, 1);\n\tfor (int i = 1; i < n; ++i) Addedge(n + i, edp, 1);\n\tfor (int i = 1, ilen; i < n; ++i) {\n\t\tRead(ilen);\n\t\tfor (int j = 1, x; j <= ilen; ++j) {\n\t\t\tRead(x);\n\t\t\tbel[x].push_back(n + i);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i)\n\t\tfor (int j = 0; j < (int)bel[i].size(); ++j /* not i */)\n\t\t\tAddedge(i, bel[i][j], 1);\n\tDinic();\n\tif (fans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tSolve();\n\tif (ctnum < n) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int j = 1; j < n; ++j)\n\t\tprintf(\"%d %d\\n\", bufans[j].first, bufans[j].second);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int MAXN = 100005;\nconst int MAXM = 100005;\n\nstruct bpm{\n\tvector<int> gph[MAXN];\n\tint dis[MAXN], l[MAXN], r[MAXM], vis[MAXN];\n\tvoid clear(){ for(int i=0; i<MAXN; i++) gph[i].clear();\t}\n\tvoid add_edge(int l, int r){ gph[l].push_back(r); }\n\tbool bfs(int n){\n\t\tqueue<int> que;\n\t\tbool ok = 0;\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(l[i] == -1 && !dis[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdis[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &i : gph[x]){\n\t\t\t\tif(r[i] == -1) ok = 1;\n\t\t\t\telse if(!dis[r[i]]){\n\t\t\t\t\tdis[r[i]] = dis[x] + 1;\n\t\t\t\t\tque.push(r[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tbool dfs(int x){\n\t\tif(vis[x]) return 0;\n\t\tvis[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(r[i] == -1 || (!vis[r[i]] && dis[r[i]] == dis[x] + 1 && dfs(r[i]))){\n\t\t\t\tl[x] = i; r[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match(int n){\n\t\tmemset(l, -1, sizeof(l));\n\t\tmemset(r, -1, sizeof(r));\n\t\tint ret = 0;\n\t\twhile(bfs(n)){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tfor(int i=0; i<n; i++) if(l[i] == -1 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool chk[MAXN + MAXM];\n\tvoid rdfs(int x, int n){\n\t\tif(chk[x]) return;\n\t\tchk[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tchk[i + n] = 1;\n\t\t\trdfs(r[i], n);\n\t\t}\n\t}\n\tvector<int> getcover(int n, int m){ // solve min. vertex cover\n\t\tmatch(n);\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor(int i=0; i<n; i++) if(l[i] == -1) rdfs(i, n);\n\t\tvector<int> v;\n\t\tfor(int i=0; i<n; i++) if(!chk[i]) v.push_back(i);\n\t\tfor(int i=n; i<n+m; i++) if(chk[i]) v.push_back(i);\n\t\treturn v;\n\t}\n\n}bpm;\n\nint n, M[MAXN];\nint proc[MAXN];\npi dap[MAXN];\n\nvector<int> E[MAXN];\nvector<int> R[MAXN];\nqueue<int> que;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tE[i].resize(s);\n\t\tfor(auto &j : E[i]){\n\t\t\tscanf(\"%d\",&j);\n\t\t\tR[j].push_back(i);\n\t\t\tif(j != 1) bpm.add_edge(i, j);\n\t\t}\n\t}\n\tint x = bpm.match(n + 1);\n\tif(x != n - 1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; i++) M[i] = bpm.l[i];\n\tque.push(1);\n\tvector<pi> edg;\n\twhile(!que.empty()){\n\t\tint x = que.front();\n\t\tque.pop();\n\t\tfor(auto &j : R[x]){\n\t\t\tif(proc[j]) continue;\n\t\t\tproc[j] = 1;\n\t\t\tdap[j] = pi(M[j], x);\n\t\t\tque.push(M[j]);\n\t\t}\n\t}\n\tfor(int i=1; i<n; i++) printf(\"%d %d\\n\", dap[i].first, dap[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dinic {\n    using F = int; const static F INF = 0x3f3f3f3f; \n    //using F = long long; const static F INF = 0x3f3f3f3f3f3f3f3f; \n    struct Edge {\n        int v, bro; F cap;\n        Edge() {}\n        Edge(int _v, int _bro, F _cap) : v(_v), bro(_bro), cap(_cap) {}\n    };\n    vector<Edge> e;\n    vector<int> pos, cur;\n    int n, s, t, m;\n    Dinic(int _n, int _s, int _t) : n(_n), s(_s), t(_t), m(0) {\n        pos.assign(n, -1);\n        cur.resize(n);\n        d.resize(n);\n        e.reserve(4e5);\n    }\n    void add(int u, int v, F c=INF) {\n        assert(u < n && v < n);\n        e.emplace_back(v, pos[u], c); pos[u] = m++;\n        e.emplace_back(u, pos[v], 0); pos[v] = m++;\n    }\n    vector<int> d;\n    // build layer graph\n    bool bfs() {\n        fill(d.begin(), d.end(), -1);\n        d[s] = 0;\n        queue<int> q; q.push(s);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = cur[u] = pos[u]; i != -1; i = e[i].bro) {\n                int v = e[i].v;\n                if (d[v] == -1 && e[i].cap != 0) {\n                    d[v] = d[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        return d[t] != -1;\n    }\n    // find blocking flow\n    F dfs(int u, F lim) {\n        if (u == t) return lim;\n        F tot = 0;\n        for (int& i = cur[u]; i != -1; i = e[i].bro) {\n            int v = e[i].v;\n            if (e[i].cap != 0 && d[v] == d[u] + 1) {\n                F flow = dfs(v, min(e[i].cap, lim-tot));\n                tot += flow;\n                e[i].cap -= flow;\n                e[i^1].cap += flow;\n                if (tot == lim) return lim;\n            }\n        }\n        return tot;\n    }\n    F flow() {\n        F res = 0;\n        while (bfs()) {\n            res += dfs(s, INF);\n        }\n        return res;\n    }\n};\n\nvoid solve() {\n    int n; cin >> n;\n    int S = 0, T = 2*n;\n    Dinic mf(T+1, S, T);\n    vector<vector<int>> g(n+1);\n    vector<int> left(n);\n    vector<bool> trk(n+1, false);\n    for (int i = 1; i < n; i++) {\n        int c; cin >> c;\n        for (int _ = 0; _ < c; _++) {\n            int x; cin >> x;\n            mf.add(x, n+i, 1);\n            g[x].push_back(i);\n        }\n    }\n\n    int root = n;\n    for (int i = 1; i <= n; i++) {\n        if (i != root) mf.add(S, i, 1);\n    }\n    for (int i = 1; i < n; i++) {\n        mf.add(n+i, T, 1);\n    }\n    if (mf.flow() != n-1) {\n        cout << -1; return;\n    }\n    for (int i = 1; i < n; i++) {\n        for (int p = mf.pos[n+i]; p != -1; p = mf.e[p].bro) {\n            if (mf.e[p].cap && mf.e[p].v <= n) {\n                left[i] = mf.e[p].v;\n            }\n        }\n    }\n\n    vector<int> pa(n);\n    function<void(int)> dfs = [&](int l){\n        trk[l] = true;\n        for (int r: g[l])if(!trk[left[r]]){\n            pa[r] = l;\n            dfs(left[r]);\n        }\n    };\n    dfs(root);\n    for (int i = 1; i <= n; i++) {\n        if (!trk[i]) {\n            cout << -1; return;\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        cout << pa[i] << ' ' << left[i] << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 4e5 + 10, maxm = maxn;\nint to[maxm], nxt[maxm], head[maxn], cap[maxm], e, dep[maxn], flow[maxm], vis[maxn], s, t;\npair<int, int> p[maxn];\n\nvoid add(int x, int y, int z)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0;\n}\n\nint bfs()\n{\n\tmemset(dep, 0, sizeof(dep));\n\tqueue<int> Q;\n\tdep[s] = 1; Q.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(!dep[v] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dep[t]) return 1;\n\treturn 0;\n}\n\nint dfs(int x, int a)\n{\n\tif(x == t || a == 0) return a;\n\tint FLOW = 0, f;\n\tfor(int i = head[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif(dep[v] == dep[x] + 1 && (f = dfs(v, min(a, cap[i] - flow[i]))) > 0)\n\t\t{\n\t\t\tFLOW += f;\n\t\t\ta -= f;\n\t\t\tflow[i] += f; flow[i ^ 1] -= f;\n\t\t\tif(!a) return FLOW;\n\t\t}\n\t}\n\treturn FLOW;\n}\n\nint main()\n{\n\n\tint n = read();\n\te = 1; s = 0; t = n + n;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint m = read();\n\t\tfor(int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\n\tfor(int i = 2; i <= n; ++i) add(s, i, 1);\n\tfor(int i = n + 1; i <= n + n - 1; ++i) add(i, t, 1);\n\n\twhile(bfs()) dfs(s, 0x3f3f3f3f);\n\tfor(int u = 2; u <= n; ++u)\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(cap[i] == flow[i] && to[i] != s)\n\t\t{\n\t//\t\tcout << u << ' ' << to[i] << endl;\n\t\t\tp[to[i]].x = u;\n\t\t}\n\n\tqueue<int> Q; Q.push(1);\n\tint fg = n - 1;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(to[i] != s && !vis[to[i]])\n\t\t\tp[to[i]].y = u, vis[to[i]] = 1, Q.push(p[to[i]].x), --fg;\n\t}\n\tif(fg) return puts(\"-1\"), 0;\n\n\tfor(int i = n + 1; i <= n + n - 1; ++i) printf(\"%d %d\\n\", p[i].x, p[i].y);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (int)(n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace mf {\n    static const int N = 5e5;\n    static const int M = 2e6 + 233;\n    static const int inf = 1e9;\n    struct E {\n\t\tint nxt, to, fl;\n    }e[M << 1];\n    int d[N], head[N], cur[N], e_cnt = 1;\n    int n, s, t;\n    inline void init(int _n, int _s, int _t) {\n\t\tn = _n; s = _s; t = _t;\n\t\tfill(head, head + n + 1, 0);\n\t\te_cnt = 1;\n    }\n    inline void add(int u, int v, int fl) {\n\t\te[++ e_cnt] = (E) {head[u], v, fl}; head[u] = e_cnt;\n    }\n    inline void link(int u, int v, int fl) {\n\t\tadd(u, v, fl); add(v, u, 0);\n    }\n    inline bool bfs(void) {\n\t\tqueue<int> q;\n\t\tfill(d, d + n + 1, -1);\n\t\td[s] = 0; q.push(s);\n\t\twhile(!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(int i = head[u]; i; i = e[i].nxt) if(e[i].fl) {\n\t\t\t\t\tint v = e[i].to;\n\t\t\t\t\tif(!~ d[v]) d[v] = d[u] + 1, q.push(v);\n\t\t\t\t}\n\t\t}\n\t\treturn d[t] != -1;\n    }\n    inline int dfs(int u, int f) {\n\t\tif(u == t || !f) return f;\n\t\tint used = 0, t;\n\t\tfor(int &i = cur[u]; i; i = e[i].nxt) if(e[i].fl) {\n\t\t\t\tint v = e[i].to;\n\t\t\t\tif(d[v] != d[u] + 1) continue;\n\t\t\t\tt = dfs(v, min(f - used, e[i].fl));\n\t\t\t\tused += t; e[i].fl -= t; e[i ^ 1].fl += t;\n\t\t\t\tif(used == f) break;\n\t\t\t}\n\t\tif(!used) d[u] = -1;\n\t\treturn used;\n    }\n    inline int doit(void) {\n\t\tint fl = 0;\n\t\twhile(bfs()) {\n\t\t\tmemcpy(cur, head, sizeof (int) * (n + 2));\n\t\t\tfl += dfs(s, inf);\n\t\t}\n\t\treturn fl;\n    }\n}\n\n#define GG (puts(\"-1\"), exit(0))\nconst int N = mf::N;\nint n, match[N], con[N];\nvector <int> adj[N];\n\nint main(void) {\n\tread(n);\n\tint S = n + n, T = S + 1;\n\tmf::init(T, S, T);\n\tfor (int i = 2; i <= n; i++) {\n\t\tint E = i + n - 1;\n\t\tmf::link(S, i, 1);\n\t\tmf::link(E, T, 1);\n\t\tint sz, x; read(sz);\n\t\twhile (sz--) {\n\t\t\tread(x);\n\t\t\tmf::link(x, E, 1);\n\t\t}\t\t\n\t}\n\tif (mf::doit() != n - 1) GG;\n\tfor (int i = 2; i <= mf::e_cnt; i += 2) {\n\t\tint u = mf::e[i ^ 1].to;\n\t\tint v = mf::e[i].to;\n\t\tif (!mf::e[i].fl && (2 <= u && u <= n)) {\n\t\t\tmatch[v] = u;\n\t\t} else {\n\t\t\tadj[u].push_back(v);\n\t\t}\n\t}\n\tqueue <int> Q;\n\tQ.push(1);\n\twhile (!Q.empty()) {\n\t\tint u = Q.front(); Q.pop();\n\t\tfor (int i : adj[u]) {\n\t\t\tif (con[i]) continue;\n\t\t\tcon[i] = u;\n\t\t\tQ.push(match[i]);\n\t\t}\n\t}\n\tfor (int i = n + 1; i <= n + n - 1; i++) {\n\t\tcout << con[i] << \" \" << match[i] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct Edge{\n\tint v,c,nxt;\n}e[1000010];int tot=1;\nint first[400010];\nvoid build(int u,int v,int c)\n{\n\te[++tot]=(Edge){v,c,first[u]};\n\tfirst[u]=tot;\n\treturn ;\n}\nvoid adde(int u,int v,int c)\n{\n\tbuild(u,v,c);\n\tbuild(v,u,0);\n\treturn ;\n}\nint dep[400010];\nint S,T;\nqueue<int>q;\nbool bfs()\n{\n\tfor(int i=1;i<=T;i++)\n\t\tdep[i]=0;\n\tq.push(S);dep[S]=1;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(e[i].c&&!dep[e[i].v])\n\t\t\t{\n\t\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\t\tq.push(e[i].v);\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint cur[400010];\nint dfs(int u,int flow)\n{\n\tif(u==T)return flow;\n\tfor(int &i=cur[u];i;i=e[i].nxt)\n\t\tif(e[i].c&&dep[e[i].v]==dep[u]+1)\n\t\t{\n\t\t\tint d=dfs(e[i].v,min(flow,e[i].c));\n\t\t\tif(d){\n\t\t\t\te[i].c-=d;\n\t\t\t\te[i^1].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=T;i++)\n\t\t\tcur[i]=first[i];\n\t\tint d;\n\t\twhile(d=dfs(S,1e9))\n\t\t\tans+=d;\n\t}\n\treturn ans;\n}\nvector<int>vec[100010];\nint tos[100010],ton[100010];\nint ansu[100010],ansv[100010];\nbool book[100010];\nvoid solve(int u)\n{\n\tbook[u]=true;\n\tfor(int i=0;i<vec[u].size();i++)\n\t{\n\t\tint v=vec[u][i];\n\t\tif(v==tos[u])continue;\n\t\tif(book[ton[v]])continue;\n\t\tansu[v]=u;\n\t\tansv[v]=ton[v];\n\t\tsolve(ton[v]);\n\t}\n\treturn ;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tS=n*2;T=n*2+1;\n\tfor(int i=1;i<=n;i++)\n\t\tadde(S,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadde(i+n,T,1);\n\t\tint num;scanf(\"%d\",&num);\n\t\twhile(num--)\n\t\t{\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tvec[u].push_back(i);\n\t\t\tadde(u,i+n,1);\n\t\t}\n\t}\n\tif(dinic()<n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint s=0;\n\tfor(int u=1;u<=n;u++)\n\t{\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(!e[i].c&&e[i].v>n&&e[i].v<S){\n\t\t\t\tint v=e[i].v-n;\n\t\t\t\ttos[u]=v;\n\t\t\t\tton[v]=u;\n\t\t\t}\n\t\tif(!tos[u])s=u;\n\t}\n\tsolve(s);\n\tfor(int i=1;i<n;i++)\n\t\tif(!ansu[i]){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",ansu[i],ansv[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[j]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //不能直接判f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t}\n\tfor(int i=n-1;i>=0;--i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(val[i]*e[i][j-1]>=mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 800008\n#define N 200002\nint A[N],B[M],C[M],F[N],S,T,a[N],b[M],c[M],e[N],h[N],l,n,q[N],r,t;bool D[N],d[M];\ninline void add(int u,int v){b[++t]=a[u],c[a[u]=t]=v,d[t]=true,b[++t]=a[v],c[a[v]=t]=u;}\ninline bool bfs()\n{\n\tmemset(h+1,-1,T<<2),*h=l=0,*q=S,r=1;\n\twhile(l<r)for(int u=q[l++],i=a[u];i;i=b[i])if(d[i]&&h[c[i]]<0)h[q[r++]=c[i]]=h[u]+1;\n\treturn h[T]>=0;\n}\nbool dfs(int u)\n{\n\tif(u==T)return true;\n\tfor(int&i=e[u];i;i=b[i])if(d[i]&&h[c[i]]==h[u]+1&&dfs(c[i]))return d[i]=false,d[i^1]=true;\n\treturn false; \n}\nvoid ans(int u)\n{\n\tD[u]=true;\n\tfor(int&i=A[u];i;i=B[i])if(!D[C[i]])t++,F[C[i]]=u,ans(C[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n),T=n<<1;\n\tfor(int i=t=1,u,v;i<n;i++)for(scanf(\"%d\",&u);u--;)scanf(\"%d\",&v),add(n+i,v);\n\tfor(int i=2;i<=n;i++)add(i,T);\n\tfor(int i=1;i<n;i++)add(S,n+i);\n\tfor(t=0;bfs();)for(memcpy(e,a,T+1<<2);dfs(S);t++);\n\tif(t!=n-1)return 0*puts(\"-1\");\n\tfor(int i=2;i<=n;i++)while(a[i]=b[a[i]])if(d[a[i]])e[c[a[i]]-n]=i;\n\tfor(int i=t=1;i<n;i++)while(a[n+i]=b[a[n+i]])if(d[a[n+i]])B[++t]=A[c[a[n+i]]],C[A[c[a[n+i]]]=t]=e[i];\n\tif(t=0,ans(1),t!=n-1)return 0*puts(\"-1\");\n\telse for(int i=1;i<n;i++)printf(\"%d %d\\n\",F[e[i]],e[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 1E5;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i)\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n///\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\nint vt[N*2],tim;\n\nbool bfs(){\n\ttim++;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tvt[st]=tim;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt){\n\t\t\tint y=e[p].x;\n\t\t\tif (vt[y]<tim&&e[p].f){\n\t\t\t\tvt[y]=tim;\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tque[++ta]=y;\n\t\t\t\tif (y==ed)return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn vt[ed]==tim;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&vt[e[p].x]==tim&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs()){\n\t\tint tmp=aug(st,INF);\n\t\twhile(tmp){\n\t\t\tret+=tmp;\n\t\t\ttmp=aug(st,INF);\n\t\t}\n\t}\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 5;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 1, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tif(Dinic() != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; bl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=2e5+5,M=N<<3;\n\nint t[M],f[M],nxt[M],lst[N],l;\n\nvoid add(int x,int y,int z) {\n\tt[++l]=y;f[l]=z;nxt[l]=lst[x];lst[x]=l;\n\tt[++l]=x;f[l]=0;nxt[l]=lst[y];lst[y]=l;\n}\n\nint n,S,T,q[N],dis[N],p[N],fa[N];\nvector<int> to[N];\n\nbool bfs() {\n\tfo(i,S,T) dis[i]=0;dis[S]=1;\n\tint i=0,j=1;q[1]=S;\n\twhile (i<j) \n\t\trep(k,q[++i]) \n\t\t\tif (f[k]&&!dis[t[k]]) {\n\t\t\t\tdis[t[k]]=dis[q[i]]+1;\n\t\t\t\tq[++j]=t[k];\n\t\t\t}\n\treturn dis[T];\n}\n\nint dinic(int x,int y) {\n\tif (x==T) return y;\n\tint now=0;\n\trep(i,x)\n\t\tif (f[i]&&dis[t[i]]==dis[x]+1) {\n\t\t\tint k=dinic(t[i],min(y,f[i]));\n\t\t\tf[i]-=k;f[i^1]+=k;\n\t\t\ty-=k;now+=k;\n\t\t\tif (!y) break;\n\t\t}\n\tif (!now) dis[x]=-1;\n\treturn now;\n}\n\nbool vis[N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x])\n\t\tif (!vis[p[y]]) {\n\t\t\tfa[y]=x;\n\t\t\tdfs(p[y]);\n\t\t}\n}\n\nint main() {\n\tn=read();S=0;T=n<<1;l=1;\n\tfo(i,1,n-1) {\n\t\tadd(S,i,1);\n\t\tint c=read();\n\t\tfo(j,1,c) {\n\t\t\tint x=read();\n\t\t\tif (x>1) add(i,x+n-1,1);\n\t\t\tto[x].push_back(i);\n\t\t}\n\t}\n\tfo(i,1,n) add(i+n-1,T,1);\n\tint ret=0;\n\twhile (bfs()) ret+=dinic(S,1);\n\tif (ret<n-1) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) rep(j,i) if (!f[j]&&t[j]) p[i]=t[j]-n+1;\n\tdfs(1);\n\tfo(i,1,n-1) if (!fa[i]) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005, inf = 0x3f3f3f3f;\n\nint n, s, t, head[N], cur[N], tot = 1, f[N];\nstruct edge { int to, nxt, rem; } e[N << 2];\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\n\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x], 1 }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y], 0 }, head[y] = tot;\n\tif (x != s && y != t) f[find(x)] = find(y);\n}\n\nint dis[N];\nbool bfs() {\n\tstd::memset(dis, 0, sizeof dis), dis[s] = 1;\n\tstd::queue<int> q; q.push(s);\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].rem && !dis[e[i].to])\n\t\t\t\tdis[e[i].to] = dis[tmp] + 1, q.push(e[i].to);\n\t}\n\treturn dis[t] > 0;\n}\nint dinic(int x, int low) {\n\tif (x == t || !low) return low;\n\tint ans = 0, t;\n\tfor (int &i = cur[x]; i; i = e[i].nxt)\n\t\tif (e[i].rem && dis[e[i].to] > dis[x] && (t = dinic(e[i].to, std::min(low, e[i].rem)))) {\n\t\t\te[i].rem -= t, e[i ^ 1].rem += t, low -= t, ans += t;\n\t\t\tif (!low) break;\n\t\t}\n\treturn ans;\n}\n\nstd::pair<int, int> ans[N];\nint E[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n, s = 0, t = 2 * n;\n\tfor (int i = 1; i < 2 * n; ++i) f[i] = i;\n\tfor (int i = 1, c, x; i < n; ++i) {\n\t\tstd::cin >> c, link(s, i + n);\n\t\twhile (c--) std::cin >> x, link(i + n, x);\n\t}\n\tfor (int i = 2; i <= n; ++i) link(i, t);\n\tfor (int i = 1; i < 2 * n; ++i) if (find(i) != find(1))\n\t\treturn std::cout << \"-1\\n\", 0;\n\tint sum = 0;\n\twhile (bfs()) std::memcpy(cur, head, sizeof head), sum += dinic(s, inf);\n\tif (sum < n - 1) return std::cout << \"-1\\n\", 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = head[i + n]; j; j = e[j].nxt)\n\t\t\tif (e[j].to != s && !e[j].rem) E[i] = e[j].to;\n\tstatic bool vis[N];\n\tstd::queue<int> q; q.push(1), vis[1] = 1;\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].to != t && !vis[E[e[i].to - n]]) {\n\t\t\t\tvis[E[e[i].to - n]] = 1, q.push(E[e[i].to - n]);\n\t\t\t\tans[e[i].to - n] = std::make_pair(tmp, E[e[i].to - n]);\n\t\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cout << ans[i].first << ' ' << ans[i].second << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 200002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[MAX_N], visited[MAX_N], rev[MAX_N];\nint source, target, d[MAX_N], f[MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    queue<int> qu;\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 400005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 10];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //不能直接判f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing db = double;\nusing vi = vector<int>;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x <<'\t' << x <<endl\n#else\n#define debug(x)\n#endif\nconst int inf = 0x3f3f3f3f;\nconst db eps = 1e-8;\nconst int mod = 1e9+7;\nll qpow(ll a, ll b){\n    ll ret = 1;\n    while(b){\n        if(b&1)ret = ret*a%mod;\n        a = a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nconst int maxn = 2e5 + 7;\nconst int INF = 0x3f3f3f3f;\nstruct Edge\n{\n    int from, to, cap, flow;\n};\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;\n    vector<int> G[maxn];\n    bool vis[maxn];\n    int d[maxn];\n    int cur[maxn];\n\n    void AddEdge(int from, int to, int cap, int c = 0)\n    {\n        edges.push_back(Edge{from, to, cap, 0});\n        edges.push_back(Edge{to, from, c, 0});\n        m = edges.size();\n        G[from].push_back(m - 2);\n        G[to].push_back(m - 1);\n    }\n\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> q;\n        q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i < G[u].size(); i++)\n            {\n                Edge &e = edges[G[u][i]];\n                if (!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n    int DFS(int u, int dist)\n    {\n        if (u == t || dist == 0)\n            return dist;\n        int flow = 0, f;\n        for (int &i = cur[u]; i < G[u].size(); i++)\n        {\n            Edge &e = edges[G[u][i]];\n            if (d[u] + 1 == d[e.to] && (f = DFS(e.to, min(dist, e.cap - e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[u][i] ^ 1].flow -= f;\n                flow += f;\n                dist -= f;\n                if (!dist)\n                    break;\n            }\n        }\n        return flow;\n    }\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while (BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        debug(flow);\n        return flow;\n    }\n    void print(){\n    \tfor(auto u:edges){\n    \t\tif(u.flow==0&&u.from>n)\n    \t\tcout << u.from << \" \"<< u.to <<\" \" << u.flow <<\"\\n\";\n\t\t}\n\t}\n}net;\nint n;\nbool vis1[maxn], vis2[maxn];\nint id[maxn], nxt[maxn];\nqueue<int>q;\nvector<int>G[maxn];\nbool solve(int n){\n\tfor(int i=1; i<n; ++i){\n\t\tcout <<\"begin :\" <<i <<endl;\n\t\tfor(auto v: net.G[n+i]){\t\n\t\t\tif(net.edges[v].to && !net.edges[v].flow){\n\t\t\t\tint u = net.edges[v].to;\n\t\t\t\tid[i] = u;\n\t\t\t\tvis1[u] = 1;\n\t\t\t\t\n\t\t\t\tdebug(u);break;\n\t\t\t}\t\n\t\t} \n\t\tcout <<\"end: \"<<i <<endl;\n\t}\n\tfor(int i=1; i<=n; ++i)if(!vis1[i])q.push(i);//, vis2[i]=1;\n\tint cnt =0;\n\tdebug(q.size());\n\twhile(!q.empty()){\n\t\tint x = q.front(); q.pop();\n\t\tcnt++;\n\t\tfor(auto v:G[x]){\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v] = 1;\n\t\t\t\tnxt[v] = x;\n\t\t\t\tq.push(id[v]);\n\t\t\t} \n\t\t}\n\t}debug(cnt);\n\treturn cnt==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tnet.n = n;\n\tnet.s = 0, net.t = 2*n;\n\tfor(int i=1; i<n; ++i){\n\t\tint x;cin >> x;\n\t\tnet.AddEdge(0, n+i, 1);\n\t\tfor(int j=0, u; j<x; ++j){\n\t\t\tcin >> u;\n\t\t\tnet.AddEdge(n+i, u, 1);\n\t\t\tG[u].pb(i);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tnet.AddEdge(i, 2*n, 1);\n\t}\n\tif(net.Maxflow(net.s, net.t)<n-1){\n\t\tcout <<\"-1\\n\";return 0;\n\t}\n\tnet.print();\n\tif(!solve(n)){\n\t\tcout <<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i)cout << id[i] <<\" \"<< nxt[i] <<\"\\n\";\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 400002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[MAX_N], visited[MAX_N], rev[MAX_N];\nint source, target, d[MAX_N], f[MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    queue<int> qu;\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &i : x) cin >> i;\n\t\ta.pb({x, i});\n\t}\n\tsort(all(a), [](auto i, auto j) {\n\t\treturn i.first.size() < j.first.size();\n\t});\n\trans.resize(n-1);\n\tdsu d(n);\n\tfor(auto [i, idx] : a) {\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 400050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn],gap[maxn];\nint cur[maxn],prt[maxn];\n\nint isap()\n{\n    for (int i=1;i<=vt;++i) cur[i]=head[i],++gap[d[i]=0];\n    int i=vs,ans=0;\n    while (d[vs]<vt)\n    {\n        if (i==vt)\n        {\n            for (++ans;i!=vs;i=edge[prt[i]^1])\n                // cout<<\"path:\"<<i<<endl,\n                --cost[prt[i]],++cost[prt[i]^1];\n            // cout<<\"path:\"<<vs<<endl<<endl;\n        }\n\n        bool flag=0;\n        for (int k=cur[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (cost[k]&&d[i]==d[j]+1)\n            {\n                flag=1;\n                cur[i]=prt[j]=k;\n                i=j;\n                break;\n            }\n        }\n\n        if (flag)   continue;\n\n        if (--gap[d[i]]==0) break;\n        d[i]=vt;\n        for (int k=head[i];~k;k=nxt[k])\n            if (cost[k]&&d[edge[k]]+1<d[i])\n                cur[i]=k,d[i]=d[edge[k]]+1;\n                // d[i]=min(d[i],d[edge[k]]+1);\n        ++gap[d[i]];\n        // cur[i]=head[i];\n        if (i!=vs)\n            i=edge[prt[i]^1];\n    }\n    // cout<<\"isap:\"<<ans<<endl;\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sort stable_sort\n#define all(x) (x).begin(),(x).end()\n#define rep(i,x) for (register int (i)=(1);(i)<=(x);(i)++)\n#define rep1(i,x,y) for (register int (i)=(x);(i)<=(y);(i)++)\n#define rep2(i,x) for (register int (i)=(x);(i)>=(1);(i)--)\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\nusing namespace std;\nint n,m,i,j,s=0,t=400001,dis[400005],lk[200005],fa[200005],cnt;\nvector<int> ss[200005],adj[200005];\nstruct edg\n{\n\tint y,z;\n}ee[2000005];\nvector<int> e[400005];\nvoid add(int x,int y,int z)\n{\n\tcnt++;\n\tee[cnt*2-2]=(edg){y,z};\n\tee[cnt*2-1]=(edg){x,0};\n\te[x].pb(cnt*2-2);e[y].pb(cnt*2-1);\n}\nbool bfs(int s,int t)\n{\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[s]=0;queue<int> qx;qx.push(s);\n\twhile(!qx.empty()){\n\t\tint x=qx.front();qx.pop();\n\t\tforeach(it,e[x])if(ee[*it].z&&dis[ee[*it].y]>dis[x]+1){\n\t\t\tdis[ee[*it].y]=dis[x]+1;\n\t\t\tqx.push(ee[*it].y);\n\t\t}\n\t}\n\treturn dis[t]<dis[t+1];\n}\nint dfs(int x,int tt,int flw)\n{\n\tif(!flw||x==tt)return flw;\n\tint ans=0;\n\tforeach(it,e[x])if(ee[*it].z&&dis[ee[*it].y]==dis[x]+1){\n\t\tint t=dfs(ee[*it].y,tt,min(flw,ee[*it].z));\n\t\tans+=t;flw-=t;\n\t\tee[*it].z-=t;ee[(*it)^1].z+=t;\n\t}\n\treturn ans;\n}\nint dinic(int s,int t)\n{\n\tint ans=0;\n\twhile(bfs(s,t)){\n\t\tans+=dfs(s,t,0x3f3f3f3f);\n\t}\n\treturn ans;\n}\nvoid dfs2(int x)\n{\n\tforeach(it,adj[x]){\n\t\tif(!fa[*it]){\n\t\t\tfa[*it]=x;\n\t\t\tdfs2(*it);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n-1){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\twhile(x--){\n\t\t\tint y;\n\t\t\tscanf(\"%d\",&y);\n\t\t\tss[i].push_back(y);\n\t\t\tif(y!=1){\n\t\t\t\tadd(y,i+n,1);\n\t\t\t}\n\t\t}\n\t}\n\trep1(i,2,n) add(s,i,1);\n\trep(i,n-1) add(i+n,t,1);\n\tif(dinic(s,t)!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<cnt*2;i+=2){\n\t\tif(2<=ee[i].y&&ee[i].y<=n&&n<ee[i^1].y&&ee[i^1].y<n+n&&ee[i].z){\n\t\t\tlk[ee[i^1].y-n]=ee[i].y;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tforeach(it,ss[i])if(*it!=lk[i]){\n\t\t\tadj[*it].pb(lk[i]);\n\t\t}\n\t}\n\tfa[1]=1;\n\tdfs2(1);\n\trep1(i,2,n)if(!fa[i]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,n-1) printf(\"%d %d\\n\",lk[i],fa[lk[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2], Q[Max_N];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tQ[Q[0] = 1] = 1;\n\t\tfor (int u, ft = 1;ft <= Q[0];)\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = 0, t;i < In[u].size();++i)\n\t\t\t\tif (!done[t = In[u][i]])\n\t\t\t\t{\n\t\t\t\t\tdone[t] = true;\n\t\t\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), Q[++Q[0]] = v;\n\t\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);h=t=0;q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)return used++,c[i]--,c[i^1]++,pre[a[i]]=x,1; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing db = double;\nusing vi = vector<int>;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x <<'\t' << x <<endl\n#else\n#define debug(x)\n#endif\nconst int inf = 0x3f3f3f3f;\nconst db eps = 1e-8;\nconst int mod = 1e9+7;\nll qpow(ll a, ll b){\n    ll ret = 1;\n    while(b){\n        if(b&1)ret = ret*a%mod;\n        a = a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nconst int maxn = 2e5 + 7;\nconst int INF = 0x3f3f3f3f;\n/*\nstruct Edge\n{\n    int from, to, cap, flow;\n};\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;\n    vector<int> G[maxn];\n    bool vis[maxn];\n    int d[maxn];\n    int cur[maxn];\n\n    void AddEdge(int from, int to, int cap, int c = 0)\n    {\n        edges.push_back(Edge{from, to, cap, 0});\n        edges.push_back(Edge{to, from, c, 0});\n        m = edges.size();\n        G[from].push_back(m - 2);\n        G[to].push_back(m - 1);\n    }\n\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> q;\n        q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i < G[u].size(); i++)\n            {\n                Edge &e = edges[G[u][i]];\n                if (!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n    int DFS(int u, int dist)\n    {\n        if (u == t || dist == 0)\n            return dist;\n        int flow = 0, f;\n        for (int &i = cur[u]; i < G[u].size(); i++)\n        {\n            Edge &e = edges[G[u][i]];\n            if (d[u] + 1 == d[e.to] && (f = DFS(e.to, min(dist, e.cap - e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[u][i] ^ 1].flow -= f;\n                flow += f;\n                dist -= f;\n                if (!dist)\n                    break;\n            }\n        }\n        return flow;\n    }\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while (BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        debug(flow);\n        return flow;\n    }\n    void print(){\n    \tfor(auto u:edges){\n    \t\tif(u.flow==0&&u.from>n)\n    \t\tcout << u.from << \" \"<< u.to <<\" \" << u.flow <<\"\\n\";\n\t\t}\n\t}\n}net;*/\n#define maxn 250000\n#define INF 0x3f3f3f3f\n\nstruct Edge {\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\n\nstruct Dinic {\n  int n, m, s, t;\n  vector<Edge> edges;\n  vector<int> G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) {\n    for (int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  }\n\n  bool BFS() {\n    memset(vis, 0, sizeof(vis));\n    queue<int> Q;\n    Q.push(s);\n    d[s] = 0;\n    vis[s] = 1;\n    while (!Q.empty()) {\n      int x = Q.front();\n      Q.pop();\n      for (int i = 0; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i]];\n        if (!vis[e.to] && e.cap > e.flow) {\n          vis[e.to] = 1;\n          d[e.to] = d[x] + 1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return vis[t];\n  }\n\n  int DFS(int x, int a) {\n    if (x == t || a == 0) return a;\n    int flow = 0, f;\n    for (int& i = cur[x]; i < G[x].size(); i++) {\n      Edge& e = edges[G[x][i]];\n      if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {\n        e.flow += f;\n        edges[G[x][i] ^ 1].flow -= f;\n        flow += f;\n        a -= f;\n        if (a == 0) break;\n      }\n    }\n    return flow;\n  }\n\n  int Maxflow(int s, int t) {\n    this->s = s;\n    this->t = t;\n    int flow = 0;\n    while (BFS()) {\n      memset(cur, 0, sizeof(cur));\n      flow += DFS(s, INF);\n    }\n    return flow;\n  }\n}net;\nint n;\nbool vis1[maxn], vis2[maxn];\nint id[maxn], nxt[maxn];\nqueue<int>q;\nvector<int>G[maxn];\nbool solve(int n){\n\tfor(int i=1; i<n; ++i){\n\t//\tcout <<\"begin :\" <<i <<endl;\n\t\tfor(auto v: net.G[n+i]){\t\n\t\t\tif(net.edges[v].to && net.edges[v].flow>0){\n\t\t\t\tint u = net.edges[v].to;\n\t\t\t\tid[i] = u;\n\t\t\t\tvis1[u] = 1;\n\t\t\t\t\n\t\t\t\tdebug(u);//break;\n\t\t\t}\t\n\t\t} \n\t//\tcout <<\"end: \"<<i <<endl;\n\t}\n\tfor(int i=1; i<=n; ++i)if(!vis1[i])q.push(i);//, vis2[i]=1;\n\tint cnt =0;\n\tdebug(q.size());\n\twhile(!q.empty()){\n\t\tint x = q.front(); q.pop();\n\t\tcnt++;\n\t\tfor(auto v:G[x]){\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v] = 1;\n\t\t\t\tnxt[v] = x;\n\t\t\t\tq.push(id[v]);\n\t\t\t} \n\t\t}\n\t}debug(cnt);\n\treturn cnt==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tnet.n = n;\n\tnet.s = 0, net.t = 2*n;\n\tfor(int i=1; i<n; ++i){\n\t\tint x;cin >> x;\n\t\tnet.AddEdge(0, n+i, 1);\n\t\tfor(int j=0, u; j<x; ++j){\n\t\t\tcin >> u;\n\t\t\tnet.AddEdge(n+i, u, 1);\n\t\t\tG[u].pb(i);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tnet.AddEdge(i, 2*n, 1);\n\t}\n\tif(net.Maxflow(net.s, net.t)<n-1){\n\t\tcout <<\"-1\\n\";return 0;\n\t}\n//\tnet.print();\n\tif(!solve(n)){\n\t\tcout <<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i)cout << id[i] <<\" \"<< nxt[i] <<\"\\n\";\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200100,MAXM=1000100,INF=0x3f3f3f3f;\nstruct Edge\n{\n\tint to,val,nxt;\n\tinline Edge() {}\n\tinline Edge(register int to,register int val,register int nxt):to(to),val(val),nxt(nxt) {}\n};\nEdge e[MAXM];\nint head[MAXN],S,T,cnt;\nint d[MAXN],cur[MAXN];\nint vis1[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];\nint N;\nqueue<int> q,q_;\nvector<int> bel[MAXN];\ninline void Addedge(register int x,register int y,register int z)\n{\n\te[++cnt]=Edge(y,z,head[x]),head[x]=cnt;\n\te[++cnt]=Edge(x,0,head[y]),head[y]=cnt;\n\treturn;\n}\ninline bool bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tmemset(d,-1,sizeof(d));\n\td[S]=0,cur[S]=head[S],q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tregister int now=q.front(); q.pop();\n\t\tfor(register int i=head[now];i;i=e[i].nxt)\n\t\t\tif(e[i].val&&!(~d[e[i].to]))\n\t\t\t{\n\t\t\t\tregister int to=e[i].to;\n\t\t\t\td[to]=d[now]+1,cur[to]=head[to];\n\t\t\t\tif(to==T) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(register int now,register int num)\n{\n\tif(now==T||!num) return num;\n\tregister int ans=0;\n\tfor(register int i=cur[now];i;i=e[i].nxt)\n\t\tif(e[i].val&&d[e[i].to]==d[now]+1)\n\t\t{\n\t\t\tregister int to=e[i].to,f=dfs(to,min(num,e[i].val));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\te[i].val-=f,e[i^1].val+=f;\n\t\t\t\tans+=f,num-=f;\n\t\t\t\tif(!num) break;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\ninline int maxflow()\n{\n\tregister int ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\ninline bool solve(register int n)\n{\n\tfor(register int i=1;i<n;i++)\n\t\tfor(register int j=head[n+i];j;j=e[j].nxt)\n\t\t\tif(e[j].to&&!e[j].val) id[i]=e[j].to,vis1[e[j].to]=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis1[i]) q_.push(i);\n\tregister int cnt_=0;\n\twhile(!q_.empty())\n\t{\n\t\tregister int now=q_.front(); q_.pop();\n\t\tcnt_++;\n\t\tfor(register int i=0;i<(int)bel[now].size();i++)\n\t\t\tif(!vis2[bel[now][i]]) vis2[bel[now][i]]=1,nxt[bel[now][i]]=now,q_.push(id[bel[now][i]]);\n\t}\n\treturn cnt_==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>N;\n\tS=0,T=N<<1;\n\tfor(register int i=1,x,y;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\tAddedge(S,N+i,1);\n\t\tfor(register int j=1;j<=x;j++) cin>>y,Addedge(N+i,y,1),bel[y].push_back(i);\n\t}\n\tfor(register int i=1;i<=N;i++) Addedge(i,T,1);\n\tif(maxflow()<N-1) return puts(\"-1\"),0;\n\tif(!solve(N)) return puts(\"-1\"),0;\n\tfor(register int i=1;i<N;i++) cout<<id[i]<<\" \"<<nxt[i]<<\"\\n\";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//存\n#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0),dis[i]=2;\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0),dis[i]=1;\n\tn<<=1;int ans=0;\n\tdis[T]=0;dis[S]=3;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nusing ld = long double;\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n};\n\nvoid dfs(int v, vector<set<int>>& g, vector<int>& ord) {\n    for(auto adj: g[v]) {\n        if(ord[adj] == inf) {\n            ord[adj] = ord[v] + 1;\n            dfs(adj, g, ord);\n        }\n    }\n    return;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<int>> w(n - 1);\n    HopcroftKarp hk(n, n - 1);\n    REP(i, n - 1) {\n        int c;\n        cin >> c;\n        vector<int> v(c);\n        REP(j, c) {\n            cin >> v[j];\n            v[j]--;\n            hk.add_edge(v[j], i);\n        }\n        w[i] = v;\n    }\n    int mx = hk.bipartite_matching();\n    if(mx <= n - 2) {\n        cout << -1 << endl;\n        return 0;\n    }\n    set<int> unused;\n    REP(i, n) unused.insert(i);\n    vector<pair<int, int>> ans(n - 1);\n    vector<set<int>> g(n);\n    REP(i, n - 1) {\n        unused.erase(hk.match[i]);\n        ans[i].first = hk.match[i];\n        for(auto elm: w[i]) {\n            if(elm == hk.match[i]) continue;\n            g[elm].insert(hk.match[i]);\n        }\n    }\n    int root = *(unused.begin());\n    vector<int> ord(n, inf);\n    ord[root] = 0;\n    dfs(root, g, ord);\n    REP(i, n) if(ord[i] == inf) {\n        cout << -1 << endl;\n        return 0;\n    }\n    REP(i, n - 1) {\n        for(auto elm: w[i]) {\n            if(ord[elm] < ord[hk.match[i]]) {\n                ans[i].second = elm;\n                break;\n            }\n        }\n    }\n    REP(i, n - 1) {\n        cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 1e5+5;\n\ntypedef ll Flow;\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\n\nstruct PushRelabel {\n\tvector<vector<Edge>> g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\n\nint n, m[MAXN], r[MAXN];\nvector<int> e[MAXN], g[MAXN];\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tPushRelabel mf(2*n+1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tmf.add_edge(0, i+1, 1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tmf.add_edge(i+1, x+n, 1);\n\tfor (int i = n; i < 2*n; ++i)\n\t\tmf.add_edge(i, 2*n, 1);\n\tint fl = mf.maxflow(0, 2*n);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tauto h = mf.g;\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 1) {\n\t\t\t\tm[i] = e.dest-n;\n\t\t\t\tr[e.dest-n] = i;\n\t\t\t\ts -= (e.dest - n);\n\t\t\t\t// cout << i << ' ' << m[i]+1 << endl;\n\t\t\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 0) {\n\t\t\t\t// cout << e.dest - n << ' ' << m[i] << endl;\n\t\t\t\tg[e.dest - n].push_back(m[i]);\n\t\t\t}\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 210000\n\nint n;\nvector <int> S[N];\nint fa[N], tx[N], u[N], v[N];\n\nint gf(int k) {\n\tif (fa[k] != k)\n\t\tfa[k] = gf(fa[k]);\n\treturn fa[k];\n}\n\nvoid doit() {\n\tfor (int i = 1; i < n; i++)\n\t\ttx[i] = i;\n\trandom_shuffle(tx, tx + n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfa[i] = i;\n\tfor (int i = 1; i < n; i++) {\n\t\tbool ok = false;\n\t\tfor (int j = 1; j < (int) S[tx[i]].size(); j++)\n\t\t\tif (gf(S[tx[i]][0]) != gf(S[tx[i]][j]))\n\t\t\t\tok = true;\n\t\tif (!ok)\n\t\t\treturn ;\n\t\twhile (true) {\n\t\t\tint x = S[tx[i]][rand() % S[tx[i]].size()];\n\t\t\tint y = S[tx[i]][rand() % S[tx[i]].size()];\n\t\t\tif (gf(x) != gf(y)) {\n\t\t\t\tu[tx[i]] = x;\n\t\t\t\tv[tx[i]] = y;\n\t\t\t\tfa[gf(x)] = gf(y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\texit(0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tS[i].push_back(v);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 100; i++) {\n\t\tdoit();\n\t}\n\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nvoid init(){\n\tqueue<int> Q;\n\t++u[d[t]=1];Q.push(t);\n\twhile(!Q.empty()){\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=fr[x];i;i=nex[i])if(wi[i]&&!d[vi[i]]){\n\t\t\t++u[d[vi[i]]=d[x]+1];Q.push(vi[i]);\n\t\t}\n\t}\n}\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]]==0)d[s]=t+3;else ++u[++d[x]];\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;init();\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\treturn 0;\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define N 500001\nusing namespace std;\nint n,du[N];\nvector<int>point[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tpoint[i].resize(p+1);\n\t\tpoint[i][0]=p;\n\t\tfor (int j=1;j<=p;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpoint[i][j]=x;\n\t\t\tdu[x]++;\n\t\t}\n\t}\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint times=0;\n\t\tfor (int j=1;j<=point[i][0];j++)\n\t\t{\n\t\t\tif (du[point[i][j]]==1) times++;\n\t\t}\n\t\tif (times>1)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int maxn = 100100;\nint seen[maxn], q[maxn];\nint main(){\n\tint n; scanf(\"%d\", &n);\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; scanf(\"%d\", &x);\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; scanf(\"%d\", &y); y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tint st = -1, tp = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(hop.pair_l[i] == -1) st = i;\n\t\tseen[i] = -2;\n\t}\n\tif(st == -1) bad();\n\tq[tp++] = st; seen[st] = -1;\n\tfor(int tu = 0; tu < tp; tu++){\n\t\tint u = q[tu];;\n\t\tfor(int v :hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq[tp++] = nv;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) \n\t\tprintf(\"%d %d\\n\", pu[i] + 1, pv[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=210000,V=301000,E=2010000;\nint s,t,vtot,n,vis[N],pl[N],pr[N];\nvector<PII> ed[N];\nvector<pair<int,PII>> ans;\nVI eg[N];\nstruct edge{int v,ne;ll f;}e[E*2];int g[V],et;\nvoid ae(int u,int v,ll f){\n\te[et]={v,g[u],f};g[u]=et++;\n\te[et]={u,g[v],0};g[v]=et++;\n}\nint d[V],cu[V];\nbool lb(){\n\trep(i,0,vtot)d[i]=0,cu[i]=g[i];\n\tstatic int qu[V];\n\tint p=0,q=0;\n\tqu[q++]=s,d[s]=1;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].ne)if(e[i].f && !d[e[i].v]){\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tif(e[i].v==t)return 1;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}return 0;\n}\nll aug(int u,ll m){\n\tif(u==t)return m;\n\tll su=0,f;\n\tfor (int i=cu[u];~i;cu[u]=i=e[i].ne)if(e[i].f && d[e[i].v]==d[u]+1){\n\t\tf=aug(e[i].v,min(m,e[i].f));\n\t\te[i].f-=f; e[i^1].f+=f;\n\t\tm-=f; su+=f;\n\t\tif(!m)break;\n\t}\n\tif(!su)d[u]=-1;\n\treturn su;\n}\nll dinic(){\n\tll su=0;\n\twhile(lb())su+=aug(s,1<<30);\n\treturn su;\n}\nvoid init(){\n\trep(i,0,vtot)g[i]=-1;\n\tet=0;\n}\n\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (auto v:eg[u]) if (v!=pr[u]&&!vis[pl[v]]) {\n\t\tans.pb(mp(v,mp(u,pl[v])));\n\t\tdfs(pl[v]);\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\ts=2*n-1, t=2*n;\n\tvtot=2*n+1;\n\tinit();\n\trep(i,0,n-1) {\n\t\tae(n+i,t,1);\n\t\tint t,x;\n\t\tscanf(\"%d\",&t);\n\t\trep(j,0,t) {\n\t\t\tscanf(\"%d\",&x);\n\t\t\t--x;\n\t\t\ted[i].pb(mp(et,x));\n\t\t\teg[x].pb(i);\n\t\t\tae(x,n+i,1);\n\t\t}\n\t}\n\trep(i,0,n) ae(s,i,1);\n\tint w=dinic();\n\tif (w!=n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,0,n) pr[i]=-1;\n\trep(i,0,n-1) {\n\t\tfor (auto p:ed[i]) {\n\t\t\tif (e[p.fi].f==0) {\n\t\t\t\tpl[i]=p.se;\n\t\t\t\tpr[p.se]=i;\n\t\t\t}\n\t\t}\n\t}\n\tint rt=-1;\n\trep(i,0,n) if (pr[i]==-1) {\n\t\trt=i;\n\t}\n\tdfs(rt);\n\tif (SZ(ans)!=n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsort(all(ans));\n\tfor (auto p:ans) {\n\t\tprintf(\"%d %d\\n\",p.se.fi+1,p.se.se+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint n;\nstruct data{\n    int to,nxt,c;\n}mp[1000100];\nint head[500500],cnt=1;\nint cur[500500];\nvoid link(int x,int y,int c)\n{\n    mp[++cnt].to=y;\n    mp[cnt].nxt=head[x];\n    mp[cnt].c=c;\n    head[x]=cnt;\n}\nvoid add(int x,int y,int c){link(x,y,c);link(y,x,0);}\nint s,t;\nint dis[500500];\nqueue<int>q;\nbool BFS()\n{\n    for(int i=0;i<=t;++i)dis[i]=0;\n    dis[s]=1;q.push(s);\n    int u,v;\n    while(!q.empty())\n    {\n        u=q.front();q.pop();\n        for(int i=head[u];i;i=mp[i].nxt)\n            if(mp[i].c&&!dis[mp[i].to])\n            {\n                v=mp[i].to;\n                q.push(v);\n                dis[v]=dis[u]+1;\n            }\n    }\n    return dis[t];\n}\nint dfs(int x,int f)\n{\n    if(x==t)return f;\n    int rf=0,fl;\n    for(int& i=cur[x];i;i=mp[i].nxt)\n        if(mp[i].c&&dis[mp[i].to]==dis[x]+1)\n        {\n            fl=dfs(mp[i].to,min(mp[i].c,f));\n            if(fl)\n            {\n                f-=fl;\n                rf+=fl;\n                mp[i].c-=fl;\n                mp[i^1].c+=fl;\n                if(!f)break;\n            }\n        }\n    return rf;\n}\nint Dinic()\n{\n    int maxflow=0,flow;\n    while(BFS())\n    {\n        for(int i=1;i<=t;++i)cur[i]=head[i];\n        while(flow=dfs(s,inf))maxflow+=flow;\n    }\n    return maxflow;\n}\n\nvector<int>bel[100100];\nint par[100100];\nbool book[100100];\nint ed[100100][2],ted;\nvoid solve()\n{\n    int x,v;\n    for(x=2;x<=n;++x)\n    {\n        for(int i=head[x];i;i=mp[i].nxt)\n            if(mp[i].to>n&&mp[i].to<n*2&&!mp[i].c)\n                par[mp[i].to-n]=x;\n    }\n    q.push(1);\n    int siz;\n    while(!q.empty())\n    {\n        x=q.front();q.pop();\n        siz=bel[x].size();\n        for(int i=0;i<siz;++i)\n            if(!book[par[bel[x][i]]])\n            {\n                v=par[bel[x][i]];\n                book[v]=1;\n                q.push(v);\n                ed[++ted][0]=x;\n                ed[ted][1]=v;\n            }\n    }\n    if(ted!=n-1)puts(\"-1\"),exit(0);\n    for(int i=1;i<n;++i)printf(\"%d %d\\n\",ed[i][0],ed[i][1]);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    s=n*2;t=s+1;\n    int siz,xx;\n    for(int i=1;i<n;++i)\n    {\n        add(i+n,t,1);\n        scanf(\"%d\",&siz);\n        for(int j=1;j<=siz;++j)\n        {\n            scanf(\"%d\",&xx);\n            bel[xx].push_back(i);\n            if(xx!=1) add(xx,i+n,1);\n        }\n    }\n    for(int i=1;i<=n;++i)add(s,i,1);\n    int flow=Dinic();\n    if(flow!=n-1)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 200111;\nconst int maxm = 400111*2;\nint n;\nint head[maxn], nxt[maxm], to[maxm], cap[maxm], tot=1;\nvoid add_edge(int x, int y, int c)\n{\n\tnxt[++tot] = head[x];\n\thead[x] = tot;\n\tto[tot] = y;\n\tcap[tot] = c;\n\tswap(x, y);\n\tnxt[++tot] = head[x];\n\thead[x] = tot;\n\tto[tot] = y;\n\tcap[tot] = 0;\n}\nint q[maxn], qn, dis[maxn];\nvoid bfs(int S, int N)\n{\n\tfor (int i=0; i<=N; i++) dis[i] = -1;\n\tqn = 0;\n\tq[qn++] = S;\n\tdis[S] = 0;\n\tfor (int i=0; i<qn; i++)\n\t{\n\t\tint x = q[i];\n\t\tfor (int j=head[x]; j; j=nxt[j])\n\t\t{\n\t\t\tint u = to[j];\n\t\t\tif (cap[j]&&dis[u]==-1)\n\t\t\t{\n\t\t\t\tdis[u] = dis[x]+1;\n\t\t\t\tq[qn++] = u;\n\t\t\t}\n\t\t}\n\t}\n}\nint it[maxn];\nint dfs(int x, int T, int f)\n{\n\tif (x==T) return f;\n\tint of = f;\n\tfor (int &i = it[x]; i; i=nxt[i])\n\t{\n\t\tint u = to[i];\n\t\tif (cap[i]&&dis[u]==dis[x]+1)\n\t\t{\n\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\tif (d>0)\n\t\t\t{\n\t\t\t\tf -= d;\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t}\n\treturn of-f;\n}\nint max_flow(int S, int T, int N)\n{\n\tint flow = 0;\n\twhile (true)\n\t{\n\t\tbfs(S, N);\n\t\tif (dis[T]==-1) return flow;\n\t\tfor (int i=0; i<=N; i++) it[i] = head[i];\n\t\tint f;\n\t\twhile (f = dfs(S, T, 1e9)) flow += f;\n\t}\n}\nint mt[maxn];\nvector<int> v[maxn];\nint ans[maxn];\nint main()\n{\n\tgeti(n);\n\tint S = n+n, T = n+n+1;\n\tfor (int i=2; i<=n; i++) add_edge(S, i, 1);\n\tfor (int i=1; i<=n-1; i++)\n\t{\n\t\tadd_edge(i+n, T, 1);\n\t\tint k;\n\t\tgeti(k);\n\t\tfor (int j=1; j<=k; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tgeti(x);\n\t\t\tadd_edge(x, i+n, 1);\n\t\t\tv[x].PB(i);\n\t\t}\n\t}\n\tint f = max_flow(S, T, T);\n\tif (f!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t}\n\telse\n\t{\n\t\tfor (int i=2; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=head[i]; j; j=nxt[j])\n\t\t\t{\n\t\t\t\tif (!cap[j]&&to[j]>n&&to[j]<n+n)\n\t\t\t\t{\n\t\t\t\t\tmt[to[j]-n] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqn = 0; q[qn++] = 1;\n\t\tfor (int i=0; i<qn; i++)\n\t\t{\n\t\t\tint x = q[i];\n\t\t\tfor (auto u: v[x])\n\t\t\t{\n\t\t\t\tif (!ans[u])\n\t\t\t\t{\n\t\t\t\t\tans[u] = x;\n\t\t\t\t\tq[qn++] = mt[u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (qn!=n)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i=1; i<=n-1; i++) putsii(ans[i], mt[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,F[N],vis[N];\nvector<int> go[N];\n\nnamespace flow {\n\tconst int V = 100005, E = 1000004;\n\tint S, T, tot = 1, fst[V], nxt[E], to[E], flow[E], lvl[V];\n\t\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; flow[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; flow[tot] = 0;\n\t}\n\t\n\tint bfs() {\n\t\tqueue<int> q;\n\t\tfor(int i = 0; i <= T; i ++)\n\t\t\tlvl[i] = 0;\n\t\tq.push(S); lvl[S] = 1;\n\t\tint u, v;\n\t\twhile (!q.empty()) {\n\t\t\tu = q.front(); q.pop();\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (flow[i] && !lvl[v = to[i]]) {\n\t\t\t\t\tlvl[v] = lvl[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t}\n\t\treturn lvl[T];\n\t}\n\t\n\tint dinic(int u, int f) {\n\t\tif (u == T)\n\t\t\treturn f;\n\t\tint v, k = f;\n\t\tfor (int i = fst[u]; i && k; i = nxt[i])\n\t\t\tif (flow[i] && lvl[v = to[i]] == lvl[u] + 1) {\n\t\t\t\tint t = dinic(v, min(k, flow[i]));\n\t\t\t\tif (!t)\n\t\t\t\t\tlvl[v] = 0;\n\t\t\t\telse\n\t\t\t\t\tk -= t, flow[i] -= t, flow[i ^ 1] += t;\n\t\t\t}\n\t\treturn f - k;\n\t}\n\t\n\tint mf() {\n\t\tint res = 0;\n\t\twhile(bfs()) res += dinic(S, 2e9);\n\t\treturn res;\n\t}\n\t\n\tvoid getmatch() {\n\t\tfor(int s = 1; s < n; ++s)\n\t\t\tfor(int i = fst[s]; i; i = nxt[i])\n\t\t\t\tif(to[i] != S && !flow[i]) {\n\t\t\t\t\tF[s] = to[i] - n; break;\n\t\t\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tflow::S=2*n+1;\n\tflow::T=2*n+2;\n\tfor(int i=1,d,x; i<n; i++)\n\t{\n\t\tflow::addedge(flow::S,i,1);\n\t\tscanf(\"%d\",&d);\n\t\tfor(int j=1; j<=d; ++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tgo[x].push_back(i);\n\t\t\tif(x!=1)\n\t\t\t\tflow::addedge(i,n+x,1);\n\t\t}\n\t}\n\tfor(int i=2; i<=n; i++)\n\t\tflow::addedge(n+i,flow::T,1);\n\tint f=flow::mf();\n\tif(f<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tflow::getmatch();\n\tvector<pair<int,int>> out;\n\tout.resize(n);\n\tqueue<int> q;\n\tq.push(1);\n\tvis[1]=true;\n\twhile(!q.empty()) {\n\t\tint u=q.front(); q.pop();\n\t\tfor(auto &v:go[u]) if(!vis[F[v]]) {\n\t\t\tvis[F[v]]=true;\n\t\t\tout[v]=make_pair(u,F[v]);\n\t\t\tq.push(F[v]);\n\t\t}\n\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tif(!p->first){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tprintf(\"%d %d\\n\",p->first,p->second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM=1000000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nstruct edge{\n\tint to,rem,xt;\n}e[MM];\nint ecnt=1;\nint p[2*NN]={};\nvoid ADD(int x,int y,int rem){\n\te[++ecnt].to=y;\n\te[ecnt].rem=rem;\n\te[ecnt].xt=p[x];\n\tp[x]=ecnt;\n}\nvoid add(int x,int y,int rem){\n\tADD(x,y,rem);\n\tADD(y,x,0);\n}\nint st,fin;\nint g[2*NN]={};\nint ht[2*NN]={};\nint q[2*NN]={};\nbool bfs(int x){\n\tint std=ht[fin]+10;\n\tht[st]=std;\n\tint hd=0,tl=0;\n\tq[tl++]=st;\n\twhile(hd!=tl){\n\t\tint x=q[hd++];\n\t\tif(x==fin)break;\n\t\tfor(int pos=p[x];pos;pos=e[pos].xt){\n\t\t\tint cur=e[pos].to;\n\t\t\tif(e[pos].rem&&ht[cur]<std){\n\t\t\t\tht[cur]=ht[x]+1;\n\t\t\t\tq[tl++]=cur;\n\t\t\t}\n\t\t}\n\t}\n\treturn ht[fin]>=std;\n}\nint dfs(int x,int rem){\n\tif(x==fin)return rem;\n\tint res=0;\n\tfor(int &pos=g[x];pos;pos=e[pos].xt){\n\t\tint cur=e[pos].to;\n\t\tif(e[pos].rem&&ht[cur]==ht[x]+1){\n\t\t\tint tp=dfs(cur,min(rem,e[pos].rem));\n\t\t\tif(tp){\n\t\t\t\te[pos].rem-=tp;\n\t\t\t\te[pos^1].rem+=tp;\n\t\t\t\trem-=tp;\n\t\t\t\tres+=tp;\n\t\t\t}\n\t\t\tif(!rem)break;\n\t\t}\n\t}\n\treturn res;\n}\nint getf(){\n\tint res=0;\n\twhile(bfs(st)){\n\t\tfor(int i=1;i<=fin;++i)g[i]=p[i];\n\t\tres+=dfs(st,1e9);\n\t}\n\treturn res;\n}\nint match[NN]={};\nvector<int> t[NN]={};\nint ans[NN][2]={};\nint anscnt=0;\nbool vis[NN]={};\nvoid getres(int x){\n\tfor(int i=0;i<t[x].size();++i){\n\t\tint cur=t[x][i];\n\t\tif(!vis[cur]){\n\t\t\t++anscnt;\n\t\t\tvis[cur]=1;\n\t\t\tans[cur][0]=x;\n\t\t\tans[cur][1]=match[cur];\n\t\t\tgetres(match[cur]);\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tst=2*n;\n\tfin=st+1;\n\tfor(int i=1;i<=n;++i)add(st,i,1);\n\tfor(int i=1;i<n;++i){\n\t\tadd(n+i,fin,1);\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;++j){\n\t\t\tint x=read();\n\t\t\tt[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\tint k=getf();\n\tif(k!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;++i){\n\t\tbool fl=1;\n\t\tfor(int pos=p[i];pos;pos=e[pos].xt){\n\t\t\tint cur=e[pos].to;\n\t\t\tif(cur>n&&cur<2*n&&!e[pos].rem){\n\t\t\t\tmatch[cur-n]=i;\n\t\t\t\tfl=0;\n\t\t\t}\n\t\t}\n\t\tif(fl)rt=i;\n\t}\n\tgetres(rt);\n\tif(anscnt!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n-1;++i){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\treturn 0;\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nvector<int> hv[200005];\nstruct edge\n{\n\tint to, cap, rev;\n}E[800005];\nvector<int> G[200005];\n\nvoid add_edge(int u, int v, int c)\n{\n\tE[m].to = v;\n\tE[m].cap = c;\n\tE[m].rev = m ^ 1;\n\tG[u].push_back(m ++);\n\tE[m].to = u;\n\tE[m].cap = 0;\n\tE[m].rev = m ^ 1;\n\tG[v].push_back(m ++);\n}\n\nint dis[200005], cur[200005];\nbool bfs()\n{\n\trep1(i, 2 * n) dis[i] = -1;\n\tqueue<int> que;\n\tque.push(0);\n\tdis[0] = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i, G[v].size()) {\n\t\t\tint ce = G[v][i];\n\t\t\tif(E[ce].cap > 0 && dis[E[ce].to] == -1) {\n\t\t\t\tque.push(E[ce].to);\n\t\t\t\tdis[E[ce].to] = dis[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2 * n] == -1) return false;\n\trep(i, 2 * n + 1) cur[i] = 0;\n\treturn true;\n}\n\nint dfs(int v, int maxf)\n{\n\tif(v == 2 * n) return maxf;\n\tif(maxf == 0) return 0;\n\tint ret = 0;\n\tfor(; cur[v] < G[v].size(); cur[v] ++) {\n\t\tint ce = G[v][cur[v]];\n\t\tif(dis[E[ce].to] == dis[v] + 1 && E[ce].cap > 0) {\n\t\t\tint cf = dfs(E[ce].to, min(maxf - ret, E[ce].cap));\n\t\t\tE[ce].cap -= cf;\n\t\t\tE[E[ce].rev].cap += cf;\n\t\t\tret += cf;\n\t\t\tif(ret == maxf) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint lp[200005], par[200005];\n\nint dinic()\n{\n\tint ret = 0;\n\twhile(bfs()) ret += dfs(0, INF);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n - 1) {\n\t\tint cs;\n\t\tscanf(\"%d\", &cs);\n\t\thv[i].resize(cs);\n\t\trep(j, cs) {\n\t\t\tscanf(\"%d\", &hv[i][j]);\n\t\t\tadd_edge(hv[i][j], i + n, 1);\n\t\t}\n\t\tadd_edge(i + n, n * 2, 1);\n\t}\n\trep1(i, n) add_edge(0, i, 1);\n\tif(dinic() != n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\trep1(i, n) if(dis[i] == -1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\t\n\trep1(i, 2 * n - 1) rep(j, G[i].size()) {\n\t\tint ce = G[i][j];\n\t\tif(E[ce].cap == 0 && dis[E[ce].to] == dis[i] - 1) {\n\t\t\tpar[i] = E[ce].to;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\trep1(i, n) if(par[i] != 0) lp[par[i] - n] = i;\n\trep1(i, n - 1) printf(\"%d %d\\n\", par[i + n], lp[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005 , S = 0 , T = 200000;\nstruct node{int to,next,val;}e[N<<4];\nint head[N],cnt,dep[N],q[N],c[N],n;\nvoid add(int x,int y,int z){e[cnt]=(node){y,head[x],z};head[x]=cnt++;}\nvoid insert(int x,int y,int z){add(x,y,z),add(y,x,0);}\nint bfs()\n{\n\tint l=0,r=0;q[r++] = S;memset(dep,-1,sizeof(dep));dep[S] = 1;\n\twhile(l<r)\n\t{\n\t\tint x = q[l++];\n\t\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t\t{\n\t\t\tint to1=e[i].to;\n\t\t\tif(dep[to1]==-1&&e[i].val)dep[to1] = dep[x]+1 , q[r++] = to1;\n\t\t}\n\t}return dep[T] != -1;\n}\nint dfs(int x,int maxf)\n{\n\tif(x==T)return maxf;int tflow = maxf , nowf;\n\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t{\n\t\tint to1=e[i].to;\n\t\tif(dep[to1]==dep[x]+1&&e[i].val)\n\t\t{\n\t\t\tnowf = dfs(to1 , min(tflow , e[i].val) );\n\t\t\tif(nowf && x>=1 && x<=n-1 && to1) c[x]=to1-n+2;\n\t\t\te[i].val-=nowf , tflow -= nowf , e[i^1].val += nowf;\n\t\t\tif(!tflow)break;\n\t\t}\n\t}return maxf-tflow;\n}\nvector<int >v[N];\nint Dinic()\n{\n\tint sum = 0;\n\twhile(bfs())sum += dfs(S,1<<30);\n\treturn sum;\n}\nint vis[N];pair<int ,int > ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);memset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint siz; scanf(\"%d\",&siz); insert(S,i,1); insert(n+i-1,T,1);\n\t\tfor(int j=1,x;j<=siz;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x),v[x].push_back(i);\n\t\t\tif(x!=1)insert(i,n+x-2,1);\n\t\t}\n\t}\n\t// puts(\"B\");\n\tif(Dinic()==n-1)\n\t{\n\t\t// puts(\"a\");\n\t\tint l = 0 , r = 0;\n\t\tfor(int i=0;i<v[1].size();i++)\n\t\t\tq[r++] = v[1][i] , vis[v[1][i]] = 1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint x = q[l++]; ans[x] = make_pair(vis[x] , c[x]); x = c[x];\n\t\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\t\tif(!vis[v[x][i]]) q[r++] = v[x][i] , vis[v[x][i]] = x;\n\t\t}\n\t\tif(r==n-1)for(int i=1;i<n;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\telse puts(\"-1\");\n\t}else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define M 1000010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[M],got[M],tak[M];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[u]=x,b[u]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n \n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n \ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n \n// ========================================================================= //\n \nint main() {\n    ios::sync_with_stdio(false);\n \n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n \n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n \n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n \n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i))\n                    was = 1;\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n \n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n \n    vector<ipair> es(n - 1);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es[s] = {v, nv};\n            ++cnt;\n            dfs(nv);\n        }\n    };\n    dfs(root);\n \n    if (cnt != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 200500\nqueue<int> tp;\nint n,m,a,head[N],cnt=1,id[N],fa[N],cur[N],dis[N],is[N],ct1;\nvector<int> st2[N];\nstruct edge{int t,next,v;}ed[N*2];\nvoid adde(int f,int t,int v){ed[++cnt]=(edge){t,head[f],v};head[f]=cnt;ed[++cnt]=(edge){f,head[t],0};head[t]=cnt;}\nbool bfs(int s,int t)\n{\n\tmemset(dis,-1,sizeof(dis));\n\tmemcpy(cur,head,sizeof(cur));\n\tdis[s]=0;\n\tqueue<int> st;st.push(s);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tfor(int i=head[a];i;i=ed[i].next)\n\t\tif(ed[i].v&&dis[ed[i].t]==-1)\n\t\t{\n\t\t\tdis[ed[i].t]=dis[a]+1,st.push(ed[i].t);\n\t\t\tif(ed[i].t==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int u,int t,int f)\n{\n\tif(u==t||!f)return f;\n\tint as=0,tp;\n\tfor(int &i=cur[u];i;i=ed[i].next)\n\tif(ed[i].v&&dis[ed[i].t]==dis[u]+1&&(tp=dfs(ed[i].t,t,min(ed[i].v,f))))\n\t{\n\t\tas+=tp,f-=tp;ed[i].v-=tp;ed[i^1].v+=tp;\n\t\tif(!f)return as;\n\t}\n\treturn as;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++)scanf(\"%d\",&a),st2[a].push_back(i),adde(a,i+n,1);\n\t}\n\tfor(int i=1;i<n;i++)adde(2*n,i+1,1),adde(i+n,2*n+1,1);\n\tint as=0;while(bfs(n*2,n*2+1))\n\tas+=dfs(n*2,n*2+1,n);\n\tif(as<n-1){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tfor(int j=head[i+n];j;j=ed[j].next)if(ed[j].v)id[i]=ed[j].t;\n\tqueue<int> st;\n\tst.push(1);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tct1++;\n\t\tfor(int j=0;j<st2[a].size();j++)if(!fa[id[st2[a][j]]])fa[id[st2[a][j]]]=a,st.push(id[st2[a][j]]);\n\t}\n\tif(ct1<n){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",fa[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>ans[200005];\nint beg = -1;\nbool in[400005];\n\n//O(E sqrt V)\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph, rev;\n  vector< int > dist, match, revmatch;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), rev(m), match(m, -1), revmatch(n,-1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    rev[v].push_back(u);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        revmatch[a] = b;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n  \n  void put_ans() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        ans[match[i]].pb(i);\n      }\n      else{\n      \tbeg = i;\n      }\n    }\n  }\n  \n  void DFS(int cur,bool right){\n      //cout << cur << \" \" << right << endl;\n  \tif(right){\n  \t\t\n  \t\tfor(int i=0;i<rev[cur].size();i++){\n  \t\t\tif(match[cur] == rev[cur][i]) continue;\n  \t\t\tint to = rev[cur][i];\n  \t\t\t//cout << to << endl;\n  \t\t\tif(in[to]) continue;\n  \t\t\tin[to] = 1;\n  \t\t\tans[to].pb(cur);\n  \t\t\t//cout << to << \" \" << cur << endl;\n  \t\t\t//cout << to << endl;\n  \t\t\tDFS(to,false);\n  \t\t}\n  \t}\n  \telse{\n  \t\t\n\t\tfor(int i=0;i<graph[cur].size();i++){\n  \t\t\tif(match[graph[cur][i]] != cur) continue;\n  \t\t\tint to = graph[cur][i];\n  \t\t\tif(in[to+200001]) continue;\n  \t\t\tin[to+200001] = 1;\n  \t\t\tDFS(to,true);\n  \t\t}\n  \t}\n  }\n};\n\nint n;\nvector<int>vec[200005];\n\nint par[200005],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tHopcroftKarp bm(n-1,n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\trep(j,a){\n\t\t\tint x; scanf(\"%d\",&x); x--;\n\t\t\tvec[i].pb(x);\n\t\t\tbm.add_edge(i,x);\n\t\t}\n\t}\n\tint v = bm.bipartite_matching(); \n\tbm.put_ans();\n\tif(beg != -1) bm.DFS(beg,true);\n\tinit();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ans[i].size() != 2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tint x = ans[i][0], y = ans[i][1];\n\t\tif(same(x,y)){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tunite(x,y);\n\t}\n//\tputs(\"YES\");\n\trep(i,n-1) cout << ans[i][0]+1 << \" \" << ans[i][1]+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nconst int N=500010;\nint n,m,i,j,k,ans[N][2],d[N],head,tail,cnt,x;\nvector<int> a[N];\nset<int> b[N],c,e[N];\nbool ok[N];\nvoid doit(int x){ans[++cnt][0]=x;ok[x]=true;set<int>::iterator it=b[x].begin();c.erase(x);\n\tfor (int i=0;i<a[*it].size();i++) if (a[*it][i]!=x&&!e[x].count(a[*it][i])){ans[cnt][1]=a[*it][i];break;}int xx=*it;\n\tfor (int i=0;i<a[xx].size();i++){b[a[xx][i]].erase(xx);\n\tif (b[a[xx][i]].size()==1&&!ok[a[xx][i]]) d[++tail]=a[xx][i],\n\tc.erase(a[xx][i]);}e[ans[cnt][0]].insert(ans[cnt][1]);e[ans[cnt][1]].insert(ans[cnt][0]);\n}\nint main(){\n\tscanf(\"%d\",&n);for (i=1;i<=n-1;i++){scanf(\"%d\",&m);for (j=1;j<=m;j++) scanf(\"%d\",&x),a[i].push_back(x),b[x].insert(i);}\n\tfor (i=1;i<=n;i++) c.insert(i);\n\thead=1;tail=0;for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) d[++tail]=i,c.erase(i);\n\t//for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) doit(i);\n\twhile (cnt!=n-1){\n\t\twhile (head<=tail&&cnt!=n-1){\n\t\t\tx=d[head];if (b[x].size()==0){printf(\"-1\\n\");return 0;} else doit(x);head++;\n\t\t}\n\t\tif (cnt!=n-1) doit(*c.begin());\n\t}for (i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans[i][0],ans[i][1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nnamespace FlowGraph{\n\tconst int MAXV = 2*MAXN;\n\tconst int MAXE = 10*MAXN;\n\tconst int INF = (1 << 30);\n\t\n\tstruct edge{\n\t\tint to, flow, cap;\n\t\tedge *nxt, *rev;\n\t}edges[MAXE + 5], *adj[MAXV + 5], *cur[MAXV + 5], *ecnt = edges;\n\tvoid addedge(int u, int v, int c) {\n\t\tedge *p = (++ecnt), *q = (++ecnt);\n\t\tp->to = v, p->cap = c, p->flow = 0;\n\t\tp->nxt = adj[u], adj[u] = p;\n\t\tq->to = u, q->cap = 0, q->flow = 0;\n\t\tq->nxt = adj[v], adj[v] = q;\n\t\tp->rev = q, q->rev = p;\n\t}\n\tint s, t;\n\tint fa[MAXV + 5], dis[MAXV + 5];\n\tint que[MAXV + 5], hd, tl;\n\tbool relabel() {\n\t\tfor(int i=s;i<=t;i++)\n\t\t\tdis[i] = t + 5, cur[i] = adj[i];\n\t\tdis[que[hd = tl = 1] = t] = 0;\n\t\twhile( hd <= tl ) {\n\t\t\tint x = que[hd++];\n\t\t\tfor(edge *p=adj[x];p;p=p->nxt) {\n\t\t\t\tif( dis[p->to] > dis[x] + 1 && p->rev->cap > p->rev->flow )\n\t\t\t\t\tdis[p->to] = dis[x] + 1, fa[p->to] = x, que[++tl] = p->to;\n\t\t\t}\n\t\t}\n\t\treturn !(dis[s] == t + 5);\n\t}\n\tint aug(int x, int tot) {\n\t\tif( x == t ) return tot;\n\t\tint sum = 0;\n\t\tfor(edge *&p=cur[x];p;p=p->nxt) {\n\t\t\tif( p->cap > p->flow && dis[p->to] + 1 == dis[x] ) {\n\t\t\t\tint del = aug(p->to, min(tot - sum, p->cap - p->flow));\n\t\t\t\tp->flow += del, p->rev->flow -= del, sum += del;\n\t\t\t\tif( sum == tot ) break;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tint max_flow(int _s, int _t) {\n\t\tint flow = 0; s = _s, t = _t;\n\t\twhile( relabel() )\n\t\t\tflow += aug(s, INF);\n\t\treturn flow;\n\t}\n}\n\nint a[MAXN + 5], b[MAXN + 5];\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor(int i=1;i<N;i++) {\n\t\tint c; scanf(\"%d\", &c);\n\t\tfor(int j=1;j<=c;j++) {\n\t\t\tint w; scanf(\"%d\", &w);\n\t\t\tFlowGraph::addedge(N + i, w, 1);\n\t\t}\n\t}\n\tint s = 0, t = N + N - 1 + 1;\n\tfor(int i=1;i<N;i++) FlowGraph::addedge(s, N + i, 1);\n\tfor(int i=1;i<=N;i++) FlowGraph::addedge(i, t, 1);\n\tint f = FlowGraph::max_flow(s, t);\n\tif( f == N - 1 ) {\n\t\tFlowGraph::relabel();\n\t\tfor(int i=1;i<t;i++)\n\t\t\tif( FlowGraph::dis[i] == t + 5 ) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tfor(int i=1;i<N;i++) a[i] = FlowGraph::fa[N + i];\n\t\tfor(int i=1;i<=N;i++) b[FlowGraph::fa[i] - N] = i;\n\t\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\", a[i], b[i]);\n\t}\n\telse puts(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n     \ntemplate <typename Weight, int MAX_N, Weight INF> class MaxFlow{\npublic:\n\tstruct E{\n\t\tint to, rev;\n\t\tWeight lim;\n\t\tE(int x, Weight y, int z){\n\t\t\tto = x;\n\t\t\tlim = y;\n\t\t\trev = z;\n\t\t}\n\t};\n     \n\tvector<E> edge[MAX_N];\n\tint lev[MAX_N];\n\tint iter[MAX_N];\n     \n     \n\tWeight dfs(int s, int g, Weight f){\n\t\tif(s == g)return f;\n\t\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\t\tE &e = edge[s][i];\n\t\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\t\tWeight tmp = dfs(e.to, g, min(f, e.lim));\n\t\t\tif(tmp<1e-9)continue;\n\t\t\te.lim -= tmp;\n\t\t\tedge[e.to][e.rev].lim += tmp;\n\t\t\treturn tmp;\n\t\t}\n\t\treturn 0;\n\t}\n     \n\tvoid bfs(int x){\n\t\tqueue<int> q;\n\t\tq.push(x);\n\t\tint p = 0;\n\t\twhile(!q.empty()){\n\t\t\tfor(int i = q.size();i--;){\n\t\t\t\tint tmp = q.front();q.pop();\n\t\t\t\tif(lev[tmp] != MAX_N)continue;\n\t\t\t\tlev[tmp] = p;\n\t\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == MAX_N)q.push(edge[tmp][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n     \n\tvoid make_edge(int a, int b, Weight l){\n\t\tedge[a].push_back(E(b, l, edge[b].size()));\n\t\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n\t}\n     \n\tWeight max_flow(int s, int g){\n\t\tWeight res = 0;\n\t\tbool fin = false;\n\t\twhile(!fin){\n\t\t\tfill(lev, lev + MAX_N, MAX_N);\n\t\t\tfill(iter, iter + MAX_N, 0);\n\t\t\tbfs(s);\n\t\t\tfin = true;\n\t\t\twhile(true){\n\t\t\t\tWeight p = dfs(s, g, INF);\n\t\t\t\tif(p < 1e-9)break;\n\t\t\t\tfin = false;\n\t\t\t\tres += p;\n\t\t\t}\n\t\t}\t\n\t\treturn res;\n\t}\n};\n     \nMaxFlow<int, 216000, (1<<26)> mf;\nbool come[216000];\nint n,c, u;\nvector<int> ans[216000];\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < mf.edge[x].size();i++){\n\t\tif(mf.edge[x][i].lim == 0)continue;\n\t\tint to = mf.edge[x][i].to;\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x != 0 && x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tint T = 215000, S = 0;\n\tfor(int i = 1;i <= n;i++)mf.make_edge(S, n + i, 1);\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tmf.make_edge(i, T, 1);\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tmf.make_edge(n + u, i, 1);\n\t\t}\t\n\t}\n\tif(mf.max_flow(S, T) != n-1)ng();\n\tdfs(S);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nset<int> lp[1<<17];\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[orig[1]]) if(!used[t] && lp[t].count(orig[0])) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i), lp[i].insert(j);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=233,Maxm=666;\n\tint S,T,cnt,h[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs())ans+=dfs(S,INT_MAX);\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;\n}E[MAXN * 10];\nint N,head[MAXN * 2],sumE = 1,S,T,tot,lev[MAXN * 2],cur[MAXN * 2],ch[MAXN],fa[MAXN];\nvector<int> v[MAXN];\nbool vis[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c) {\n    add(u,v,c);add(v,u,0);\n}\nbool BFS() {\n    static int que[MAXN * 2],ql,qr;\n    que[ql = qr = 1] = S;\n    for(int i = 1 ; i <= T ; ++i) lev[i] = -1,cur[i] = head[i];\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    int v = E[i].to;\n\t    if(E[i].cap > 0 && lev[v] == -1) {\n\t\tlev[v] = lev[u] + 1;\n\t\tif(v == T) return true;\n\t\tque[++qr] = v;\n\t    }\n\t}\n    }\n    return false;\n}\nint dfs(int u,int aug) {\n    if(u == T) return aug;\n    int flow = 0;\n    for(int &i = cur[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(E[i].cap > 0 && lev[v] > lev[u]) {\n\t    int t = dfs(v,min(E[i].cap,aug - flow));\n\t    flow += t;E[i].cap -= t;E[i ^ 1].cap += t;\n\t    if(flow == aug) break;\n\t}\n    }\n    if(flow != aug) lev[u] = -1;\n    return flow;\n}\nint Dinic() {\n    int res = 0;\n    while(BFS()) {\n\tres += dfs(1,0x7fffffff);\n    }\n    return res;\n}\nvoid Init() {\n    read(N);\n    S = 1;\n    for(int i = 1 ; i < N ; ++i) {\n\taddtwo(S,i + N,1);\n\tint c,w;\n\tread(c);\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    read(w);\n\t    if(w != 1) addtwo(i + N,w,1);\n\t    v[w].pb(i);\n\t}\n    }\n    T = 2 * N;\n    for(int i = 2 ; i <= N ; ++i) addtwo(i,T,1);\n}\nvoid construct() {\n    static int que[MAXN],ql,qr;\n    que[ql = qr = 1] = 1;\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(auto t : v[u]) {\n\t    if(!vis[t]) {\n\t\tvis[t] = 1;\n\t\tfa[ch[t]] = u;\n\t\tque[++qr] = ch[t];\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    if(Dinic() != N - 1) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= N - 1 ; ++i) {\n\tint u = i + N;\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(E[j].cap == 0) {ch[i] = v;break;}\n\t}\n    }\n    construct();\n    for(int i = 1 ; i < N ; ++i) {\n\tif(!vis[i]) {puts(\"-1\");return;}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tout(fa[ch[i]]);space;out(ch[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2000002;\nint n,i,j,k,cnt[N],m,a,x[N],y[N],in[N];\nint h[N],t[N],v[N],vis[N],Mc[N],q[N],s,e;\nvoid add(int a,int b){\n\tt[++k]=h[a];\n\th[a]=k;\n\tv[k]=b;\n}\nvoid init(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d\",cnt+i);\n\t\tfor(j=1;j<=cnt[i];j++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tadd(a,i+n);\n\t\t}\n\t}\n}\nbool dfs(int i){\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(vis[v[j]]!=k){\n\t\t\tvis[v[j]]=k;\n\t\t\tif(!Mc[v[j]]||dfs(Mc[v[j]])){\n\t\t\t\tMc[v[j]]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nvoid work(){\n\tfor(k=n;k>1;k--)\n\t\tif(!dfs(k)){\n\t\t\tprintf(\"-1\");\n\t\t\treturn;\n\t\t}\n\tq[s=e=0]=1;\n\tin[1]=1;\n\twhile(s<=e){\n\t\ti=q[s++];\n\t\tfor(j=h[i];j;j=t[j]){\n\t\t\ta=Mc[v[j]];\n\t\t\tif(!in[a]){\n\t\t\t\tin[a]=1;\n\t\t\t\tq[++e]=a;\n\t\t\t\tm++;\n\t\t\t\tx[m]=i;y[m]=a;\n\t\t\t}\n\t\t}\n\t}\n\tif(m!=n-1)\n\t\tprintf(\"-1\");\n\telse\n\t\tfor(i=1;i<=m;i++)\n\t\t\tprintf(\"%d %d\\n\",x[i],y[i]);\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200100,MAXM=1000100,INF=0x3f3f3f3f;\nstruct Edge\n{\n\tint to,val,nxt;\n\tinline Edge() {}\n\tinline Edge(register int to,register int val,register int nxt):to(to),val(val),nxt(nxt) {}\n};\nEdge e[MAXM];\nint head[MAXN],S,T,cnt=-1;\nint d[MAXN],cur[MAXN];\nint vis1[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];\nint N;\nqueue<int> q,q_;\nvector<int> bel[MAXN];\ninline void Addedge(register int x,register int y,register int z)\n{\n\te[++cnt]=Edge(y,z,head[x]),head[x]=cnt;\n\te[++cnt]=Edge(x,0,head[y]),head[y]=cnt;\n\treturn;\n}\ninline bool bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tmemset(d,-1,sizeof(d));\n\td[S]=0,cur[S]=head[S],q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tregister int now=q.front(); q.pop();\n\t\tfor(register int i=head[now];~i;i=e[i].nxt)\n\t\t\tif(e[i].val&&(!(~d[e[i].to])))\n\t\t\t{\n\t\t\t\tregister int to=e[i].to;\n\t\t\t\td[to]=d[now]+1,cur[to]=head[to];\n\t\t\t\tif(to==T) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(register int now,register int num)\n{\n\tif(now==T||!num) return num;\n\tregister int ans=0;\n\tfor(register int &i=cur[now];~i;i=e[i].nxt)\n\t\tif(e[i].val&&d[e[i].to]==d[now]+1)\n\t\t{\n\t\t\tregister int to=e[i].to;\n\t\t\tregister int f=dfs(to,min(num,e[i].val));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\te[i].val-=f,e[i^1].val+=f;\n\t\t\t\tans+=f,num-=f;\n\t\t\t\tif(!num) break;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\ninline int maxflow()\n{\n\tregister int ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\ninline bool solve(register int n)\n{\n\tfor(register int i=1;i<n;i++)\n\t\tfor(register int j=head[n+i];~j;j=e[j].nxt)\n\t\t\tif(e[j].to&&!e[j].val) id[i]=e[j].to,vis1[e[j].to]=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis1[i]) q_.push(i);\n\tregister int cnt_=0;\n\twhile(!q_.empty())\n\t{\n\t\tregister int now=q_.front(); q_.pop();\n\t\tcnt_++;\n\t\tfor(register int i=0;i<(int)bel[now].size();i++)\n\t\t\tif(!vis2[bel[now][i]])\n\t\t\t{\n\t\t\t\tregister int to=bel[now][i];\n\t\t\t\tvis2[to]=1,nxt[to]=now,q_.push(id[to]);\n\t\t\t}\n\t}\n\treturn cnt_==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tmemset(head,-1,sizeof(head));\n\tcin>>N;\n\tS=0,T=N<<1;\n\tfor(register int i=1,x,y;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\tAddedge(S,N+i,1);\n\t\tfor(register int j=1;j<=x;j++) cin>>y,Addedge(N+i,y,1),bel[y].push_back(i);\n\t}\n\tfor(register int i=1;i<=N;i++) Addedge(i,T,1);\n\tif(maxflow()<N-1) return puts(\"-1\"),0;\n\tif(!solve(N)) return puts(\"-1\"),0;\n\tfor(register int i=1;i<N;i++) cout<<id[i]<<\" \"<<nxt[i]<<\"\\n\";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=400010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N],ans[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tq.push(1);int tot=0;\n\t\twhile(!q.empty()){\n\t\t\ttot++;\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans[link[v]]=u;\n\t\t\t}\n\t\t}\n\t\tif(tot!=n)puts(\"-1\");else\n\t\t\tref(i,1,n-1)cout<<ans[link[i]]<<\" \"<<link[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=2e5+5,M=N<<3;\n\nint t[M],f[M],nxt[M],lst[N],l;\n\nvoid add(int x,int y,int z) {\n\tt[++l]=y;f[l]=z;nxt[l]=lst[x];lst[x]=l;\n\tt[++l]=x;f[l]=0;nxt[l]=lst[y];lst[y]=l;\n}\n\nint n,S,T,q[N],dis[N],p[N],fa[N];\nvector<int> to[N];\n\nbool bfs() {\n\tfo(i,S,T) dis[i]=0;dis[S]=1;\n\tint i=0,j=1;q[1]=S;\n\twhile (i<j) \n\t\trep(k,q[++i]) \n\t\t\tif (f[k]&&!dis[t[k]]) {\n\t\t\t\tdis[t[k]]=dis[q[i]]+1;\n\t\t\t\tq[++j]=t[k];\n\t\t\t}\n\treturn dis[T];\n}\n\nint dinic(int x,int y) {\n\tif (x==T) return y;\n\tint now=0;\n\trep(i,x)\n\t\tif (f[i]&&dis[t[i]]==dis[x]+1) {\n\t\t\tint k=dinic(t[i],min(y,f[i]));\n\t\t\tf[i]-=k;f[i^1]+=k;\n\t\t\ty-=k;now+=k;\n\t\t\tif (!y) break;\n\t\t}\n\tif (!now) dis[x]=-1;\n\treturn now;\n}\n\nbool vis[N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x])\n\t\tif (!vis[p[y]]) {\n\t\t\tfa[y]=x;\n\t\t\tdfs(p[y]);\n\t\t}\n}\n\nint main() {\n\tn=read();S=0;T=n<<1;l=1;\n\tfo(i,1,n-1) {\n\t\tadd(S,i,1);\n\t\tint c=read();\n\t\tfo(j,1,c) {\n\t\t\tint x=read();\n\t\t\tif (x>1) add(i,x+n-1,1);\n\t\t\tto[x].push_back(i);\n\t\t}\n\t}\n\tfo(i,1,n) add(i+n-1,T,1);\n\tint ret=0;\n\twhile (bfs()) ret+=dinic(S,1);\n\tif (ret<n-1) {puts(\"-1\");return 0;}\n\t/*fo(i,1,n-1) rep(j,i) if (!f[j]&&t[j]) p[i]=t[j]-n+1;\n\tdfs(1);\n\tfo(i,1,n-1) if (!fa[i]) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[i]);*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int maxm=400111;\n\nstruct edge{int to,cap;};\nnamespace flow\n{\n\tint head[maxn],nxt[maxm<<1],iter[maxn],tot;\n\tedge e[maxm<<1];\n\tvoid clear()\n\t{\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=1;\n\t}\n\tvoid addedge(int u,int v,int cap)\n\t{\n\t\tnxt[++tot]=head[u];\n\t\thead[u]=tot;\n\t\te[tot]=edge{v,cap};\n\t\tnxt[++tot]=head[v];\n\t\thead[v]=tot;\n\t\te[tot]=edge{u,0};\n\t}\n\t \n\tint lvl[maxn],q[maxn];\n\tbool bfs(int s,int t)\n\t{\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;int rr=0;q[rr++]=s;\n\t\tfor(int fr=0;fr<rr;fr++)\n\t\t{\n\t\t\tint x=q[fr];if(x==t)return true;\n\t\t\tfor(int i=head[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==-1)\n\t\t\t{\n\t\t\t\tlvl[e[i].to]=lvl[x]+1;\n\t\t\t\tq[rr++]=e[i].to;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int x,int t,int f)\n\t{\n\t\tif(x==t||f==0)return f;\n\t\tint ret=0;\n\t\tfor(int&i=iter[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==lvl[x]+1)\n\t\t{\n\t\t\tint d=dfs(e[i].to,t,min(f,e[i].cap));\n\t\t\te[i].cap-=d;e[i^1].cap+=d;\n\t\t\tf-=d;ret+=d;\n\t\t\tif(!f)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint maxflow(int s,int t)\n\t{\n\t\tint flow=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemcpy(iter,head,sizeof(head));\n\t\t\tflow+=dfs(s,t,inf);\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nvector<int> e[maxn],g[maxn];\nint n,piv[maxn],fa[maxn];\n\nbool use[maxn];\nvoid dfs(int x)\n{\n\tuse[x]=1;\n\tfor(auto&v:g[x])if(!use[v])\n\t{\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tget1(n);\n\tint S=1,T=n+n;\n\tflow::clear();\n\tfor(int i=2;i<=n;i++)flow::addedge(S,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint cnt,x;get1(cnt);\n\t\tflow::addedge(i+n,T,1);\n\t\twhile(cnt--)\n\t\t{\n\t\t\tget1(x);\n\t\t\te[i].pb(x);\n\t\t\tif(x>1)flow::addedge(x,i+n,1);\n\t\t}\n\t}\n\tif(flow::maxflow(S,T)<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=2;i<=n;i++)for(int j=flow::head[i];j;j=flow::nxt[j])if(flow::e[j].to!=S&&!flow::e[j].cap)\n\t\tpiv[flow::e[j].to-n]=i;\n\t\n\tfor(int i=1;i<n;i++)for(int j=0;j<(int)e[i].size();j++)if(e[i][j]!=piv[i])g[e[i][j]].pb(piv[i]);\n\t\n\tdfs(1);\n\tfor(int i=2;i<=n;i++)if(!fa[i])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",piv[i],fa[piv[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef std::pair <int, int> pr;\nconst int N = 100054;\n\nnamespace F {\n\t#define ad(x) ((x - 1 ^ 1) + 1)\n\n\tconst int N = ::N * 2, M = ::N * 8;\n\n\tstruct edge {\n\t\tint u, v, f;\n\t\tedge (int u0 = 0, int v0 = 0, int f0 = 0) : u(u0), v(v0), f(f0) {}\n\t} e[M];\n\n\tint V = 2, E = 0, si = 1, ti = 2, flow;\n\tint first[N], next[M];\n\tint dep[N], cur[N], que[N];\n\n\tinline void addedge(int u, int v, int f) {\n\t\te[++E] = edge(u, v, f), next[E] = first[u], first[u] = E;\n\t\te[++E] = edge(v, u), next[E] = first[v], first[v] = E;\n\t}\n\n\tbool bfs() {\n\t\tint h, t = 1, i, x, y;\n\t\tmemset(dep, -1, sizeof dep);\n\t\tque[0] = si, dep[si] = 0;\n\t\tfor (h = 0; h < t; h++) {\n\t\t\tif ((x = que[h]) == ti) return true;\n\t\t\tfor (i = first[x]; i; i = next[i])\n\t\t\t\tif (dep[y = e[i].v] == -1 && e[i].f)\n\t\t\t\t\tque[t++] = y, dep[y] = dep[x] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint dfs(int x, int lim) {\n\t\tint a, c, f = 0;\n\t\tif (x == ti || !lim) return lim;\n\t\tfor (int &i = cur[x]; i; i = next[i])\n\t\t\tif (dep[e[i].v] == dep[x] + 1 && e[i].f) {\n\t\t\t\ta = std::min(lim - f, e[i].f);\n\t\t\t\tc = dfs(e[i].v, a);\n\t\t\t\te[i].f -= c; e[ad(i)].f += c;\n\t\t\t\tif ((f += c) == lim) return f;\n\t\t\t}\n\t\treturn f;\n\t}\n\n\tint Dinic() {\n\t\tfor (flow = 0; bfs(); flow += dfs(si, INT_MAX))\n\t\t\tmemcpy(cur, first, sizeof cur);\n\t\treturn flow;\n\t}\n\n\tint get(int x) {\n\t\tfor (int i = first[x]; i; i = next[i]) if (i & 1 && !e[i].f) return e[i].v;\n\t\treturn -1;\n\t}\n}\n\nint n;\nint que[N], match[N], matup[N];\nstd::vector <int> nb[N];\n\nint main() {\n\tint i, v, m, h, t = 1;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; ++i) {\n\t\tF::addedge(i + n + 1, 2, 1), scanf(\"%d\", &m);\n\t\tfor (; m; --m) scanf(\"%d\", &v), nb[v].EB(i), F::addedge(v + 1, i + n + 1, 1);\n\t}\n\tfor (i = 2; i <= n; ++i) F::addedge(1, i + 1, 1);\n\tif (F::Dinic() != n - 1) return puts(\"-1\"), 0;\n\tfor (i = 2; i <= n; ++i) match[ F::get(i + 1) - n - 1 ] = i;\n\tfor (*que = 1, h = 0; h < t; ++h)\n\t\tfor (int s : nb[v = que[h]]) if (!matup[s])\n\t\t\tmatup[s] = v, que[t++] = match[s];\n\tif (t != n) return puts(\"-1\"), 0;\n\tfor (i = 1; i < n; ++i) printf(matup[i] < match[i] ? \"%d %d\\n\" : \"%2$d %1$d\\n\", matup[i], match[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 210000;\nconst int INF = 1000000000;\n \nstruct edge {\n    int a, b, cap, flow;\n};\n \nint nv, s, t, d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n \nvoid addEdge (int a, int b, int cap) {\n    edge e1 = { a, b, cap, 0 };\n    edge e2 = { b, a, 0, 0 };\n    g[a].push_back ((int) e.size());\n    e.push_back (e1);\n    g[b].push_back ((int) e.size());\n    e.push_back (e2);\n}\n \nbool bfs() {\n    int qh=0, qt=0;\n    q[qt++] = s;\n    memset (d, -1, nv * sizeof d[0]);\n    d[s] = 0;\n    while (qh < qt && d[t] == -1) {\n        int v = q[qh++];\n        for (size_t i=0; i<g[v].size(); ++i) {\n            int id = g[v][i],\n                to = e[id].b;\n            if (d[to] == -1 && e[id].flow < e[id].cap) {\n                q[qt++] = to;\n                d[to] = d[v] + 1;\n            }\n        }\n    }\n    return d[t] != -1;\n}\n \nint dfs (int v, int flow) {\n    if (!flow)  return 0;\n    if (v == t)  return flow;\n    for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n        int id = g[v][ptr[v]],\n            to = e[id].b;\n        if (d[to] != d[v] + 1)  continue;\n        int pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n        if (pushed) {\n            e[id].flow += pushed;\n            e[id^1].flow -= pushed;\n            return pushed;\n        }\n    }\n    return 0;\n}\n\nvector<bool> visited;\nvector<int> via;\n\nvoid dfs2(int v) {\n  visited[v] = true;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    int id = g[v][i];\n    int to = e[id].b;\n    if (!visited[to] && e[id].flow < e[id].cap) {\n      via[to] = v;\n      dfs2(to);\n    }\n  }\n}\n \nint dinic() {\n    int flow = 0;\n    for (;;) {\n        if (!bfs())  break;\n        memset (ptr, 0, nv * sizeof ptr[0]);\n        while (int pushed = dfs (s, INF))\n            flow += pushed;\n    }\n    return flow;\n}\n\nint main() {\n        int n; scanf(\"%d\", &n);\n        nv = 2 * n + 1;\n        s = nv - 2;\n        t = nv - 1;\n        vector<int> left(n);\n        for (int i = 0; i < n; ++i) {\n            left[i] = i;\n            addEdge(s, left[i], 1);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int cur = n + i;\n            int count; scanf(\"%d\", &count);\n            addEdge(cur, t, 1);\n            for (int j = 0; j < count; ++j) {\n                int a; scanf(\"%d\", &a);\n                addEdge(left[a - 1], cur, 1);\n            }\n        }\n        int flow = dinic();\n        if (flow != n - 1) {\n            \n                printf(\"-1\\n\");\n                return 0;\n        }\n        visited = vector<bool>(nv);\n        via = vector<int>(nv);\n        dfs2(s);\n        for (int v : left) {\n            if (!visited[v]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n        vector<int> first(n - 1);\n        vector<int> second(n - 1);\n        for (int v : left) {\n            if (via[v] == s) continue;\n            int u = via[via[v]];\n            first[via[v] - n] = v + 1;\n            second[via[v] - n] = u + 1;\n        }\n        for (int i = 0; i < n - 1; ++i)           {\n            printf(\"%d %d\\n\", first[i], second[i]);\n        }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[100000];\nint p[100000];\nbool used[100000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  vector< int > rev[100000];\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n      rev[x].emplace_back(i);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n \ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e_orig[a].PB(Edge{b, cap, SZ(e_orig[b])});\n    e_orig[b].PB(Edge{a, bi_dir * cap, SZ(e_orig[a]) - 1});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n \n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n    for (int i = 0; i <= n; i++) {\n      dis[i] = n + 1;\n    }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e_orig.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n \nint32_t main() {\n \n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<PII> halko;\n    for (auto edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        halko.PB({-edge.c, edge.v - n,  });\n      }\n    }\n    //assert(SZ(halko) == 2);\n    sort(ALL(halko));\n    REP (tr, 2) {\n      cout<<halko[tr].nd<<\" \";\n    }\n//     for (auto x : halko) {\n//       cout<<x<<\" \";\n//     }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MN 201000\n#define MM 801000\n\nint h[MN], nxt[MM], to[MM], cap[MM], K = 1;\nint iter[MN], d[MN], q[MN], hh = 0, tt = 0;\nstd::vector<int> B[MN];\nint x[MN], y[MN], o = 0;\nbool used[MN]; int mat[MN];\n\nvoid ins(int u, int v, int c) {nxt[++K] = h[u]; h[u] = K; to[K] = v; cap[K] = c;}\nvoid insw(int u, int v, int c) {ins(u, v, c); ins(v, u, 0);}\n\nbool bfs(int S, int T)\n{\n\tmemset(d, 0, sizeof(d));\n\thh = tt = 0; d[S] = 1; q[tt++] = S;\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t\tif(cap[i] && !d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\tif(to[i] == T) return 1;\n\t\t\t\tq[tt++] = to[i];\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int T, int f)\n{\n\tif(u == T) return f;\n\tint used = 0;\n\tfor(int &i = iter[u]; i; i = nxt[i])\n\t\tif(cap[i] && d[to[i]] == d[u] + 1)\n\t\t{\n\t\t\tint w = dfs(to[i], T, std::min(f - used, cap[i]));\n\t\t\tif(w)\n\t\t\t{\n\t\t\t\tcap[i] -= w; cap[i ^ 1] += w; used += w; \n\t\t\t\tif(used == f) return f;\n\t\t\t}\n\t\t}\n\treturn used;\n}\n\nint dinic(int S, int T)\n{\n\tint flow = 0;\n\twhile(bfs(S, T))\n\t{\n\t\tmemcpy(iter, h, sizeof(h));\n\t\tint f;\n\t\twhile(f = dfs(S, T, 1e9)) flow += f;\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint S = 2 * n, T = S + 1; \n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint o; scanf(\"%d\", &o);\n\t\tfor(int j = 1; j <= o; j++) \n\t\t{\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\tB[k].push_back(i);\n\t\t\tinsw(i, n - 1 + k, 1); \n\t\t}\n\t\tinsw(S, i, 1);\n\t}\n\tfor(int i = n; i < 2 * n; i++) insw(i, T, 1);\n\tif(dinic(S, T) != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = h[i]; j; j = nxt[j])\n\t\t\tif(!cap[j] && n <= to[j] && to[j] < 2 * n) mat[i] = to[j] - n + 1;\n\tfor(int i = 1; i < n; i++) used[mat[i]] = 1;\n\thh = tt = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) q[tt++] = i;\n\tmemset(used, 0, sizeof(used));\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = 0; i < B[u].size(); i++)\n\t\t{\n\t\t\tif(!used[B[u][i]]) \n\t\t\t{\n\t\t\t\tused[B[u][i]] = 1;\n\t\t\t\t++o; x[o] = mat[B[u][i]]; y[o] = u;\n\t\t\t\tq[tt++] = mat[B[u][i]];\n\t\t\t}\n\t\t}\n\t}\n\tif(o != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i <= o; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 10];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = true;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    /*\n                    if (!pp[jh]) {\n                        cout << jh << endl;\n                    }\n                    */\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        // freopen(\"a.in\", \"r\", stdin);\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            // assert(ee[i + n - 1].first), assert(ee[i + n - 1].second), assert(ee[i + n - 1].first != ee[i + n - 1].second);\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue < int > q;\n    q.push(n);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200100;\n\nvector<int> g[N];\n\nbool mark[N];\nint match[N];\nint n;\n\nbool dfs(int v) {\n  if (mark[v]) {\n    return false;\n  }\n  mark[v] = true;\n  for (int to : g[v]) {\n    if (match[to] == -1 || dfs(match[to])) {\n      match[to] = v;\n      match[n + v] = to;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching() {\n  memset(match, -1, sizeof match);\n  while (true) {\n    memset(mark, false, sizeof mark);\n    bool done = true;\n    for (int i = 0; i < n - 1; i++) {\n      if (match[n + i] == -1) {\n        done &= !dfs(i);\n      }\n    }\n    if (done) {\n      break;\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n - 1; i++) {\n    res += (match[n + i] != -1);\n  }\n  return res;\n}\n\nvector<pair<int, int>> ed;\n\nint make(int v) {\n  int res = 1;\n  for (int to : g[n + v]) {\n    if (!mark[to]) {\n      mark[to] = 1;\n      assert(match[n + to] != -1);\n      ed[to] = {v, match[n + to]};\n      res += make(match[n + to]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int c;\n    cin >> c;\n    while (c--) {\n      int x;\n      cin >> x;\n      --x;\n      g[i].push_back(x);\n      g[n + x].push_back(i);\n    }\n  }\n  if (matching() != n - 1) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int root = -1;\n  for (int i = 0; i < n; i++) {\n    if (match[i] == -1) {\n      root = i;\n      break;\n    }\n  }\n  memset(mark, 0, sizeof mark);\n  ed.resize(n - 1);\n  if (make(root) != n) {\n    cout << -1 << '\\n';\n  } else {\n    for (auto e : ed) {\n      cout << e.first + 1 << \" \" << e.second + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = lis[i - 1], v = pre[u];\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[v-n]=u;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(cho[v]),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MN 200010\n#define MM 800010\n#define inf 999999999\nusing namespace std;\nint fr[MN],dy[MN],ne[MM],v[MM],w[MM],bs=0;\nvoid add(int a,int b,int c)\n{\n\tv[bs]=b;\n\tw[bs]=c;\n\tne[bs]=fr[a];\n\tfr[a]=bs++;\n}\nvoid addb(int a,int b,int c)\n{\n\tadd(a,b,c);\n\tadd(b,a,0);\n}\nint dl[100010],jl[100010],N,S,T;bool bk[100010];\nbool bfs()\n{\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tbk[i]=false;\n\t\tjl[i]=inf;\n\t}\n\tbk[S]=true;jl[S]=0;\n\tint he=0,ta=1;dl[0]=S;\n\twhile(he<ta)\n\t{\n\t\tint u=dl[he++];\n\t\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t\t{\n\t\t\tif(w[i]>0&&!bk[v[i]])\n\t\t\t{\n\t\t\t\tbk[v[i]]=true;\n\t\t\t\tjl[v[i]]=jl[u]+1;\n\t\t\t\tdl[ta++]=v[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn jl[T]<inf;\n}\nint dfs(int u,int z)\n{\n\tif(u==T)\n\t\treturn z;\n\tfor(int &i=dy[u];i!=-1;i=ne[i])\n\t{\n\t\tif(w[i]>0&&jl[v[i]]==jl[u]+1)\n\t\t{\n\t\t\tint t=dfs(v[i],z<w[i]?z:w[i]);\n\t\t\tif(t!=-1)\n\t\t\t{\n\t\t\t\tw[i]-=t;\n\t\t\t\tw[i^1]+=t;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint dinic()\n{\n\tint jg=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tdy[i]=fr[i];\n\t\twhile(1)\n\t\t{\n\t\t\tint t=dfs(S,inf);\n\t\t\tif(t==-1)\n\t\t\t\tbreak;\n\t\t\tjg+=t;\n\t\t}\n\t}\n\treturn jg;\n}\nvector<int> ve[100010],to[100010];\nint pp[100010],fa[100010];\nvoid dfs2(int u,int f)\n{\n\tif(bk[u])return;\n\tfa[u]=f;bk[u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],u);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint s,a;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<s;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tN=n*2+1;S=N-1;T=N;\n\tfor(int i=1;i<=N;i++)\n\t\tfr[i]=-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\taddb(S,i,1);\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t\taddb(i,ve[i][j]+n-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\taddb(i+n-1,T,1);\n\tif(dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbk[i]=false;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=fr[i];j!=-1;j=ne[j])\n\t\t{\n\t\t\tint t=v[j];\n\t\t\tif(t>n-1&&w[j]==0)\n\t\t\t{\n\t\t\t\tpp[i]=t-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t{\n\t\t\tif(ve[i][j]!=pp[i])\n\t\t\t\tto[ve[i][j]].push_back(pp[i]);\n\t\t}\n\t\tbk[pp[i]]=true;\n\t}\n\tint ro=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!bk[i])\n\t\t{\n\t\t\tro=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)bk[i]=false;\n\tdfs2(ro,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=ro&&fa[i]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t\tprintf(\"%d %d\\n\",pp[i],fa[pp[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\n\nstruct UnionFind // UnionFind Tree (0-indexed)\n{\n    vector<int> par, rank;\n    UnionFind(int N) : par(N), rank(N) { REP(i, N) par[i] = i; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (rank[x] < rank[y]) par[x] = y; else par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        UnionFind uf(N + 1);\n        for (auto pa : ans) uf.unite(pa.first, pa.second);\n        REP(i, N) if (!uf.same(1, i + 1)) exit(1);\n\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200005;\nconst int ME = 800005;\nconst int oo = 123123123;\n\ntemplate<typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate<typename T> void read(T &x)\n{\n\tx = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v, c;\n\n\tEDGE (const int &v0 = 0, const int &c0 = 0) : v(v0), c(c0) {}\n};\n\nstruct GRAPH\t//板子\n{\n\tEDGE e[ME];\n\tint fst[MX], nxt[ME], lnum;\n\tint dep[MX],q[MX];          //分层网络的深度，bfs 的队列\n\n\tvoid addeg(int nu, int nv, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\tfst[nu] = lnum;\n\t\te[lnum] = EDGE(nv, nc);\n\t}\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tint bfs(int frm,int to)     //生成分层网络\n\t{\n\t\tint h=0,t=1,x,y;\n\t\tmemset(dep,0xff,sizeof(dep));\n\t\tq[++h]=frm;\n\t\tdep[frm]=0;\n\t\twhile(h>=t)\n\t\t{\n\t\t\tx=q[t++];\n\t\t\tfor(int i=fst[x];i!=-1;i=nxt[i])\n\t\t\t{\n\t\t\t\ty=e[i].v;\n\t\t\t\tif(dep[y]==-1&&e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tq[++h]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dep[to]>=0);    //返回分层网络是否成功生成\n\t}\n\n\tint cur[MX];                //当前弧优化的记录数组\n\tint dinic(int x,int mn,int tar)\n\t{\n\t\tif(x==tar)return mn;\n\t\tint y,a,now=0;\n\t\tfor(int &i=cur[x];i!=-1;i=nxt[i])   //\"int &i=\"这一句是当前弧优化的核心\n\t\t{\n\t\t\ty=e[i].v;\n\t\t\tif(e[i].c&&dep[y]==dep[x]+1)\n\t\t\t{\n\t\t\t\ta=dinic(y,min(mn-now,e[i].c),tar);\n\t\t\t\tnow+=a;                     //整体流量优化，记录当前节点往下流的最大流量后再返回\n\t\t\t\te[i].c-=a,e[i^1].c+=a;      //帮助 dinic 反悔\n\t\t\t\tif(mn==now)return now;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\n\tint mxflow(int s, int t)\n\t{\n\t\tint tot=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemmove(cur,fst,sizeof(fst));\n\t\t\ttot+=dinic(s,+oo,t);\n\t\t}\n\t\treturn tot;\n\t}\n} G;\n\nint n;\nint global_s, global_t;\n\nvoid input()\n{\n\tG.init();\n\tread(n);\n\tglobal_s = n*2, global_t = n*2+1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint c, x;\n\t\tread(c);\n\t\tfor(int j=1; j<=c; j++)\n\t\t{\n\t\t\tread(x);\n\t\t\tG.addeg(x, n+i, 1);\n\t\t\tG.addeg(n+i, x, 0);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tG.addeg(global_s, i, 1);\n\t\tG.addeg(i, global_s, 0);\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tG.addeg(n+i, global_t, 1);\n\t\tG.addeg(global_t, n+i, 0);\n\t}\n}\n\nint frm[MX];\npair<int, int> ans[MX];\n\nvoid dfs(int x, int f)\n{\n\tfrm[x] = f;\n\tfor(int i=G.fst[x]; ~i; i=G.nxt[i])\n\t\tif(G.e[i].c && !frm[G.e[i].v])\n\t\t\tdfs(G.e[i].v, x);\n}\n\nvoid work()\n{\n\tif(G.mxflow(global_s, global_t) != n-1) puts(\"-1\");\n\telse\n\t{\n\t\tint root = 0;\n\t\tfor(int i=G.fst[global_s]; ~i; i=G.nxt[i])\n\t\t\tif(G.e[i].c)\n\t\t\t\troot = G.e[i].v;\n\t\tdfs(root, -1);\n\t\tbool fucked = 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tif(!frm[i])\n\t\t\t\tfucked = 1;\n\t\tif(fucked) puts(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++)\n\t\t\t\tif(i != root)\n\t\t\t\t\tans[frm[i]-n] = make_pair(i, frm[frm[i]]);\n\t\t\tfor(int i=1; i<n; i++)\n\t\t\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define pb push_back\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define MEM(i,j) memset(i,j,sizeof i)\n#define ALL(v) v.begin(),v.end()\n#define DB(a,s,e) {for(int i=s;i<e;++i) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int MAXN=2e5+50,INF=1e9;\nstruct Maxflow{\n\tstruct edge{\n\t\tint to,cap,flow,rev;\n\t};\n\tvector<edge> G[MAXN];\n\tint dis[MAXN],cur[MAXN],s,t;\n\tint dfs(int u,int cap){\n\t\tif(u==t||!cap) return cap;\n\t\tfor(int &i=cur[u];i<G[u].size();++i){\n\t\t\tauto &e=G[u][i];\n\t\t\tif(dis[e.to]==dis[u]+1&&e.flow!=e.cap){\n\t\t\t\tint df=dfs(e.to,min(cap,e.cap-e.flow));\n\t\t\t\tif(df){\n\t\t\t\t\te.flow+=df,G[e.to][e.rev].flow-=df;\n\t\t\t\t\treturn df;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[u]=-1;\n\t\treturn 0;\n\t}\n\tbool bfs(){\n\t\tMEM(dis,-1);\n\t\tqueue<int> q;\n\t\tq.push(s),dis[s]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto e:G[u])\n\t\t\t\tif(!~dis[e.to]&&e.flow!=e.cap)\n\t\t\t\t\tq.push(e.to),dis[e.to]=dis[u]+1;\n\t\t}\n\t\treturn dis[t]!=-1;\n\t}\n\tint maxflow(int _s,int _t){\n\t\ts=_s,t=_t;\n\t\tint flow=0,df;\n\t\twhile(bfs()){\n\t\t\tMEM(cur,0);\n\t\t\twhile(df=dfs(s,INF)) flow+=df;\n\t\t}\n\t\treturn flow;\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;++i) G[i].clear();\n\t}\n\tvoid add_edge(int a,int b,int cap){\n\t\tG[a].pb(edge{b,cap,0,G[b].size()});\n\t\tG[b].pb(edge{a,0,0,G[a].size()-1});\n\t}\n}Dinic;\n\nint match[200005],n;\npii ans[100005];\nvector<int> G[100005],one;\nbitset<100005> vis;\n\nvoid dfs(int u,int f)\n{\n\tvis[u]=1;\n\tif(u!=1)\n\t\tans[match[u]-n]=MP(u,f);\n\tfor(int i:G[u])\n\t\tif(!vis[i])\n\t\t\tdfs(i,u);\n}\n\nint main()\n{jizz\n\tint t,x;\n\tcin >> n,Dinic.init(2*n-2);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tcin >> t;\n\t\twhile(t--)\n\t\t\tif(cin >> x,x==1)\n\t\t\t\tone.pb(i+n);\n\t\t\telse\n\t\t\t\tDinic.add_edge(x,i+n,1);\n\t}\n\tfor(int i=2;i<=n;++i)\n\t\tDinic.add_edge(0,i,1);\n\tfor(int i=1;i<n;++i)\n\t\tDinic.add_edge(i+n,1,1);\n\tif(Dinic.maxflow(0,1)!=n-1)\n\t\treturn cout << \"-1\\n\",0;\n\tfor(int i=2;i<=n;++i)\n\t\tfor(auto e:Dinic.G[i])\n\t\t\tif(e.cap==e.flow&&e.to>n)\n\t\t\t{\n\t\t\t\tmatch[i]=e.to,match[e.to]=i;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i:one)\n\t\tG[1].pb(match[i]),G[match[i]].pb(1);\n\tfor(int i=2;i<=n;++i)\n\t\tfor(auto e:Dinic.G[i])\n\t\t\tif(e.cap!=e.flow&&e.to>n)\n\t\t\t\tG[i].pb(match[e.to]),G[match[e.to]].pb(i);\n\tdfs(1,-1);\n\tfor(int i=1;i<n;++i)\n\t\tcout << ans[i].F << \" \" << ans[i].S << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\treturn 0;\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F> struct dinic {\n    static constexpr F inf = numeric_limits<F>::has_infinity ?\n        numeric_limits<F>::infinity() : numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return { res, flow };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    int src = 0, snk = 2 * N;\n    dinic<int> g(2 * N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        g.arc(src, i, 1);\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        g.arc(N + i, snk, 1);\n\n        int sz, w;\n        cin >> sz;\n        for (int j = 0; j < sz; j++) {\n            cin >> w;\n            g.arc(w, N + i, 1);\n        }\n    }\n\n    auto [F, flow] = g.max_flow(src, snk);\n    if (F != N - 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int root;\n    for (int e : g.adj[src]) {\n        if (flow[e] == 0) {\n            root = g.dest[e];\n            break;\n        }\n    }\n\n    vi vis(g.V);\n    vis[src] = -1;\n    vis[snk] = -1;\n    vis[root] = root;\n\n    queue<int> bfs({ root });\n    while (!bfs.empty()) {\n        int loc = bfs.front();\n        bfs.pop();\n        for (int e : g.adj[loc]) {\n            if (!vis[g.dest[e]] && (loc > N && flow[e] == -1 || loc <= N && flow[e] == 0)) {\n                vis[g.dest[e]] = loc;\n                bfs.push(g.dest[e]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> res(N - 1);\n    for (int i = 1; i <= N; i++) {\n        if (i == root) continue;\n        if (!vis[i]) { cout << -1 << endl; return 0; }\n        res[vis[i] - N - 1] = { i, vis[vis[i]] };\n    }\n\n    for (auto [u, v] : res) {\n        cout << u << \" \" << v << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*4,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[S]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\toutarr(dis,1,n);\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(now,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define M 400010\n#define inf 1e9\nusing namespace std;\nint n,num,cnt,s,t,h[M],head[M],son[M],vis[M];\nvector<int>S[M],P[M];\nqueue<int>Que;\nstruct node{int x,y,id;}f[M];\nstruct edge{int next,to,dis;}e[M<<1];\nbool cmp(node a,node b) {return a.id<b.id;}\nvoid add(int from,int to,int dis) {\n\te[num]=(edge){head[from],to,dis};\n\thead[from]=num++;\n}\nbool bfs() {\n\tqueue<int>Q;Q.push(s);\n\tmemset(h,0,sizeof(h)),h[s]=1;\n\twhile(!Q.empty()) {\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis>0&&!h[e[i].to])\n\t\t\t\tQ.push(e[i].to),h[e[i].to]=h[x]+1;\n\t}\n\treturn h[t];\n}\nint dfs(int x,int dis) {\n\tif(x==t) return dis;int sum=0;\n\tfor(int i=head[x];i;i=e[i].next) {\n\t\tint to=e[i].to;\n\t\tif(e[i].dis&&h[to]==h[x]+1) {\n\t\t\tint diss=dfs(to,min(e[i].dis,dis));\n\t\t\tdis-=diss;sum+=diss;\n\t\t\te[i].dis-=diss;e[i^1].dis+=diss;\n\t\t\tif(!dis) break;\n\t\t}\n\t}\n\tif(!sum) h[x]=-1;\n\treturn sum;\n}\nint dinic() {\n\tint tot=0;\n\twhile(bfs()) \n\t\ttot+=dfs(s,inf);\n\treturn tot;\n}\nint main() {\n\tscanf(\"%d\",&n);s=0,t=2*n;\n\tfor(int i=1;i<n;i++) {\n\t\tint sum;scanf(\"%d\",&sum);\n\t\tfor(int j=1;j<=sum;j++) {\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tS[i+n].push_back(x);\n\t\t\tadd(i+n,x,0),add(x,i+n,1);\n\t\t\tP[x].push_back(i+n);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) add(i,s,0),add(s,i,1);\n\tfor(int i=n+1;i<n+n;i++) add(t,i,0),add(i,t,1);\n\tint ans=dinic();\n\tif(ans!=n-1) {puts(\"-1\");return 0;}\n\tfor(int x=n+1;x<n+n;x++)\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis&&e[i].to!=t)\n\t\t\t\tson[x]=e[i].to;\n\tQue.push(1);\n\twhile(!Que.empty()) {\n\t\tint x=Que.front();Que.pop();\n\t\tfor(int i=0;i<P[x].size();i++) {\n\t\t\tint to=P[x][i];\n\t\t\tif(!vis[to]) {\n\t\t\t\tvis[to]=true;\n\t\t\t\tQue.push(son[to]);\n\t\t\t\tf[++cnt]=(node){x,son[to],to};\n\t\t\t}\n\t\t}\n\t}\n\tsort(f+1,f+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=100005;\nstruct edge\n{\n\tint to,nxt;\n}e[N<<1]; int n,x,y,cnt,head[N],frm[N],tim[N],pre[N],q[N];\ninline void addedge(CI x,CI y)\n{\n\te[++cnt]=(edge){y,head[x]}; head[x]=cnt;\n}\n#define to e[i].to\ninline bool find(CI now,CI t)\n{\n\tfor (RI i=head[now];i;i=e[i].nxt) if (tim[to]!=t)\n\tif (tim[to]=t,!frm[to]||find(frm[to],t)) return frm[to]=now,1; return 0;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),i=1;i<n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=x;++j) scanf(\"%d\",&y),addedge(y,i);\n\tfor (i=2;i<=n;++i) if (!find(i,i)) return puts(\"-1\"),0;\n\tRI H=0,T=1; q[1]=1; while (H<T)\n\t{\n\t\tint now=q[++H]; for (i=head[now];i;i=e[i].nxt)\n\t\tif (!pre[to]) pre[to]=now,q[++T]=frm[to];\n\t}\n\tif (T!=n) return puts(\"-1\"),0;\n\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",pre[i],frm[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define M 100010\nusing namespace std;\nstruct edge{int x,y;}f[M];\nint n,cnt,p[M],vis[M];\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int T=1;T<n;T++) {\n\t\tint m;scanf(\"%d\",&m);\n\t\tfor(int i=1;i<=m;i++) scanf(\"%d\",&p[i]);\n\t\tif(T==1) {\n\t\t\tvis[p[1]]=vis[p[2]]=true;\n\t\t\tf[++cnt]=(edge){p[1],p[2]};\n\t\t}\n\t\telse{\n\t\t\tint a1=0,a2=0;\n\t\t\tfor(int i=1;i<=m;i++) {\n\t\t\t\tif(!a1&&vis[p[i]]) a1=p[i];\n\t\t\t\telse if(!a2&&!vis[p[i]]) a2=p[i];\n\t\t\t}\n\t\t\tif(!a1||!a2) {puts(\"-1\");return 0;}\n\t\t\tf[++cnt]=(edge){a1,a2};vis[a1]=vis[a2]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500015;\nconst int INF = (int) 1e9;\nint e_num = 1, S, T;\nint hed[maxn], dep[maxn];\nstruct Edge {\n  int from, to, nxt, c;\n} edge[maxn * 4];\nvoid addedge(int from, int to, int c) {\n  edge[++e_num] = (Edge){from, to, hed[from], c};\n  hed[from] = e_num;\n}\nvoid adde(int from, int to, int c) {\n  addedge(from, to, c);\n  addedge(to, from, 0);\n}\nint que[maxn + 5], head = 0, tail = 0;\nbool bfs() {\n  head = tail = 0;\n  que[tail++] = S;\n  for (int i = S; i <= T; i++) dep[i] = 0;\n  dep[S] = 1;\n  while (head != tail) {\n    int cur = que[head++]; head %= maxn;\n    for (int i = hed[cur]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (!dep[to] && edge[i].c) {\n        dep[to] = dep[cur] + 1;\n        que[tail++] = to; tail %= maxn;\n      }\n    }\n  }\n  return dep[T];\n}\nint dfs(int x, int flow) {\n  if (x == T) return flow;\n  int ret = 0;\n  for (int i = hed[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (dep[to] == dep[x] + 1 && edge[i].c) {\n      int tmp = dfs(to, std::min(flow, edge[i].c));\n      edge[i].c -= tmp;\n      edge[i ^ 1].c += tmp;\n      flow -= tmp;\n      ret += tmp;\n      if (!flow) {\n        break;\n      }\n    }\n  }\n  if (!ret) dep[x] = 0;\n  return ret;\n}\nint dinic() {\n  int ret = 0;\n  while (bfs()) {\n    ret += dfs(S, INF);\n  }\n  return ret;\n}\n\nconst int N = 100233;\nint n, visit[N], son[N], fa[N];\nvector<int> e[N], g[N];\nint main() {\n  scanf(\"%d\", &n);\n  S = 0, T = n * 2 + 1;\n  for (int i = 1, t, x; i < n; i++) {\n    adde(S, i, 1);\n    scanf(\"%d\", &t);\n    while (t--) {\n      scanf(\"%d\", &x);\n      e[i].push_back(x);\n      g[x].push_back(i);\n      if (x > 1) adde(i, x + n, 1);\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    adde(i + n, T, 1);\n  }\n  int p = dinic();\n  if (p < n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    for (int e = hed[i]; e; e = edge[e].nxt) {\n      if (edge[e].to > n && !edge[e].c) {\n        son[i] = edge[e].to - n;\n      }\n    }\n  }\n  queue<int> q;\n  for (auto x : g[1]) {\n    q.push(x);\n    visit[x] = 1;\n    fa[x] = 1;\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto y : g[son[x]]) {\n      if (!visit[y]) {\n        q.push(y);\n        visit[y] = 1;\n        fa[y] = son[x];\n      }\n    }\n  }\n  if (accumulate(visit + 1, visit + n, 0) != n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", fa[i], son[i]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nint cho1[MAXN+5],cho2[MAXN+5];\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\tint cnt=0;\n\twhile(!Q.empty()){\n\t\tcnt++;\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tcho1[s]=u,cho2[s]=ma[s];\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",cho1[i],cho2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct Matching2 { // for bipartite graph\n    vector<int>matchM, matchW, use;\n    int ans;\n    bool dfs(const VI G[], int v) {\n\tif (use[v]) return false;\n\tuse[v] = true;\n\tfor (int i=0; i<(int)G[v].size(); i++) {\n\t    int u = G[v][i];\n\t    if (matchW[u] == -1 || dfs(G, matchW[u])) {\n\t\tmatchM[v] = u;\n\t\tmatchW[u] = v;\n\t\treturn true;\n\t    }\n\t}\n\treturn false;\n    }\n    Matching2(const VI G[], int sizeM, int sizeW): matchM(sizeM, -1), matchW(sizeW, -1), ans(0) {\n\tuse = vector<int>(sizeM, 0);\n\tfor (int i=0; i<sizeM; i++) {\n\t    fill(use.begin(), use.end(), 0);\n\t    if (dfs(G, i)) ans++;\n\t}\n    }\n};\n\nint N;\nVI E[100011];\nVI R[100011];\nVI G[100011];\nbool use[100011];\npair<int, int> ans[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint K;\n\tscanf(\"%d\", &K);\n\tE[i].resize(K);\n\tREP (j, K) scanf(\"%d\", &E[i][j]), E[i][j]--;\n    }\n\n    REP (i, N-1) {\n\tG[i] = E[i];\n\tG[i].erase(remove(G[i].begin(), G[i].end(), N-1), G[i].end());\n\tEACH (e, E[i]) R[*e].push_back(i);\n    }\n\n    Matching2 X(G, N-1, N-1);\n\n    if (X.ans == N-1) {\n\tVI ord; ord.reserve(N);\n\tord.push_back(N-1);\n\tuse[N-1] = true;\n\tfor (int i=0; i<(int)ord.size(); i++) {\n\t    int v = ord[i];\n\t    EACH (e, R[v]) if (!use[*e]) {\n\t\tint w = X.matchM[*e];\n\t\tans[*e] = make_pair(v, w);\n\t\tord.push_back(w);\n\t\tuse[*e] = true;\n\t    }\n\t}\n\n\tif ((int)ord.size() == N) {\n\t    REP (i, N-1) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t    return;\n\t}\n    }\n    puts(\"-1\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n \n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n \nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n \ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n \nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\nint y[M];\n \nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n \ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n \ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n \ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n\tfo(i,1,T)y[i]=la[i];\n}\n \ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(;y[o];y[o]=ne[y[o]])\n\tif(dep[lb[y[o]]]==dep[o]+1&&c[y[o]])\n\tif(flow(lb[y[o]])){\n\t\tc[y[o]]=0;\n\t\tc[y[o]^1]=1;\n\t\treturn 1;\n\t}\n\tdep[o]=-1;\n\treturn 0;\n}\n \ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[re[lb[y]]][0]=o;\n\t\tbb[re[lb[y]]][1]=lb[y];\n\t\t++oo;\n\t\tdg(lb[y]);\n\t}\n}\n \nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int S=0,T=1;\nstruct bian\n{\n\tint nxt,to,f;\n}bi[1000010];\nint n,head[200020],num=1,cur[200020],dep[200020],flow,match[200020],f[200020];\nvector<int>E[100010];\ninline void add(int from,int to,int f){bi[++num]=bian{head[from],to,f};head[from]=num;}\ninline void ADD(int from,int to,int f){add(from,to,f),add(to,from,0);}\nint q[200020],h,t;\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tmemcpy(cur,head,sizeof(cur));\n\th=0,t=1;q[t]=S;dep[S]=1;\n\tint x,y;\n\twhile(h<t)\n\t{\n\t\tx=q[++h];\n\t\tfor(int i=head[x];i;i=bi[i].nxt)\n\t\t\tif(bi[i].f)\n\t\t\t{\n\t\t\t\ty=bi[i].to;\n\t\t\t\tif(!dep[y])dep[y]=dep[x]+1,q[++t]=y;\n\t\t\t}\n\t}\n\treturn dep[T]!=0;\n}\nint dfs(int v,int last)\n{\n//\tprintf(\"%d %d\\n\",v,last);\n\tif(v==T)\n\t{\n\t\tflow+=last;\n\t\treturn last;\n\t}\n\tint now=0;\n\tfor(int &i=cur[v],u;i;i=bi[i].nxt)\n\t\tif(bi[i].f)\n\t\t{\n\t\t\tu=bi[i].to;\n\t\t\tif(dep[u]!=dep[v]+1)continue;\n\t\t\tint dmin=dfs(u,min(last,bi[i].f));\n\t\t\tbi[i].f-=dmin,bi[i^1].f+=dmin;\n\t\t\tlast-=dmin,now+=dmin;\n\t\t\tif(!last)return now;\n\t\t}\n\treturn now;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;++i)ADD(S,i,1);\n\tfor(int i=1;i<n;++i)ADD(i+n,T,1);\n\tint x;\n\tfor(int i=1;i<=n-1;++i)\n\t{\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tfor(int j=1;j<=cnt;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tE[x].push_back(i);\n\t\t\tif(x>1)ADD(x,i+n,1);\n\t\t}\n\t}\n//\tfor(int i=0;i<=2*n;++i)\n//\t\tfor(int j=head[i];j;j=bi[j].nxt)\n//\t\t\tprintf(\"%d %d %d\\n\",i,bi[j].to,bi[j].f);\n\twhile(bfs())\n\t\twhile(dfs(S,0x3f3f3f3f));\n//\tprintf(\"%d\\n\",flow);\n\tif(flow!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=n-1;++i)\n\t\tfor(int j=head[i+n];j;j=bi[j].nxt)\n\t\t\tif(bi[j].to<=n&&bi[j].f){match[i]=bi[j].to;break;}\n//\tfor(int i=1;i<=n-1;++i)printf(\"%d \",match[i]);printf(\"\\n\");\n\tmemset(dep,0,sizeof(dep));\n\th=0,t=1;q[t]=1;\n\twhile(h<t)\n\t{\n\t\tx=q[++h];\n\t\tfor(auto y:E[x])\n\t\t\tif(!dep[y])\n\t\t\t{\n\t\t\t\tdep[y]=1;\n\t\t\t\tq[++t]=match[y];\n\t\t\t\tf[match[y]]=x;\n\t\t\t}\n\t}\n\tif(t!=n){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=n-1;++i)printf(\"%d %d\\n\",match[i],f[match[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nstruct Edge{int go; int c; int f;};\nvector<int> where, d, vert;\nvector<Edge> edges;\nvector<bool> used;\nvector<vector<int> > data;\nint number, m;\nqueue<int> q;\nint INF = 1e15;\nvoid construct_edge(int u, int v, int c){\n    Edge e1 = {v, c, 0};\n\tEdge e2 = {u, 0, 0};\n    edges.push_back(e1);\n\tedges.push_back(e2);\n\tdata[u].push_back(edges.size() - 2);\n\tdata[v].push_back(edges.size() - 1);\n}\nint dfs(int vertex, int flow, int maximum){\n    if (vertex == number - 1) return flow;\n    while (where[vertex] < data[vertex].size()){\n        int i = where[vertex];\n\t\tint edge_number = data[vertex][i];\n        int to = edges[edge_number].go;\n        int can = min(edges[edge_number].c - edges[edge_number].f, flow);\n        if (can < maximum || d[to] != d[vertex] + 1) {\n            where[vertex]++;\n            continue;\n        }\n        int fl = dfs(to, can, maximum);\n        if (fl >= maximum){\n            edges[edge_number].f += fl;\n            edges[edge_number^1].f -= fl;\n            return fl;\n        }\n        where[vertex]++;\n    }\n    return 0;\n}\nvoid bfs(int maximum){\n    while (!q.empty()){\n        int vertex = q.front();\n        q.pop();\n        for (int i=0; i < data[vertex].size(); i++){\n\t\t\tint edge_number = data[vertex][i];\n            int nv = edges[edge_number].go;\n            int can = edges[edge_number].c - edges[edge_number].f;\n            if (d[nv] == -1 && can >= maximum){\n                d[nv] = d[vertex] + 1;\n                q.push(nv);\n            }\n        }\n    }\n}\nvoid DFS(int vertex){\n    used[vertex] = true;\n    vert.push_back(vertex);\n    for (int i=0; i < data[vertex].size(); i++){\n        int e = data[vertex][i];\n        if (edges[e].f == edges[e].c) continue;\n        if (used[edges[e].go]) continue;\n        DFS(edges[e].go);\n    }\n}\nint dinic(){\n    int A = 1LL << 60;\n    while (A > 0){\n        while (true){\n            for (int i=0; i < number; i++){\n                where[i] = 0;\n                d[i] = -1;\n            }\n            d[0] = 0;\n            q.push(0);\n            bfs(A);\n            if (d[number-1] == -1) break;\n            while (true){\n                int flow = dfs(0, INF, A);\n                if (flow < A) break;\n            }\n        }\n        A /= 2;\n    }\n    int ans = 0;\n    for (int i=0; i < data[0].size(); i++){\n        ans += edges[data[0][i]].f;\n    }\n    return ans;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    number = 2*n+1;\n    for (int i=0; i < number; i++){\n        where.push_back(0);\n        used.push_back(false);\n        d.push_back(0);\n        vector<int> help;\n        data.push_back(help);\n    }\n    for (int i=0; i < n-1; i++) construct_edge(0, i+1, 1);\n    for (int i=0; i < n; i++) construct_edge(n+i, number-1, 1);\n    vector<vector<int> > where(n), tot(n-1);\n    for (int i=0; i < n-1; i++){\n        int x;\n        cin >> x;\n        for (int j=0; j < x; j++){\n            int a;\n            cin >> a;\n            tot[i].push_back(a-1);\n            where[a-1].push_back(i);\n            construct_edge(i+1, n+a-1, 1);\n        }\n    }\n    int res = dinic();\n    if (res != n-1){\n        cout << -1;\n        return 0;\n    }\n    vector<int> nei;\n    for (int i=1; i < n; i++){\n        for (int j=0; j < data[i].size(); j++){\n            if (data[i][j] % 2 != 0) continue;\n            int num = data[i][j];\n            if (edges[num].f > 0){\n                nei.push_back(edges[num].go - n);\n            }\n        }\n    }\n    //for (int i=0; i < n-1; i++) cout << nei[i] << endl;\n    set<int> kek;\n    for (int i=0;i<n-1; i++) kek.insert(nei[i]);\n    for (int i=0; i < n; i++) if (!kek.count(i)) nei.push_back(i);\n    set<int> may;\n    set<int> used, e;\n    e.insert(nei.back());\n    for (int i=0; i < where[nei.back()].size(); i++){\n        may.insert(where[nei.back()][i]);\n    }\n    vector<pair<int, int> > ans(n-1);\n    for (int i=0; i < n-1; i++){\n        if (!may.size()){\n            cout <<-1;\n            return 0;\n        }\n        auto it = may.begin();\n        int num = *it;\n        may.erase(it);\n        int element = nei[num];\n        for (int j=0; j < tot[num].size(); j++){\n            int N = tot[num][j];\n            if (e.count(N)){\n                ans[num] = {N, element};\n                break;\n            }\n        }\n        used.insert(num);\n        e.insert(element);\n        for (int j=0; j < where[element].size(); j++){\n            int T = where[element][j];\n            if (!used.count(T)) may.insert(T);\n        }\n    }\n    for (int i=0;i<n-1;i++) cout << ans[i].first+1 << \" \" << ans[i].second+1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#include<cstring>\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\nconst int INF=1e9;\n\nint n;\nvector<int> rec[100010];\nstruct Edge{\n\tint to,nxt,val;\n}edge[800010];\nint cnt=1,last[200010],S=2e5+1,T=2e5+2,lastcur[200010];\ninline void addedge(int x,int y){\n//\tprintf(\"addedge %d->%d\\n\",x,y);\n\tedge[++cnt]=(Edge){y,last[x],1},last[x]=cnt;\n\tedge[++cnt]=(Edge){x,last[y],0},last[y]=cnt;\n}\nint dep[200010]; int que[200010],hd,tl;\nbool bfs(){\n\tmemset(dep+1,-1,T*sizeof(int)); hd=tl=0;\n\tdep[S]=1; que[++tl]=S;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (edge[i].val&&!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tif (v==T) return 1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int cur,int flw){\n//\tprintf(\"dfs %d %d\\n\",cur,flw);\n\tif (cur==T) return flw;\n\tint tmp,used=0;\n\tfor (int &i=lastcur[cur],v;i;i=edge[i].nxt)\n\t\tif (edge[i].val&&dep[cur]+1==dep[v=edge[i].to]){\n\t\t\ttmp=dfs(v,min(flw-used,edge[i].val));\n\t\t\tedge[i].val-=tmp; edge[i^1].val+=tmp;\n\t\t\tused+=tmp; if (used==flw) return used;\n\t\t}\n\tif (!used) dep[cur]=-1;\n\treturn used;\n}\nint maxflow(){\n\tint res=0;\n\twhile (bfs()){\n\t\tmemcpy(lastcur+1,last+1,T*sizeof(int));\n\t\tres+=dfs(S,INF);\n\t}\n\treturn res;\n}\nint chosen[100010];\ntypedef pair<int,int> P;\nvector<P> ans;\nbool vis[100010];\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\taddedge(S,i+1),addedge(i+n,T);\n\t\tfor (int c=read(),t;c--;){\n\t\t\tt=read(); rec[t].push_back(i);\n\t\t\taddedge(t,i+n);\n\t\t}\n\t}\n\tif (maxflow()^(n-1)) return puts(\"-1\"),0;\n\tfor (int i=2;i<=n;i++)\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt)\n\t\t\tif ((v=edge[j].to)>n&&(edge[j].val^1)){\n\t\t\t\tchosen[v-n]=i; break;\n\t\t\t}\n\thd=tl=0; que[++tl]=1; vis[1]=1;\n\tans.resize(n); int tot=0;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=0;i<rec[u].size();i++){\n\t\t\tv=chosen[rec[u][i]];\n\t\t\tif (!vis[v]) vis[v]=1,que[++tl]=v,ans[rec[u][i]]=(P){u,v},tot++;\n\t\t}\n\t}\n\tif (tot!=n-1) return puts(\"-1\"),0;\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 8e5 + 10, maxm = maxn;\nint to[maxm], nxt[maxm], head[maxn], cap[maxm], e, dep[maxn], flow[maxm], vis[maxn], s, t;\npair<int, int> p[maxn];\n\nvoid add(int x, int y, int z)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0;\n}\n\nint bfs()\n{\n\tmemset(dep, 0, sizeof(dep));\n\tqueue<int> Q;\n\tdep[s] = 1; Q.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(!dep[v] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dep[t]) return 1;\n\treturn 0;\n}\n\nint dfs(int x, int a)\n{\n\tif(x == t || a == 0) return a;\n\tint FLOW = 0, f;\n\tfor(int i = head[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif(dep[v] == dep[x] + 1 && (f = dfs(v, min(a, cap[i] - flow[i]))) > 0)\n\t\t{\n\t\t\tFLOW += f;\n\t\t\ta -= f;\n\t\t\tflow[i] += f; flow[i ^ 1] -= f;\n\t\t\tif(!a) return FLOW;\n\t\t}\n\t}\n\treturn FLOW;\n}\n\nint main()\n{\n\n\tint n = read();\n\te = 1; s = 0; t = n + n;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint m = read();\n\t\tfor(int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\n\tfor(int i = 2; i <= n; ++i) add(s, i, 1);\n\tfor(int i = n + 1; i <= n + n - 1; ++i) add(i, t, 1);\n\n\twhile(bfs()) dfs(s, 0x3f3f3f3f);\n\tfor(int u = 2; u <= n; ++u)\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(cap[i] == flow[i] && to[i] != s)\n\t\t{\n\t//\t\tcout << u << ' ' << to[i] << endl;\n\t\t\tp[to[i]].x = u;\n\t\t}\n\n\tqueue<int> Q; Q.push(1);\n\tint fg = n - 1;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(to[i] != s && !vis[to[i]])\n\t\t\tp[to[i]].y = u, vis[to[i]] = 1, Q.push(p[to[i]].x), --fg;\n\t}\n\tif(fg) return puts(\"-1\"), 0;\n\n\tfor(int i = n + 1; i <= n + n - 1; ++i) printf(\"%d %d\\n\", p[i].x, p[i].y);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=12e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(dep[lb[y]]==dep[o]+1&&c[y])\n\tif(flow(lb[y])){\n\t\tc[y]=0;\n\t\tc[y^1]=1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[++oo][0]=o;\n\t\tbb[oo][1]=lb[y];\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse ans=ans+flow(S);\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    while (!q.empty()) {\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v, done);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nnamespace MF{\n\t#define MAXN 25252\n\t#define MAXM 364364//実際の辺の2倍必要！！\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//フローを流した後の残余グラフからカットでS側に属する辺を求める\n\t//この後levの中身が非負な点がS側の点っぽい？(AOJ2396でverify済み？)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//マッチング相手\nbool used[200100];//マッチング相手として使われたか\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nstd::vector<int> set[maxn];\n\nint head[maxn << 1], nxt[maxn << 2], to[maxn << 2], cap[maxn << 2], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f = dinic(s, t);\n\t\twhile(f) {\n\t\t\tflow += f;\n\t\t\tf = dinic(s, t);\n\t\t}\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[ap] = u;\n\t\t\t\tansy[ap] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#define N 500001\nusing namespace std;\nint total1,total2;\nint nexts[N],head[N],edge[N],nexts2[N],head2[N],edge2[N];\nint n;\nbool go[N];\nvector<int>s[N];\nvoid insert(int x,int y)\n{\n\ttotal1++;\n\tnexts[total1]=head[x];\n\thead[x]=total1;\n\tedge[total1]=y;\n}\nvoid insert2(int x,int y)\n{\n\ttotal2++;\n\tnexts2[total2]=head2[x];\n\thead2[x]=total2;\n\tedge2[total2]=y;\n}\nvoid dfs(int k,int fa)\n{\n\tgo[k]=true;\n\tinsert2(k,fa);\n\tinsert2(fa,k);\n\tfor (int i=head[k];i;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (go[y]) continue;\n\t\tdfs(y,k);\n\t\tif (k<n) break;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) scanf(\"%d\",&s[i][j]);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert(i,s[i][j]+n);\n\t\t\tinsert(s[i][j]+n,i);\t\n\t\t}\n\t}\n\tmemset(go,false,sizeof(go));\n\tdfs(1+n,0);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!go[i+n])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tif (y>n)\n\t\t\t\tprintf(\"%d \",y-n);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005, inf = 0x3f3f3f3f;\n\nint n, s, t, head[N], tot = 1, f[N];\nstruct edge { int to, nxt, rem; } e[N << 2];\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\n\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x], 1 }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y], 0 }, head[y] = tot;\n\tif (x != s && y != t) f[find(x)] = find(y);\n}\n\nint dis[N];\nbool bfs() {\n\tstd::memset(dis, 0, sizeof dis), dis[s] = 1;\n\tstd::queue<int> q; q.push(s);\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].rem && !dis[e[i].to])\n\t\t\t\tdis[e[i].to] = dis[tmp] + 1, q.push(e[i].to);\n\t}\n\treturn dis[t] > 0;\n}\nint dinic(int x, int low) {\n\tif (x == t || !low) return low;\n\tint ans = 0, t;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (e[i].rem && dis[e[i].to] > dis[x] && (t = dinic(e[i].to, std::min(low, e[i].rem)))) {\n\t\t\te[i].rem -= t, e[i ^ 1].rem += t, low -= t, ans += t;\n\t\t\tif (!low) break;\n\t\t}\n\treturn ans;\n}\n\nstd::pair<int, int> ans[N];\nint E[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n, s = 0, t = 2 * n;\n\tfor (int i = 1; i < 2 * n; ++i) f[i] = i;\n\tfor (int i = 1, c, x; i < n; ++i) {\n\t\tstd::cin >> c, link(s, i + n);\n\t\twhile (c--) std::cin >> x, link(i + n, x);\n\t}\n\tfor (int i = 2; i <= n; ++i) link(i, t);\n\tfor (int i = 1; i < 2 * n; ++i) if (find(i) != find(1))\n\t\treturn std::cout << \"-1\\n\", 0;\n\tint sum = 0;\n\twhile (bfs()) sum += dinic(s, inf);\n\tif (sum < n - 1) return std::cout << \"-1\\n\", 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = head[i + n]; j; j = e[j].nxt)\n\t\t\tif (e[j].to != s && !e[j].rem) E[i] = e[j].to;\n\tstatic bool vis[N];\n\tstd::queue<int> q; q.push(1), vis[1] = 1;\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].to != t && !vis[E[e[i].to - n]]) {\n\t\t\t\tvis[E[e[i].to - n]] = 1, q.push(E[e[i].to - n]);\n\t\t\t\tans[e[i].to - n] = std::make_pair(tmp, E[e[i].to - n]);\n\t\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cout << ans[i].first << ' ' << ans[i].second << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e5+5;\nint par[N] = {};\n\nvoid init(){\n\tfor (int i = 0; i < N; i++)\n\t\tpar[i] = i;\n}\n\nint root(int x) {\n\tif(x == par[x])\treturn x;\n\treturn root(par[x]);\n}\n\nvoid join(int x, int y) {\n\tpar[root(x)] = root(y);\n}\n\nvoid solve() {\n\tll p;\t\n\tcin >> p;\n\tp--;\n\tinit();\n\tvector<pair<int,int>> ans;\n\tbool possible = false;\n\twhile (p--) {\n\t\tll n;\n\t\tcin >> n;\n\t\tll start;\n\t\tcin >> start;\n\t\tn--;\n\t\tbool added =false;\n\t\twhile(n--) {\n\t\t\tll p;\n\t\t\tcin >> p;\n\t\t\tif ((!added) && (root(start) != root(p))) {\n\t\t\t\tjoin(start, p);\n\t\t\t\tadded = true;\n\t\t\t\tans.push_back({start, p});\n\t\t\t} \n\t\t}\n\t\tif (!added) {\n\t\t\tcout << -1 << endl;\treturn;\n\t\t}\n\t}\n\n\tfor (auto x: ans) {\n\t\tcout << x.first << ' ' << x.second << endl;\n\t}\n}\n\nint main() {\n\tll t = 1;\n\t//cin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 200500\nqueue<int> tp;\nint n,m,a,head[N],cnt=1,id[N],fa[N],cur[N],dis[N],is[N],ct1;\nvector<int> st2[N];\nstruct edge{int t,next,v;}ed[N*4];\nvoid adde(int f,int t,int v){ed[++cnt]=(edge){t,head[f],v};head[f]=cnt;ed[++cnt]=(edge){f,head[t],0};head[t]=cnt;}\nbool bfs(int s,int t)\n{\n\tmemset(dis,-1,sizeof(dis));\n\tmemcpy(cur,head,sizeof(cur));\n\tdis[s]=0;\n\tqueue<int> st;st.push(s);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tfor(int i=head[a];i;i=ed[i].next)\n\t\tif(ed[i].v&&dis[ed[i].t]==-1)\n\t\t{\n\t\t\tdis[ed[i].t]=dis[a]+1,st.push(ed[i].t);\n\t\t\tif(ed[i].t==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int u,int t,int f)\n{\n\tif(u==t||!f)return f;\n\tint as=0,tp;\n\tfor(int &i=cur[u];i;i=ed[i].next)\n\tif(ed[i].v&&dis[ed[i].t]==dis[u]+1&&(tp=dfs(ed[i].t,t,min(ed[i].v,f))))\n\t{\n\t\tas+=tp,f-=tp;ed[i].v-=tp;ed[i^1].v+=tp;\n\t\tif(!f)return as;\n\t}\n\treturn as;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++)scanf(\"%d\",&a),st2[a].push_back(i),adde(a,i+n,1);\n\t}\n\tfor(int i=1;i<n;i++)adde(2*n,i+1,1),adde(i+n,2*n+1,1);\n\tint as=0;while(bfs(n*2,n*2+1))\n\tas+=dfs(n*2,n*2+1,n);\n\tif(as<n-1){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tfor(int j=head[i+n];j;j=ed[j].next)if(ed[j].v)id[i]=ed[j].t;\n\tqueue<int> st;\n\tst.push(1);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tct1++;\n\t\tfor(int j=0;j<st2[a].size();j++)if(!fa[id[st2[a][j]]])fa[id[st2[a][j]]]=a,st.push(id[st2[a][j]]);\n\t}\n\tif(ct1<n){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",fa[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][3];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z,int z1)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf,inf);\n\tinsert(S,T,0,inf);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i],inf);insert(i,SS,0,inf);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i],inf);insert(TT,i,0,inf);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j],down[j]);\n\t\t\tinsert(y,i,0,down[j]);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tfor (int i=2;i<=total2;i++)\n\t\t{\n\t\t\tif (v1[i]>=inf) continue;\n\t\t\tif (v1[i]+v[i^1]==1)\n\t\t\t{\n\t\t\t\tint u1=edge[i];\n\t\t\t\tint u2=edge[i^1];\n\t\t\t\tif (u1<u2)\n\t\t\t\t{\n\t\t\t\t\tint t=u1;u1=u2;u2=t;\n\t\t\t\t}\n\t\t\t\tu1=(u1+n-1)%n+1;\n\t\t\t\tu2=(u2+n-1)%n+1;\n\t\t\t\tans[u1][0]++;\n\t\t\t\tans[u1][ans[u1][0]]=u2;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<n;i++) \n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][2]);\n//\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\nint vt[N*2],tim;\n\nbool bfs(){\n\ttim++;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tvt[st]=tim;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt){\n\t\t\tint y=e[p].x;\n\t\t\tif (vt[y]<tim&&e[p].f){\n\t\t\t\tvt[y]=tim;\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tque[++ta]=y;\t\n\t\t\t}\n\t\t}\n\t}\n\treturn vt[ed]==tim;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&vt[e[p].x]==tim&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs())\n\t\tret+=aug(st,INF);\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nstruct edge{\n\tint y,next,c;\n}s[N<<3];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[st]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t\tif(t==tot) break;\n\t}\n\tif(!tot) d[x]=0;\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(c[P[c[x]][i]]!=c[x] && !las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\\n\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],gap[N << 1],dis[N << 1],pos[N],vis[N];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline int isap(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = isap(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]];\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tfor(gap[0] = T;dis[S] < T;) ans += isap(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[++tot] = mp(x,pos[cur]),Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n    \n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    while (!q.empty()) {\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v, done);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[4*N],cnt=1,s,t,ma[N];\nint d[4*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[10*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1;\n\t\tson[x].push_back(ma[v[x][i]]);\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#include<cstring>\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\nconst int INF=1e9;\n\nint n;\nvector<int> rec[100010];\nstruct Edge{\n\tint to,nxt,val;\n}edge[800010];\nint cnt=1,last[200010],S=2e5+1,T=2e5+2,lastcur[200010];\ninline void addedge(int x,int y){\n//\tprintf(\"addedge %d->%d\\n\",x,y);\n\tedge[++cnt]=(Edge){y,last[x],1},last[x]=cnt;\n\tedge[++cnt]=(Edge){x,last[y],0},last[y]=cnt;\n}\nint dep[200010]; int que[200010],hd,tl;\nbool bfs(){\n\tmemset(dep+1,-1,T*sizeof(int)); hd=tl=0;\n\tdep[S]=1; que[++tl]=S;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (edge[i].val&&!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tif (v==T) return 1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int cur,int flw){\n//\tprintf(\"dfs %d %d\\n\",cur,flw);\n\tif (cur==T) return flw;\n\tint tmp,used=0;\n\tfor (int &i=lastcur[cur],v;i;i=edge[i].nxt)\n\t\tif (edge[i].val&&dep[cur]+1==dep[v=edge[i].to]){\n\t\t\ttmp=dfs(v,min(flw-used,edge[i].val));\n\t\t\tedge[i].val-=tmp; edge[i^1].val+=tmp;\n\t\t\tused+=tmp; if (used==flw) return used;\n\t\t}\n\tif (!used) dep[cur]=-1;\n\treturn used;\n}\nint maxflow(){\n\tint res=0;\n\twhile (bfs()){\n\t\tmemcpy(lastcur+1,last+1,T*sizeof(int));\n\t\tres+=dfs(S,INF);\n\t}\n\treturn res;\n}\nint chosen[100010];\ntypedef pair<int,int> P;\nvector<P> ans;\nbool vis[100010];\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\taddedge(S,i+1),addedge(i+n,T);\n\t\tfor (int c=read(),t;c--;){\n\t\t\tt=read(); rec[t].push_back(i);\n\t\t\taddedge(t,i+n);\n\t\t}\n\t}\n\tif (maxflow()^(n-1)) return puts(\"-1\"),0;\n\tfor (int i=2;i<=n;i++)\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt)\n\t\t\tif ((v=edge[j].to)>n&&(edge[j].val^1)){\n\t\t\t\tchosen[v-n]=i; break;\n\t\t\t}\n\thd=tl=0; que[++tl]=1; vis[1]=1;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=0;i<rec[u].size();i++){\n\t\t\tv=chosen[rec[u][i]];\n\t\t\tif (!vis[v]) vis[v]=1,que[++tl]=v,ans.push_back((P){u,v});\n\t\t}\n\t}\n\tif (ans.size()!=n-1) return puts(\"-1\"),0;\n\tfor (int i=0;i<n-1;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=200010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tvector<pair<int,int> >ans;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans.push_back(make_pair(u,link[v]));\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,0,SZ(ans)-1)cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111],u[111111],v[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n&&pa)\n\t{\n\t\t::u[pa-n]=gp;\n\t\t::v[pa-n]=u;\n\t}\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=2;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=1;i<n;++i)if(!u[i])return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E(200050 * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0, t;i < In[u].size();++i)\n\t\tif (!done[t = In[u][i]])\n\t\t{\n\t\t\tdone[t] = true;\n\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), dfs(v);\n\t\t}\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 1;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tdfs(1); \n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nint lst[200005], to[2000005], pre[2000005], cap[2000005], tot;\nint dep[200005], que[200005], fst[200005];\ninline void add_edge(int u, int v, int _cap)\n{\n\t// printf(\"%d %d %d\\n\", u, v, _cap);\n\tauto add = [&] (int x, int y, int c)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = c;\n\t\tlst[x] = tot++;\n\t};\n\tadd(u, v, _cap);\n\tadd(v, u, 0);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tint he = 0, ta = 0;\n\tque[ta++] = s;\n\twhile (he < ta)\n\t{\n\t\tint u = que[he++];\n\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t{\n\t\t\tif (cap[i] && dep[to[i]] == -1)\n\t\t\t{\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t\tque[ta++] = to[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tint ans = 0;\n\tfor (int i = fst[u]; ~i; i = pre[i])\n\t{\n\t\tif (cap[i] && dep[to[i]] == dep[u] + 1)\n\t\t{\n\t\t\tint res = dfs(to[i], t, std::min(rem - ans, cap[i]));\n\t\t\tcap[i] -= res;\n\t\t\tcap[i ^ 1] += res;\n\t\t\tif (cap[i])\n\t\t\t\tfst[u] = i;\n\t\t\tans += res;\n\t\t\tif (ans == rem)\n\t\t\t\treturn ans;\n\t\t}\n\t}\n\tif (!ans)\n\t\tdep[u] = -1;\n\treturn ans;\n}\ninline int dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t))\n\t{\n\t\tmemcpy(fst, lst, sizeof(lst));\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nstd::vector<int> vec[200005], bel[200005];\nint fa[200005], rep[200005];\nbool vis[200005];\nint add(int u)\n{\n\tint res = 1;\n\tvis[u] = true;\n\tfor (int x : bel[u])\n\t{\n\t\tif (!vis[rep[x]])\n\t\t{\n\t\t\tfa[x] = u;\n\t\t\tres += add(rep[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC029-F.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint len;\n\t\tscanf(\"%d\", &len);\n\t\twhile (len--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tif (--u)\n\t\t\t\tadd_edge(i + 1, u + n - 1, 1);\n\t\t\tvec[i].pb(u);\n\t\t\tbel[u].pb(i);\n\t\t}\n\t\tadd_edge(0, i + 1, 1);\n\t\tadd_edge(i + n, n + n, 1);\n\t}\n\tif (dinic(0, n + n) != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = lst[i]; ~j; j = pre[j])\n\t\t{\n\t\t\tif (to[j] && !cap[j])\n\t\t\t\trep[i - 1] = to[j] - n + 1;\n\t\t}\n\t}\n\tif (add(0) != n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i + 1 < n; i++)\n\t\tprintf(\"%d %d\\n\", fa[i] + 1, rep[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\n\nint n;\n\ninline void failed(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<int> G[N];\nbool vis[N];\nint match[N];\nint pref[N];\nstack<int> stk;\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<G[x].size();i++){\n\t\tint v=G[x][i];if(vis[v])continue;\n\t\tvis[v]=1;stk.push(v);\n\t\tif(!pref[v] || dfs(pref[v])){\n\t\t\tmatch[x] = v;\n\t\t\tpref[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint s[N];\ntypedef pair<int,int> pi;\nvector<pi> tr;\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<n;i++){\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int j=1,e;j<=c;j++){\n\t\t\tscanf(\"%d\",&e);\n\t\t\tG[e].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\t// cout << i << \":\";\n\t\tif(!dfs(i))failed();\n\t\twhile(stk.size()){\n\t\t\t// cout << stk.top();\n\t\t\tvis[stk.top()]=0;\n\t\t\tstk.pop();\n\t\t}\n\t\t// cout << \"?\" << endl;\n\t}\n\tqueue<int> q;\n\tfor(size_t i=0;i<G[1].size();i++){\n\t\ts[G[1][i]]=1;\n\t\tq.push(G[1][i]);\n\t}\n\ttr.resize(n);\n\tint ss=0;\n\twhile(q.size()){\n\t\t++ss;\n\t\tint u=q.front();q.pop();\n\t\tint v = pref[u];\n\t\t// cout << u << \":::\" << s[u] << \" \" << v << endl;\n\t\ttr[u] = pi(v,s[u]);\n\t\tfor(size_t i=0;i<G[v].size();i++){\n\t\t\tif(!s[G[v][i]])s[G[v][i]]=v,q.push(G[v][i]);\n\t\t}\n\t}\n\tif(ss<n-1){\n\t\tfailed();\n\t}\n\tfor(size_t i=1;i<tr.size();i++){\n\t\tprintf(\"%d %d\\n\",tr[i].first,tr[i].second);\n\t}\n\treturn 0;\n}\n/* \n10\n5 1 2 3 4 5\n5 2 3 4 5 6\n5 3 4 5 6 7\n5 4 5 6 7 8\n5 5 6 7 8 9\n5 6 7 8 9 10\n5 7 8 9 10 1\n5 8 9 10 1 2\n5 9 10 1 2 3\n */"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E(200050 * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N];\nvector<int> A[Max_N], In[Max_N];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0, t;i < In[u].size();++i)\n\t\tif (!done[t = In[u][i]])\n\t\t{\n\t\t\tdone[t] = true;\n\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), dfs(v);\n\t\t}\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 1;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tdfs(1); \n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst LL INF=1e16;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+2*NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tvoid AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL Aug(int u,LL flow) {\n\t\tif(u==t) return flow;\n\t\tLL sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min((LL)e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tLL Flow;\n\tLL ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c;i<n;i++) {\n\t\tscanf(\"%d\",&c);\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1,u;j<=c;j++) {\n\t\t\tscanf(\"%d\",&u);\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--, q[a[i][j]].insert(i);\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (w != tos)\n                y = i, q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct vertex {\n\tint estart;\n\tint ecur;\n\tint dist;\n} v[300003];\nstruct edge {\n\tint enext,to;\n\tint cap;\n} e[1000003];int en;\nvoid addedge(int a,int b,int cap)\n{\n\te[en].enext = v[a].estart;e[en].to = b;e[en].cap = cap;v[a].estart = en++;\n\te[en].enext = v[b].estart;e[en].to = a;e[en].cap = 0;v[b].estart = en++;\n}\nint start, end;\nint dfs(int i,int cap)\n{\n\tif(i == end) return cap;\n\tint flow = 0;\n\tfor(int &j = v[i].ecur;j != -1;j = e[j].enext) {\n\t\tint to = e[j].to;\n\t\tif(e[j].cap == 0 || v[to].dist != v[i].dist + 1) continue;\n\t\tint val = dfs(to,std::min(cap,e[j].cap));\n\t\tflow += val;cap -= val;e[j].cap -= val;e[j^1].cap += val;\n\t\tif(cap == 0) break;\n\t}\n\treturn flow;\n}\nint n,m;\nstruct vertex2 {\n\tstd::vector<int> inset;\n\tbool vis;\n} v2[100003];\nstd::pair<int,int> ans[100003];\nint match[100003];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < 2*n+1;++i) {\n\t\tv[i].estart = -1;\n\t}\n\tstart = 2*n-1, end = 2*n;\n\t// root = 0\n\tfor(int i = 1;i < n;++i) {\n\t\taddedge(start,i,1);\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j = 0;j < c;++j) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);--k;\n\t\t\tv2[k].inset.push_back(i);\n\t\t\tif(k != 0) addedge(k,n+i,1);\n\t\t}\n\t\taddedge(n+i,end,1);\n\t}\n\tint flow = 0;\n\tfor(;;) {\n\t\tfor(int i = 0;i < 2*n+1;++i) {\n\t\t\tv[i].dist = -1;\n\t\t\tv[i].ecur = v[i].estart;\n\t\t}\n\t\tv[start].dist = 0;\n\t\tstd::queue<int> q;\n\t\tq.push(start);\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = v[cur].estart;j != -1;j = e[j].enext) {\n\t\t\t\tif(e[j].cap == 0) continue;\n\t\t\t\tint to = e[j].to;\n\t\t\t\tif(v[to].dist == -1) {\n\t\t\t\t\tv[to].dist = v[cur].dist + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v[end].dist == -1) break;\n\t\tflow += dfs(start,999999);\n\t}\n\tif(flow != n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint x = n+i;\n\t\tmatch[i] = -1;\n\t\tfor(int j = v[x].estart;j != -1;j = e[j].enext) {\n\t\t\tif(e[j].to >= 1 && e[j].to < n && e[j].cap == 1) {\n\t\t\t\tmatch[i] = e[j].to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(match[i] != -1);\n\t}\n\t\n\t{\n\t\tstd::queue<int> q;\n\t\tq.push(0);v2[0].vis = true;\n\t\tint cnt = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = 0;j < v2[cur].inset.size();++j) {\n\t\t\t\tint to = v2[cur].inset[j];\n\t\t\t\tif(!v2[match[to]].vis) {\n\t\t\t\t\tans[to] = std::make_pair(cur,match[to]);\n\t\t\t\t\tv2[match[to]].vis = true;\n\t\t\t\t\tq.push(match[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t++cnt;\n\t\t}\n\t\tif(cnt == n) {\n\t\t\tfor(int i = 0;i < n-1;++i) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t\t} else {\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1;\n\t\tson[x].push_back(ma[v[x][i]]);\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) u[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (u[i]) q.push(u[i]), fa[getfa(g[i] = s)] = getfa(h[i] = u[i]), u[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nstd::vector<int> set[maxn];\n\nint head[maxn << 1], nxt[maxn << 2], to[maxn << 2], cap[maxn << 2], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f = dinic(s, t);\n\t\twhile(f) {\n\t\t\tflow += f;\n\t\t\tf = dinic(s, t);\n\t\t}\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[to[i] - n] = u;\n\t\t\t\tansy[to[i] - n] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct Edge {\n\tint v, to;\n\tll cap, flow;\n\n\tEdge() : v(), to(), cap(), flow() {}\n\tEdge(int _v, int _to, ll _cap) : v(_v), to(_to), cap(_cap), flow(0LL) {}\n};\n\nconst ll INF = (ll)1e11;\nconst int N = (int)1e6 + 7;\nEdge ed[N];\nint edSz;\nvector<int> g[N];\nint n;\nint S, T;\nvector<int> ans[N];\nint dist[N];\nint q[N];\nint topQ;\nint idx[N];\n\nvoid addEdge(int v, int to, ll cap) {\n\ted[edSz] = Edge(v, to, cap);\n\tg[v].push_back(edSz++);\n\ted[edSz] = Edge(to, v, 0LL);\n\tg[to].push_back(edSz++);\n}\n\nbool BFS() {\n\tfor (int i = 0; i <= T; i++)\n\t\tdist[i] = N;\n\ttopQ = 0;\n\tq[topQ++] = S;\n\tdist[S] = 0;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int id : g[v]) {\n\t\t\tEdge e = ed[id];\n\t\t\tif (e.cap == e.flow) continue;\n\t\t\tint to = e.to;\n\t\t\tif (dist[to] <= dist[v] + 1) continue;\n\t\t\tdist[to] = dist[v] + 1;\n\t\t\tq[topQ++] = to;\n\t\t}\n\t}\n\treturn dist[T] < N;\n}\nll dfs(int v, ll flow) {\n\tif (flow == 0 || v == T) return flow;\n\tll res = 0;\n\tfor (int &i = idx[v]; i < (int)g[v].size(); i++) {\n\t\tint id = g[v][i];\n\t\tEdge e = ed[id];\n\t\tint to = e.to;\n\t\tif (dist[to] != dist[v] + 1) continue;\n\t\tll df = dfs(to, min(flow, e.cap - e.flow));\n\t\tres += df;\n\t\tflow -= df;\n\t\ted[id].flow += df;\n\t\ted[id ^ 1].flow -= df;\n\t\tif (flow == 0) return res;\n\t}\n\treturn res;\n}\n\nll Flow() {\n\tll res = 0;\n\twhile(BFS()) {\n\t\tfor (int i = 0; i <= T; i++)\n\t\t\tidx[i] = 0;\n\t\tres += dfs(S, INF);\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tS = 2 * n;\n\tT = S + 1;\n\tfor (int i = 0; i < n; i++)\n\t\taddEdge(n + i, T, n - 1);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\taddEdge(S, i, n);\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\twhile(k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tv--;\n\t\t\taddEdge(i, n + v, INF);\n\t\t}\n\t}\n\tif (Flow() != (ll)n * (n - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < edSz; i++) {\n\t\tEdge e = ed[i];\n\t\tif (e.flow <= 0) continue;\n\t\tint v = e.v, u = e.to;\n\t\tif (v >= n || u < n || u >= 2 * n) continue;\n\t\tans[v].push_back(u - n);\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif ((int)ans[i].size() != 2) throw;\n\t\tprintf(\"%d %d\\n\", ans[i][0] + 1, ans[i][1] + 1);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N, N);\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0)\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> chosen(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0 && eref[i][j].get())\n        chosen[i] = e[i][j];\n  }\n  vector<bool> vis(n);\n  vector<pair<int, int>> ans(n - 1);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = true;\n    for (int id : fnd[u])\n      if (chosen[id] != -1) {\n        int v = chosen[id];\n        chosen[id] = -1;\n        ans[id] = make_pair(u + 1, v + 1);\n        dfs(v);\n      }\n  };\n  dfs(0);\n  if (count(chosen.begin(), chosen.end(), -1) != n - 1)\n    cout << \"-1\\n\";\n  else\n    for (const auto& pr : ans)\n      cout << pr.first << ' ' << pr.second << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 600010;\nconst int INF = 2147483600;\n\nint N;\n\nint Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],C[MAXN<<1],cnt; \ninline void addedge(int u,int v,int c){\n\tNode[cnt]=v; Next[cnt]=Root[u]; C[cnt]=c; Root[u]=cnt++;\n}\ninline void insert(int u,int v,int c){\n\taddedge(u,v,c); addedge(v,u,0);\n}\nint S,T; int dis[MAXN+1];\ninline bool BFS(){\n\tfor(int i=S;i<=T;i++) dis[i]=0;\n\tqueue<int> que; que.push(S); dis[S]=1;\n\twhile(!que.empty()){\n\t\tint k=que.front();\n\t\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\t\tint v=Node[x]; \n\t\t\tif(C[x]>0&&!dis[v]) dis[v]=dis[k]+1,que.push(v); \n\t\t} que.pop();\n\t} \n\treturn (dis[T]?1:0);\n}\ninline int DFS(int k,int t){\n\tif(k==T) {return t;} int ret=0;\n\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\tint v=Node[x]; if(C[x]>0&&dis[v]==dis[k]+1){\n\t\t\tint d=DFS(v,min(t,C[x]));\n\t\t\tC[x]-=d; C[x^1]+=d; ret+=d; t-=d;\n\t\t\tif(!t) return ret;\n\t\t}\n\t} if(!ret) dis[k]=0;\n\treturn ret;\n}\nint nod;\nqueue<int> que; int vis[MAXN+1],chs[MAXN+1],root;\nvector<int> vec[MAXN+1]; int P[MAXN+1];\ninline void Add(int k){\n\t++nod; for(int i=0,sz=vec[k].size();i<sz;i++){\n\t\tint j=vec[k][i];\n\t\tif(!vis[j]&&chs[j]!=k) vis[j]=k,que.push(j); \n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); T=2*N,S=0;\n\tmemset(Root,-1,sizeof(Root));\n\tfor(int i=1;i<N;i++){\n\t\tP[i]=read();\n\t\tinsert(S,i,1);\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tint x=read();\n\t\t\tvec[x].push_back(i);\n\t\t\tinsert(i,x+N-1,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) insert(i+N-1,T,1);\n\tint sum=0; while(BFS()) sum+=DFS(S,INF);\n\tif(sum!=N-1){ puts(\"-1\"); return 0; }\n\tint id=1; int now=0;\n\tfor(int i=1;i<N;i++){\n\t\tnow+=2;\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tif(!C[now]) chs[i]=Node[now]-(N-1);\n\t\t\tnow+=2;\n\t\t}\n\t}\n\twhile(now<cnt) {\n\t\tif(C[now]) {\n\t\t\troot=id; break;\n\t\t} now+=2; ++id;\n\t} \n\tAdd(root);\n\twhile(!que.empty()){ int k=que.front();  Add(chs[k]); que.pop(); }\n\tif(nod!=N){ puts(\"-1\"); return 0; }\n\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\",chs[i],vis[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 400050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn],gap[maxn];\nint cur[maxn],prt[maxn];\n\nint isap()\n{\n    for (int i=1;i<=vt;++i) cur[i]=head[i],++gap[d[i]=0];\n    int i=vs,ans=0;\n    while (d[vs]<vt)\n    {\n        if (i==vt)\n        {\n            for (++ans;i!=vs;i=edge[prt[i]^1])\n                // cout<<\"path:\"<<i<<endl,\n                --cost[prt[i]],++cost[prt[i]^1];\n            // cout<<\"path:\"<<vs<<endl<<endl;\n        }\n\n        bool flag=0;\n        for (int k=cur[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (cost[k]&&d[i]==d[j]+1)\n            {\n                flag=1;\n                cur[i]=prt[j]=k;\n                i=j;\n                break;\n            }\n        }\n\n        if (flag)   continue;\n\n        if (--gap[d[i]]==0) break;\n        d[i]=vt;\n        for (int k=head[i];~k;k=nxt[k])\n            if (cost[k])\n                d[i]=min(d[i],d[edge[k]]+1);\n        ++gap[d[i]];\n        cur[i]=head[i];\n        if (i!=vs)\n            i=edge[prt[i]^1];\n    }\n    // cout<<\"isap:\"<<ans<<endl;\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 200002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[5*MAX_N], visited[MAX_N], rev[5*MAX_N];\nint source, target, d[MAX_N], f[5*MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\nqueue<int> qu;\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    while (qu.size())\n        qu.pop();\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tif(!pre[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = lis[i - 1], v = pre[u];\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nusing namespace std;\nint head[262144],now[262144],last[1048576],to[1048576],c[1048576],cnt=1;\nvoid add(int u,int v,int cc)\n{\n\tcnt++;\n\tlast[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n\tc[cnt]=cc;\n}\nint n;\nqueue<int> q;\nint d[262144],pre[262144];\nvoid bfs()\n{\n\tfor(int i=1;i<=(n<<1)+1;i++)\n\t{\n\t\tnow[i]=head[i];\n\t\td[i]=-1;\n\t}\n\td[(n<<1)]=0;\n\tq.push(n<<1);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[u];i;i=last[i])\n\t\t{\n\t\t\tif(c[i]==0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint v=to[i];\n\t\t\tif(d[v]<0)\n\t\t\t{\n\t\t\t\td[v]=d[u]+1;\n\t\t\t\tpre[v]=u;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int u,int a)\n{\n\tif(u==(n<<1)+1||a==0)\n\t{\n\t\treturn a;\n\t}\n\tint flow=0;\n\tfor(int& i=now[u];i;i=last[i])\n\t{\n\t\tint v=to[i];\n\t\tif(d[v]<=d[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint flow2;\n\t\tif(c[i]<a)\n\t\t{\n\t\t\tflow2=dfs(v,c[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflow2=dfs(v,a);\n\t\t}\n\t\tc[i]-=flow2;\n\t\tc[i^1]+=flow2;\n\t\ta-=flow2;\n\t\tflow+=flow2;\n\t\tif(a==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flow;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(1)\n\t{\n\t\tbfs();\n\t\tif(d[(n<<1)+1]<0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tans+=dfs(n<<1,1000000000);\n\t}\n\treturn ans;\n}\nint s[131072],t[131072];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd((n<<1),i,1);\n\t\tadd(i,(n<<1),0);\n\t}\n\tfor(int i=n+1;i<(n<<1);i++)\n\t{\n\t\tadd(i,(n<<1)+1,1);\n\t\tadd((n<<1)+1,i,0);\n\t\tint num;\n\t\tscanf(\"%d\",&num);\n\t\twhile(num--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\",&u);\n\t\t\tadd(u,i,1);\n\t\t\tadd(i,u,0);\n\t\t}\n\t}\n\tif(dinic()<n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(d[i]<0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(d[i]==1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\ts[pre[i]-n]=i;\n\t\tt[pre[i]-n]=pre[pre[i]];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",s[i],t[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 10];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int INF=0x3f3f3f3f;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tinline void AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int Aug(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tint sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min(e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tint Flow;\n\tint ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c;i<n;i++) {\n\t\tscanf(\"%d\",&c);\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1,u;j<=c;j++) {\n\t\t\tscanf(\"%d\",&u);\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=S; dis[S]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[T]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]+1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(u+n,i,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i+n+1,1); dinic::Add(i,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]]==0)d[s]=t+3;else ++u[++d[x]];\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int inf=1000000000;\nint n,m,cnt,p[100001],P[100001],hd[200101],cur[200101],dis[200101],q[200101],l,r,K,x,ans;\nstruct node{int to,next,c;}e[1000001];\nvector<int> v[100001],t[100001];\nbool bo[200101];\n\nvoid addedge(int x,int y,int c) \n{\n\te[++cnt]=(node){y,hd[x],c},hd[x]=cnt;\n\te[++cnt]=(node){x,hd[y],0},hd[y]=cnt;\n}\n\nbool bfs()\n{\n\tfor (int i=1; i<=n+n+1; i++) dis[i]=inf;\n\tq[l=r=1]=1,dis[1]=0,memset(bo,0,sizeof(bo)),bo[1]=1;\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\tif (e[i].c&&!bo[e[i].to]) bo[e[i].to]=1,q[++r]=e[i].to,dis[e[i].to]=dis[x]+1;\n\t\tl++;\n\t}\n\treturn dis[n+n+1]<inf;\n}\n\nbool dinic(int x)\n{\n\tif (x==n+n+1) return 1;\n\tfor (int &i=cur[x]; i; i=e[i].next)\n\t\tif (e[i].c&&dis[e[i].to]==dis[x]+1&&dinic(e[i].to)) \n\t\t\treturn e[i].c--,e[i^1].c++,1;\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),cnt=1;\n\tmemset(hd,0,sizeof(hd));\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&K),v[i].clear();\n\t\tfor (int j=1; j<=K; j++) scanf(\"%d\",&x),v[i].push_back(x);\n\t}\n\tfor (int i=1; i<n; i++) addedge(1,i+1,1);\n\tfor (int i=1; i<=n; i++) addedge(i+n,n+n+1,1),t[i].clear();\n\tfor (int i=1; i<n; i++)\n\t\tfor (int siz=v[i].size(),j=0; j<siz; j++) \n\t\t\taddedge(i+1,v[i][j]+n,1);\n\tans=0;\n\twhile (bfs())\n\t{\n\t\tfor (int i=1; i<=n+n+1; i++) cur[i]=hd[i];\n\t\twhile (dinic(1)) ans++;\n\t}\n\tif (ans!=n-1) return puts(\"-1\"),0;\n\tmemset(bo,0,sizeof(bo));\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=hd[i+1]; j; j=e[j].next)\n\t\t\tif (!e[j].c) {bo[p[i]=e[j].to-n]=1; break;}\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=0,siz=v[i].size(); j<siz; j++)\n\t\t\tif (v[i][j]!=p[i]) t[v[i][j]].push_back(p[i]);\n\tfor (int i=1; i<=n; i++) if (!bo[i]) q[l=r=1]=i;\n\tmemset(P,0,sizeof(P));\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=0,siz=t[x].size(); i<siz; i++)\n\t\t\tif (!P[t[x][i]]) P[t[x][i]]=x,q[++r]=t[x][i];\n\t\tl++;\n\t}\n\tif (r<n) return puts(\"-1\"),0;\n\tfor (int i=1; i<n; i++) printf(\"%d %d\\n\",p[i],P[p[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nnamespace MF{\n\t#define MAXN 512810\n\t#define MAXM 512810//実際の辺の2倍必要！！\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//フローを流した後の残余グラフからカットでS側に属する辺を求める\n\t//この後levの中身が非負な点がS側の点っぽい？(AOJ2396でverify済み？)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//マッチング相手\nbool used[200100];//マッチング相手として使われたか\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline int solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\tint link = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tlink++;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn link;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif (solve() < n - 1) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nint ans[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t}\n\t\tstd::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=1;j<b;j++){\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\tans[i]=to-(a-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",v[i][0]+1,ans[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nstruct EDGE { int v,w,nx; }lb[N<<3]; int tot=1,top[N],cur[N];\nvoid add (int u,int v,int w)\n{\n\tlb[++tot]=(EDGE){v,w,top[u]},top[u]=tot;\n\tlb[++tot]=(EDGE){u,0,top[v]},top[v]=tot;\n}\nint s,t,dep[N];\nbool bfs ()\n{\n\tmemcpy (cur,top,sizeof (int)*(t+1));\n\tmemset (dep,0,sizeof (int)*(t+1));\n\tqueue <int> q;\n\tdep[s]=1,q.push (s);\n\twhile (q.size ())\n\t{\n\t\tint u=q.front (); q.pop ();\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\tif (w&&!dep[v]) dep[v]=dep[u]+1,q.push (v);\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dinic (int u,int flow)\n{\n\tif (u==t) return flow;\n\tint rest=flow;\n\tfor (int &kb=cur[u]; kb; kb=lb[kb].nx)\n\t{\n\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\tif (w&&dep[v]==dep[u]+1)\n\t\t{\n\t\t\tint k=dinic (v,min (rest,w));\n\t\t\tif (!k) dep[v]=1;\n\t\t\trest-=k;\n\t\t\tlb[kb].w-=k,lb[kb^1].w+=k;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nint n,pos[N],x[N],y[N];\nbool vis[N];\nvoid dfs (int u)\n{\n\tint nx=0;\n\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t{\n\t\tint v=lb[kb].v;\n\t\tif (v< s&&!vis[v])\n\t\t{\n\t\t\tnx=v,vis[v]=1;\n\t\t\tx[nx-n]=u;\n\t\t\tfor (int kb=top[nx]; kb; kb=lb[kb].nx)\n\t\t\t{\n\t\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\t\tif (w&&v<=n) { y[nx-n]=v; break; }\n\t\t\t}\n\t\t\tdfs (y[nx-n]);\n\t\t}\n\t}\n\t\n\n}\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n); s=n<<1,t=s+1;\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tint m,x; sc(m); add (n+i,t,1);\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tsc(x),add (x,n+i,1);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tadd (s,i,1),pos[i]=tot;\n\tint ans=0,flow=0;\n\twhile (bfs ())\n\t\twhile ((flow=dinic (s,oo))) ans+=flow;\n\tif (ans!=n-1) return pr(-1),0;\n\tint rt=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!lb[pos[i]].w) { rt=i; break; }\n\tdfs (rt);\n\tfor (int i=1; i< n; i++)\n\t\tif (!x[i]) return pr(-1),0;\n\tfor (int i=1; i< n; i++)\n\t\tprintf (\"%d %d\\n\",x[i],y[i]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; if(x == s || x >= n) continue;\n\t\tbl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define PRINT(x...) TRACE(printf(x))\n#define WATCHR(a, b) TRACE(for (auto c=a; c!=b;) cout << *(c++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define FU(i, a, b) for (auto i = a; i < b; ++i)\n#define fu(i, b) FU(i, 0, b)\n#define FD(i, a, b) for (auto i = (b) - 1; i >= a; --i)\n#define fd(i, b) FD(i, 0, b)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nll mod(ll a, ll b) {\n  return ((a%b)+b)%b;\n}\n\nint cmp(double x, double y = 0, double tol = 1.e-7) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\nstruct graph {\n  vi dest;  // use sz(dest) as number of arcs\n  vvi adj;  // use sz(adj) as number of vertices\n  int inv(int a) { return a ^ 0x1; }\n  graph(int n = 0) {\n    adj.resize(n);\n  }\n  // Adds an arc to the graph. u is capacity, c is cost.\n  // u is only needed on flows, and c only on min-cost-flow\n  int arc(int i, int j, ll u = 1) {\n    dest.pb(j);\n    adj[i].pb(sz(dest)-1);\n    dest.pb(i);\n    adj[j].pb(sz(dest)-1);\n    cap.pb(u); // For both flows\n    cap.pb(0);\n    return sz(dest)-2;\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  // For both flows!!\n  //\n\n  vll cap, flow;\n\n  int orig(int a) { return dest[inv(a)]; }\n  ll capres(int a) { return cap[a] - flow[a]; }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Max Flow! - Dinic O(n^2 * m)\n  // don't call maxflow with ini == end\n  //\n\n  vi curAdj, d;\n\n  bool MFbfs(int s, int t) {\n    d.assign(sz(adj), INT_MAX/2);\n    curAdj = vi(sz(adj));\n    d[s] = 0;\n    queue<int> Q; Q.push(s);\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (auto i : adj[u]) {\n        int v = dest[i];\n        if (capres(i) > 0 && d[v] == INT_MAX/2) {\n          d[v] = d[u] + 1; Q.push(v);\n        }\n      }\n    }\n    return d[t] != INT_MAX/2;\n  }\n\n  ll MFdfs(int u, int t, ll f) {\n    if (u == t) return f;\n    for(int &i = curAdj[u]; i < adj[u].size(); ++i) {\n      int ar = adj[u][i], v = dest[ar];\n      if (d[v] != d[u]+1 || capres(ar) == 0) continue;\n      ll tmpF = MFdfs(v, t, min(f, capres(ar)));\n      if (tmpF) {\n        flow[ar] += tmpF;\n        flow[inv(ar)] -= tmpF;\n        return tmpF;\n      }\n    }\n    return 0;\n  }\n\n  ll maxflow(int ini, int end) {\n    flow.assign(sz(dest), 0);\n    while (MFbfs(ini, end))\n      while (MFdfs(ini, end, LLONG_MAX/2));\n    ll F = 0;\n    for (int a : adj[ini]) F += flow[a];\n    return F;\n  }\n};\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tgraph G(2 * N + 1);\n\tfu(i, N-1) G.arc(0, 1 + i, 1);\n\tfu(i, N) G.arc(N + i, 2 * N, 1);\n\n\tvvi inc(N);\n\tfu(i, N-1) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x); x--;\n\t\t\tG.arc(1 + i, N + x, 1);\n\t\t\tinc[x].push_back(i);\n\t\t}\n\t}\n\n\tif (G.maxflow(0, 2*N) != (N - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\t// find the match of each set\n\tvi match(N-1);\n\tll root = 0;\n\tfu(i, N) root += i;\n\n\tfu(i, N-1) {\n\t\tfor (int a : G.adj[1 + i])\n\t\t\tif (G.flow[a] == 1) {\n\t\t\t\tmatch[i] = G.dest[a] - N;\n\t\t\t\troot -= G.dest[a] - N;\n\t\t\t}\n\t}\n\n\tqueue<int> Q;\n\tQ.push(root);\n\tvb mark(N, false);\n\tmark[root] = true;\n\n\tvector<pair<int, int>> ans(N - 1);\n\tint tot = 0;\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\ttot++;\n\n\t\tfor (int s : inc[x]) {\n\t\t\tint y = match[s];\n\t\t\tif (mark[y]) continue;\n\t\t\tmark[y] = true;\n\t\t\tQ.push(y);\n\t\t\tans[s] = {x, y};\n\t\t}\n\t}\n\n\tif (tot != N) printf(\"-1\\n\");\n\telse for (auto p : ans) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 200005\n#define M 800005\n#define inf 0x3f3f3f3f\nint tar[M], nex[M], cap[M], fir[N], cnt = 1;\nint n, m, d[N], dx[N], use[N][2];\nvector<int>A[N];\nset<int>S[N];\nqueue<int>Q;\nvoid add(int a, int b, int c)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tcap[cnt] = c;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nvoid Add(int a, int b)\n{\n\tadd(a, b, 1);\n\tadd(b, a, 0);\n}\nint aug(int s, int b, int e, int g, int augco)\n{\n\tif (s == e)\n\t\treturn augco;\n\tint augc = augco, mind = g - 1;\n\tfor (int i = fir[s]; i; i = nex[i])\n\t{\n\t\tint v = tar[i];\n\t\tif (cap[i])\n\t\t{\n\t\t\tif (d[s] == d[v] + 1)\n\t\t\t{\n\t\t\t\tint delta = aug(v, b, e, g, min(augc, cap[i]));\n\t\t\t\tcap[i] -= delta;\n\t\t\t\tcap[i ^ 1] += delta;\n\t\t\t\taugc -= delta;\n\t\t\t\tif (!augc || d[b] == g)\n\t\t\t\t\treturn augco - augc;\n\t\t\t}\n\t\t\tmind = min(mind, d[v]);\n\t\t}\n\t}\n\tif (augco == augc)\n\t{\n\t\tdx[d[s]]--;\n\t\tif (!dx[d[s]])\n\t\t\td[b] = g;\n\t\tdx[d[s] = mind + 1]++;\n\t}\n\treturn augco - augc;\n}\nint sap(int b, int e, int g)\n{\n\tint flow = 0;\n\tmemset(d, 0, sizeof(d));\n\tmemset(dx, 0, sizeof(dx));\n\tdx[0] = g;\n\twhile (d[b] < g)\n\t\tflow += aug(b, b, e, g, inf);\n\treturn flow;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int j = 1; j <= t; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tS[x].insert(i);\n\t\t\tA[i].push_back(x);\n\t\t\tif (x != 1)\n\t\t\t\tAdd(i, n + x);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tAdd(2 * n + 1, i);\n\t\tAdd(n + i, 2 * n + 2);\n\t}\n\tint ans = sap(2 * n + 1, 2 * n + 2, 2 * n + 2);\n\tif (ans < n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = fir[i]; j; j = nex[j])\n\t\t{\n\t\t\tint v = tar[j];\n\t\t\tif (v > n && !cap[j])\n\t\t\t\tuse[i][0] = v - n;\n\t\t}\n\t}\n\tQ.push(1);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front();\n\t\tm++;\n\t\tQ.pop();\n\t\tset<int>::iterator it = S[x].begin();\n\t\tfor (; it != S[x].end(); it++)\n\t\t{\n\t\t\tif (!use[*it][1])\n\t\t\t{\n\t\t\t\tuse[*it][1] = x;\n\t\t\t\tQ.push(use[*it][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (m < n)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", use[i][0], use[i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tr1/unordered_map>\n#define ri register int\n#define ptf printf\nusing namespace std;\ntypedef double db;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector <int> poly;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntypedef unsigned long long ulll;\ntypedef unsigned int uii;\ntypedef string strr;\n#define fi first\n#define se second\n#define pb push_back\n#define ppp pop_back\n#define rez resize\nconst ll Inf = 2e18;\nconst int rlen = 1 << 20, inf = 0x3f3f3f3f;\nchar buf[rlen], *ib = buf, *ob = buf;\n#define gc() (((ib == ob) && (ob = (ib =  buf) + fread(buf, 1, rlen, stdin)), ib == ob) ? -1 : *ib++)\ninline int read() {\n  static int ans, f;\n  static char ch;\n  ans = 0, ch = gc(), f = 1;\n  while (!isdigit(ch)) f ^= ch == '-', ch = gc();\n  while (isdigit(ch)) ans = (ans << 3) + (ans << 1) + (ch ^ 48), ch = gc();\n  return f ? ans: -ans;\n}\ninline ll readl() {\n  static ll ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ninline int Read(char *s) {\n  static int top;\n  static char ch;\n  top = 0, ch = gc();\n  while (!isalpha(ch) && !isdigit(ch)) ch = gc();\n  while (isalpha(ch) || isdigit(ch)) s[++top] = ch, ch = gc();\n  return top;\n}\nnamespace modular {\n  const int mod = 998244353;//= 1e9 + 7;\n  //int mod;\n  int ret;\n  inline int add(int a, int b) { return a + b < mod ? a + b : a + b - mod; }\n  inline int dec(int a, int b) { return a < b ? a - b + mod : a - b; }\n  inline int mul(int a, int b) { return (ll) a * b % mod; }\n  inline void Add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod; }\n  inline void Dec(int &a, int b) { a = a < b? a - b + mod : a - b; }\n  inline void Mul(int &a, int b) { a = (ll) a * b % mod; }\n  inline int ksm(int a, int p) {\n    for (ret = 1; p; p >>= 1, Mul(a, a)) (p & 1) && (Mul(ret, a), 1);\n    return ret;\n  }\n  inline int Inv(int a) { return ksm(a, mod - 2); }\n  inline int sqr(int a) { return (ll) a * a % mod; }\n  inline int cub(int a) { return (ll) a * a % mod * a % mod; }\n} using namespace modular;\ntemplate <typename T> inline void ckmax(T &a, T b) { a < b ? a = b : 0; }\ntemplate <typename T> inline void ckmin(T &a, T b) { a > b ? a = b : 0; }\ntemplate <typename T> inline T Abs(T a) { return a < 0 ? -a : a; }\ntemplate <typename T> inline T gcd(T a, T b) {\n  T t;\n  while (b) t = a, a = b, b = t - t / a * a;\n  return a;\n}\ntemplate <typename T> inline void exgcd(T a, T b, T &x, T &y) {\n  if (!b) {\n    x = 1, y = 0;\n    return;\n  }\n  exgcd(b, a - a / b * b, y, x);\n  y -= a / b * x;\n}\nstruct E { int v, nxt, c; };\nconst int N = 2e5 + 5;\nint n, m;\nvector <int> g[N];\nnamespace Flow {\n  int d[N], cnt, fst[N], cur[N], s, t, ss, tt;\n  E e[2000005];\n  inline void init() {\n    cnt = -1, s = 0, t = n + m + 1;\n    for (ri i = s; i <= t; ++i) fst[i] = -1;\n  }\n  inline void addedge(int u, int v, int c) { e[++cnt] = (E) {v, fst[u], c}, fst[u] = cnt; }\n  inline void _add(int u, int v, int c) {\n    addedge(u, v, c);\n    addedge(v, u, 0);\n  }\n  inline bool bfs() {\n    queue <int> q;\n    for (ri i = 0; i <= n + m + 4; ++i) d[i] = -1;\n    q.push(s), d[s] = 0;\n    while (q.size()) {\n      int x = q.front();\n      q.pop(), cur[x] = fst[x];\n      for (ri i = fst[x], v; ~i; i = e[i].nxt) {\n        if (~d[v = e[i].v] || e[i].c <= 0) continue;\n        d[v] = d[x] + 1, q.push(v);\n      }\n    }\n    return ~d[t];\n  }\n  inline int dfs(int x, int f) {\n    if (x == t || !f) return f;\n    int fl = f;\n    for (ri &i = cur[x], v, tp; ~i; i = e[i].nxt) {\n      if (!fl) return f;\n      if (d[v = e[i].v] == d[x] + 1 && e[i].c > 0) {\n        tp = dfs(v, min(fl, e[i].c));\n        if (!tp) d[v] = -1;\n        e[i].c -= tp, e[i ^ 1].c += tp, fl -= tp;\n      }\n    }\n    return f - fl;\n  }\n  inline int solve() {\n    int res = 0, tp;\n    while (bfs()) while ((tp = dfs(s, inf)) > 0) res += tp;\n    return res;\n  }\n  bool vs[N];\n  pii ans[N];\n  inline void Solve() {\n    queue <int> q;\n    q.push(1);\n    int ct = 0;\n    while (q.size()) {\n      int x = q.front();\n      q.pop();\n      for (ri i = 0, v; i < g[x].size(); ++i) {\n        if (vs[v = g[x][i] + n]) continue;\n        vs[v] = 1;\n        for (ri j = fst[v]; ~j; j = e[j].nxt) if (e[j].c > 0) {\n          int _v = e[j].v;\n          ans[v] = pii(x, _v);\n          q.push(_v);\n          ++ct;\n        }\n      }\n    }\n    if (!ct) cout << -1, exit(0);\n    for (ri i = 1; i < n; ++i) cout << ans[i + n].fi << ' ' << ans[i + n].se << '\\n';\n  }\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\", \"r\", stdin);\n  #endif\n  n = read(), m = n - 1;\n  Flow:: init();\n  for (ri i = 1; i <= n; ++i) Flow:: _add(Flow:: s, i, 1);\n  for (ri i = 1; i <= m; ++i) for (ri tt = read(); tt; --tt) {\n    int x = read();\n    g[x].pb(i);\n    if (x > 1) Flow:: _add(x, n + i, 1);\n  }\n  for (ri i = 1; i <= m; ++i) Flow:: _add(i + n, Flow:: t, 1);\n  if (Flow:: solve() != n - 1) return cout << -1, 0;\n  Flow:: Solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x){\n\t\tif (x==T)\n\t\t\treturn 1;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tif (dfs(y)){\n\t\t\t\t\te[i].cap^=1,e[i^1].cap^=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tclr(vis),flow+=dfs(S,INF);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//問題文および制約はちゃんと確認しよう！\n//サイズは10^5じゃなくて2×10^5とかかもしれないし、重要な制約・条件を見落としているかも\n//とりあえずサンプルを読んでから解法を考えよう？\nnamespace MF{\n\t#define MAXN 512810\n\t#define MAXM 512810//実際の辺の2倍必要！！\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//フローを流した後の残余グラフからカットでS側に属する辺を求める\n\t//この後levの中身が非負な点がS側の点っぽい？(AOJ2396でverify済み？)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//マッチング相手\nbool used[200100];//マッチング相手として使われたか\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\t/*memset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 100000 + 10;\nconst int N = maxn << 1;\nconst int maxE = maxn << 1;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing vi = vector<int>;\n#define all(v) begin(v), end(v)\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define sz(v) (int)(v).size()\n\nbool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {\n  if (A[a] != L) return 0;\n  A[a] = -1;\n  for (int b : g[a]) if (B[b] == L + 1) {\n    B[b] = 0;\n    if (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n      return btoa[b] = a, 1;\n  }\n  return 0;\n}\n\nint hopcroftKarp(vector<vi>& g, vi& btoa) {\n  int res = 0;\n  vi A(g.size()), B(btoa.size()), cur, next;\n  for (;;) {\n    fill(all(A), 0);\n    fill(all(B), 0);\n    /// Find the starting nodes for BFS (i.e. layer 0).\n    cur.clear();\n    for (int a : btoa) if(a != -1) A[a] = -1;\n    rep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n    /// Find all layers using bfs.\n    for (int lay = 1;; lay++) {\n      bool islast = 0;\n      next.clear();\n      for (int a : cur) for (int b : g[a]) {\n        if (btoa[b] == -1) {\n          B[b] = lay;\n          islast = 1;\n        }\n        else if (btoa[b] != a && !B[b]) {\n          B[b] = lay;\n          next.push_back(btoa[b]);\n        }\n      }\n      if (islast) break;\n      if (next.empty()) return res;\n      for (int a : next) A[a] = lay;\n      cur.swap(next);\n    }\n    /// Use DFS to scan for augmenting paths.\n    rep(a,0,sz(g))\n      res += dfs(a, 0, g, btoa, A, B);\n  }\n}\n\nint main(int argc, char const *argv[])\n{\n#ifdef LOCAL\n  freopen(\"in\", \"r\", stdin);\n#endif\n  int n; scanf(\"%d\", &n);\n  vector<vi> li(n-1), g(n);\n  for(int i = 0; i < n-1; ++i) {\n    int k; scanf(\"%d\", &k);\n    li[i] = vi(k);\n    for(int& x : li[i]) {\n      scanf(\"%d\", &x);\n      x--;\n      g[x].push_back(i);\n    }\n  }\n  vi vis(2*n-1);\n  function<void(int)> dfs0 = [&](int u) {\n    vis[u] = 1;\n    if(u >= n) {\n      for(int& v : li[u-n]) {\n        if(!vis[v]) dfs0(v);\n      }\n    } else {\n      for(int& v : g[u]) {\n        if(!vis[v+n]) dfs0(v+n);\n      }\n    }\n  };\n  dfs0(0);\n  if(count(all(vis), 1) != 2*n-1) {\n    return puts(\"-1\"), 0;\n  }\n  vi g0 = g[0], btoa(n-1, -1);\n  g[0].clear();\n  hopcroftKarp(g, btoa);\n  g[0] = g0;\n  if(count(all(btoa), -1)) {\n    return puts(\"-1\"), 0;\n  }\n  vi atob(n, -1);\n  vector<ii> ans(n-1);\n  for(int i = 0; i < n-1; ++i) {\n    if(~btoa[i]) atob[btoa[i]] = i;\n  }\n  vis.assign(n, 0);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = 1;\n    for(int& m : g[u]) if(m != atob[u]) {\n      int v = btoa[m];\n      if(!vis[v]) {\n        ans[m] = {u, v};\n        dfs(v);\n      }\n    }\n  };\n  dfs(0);\n  for(int i = 0; i < n-1; ++i) {\n    printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint next[N],head[N],edge[N],v[N],next2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnext[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnext2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=next[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=next2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nvector<int> adj[MaxN];\nint N;\nbool visited[MaxN];\nint match_left[MaxN], match_right[MaxN];\nVI rev_adj[MaxN];\n\nbool DfsMatch(int v) {\n  if (visited[v]) { return false; }\n  visited[v] = true;\n  for (int s : adj[v]) {\n    if (match_right[s] == -1 || DfsMatch(match_right[s])) {\n      match_right[s] = v;\n      match_left[v] = s;\n      return true;\n    }\n  }\n  return false;\n}\n\nint Matching() {\n  fill_n(match_left, N, -1);\n  fill_n(match_right, N, -1);\n  int size = 0;\n  bool has_incr;\n  do {\n    has_incr = false;\n    fill_n(visited, N, false);\n    for (int i = 0; i < N; ++i)\n      if (match_left[i] == -1 && !visited[i] && DfsMatch(i)) {\n        ++size;\n        has_incr = true;\n      }\n  } while (has_incr);\n  return size;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  for (int i = 1; i <= N - 1; ++i) {\n    int sz;\n    cin >> sz;\n    for (int j = 0; j < sz; ++j) {\n      int v; cin >> v;\n      --v;\n      adj[i].PB(v);\n      rev_adj[v].PB(i);\n    }\n    adj[0].PB(i - 1);\n  }\n\n  if (Matching() != N) {\n    cout << \"-1\\n\";\n  }\n\n  for (int i = 0; i < N; ++i)\n    debug(i, match_left[i]);\n\n  vector<PII> edges(N - 1);\n  int num_edges = 0;\n  queue<int> Q;\n  vector<bool> vis_set(N);\n  vector<bool> vis_vert(N);\n\n  Q.push(match_left[0]);\n  vis_set[0] = true;\n  vis_vert[match_left[0]] = true;\n\n  while (!Q.empty()) {\n    const int v = Q.front();\n    Q.pop();\n\n    for (int set_id : rev_adj[v]) {\n      if (vis_set[set_id]) { continue; }\n      vis_set[set_id] = true;\n      const int s = match_left[set_id];\n      assert(!vis_vert[s]);\n      vis_vert[s] = true;\n      debug(set_id, v, s);\n      edges[set_id - 1] = make_pair(v, s);\n      ++num_edges;\n      Q.push(s);\n    }\n  }\n\n  if (num_edges != N - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  for (auto &edge : edges)\n    cout << edge.st + 1 << \" \" << edge.nd + 1 << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[v-n]=u;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(cho[v]),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct Edge {\n  int t,f,next;\n  Edge() {}\n  Edge(int a,int b,int c):t(a),f(b),next(c) {}\n};\n\nEdge e[1000000];\nint head[200005],vs,vt,tot=-1;\n\ninline void addEdge(int x,int y,int z) {\n  e[++tot]=Edge(y,z,head[x]);\n  head[x]=tot;\n  e[++tot]=Edge(x,0,head[y]);\n  head[y]=tot;\n}\n\nnamespace Flow {\n\t\nint d[200005],cur[200005];\nqueue <int> q;\n\nbool bfs() {\n  while (!q.empty()) q.pop();\n  memset(d,255,sizeof(d));\n  d[vs]=0;cur[vs]=head[vs];\n  q.push(vs);\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tfor(int i=head[x];i!=-1;i=e[i].next)\n  \t  if (e[i].f&&d[e[i].t]==-1) {\n  \t  \t  int u=e[i].t;\n  \t  \t  d[u]=d[x]+1;\n  \t  \t  cur[u]=head[u];\n  \t  \t  if (u==vt) return 1;\n  \t  \t  q.push(u);\n\t\t}\n  }\n  return 0;\n}\n\nint dfs(int x,int a) {\n  if (x==vt||!a) return a;\n  int ans=0;\n  for(int &i=cur[x];i!=-1;i=e[i].next)\n    if (e[i].f&&d[e[i].t]==d[x]+1) {\n    \tint u=e[i].t;\n    \tint f=dfs(u,min(a,e[i].f));\n    \tif (f) {\n    \t\te[i].f-=f;\n    \t\te[i^1].f+=f;\n    \t\tans+=f;\n    \t\ta-=f;\n    \t\tif (!a) break;\n\t\t}\n\t}\n  return ans;\n} \n\nint maxflow() {\n  int ans=0;\n  while (bfs())\n    ans+=dfs(vs,inf);\n  return ans;\n}\n\t\n}\n\nvector <int> bel[100005];\nbool vis1[100005],vis2[100005];\nint id[100005],nxt[100005];\n\nqueue <int> q;\n\nbool solve(int n) {\n  for(int i=1;i<n;i++)\n    for(int j=head[n+i];j!=-1;j=e[j].next)\n      if (e[j].t&&!e[j].f) {\n      \tint u=e[j].t;\n      \tid[i]=u;\n      \tvis1[u]=1;\n\t  }\n  for(int i=1;i<=n;i++)\n    if (!vis1[i]) q.push(i);\n  int cnt=0;\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tcnt++;\n  \tfor(int i=0;i<bel[x].size();i++)\n  \t  if (!vis2[bel[x][i]]) {\n  \t  \t  int u=bel[x][i];\n  \t  \t  vis2[u]=1;\n  \t  \t  nxt[u]=x;\n  \t  \t  q.push(id[u]);\n\t\t}\n  }\n  return cnt==n;\n}\n\nint main() {\n  memset(head,255,sizeof(head));\n  int n;\n  scanf(\"%d\",&n);\n  vs=0;vt=2*n;\n  for(int i=1;i<n;i++) {\n  \tint x;\n  \tscanf(\"%d\",&x);\n  \taddEdge(vs,n+i,1);\n  \tfor(int j=1;j<=x;j++) {\n  \t\tint y;\n  \t\tscanf(\"%d\",&y);\n  \t\taddEdge(n+i,y,1);\n  \t\tbel[y].push_back(i);\n\t  }\n  }\n  for(int i=1;i<=n;i++) addEdge(i,vt,1);\n  if (Flow::maxflow()<n-1) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  if (!solve(n)) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  for(int i=1;i<n;i++) printf(\"%d %d\\n\",id[i],nxt[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nclass matching {\n  public:\n  vector< vector<int> > g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint n;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  matching st(n - 1, n);\n  vector<vector<int>> e(n - 1);\n  range(i, 0, n - 1) {\n    int sz;\n    cin >> sz;\n    range(j, 0, sz) {\n      int a;\n      cin >> a;\n      a--;\n      e[i].push_back(a);\n      st.add(i, a);\n    }\n  }\n  if(st.solve() != n - 1) {\n    cout << -1;\n    return 0;\n  }\n  vector<int> pb = st.pb;\n  vector<int> pa = st.pa;\n  pa.resize(n);\n  range(i, 0, n) if(pb[i] == -1) {\n    pb[i] = n - 1;\n    pa[n - 1] = i;\n  }\n  vector<vector<int>> g(n);\n  range(i, 0, n - 1) {\n    for(int u : e[i]) {\n      g[pb[u]].push_back(i);\n    }\n  }\n  vector<int> was(n);\n  vector<int> par(n, -1);\n  function<void(int, int)> dfs = [&](int v, int p) {\n    was[v] = 1;\n    par[v] = p;\n    for(int u : g[v]) {\n      if(was[u]) continue;\n      dfs(u, v);\n    }\n  };\n  dfs(n - 1, -1);\n  if(count(was.begin(), was.end(), 0) > 1) {\n    cout << -1;\n    return 0;\n  }\n  range(i, 0, n - 1) {\n    cout << pa[i] + 1 << \" \" << pa[par[i]] + 1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],pos[N],vis[N],dis[N << 1],cur[N << 1],gap[N << 1];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline bool bfs() {\n\tqueue <int> q;\n\tmemset(dis,0,sizeof(dis));\n\tq.push(T),gap[dis[T] = 0]++;\n\twhile(!q.empty()) {\n\t\tint x = q.front();q.pop();\n\t\tif(x == S) return true;\n\t\tfor(int i = beg[x];i;i = nex[i])\n\t\t\tif(!dis[to[i]] && flow[i ^ 1]) {\n\t\t\t\t++gap[dis[to[i]] = dis[x] + 1];\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int &i = cur[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = dfs(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]],cur[x] = beg[x];\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tbfs(),memcpy(cur,beg,sizeof(cur));\n\twhile(dis[S] < T) ans += dfs(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, M = 200005, inf = 0x3f3f3f3f;\nint n, p[N], fa[N];\nvector<int> E[N], F[N];\n\nnamespace flow {\n\tconst int V = 2 * N, E = 2 * (M + 2 * N);\n\tint ans, S, T, tot = 1, nxt[E], fst[V], to[E], f[E], cur[V], d[V];\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; f[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; f[tot] = 0;\n\t}\n\tbool bfs() {\n\t\tstatic int q[E];\n\t\tint st = 0, ed = 0;\n\t\tq[ed++] = S;\n\t\tfor (int i = 1; i <= T; i++) d[i] = -1, cur[i] = fst[i];\n\t\td[S] = 0;\n\t\twhile (st < ed) {\n\t\t\tint u = q[st++];\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (f[i] && d[to[i]] == -1) {\n\t\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\t\tif (to[i] == T) return true;\n\t\t\t\t\tq[ed++] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint aug(int u, int flow) {\n\t\tif (u == T || !flow) return flow;\n\t\tint used = 0;\n\t\tfor (int &i = cur[u], w; i; i = nxt[i])\n\t\t\tif (d[to[i]] == d[u] + 1 && (w = aug(to[i], min(f[i], flow - used)))) {\n\t\t\t\tf[i] -= w, f[i ^ 1] += w;\n\t\t\t\tif ((used += w) == flow) break;\n\t\t\t}\n\t\tif (!used) d[u] = -1;\n\t\treturn used;\n\t}\n\tint dinic() {\n\t\twhile (bfs()) ans += aug(S, inf);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs(int u) {\n\tfor (int v : F[u])\n\t\tif (!fa[p[v]]) {\n\t\t\tfa[p[v]] = u;\n\t\t\tdfs(p[v]);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tflow::S = 2 * (n - 1) + 1, flow::T = 2 * (n - 1) + 2;\n\tfor (int i = 1, k; i < n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tE[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tscanf(\"%d\", &E[i][j]);\n\t\t\tif (E[i][j] != n)\n\t\t\t\tflow::addedge(E[i][j], n - 1 + i, 1);\n\t\t\tF[E[i][j]].push_back(i);\n\t\t}\n\t\tflow::addedge(flow::S, i, 1);\n\t\tflow::addedge(n - 1 + i, flow::T, 1);\n\t}\n\tint x = flow::dinic();\n\tif (x != n - 1) return !puts(\"-1\");\n\tfor (int i = 2; i <= flow::tot; i += 2)\n\t\tif (!flow::f[i] && flow::to[i] != flow::T && flow::to[i ^ 1] != flow::S)\n\t\t\tp[flow::to[i] - n + 1] = flow::to[i ^ 1];\n\tfa[n] = -1, dfs(n);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!fa[i]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n\nconst int N=5e5+5,M=3e6+5,INF=0x3f3f3f3f;\nint n;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint h[N],le=1;\nint hh[N];\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\nvoid add_bidir_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,v);}\n#define FORe(i,u,v,w)     for(int  i= h[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,u,v,w) for(int &i=hh[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint dep[N];\nqueue<int> q;\n\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    dep[s]=1, q.push(s);\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w) if(!dep[v]&&w)dep[v]=dep[u]+1, q.push(v);\n    }\n    return dep[t]!=0;\n}\nint dfs(int u,int flow){\n    if(u==t||!flow)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(rest,w));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int x;(x=dfs(s,INF));)maxflow+=x;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1000010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        if (a == 0)\n            d[e[i].v] = 0;\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], vis[100010], to[100010], ans[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue <int> q;\n    q.push(n);\n    vis[n] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (e[i].c == 0 && !::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\nint q[M], q0;\n\nint bfs() {\n\tfo(i, 1, T) d[i] = 0, cur[i] = fi[i];\n\tq[q0 = 1] = S;\n\tfor(int i = 1; i <= q0; i ++) {\n\t\tint x = q[i];\n\t\tfor(int j = fi[x]; j; j = nt[j]) if(r[j])\n\t\t\tif(!d[to[j]]) d[to[j]] = d[x] + 1, q[++ q0] = to[j];\n\t} \n\treturn d[T] > 0;\n}\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] + 1 == d[to[i]] && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\tco[0] = T; while(bfs()) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nbool bfs(){\n\tmemset(dep,-1,sizeof(dep));\n\tqueue<int>q;\n\tq.push(S);\n\tdep[S]=0;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]==-1){\n\t\t\tdep[to[i]]=dep[k1]+1;\n\t\t\tq.push(to[i]);\n\t\t}\n\t}\n\treturn dep[T]!=-1;\n}\nint dfs(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]==dep[k1]+1){\n\t\tint f=dfs(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tcur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\trd(n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\trd(m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\trd(k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tint res=0;\n\twhile(bfs()){\n\t\tmemcpy(cur,lnk,sizeof(cur));\n\t\tres+=dfs(S,INF);\n\t}\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<ll, ll>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vii = vector<ii>;\nusing vvii = vector<vii>;\nusing vd = vector<ld>;\n\ntemplate<class T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class TIn, class TOut = null_type>\nusing order_tree = tree<TIn, TOut, less<TIn>, rb_tree_tag,\n\ttree_order_statistics_node_update>;\n// .find_by_order(int r) and .order_of_key(TIn v)\n\nconstexpr int INF = 2000000010;\nconstexpr ll LLINF = 9000000000000000010LL;\nconstexpr ld PI = acos(-1);\n\nauto now(){ return chrono::high_resolution_clock::now(); }\nusing TP = decltype(now());\t// time point\nauto duration(TP t1, TP t2){\n\treturn chrono::duration_cast<chrono::microseconds>(t2-t1).count();\n}\n\n\n// Need a much better hash function for gp_hash_table\nstruct custom_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31); }\n\tsize_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM\n\t\t\t= chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM); } };\n\ntemplate<class TOut>\n//using table = gp_hash_table<TIn, TOut>;\nusing table = gp_hash_table<uint64_t, TOut, custom_hash>;\n\nstruct UnionFind {\n\tvi par, rank, size; int c;\n\tUnionFind(int n) : par(n), rank(n,0), size(n,1), c(n) {\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }\n\tbool same(int i, int j) { return find(i) == find(j); }\n\tint get_size(int i) { return size[find(i)]; }\n\tint count() { return c; }\n\tint merge(int i, int j) {\n\t\tif ((i = find(i)) == (j = find(j))) return -1; else --c;\n\t\tif (rank[i] > rank[j]) swap(i, j);\n\t\tpar[i] = j; size[j] += size[i];\n\t\tif (rank[i] == rank[j]) rank[j]++;\n\t\treturn j;\n\t}\n};\n\nvoid solve() {\n\tauto start = now();\n\tint N;\n\tcin >> N;\n\tvvi E(N-1);\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tint c;\n\t\tcin >> c;\n\t\tE[i].resize(c);\n\t\tfor (ll &id : E[i]) cin >> id, --id;\n\t}\n\tvi inds(N-1);\n\tiota(inds.begin(), inds.end(), 0);\n\tshuffle(inds.begin(), inds.end(), mt19937(0x94949));\n\tsort(inds.begin(), inds.end(), [&E](int l, int r) { return E[l].size() < E[r].size(); });\n\n\twhile (duration(start, now()) < 1800000) {\n\t\tbool ok = true;\n\t\tvii edges(N-1);\n\t\tUnionFind uf(N);\n\t\tfor (size_t l = 0, r = 0; ok && l < inds.size(); l = r) {\n\t\t\twhile (r < inds.size() && E[inds[l]].size() == E[inds[r]].size()) ++r;\n\t//\t\tshuffle(inds.begin()+l, inds.begin()+r, mt19937(0x94949));\n\n\t\t\tfor (size_t i = l; i < r; ++i) {\n\t\t\t\tint x = inds[i];\n\t\t\t\ttable<null_type> sn;\n//\t\t\t\tunordered_set<int> sn;\n\t\t\t\tvi vec;\n//\t\t\t\tcerr << \"Trying E[\" << x << \"] = {\";\n\t\t\t\tfor (int v : E[x]) {\n\t\t\t\t\tint id = uf.find(v);\n//\t\t\t\t\tcerr << \"(\"<<v<<\", \"<<id<<\") \";\n\t\t\t\t\tif (sn.find(id) != sn.end()) continue;\n\t\t\t\t\tsn.insert(id);\n\t\t\t\t\tvec.push_back(v);\n\t\t\t\t}\n//\t\t\t\tcerr << \"}\" << endl;\n\t\t\t\tif (sn.size() == 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tcerr << \"Final vec:\"; for (int k : vec) cerr << ' ' << k; cerr << endl;\n\t\t\t\tint a = rand() % vec.size(), b;\n\t\t\t\tdo { b = rand() % vec.size(); } while (a == b);\n\t\t\t\ta = vec[a], b = vec[b];\n\t\t\t\tif (a > b) swap(a, b);\n\t\t\t\tuf.merge(a, b);\n\t\t\t\tedges[x] = {a, b};\n\t\t\t}\n\t\t}\n\t\tif (!ok) continue;\n\t\tfor (int i = 0; i < N-1; ++i)\n\t\t\tcout << 1+edges[i].first << ' ' << 1+edges[i].second << '\\n';\n\t\treturn;\n\t}\n\n\tcout << -1 << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(12);\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nvector<int> g[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    vector<int> vs(k);\n    for (int j = 0; j < k; j++) {\n      scanf(\"%d\", &vs[j]);\n      vs[j]--;\n    }\n    g[i] = vs;\n  }\n  return true;\n}\n\nint p[maxn];\nint q[maxn];\nint used[maxn];\n\nbool dfs(int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (p[u] == -1) {\n      p[u] = v;\n      q[v] = u;\n      return true;\n    }\n  }\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (!used[p[u]] && dfs(p[u])) {\n      p[u] = v;\n      q[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint match() {\n  for (int i = 0; i < n; i++) {\n    p[i] = -1;\n    q[i] = -1;\n  }\n  int res = 0;\n  while (true) {\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n      used[i] = false;\n    }\n    for (int i = 0; i < n - 1; i++) {\n      if (q[i] == -1 && dfs(i)) {\n        found = true;\n        res++;\n      }\n    }\n    if (!found) {\n      break;\n    }\n  }\n  return res;\n}\n\nvector<int> ng[maxn];\nvector<int> vs;\npair<int, int> ans[maxn];\n\nvoid dfs1(int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (used[u]) {\n      continue;\n    }\n    int id = p[u];\n    ans[id] = make_pair(v, u);\n    dfs1(u);\n  }\n}\n\nvoid solve() {\n  if (match() < n - 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 0; i < n; i++) {\n    ng[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v = q[i];\n    for (int j = 0; j < sz(g[i]); j++) {\n      int u = g[i][j];\n      if (u != v) {\n        ng[u].push_back(v);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    g[i] = ng[i];\n    used[i] = false;\n  }\n  int root = -1;\n  for (int i = 0; i < n; i++) {\n    if (p[i] == -1) {\n      root = i;\n      break;\n    }\n  }\n  dfs1(root);\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < n - 1; i++) {\n    printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[(N<<1)+3];\nvector<pair<int,pii> > ans;\nint mch[(N<<1)+3];\nbool vis[(N<<1)+3];\nint que[N+3];\nint n;\n\nbool bfs()\n{\n\tint hd = 1,tl = 1; que[1] = 1; vis[1] = true;\n\twhile(hd<=tl)\n\t{\n\t\tint u = que[hd]; hd++;\n\t\tfor(int o=0; o<adj[u].size(); o++)\n\t\t{\n\t\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\t\tif(vis[mch[v]]) continue;\n\t\t\tque[++tl] = mch[v]; vis[v] = vis[mch[v]] = true;\n\t\t\tans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\t}\n\t}\n\tif(tl<n) {return false;}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tif(!bfs()) {puts(\"-1\"); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num,ans[N];\nconst int inf=0x3f3f3f3f;\nvector<int>v[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1,ans[v[x][i]]=x;\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&n+1<=w[i].to&&w[i].to<=n+n-1)\n\t\t\t\tma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",ans[i],ma[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>ans[200005];\nint beg = -1;\nbool in[400005];\n\n//O(E sqrt V)\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph, rev;\n  vector< int > dist, match, revmatch;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), rev(m), match(m, -1), revmatch(n,-1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    rev[v].push_back(u);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        revmatch[a] = b;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n  \n  void put_ans() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        ans[match[i]].pb(i);\n      }\n      else{\n      \tbeg = i;\n      }\n    }\n  }\n  \n  void DFS(int cur,bool right){\n      //cout << cur << \" \" << right << endl;\n  \tif(right){\n  \t\t\n  \t\tfor(int i=0;i<rev[cur].size();i++){\n  \t\t\tif(match[cur] == rev[cur][i]) continue;\n  \t\t\tint to = rev[cur][i];\n  \t\t\t//cout << to << endl;\n  \t\t\tif(in[to]) continue;\n  \t\t\tin[to] = 1;\n  \t\t\tans[to].pb(cur);\n  \t\t\t//cout << to << \" \" << cur << endl;\n  \t\t\t//cout << to << endl;\n  \t\t\tDFS(to,false);\n  \t\t}\n  \t}\n  \telse{\n  \t\t\n\t\tfor(int i=0;i<graph[cur].size();i++){\n  \t\t\tif(match[graph[cur][i]] != cur) continue;\n  \t\t\tint to = graph[cur][i];\n  \t\t\tif(in[to+200001]) continue;\n  \t\t\tin[to+200001] = 1;\n  \t\t\tDFS(to,true);\n  \t\t}\n  \t}\n  }\n};\n\nint n;\nvector<int>vec[200005];\n\nint par[200005],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tHopcroftKarp bm(n-1,n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\trep(j,a){\n\t\t\tint x; scanf(\"%d\",&x); x--;\n\t\t\tvec[i].pb(x);\n\t\t\tbm.add_edge(i,x);\n\t\t}\n\t}\n\tint v = bm.bipartite_matching(); \n\tbm.put_ans();\n\tif(beg != -1) bm.DFS(beg,true);\n\tinit();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ans[i].size() != 2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tint x = ans[i][0], y = ans[i][1];\n\t\tif(same(x,y)){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tunite(x,y);\n\t}\n//\tputs(\"YES\");\n\trep(i,n-1) cout << ans[i][0]+1 << \" \" << ans[i][1]+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\n\nvoid failure(){cout<<-1<<lf;exit(0);}\n\nvector<int> e[_];\nint n,ed[_]={0},via[_]={0};\n\nint dfs(int x,int who)\n{\n\tif(ed[x]==who)return 0;\n\ted[x]=who;\n\tfor(auto b:e[x])if(!via[b] || dfs(via[b],who)){via[b]=x;return 1;}\n\treturn 0;\n}\n\nint es[_]={0};\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<n;i++)for(int j=ty();j>=1;j--)e[ty()].emplace_back(i);\n\tfor(int i=2;i<=n;i++)if(!dfs(i,i))failure();\n\n\tqueue<int> q;\n\tq.emplace(1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(q.empty())failure();\n\t\tint a=q.front();q.pop();\n\t\tfor(auto b:e[a])if(!es[b])es[b]=a,q.emplace(via[b]);\n\t}\n\tfor(int i=1;i<n;i++)cout<<es[i]<<' '<<via[i]<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nnamespace MF { //init before you use it. when you use double, be careful.\n\tstruct edge { int to, cap, rev; };\n\n\tvector<edge> G[MAX_N];\n\tint level[MAX_N];\n\tint iter[MAX_N];\n\n\tvoid init(int n) {\n\t\trep(i, 0, n) G[i].clear();\n\t}\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n\t}\n\n\tvoid bfs(int s) {\n\t\tmemset(level, -1, sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor(int i = 0; i < (int)G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] == -1) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll get(int s, int t) {\n\t\tll flow = 0;\n\t\twhile(true) {\n\t\t\tbfs(s);\n\t\t\tif(level[t] == -1) return flow;\n\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, inf)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint N;\nint used[MAX_N];\n\nvoid loop(int v, int p) {\n\t// debug(v, p);\n\tif(v < N - 1) used[v] = p - (N - 1);\n\telse used[v] = 0;\n\trep(i, 0, sz(MF::G[v])) {\n\t\tauto& e = MF::G[v][i];\n\t\tif(e.cap == 0 && used[e.to] == -1 && e.to < 2 * N - 1) loop(e.to, v);\n\t}\n}\n\nvoid solve() {\n\tcin >> N;\n\tint S = 2 * N - 1, T = 2 * N;\n\tMF::init(2 * N + 1);\n\trep(i, 0, N - 1) {\n\t\tint a; cin >> a;\n\t\twhile(a--) {\n\t\t\tint b; cin >> b; b--;\n\t\t\tMF::add_edge(i, b + N - 1, 1);\n\t\t}\n\t}\n\trep(i, 0, N - 1) MF::add_edge(S, i, 1);\n\trep(i, 0, N) MF::add_edge(i + N - 1, T, 1);\n\tif(MF::get(S, T) != N - 1) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\trep(i, 0, N - 1) {\n\t\trep(j, 0, sz(MF::G[i])) {\n\t\t\tauto& e = MF::G[i][j];\n\t\t\tif(e.cap == 0) {\n\t\t\t\tused[e.to] = 1;\n\t\t\t\t// debug(i, e.to);\n\t\t\t}\n\t\t}\n\t}\n\tint root = -1;\n\trep(i, 0, N) {\n\t\tif(!used[i + N - 1]) {\n\t\t\troot = i + N - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmemset(used, -1, sizeof(used));\n\tloop(root, -1);\n\trep(i, 0, N - 1) {\n\t\tif(used[i] == -1) {\n\t\t\tcout << -1 << \"\\n\"; return;\n\t\t}\n\t}\n\trep(i, 0, N - 1) {\n\t\trep(j, 0, sz(MF::G[i])) {\n\t\t\tauto& e = MF::G[i][j];\n\t\t\tif(e.cap == 0) {\n\t\t\t\tcout << e.to - (N - 1) + 1 << \" \" << used[i] + 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<set<ll>>& cap){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[v].count(nex) == 0)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            cap[v].insert(nex);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n    vector<ll> level(N,inf);\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        rep(i,0,N) level[i] = inf;\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<set<ll>> cap(N); \n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=200*1007;\n\nusing T = int;\nclass Flow {\n  struct E {\n    int dest;\n    T orig, *lim, *rev;\n  };\n  int zr, uj, n = 0;\n  vector<unique_ptr<T>> ts;\n  vector<vector<E>> graf;\n  vector<int> ptr, odl;\n\n  void vert(int v) {\n    n = max(n, v + 1);\n    graf.resize(n);\n    ptr.resize(n);\n    odl.resize(n);\n  }\n\n  bool iszero(T v) {\n    return !v; // Zmienić dla doubli.\n  }\n\n  void bfs() {\n    fill(odl.begin(), odl.end(), 0);\n    vector<int> kol = {zr};\n    odl[zr] = 1;\n    for (int i = 0; i < (int) kol.size(); i++) {\n      for (E& e : graf[kol[i]]) {\n        if (!odl[e.dest] and !iszero(*e.lim)) {\n          odl[e.dest] = odl[kol[i]] + 1;\n          kol.push_back(e.dest);\n        }\n      }\n    }\n  }\n\n  T dfs(int v, T lim) {\n    if (v == uj) return lim;\n    T ret = 0, wez;\n    for (int& i = ptr[v]; i < (int) graf[v].size(); i++) {\n      E& e = graf[v][i];\n      if (odl[e.dest] == odl[v] + 1 and !iszero(*e.lim) and\n          !iszero(wez = dfs(e.dest, min(*e.lim, lim)))) {\n        ret += wez;\n        *e.lim -= wez;\n        *e.rev += wez;\n        lim -= wez;\n        if (iszero(lim)) break;\n      }\n    }\n    return ret;\n  }\n\n public:\n  void add_edge(int u, int v, T lim, bool bi = false /* bidirectional? */) {\n    vert(max(u, v));\n    T *a = new T(lim), *b = new T(lim * bi);\n    ts.emplace_back(a);\n    ts.emplace_back(b);\n    graf[u].push_back(E{v, lim,      a, b});\n    graf[v].push_back(E{u, lim * bi, b, a});\n  }\n\n  T dinic(int zr_, int uj_) {\n    zr = zr_; uj = uj_;\n    vert(max(zr, uj));\n    T ret = 0;\n    while (true) {\n      bfs();\n      fill(ptr.begin(), ptr.end(), 0);\n      const T sta = dfs(zr, numeric_limits<T>::max());  // Dla doubli można dać\n      if (iszero(sta)) break;                           // infinity() zamiast\n      ret += sta;                                       // max().\n    }\n    return ret;\n  }\n\n  vector<int> cut() {\n    vector<int> ret;\n    bfs();\n    for (int i = 0; i < n; i++)\n      if (odl[i])\n        ret.push_back(i);\n    return ret;\n  }\n\n  map<pair<int, int>, T> get_flowing() {  // Tam gdzie plynie 0 może nie być\n    map<pair<int, int>, T> ret;           // krawędzi.\n    for (int i = 0; i < n; i++)\n      for (E& e : graf[i])\n        if (*e.lim < e.orig)\n          ret[make_pair(i, e.dest)] += e.orig - *e.lim;\n    for (auto& i : ret) {\n      const pair<int, int> rev{i.first.second, i.first.first};\n      const T x = min(i.second, ret[rev]);\n      i.second -= x;\n      ret[rev] -= x;\n    }\n    return ret;\n  }\n};\n\n\nint n;\nvi wek[nax];\n\nFlow janusz;\n\nvi nalezy[nax];\n\nint sko[nax];\nint prze[nax];\n\nint oj[nax];\n\nint ile[nax];\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nint fin(int v)\n{\n\tif (oj[v]!=v)\n\t\toj[v]=fin(oj[v]);\n\treturn oj[v];\n}\n\npii kra[nax];\n\nvoid uni(int a, int b, int kt)\n{\n\tif (fin(a)==fin(b))\n\t\tnope();\n\tkra[kt]={a, b};\n\toj[fin(a)]=fin(b);\n}\n\nint bylo[nax];\n\nvoid dfs(int v)\n{\n\tif (bylo[v])\n\t\treturn;\n\tbylo[v]=1;\n\tdebug() << imie(v);\n\tfor (int i : nalezy[v])\n\t{\n\t\tif (kra[i].first)\n\t\t\tcontinue;\n\t\tuni(v, prze[i], i);\n\t\tdfs(prze[i]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\toj[i]=i;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d\", &x);\n\t\twhile(x--)\n\t\t{\n\t\t\tscanf(\"%d\", &y);\n\t\t\twek[i].push_back(y);\n\t\t\tnalezy[y].push_back(i);\n\t\t}\n\t\tile[i]=wek[i].size();\n\t\t//~ debug() << wek[i];\n\t}\n\tfor (int i=1; i<n; i++)\n\t\tjanusz.add_edge(0, i, 1);\n\tfor (int i=1; i<=n; i++)\n\t\tjanusz.add_edge(n+i, n, 1);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int j : wek[i])\n\t\t\tjanusz.add_edge(i, n+j, 1);\n\tjanusz.dinic(0, n);\n\tauto wez=janusz.get_flowing();\n\tdebug() << wez;\n\tfor (auto i : wez)\n\t\tif (i.first.first>0 && i.first.first<n && i.first.second>n && i.second)\n\t\t\tsko[i.first.second-n]=i.first.first;\n\tfor (int i=1; i<=n; i++)\n\t\tprze[sko[i]]=i;\n\tint v=0;\n\tdebug() << range(prze+1, prze+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tif (!sko[i])\n\t\t\tv=i;\n\tdebug() << imie(v);\n\tdfs(v);\n\tfor (int i=1; i<n; i++)\n\t\tif (!kra[i].first)\n\t\t\tnope();\n\tfor (int i=1; i<n; i++)\n\t\tprintf(\"%d %d\\n\", kra[i].first, kra[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0, t;i < In[u].size();++i)\n\t\tif (!done[t = In[u][i]])\n\t\t{\n\t\t\tdone[t] = true;\n\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), dfs(v);\n\t\t}\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tdfs(1); \n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\ntypedef unsigned long long lu;\ntypedef long long li;\ntypedef pair<int, int> pii;\nconst int mod = 1e9 + 7;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x = Sub(x - y); }\ninline int Mul(int x, int y) { return (int)((lu)x * y % mod); }\ninline int Mul(int x, int y, int z) { return (int)((lu)x * y % mod * z % mod); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) { return Pow(x, mod - 2); }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\n\n// ----------------------------------------\n\nnamespace dinic {\n  const int maxn = 1e6, maxm = 1e6;\n  typedef int FlowType;\n  const FlowType inf_f = ~0U >> 1;\n\n  void Init(int n);\n  void AddEdge(int u, int v, FlowType cap, li id);\n  FlowType Solve(int s, int t);\n  vector< pair<li, FlowType> > Result(void);\n}\n\nnamespace dinic {\n  struct Edge {\n    int v;\n    li id;\n    FlowType cap, cap0;\n  } edge[maxm << 1];\n\n  int n, m, s, t;\n  vector<int> g[maxn];\n\n  void Init(int _n) {\n    n = _n, m = 0;\n    for (int i = 0; i < n; ++i) g[i].clear();\n  }\n\n  void AddEdge(int u, int v, FlowType c, li id = -1) {\n    g[u].push_back(m);\n    edge[m++] = (Edge){v, id, c, c};\n    g[v].push_back(m);\n    edge[m++] = (Edge){u, id, 0, 0};\n  }\n\n  int iter[maxn], dist[maxn];\n\n  bool Bfs(void) {\n    queue<int> que;\n    que.push(s);\n    FILL(dist, n, -1);\n    dist[s] = 0;\n    while (!que.empty()) {\n      int u = que.front(); que.pop();\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap && dist[e.v] == -1) {\n          dist[e.v] = dist[u] + 1;\n          que.push(e.v);\n        }\n      }\n    }\n    return dist[t] >= 0;\n  }\n\n  FlowType Dfs(int u, FlowType f) {\n    if (u == t) return f;\n    FlowType sum = 0;\n    for (int &i = iter[u]; i < g[u].size(); ++i) {\n      Edge &e = edge[g[u][i]], &rev = edge[g[u][i] ^ 1];\n      if (e.cap && dist[e.v] == dist[u] + 1) {\n        FlowType res = Dfs(e.v, min(f - sum, e.cap));\n        e.cap -= res;\n        rev.cap += res;\n        if ((sum += res) == f) break;\n      }\n    }\n    return sum;\n  }\n\n  FlowType Solve(int _s, int _t) {\n    s = _s, t = _t;\n    FlowType ans = 0;\n    while (Bfs()) {\n      FILL(iter, n, 0);\n      ans += Dfs(s, inf_f);\n    }\n    return ans;\n  }\n\n  vector< pair<li, FlowType> > Result(void) {\n    vector< pair<li, FlowType> > ans;\n    for (int u = 0; u < n; ++u) {\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap < e.cap0 && e.id != -1) {\n          ans.push_back(make_pair(e.id, e.cap0 - e.cap));\n        }\n      }\n    }\n    return ans;\n  }\n}\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\nint n;\nvector<int> E[maxn];\nvector<int> F[maxn];\n\nint match[maxn], par[maxn];\nint A[maxn], B[maxn];\n\nvoid NoSolution(void) {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    while (c--) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      E[i].push_back(x);\n      F[x].push_back(i);\n    }\n  }\n\n  // root = 0\n  int L = 0, R = n, S = R + n - 1, T = S + 1, N = T + 1;\n  dinic::Init(N);\n  for (int i = 1; i < n; ++i) {\n    dinic::AddEdge(S, L + i, 1, -1);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    dinic::AddEdge(R + i, T, 1, -1);\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j : F[i]) {\n      dinic::AddEdge(L + i, R + j, 1, (li)i * n + j);\n    }\n  }\n  int flow = dinic::Solve(S, T);\n  if (flow < n - 1) NoSolution();\n\n  vector< pair<li, int> > way = dinic::Result();\n  for (pair<li, int> p : way) {\n    int x = (int)(p.first / n), y = (int)(p.first % n);\n    match[y] = x;\n  }\n\n  queue<int> que;\n  que.push(0);\n  FILL(par, n, -1);\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (int j : F[u]) {\n      int i = match[j];\n      if (par[i] == -1) {\n        par[i] = u;\n        A[j] = i;\n        B[j] = u;\n        que.push(i);\n      }\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    if (par[i] == -1) NoSolution();\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    printf(\"%d %d\\n\", A[i] + 1, B[i] + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 200000;\nconst int M = N << 4;\n\nint S, T;\n\nstruct edge {\n    int to, nxt, cap;\n};\n\nedge e[M + 5];\nint st[N + 5], ecnt = 1;\n\nvoid addedge(int u, int v, int c) {\n    e[++ ecnt] = (edge) { v, st[u], c }, st[u] = ecnt;\n    e[++ ecnt] = (edge) { u, st[v], 0 }, st[v] = ecnt;\n}\n\nint cur[N + 5], dis[N + 5];\n\nbool bfs() {\n    static int que[N + 5];\n    int head = 0, tail = 0;\n\n    memset(dis, 0xff, sizeof dis);\n    dis[que[tail ++] = S] = 0;\n\n    while(head < tail) {\n        int x = que[head ++];\n        for(int i = st[x]; i; i = e[i].nxt) if(e[i].cap) {\n            int y = e[i].to;\n            if(dis[y] == -1) {\n                dis[y] = dis[x] + 1;\n                que[tail ++] = y;\n            }\n        }\n    }\n    return ~dis[T];\n}\n\nint dfs(int x, int flow) {\n    if(x == T || !flow) {\n        return flow;\n    }\n\n    int res = 0;\n    for(int &i = cur[x]; i; i = e[i].nxt) {\n        int y = e[i].to, aug;\n        if(dis[y] == dis[x] + 1 && (aug = dfs(y, std::min(e[i].cap, flow)))) {\n            res += aug;\n            flow -= aug;\n            e[i].cap -= aug;\n            e[i ^ 1].cap += aug;\n            if(!flow) break;\n        }\n    }\n    return res;\n}\n\nint max_flow() {\n    int ans = 0;\n    while(bfs()) {\n        memcpy(cur, st, sizeof cur);\n        ans += dfs(S, oo);\n    }\n    return ans;\n}\n\nint n, cnt;\npii ans[N + 5];\nint mat[N + 5];\nbool vis[N + 5];\nvector<int> g[N + 5];\n\nvoid dfs(int u) {\n    for(auto v : g[u]) if(!vis[v]) {\n        ++ cnt;\n        vis[v] = true;\n        ans[v - n] = mp(u, mat[v]);\n        dfs(mat[v]);\n    }\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    S = n << 1, T = S + 1;\n    for(int i = 2; i <= n; ++i) {\n        addedge(S, i, 1);\n    }\n\n    for(int i = 1; i < n; ++i) {\n        static int c, x;\n\n        for(read(c); c--; ) {\n            read(x);\n            g[x].pb(i + n);\n            addedge(x, i + n, 1);\n        }\n        addedge(i + n, T, 1);\n    }\n\n    int mf = max_flow();\n\n    if(mf < n - 1) return !puts(\"-1\");\n\n    for(int i = 2; i <= n; ++i) {\n        for(int j = st[i]; j; j = e[j].nxt) {\n            int t = e[j].to;\n            if(!e[j].cap && t > n && t < 2*n) {\n                mat[t] = i;\n                break;\n            }\n        }\n    }\n\n    dfs(1);\n\n    if(cnt < n - 1) {\n        puts(\"-1\");\n    } else {\n        for(int i = 1; i < n; ++i) {\n            printf(\"%d %d\\n\", ans[i].fst, ans[i].snd);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int inf=1000000000;\nint n,m,cnt,id[100001],p[100001],P[100001],hd[200101],cur[200101],dis[200101],q[200101],l,r,K,x,fa[100001],ans,nw;\nstruct node{int to,next,c;}e[1000001];\nvector<int> v[100001];\nbool bo[200101];\n\nint ask(int x) {return fa[x]==x?x:fa[x]=ask(fa[x]);}\nbool cmp(int a,int b) {return v[a].size()<v[b].size();}\n\nvoid addedge(int x,int y,int c) \n{\n\te[++cnt]=(node){y,hd[x],c},hd[x]=cnt;\n\te[++cnt]=(node){x,hd[y],0},hd[y]=cnt;\n}\n\nbool bfs()\n{\n\tfor (int i=1; i<=n+n+1; i++) dis[i]=inf;\n\tq[l=r=1]=1,dis[1]=0,memset(bo,0,sizeof(bo)),bo[1]=0;\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\tif (e[i].c&&!bo[e[i].to]) bo[e[i].to]=1,q[++r]=e[i].to,dis[e[i].to]=dis[x]+1;\n\t\tl++;\n\t}\n\treturn dis[n+n+1]<inf;\n}\n\nbool dinic(int x)\n{\n\tif (x==n+n+1) return 1;\n\tfor (int &i=cur[x]; i; i=e[i].next)\n\t\tif (e[i].c&&dis[e[i].to]==dis[x]+1&&dinic(e[i].to)) \n\t\t\treturn e[i].c--,e[i^1].c++,1;\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),cnt=1;\n\tmemset(hd,0,sizeof(hd));\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&K),v[i].clear(),id[i]=i;\n\t\tfor (int j=1; j<=K; j++) scanf(\"%d\",&x),v[i].push_back(x);\n\t}\n\tsort(id+1,id+n,cmp);\n\tfor (int i=1; i<n; i++) addedge(1,i+1,1);\n\tfor (int i=1; i<=n; i++) addedge(i+n,n+n+1,1);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int siz=v[i].size(),j=0; j<siz; j++) \n\t\t\taddedge(i+1,v[i][j]+n,1);\n\tans=0;\n\twhile (bfs())\n\t{\n\t\tfor (int i=1; i<=n+n+1; i++) cur[i]=hd[i];\n\t\twhile (dinic(1)) ans++;\n\t}\n\tif (ans!=n-1) return puts(\"-1\"),0;\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=hd[i+1]; j; j=e[j].next)\n\t\t\tif (!e[j].c) {p[i]=e[j].to-n; break;}\n\tfor (int i=1; i<=n; i++) fa[i]=i;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tP[id[i]]=0;\n\t\tfor (int j=0,siz=v[id[i]].size(); j<siz; j++)\n\t\t\tif (ask(v[id[i]][j])!=ask(p[id[i]])) {P[id[i]]=v[id[i]][j]; break;}\n\t\tif (!P[id[i]]) return puts(\"-1\"),0;\n\t\tfa[ask(P[id[i]])]=ask(p[id[i]]);\n\t}\n\tfor (int i=1; i<n; i++) printf(\"%d %d\\n\",p[i],P[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXESUM=200000;\n\nconst int MAXGN=2+MAXN+MAXN-1;\nconst int MAXGM=MAXN-1+MAXN-1+MAXESUM;\n\ntypedef struct MF {\n\tint n,m;\n\tint ghead[MAXGN],gnxt[2*MAXGM],gto[2*MAXGM]; ll gcap[2*MAXGM];\n\tvoid init(int _n) { n=_n,m=0; REP(i,n) ghead[i]=-1; }\n\tvoid addedge(int a,int b,ll c) { gnxt[2*m+0]=ghead[a],ghead[a]=2*m+0,gto[2*m+0]=b,gcap[2*m+0]=c; gnxt[2*m+1]=ghead[b],ghead[b]=2*m+1,gto[2*m+1]=a,gcap[2*m+1]=0; ++m; /*printf(\"%d->%d\\n\",a,b);*/ }\n\tint d[MAXGN];\n\tint q[MAXGN],qhead,qtail;\n\tint cur[MAXGN];\n\tll dinic(int s,int t) {\n\t\tll ret=0; int niter=0;\n\t\twhile(true) {\n\t\t\tREP(i,n) d[i]=INT_MAX; qhead=qtail=0; d[s]=0,q[qhead++]=s;\n\t\t\twhile(qtail<qhead&&d[t]==INT_MAX) { int at=q[qtail++];for(int x=ghead[at];x!=-1;x=gnxt[x]) { int to=gto[x]; if(gcap[x]==0||d[to]!=INT_MAX) continue; d[to]=d[at]+1; q[qhead++]=to; } }\n\t\t\tif(d[t]==INT_MAX) return ret;\n\t\t\tREP(i,n) cur[i]=ghead[i];\n\t\t\tret+=dfs(s,t,LLONG_MAX); ++niter;\n\t\t}\n\t}\n\tll dfs(int at,int t,ll rem) {\n\t\tll ret=0; if(at==t) return rem;\n\t\tif(d[at]>=d[t]) return 0;\n\t\tfor(;cur[at]!=-1;cur[at]=gnxt[cur[at]]) {\n\t\t\tint to=gto[cur[at]]; ll cap=gcap[cur[at]]; if(d[to]!=d[at]+1||cap==0) continue;\n\t\t\tll now=dfs(to,t,min(cap,rem));\n\t\t\trem-=now; ret+=now; if(gcap[cur[at]]!=LLONG_MAX) gcap[cur[at]]-=now; if(gcap[cur[at]^1]!=LLONG_MAX) gcap[cur[at]^1]+=now; if(rem==0) return ret;\n\t\t}\n\t\treturn ret;\n\t}\n} MF;\nMF g;\n\n\nint n;\nvector<int> e[MAXN-1];\npair<int,int> ans[MAXN-1];\n\nint sid,tid,lid[MAXN],rid[MAXN-1],nid;\nint match[MAXN],rmatch[MAXN-1];\nvector<int> who[MAXN];\nbool intree[MAXN];\nint q[MAXN],qhead,qtail;\n\nbool solve() {\n\tnid=0; sid=nid++,tid=nid++; FOR(i,1,n) lid[i]=nid++; REP(i,n-1) rid[i]=nid++;\n\tg.init(nid);\n\tFOR(i,1,n) g.addedge(sid,lid[i],1);\n\tREP(j,n-1) for(int i:e[j]) if(i!=0) g.addedge(lid[i],rid[j],1);\n\tREP(i,n-1) g.addedge(rid[i],tid,1);\n\tll flow=g.dinic(sid,tid);\n\t\n\tif(flow!=n-1) return false;\n\tREP(i,n) match[i]=-1; FOR(i,1,n) for(int x=g.ghead[lid[i]];x!=-1;x=g.gnxt[x]) if(g.gcap[x^1]==1&&g.gto[x]>=rid[0]) { assert(match[i]==-1); match[i]=g.gto[x]-rid[0]; } FOR(i,1,n) assert(match[i]!=-1);\n\tREP(i,n-1) rmatch[i]=-1; REP(i,n) if(match[i]!=-1) { assert(rmatch[match[i]]==-1); rmatch[match[i]]=i; } REP(i,n-1) assert(rmatch[i]!=-1);\n\t//FOR(i,1,n) { printf(\"%d:\",i+1); REPSZ(j,e[match[i]]) printf(\" %d\",e[match[i]][j]+1); puts(\"\"); }\n\n\tREP(i,n-1) REPSZ(j,e[i]) who[e[i][j]].PB(i);\n\tqhead=qtail=0; REP(i,n) intree[i]=false;\n\tintree[0]=true; q[qhead++]=0;\n\twhile(qtail<qhead) {\n\t\tint at=q[qtail++];\n\t\tREPSZ(i,who[at]) {\n\t\t\tint id=who[at][i],to=rmatch[id];\n\t\t\tif(!intree[to]) { ans[id]=MP(at,to); intree[to]=true; q[qhead++]=to; }\n\t\t}\n\t}\n\tREP(i,n) if(!intree[i]) return false;\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n-1) { int cnt; scanf(\"%d\",&cnt); REP(j,cnt) { int x; scanf(\"%d\",&x); --x; e[i].PB(x); } }\n\tif(!solve()) { printf(\"-1\\n\"); return; }\n\tREP(i,n-1) printf(\"%d %d\\n\",ans[i].first+1,ans[i].second+1);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1000010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[100010], ans[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue < int > q;\n    q.push(n);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[(N<<1)+3];\nvector<pair<int,pii> > ans;\nint mch[(N<<1)+3];\nbool vis[(N<<1)+3];\nint n;\n\nvoid dfs(int u)\n{\n\tfor(int o=0; o<adj[u].size(); o++)\n\t{\n\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\tif(vis[mch[v]]) continue;\n\t\tvis[v] = vis[mch[v]] = true; ans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\tdfs(mch[v]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tvis[1] = true; dfs(1);\n\tif(ans.size()<n-1) {puts(\"-1\"); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n\n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n\n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n\n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i))\n                    was = 1;\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << min(a.X, a.Y) + 1 << \" \" << max(a.X, a.Y) + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back({x,i,mxfl::adde(x,i+n,1)});\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],u[N],v[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; u[m]=i; v[m]=id[j]; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,m) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 200011\n#define INF 0x7f7f7f7f\nusing namespace std;\nstruct apple{\n\tint v,nxt,flw;\n}edge[N*11];\nint que[N],indexx[N],dist[N],cur[N],Mac[N][2],tot,S,T,vist[N],n;\nvector<int> V[N];\nvoid addedge(int x,int y,int flw){\n\tedge[++tot].v=y;\n\tedge[tot].flw=flw;\n\tedge[tot].nxt=indexx[x];\n\tindexx[x]=tot;\n}\nvoid add(int x,int y,int flw){\n\taddedge(x,y,flw);\n\taddedge(y,x,0);\n}\nint bfs(){\n\tmemset(dist,0,sizeof(dist));\n\tmemcpy(cur,indexx,sizeof(indexx));\n\tdist[S]=1;\n\tint head=0,tail=0;\n\tque[++tail]=S;\n\twhile(head<tail){\n\t\tint x=que[++head];\n\t\tint t=indexx[x],vv;\n\t\twhile(t){\n\t\t\tvv=edge[t].v;\n\t\t\tif(edge[t].flw && !dist[vv]){\n\t\t\t\tdist[vv]=dist[x]+1;\n\t\t\t\tque[++tail]=vv;\n\t\t\t}\n\t\t\tt=edge[t].nxt;\n\t\t}\n\t}\n\treturn dist[T];\n}\nint dfs(int u,int flw){\n\tif(u==T) return flw;\n\tint t=cur[u],vv,All=0;\n\twhile(t){\n\t\tvv=edge[t].v;\n\t\tcur[u]=t;\n\t\tif(edge[t].flw && dist[vv]==dist[u]+1){\n\t\t\tint temp=dfs(vv,min(flw,edge[t].flw));\n\t\t\tif(temp){\n\t\t\t\tAll+=temp;\n\t\t\t\tedge[t].flw-=temp;\n\t\t\t\tedge[((t-1)^1)+1].flw+=temp;\n\t\t\t\tflw-=temp;\n\t\t\t\tif(!flw) return All;\n\t\t\t}\n\t\t}\n\t\tt=edge[t].nxt;\n\t}\n\treturn All;\n}\nint Dinic(){\n\tint ret=0;\n\twhile(bfs()){\n\t\tret+=dfs(S,INF);\n\t}\n\treturn ret;\n}\nint solve(){\n\tint head=0,tail=0;\n\tque[++tail]=n;\n\twhile(head<tail){\n\t\tint x=que[++head];\n\t\tint len=V[x].size();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint y=V[x][i];\n\t\t\tif(vist[y]) continue;\n\t\t\tvist[y]=1;\n\t\t\tMac[y][0]=x;\n\t\t\tint t=indexx[y+n],vv;\n\t\t\twhile(t){\n\t\t\t\tvv=edge[t].v;\n\t\t\t\tif(!edge[t].flw){\n\t\t\t\t\tMac[y][1]=vv;\n\t\t\t\t\tque[++tail]=vv;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt=edge[t].nxt;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(!vist[i]) return -1;\n\t}\n\treturn 1;\n}\nint main(){\n\tint m,x;\n\tscanf(\"%d\",&n);S=n*2,T=n*2+1;\n\tfor(int i=1;i<n;i++){\n\t\tadd(S,i+n,1);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tV[x].push_back(i);\n\t\t\tadd(i+n,x,1);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) add(i,T,1);\n\tint t=Dinic();\n\tif(t!=n-1){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tt=solve();\n\tif(t==-1){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(Mac[i][0]>Mac[i][1]) swap(Mac[i][0],Mac[i][1]);\n\t\tprintf(\"%d %d\\n\",Mac[i][0],Mac[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nstruct edge{\n\tint y,next,c;\n}s[N<<3];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[0]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t\tif(t==tot) break;\n\t}\n\tif(!tot) d[x]=0;\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(!las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\\n\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n\nconst int N=1e6+5,M=3e6+5,INF=0x3f3f3f3f;\nint n;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint h[N],le=1;\nint hh[N];\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\nvoid add_bidir_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,v);}\n#define FORe(i,u,v,w)     for(int  i= h[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,u,v,w) for(int &i=hh[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint dep[N];\nqueue<int> q;\n\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    dep[s]=1, q.push(s);\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w) if(!dep[v]&&w)dep[v]=dep[u]+1, q.push(v);\n    }\n    return dep[t]!=0;\n}\nint dfs(int u,int flow){\n    if(u==t||!flow)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(rest,w));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int x;(x=dfs(s,INF));)maxflow+=x;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nvoid bfs(){\n\tmemset(dep,-1,sizeof(dep));\n\tqueue<int>q;\n\tq.push(T);\n\tdep[T]=0;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\t++gap[dep[k1]];\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i])if(dep[to[i]]==-1){\n\t\t\tdep[to[i]]=dep[k1]+1;\n\t\t\tq.push(to[i]);\n\t\t}\n\t}\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\trd(n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\trd(m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\trd(k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tbfs();\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\n\nint n;\n\ninline void failed(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<int> G[N];\nbool vis[N];\nint match[N];\nint pref[N];\nstack<int> stk;\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<G[x].size();i++){\n\t\tint v=G[x][i];if(vis[v])continue;\n\t\tvis[v]=1;stk.push(v);\n\t\tif(!pref[v] || dfs(pref[v])){\n\t\t\tmatch[x] = v;\n\t\t\tpref[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint s[N];\ntypedef pair<int,int> pi;\nvector<pi> tr;\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<n;i++){\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int j=1,e;j<=c;j++){\n\t\t\tscanf(\"%d\",&e);\n\t\t\tG[e].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\t// cout << i << \":\";\n\t\tif(!dfs(i))failed();\n\t\twhile(stk.size()){\n\t\t\t// cout << stk.top();\n\t\t\tvis[stk.top()]=0;\n\t\t\tstk.pop();\n\t\t}\n\t\t// cout << \"?\" << endl;\n\t}\n\tqueue<int> q;\n\tfor(size_t i=0;i<G[1].size();i++){\n\t\ts[G[1][i]]=1;\n\t\tq.push(G[1][i]);\n\t}\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tint v = pref[u];\n\t\t// cout << u << \":::\" << s[u] << \" \" << v << endl;\n\t\ttr.push_back(pi(v,s[u]));\n\t\tfor(size_t i=0;i<G[v].size();i++){\n\t\t\tif(!s[G[v][i]])s[G[v][i]]=v,q.push(G[v][i]);\n\t\t}\n\t}\n\tif((int)tr.size()<n-1){\n\t\tfailed();\n\t}\n\tfor(size_t i=0;i<tr.size();i++){\n\t\tprintf(\"%d %d\\n\",tr[i].first,tr[i].second);\n\t}\n\treturn 0;\n}\n/* \n10\n5 1 2 3 4 5\n5 2 3 4 5 6\n5 3 4 5 6 7\n5 4 5 6 7 8\n5 5 6 7 8 9\n5 6 7 8 9 10\n5 7 8 9 10 1\n5 8 9 10 1 2\n5 9 10 1 2 3\n */"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nvector<pii> g[N];\npii ans[N];\nint p[N],vis[N],use[N],la;\nvoid dfs(int u){\n    vis[u]=1;\n    for(pii v:g[u])if(!vis[v.fi]&&!use[v.se]){\n        use[v.se]=1;\n        ans[v.se]={u,v.fi};\n        ++la;\n        dfs(v.fi);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1是根结点\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb({p[i],i});//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(la!=n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\nusing namespace std;\nconst int N=1e5+5;\nint n,T,c,a,ans,u[N],v[N];\nint la[N*2],st[N*2],ne[N*8],to[N*8],l[N*8],h[N*2],d[N*2],js;\nbool bz[N*2];\nvector<int>e[N*2];\nvoid link(int x,int y){\n\tne[++js]=la[x];la[x]=js;to[js]=y;l[js]=1;\n\tne[++js]=la[y];la[y]=js;to[js]=x;\n}\nbool get(){\n\tfo(i,0,T)st[i]=la[i],h[i]=-1;\n\th[0]=0;d[1]=0;\n\tfor(int s=0,t=1,x;x=d[++s],s<=t;)\n\t\tfor(int i=la[x];i;i=ne[i])if(l[i]&&h[to[i]]==-1)\n\t\t\th[to[i]]=h[x]+1,d[++t]=to[i];\n\treturn h[T]>-1;\n}\nint dinic(int x,int su){\n\tif(x==T)return su;int us=0;\n\tfor(int i=st[x];i;i=ne[i])\n\t\tif(l[i]&&h[to[i]]==h[x]+1){\n\t\t\tint tt=dinic(to[i],min(su-us,l[i]));\n\t\t\tif(tt){\n\t\t\t\tl[i]-=tt;l[i^1]+=tt;us+=tt;\n\t\t\t\tif(us==su)return us;\n\t\t\t}\n\t\t\tst[x]=i;\n\t\t}\n\th[x]=-1;\n\treturn us;\n}\nvoid dfs(int x){\n\tbz[x]=1;\n\tif(x<=n){\n\t\tfor(int i:e[x])if(!bz[i])u[i-n]=x,dfs(i);\n\t}else{\n\t\tif(!bz[v[x-n]])dfs(v[x-n]);\n\t}\n}\nbool ck(){\n\tfo(i,1,n*2-1)if(!bz[i])return 0;\n\treturn 1;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;js=1;\n\tT=n+n+1;\n\tfo(i,1,n-1){\n\t\tcin>>c;\n\t\tlink(0,i);\n\t\tfo(j,1,c){\n\t\t\tcin>>a;\n\t\t\tif(a!=1)link(i,n+a);\n\t\t\te[a].push_back(n+i);\n\t\t\te[n+i].push_back(a);\n\t\t}\n\t}\n\tfo(i,2,n)link(n+i,T);\n\tfor(;get();)ans+=dinic(0,n);\n\tif(ans==n-1){\n\t\tfo(i,1,n-1)for(int j=la[i];j;j=ne[j])if(!l[j])v[i]=to[j]-n;\n\t\tdfs(1);\n\t\tif(ck()){\n\t\t\tfo(i,1,n-1)printf(\"%d %d\\n\",u[i],v[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<-1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[101010];\nint match[101010];\nbool used[101010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used[en]) {\n                        used[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<ll>& cap){\n\n    if (v == g) return maxflow;\n    cap[v] = 0;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[nex] == 1)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n    vector<ll> level(N,inf);\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        rep(i,0,N) level[i] = inf;\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<ll> cap(N,1);\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=200000+10,inf=0x3f3f3f3f;\nint n,e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<2],to[MAXN<<2],out[MAXN<<2],cap[MAXN<<2],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nPII side[MAXN];\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tside[v]=mp(mh[v],x),vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,1,n-1)printf(\"%d %d\\n\",side[i].ft,side[i].sd);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--) \n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a % b == 0) return 0;\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\n\nint n;\nvector<vector<int>> g;\nvector<int> rez;\nvector<int> sc;\nvector<bool> used;\n\nbool ktun(int v) {\n\tused[v] = true;\n\tfor (int sub : g[v]) {\n\t\tif (rez[sub] == -1) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int sub : g[v]) {\n\t\tif (used[rez[sub]]) continue;\n\t\tif (ktun(rez[sub])) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\t\n\tg.resize(n);\n\trez.resize(n - 1, -1);\n\tsc.resize(n - 1, -1);\n\tf(i, n - 1) {\n\t\tint k;\n\t\tscan k;\n\t\tf(j, k) {\n\t\t\tint x;\n\t\t\tscan x;\n\t\t\tx--;\n\t\t\tg[x].pb(i);\n\t\t}\n\t}\n\tused = vector<bool>(n, false);\n\tf(i, n) {\n\t\tif (ktun(i)) {\n\t\t\tused = vector<bool>(n, false);\n\t\t}\n\t}\n\tset<int> all;\n\tf(i, n) {\n\t\tall.insert(i);\n\t}\n\tvector<int> id(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (rez[i] == -1) {\n\t\t\tprint -1;\n\t\t\treturn 0;\n\t\t}\n\t\tid[rez[i]] = i;\n\t\tall.erase(rez[i]);\n\t}\n\tused = vector<bool>(n, false);\n\tdeque<int> deq{*all.begin()};\n\tused[deq[0]] = true;\n\twhile (!deq.empty()) {\n\t\tint v = deq[0];\n\t\tdeq.pop_front();\n\t\tfor (int sub : g[v]) {\n\t\t\tif (used[rez[sub]]) continue;\n\t\t\tused[rez[sub]] = true;\n\t\t\tsc[sub] = v;\n\t\t\tdeq.pb(rez[sub]);\n\t\t}\n\t}\n\tif (used != vector<bool>(n, true)) {\n\t\tprint -1;\n\t\treturn 0;\n\t}\n\tf(i, n - 1) {\n\t\tprint rez[i] + 1, sc[i] + 1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[(N<<1)+3];\nvector<pair<int,pii> > ans;\nint mch[(N<<1)+3];\nbool vis[(N<<1)+3];\nint que[N+3];\nint n;\n\nbool bfs()\n{\n\tint hd = 1,tl = 1; que[1] = 1; vis[1] = true;\n\twhile(hd<=tl)\n\t{\n\t\tint u = que[hd]; hd++;\n\t\tfor(int o=0; o<adj[u].size(); o++)\n\t\t{\n\t\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\t\tif(vis[mch[v]]) continue;\n\t\t\tque[++tl] = mch[v]; vis[v] = vis[mch[v]] = true;\n\t\t\tans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\t}\n\t}\n\tif(tl<n) {return false;}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tif(!bfs()) {puts(\"-1\"); assert(0); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n)p[u]=gp;\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=2;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=2;i<=n;++i)if(!p[i])return puts(\"-1\"),0;\n\tfor(int i=2;i<=n;++i)printf(\"%d %d\\n\",p[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MN 101000\n#define MM 801000\n\nint h[MN], nxt[MM], to[MM], cap[MM], K = 1;\nint iter[MN], d[MN], q[MN], hh = 0, tt = 0;\nstd::vector<int> B[MN];\nint x[MN], y[MN], o = 0;\nbool used[MN]; int mat[MN];\n\nvoid ins(int u, int v, int c) {nxt[++K] = h[u]; h[u] = K; to[K] = v; cap[K] = c;}\nvoid insw(int u, int v, int c) {ins(u, v, c); ins(v, u, 0);}\n\nbool bfs(int S, int T)\n{\n\tmemset(d, 0, sizeof(d));\n\thh = tt = 0; d[S] = 1; q[tt++] = S;\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t\tif(cap[i] && !d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\tif(to[i] == T) return 1;\n\t\t\t\tq[tt++] = to[i];\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int T, int f)\n{\n\tif(u == T) return f;\n\tint used = 0;\n\tfor(int &i = iter[u]; i; i = nxt[i])\n\t\tif(cap[i] && d[to[i]] == d[u] + 1)\n\t\t{\n\t\t\tint w = dfs(to[i], T, std::min(f - used, cap[i]));\n\t\t\tif(w)\n\t\t\t{\n\t\t\t\tcap[i] -= w; cap[i ^ 1] += w; used += w; \n\t\t\t\tif(used == f) return f;\n\t\t\t}\n\t\t}\n\treturn used;\n}\n\nint dinic(int S, int T)\n{\n\tint flow = 0;\n\twhile(bfs(S, T))\n\t{\n\t\tmemcpy(iter, h, sizeof(h));\n\t\tint f;\n\t\twhile(f = dfs(S, T, 1e9)) flow += f;\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint S = 2 * n, T = S + 1; \n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint o; scanf(\"%d\", &o);\n\t\tfor(int j = 1; j <= o; j++) \n\t\t{\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\tB[k].push_back(i);\n\t\t\tinsw(i, n - 1 + k, 1); \n\t\t}\n\t\tinsw(S, i, 1);\n\t}\n\tfor(int i = n; i < 2 * n; i++) insw(i, T, 1);\n\tif(dinic(S, T) != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = h[i]; j; j = nxt[j])\n\t\t\tif(!cap[j] && n <= to[j] && to[j] < 2 * n) mat[i] = to[j] - n + 1;\n\tfor(int i = 1; i < n; i++) used[mat[i]] = 1;\n\thh = tt = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) q[tt++] = i;\n\tmemset(used, 0, sizeof(used));\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = 0; i < B[u].size(); i++)\n\t\t{\n\t\t\tif(!used[B[u][i]]) \n\t\t\t{\n\t\t\t\tused[B[u][i]] = 1;\n\t\t\t\t++o; x[o] = mat[B[u][i]]; y[o] = u;\n\t\t\t\tq[tt++] = mat[B[u][i]];\n\t\t\t}\n\t\t}\n\t}\n\tif(o != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i <= o; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_], vis[N_], UF[N_], vv[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)UF[i] = i;\n\tfor (i = 1; i < n; i++) {\n\t\tw[i] = { Deg[i],i };\n\t}\n\tsort(w + 1, w + n);\n\tint s = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint a = w[i].num, c = 0, u[4];\n\t\tif (vis[a])continue;\n\t\tfor (auto &t : A[a]) {\n\t\t\tif (!vv[Find(t)]) {\n\t\t\t\tvv[Find(t)] = 1;\n\t\t\t\tu[c++] = t;\n\t\t\t\tif (c >= 2)break;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < c; j++)vv[Find(u[j])] = 0;\n\t\ts++;\n\t\tvis[a] = 1;\n\t\tRes[a][0] = u[0], Res[a][1] = u[1];\n\t\tMerge(u[0], u[1]);\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\nint W[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tif (N == 2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t\tW[x]++;\n\t\t}\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsort(v.begin(),v.end());\n\n\tfor (int i=1;i<=N;i++){\n\t\tif (W[i] == 0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=0;i<N-1;i++){\n\t\tint c = 0;\n\t\tfor (int x : G[i]) if (W[x] == 1) c++;\n\t\tif (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsrand(time(NULL));\n\tfor (int t=0;t<1000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005, Inf = 1 << 30;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nint n;\nqueue<int> q;\nvector<int> vec[maxn];\nint eu[maxn], ev[maxn], vis[maxn];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn << 3];\nint s, t, h[maxn << 1], cur[maxn << 1], dis[maxn << 1], mat[maxn << 1], tot = 1;\n\ninline void add(int u, int v, int w)\n{\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nbool bfs()\n{\n\tstatic int l, r, q[maxn << 1];\n\tmemset(dis + 1, 0, sizeof(int) * t);\n\tl = 0; q[r = 1] = s; dis[s] = 1;\n\twhile (l < r) {\n\t\tint u = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!dis[v] && e[i].cap) dis[v] = dis[u] + 1, q[++r] = v;\n\t}\n\treturn dis[t];\n}\n\nint dfs(int u, int a)\n{\n\tif (u == t || !a) return a;\n\tint f, flow = 0;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (dis[v] == dis[u] + 1 && (f = dfs(v, min(a, e[i].cap)))) {\n\t\t\tflow += f; a -= f;\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint max_flow()\n{\n\tint res = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * t);\n\t\tres += dfs(s, Inf);\n\t}\n\tfor (int u = 1; u < n; ++u)\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!e[i].cap && v != s) {mat[u] = v; mat[v] = u; break;}\n\treturn res;\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int c, w, i = 1; i < n; ++i) {\n\t\tc = gi();\n\t\twhile (c--) {\n\t\t\tw = gi(); vec[w].push_back(i);\n\t\t\tif (w != n) add(w, i + n - 1, 1);\n\t\t}\n\t}\n\ts = n * 2 - 1; t = s + 1;\n\tfor (int i = 1; i < n; ++i) add(s, i, 1), add(i + n - 1, t, 1);\n\t\n\tif (max_flow() != n - 1) return puts(\"-1\"), 0;\n\tint cnt = 0; q.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); ++cnt;\n\t\tfor (int e : vec[u])\n\t\t\tif (!vis[e]) vis[e] = 1, q.push(mat[e + n - 1]), eu[e] = u, ev[e] = mat[e + n - 1];\n\t}\n\tif (cnt != n) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\n// O(V^2 E)\nstruct Dinic {\n    using F = ll;\n    static constexpr F INF = numeric_limits<F>::max();\n\n    struct Edge {\n        int to, rev;\n        F cap;\n        Edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev){};\n    };\n\n    using E = Edge;\n\n    VV<E> g;\n    V<int> level, iter;\n\n    Dinic() {}\n    Dinic(int n) : g(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, F cap) {\n        g[from].emplace_back(to, cap, (int)g[to].size());\n        g[to].emplace_back(from, 0, (int)g[from].size() - 1);\n    }\n\n    void bfs(int s) {\n        fill(ALL(level), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (auto& e : g[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    F dfs(int v, int t, F f) {\n        if (v == t) return f;\n        for (int& i = iter[v]; i < g[v].size(); i++) {\n            auto& e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                F d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    F max_flow(int s, int t) {\n        F flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(ALL(iter), 0);\n            F f;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n};\n\nVV<pii> gg;\nV<bool> vis;\nV<pii> ans;\n\nvoid dfs(int v) {\n    vis[v] = 1;\n    for (auto e : gg[v]) {\n        if (!vis[e.fi]) {\n            ans[e.se] = mp(v, e.fi);\n            dfs(e.fi);\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    VV<int> E(N);\n    rep(i, N - 1) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int x;\n            cin >> x;\n            --x;\n            E[i].pb(x);\n        }\n    }\n\n    int r = 0;  // special\n    Dinic flow(N + N + 2);\n    int s = N * 2, t = s + 1;\n    rep(i, N - 1) {\n        flow.add_edge(i + N, t, 1);\n        for (int x : E[i])\n            if (x != r) {\n                flow.add_edge(x, i + N, 1);\n            }\n    }\n    rep(i, N) { flow.add_edge(s, i, 1); }\n    int f = flow.max_flow(s, t);\n\n    if (f != N - 1) {\n        puts(\"-1\");\n        return 0;\n    }\n\n    V<int> rmt(N);\n    for (int i = 1; i < N; ++i) {\n        for (auto e : flow.g[i]) {\n            if (e.to >= N && e.to < N + N - 1 && e.cap == 0) {\n                rmt[e.to - N] = i;\n            }\n        }\n    }\n    debug(rmt);\n\n    gg.resize(N);\n    vis.resize(N);\n\n    rep(i, N - 1) {\n        for (int v : E[i]) {\n            gg[v].eb(rmt[i], i);\n        }\n    }\n\n    ans.resize(N - 1, mp(-1, -1));\n    dfs(0);\n    bool ok = 1;\n    rep(i, N - 1) if (ans[i] == mp(-1, -1)) {\n        puts(\"-1\");\n        return 0;\n    }\n    rep(i, N - 1) { cout << ans[i].fi + 1 << \" \" << ans[i].se + 1 << endl; }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005 , S = 0 , T = 200000;\nstruct node{int to,next,val;}e[N<<4];\nint head[N],cnt,dep[N],q[N],c[N],n;\nvoid add(int x,int y,int z){e[cnt]=(node){y,head[x],z};head[x]=cnt++;}\nvoid insert(int x,int y,int z){add(x,y,z),add(y,x,0);}\nint bfs()\n{\n\tint l=0,r=0;q[r++] = S;memset(dep,-1,sizeof(dep));dep[S] = 1;\n\twhile(l<r)\n\t{\n\t\tint x = q[l++];\n\t\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t\t{\n\t\t\tint to1=e[i].to;\n\t\t\tif(dep[to1]==-1&&e[i].val)dep[to1] = dep[x]+1 , q[r++] = to1;\n\t\t}\n\t}return dep[T] != -1;\n}\nint dfs(int x,int maxf)\n{\n\tif(x==T)return maxf;int tflow = maxf , nowf;\n\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t{\n\t\tint to1=e[i].to;\n\t\tif(dep[to1]==dep[x]+1&&e[i].val)\n\t\t{\n\t\t\tnowf = dfs(to1 , min(tflow , e[i].val) );\n\t\t\tif(nowf && x>=1 && x<=n-1 && to1) c[x]=to1-n+2;\n\t\t\te[i].val-=nowf , tflow -= nowf , e[i^1].val += nowf;\n\t\t\tif(!tflow)break;\n\t\t}\n\t}if(tflow)dep[x] = -1;return maxf-tflow;\n}\nvector<int >v[N];\nint Dinic()\n{\n\tint sum = 0;\n\twhile(bfs())sum += dfs(S,1<<30);\n\treturn sum;\n}\nint vis[N];pair<int ,int > ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);memset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint siz; scanf(\"%d\",&siz); insert(S,i,1); insert(n+i-1,T,1);\n\t\tfor(int j=1,x;j<=siz;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x),v[x].push_back(i);\n\t\t\tif(x!=1)insert(i,n+x-2,1);\n\t\t}\n\t}\n\t// puts(\"B\");\n\tif(Dinic()==n-1)\n\t{\n\t\t// puts(\"a\");\n\t\tint l = 0 , r = 0;\n\t\tfor(int i=0;i<v[1].size();i++)\n\t\t\tq[r++] = v[1][i] , vis[v[1][i]] = 1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint x = q[l++]; ans[l] = make_pair(vis[x] , c[x]); x = c[x];\n\t\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\t\tif(!vis[v[x][i]]) q[r++] = v[x][i] , vis[v[x][i]] = x;\n\t\t}\n\t\tif(r==n-1)for(int i=1;i<n;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\telse puts(\"-1\");\n\t}else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//数字i在哪些集合 \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);h=t=0;q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i]){\n\t\t\tdis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t\t\tif(a[i]==T)return 1;\n\t\t}\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\nvector<int> r;\nvector<int> z;\n\nint ccc = 0;\n\nbool dfs(int x) {\n//    cout << x << \"\\n\";\n    if (z[x] == ccc) return false;\n    z[x] = ccc;\n    for (int y : g[x]) {\n        if (r[y] == -1 || dfs(r[y])) {\n            r[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    g.resize(n);\n    r.assign(n, -1);\n    z.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x;\n            x--;\n            g[x].push_back(i);\n        }\n    }\n\n    int ff = -1;\n    for (int i = 0; i < n; i++) {\n        ccc++;\n        if (!dfs(i)) {\n            if (ff == -1) {\n                ff = i;\n            } else {\n                cout << -1 << \"\\n\";\n                return 0;\n            }\n        }\n    }\n\n//    for (int i = 0; i < n - 1; i++) {\n//        cout << r[i] << \"\\n\";\n//    }\n\n    vector<int> q;\n    vector<bool> zz(n);\n    q.push_back(ff);\n    vector<pair<int, int>> res(n - 1);\n    for (int i = 0; i < q.size(); i++) {\n        int x = q[i];\n        for (int c : g[x]) {\n            if (!zz[c]) {\n                zz[c] = true;\n                q.push_back(r[c]);\n                res[c] = {r[c], x};\n            }\n        }\n    }\n\n    if (q.size() < n) {\n        cout << \"-1\\n\";\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            cout << res[i].first + 1 << \" \" << res[i].second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint s[Nmax];\nint n;\nbool unlocked[Nmax];\nvector<int> v[Nmax], w[Nmax];\nvector< pair<int,int> > edges;\n\nclass Graph\n{\n    vector<int> v[Nmax];\n    bool used[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(used[node]) return 0;\n        used[node] = 1;\n\n        for(auto it : v[node])\n            if(!R[it])\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : v[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        v[x].push_back(y);\n    }\n\n    bool cuplaj()\n    {\n        bool done = 1; int i;\n        while(done)\n        {\n            done = 0;\n            for(i=1; i<=n; ++i) used[i] = 0;\n\n            for(i=1; i<=n; ++i)\n                if(!L[i]) done |= cupleaza(i);\n        }\n\n        for(i=1; i<n; ++i)\n        {\n            s[i] = R[i];\n            if(!s[i]) return 0;\n        }\n        return 1;\n    }\n\n} graph;\n\nvoid build_sol()\n{\n    queue<int> q;\n    q.push(n);\n\n    int node;\n    while(q.size())\n    {\n        node = q.front();\n        q.pop();\n\n        for(auto it : w[node])\n            if(!unlocked[s[it]])\n            {\n                q.push(s[it]);\n                unlocked[s[it]] = 1;\n                edges.push_back({node, s[it]});\n            }\n    }\n\n    if(edges.size() != n-1)\n    {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    for(auto e : edges) cout << e.first << ' ' << e.second << '\\n';\n}\n\nint main()\n{\n  ///  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    int i, nr, x;\n    cin >> n;\n    for(i=1; i<n; ++i)\n    {\n        cin >> nr;\n        while(nr--)\n        {\n            cin >> x;\n            v[i].push_back(x);\n            w[x].push_back(i);\n            if(x < n) graph.add_edge(x, i);\n        }\n    }\n\n    if(!graph.cuplaj())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    build_sol();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int inf = (signed) (~0u >> 1);\n\ntypedef class Edge {\n\tpublic:\n\t\tint ed, nx, r;\n\n\t\tEdge() {\t}\n\t\tEdge(int ed, int nx, int r) : ed(ed), nx(nx), r(r) {\t}\n} Edge;\n\ntypedef class MapManager {\n\tpublic:\n\t\tint *h;\n\t\tvector<Edge> E;\n\n\t\tMapManager() {\t}\n\t\tMapManager(int n) {\n\t\t\th = new int[(n + 1)];\n\t\t\tmemset(h, -1, sizeof(int) * (n + 1));\n\t\t}\n\t\t~MapManager() {\n\t\t\tdelete[] h;\n\t\t\tE.clear();\n\t\t}\n\n\t\tvoid add_edge(int u, int v, int r) {\n\t\t\tE.emplace_back(v, h[u], r);\n\t\t\th[u] = (signed) E.size() - 1;\n\t\t}\n\t\tvoid add_arc(int u, int v, int r) {\n\t\t\tadd_edge(u, v, r);\n\t\t\tadd_edge(v, u, 0);\n\t\t}\n\t\tEdge& operator [] (int p) {\n\t\t\treturn E[p];\n\t\t}\n} MapManager;\n\ntypedef class Network {\n\tpublic:\n\t\tint S, T;\n\t\tMapManager g;\n\n\t\tint *d, *h;\n\n\t\tNetwork(int S, int T) : S(S), T(T), g(T) {\n\t\t\td = new int[(T + 1)];\n\t\t\th = new int[(T + 1)];\n\t\t}\n\t\t~Network() {\n\t\t\tdelete[] d;\n\t\t\tdelete[] h;\n\t\t}\n\n\t\tboolean bfs() {\n\t\t\tqueue<int> Q;\n\t\t\tmemset(d, -1, sizeof(int) * (T + 1));\n\t\t\td[S] = 0;\n\t\t\tQ.push(S);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint e = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int i = g.h[e], eu; ~i; i = g[i].nx) {\n\t\t\t\t\teu = g[i].ed;\n\t\t\t\t\tif (!g[i].r || ~d[eu])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\td[eu] = d[e] + 1;\n\t\t\t\t\tQ.push(eu);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn d[T] != -1;\n\t\t}\n\t\t\n\t\tint dfs(int p, int mf) {\n\t\t\tif (p == T || !mf)\n\t\t\t\treturn mf;\n\t\t\tint flow = 0, f;\n\t\t\tfor (int& i = h[p], j, e; ~i; (i != -1) && (i = g[i].nx)) {\n\t\t\t\te = g[i].ed, j = i;\n\t\t\t\tif (g[i].r && d[e] == d[p] + 1 && (f = dfs(e, min(mf, g[i].r))) > 0) {\n\t\t\t\t\tg[j].r -= f;\n\t\t\t\t\tg[j ^ 1].r += f;\n\t\t\t\t\tflow += f;\n\t\t\t\t\tmf -= f;\n\t\t\t\t\tif (!mf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\n\t\tint dinic() {\n\t\t\tint rt = 0;\n\t\t\twhile (bfs()) {\n\t\t\t\tfor (int i = 0; i <= T; i++)\n\t\t\t\t\th[i] = g.h[i];\n\t\t\t\trt += dfs(S, inf);\n\t\t\t}\n\t\t\treturn rt;\n\t\t}\n\n\t\tvoid add_edge(int u, int v, int r) {\n\t\t\tg.add_arc(u, v, r);\n\t\t}\n\n\t\tint find_in_match(int p) {\n\t\t\tfor (int i = g.h[p]; ~i; i = g[i].nx) {\n\t\t\t\tif (!g[i].r) {\n\t\t\t\t\treturn g[i].ed;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n} Network;\n\nconst int N = 1e5 + 5;\n\nint n, T;\nint A[N], B[N];\nboolean vis[N];\nvector<int> S[N], G[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tNetwork network (0, T = 2 * n - 1);\n\tfor (int i = 1; i < n; i++)\n\t\tnetwork.add_edge(0, i, 1);\n\tfor (int i = 1; i < n; i++)\n\t\tnetwork.add_edge(n - 1 + i, T, 1);\n\tfor (int i = 1, k; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tS[i].resize(k);\n\t\tfor (auto& x : S[i]) {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif (x > 1) {\n\t\t\t\tnetwork.add_edge(i, n - 2 + x, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint flow = network.dinic();\n\tif (flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tA[i] = network.find_in_match(i);\n\t\tassert(A[i] >= n);\n\t\tA[i] -= n - 2;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (auto e : S[i]) {\n\t\t\tif (e ^ A[i]) {\n\t\t\t\tG[e].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> Q;\n\tQ.push(1);\n\twhile (!Q.empty()) {\n\t\tint p = Q.front();\n\t\tQ.pop();\n\t\tfor (auto e : G[p]) {\n\t\t\tif (!B[e]) {\n\t\t\t\tB[e] = p;\n\t\t\t\tQ.push(A[e]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tif (!B[i]) {\n\t\t\tputs(\"-1\");\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", A[i], B[i]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false) returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  ll build(int s, int t) {\n    vector< int > level(n);\n    vector< int > colors(n);\n    int color = 1;\n    ll flow = 0;\n    while(++color, bfs(s, level, colors, color), colors[t] == color) {\n      ll newflow = dfs(s, t, inf, level);\n      if(newflow == 0) break;\n      flow += newflow;\n      if(flow >= inf) return inf;\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level, vector<int> & colors, int color) {\n    // fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    colors[s] = color;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(colors[edge.To(i)] != color && edge.Cap(i) > 0) {\n          colors[edge.To(i)] = color;\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e18;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := xを要素に持つグループら\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// メモ：\n// k個のグループにk頂点しか無い場合は自明にループができるので不可\n// よって (k+1) 頂点以上に繋がってていなきゃいけない\n// そのとき k 頂点に必ず繋がっていることになる\n// これは結婚定理と同じ条件なので，必ずn-1本のマッチングが存在することになる\n\n// すると E_i has i を必ず達成できるように番号付けできる\n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} が成り立ってはいけない，と言い換えられる\n// どのような頂点からはじめても，頂点Nにたどり着けなければならない\n// 頂点Nから逆にたどってやって，全てにたどり着けるかだけ調べればいい\n\n// その仮定で，そのDFS木をそのまま構成する木にできる\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][15];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z,int z1)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf,inf);\n\tinsert(S,T,0,inf);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i],inf);insert(i,SS,0,inf);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i],inf);insert(TT,i,0,inf);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j],down[j]);\n\t\t\tinsert(y,i,0,down[j]);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tfor (int i=2;i<=total2;i++)\n\t\t{\n\t\t\tif (v1[i]>=inf) continue;\n\t\t\tint u1=edge[i];\n\t\t\tint u2=edge[i^1];\n\t\t\tif (v1[i]!=0) continue;\n\t\t\tif (u1==S||u2==S) continue;\n\t\t\tif (u1==T||u2==T) continue;\n\t\t\tif (u1<u2)\n\t\t\t{\n\t\t\t\tint t=u1;u1=u2;u2=t;\n\t\t\t}\n\t\t\tif (i==62)\n\t\t\t{\n\t\t\t\tn++;n--;\n\t\t\t}\n\t\t\tif (i%2==0&&v1[i]+v[i^1]==1)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\",u1,u2);\n\t\t\t\tu1=(u1+n-1)%n+1;\n\t\t\t\tu2=(u2+n-1)%n+1;\n\t\t\t\tans[u1][0]++;\n\t\t\t\tans[u1][ans[u1][0]]=u2;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<n;i++) \n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][2]);\n//\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nint lst[200005], to[2000005], pre[2000005], cap[2000005], tot;\nint dep[200005], que[200005], fst[200005];\ninline void add_edge(int u, int v, int _cap)\n{\n\t// printf(\"%d %d %d\\n\", u, v, _cap);\n\tauto add = [&] (int x, int y, int c)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = c;\n\t\tlst[x] = tot++;\n\t};\n\tadd(u, v, _cap);\n\tadd(v, u, 0);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tint he = 0, ta = 0;\n\tque[ta++] = s;\n\twhile (he < ta)\n\t{\n\t\tint u = que[he++];\n\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t{\n\t\t\tif (cap[i] && dep[to[i]] == -1)\n\t\t\t{\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t\tque[ta++] = to[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tint ans = 0;\n\tfor (int i = fst[u]; ~i; i = pre[i])\n\t{\n\t\tif (cap[i] && dep[to[i]] == dep[u] + 1)\n\t\t{\n\t\t\tint res = dfs(to[i], t, std::min(rem - ans, cap[i]));\n\t\t\tcap[i] -= res;\n\t\t\tcap[i ^ 1] += res;\n\t\t\tif (cap[i])\n\t\t\t\tfst[u] = i;\n\t\t\tans += res;\n\t\t\tif (ans == rem)\n\t\t\t\treturn ans;\n\t\t}\n\t}\n\tif (!ans)\n\t\tdep[u] = -1;\n\treturn ans;\n}\ninline int dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t))\n\t{\n\t\tmemcpy(fst, lst, sizeof(lst));\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nstd::vector<int> vec[200005], bel[200005];\nint fa[200005], rep[200005];\nbool vis[200005];\nint add(int u)\n{\n\tint res = 1;\n\tvis[u] = true;\n\tfor (int x : bel[u])\n\t{\n\t\tif (!vis[rep[x]])\n\t\t{\n\t\t\tfa[rep[x]] = u;\n\t\t\tres += add(rep[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC029-F.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint len;\n\t\tscanf(\"%d\", &len);\n\t\twhile (len--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tif (--u)\n\t\t\t\tadd_edge(i + 1, u + n - 1, 1);\n\t\t\tvec[i].pb(u);\n\t\t\tbel[u].pb(i);\n\t\t}\n\t\tadd_edge(0, i + 1, 1);\n\t\tadd_edge(i + n, n + n, 1);\n\t}\n\tif (dinic(0, n + n) != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = lst[i]; ~j; j = pre[j])\n\t\t{\n\t\t\tif (to[j] && !cap[j])\n\t\t\t\trep[i - 1] = to[j] - n + 1;\n\t\t}\n\t}\n\tif (add(0) != n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", fa[i] + 1, i + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define PRINT(x...) TRACE(printf(x))\n#define WATCHR(a, b) TRACE(for (auto c=a; c!=b;) cout << *(c++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define FU(i, a, b) for (auto i = a; i < b; ++i)\n#define fu(i, b) FU(i, 0, b)\n#define FD(i, a, b) for (auto i = (b) - 1; i >= a; --i)\n#define fd(i, b) FD(i, 0, b)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nll mod(ll a, ll b) {\n  return ((a%b)+b)%b;\n}\n\nint cmp(double x, double y = 0, double tol = 1.e-7) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\nstruct graph {\n  vi dest;  // use sz(dest) as number of arcs\n  vvi adj;  // use sz(adj) as number of vertices\n  int inv(int a) { return a ^ 0x1; }\n  graph(int n = 0) {\n    adj.resize(n);\n  }\n  // Adds an arc to the graph. u is capacity, c is cost.\n  // u is only needed on flows, and c only on min-cost-flow\n  int arc(int i, int j, ll u = 1) {\n    dest.pb(j);\n    adj[i].pb(sz(dest)-1);\n    dest.pb(i);\n    adj[j].pb(sz(dest)-1);\n    cap.pb(u); // For both flows\n    cap.pb(0);\n    return sz(dest)-2;\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  // For both flows!!\n  //\n\n  vll cap, flow;\n\n  int orig(int a) { return dest[inv(a)]; }\n  ll capres(int a) { return cap[a] - flow[a]; }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Max Flow! - Dinic O(n^2 * m)\n  // don't call maxflow with ini == end\n  //\n\n  vi curAdj, d;\n\n  bool MFbfs(int s, int t) {\n    d.assign(sz(adj), INT_MAX/2);\n    curAdj = vi(sz(adj));\n    d[s] = 0;\n    queue<int> Q; Q.push(s);\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (auto i : adj[u]) {\n        int v = dest[i];\n        if (capres(i) > 0 && d[v] == INT_MAX/2) {\n          d[v] = d[u] + 1; Q.push(v);\n        }\n      }\n    }\n    return d[t] != INT_MAX/2;\n  }\n\n  ll MFdfs(int u, int t, ll f) {\n    if (u == t) return f;\n    for(int &i = curAdj[u]; i < adj[u].size(); ++i) {\n      int ar = adj[u][i], v = dest[ar];\n      if (d[v] != d[u]+1 || capres(ar) == 0) continue;\n      ll tmpF = MFdfs(v, t, min(f, capres(ar)));\n      if (tmpF) {\n        flow[ar] += tmpF;\n        flow[inv(ar)] -= tmpF;\n        return tmpF;\n      }\n    }\n    return 0;\n  }\n\n  ll maxflow(int ini, int end) {\n    flow.assign(sz(dest), 0);\n    while (MFbfs(ini, end))\n      while (MFdfs(ini, end, LLONG_MAX/2));\n    ll F = 0;\n    for (int a : adj[ini]) F += flow[a];\n    return F;\n  }\n};\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tgraph G(2 * N + 1);\n\tfu(i, N-1) G.arc(0, 1 + i, 1);\n\tfu(i, N) G.arc(N + i, 2 * N, 1);\n\n\tvvi inc(N);\n\tfu(i, N-1) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x); x--;\n\t\t\tG.arc(1 + i, N + x, 1);\n\t\t\tinc[x].push_back(i);\n\t\t}\n\t}\n\n\tif (G.maxflow(0, 2*N) != (N - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\t// find the match of each set\n\tvi match(N-1);\n\tll root = 0;\n\tfu(i, N) root += i;\n\n\tfu(i, N-1) {\n\t\tfor (int a : G.adj[1 + i])\n\t\t\tif (G.flow[a] == 1) {\n\t\t\t\tmatch[i] = G.dest[a] - N;\n\t\t\t\troot -= G.dest[a] - N;\n\t\t\t}\n\t}\n\n\tqueue<int> Q;\n\tQ.push(root);\n\tvb mark(N, false);\n\tmark[root] = true;\n\n\tvector<pair<int, int>> ans;\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\n\t\tfor (int s : inc[x]) {\n\t\t\tint y = match[s];\n\t\t\tif (mark[y]) continue;\n\t\t\tmark[y] = true;\n\t\t\tQ.push(y);\n\t\t\tans.emplace_back(x, y);\n\t\t}\n\t}\n\n\tif (ans.size() != N - 1) printf(\"-1\\n\");\n\telse for (auto p : ans) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Text",
    "code": "これは威圧のための提出です"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDfs(s, t);\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int nextEdge = 0;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDinic(s, t, all.size());\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        boolean bfs(TaskF.Vertex s, TaskF.Vertex t, TaskF.Vertex[] q, int curGen) {\n            int qh = 0, qt = 0;\n            q[qt++] = s;\n            s.generation = curGen;\n            s.dist = 0;\n            while (t.generation < curGen && qh < qt) {\n                TaskF.Vertex v = q[qh++];\n                for (TaskF.Edge e : v.outgo) {\n                    if (e.dest.generation < curGen && e.flow < e.cap) {\n                        e.dest.generation = curGen;\n                        q[qt++] = e.dest;\n                        e.dest.dist = v.dist + 1;\n                    }\n                }\n            }\n            return t.generation == curGen;\n        }\n\n        int maxFlowDinic(TaskF.Vertex s, TaskF.Vertex t, int nv) {\n            int flow = 0;\n            int curGen = 0;\n            TaskF.Vertex[] q = new TaskF.Vertex[nv];\n            for (; ; ) {\n                ++curGen;\n                if (!bfs(s, t, q, curGen)) break;\n                ++curGen;\n                t.markDinic(curGen - 1, curGen);\n                while (true) {\n                    int pushed = s.dfsDinic(t, curGen, INF);\n                    if (pushed == 0) break;\n                    flow += pushed;\n                }\n            }\n            return flow;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int interestingGeneration = 0;\n            int nextEdge = 0;\n            int dist;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            int dfsDinic(TaskF.Vertex t, int curGen, int got) {\n                if (got == 0) return 0;\n                if (this == t) return got;\n                if (interestingGeneration != curGen) return 0;\n                if (generation < curGen) {\n                    generation = curGen;\n                    nextEdge = 0;\n                }\n                for (; nextEdge < outgo.size(); ++nextEdge) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.dest.dist != dist + 1) continue;\n                    int pushed = e.dest.dfs(t, curGen, Math.min(got, e.cap - e.flow));\n                    if (pushed > 0) {\n                        e.flow += pushed;\n                        e.rev.flow -= pushed;\n                        return pushed;\n                    }\n                }\n                return 0;\n            }\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n            public void markDinic(int bfsGen, int curGen) {\n                interestingGeneration = curGen;\n                for (TaskF.Edge e : outgo)\n                    if (e.dest.interestingGeneration < curGen && e.dest.generation == bfsGen && e.dest.dist == dist - 1 && e.rev.flow < e.rev.cap) {\n                        e.dest.markDinic(bfsGen, curGen);\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDinic(s, t, all.size());\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        boolean bfs(TaskF.Vertex s, TaskF.Vertex t, TaskF.Vertex[] q, int curGen) {\n            int qh = 0, qt = 0;\n            q[qt++] = s;\n            s.generation = curGen;\n            s.dist = 0;\n            while (t.generation < curGen && qh < qt) {\n                TaskF.Vertex v = q[qh++];\n                for (TaskF.Edge e : v.outgo) {\n                    if (e.dest.generation < curGen && e.flow < e.cap) {\n                        e.dest.generation = curGen;\n                        q[qt++] = e.dest;\n                        e.dest.dist = v.dist + 1;\n                    }\n                }\n            }\n            return t.generation == curGen;\n        }\n\n        int maxFlowDinic(TaskF.Vertex s, TaskF.Vertex t, int nv) {\n            int flow = 0;\n            int curGen = 0;\n            TaskF.Vertex[] q = new TaskF.Vertex[nv];\n            for (; ; ) {\n                ++curGen;\n                if (!bfs(s, t, q, curGen)) break;\n                ++curGen;\n                t.markDinic(curGen - 1, curGen);\n                while (true) {\n                    int pushed = s.dfsDinic(t, curGen, INF);\n                    if (pushed == 0) break;\n                    flow += pushed;\n                }\n            }\n            return flow;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int interestingGeneration = 0;\n            int nextEdge = 0;\n            int dist;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            int dfsDinic(TaskF.Vertex t, int curGen, int got) {\n                if (got == 0) return 0;\n                if (this == t) return got;\n                if (interestingGeneration != curGen) return 0;\n                if (generation < curGen) {\n                    generation = curGen;\n                    nextEdge = 0;\n                }\n                for (; nextEdge < outgo.size(); ++nextEdge) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.dest.dist != dist + 1) continue;\n                    int pushed = e.dest.dfs(t, curGen, Math.min(got, e.cap - e.flow));\n                    if (pushed > 0) {\n                        e.flow += pushed;\n                        e.rev.flow -= pushed;\n                        return pushed;\n                    }\n                }\n                return 0;\n            }\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n            public void markDinic(int bfsGen, int curGen) {\n                interestingGeneration = curGen;\n                for (TaskF.Edge e : outgo)\n                    if (e.dest.interestingGeneration < curGen && e.dest.generation == bfsGen && e.dest.dist == dist - 1 && e.rev.flow < e.rev.cap) {\n                        e.dest.markDinic(bfsGen, curGen);\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\t\n\tList<Integer>[] where;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint[][] a = new int[n - 1][];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint k = nextInt();\n\t\t\ta[i] = new int[k];\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\ta[i][j] = nextInt() - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhere = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhere[i] = new ArrayList<>();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\twhere[v].add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFlowGraph g = new FlowGraph(2 * n + 1, 2 * n - 1, 2 * n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.addDirectedEdge(g.S, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tg.addDirectedEdge(i + n, g.T, 1);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\tg.addDirectedEdge(v, i + n, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (g.maxFlow() != n - 1) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmatch = new int[n - 1];\n\t\t\n\t\tArrays.fill(match, -1);\n\t\tint src = -1;\n\t\touter: for (int i = 0; i < n; i++) {\n\t\t\tfor (FlowEdge e : g.g[i]) {\n\t\t\t\tif (e.flow == 1) {\n\t\t\t\t\tmatch[e.to - n] = i;\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsrc = i;\n\t\t}\n\t\t\n\t\tvis1 = new boolean[n];\n\t\tvis2 = new boolean[n];\n\t\tdfs(src);\n\t\t\n\t\tif (ans.size() == 2 * n - 2) {\n\t\t\tfor (int i = 0; i < ans.size(); i += 2) {\n\t\t\t\tout.println((ans.get(i) + 1) + \" \" + (ans.get(i + 1) + 1));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tout.println(-1);\n\t}\n\t\n\tboolean[] vis1, vis2;\n\tint[] match;\n\t\n\tList<Integer> ans = new ArrayList<>();\n\t\n\tvoid dfs(int v) {\n\t\tvis1[v] = true;\n\t\tfor (int u : where[v]) {\n\t\t\tif (vis2[u]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis2[u] = true;\n\t\t\tif (vis1[match[u]]) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tans.add(v);\n\t\t\tans.add(match[u]);\n\t\t\tdfs(match[u]);\n\t\t}\n\t}\n\t\n\tstatic class FlowGraph {\n\t\tint N, S, T;\n\t\tstatic final int INF = Integer.MAX_VALUE / 3;\n\n\t\tList<FlowEdge>[] g;\n\n\t\tprivate int[] dist;\n\t\tprivate Deque<Integer> q;\n\t\tprivate int[] ptr;\n\n\t\tpublic FlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tdist = new int[N];\n\t\t\tq = new ArrayDeque<>();\n\t\t\tptr = new int[N];\n\t\t}\n\n\t\tpublic void addDirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, 0);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tpublic void addUndirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, cap);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tprivate boolean bfs() {\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[S] = 0;\n\t\t\tq.clear();\n\t\t\tq.add(S);\n\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint v = q.poll();\n\t\t\t\tList<FlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow < e.cap && dist[e.to] > dist[v] + 1) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\t\tq.add(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist[T] != INF;\n\t\t}\n\n\t\tprivate int dfs(int v, int curFlow) {\n\t\t\tif (v == T)\n\t\t\t\treturn curFlow;\n\t\t\tList<FlowEdge> adj = g[v];\n\t\t\tfor (; ptr[v] < adj.size(); ptr[v]++) {\n\t\t\t\tFlowEdge e = adj.get(ptr[v]);\n\t\t\t\tif (dist[e.to] == dist[v] + 1 && e.flow != e.cap) {\n\t\t\t\t\tint go = dfs(e.to, Math.min(curFlow, e.cap - e.flow));\n\t\t\t\t\tif (go != 0) {\n\t\t\t\t\t\te.flow += go;\n\t\t\t\t\t\te.rev.flow -= go;\n\t\t\t\t\t\treturn go;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic int maxFlow() {\n\t\t\tint flow = 0;\n\n\t\t\twhile (bfs()) {\n\t\t\t\tArrays.fill(ptr, 0);\n\t\t\t\tint addFlow;\n\t\t\t\tdo {\n\t\t\t\t\taddFlow = dfs(S, INF);\n\t\t\t\t\tflow += addFlow;\n\t\t\t\t} while (addFlow > 0);\n\t\t\t}\n\n\t\t\treturn flow;\n\t\t}\n\n\t}\n\n\tstatic class FlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tFlowEdge rev;\n\n\t\tpublic FlowEdge(int to, int cap) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t}\n\t}\n\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tList<Integer>[] where;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint[][] a = new int[n - 1][];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint k = nextInt();\n\t\t\ta[i] = new int[k];\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\ta[i][j] = nextInt() - 1;\n\t\t\t}\n\t\t}\n\n\t\twhere = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhere[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\twhere[v].add(i);\n\t\t\t}\n\t\t}\n\n\t\tFlowGraph g = new FlowGraph(2 * n + 1, 2 * n - 1, 2 * n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.addDirectedEdge(g.S, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tg.addDirectedEdge(i + n, g.T, 1);\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\tg.addDirectedEdge(v, i + n, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (g.maxFlow() != n - 1) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\n\t\tmatch = new int[n - 1];\n\n\t\tArrays.fill(match, -1);\n\t\tint src = -1;\n\t\touter: for (int i = 0; i < n; i++) {\n\t\t\tfor (FlowEdge e : g.g[i]) {\n\t\t\t\tif (e.flow == 1) {\n\t\t\t\t\tmatch[e.to - n] = i;\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsrc = i;\n\t\t}\n\n\t\tvis1 = new boolean[n];\n\t\tvis2 = new boolean[n];\n\n\t\tans = new int[2 * n - 2];\n\t\tArrays.fill(ans, -1);\n\n\t\tdfs(src);\n\n\t\tif (Arrays.stream(ans).anyMatch(x -> x == -1)) {\n\t\t\tout.println(-1);\n\t\t} else {\n\t\t\tfor (int i = 0; i < ans.length; i += 2) {\n\t\t\t\tout.println((ans[i] + 1) + \" \" + (ans[i + 1] + 1));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean[] vis1, vis2;\n\tint[] match;\n\n\tint[] ans;\n\n\tvoid dfs(int v) {\n\t\tvis1[v] = true;\n\t\tfor (int u : where[v]) {\n\t\t\tif (vis2[u]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis2[u] = true;\n\t\t\tif (vis1[match[u]]) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tans[2 * u] = v;\n\t\t\tans[2 * u + 1] = match[u];\n\t\t\tdfs(match[u]);\n\t\t}\n\t}\n\n\tstatic class FlowGraph {\n\t\tint N, S, T;\n\t\tstatic final int INF = Integer.MAX_VALUE / 3;\n\n\t\tList<FlowEdge>[] g;\n\n\t\tprivate int[] dist;\n\t\tprivate Deque<Integer> q;\n\t\tprivate int[] ptr;\n\n\t\tpublic FlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tdist = new int[N];\n\t\t\tq = new ArrayDeque<>();\n\t\t\tptr = new int[N];\n\t\t}\n\n\t\tpublic void addDirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, 0);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tpublic void addUndirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, cap);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tprivate boolean bfs() {\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[S] = 0;\n\t\t\tq.clear();\n\t\t\tq.add(S);\n\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint v = q.poll();\n\t\t\t\tList<FlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow < e.cap && dist[e.to] > dist[v] + 1) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\t\tq.add(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist[T] != INF;\n\t\t}\n\n\t\tprivate int dfs(int v, int curFlow) {\n\t\t\tif (v == T)\n\t\t\t\treturn curFlow;\n\t\t\tList<FlowEdge> adj = g[v];\n\t\t\tfor (; ptr[v] < adj.size(); ptr[v]++) {\n\t\t\t\tFlowEdge e = adj.get(ptr[v]);\n\t\t\t\tif (dist[e.to] == dist[v] + 1 && e.flow != e.cap) {\n\t\t\t\t\tint go = dfs(e.to, Math.min(curFlow, e.cap - e.flow));\n\t\t\t\t\tif (go != 0) {\n\t\t\t\t\t\te.flow += go;\n\t\t\t\t\t\te.rev.flow -= go;\n\t\t\t\t\t\treturn go;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic int maxFlow() {\n\t\t\tint flow = 0;\n\n\t\t\twhile (bfs()) {\n\t\t\t\tArrays.fill(ptr, 0);\n\t\t\t\tint addFlow;\n\t\t\t\tdo {\n\t\t\t\t\taddFlow = dfs(S, INF);\n\t\t\t\t\tflow += addFlow;\n\t\t\t\t} while (addFlow > 0);\n\t\t\t}\n\n\t\t\treturn flow;\n\t\t}\n\n\t}\n\n\tstatic class FlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tFlowEdge rev;\n\n\t\tpublic FlowEdge(int to, int cap) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t}\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDfs(s, t);\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int nextEdge = 0;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FConstructionOfATree solver = new FConstructionOfATree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FConstructionOfATree {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[][] w = new int[n - 1][];\n            for (int i = 0; i < n - 1; i++) {\n                w[i] = in.readIntArray(in.readInt());\n            }\n            MiscUtils.decreaseByOne(w);\n            Graph graph = new Graph(2 * n);\n            int source = n - 1;\n            int sink = n;\n            for (int i = 0; i < n - 1; i++) {\n                graph.addFlowEdge(source, i, 1);\n                for (int j : w[i]) {\n                    if (j != 0) {\n                        graph.addFlowEdge(i, n + j, 1);\n                    }\n                }\n                graph.addFlowEdge(n + 1 + i, sink, 1);\n            }\n            long flow = MaxFlow.dinic(graph, source, sink);\n            if (flow != n - 1) {\n                out.printLine(-1);\n                return;\n            }\n            int[] vertex = new int[n - 1];\n            for (int i = 0; i < graph.edgeCount(); i++) {\n                if (graph.flow(i) == 1 && graph.source(i) < n - 1 && graph.destination(i) > n) {\n                    vertex[graph.source(i)] = graph.destination(i) - n;\n                }\n            }\n            int[][] answer = new int[n - 1][2];\n            IntList[] connected = new IntList[n];\n            for (int i = 0; i < n; i++) {\n                connected[i] = new IntArrayList(1);\n            }\n            for (int i = 0; i < n - 1; i++) {\n                for (int j : w[i]) {\n                    connected[j].add(i);\n                }\n            }\n            int[] queue = new int[n];\n            boolean[] done = new boolean[n - 1];\n            int size = 1;\n            for (int i = 0; i < size; i++) {\n                int current = queue[i];\n                for (int j : connected[current]) {\n                    if (!done[j]) {\n                        done[j] = true;\n                        queue[size++] = vertex[j];\n                        answer[j][0] = current + 1;\n                        answer[j][1] = vertex[j] + 1;\n                    }\n                }\n            }\n            if (size < n) {\n                out.printLine(-1);\n                return;\n            }\n            for (int[] row : answer) {\n                out.printLine(row);\n            }\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public boolean isEmpty() {\n            return size() == 0;\n        }\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntQueue extends IntCollection {\n        public int poll();\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static class IntArrayQueue implements IntQueue {\n        private int[] data;\n        private int from;\n        private int to;\n\n        public IntArrayQueue(int capacity) {\n            data = new int[Integer.highestOneBit(capacity) << 1];\n        }\n\n        public IntArrayQueue() {\n            this(3);\n        }\n\n        public IntArrayQueue(int[] array) {\n            this(array.length);\n            to = array.length;\n            System.arraycopy(array, 0, data, 0, to);\n        }\n\n        public IntArrayQueue(IntStream s) {\n            addAll(s);\n        }\n\n        public IntArrayQueue(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public int size() {\n            return (to - from) & (data.length - 1);\n        }\n\n        public void add(int v) {\n            ensureCapacity(size() + 1);\n            data[to++] = v;\n            to &= data.length - 1;\n        }\n\n        public int poll() {\n            if (from == to) {\n                throw new NoSuchElementException();\n            }\n            int result = data[from++];\n            from &= data.length - 1;\n            return result;\n        }\n\n        public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at = from;\n\n                public int value() {\n                    if (at == to) {\n                        throw new NoSuchElementException();\n                    }\n                    return data[at];\n                }\n\n                public boolean advance() {\n                    if (!isValid()) {\n                        throw new NoSuchElementException();\n                    }\n                    at++;\n                    at &= data.length - 1;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return at != to;\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n            };\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length <= capacity) {\n                int[] newData = new int[Integer.highestOneBit(capacity) << 1];\n                if (from <= to) {\n                    System.arraycopy(data, from, newData, 0, size());\n                } else {\n                    System.arraycopy(data, from, newData, 0, data.length - from);\n                    System.arraycopy(data, 0, newData, data.length - from, to);\n                }\n                to = size();\n                from = 0;\n                data = newData;\n            }\n        }\n\n    }\n\n    static interface Edge {\n    }\n\n    static class Graph {\n        public static final int REMOVED_BIT = 0;\n        protected int vertexCount;\n        protected int edgeCount;\n        private int[] firstOutbound;\n        private int[] firstInbound;\n        private Edge[] edges;\n        private int[] nextInbound;\n        private int[] nextOutbound;\n        private int[] from;\n        private int[] to;\n        private long[] weight;\n        public long[] capacity;\n        private int[] reverseEdge;\n        private int[] flags;\n\n        public Graph(int vertexCount) {\n            this(vertexCount, vertexCount);\n        }\n\n        public Graph(int vertexCount, int edgeCapacity) {\n            this.vertexCount = vertexCount;\n            firstOutbound = new int[vertexCount];\n            Arrays.fill(firstOutbound, -1);\n\n            from = new int[edgeCapacity];\n            to = new int[edgeCapacity];\n            nextOutbound = new int[edgeCapacity];\n            flags = new int[edgeCapacity];\n        }\n\n        public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {\n            ensureEdgeCapacity(edgeCount + 1);\n            if (firstOutbound[fromID] != -1) {\n                nextOutbound[edgeCount] = firstOutbound[fromID];\n            } else {\n                nextOutbound[edgeCount] = -1;\n            }\n            firstOutbound[fromID] = edgeCount;\n            if (firstInbound != null) {\n                if (firstInbound[toID] != -1) {\n                    nextInbound[edgeCount] = firstInbound[toID];\n                } else {\n                    nextInbound[edgeCount] = -1;\n                }\n                firstInbound[toID] = edgeCount;\n            }\n            this.from[edgeCount] = fromID;\n            this.to[edgeCount] = toID;\n            if (capacity != 0) {\n                if (this.capacity == null) {\n                    this.capacity = new long[from.length];\n                }\n                this.capacity[edgeCount] = capacity;\n            }\n            if (weight != 0) {\n                if (this.weight == null) {\n                    this.weight = new long[from.length];\n                }\n                this.weight[edgeCount] = weight;\n            }\n            if (reverseEdge != -1) {\n                if (this.reverseEdge == null) {\n                    this.reverseEdge = new int[from.length];\n                    Arrays.fill(this.reverseEdge, 0, edgeCount, -1);\n                }\n                this.reverseEdge[edgeCount] = reverseEdge;\n            }\n            if (edges != null) {\n                edges[edgeCount] = createEdge(edgeCount);\n            }\n            return edgeCount++;\n        }\n\n        protected final GraphEdge createEdge(int id) {\n            return new GraphEdge(id);\n        }\n\n        public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {\n            if (capacity == 0) {\n                return addEdge(from, to, weight, 0, -1);\n            } else {\n                int lastEdgeCount = edgeCount;\n                addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());\n                return addEdge(from, to, weight, capacity, lastEdgeCount);\n            }\n        }\n\n        protected int entriesPerEdge() {\n            return 1;\n        }\n\n        public final int addFlowEdge(int from, int to, long capacity) {\n            return addFlowWeightedEdge(from, to, 0, capacity);\n        }\n\n        public final int vertexCount() {\n            return vertexCount;\n        }\n\n        public final int edgeCount() {\n            return edgeCount;\n        }\n\n        public final int firstOutbound(int vertex) {\n            int id = firstOutbound[vertex];\n            while (id != -1 && isRemoved(id)) {\n                id = nextOutbound[id];\n            }\n            return id;\n        }\n\n        public final int nextOutbound(int id) {\n            id = nextOutbound[id];\n            while (id != -1 && isRemoved(id)) {\n                id = nextOutbound[id];\n            }\n            return id;\n        }\n\n        public final int source(int id) {\n            return from[id];\n        }\n\n        public final int destination(int id) {\n            return to[id];\n        }\n\n        public final long capacity(int id) {\n            if (capacity == null) {\n                return 0;\n            }\n            return capacity[id];\n        }\n\n        public final long flow(int id) {\n            if (reverseEdge == null) {\n                return 0;\n            }\n            return capacity[reverseEdge[id]];\n        }\n\n        public final void pushFlow(int id, long flow) {\n            if (flow == 0) {\n                return;\n            }\n            if (flow > 0) {\n                if (capacity(id) < flow) {\n                    throw new IllegalArgumentException(\"Not enough capacity\");\n                }\n            } else {\n                if (flow(id) < -flow) {\n                    throw new IllegalArgumentException(\"Not enough capacity\");\n                }\n            }\n            capacity[id] -= flow;\n            capacity[reverseEdge[id]] += flow;\n        }\n\n        public final boolean flag(int id, int bit) {\n            return (flags[id] >> bit & 1) != 0;\n        }\n\n        public final boolean isRemoved(int id) {\n            return flag(id, REMOVED_BIT);\n        }\n\n        protected void ensureEdgeCapacity(int size) {\n            if (from.length < size) {\n                int newSize = Math.max(size, 2 * from.length);\n                if (edges != null) {\n                    edges = resize(edges, newSize);\n                }\n                from = resize(from, newSize);\n                to = resize(to, newSize);\n                nextOutbound = resize(nextOutbound, newSize);\n                if (nextInbound != null) {\n                    nextInbound = resize(nextInbound, newSize);\n                }\n                if (weight != null) {\n                    weight = resize(weight, newSize);\n                }\n                if (capacity != null) {\n                    capacity = resize(capacity, newSize);\n                }\n                if (reverseEdge != null) {\n                    reverseEdge = resize(reverseEdge, newSize);\n                }\n                flags = resize(flags, newSize);\n            }\n        }\n\n        protected final int[] resize(int[] array, int size) {\n            int[] newArray = new int[size];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            return newArray;\n        }\n\n        private long[] resize(long[] array, int size) {\n            long[] newArray = new long[size];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            return newArray;\n        }\n\n        private Edge[] resize(Edge[] array, int size) {\n            Edge[] newArray = new Edge[size];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            return newArray;\n        }\n\n        protected class GraphEdge implements Edge {\n            protected int id;\n\n            protected GraphEdge(int id) {\n                this.id = id;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n    }\n\n    static class MaxFlow {\n        private final Graph graph;\n        private int source;\n        private int destination;\n        private IntQueue queue;\n        private int[] distance;\n        private int[] nextEdge;\n\n        public MaxFlow(Graph graph, int source, int destination) {\n            this.graph = graph;\n            this.source = source;\n            this.destination = destination;\n            int vertexCount = graph.vertexCount();\n            queue = new IntArrayQueue(vertexCount);\n            distance = new int[vertexCount];\n            nextEdge = new int[vertexCount];\n        }\n\n        public static long dinic(Graph graph, int source, int destination) {\n            return new MaxFlow(graph, source, destination).dinic();\n        }\n\n        public long dinic() {\n            long totalFlow = 0;\n            while (true) {\n                edgeDistances();\n                if (distance[destination] == -1) {\n                    break;\n                }\n                Arrays.fill(nextEdge, -2);\n                totalFlow += dinicImpl(source, Long.MAX_VALUE);\n            }\n            return totalFlow;\n        }\n\n        private void edgeDistances() {\n            Arrays.fill(distance, -1);\n            distance[source] = 0;\n            queue.add(source);\n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                int id = graph.firstOutbound(current);\n                while (id != -1) {\n                    if (graph.capacity(id) != 0) {\n                        int next = graph.destination(id);\n                        if (distance[next] == -1) {\n                            distance[next] = distance[current] + 1;\n                            queue.add(next);\n                        }\n                    }\n                    id = graph.nextOutbound(id);\n                }\n            }\n        }\n\n        private long dinicImpl(int source, long flow) {\n            if (source == destination) {\n                return flow;\n            }\n            if (flow == 0 || distance[source] == distance[destination]) {\n                return 0;\n            }\n            int id = nextEdge[source];\n            if (id == -2) {\n                nextEdge[source] = id = graph.firstOutbound(source);\n            }\n            long totalPushed = 0;\n            while (id != -1) {\n                int nextDestinationID = graph.destination(id);\n                if (graph.capacity(id) != 0 && distance[nextDestinationID] == distance[source] + 1) {\n                    long pushed = dinicImpl(nextDestinationID, Math.min(flow, graph.capacity(id)));\n                    if (pushed != 0) {\n                        graph.pushFlow(id, pushed);\n                        flow -= pushed;\n                        totalPushed += pushed;\n                        if (flow == 0) {\n                            return totalPushed;\n                        }\n                    }\n                }\n                nextEdge[source] = id = graph.nextOutbound(id);\n            }\n            return totalPushed;\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final long INF = (long) 1e18;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, long cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            long flow = maxFlowDinic(s, t, all.size());\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private long maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            long res = 0;\n            while (true) {\n                ++curGen;\n                long by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        boolean bfs(TaskF.Vertex s, TaskF.Vertex t, TaskF.Vertex[] q, int curGen) {\n            int qh = 0, qt = 0;\n            q[qt++] = s;\n            s.generation = curGen;\n            s.dist = 0;\n            while (t.generation < curGen && qh < qt) {\n                TaskF.Vertex v = q[qh++];\n                for (TaskF.Edge e : v.outgo) {\n                    if (e.dest.generation < curGen && e.flow < e.cap) {\n                        e.dest.generation = curGen;\n                        q[qt++] = e.dest;\n                        e.dest.dist = v.dist + 1;\n                    }\n                }\n            }\n            return t.generation == curGen;\n        }\n\n        long maxFlowDinic(TaskF.Vertex s, TaskF.Vertex t, int nv) {\n            long flow = 0;\n            int curGen = 0;\n            TaskF.Vertex[] q = new TaskF.Vertex[nv];\n            for (; ; ) {\n                ++curGen;\n                if (!bfs(s, t, q, curGen)) break;\n                ++curGen;\n                t.markDinic(curGen - 1, curGen);\n                while (true) {\n                    long pushed = s.dfsDinic(t, curGen, INF);\n                    if (pushed == 0) break;\n                    flow += pushed;\n                }\n            }\n            return flow;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            long cap = 0;\n            long flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int interestingGeneration = 0;\n            int nextEdge = 0;\n            int dist;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            long dfsDinic(TaskF.Vertex t, int curGen, long got) {\n                if (got == 0) return 0;\n                if (this == t) return got;\n                if (interestingGeneration != curGen) return 0;\n                if (generation < curGen) {\n                    generation = curGen;\n                    nextEdge = 0;\n                }\n                for (; nextEdge < outgo.size(); ++nextEdge) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.dest.dist != dist + 1) continue;\n                    long pushed = e.dest.dfs(t, curGen, Math.min(got, e.cap - e.flow));\n                    if (pushed > 0) {\n                        e.flow += pushed;\n                        e.rev.flow -= pushed;\n                        return pushed;\n                    }\n                }\n                return 0;\n            }\n\n            public long dfs(TaskF.Vertex t, int curGen, long max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        long nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n            public void markDinic(int bfsGen, int curGen) {\n                interestingGeneration = curGen;\n                for (TaskF.Edge e : outgo)\n                    if (e.dest.interestingGeneration < curGen && e.dest.generation == bfsGen && e.dest.dist == dist - 1 && e.rev.flow < e.rev.cap) {\n                        e.dest.markDinic(bfsGen, curGen);\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Awk",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "$debug = false\ndef d(*s)\n  pp *s if $debug == true\nend\n\nN = readline.to_i\n\nES = (N-1).times.map do |i|\n  readline.split(' ')[1..-1].map(&:to_i)\nend\n\nd ES\n\n\ndef search(nodes, sets)\n  d \"nodes: #{nodes}, sets: #{sets}\"\n  raise unless nodes.size-1 == sets.size\n  if nodes.size == 2\n    s = ES[sets[0]]\n    if s.include?(nodes[0]) and s.include?(nodes[1])\n      return [ nodes ]\n    else\n      return nil\n    end\n  elsif nodes.size > 2\n    node_to_sets = construct_node_to_sets(nodes,sets)\n    d \"node_to_sets: #{node_to_sets.inspect}\"\n    node_to_sets.each do |node,ss|\n      d \"node: #{node}\"\n      ss.each do |s|\n        next if node == s\n        raise unless sets.include?(s)\n        s2 = sets - [s]\n        d \"s: #{s}, s2: #{s2}\"\n        found = search( nodes-[node], s2 )\n        d \"found : #{found.inspect}\"\n        if found\n          other = ES[s].find {|x| x != node and nodes.include?(x)}\n          found.push([node,other])\n          return found\n        else\n          return nil\n        end\n      end\n    end\n  else\n    raise \"must not happen\"\n  end\nend\n\ndef construct_node_to_sets(nodes, sets)\n  h = Hash.new { [] }\n  sets.each do |i|\n    ES[i].each do |n|\n      h[n] += [i] if nodes.include?(n)\n    end\n  end\n  h.sort_by {|k,v| v.size}\nend\n\n#pp node_eis\nnodes = (1..N).to_a\nsets = (0...ES.size).to_a\n\nd nodes, sets\ntree = search(nodes, sets)\nif tree\n  puts tree.map {|x| x.join(' ')}\nelse\n  puts -1\nend\n"
  },
  {
    "language": "Ruby",
    "code": "$debug = false\ndef d(*s)\n  pp *s if $debug == true\nend\n\nN = readline.to_i\n\nES = (N-1).times.map do |i|\n  readline.split(' ')[1..-1].map(&:to_i)\nend\n\n$memo = {}\n\ndef memo_key(nodes,sets)\n  nodes.join('-') + ',' + sets.join('-')\nend\n\ndef search(nodes, sets)\n  mem_key = memo_key(nodes,sets)\n  if $memo[mem_key]\n    return $memo[mem_key]\n  end\n\n  raise unless nodes.size-1 == sets.size\n  if nodes.size == 2\n    s = ES[sets[0]]\n    if s.include?(nodes[0]) and s.include?(nodes[1])\n      $memo[mem_key] = [nodes]\n      return [ nodes ]\n    else\n      $memo[mem_key] = nil\n      return nil\n    end\n  elsif nodes.size > 2\n    node_to_sets = construct_node_to_sets(nodes,sets)\n    node_to_sets.each do |node,ss|\n      ss.each do |s|\n        next if node == s\n        raise unless sets.include?(s)\n        s2 = sets - [s]\n        found = search( nodes-[node], s2 )\n        if found\n          other = ES[s].find {|x| x != node and nodes.include?(x)}\n          found.push([node,other])\n          $memo[mem_key] = found\n          return found\n        end\n      end\n      $memo[mem_key] = nil\n      return nil\n    end\n  else\n    raise \"must not happen\"\n  end\nend\n\ndef construct_node_to_sets(nodes, sets)\n  h = Hash.new { [] }\n  sets.each do |i|\n    ES[i].each do |n|\n      h[n] += [i] if nodes.include?(n)\n    end\n  end\n  h.sort_by {|k,v| v.size}\nend\n\n#pp node_eis\nnodes = (1..N).to_a\nsets = (0...ES.size).to_a\n\ntree = search(nodes, sets)\nif tree\n  puts tree.map {|x| x.join(' ')}\nelse\n  puts -1\nend\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n方針:頂点1とすべてつなげたい\n→1が入ってる場合、1 & ナニカを選べばいい\n→そうでない場合、既に選択済み & 新規点を選べばよい\n\n小さい集合から選択するべき論はそうかも\n→むしろ登場回数が少ない頂点から選択するべき？\n\n→登場回数が2回の頂点2つがある\n→互いの選択で影響しあうのは重なってる場合\n\n各集合で取るより1から遠い点は残りの集合の中での登場回数がすくない点から貪欲に？\n→おｋそう\n\nあとはこれでループが生まれないことを証明\n→おｋ\n\n\"\"\"\n\n#一転更新区間取得のセグ木とRMQである(最大取得したいなら負で突っ込めばおｋ？)\n#query区間左,右は実際に求めたい区間(半開区間なので右は+1しておくこと)\n#注目ノード番号は0でOK\n#担当範囲左,担当範囲右　は、それぞれ　0 , (len(セグ木)+1)//2 にしておくこと\n\ndef make_ST(n,first): #firstで初期化された、葉がn要素を超えるように2のべき乗個用意されたリストを返す\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #葉のindex(0-origin)がpointの要素をnumにする/treeはセグ木\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query区間左,右,注目ノード番号,担当範囲左,担当範囲右,木\n\n    if r <= a or b <= l: #区間が完全にかぶらない場合inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #区間が完全に含まれる場合自分\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n            \n"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nfrom sys import stdin\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n            \n\n\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #頂点から属す集合を逆引き\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#二部マッチングを求める　集合N-1個と数字N-1個をマッチング\n#フロー始点を0,終点をNにしよう\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n方針:頂点1とすべてつなげたい\n→1が入ってる場合、1 & ナニカを選べばいい\n→そうでない場合、既に選択済み & 新規点を選べばよい\n\n小さい集合から選択するべき論はそうかも\n→むしろ登場回数が少ない頂点から選択するべき？\n\n→登場回数が2回の頂点2つがある\n→互いの選択で影響しあうのは重なってる場合\n\n各集合で取るより1から遠い点は残りの集合の中での登場回数がすくない点から貪欲に？\n→おｋそう\n\nあとはこれでループが生まれないことを証明\n→おｋ\n\nまずいのは、選択によって不可能集合を作ってしまうこと\n\n=====再挑戦=====\n\n方針は、1が入ってるやつは 1&ナニカを選ぶ\nそれ以外は新規を選ぶ\n→マッチング\n→dinicなら高速に行ける\n\n\"\"\"\n\nfrom sys import stdin\n\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level,cap):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v] and (nex not in cap[v]):\n\n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level,cap)\n            if plusflow == 0:\n                cap[v].add(nex)\n                continue\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n\n            return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        cap = [set() for i in range(N)]\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level,cap)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level,cap)\n            \n\n\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #頂点から属す集合を逆引き\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#二部マッチングを求める　集合N-1個と数字N-1個をマッチング\n#フロー始点を0,終点をNにしよう\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\n\n\"\"\"\n#一転更新区間取得のセグ木とRMQである(最大取得したいなら負で突っ込めばおｋ？)\n#query区間左,右は実際に求めたい区間(半開区間なので右は+1しておくこと)\n#注目ノード番号は0でOK\n#担当範囲左,担当範囲右　は、それぞれ　0 , (len(セグ木)+1)//2 にしておくこと\n\ndef make_ST(n,first): #firstで初期化された、葉がn要素を超えるように2のべき乗個用意されたリストを返す\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #葉のindex(0-origin)がpointの要素をnumにする/treeはセグ木\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query区間左,右,注目ノード番号,担当範囲左,担当範囲右,木\n\n    if r <= a or b <= l: #区間が完全にかぶらない場合inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #区間が完全に含まれる場合自分\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n\n#ansにそれぞれの集合からどれを取るかを入れればいい\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\"\"\"\n            \n"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nfrom sys import stdin\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n            \n\n\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #頂点から属す集合を逆引き\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#二部マッチングを求める　集合N-1個と数字N-1個をマッチング\n#フロー始点を0,終点をNにしよう\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n方針:頂点1とすべてつなげたい\n→1が入ってる場合、1 & ナニカを選べばいい\n→そうでない場合、既に選択済み & 新規点を選べばよい\n\n小さい集合から選択するべき論はそうかも\n→むしろ登場回数が少ない頂点から選択するべき？\n\n→登場回数が2回の頂点2つがある\n→互いの選択で影響しあうのは重なってる場合\n\n各集合で取るより1から遠い点は残りの集合の中での登場回数がすくない点から貪欲に？\n→おｋそう\n\nあとはこれでループが生まれないことを証明\n→おｋ\n\nまずいのは、選択によって不可能集合を作ってしまうこと\n\n=====再挑戦=====\n\n方針は、1が入ってるやつは 1&ナニカを選ぶ\nそれ以外は新規を選ぶ\n→マッチング\n→dinicなら高速に行ける\n\n\"\"\"\n\nfrom collections import defaultdict\nfrom collections import deque\n\ndef Ford_Fulkerson_Func(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n    queue = deque([ [s,float(\"inf\")] ])\n\n    ed = [True] * N\n    ed[s] = False\n\n    route = [0] * N\n    route[s] = -1\n\n    while queue:\n\n        now,flow = queue.pop()\n        for nex in lines[now]:\n\n            if ed[nex]: \n                flow = min(cost[now][nex],flow)\n                route[nex] = now\n                queue.append([nex,flow])\n                ed[nex] = False\n\n                if nex == g:\n                    ans += flow\n                    break\n            \n        else:\n            continue\n        break\n\n    else:\n        return False,ans\n\n\n    t = g\n    s = route[t]\n\n    while s != -1:\n        cost[s][t] -= flow\n        if cost[s][t] == 0:\n            lines[s].remove(t)\n\n        if cost[t][s] == 0:\n            lines[t].add(s)\n        cost[t][s] += flow\n        t = s\n        s = route[t]\n\n    return True,ans\n\ndef Ford_Fulkerson(s,g,lines,cost):\n\n    ans = 0\n\n    while True:\n        fl,nans = Ford_Fulkerson_Func(s,g,lines,cost)\n\n        if fl:\n            ans += nans\n            continue\n        else:\n            break\n    \n    return ans\n\nimport sys\nfrom sys import stdin\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #頂点から属す集合を逆引き\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#二部マッチングを求める　集合N-1個と数字N-1個をマッチング\n#フロー始点を0,終点をNにしよう\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Ford_Fulkerson(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\n\n\"\"\"\n#一転更新区間取得のセグ木とRMQである(最大取得したいなら負で突っ込めばおｋ？)\n#query区間左,右は実際に求めたい区間(半開区間なので右は+1しておくこと)\n#注目ノード番号は0でOK\n#担当範囲左,担当範囲右　は、それぞれ　0 , (len(セグ木)+1)//2 にしておくこと\n\ndef make_ST(n,first): #firstで初期化された、葉がn要素を超えるように2のべき乗個用意されたリストを返す\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #葉のindex(0-origin)がpointの要素をnumにする/treeはセグ木\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query区間左,右,注目ノード番号,担当範囲左,担当範囲右,木\n\n    if r <= a or b <= l: #区間が完全にかぶらない場合inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #区間が完全に含まれる場合自分\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n\n#ansにそれぞれの集合からどれを取るかを入れればいい\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\"\"\"\n            \n\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n方針:頂点1とすべてつなげたい\n→1が入ってる場合、1 & ナニカを選べばいい\n→そうでない場合、既に選択済み & 新規点を選べばよい\n\n小さい集合から選択するべき論はそうかも\n→むしろ登場回数が少ない頂点から選択するべき？\n\n→登場回数が2回の頂点2つがある\n→互いの選択で影響しあうのは重なってる場合\n\n各集合で取るより1から遠い点は残りの集合の中での登場回数がすくない点から貪欲に？\n→おｋそう\n\nあとはこれでループが生まれないことを証明\n→おｋ\n\n\"\"\"\n\n#一転更新区間取得のセグ木とRMQである(最大取得したいなら負で突っ込めばおｋ？)\n#query区間左,右は実際に求めたい区間(半開区間なので右は+1しておくこと)\n#注目ノード番号は0でOK\n#担当範囲左,担当範囲右　は、それぞれ　0 , (len(セグ木)+1)//2 にしておくこと\n\ndef make_ST(n,first): #firstで初期化された、葉がn要素を超えるように2のべき乗個用意されたリストを返す\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #葉のindex(0-origin)がpointの要素をnumにする/treeはセグ木\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query区間左,右,注目ノード番号,担当範囲左,担当範囲右,木\n\n    if r <= a or b <= l: #区間が完全にかぶらない場合inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #区間が完全に含まれる場合自分\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = []\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans.append((nv+1,newv[c]+1))\n            end[newv[c]] = True\n            q.append(newv[c])\nif len(ans) == N-1:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n            \n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n方針:頂点1とすべてつなげたい\n→1が入ってる場合、1 & ナニカを選べばいい\n→そうでない場合、既に選択済み & 新規点を選べばよい\n\n小さい集合から選択するべき論はそうかも\n→むしろ登場回数が少ない頂点から選択するべき？\n\n→登場回数が2回の頂点2つがある\n→互いの選択で影響しあうのは重なってる場合\n\n各集合で取るより1から遠い点は残りの集合の中での登場回数がすくない点から貪欲に？\n→おｋそう\n\nあとはこれでループが生まれないことを証明\n→おｋ\n\nまずいのは、選択によって不可能集合を作ってしまうこと\n\n=====再挑戦=====\n\n方針は、1が入ってるやつは 1&ナニカを選ぶ\nそれ以外は新規を選ぶ\n→マッチング\n→dinicなら高速に行ける\n\n\"\"\"\n\nfrom collections import defaultdict\nfrom collections import deque\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n            \n\nimport sys\nfrom sys import stdin\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #頂点から属す集合を逆引き\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#二部マッチングを求める　集合N-1個と数字N-1個をマッチング\n#フロー始点を0,終点をNにしよう\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\n\n\"\"\"\n#一転更新区間取得のセグ木とRMQである(最大取得したいなら負で突っ込めばおｋ？)\n#query区間左,右は実際に求めたい区間(半開区間なので右は+1しておくこと)\n#注目ノード番号は0でOK\n#担当範囲左,担当範囲右　は、それぞれ　0 , (len(セグ木)+1)//2 にしておくこと\n\ndef make_ST(n,first): #firstで初期化された、葉がn要素を超えるように2のべき乗個用意されたリストを返す\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #葉のindex(0-origin)がpointの要素をnumにする/treeはセグ木\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query区間左,右,注目ノード番号,担当範囲左,担当範囲右,木\n\n    if r <= a or b <= l: #区間が完全にかぶらない場合inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #区間が完全に含まれる場合自分\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n\n#ansにそれぞれの集合からどれを取るかを入れればいい\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\"\"\"\n            \n\n"
  }
]