[
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\trd(n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\trd(m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\trd(k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tgap[0]=T;\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include <cassert>\n#include <set>\n\nusing namespace std;\n\nstruct MaxFlow{\n  typedef long long ll;\n  const ll INF = 1e18;\n  struct Edge{\n    int u,v;\n    ll c,rc;\n    shared_ptr<ll> flow;\n    Edge(int _u, int _v, ll _c, ll _rc = 0):u(_u),v(_v),c(_c),rc(_rc){\n    }\n  };\n  struct FlowTracker{\n    ll cap, rcap;\n    shared_ptr<ll> flow;\n    bool dir;\n    FlowTracker(ll _cap, ll _rcap, shared_ptr<ll> _flow, int _dir):cap(_cap),rcap(_rcap),flow(_flow),dir(_dir){ }\n    ll rem() const {\n      if(dir == 0){\n        return cap-*flow;\n      }\n      else{\n        return rcap+*flow;\n      }\n    }\n    void add_flow(ll f){\n      if(dir == 0)\n        *flow += f;\n      else\n        *flow -= f;\n      assert(*flow <= cap);\n      assert(-*flow <= rcap);\n    }\n    operator ll() const { return rem(); }\n    void operator-=(ll x){ add_flow(x); }\n    void operator+=(ll x){ add_flow(-x); }\n  };\n  int source,sink;\n  vector<vector<int> > adj;\n  vector<vector<FlowTracker> > cap;\n  vector<Edge> edges;\n  MaxFlow(int _source, int _sink):source(_source),sink(_sink){\n    assert(source != sink);\n  }\n  int add_edge(int u, int v, ll c, ll rc = 0){\n    edges.push_back(Edge(u,v,c,rc));\n    return edges.size()-1;\n  }\n  vector<int> now,lvl;\n  void prep(){\n    int max_id = max(source, sink);\n    for(auto edge : edges)\n      max_id = max(max_id, max(edge.u, edge.v));\n    adj.resize(max_id+1);\n    cap.resize(max_id+1);\n    now.resize(max_id+1);\n    lvl.resize(max_id+1);\n    for(auto &edge : edges){\n      auto flow = make_shared<ll>(0);\n      adj[edge.u].push_back(edge.v);\n      cap[edge.u].push_back(FlowTracker(edge.c, edge.rc, flow, 0));\n      if(edge.u != edge.v){\n        adj[edge.v].push_back(edge.u);\n        cap[edge.v].push_back(FlowTracker(edge.c, edge.rc, flow, 1));\n      }\n      assert(cap[edge.u].back() == edge.c);\n      edge.flow = flow;\n    }\n  }\n  bool dinic_bfs(){\n    fill(now.begin(),now.end(),0);\n    fill(lvl.begin(),lvl.end(),0);\n    lvl[source] = 1;\n    vector<int> bfs(1,source);\n    for(int i = 0; i < (int) bfs.size(); ++i){\n      int u = bfs[i];\n      for(int j = 0; j < (int) adj[u].size(); ++j){\n        int v = adj[u][j];\n        if(cap[u][j] > 0 && lvl[v] == 0){\n          lvl[v] = lvl[u]+1;\n          bfs.push_back(v);\n        }\n      }\n    }\n    return lvl[sink] > 0;\n  }\n  ll dinic_dfs(int u, ll flow){\n    if(u == sink)\n      return flow;\n    while(now[u] < (int) adj[u].size()){\n      int v = adj[u][now[u]];\n      if(lvl[v] == lvl[u] + 1 && cap[u][now[u]] != 0){\n        ll res = dinic_dfs(v,min(flow,(ll)cap[u][now[u]]));\n        if(res > 0){\n          cap[u][now[u]] -= res;\n          return res;\n        }\n      }\n      ++now[u];\n    }\n    return 0;\n  }\n  ll calc_max_flow(){\n    prep();\n    ll ans = 0;\n    while(dinic_bfs()){\n      ll cur = 0;\n      do{\n        cur = dinic_dfs(source,INF);\n        ans += cur;\n      }while(cur > 0);\n    }\n    return ans;\n  }\n  ll flow_on_edge(int edge_index){\n    assert(edge_index < (int) edges.size());\n    return *edges[edge_index].flow;\n  }\n};\n\n// auto mf = MaxFlow(1,n);\n// arguments source and sink, memory usage\n// O(largest node index + input size), sink\n// doesn't need to be last index\n// int edge_index;\n// for(int i = 0; i < m; ++i){\n//    int a,b,c;\n//    cin >> a >> b >> c;\n//mf.add\\_edge(a,b,c); // for directed edges\n//      edge_index = mf.add_edge(a,b,c,c); // store edge index if care about flow value\n//   }\n//  cout << mf.calc_max_flow() << '\\n';\n//cout << mf.flow\\_on\\_edge(edge\\_index) << endl; // return flow on this edge\n//}\n\nvoid failure () {\n  cout << -1 << endl;\n  exit(0);\n}\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N]; // adj[v] is the set of edgesets v is in\n\nconst int HYPER = 1e5 + 5;\nconst int SOURCE = 2e5 + 10;\nconst int SINK = SOURCE + 1;\n\nint adder [MAX_N];\nint match [MAX_N]; // match[e] is the v matching to edgeset e\npair<int, int> ans [MAX_N];\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  auto mf = MaxFlow(SOURCE, SINK);\n\n  vector<pair<pair<int, int>, int>> edges; // <<vertex, edgeset>, mf idx>\n  for (int i = 1; i < n; i++) {\n    int cnt;\n    cin >> cnt;\n\n    for (int j = 0; j < cnt; j++) {\n      int v;\n      cin >> v;\n\n      adj[v].push_back(i);\n      int idx = mf.add_edge(v, HYPER + i, 1);\n      edges.push_back({{v, i}, idx});\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    mf.add_edge(SOURCE, i, 1);\n  }\n\n  for (int i = 1; i < n; i++) {\n    mf.add_edge(HYPER + i, SINK, 1);\n  }\n\n  int flow = mf.calc_max_flow();\n  if (flow != n - 1) failure();\n  \n  set<int> freevs;\n  for (int i = 1; i <= n; i++) {\n    freevs.insert(i);\n  }\n\n  for (auto e : edges) {\n    if (mf.flow_on_edge(e.second) == 1) {\n      match[e.first.second] = e.first.first;\n      freevs.erase(e.first.first);\n    }\n  }\n\n  int start = *freevs.begin();\n\n  set<int> esets;\n  for (int e : adj[start]) {\n    esets.insert(e);\n    adder[e] = start;\n  }\n\n  for (int i = 0; i < n - 1; i++) {\n    if (esets.empty()) failure();\n\n    int E = *esets.begin();\n    esets.erase(E);\n\n    int v = match[E];\n    for (int e : adj[v]) {\n      if (adder[e] == 0) {\n        esets.insert(e);\n        adder[e] = v;\n      }\n    }\n\n    ans[E] = {v, adder[E]};\n  }\n\n  for (int i = 1; i < n; i++) {\n    cout << ans[i].first << \" \" << ans[i].second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fr[maxn],to[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[dy[y]]) {\n\t\t\tfr[y] = x;\n\t\t\tto[y] = dy[y];\n\t\t\tdfs(dy[y]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tprintf(\"%d %d\\n\",fr[i],to[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 400000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint x[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) x[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (x[i]) q.push(x[i]), ++k, fa[getfa(g[k] = s)] = getfa(h[k] = x[i]), x[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define SZ(x) ((int)x.size())\n#define FOR(i,a,b) for (int i=a;i<=b;++i)\n#define FORD(i,a,b) for (int i=a;i>=b;--i)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pa;\ntypedef vector<int> vec;\nvoid getint(int &v){\n    char ch,fu=0;\n    for(ch='*'; (ch<'0'||ch>'9')&&ch!='-'; ch=getchar());\n    if(ch=='-') fu=1, ch=getchar();\n    for(v=0; ch>='0'&&ch<='9'; ch=getchar()) v=v*10+ch-'0';\n    if(fu) v=-v;\n}\nconst int INF=1e9+10;\nvec w[500100],o[500010];\nbool u[500010];\npa ans[500010];\nint nedge,q[2000010],rt,S,T,d[2000010],maxmatch,n,h[500010],too[2000010],hed[1000010],nxt[2000010],cap[2000010];\nvoid ae(int x,int y,int w){\n\tnxt[++nedge]=hed[x];\n\thed[x]=nedge;\n\ttoo[nedge]=y;\n\tcap[nedge]=w;\n}\nvoid add(int x,int y,int w){\n\tae(x,y,w),ae(y,x,0);\n}\nbool build(){\n\tint he=0,ta=1;\n\tq[1]=S;\n\tFOR(i,S,T) d[i]=-1;\n\td[S]=0;\n\twhile (he!=ta){\n\t\tint x=q[++he];\n\t\tfor (int i=hed[x];i;i=nxt[i]){\n\t\t\tint y=too[i];\n\t\t\tif (!cap[i] || d[y]!=-1) continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tq[++ta]=y;\n\t\t}\n\t}\n\treturn (d[T]!=-1);\n}\nint fnd(int x,int flo){\n\tif (x==T) return flo;\n\tint ret,w=0;\n\tfor (int i=hed[x];i && w<flo;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (d[y]==d[x]+1 && cap[i] && (ret=fnd(y,min(flo-w,cap[i]))))\n\t\t\tcap[i]-=ret,cap[i^1]+=ret,w+=ret;\n\t}\n\tif (!w) d[x]=-1;\n\treturn w;\n}\nint dinic(){\n\tint ans=0;\n\twhile (build())\n\t\twhile (1){\n\t\t\tint flo=fnd(S,INF);\n\t\t\tif (!flo) break;\n\t\t\tans+=flo;\n\t\t}\n\treturn ans;\n}\nvoid dfs(int x){\n\tif (u[x]) return;\n\tu[x]=1;\n\tfor (int i=hed[x];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (!cap[i]) continue;\n\t\tdfs(y);\n\t}\n}\nint main(){\n\tcin>>n;\n\tFOR(i,1,n-1){\n\t\tint t,x;\n\t\tgetint(t);\n\t\twhile (t--){\n\t\t\tgetint(x);\n\t\t\tw[i].pb(x);\n\t\t\to[x].pb(i);\n\t\t}\n\t}\n\tS=0;\n\tnedge=1;\n\tT=n+n;\n\tFOR(i,1,n) add(S,i,1);\n\tFOR(i,n+1,n+n-1) add(i,T,1);\n\tFOR(x,1,n-1){\n\t\tFOR(i,0,SZ(w[x])-1)\n\t\t\tadd(w[x][i],x+n,1);\n\t}\n\tmaxmatch=dinic();\n\tif (maxmatch<n-1) return puts(\"-1\"),0;\n\tdfs(S);\n\tFOR(i,1,n) if (!u[i]) return puts(\"-1\"),0;\n\tfor (int i=hed[S];i;i=nxt[i]){\n\t\tint y=too[i];\n\t\tif (cap[i]){rt=y;break;}\n\t}\n\tFOR(x,1,n){\n\t\tif (x==rt) continue;\n\t\tfor (int i=hed[x];i;i=nxt[i]){\n\t\t\tint y=too[i];\n\t\t\tif (!cap[i] && y>=n+1 && y<=n+n-1){h[y-n]=x;break;}\n\t\t}\n\t}\n\tFOR(i,1,n) u[i]=0;\n\tint he=0,ta=1;\n\tq[1]=rt;\n\tu[rt]=1;\n\twhile (ta<n){\n\t\tint x=q[++he];\n\t\tFOR(i,0,SZ(o[x])-1){\n\t\t\tint y=h[o[x][i]];\n\t\t\tif (u[y]) continue;\n\t\t\tu[y]=1;\n\t\t\tans[o[x][i]]=mp(x,y);\n\t\t\tq[++ta]=y;\n\t\t}\n\t}\n\tFOR(i,1,n-1) printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for (int i = (a); i <= (b); ++ i)\n#define rrp(i,a,b) for (int i = (a); i >= (b); -- i)\n#define gc() getchar()\n#define fir first\n#define sec second\ntypedef pair<int,int> pii;\ntypedef double db;\ntypedef long long ll;\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc(); !isdigit(tmp); tmp = gc())\n    key = (tmp == '-');\n  for (; isdigit(tmp); tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int N = 200010;\nint mat[N];\nnamespace mf {\n  const int M = 400010;\n  const int INF = 0x3f3f3f3f;\n  struct edge {\n    int la,b,cap;\n  } con[M << 1];\n  int tot = 1, fir[N];\n  void add(int from,int to,int capc) {\n    con[++tot] = (edge) {fir[from], to, capc};\n    fir[from] = tot;\n    con[++tot] = (edge) {fir[to], from, 0};\n    fir[to] = tot;\n  }\n  int dis[N], st, en, cur[N], n;\n  int dfs(int pos,int imp) {\n    if (pos == en || !imp) return imp;\n    int ret = 0, tmp;\n    for (int& i = cur[pos]; i; i = con[i].la) {\n      if (dis[con[i].b] == dis[pos] + 1) {\n\ttmp = dfs(con[i].b, min(imp, con[i].cap));\n\tcon[i].cap -= tmp;\n\tcon[i^1].cap += tmp;\n\timp -= tmp;\n\tret += tmp;\n\tif (!imp) break;\n      }\n    }\n    return ret;\n  }\n  bool bfs() {\n    queue<int> q;\n    rep (i, 1, n) dis[i] = INF;\n    dis[st] = 0;\n    q.push(st);\n    for (int pos; !q.empty(); q.pop()) {\n      pos = q.front();\n      for (int i = fir[pos]; i; i = con[i].la) {\n\tif (con[i].cap && dis[con[i].b] == INF) {\n\t  dis[con[i].b] = dis[pos] + 1;\n\t  q.push(con[i].b);\n\t}\n      }\n    }\n    if (dis[en] == INF) return false;\n    rep (i, 1, n) cur[i] = fir[i];\n    return true;\n  }\n  int calc() {\n    int ret = 0;\n    while (bfs())\n      ret += dfs(st, INF);\n    rep (pos, (n/2)+1, n-2) {\n      for (int i = fir[pos]; i; i = con[i].la) {\n\tif (con[i].b <= (n/2) && con[i].cap > 0)\n\t  mat[pos - (n/2)] = con[i].b;\n      }\n    }\n    return ret;\n  }\n  \n}\nint n, vis[N];\nvector<int> vec[N], rec[N];\npii ans[N];\nvoid dfs(int pos) {\n  vis[pos] = 1;\n  rep (i, 0, (int)rec[pos].size()-1) {\n    if (vis[mat[rec[pos][i]]]) continue;\n    ans[rec[pos][i]] = pii(pos, mat[rec[pos][i]]);\n    dfs(mat[rec[pos][i]]);\n  }\n}\nint main() {\n  read(n);\n  rep (i, 1, n-1) {\n    int tmp, x;\n    read(tmp);\n    rep (j, 1, tmp) {\n      read(x);\n      vec[i].push_back(x);\n      rec[x].push_back(i);\n      if (x != 1) mf::add(x, i + n, 1);\n    }\n  }\n  mf::n = 2 * n - 1;\n  mf::st = ++ mf::n;\n  mf::en = ++ mf::n;\n  rep (i, 1, n) mf::add(mf::st, i, 1);\n  rep (i, n+1, 2*n-1) mf::add(i, mf::en, 1);\n  int res = mf::calc();\n  if (res < n-1) {\n    puts(\"-1\");\n    return 0;\n  }\n  dfs(1);\n  int tmp = 1;\n  rep (i, 1, n) if (!vis[i]) tmp = 0;\n  if (tmp == 0) puts(\"-1\");\n  else {\n    rep (i, 1, n-1) {\n      printf(\"%d %d\\n\", ans[i].fir, ans[i].sec);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\treturn 0;\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf < N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 200010\n#define T n+n+1\n#define add(x,y,z) addedge(x,y,z),addedge(y,x,0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nint head[N],tot=1,cur[N],vis[N],dis[N],n,p[N],fa[N],s; vector<int> v[N];\nstruct Edge{int v,next,f,w;}edge[N*10]; queue<int> q;\ninline void addedge(int x,int y,int z){edge[++tot]=Edge{y,head[x],0,z};head[x]=tot;}\ninline int bfs()\n{\tmemset(vis,0,sizeof(vis)); memcpy(cur,head,sizeof(cur)); q.push(0); vis[0]=1;\n\twhile(!q.empty())\n\t{\tint x=q.front(); q.pop();\n\t\tfor(rint i=head[x];i;i=edge[i].next)\n\t\tif(!vis[to]&&edge[i].f<edge[i].w) dis[to]=dis[x]+1,vis[to]=1,q.push(to);\n\t}\n\treturn vis[T];\n}\nint dfs(int x,int res)\n{\tif(x==T||!res) return res; int flow=0,f;\n\tfor(rint &i=cur[x];i;i=edge[i].next)\n\tif(dis[to]==dis[x]+1&&(f=dfs(to,min(res,edge[i].w-edge[i].f))))\n\t{edge[i].f+=f;edge[i^1].f-=f;res-=f;flow+=f;if(!res)break;}\n\treturn flow;\n}\ninline int dinic(){int A=0;while(bfs())A+=dfs(0,INT_MAX);return A;}\nvoid dfs(int x){vis[x]=1;s++;for(auto y:v[x])if(!vis[p[y]])fa[y]=x,dfs(p[y]);}\nint main()\n{\tint m,x; cin>>n; for(rint i=1;i<=n;i++) add(n+i,T,1);\n\tfor(rint i=1;i<n;add(0,i,1),i++)\n\tfor(scanf(\"%d\",&m);m--;){scanf(\"%d\",&x),v[x].push_back(i);if(x!=1)add(i,n+x,1);}\n\tif(dinic()!=n-1) return !printf(\"-1\");\n\tfor(rint j=1;j<n;j++)\n\tfor(rint i=head[j];i;i=edge[i].next) if(n<to&&to<=n+n&&edge[i].f) p[j]=to-n;\n\tdfs(1); if(s!=n) return !printf(\"-1\");\n\tfor(rint i=1;i<n;i++) printf(\"%d %d\\n\",fa[i],p[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint next[N],head[N],edge[N],v[N],next2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnext[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnext2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=next[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=next2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=600005;\nvector<int> bel[N];\nint cur[N],from[N],S,T,ne[N],a[N],b[N],dis[N],flag[N],x,y,n,m,fi[N],tot,zz[N],sl[N];\nqueue<int>Q;\nvoid jb(int x,int y,int z){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n\tsl[tot]=z;\n\tne[++tot]=fi[y];\n\tfi[y]=tot;\n\tzz[tot]=x;\n\tsl[tot]=0;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,-1,sizeof dis);\n\tdis[S]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]==-1){\n\t\t\t\tdis[zz[i]]=dis[now]+1;\n\t\t\t\tQ.push(zz[i]);\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&dis[zz[i]]==dis[x]+1&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\ty-=b;\n\t\t\ts+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=0;T=2*n;\n\ttot=1;\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tjb(S,i+n,1);\n\t\twhile (x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tjb(i+n,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)jb(i,T,1);\n\tint ans=0;\n\twhile (bfs()){\n\t\tfor (int i=S;i<=T;i++)cur[i]=fi[i];\n\t\tans+=dfs(S,1e9);\n\t}\n\tif (ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=fi[i+n];j;j=ne[j])\n\t\t\tif (zz[j]&&!sl[j]){\n\t\t\t\tflag[zz[j]]=1;\n\t\t\t\tb[i]=zz[j];\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])Q.push(i);\n\tans=0;\n\tmemset(flag,0,sizeof flag);\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tans++;\n\t\tfor (int i=0;i<bel[now].size();i++)\n\t\t\tif (!flag[bel[now][i]]){\n\t\t\t\tflag[bel[now][i]]=1;\n\t\t\t\ta[bel[now][i]]=now;\n\t\t\t\tQ.push(b[bel[now][i]]);\n\t\t\t}\n\t}\n\tif (ans!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=2e5+5,M=N<<3,inf=0x7fffffff;\n\nint t[M],f[M],nxt[M],lst[N],l;\n\nvoid add(int x,int y,int z) {\n\tt[++l]=y;f[l]=z;nxt[l]=lst[x];lst[x]=l;\n\tt[++l]=x;f[l]=0;nxt[l]=lst[y];lst[y]=l;\n}\n\nint n,S,T,q[N],dis[N],p[N],fa[N];\nvector<int> to[N];\n\nbool bfs() {\n\tfo(i,S,T) dis[i]=0;dis[S]=1;\n\tint i=0,j=1;q[1]=S;\n\twhile (i<j) {\n\t\trep(k,q[++i])\n\t\t\tif (f[k]&&!dis[t[k]]) {\n\t\t\t\tdis[t[k]]=dis[q[i]]+1;\n\t\t\t\tq[++j]=t[k];\n\t\t\t}\n\t}\n\treturn dis[T];\n}\n\nint dinic(int x,int y) {\n\tif (x==T) return y;\n\tint now=0;\n\trep(i,x)\n\t\tif (f[i]&&dis[t[i]]==dis[x]+1) {\n\t\t\tint k=dinic(t[i],min(y,f[i]));\n\t\t\tf[i]-=k;f[i^1]+=k;\n\t\t\ty-=k;now+=k;\n\t\t\tif (!y) break;\n\t\t}\n\tif (!now) dis[x]=-1;\n\treturn now;\n}\n\nbool vis[N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x])\n\t\tif (!vis[p[y]]) {\n\t\t\tfa[y]=x;\n\t\t\tdfs(p[y]);\n\t\t}\n}\n\nint main() {\n\tn=read();S=0;T=n<<1;l=1;\n\tfo(i,1,n-1) {\n\t\tadd(S,i,1);\n\t\tfor(int c=read();c;c--) {\n\t\t\tint x=read();\n\t\t\tif (x>1) add(i,x+n-1,1);\n\t\t\tto[x].push_back(i);\n\t\t}\n\t}\n\tfo(i,1,n) add(i+n-1,T,1);\n\tint ret=0;\n\twhile (bfs()) ret+=dinic(S,inf);\n\tif (ret<n-1) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) rep(j,i) if (!f[j]&&t[j]) p[i]=t[j]-n+1;\n\tdfs(1);\n\tfo(i,1,n-1) if (!fa[i]) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[200010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], fa[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) assert(to[i] == 0), to[i] = e[j].v - n + 1;\n        assert(to[i] < n);\n        assert(to[i]);\n    }\n    queue < int > q;\n    q.push(n);\n    int cnt = 0;\n    while (!q.empty()) {\n        cnt++;\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!fa[e[i].v]) {\n                q.push(to[e[i].v]);\n                fa[e[i].v] = now;\n            }\n        }\n    }\n    if (cnt != n) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", fa[i], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline void solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\tsolve();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=200000+10,inf=0x3f3f3f3f;\nint n,fa[MAXN],e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<1],to[MAXN<<1],out[MAXN<<1],cap[MAXN<<1],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tfa[mh[v]]=x,vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,n)printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[1]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(now,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 3e5 + 50, M = 2e6 + 50;\ncs int INF = 1e9 + 7;\nint n, S, T, fi[N], nxt[M], to[M], w[M], ec=1;\nvoid adde(int x, int y, int z){\n\tnxt[++ec]=fi[x], fi[x]=ec, to[ec]=y, w[ec]=z;\n\tnxt[++ec]=fi[y], fi[y]=ec, to[ec]=x, w[ec]=0;\n} int eu[N], ev[N], ct, d[N];\nbool bfs(){\n\tqueue<int> q; q.push(S); \n\tmemset(d,-1,sizeof(d)); d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x],v;e;e=nxt[e]) if(w[e]){\n\t\t\tv=to[e]; if(d[v]==-1){\n\t\t\t\td[v]=d[x]+1; q.push(v);\n\t\t\t\tif(v==T) return true;\n\t\t\t}\n\t\t}\n\t} return false;\n}\nint dfs(int u, int flw){\n\tif(u==T) return flw; int ans = 0;\n\tfor(int e=fi[u],v;e;e=nxt[e])\n\tif(d[v=to[e]]==d[u]+1){\n\t\tint dt=dfs(v,min(w[e],flw));\n\t\tans+=dt; flw-=dt;\n\t\tw[e]-=dt; w[e^1]+=dt; if(!flw) break;\n\t} if(flw) d[u]=-1; return ans;\n}\nint dinic(){ int flw = 0; while(bfs()) flw += dfs(S,INF); return flw; }\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1,k,x; i<n; i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1; j<=k; j++) \n\t\tscanf(\"%d\",&x), adde(x,i+n,1);\n\t} S=0, T=n+n;\n\tfor(int i=1; i<=n; i++) adde(S,i,1);\n\tfor(int i=1; i<n; i++) adde(i+n,T,1);\n\tint flw = dinic();\n\tif(flw < n-1) return puts(\"-1\"),0;\n\t\n\tstatic int tr[N];\n\tfor(int i=n+1; i<n+n; i++)\n\tfor(int e=fi[i];e;e=nxt[e]) \n\tif(to[e]!=T&&w[e]) tr[i]=to[e];\n\t\n\tqueue<int> q;\n\tfor(int e=fi[S];e;e=nxt[e])\n\tif(w[e]) q.push(to[e]);\n\t\n\tstatic bool ban[N];\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x];e;e=nxt[e]) \n\t\tif(to[e]!=S&&!ban[to[e]]){\n\t\t\teu[to[e]-n]=x; ev[to[e]-n]=tr[to[e]];\n\t\t\tq.push(tr[to[e]]); ban[to[e]]=true; ++ct;\n\t\t}\n\t} if(ct<n-1) return puts(\"-1\"),0;\n\tfor(int i=1; i<n; i++) cout<<eu[i]<<\" \"<<ev[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int maxm=400111;\n\nstruct edge{int to,cap;};\nnamespace flow\n{\n\tint head[maxn],nxt[maxm<<1],iter[maxn],tot;\n\tedge e[maxm<<1];\n\tvoid clear()\n\t{\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=1;\n\t}\n\tmax_flow(){clear();}\n\tvoid addedge(int u,int v,int cap)\n\t{\n\t\tnxt[++tot]=head[u];\n\t\thead[u]=tot;\n\t\te[tot]=edge{v,cap};\n\t\tnxt[++tot]=head[v];\n\t\thead[v]=tot;\n\t\te[tot]=edge{u,0};\n\t}\n\t \n\tint lvl[maxn],q[maxn];\n\tbool bfs(int s,int t)\n\t{\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;int rr=0;q[rr++]=s;\n\t\tfor(int fr=0;fr<rr;fr++)\n\t\t{\n\t\t\tint x=q[fr];if(x==t)return true;\n\t\t\tfor(int i=head[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==-1)\n\t\t\t{\n\t\t\t\tlvl[e[i].to]=lvl[x]+1;\n\t\t\t\tq[rr++]=e[i].to;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int x,int t,int f)\n\t{\n\t\tif(x==t||f==0)return f;\n\t\tint ret=0;\n\t\tfor(int&i=iter[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==lvl[x]+1)\n\t\t{\n\t\t\tint d=dfs(e[i].to,t,min(f,e[i].cap));\n\t\t\te[i].cap-=d;e[i^1].cap+=d;\n\t\t\tf-=d;ret+=d;\n\t\t\tif(!f)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint maxflow(int s,int t)\n\t{\n\t\tint flow=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemcpy(iter,head,sizeof(head));\n\t\t\tflow+=dfs(s,t,inf);\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nvector<int> e[maxn],g[maxn];\nint n,piv[maxn],fa[maxn];\n\nbool use[maxn];\nvoid dfs(int x)\n{\n\tuse[x]=1;\n\tfor(auto&v:g[x])if(!use[v])\n\t{\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tget1(n);\n\tint S=1,T=n+n;\n\tfor(int i=2;i<=n;i++)flow::addedge(S,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint cnt,x;get1(cnt);\n\t\tflow::addedge(i+n,T,1);\n\t\twhile(cnt--)\n\t\t{\n\t\t\tget1(x);\n\t\t\te[i].pb(x);\n\t\t\tif(x>1)flow::addedge(x,i+n,1);\n\t\t}\n\t}\n\tif(flow::maxflow(S,T)<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=2;i<=n;i++)for(int j=flow::head[i];j;j=flow::nxt[j])if(flow::e[j].to!=S&&!flow::e[j].cap)\n\t\tpiv[flow::e[j].to-n]=i;\n\t\n\tfor(int i=1;i<n;i++)for(int j=0;j<(int)e[i].size();j++)if(e[i][j]!=piv[i])g[e[i][j]].pb(piv[i]);\n\t\n\tdfs(1);\n\tfor(int i=2;i<=n;i++)if(!fa[i])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",piv[i],fa[piv[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<set<ll>>& cap){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[v].count(nex) == 0)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            if (plusflow == 0){\n                cap[v].insert(nex);\n                continue;\n            }\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n\n            return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        vector<ll> level(N,inf);\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<set<ll>> cap(N); \n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%lld\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%lld\" , &c);\n        rep(i,0,c){\n            scanf (\"%lld\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%lld %lld\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int N = 200228;\nvector<int> e[N];\nvector<int> erev[N];\n\nint n;\n\nint p[N];\nint pr[N];\n\nint w[N];\nint curv;\n\nint av[N], au[N];\n\nvoid nein() {\n    cout << -1 << \"\\n\";\n    exit(0);\n}\n\nbool dfs(int v) {\n    if (w[v] == curv) {\n        return false;\n    }\n\n    w[v] = curv;\n\n    for (int u: e[v]) {\n        if (p[u] == 0) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    for (int u: e[v]) {\n        if (dfs(p[u])) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool go[N];\n\nvoid dfsgo(int v) {\n    go[v] = true;\n    for (int u: erev[v]) {\n        if (!go[pr[u]]) {\n            av[u] = v;\n            au[u] = pr[u];\n            dfsgo(pr[u]);\n        }\n    }\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n\n    cin >> n;\n\n    for (curv = 1; curv < n; ++curv) {\n        int s;\n        cin >> s;\n        e[curv].resize(s);\n        for (int& v: e[curv]) {\n            cin >> v;\n            erev[v].push_back(curv);\n        }\n\n        if (!dfs(curv)) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        pr[p[i]] = i;\n    }\n\n    int root = 1;\n    while (p[root]) {\n        ++root;\n    }\n\n    dfsgo(root);\n    for (int i = 1; i <= n; ++i) {\n        if (!go[i]) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        cout << av[i] << \" \" << au[i] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int i = 0; i + 1 < n; ++i) {\n        memset(used, 0, sizeof(used));\n        dfs(i);\n    }\n    /*for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }*/\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=1e5+5,inf=0x3f3f3f3f;\nint n,s,t,head[N<<1],num=1;\nstruct edge{int to,flo,next;} e[N*10];\ninline void add(int u,int v){\n    e[++num]=(edge){v,1,head[u]},head[u]=num;\n    e[++num]=(edge){u,0,head[v]},head[v]=num;\n}\n\nint dis[N<<1];\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof dis);\n    q.push(s),dis[s]=1;\n    while(!q.empty()){\n\tint u=q.front();q.pop();\n\tfor(int i=head[u];i;i=e[i].next){\n\t    int v=e[i].to;if(dis[v]||!e[i].flo)continue;\n\t    dis[v]=dis[u]+1,q.push(v);\n\t}\n    }\n    return dis[t];\n}\nint dfs(int u,int lim){\n    if(u==t||!lim)return lim;\n    int flow=0;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(dis[v]!=dis[u]+1||!e[i].flo)continue;\n\tint f=dfs(v,min(lim,e[i].flo));\n\te[i].flo-=f,e[i^1].flo+=f;\n\tlim-=f,flow+=f;\n\tif(!lim)break;\n    }\n    return flow;\n}\nint Netflow(){\n    int ans=0;\n    while(bfs())ans+=dfs(s,inf);\n    return ans;\n}\n\nint fa[N<<1],vis[N<<1],cnt;\npii ans[N];\nvoid serch(int u,int pa){\n    cnt+=u<=n,vis[u]=1,fa[u]=pa;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(vis[v]||!e[i].flo)continue;\n\tserch(v,u);\n    }\n}\n\nint main(){\n    //freopen(\"in.in\",\"r\",stdin);\n    n=read();s=n+n,t=s+1;\n    REP(i,1,n)add(s,i);\n    REP(i,1,n-1)add(n+i,t);\n    REP(i,1,n-1)REP(c,1,read()){int u=read();add(u,n+i);}\n    if(Netflow()<n-1)return puts(\"-1\"),0;\n    int rt=0;\n    for(int i=head[s];i;i=e[i].next)if(e[i].flo){rt=e[i].to;break;}\n    serch(rt,0);\n    if(cnt<n)return puts(\"-1\"),0;\n    REP(i,1,n)if(i!=rt){\n\tint id=fa[i],p=fa[id];\n\tans[id-n]=mp(p,i);\n    }\n    REP(i,1,n-1)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\n// #include <ext/pb_ds/assoc_container.hpp>\n// using namespace __gnu_pbds;\n// gp_hash_table<int, int> mapka;\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nvoid nie(){\n  cout << \"-1\\n\";\n  exit(0);\n}\n\nconst int MAX = 1e5+1;\nint n;\nvector<int> d[MAX],d2[MAX];\nint cz[MAX],sx[MAX],sy[MAX];\nbool dfs(int x){\n  if(cz[x])return 0;\n  cz[x] = 1;\n  for(int el:d[x]){\n    if(sy[el] == -1 || dfs(sy[el])){\n      sy[el] = x;\n      sx[x] = el;\n      return 1;\n    }\n  }\n  return 0;\n}\nPII out[MAX];\nint ilout = 0;\nvoid buduj(int x){\n  for(int el:d2[x]){\n    if(!cz[el]){\n      cz[el] = 1;\n      ilout ++;\n      out[el] = {x, sx[el]};\n      buduj(sx[el]);\n    }\n  }\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  cin >> n;\n  R(i,n-1){\n    int pom;\n    cin >> pom;\n    d[i].resize(pom);\n    R(j,pom){\n      cin >> d[i][j];\n      d[i][j]--;\n      d2[d[i][j]].PB(i);\n    }\n  }\n  R(i,n){\n    sx[i] = -1;\n    sy[i] = -1;\n  }\n  int res = 0;\n  bool x = 1;\n  while(x){\n    x = 0;\n    R(i,n)cz[i] = 0;\n    R(i,n)if(sx[i] == -1){\n      if(dfs(i)){\n        res ++;\n        x = 1;\n      }\n    }\n  }\n  R(i,n-1){\n    debug(sx[i]);\n  }\n  if(res != n-1)nie();\n  R(i,n)cz[i] = 0;\n  R(i,n){\n    if(sy[i] == -1){\n      buduj(i);\n    }\n  }\n  if(ilout!=n-1)nie();\n  R(i,n-1){\n    cout << out[i].FI + 1 << \" \" << out[i].SE + 1 << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_set>\n#include <bitset>\n#include <time.h>\n#include <limits.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define szz(x) (int)x.size()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define all(x) x.begin(),x.end()\ntypedef tuple<int, int, int> t3;\n\nnamespace MaxFlow{\n\tconst int MV = 300020;\n\tconst int ME = 700040;\n\tconst int INF = 1e9;\n\tint dis[MV];\n\tint st[MV], en[ME<<1], nxt[ME<<1], flow[ME<<1], ce;\n\tint start[MV];\n\tvoid init() {\n\t\tmemset(st, 0, sizeof st);\n\t\tce = 1;\n\t}\n\tvoid addE(int s, int e, int f = 1) {\n\t\t++ce; nxt[ce] = st[s]; st[s] = ce; en[ce] = e; flow[ce] = f;\n\t\t++ce; nxt[ce] = st[e]; st[e] = ce; en[ce] = s; flow[ce] = 0;\n\t}\n\tint que[MV];\n\tint bfs(int N, int S, int E) {\n\t\tfor(int i=1;i<=N;i++) dis[i] = -1;\n\t\tdis[S] = 0;\n\t\tint *fr = que, *re = que;\n\t\t*fr++ = S;\n\t\twhile(fr != re) {\n\t\t\tint t = *re++;\n\t\t\tfor(int i=st[t];i;i=nxt[i]) if(flow[i] > 0 && dis[en[i]] == -1) {\n\t\t\t\tdis[en[i]] = dis[t] + 1;\n\t\t\t\t*fr++ = en[i];\n\t\t\t}\n\t\t}\n\t\treturn dis[E] != -1;\n\t}\n\t\n\tint dfs(int x, int E, int f) {\n\t\tif(x == E) return f;\n\t\tfor(int &i=start[x],t;i;i=nxt[i]) if(flow[i] > 0 && dis[en[i]] == dis[x] + 1 && (t = dfs(en[i], E, min(f, flow[i]))) > 0){\n\t\t\tflow[i] -= t;\n\t\t\tflow[i^1] += t;\n\t\t\treturn t;\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint Get(int N, int S, int E) {\n\t\tint res = 0;\n\t\twhile(bfs(N, S, E)) {\n\t\t\tfor(int i=1;i<=N;i++) start[i] = st[i];\n\t\t\twhile(1) {\n\t\t\t\tint t = dfs(S, E, INF);\n\t\t\t\tif(t == 0) break;\n\t\t\t\tres += t;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvoid trace(int N, int S, int E, int chk[]) {\n\t\tbfs(N, S, E);\n\t\tfor(int i=1;i<=N;i++) chk[i] = (dis[i] != -1);\n\t}\n}\n\nint N;\nvector <int> R[100010], L[100010];\nint V[100010], W[100010];\nint mark[100010];\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor(int i=1;i<N;i++) {\n\t\tint c; scanf(\"%d\", &c);\n\t\twhile(c--) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tR[i].pb(x);\n\t\t}\n\t}\n\tint ST = 1;\n\tMaxFlow::init();\n\tfor(int i=1;i<N;i++) {\n\t\tMaxFlow::addE(1, i + 1);\n\t\tfor(int j=0;j<szz(R[i]);j++) {\n\t\t\tif(R[i][j] != 1) MaxFlow::addE(i+1, N + R[i][j] - 1);\n\t\t}\n\t}\n\tfor(int i=1;i<N;i++) MaxFlow::addE(N + i, 2 * N);\n\tint r = MaxFlow::Get(2*N, 1, 2*N);\n\tif(r != N - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=N;i++) {\n\t\tfor(int j=MaxFlow::st[i];j;j=MaxFlow::nxt[j]) {\n\t\t\tint e = MaxFlow::en[j];\n\t\t\tif(N+1 <= e && e < 2*N && MaxFlow::flow[j] == 0) V[i-1] = e - N + 1;\n\t\t}\n\t}\n\tfor(int i=1;i<N;i++) for(int e : R[i]) if(e != V[i]) L[e].pb(i);\n\tvector <int> q;\n\tfor(int e : L[1]) {\n\t\tW[e] = 1; mark[e] = 1;\n\t\tq.pb(e);\n\t}\n\trep(i, szz(q)) {\n\t\tint t = q[i];\n\t\tint v = V[t];\n\t\tfor(int e : L[v]) {\n\t\t\tif(mark[e] == 0) {\n\t\t\t\tW[e] = v;\n\t\t\t\tmark[e] = 1;\n\t\t\t\tq.pb(e);\n\t\t\t}\n\t\t}\n\t}\n\tif(szz(q) < N - 1) puts(\"-1\");\n\telse {\n\t\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\", V[i], W[i]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 19.12.2019 15:42:22       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass matching {\n public:\n  vector<vector<int>> g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  matching mat(n - 1, n);\n  vector<vector<int>> gr(n);\n  for (int i = 0; i < n - 1; i++) {\n    int foo;\n    cin >> foo;\n    while (foo--) {\n      int bar;\n      cin >> bar;\n      --bar;\n      mat.add(i, bar);\n      gr[bar].push_back(i);\n    }\n  }\n  if (mat.solve() != n - 1) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int start = -1;\n  for (int i = 0; i < n; i++) {\n    if (mat.pb[i] == -1) {\n      start = i;\n      break;\n    }\n  }\n  vector<pair<int, int>> res(n - 1);\n  vector<bool> was(n, false);\n  vector<int> que(1, start);\n  was[start] = true;\n  for (int b = 0; b < (int) que.size(); b++) {\n    int x = que[b];\n    for (int v : gr[x]) {\n      int y = mat.pa[v];\n      if (!was[y]) {\n        was[y] = true;\n        que.push_back(y);\n        res[v] = make_pair(y, x);\n      }\n    }\n  }\n  if ((int) que.size() != n) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    cout << res[i].first + 1 << \" \" << res[i].second + 1 << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 100010;\nconst int inf = 0x3f3f3f3f;\n\nint src, sink;\n\nint n, l[maxn<<1], L[maxn<<1], Q[maxn<<1], r, fa[maxn], p[maxn], vis[maxn], e;\nvector<int> vec[maxn];\n\nstruct Edge {\n\tint v, c, x;\n} E[maxn<<3];\n\ninline void addEdge(int u, int v, int c) {\n\tE[e].v = v; E[e].x = l[u]; E[e].c = c; l[u] = e++;\n\tE[e].v = u; E[e].x = l[v]; E[e].c = 0; l[v] = e++;\n}\n\nint _bfs() {\n\tmemset(L, -1, sizeof(L));\n\tint s = 0, t = 0, u;\n\tL[src] = 0; Q[t++] = src;\n\twhile (s < t) {\t\n\t\tu = Q[s++];\n\t\tfor (int p = l[u]; p >= 0; p = E[p].x) {\n\t\t\tif (E[p].c && L[E[p].v] == -1) {\n\t\t\t\tL[Q[t++] = E[p].v] = L[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn L[sink] != -1;\n}\n\nint _find(int u, int in) {\n\tif (u == sink) return in;\n\tint w = 0, t;\n\tfor (int p = l[u]; p >= 0 && w < in; p = E[p].x) {\n\t\tif (L[E[p].v] == L[u] + 1 && E[p].c) {\n\t\t\tif ((t = _find(E[p].v, min(in-w, E[p].c)))) {\n\t\t\t\tE[p].c -= t;\n\t\t\t\tE[p^1].c += t;\n\t\t\t\tw += t;\n\t\t\t}\n\t\t}\n\t}\n\tif (w < in) L[u] = -1;\n\treturn w;\n}\n\nint dinic() {\n\tint res = 0, t;\n\twhile (_bfs()) {\n\t\twhile ((t = _find(src, inf))) {\n\t\t\tres += t;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tmemset(l, -1, sizeof(l));\n\tscanf(\"%d\", &n);\n\tsrc = n-1+n+1; sink = n-1+n+2;\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tint c = 0; scanf(\"%d\", &c);\n\t\tfor (int j = 1; j <= c; j++) {\n\t\t\tint w; scanf(\"%d\", &w);\n\t\t\taddEdge(i, n-1+w, 1);\n\t\t\tvec[w].push_back(i);\n\t\t}\n\t\taddEdge(src, i, 1);\n\t}\n\tfor (int i = 1; i <= n; i++) addEdge(n-1+i, sink, 1);\n\tint c = dinic();\n\tif (c < n-1) {puts(\"-1\"); return 0;}\n\tfor (int i = 1; i <= n-1; i++) {\n\t\tfor (int _p = l[i]; _p >= 0; _p = E[_p].x) {\n\t\t\tif (!E[_p].c && E[_p].v >= n) {\n\t\t\t\tp[i] = E[_p].v - n  + 1;\n\t\t\t\tvis[p[i]] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) r = i;\n\tfor (int i = 1; i <= n; i++) vis[i] ^= 1;\n\tint s = 0, t = 0, u;\n\tQ[t++] = r;\n\twhile (s < t) {\n\t\tu = Q[s++];\n\t\tfor (int i = 0; i < vec[u].size(); i++) {\n\t\t\tint v = vec[u][i];\n\t\t\tif (!vis[p[v]]) {\n\t\t\t\tvis[p[v]] = 1;\n\t\t\t\tfa[p[v]] = u;\n\t\t\t\tQ[t++] = p[v];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) {puts(\"-1\"); return 0;}\n\tfor (int i = 1; i <= n-1; i++) printf(\"%d %d\\n\", p[i], fa[p[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 200005\n#define M 800005\n#define inf 0x3f3f3f3f\nint tar[M], nex[M], cap[M], fir[N], cnt = 1;\nint n, m, dis[N], now[N], use[N][2];\nvector<int>A[N];\nset<int>S[N];\nqueue<int>Q;\nvoid add(int a, int b, int c)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tcap[cnt] = c;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nvoid Add(int a, int b)\n{\n\tadd(a, b, 1);\n\tadd(b, a, 0);\n}\nint aug(int s, int b, int e, int g, int augco)\n{\n\tif (s == e)\n\t\treturn augco;\n\tint augc = augco;\n\tfor (int &i = now[s]; i; i = nex[i])\n\t{\n\t\tint v = tar[i];\n\t\tif (cap[i])\n\t\t{\n\t\t\tif (dis[v] == dis[s] + 1)\n\t\t\t{\n\t\t\t\tint delta = aug(v, b, e, g, min(augc, cap[i]));\n\t\t\t\tcap[i] -= delta;\n\t\t\t\tcap[i ^ 1] += delta;\n\t\t\t\taugc -= delta;\n\t\t\t\tif (!augc)\n\t\t\t\t\treturn augco;\n\t\t\t}\n\t\t}\n\t}\n\treturn augco - augc;\n}\nbool Bfs(int s, int t)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tdis[s] = 0;\n\tqueue<int>que;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front();\n\t\tnow[x] = fir[x];\n\t\tque.pop();\n\t\tfor (int i = fir[x]; i; i = nex[i])\n\t\t{\n\t\t\tint v = tar[i];\n\t\t\tif (!cap[i])\n\t\t\t\tcontinue;\n\t\t\tif (dis[x] + 1 < dis[v])\n\t\t\t{\n\t\t\t\tdis[v] = dis[x] + 1;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t] != inf;\n}\nint sap(int b, int e, int g)\n{\n\tint flow = 0;\n\twhile (Bfs(b, e))\n\t\tflow += aug(b, b, e, g, inf);\n\treturn flow;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int j = 1; j <= t; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tS[x].insert(i);\n\t\t\tA[i].push_back(x);\n\t\t\tif (x != 1)\n\t\t\t\tAdd(i, n + x);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tAdd(2 * n + 1, i);\n\t\tAdd(n + i, 2 * n + 2);\n\t}\n\tint ans = sap(2 * n + 1, 2 * n + 2, 2 * n + 2);\n\tif (ans < n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = fir[i]; j; j = nex[j])\n\t\t{\n\t\t\tint v = tar[j];\n\t\t\tif (v > n && !cap[j])\n\t\t\t\tuse[i][0] = v - n;\n\t\t}\n\t}\n\tQ.push(1);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front();\n\t\tm++;\n\t\tQ.pop();\n\t\tset<int>::iterator it = S[x].begin();\n\t\tfor (; it != S[x].end(); it++)\n\t\t{\n\t\t\tif (!use[*it][1])\n\t\t\t{\n\t\t\t\tuse[*it][1] = x;\n\t\t\t\tQ.push(use[*it][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (m < n)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", use[i][0], use[i][1]);\n}\n//"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\t//dmp(s);\n\t\tfor(auto t:adj[s]){\n\t\t\tif(t.fs<=0)return;\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\ta[t.sc]=t.fs;\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\tmatch[btoa[i]]=1;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({btoa[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\n//dmp(sum);\n//assert(sum>=n);\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << a[i] << \" \" << b[i] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005 , S = 0 , T = 200000;\nstruct node{int to,next,val;}e[N<<4];\nint head[N],cnt,dep[N],q[N],c[N],n;\nvoid add(int x,int y,int z){e[cnt]=(node){y,head[x],z};head[x]=cnt++;}\nvoid insert(int x,int y,int z){add(x,y,z),add(y,x,0);}\nint bfs()\n{\n\tint l=0,r=0;q[r++] = S;memset(dep,-1,sizeof(dep));dep[S] = 1;\n\twhile(l<r)\n\t{\n\t\tint x = q[l++];\n\t\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t\t{\n\t\t\tint to1=e[i].to;\n\t\t\tif(dep[to1]==-1&&e[i].val)dep[to1] = dep[x]+1 , q[r++] = to1;\n\t\t}\n\t}return dep[T] != -1;\n}\nint dfs(int x,int maxf)\n{\n\tif(x==T)return maxf;int tflow = maxf , nowf;\n\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t{\n\t\tint to1=e[i].to;\n\t\tif(dep[to1]==dep[x]+1&&e[i].val)\n\t\t{\n\t\t\tnowf = dfs(to1 , min(tflow , e[i].val) );\n\t\t\tif(nowf && x>=1 && x<=n-1 && to1) c[x]=to1-n+2;\n\t\t\te[i].val-=nowf , tflow -= nowf , e[i^1].val += nowf;\n\t\t\tif(!tflow)break;\n\t\t}\n\t}if(tflow)dep[x]=-1;return maxf-tflow;\n}\nvector<int >v[N];\nint Dinic()\n{\n\tint sum = 0;\n\twhile(bfs())sum += dfs(S,1<<30);\n\treturn sum;\n}\nint vis[N];pair<int ,int > ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);memset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint siz; scanf(\"%d\",&siz); insert(S,i,1); insert(n+i-1,T,1);\n\t\tfor(int j=1,x;j<=siz;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x),v[x].push_back(i);\n\t\t\tif(x!=1)insert(i,n+x-2,1);\n\t\t}\n\t}\n\t// puts(\"B\");\n\tif(Dinic()==n-1)\n\t{\n\t\t// puts(\"a\");\n\t\tint l = 0 , r = 0;\n\t\tfor(int i=0;i<v[1].size();i++)\n\t\t\tq[r++] = v[1][i] , vis[v[1][i]] = 1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint x = q[l++]; ans[x] = make_pair(vis[x] , c[x]); x = c[x];\n\t\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\t\tif(!vis[v[x][i]]) q[r++] = v[x][i] , vis[v[x][i]] = x;\n\t\t}\n\t\tif(r==n-1)for(int i=1;i<n;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\telse puts(\"-1\");\n\t}else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int INF=0x3f3f3f3f;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+2*NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tinline void AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int Aug(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tint sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min(e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tint Flow;\n\tint ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c;i<n;i++) {\n\t\tscanf(\"%d\",&c);\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1,u;j<=c;j++) {\n\t\t\tscanf(\"%d\",&u);\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nconst int N=1e5+6,V=2e5+6;\nstruct edge{int v,c,nxt;}g[800003];\nint n,m,head[V],k,iter[V],S,T,d[V],q[V],l,r,f[N],x[N],vis[N];\nstd::vector<int>e[N];\ninline void Insert(int u,int v){\n\tg[k]=(edge){v,1,head[u]},head[u]=k++;\n\tg[k]=(edge){u,0,head[v]},head[v]=k++;\n}\ninline bool Bfs(){\n\tint u,v;\n\tfor(u=1;u<=T;u++)d[u]=0;\n\td[q[l=r=0]=S]=1;\n\tfor(;l<=r;){\n\t  u=q[l++];\n\t  for(int i=head[u];~i;i=g[i].nxt)if(g[i].c&&!d[v=g[i].v])\n\t\td[v]=d[u]+1,q[++r]=v;\n\t}return d[T];\n}\nint Dfs(int u,int f){\n\tif(!f||u==T)return f;\n\tint v,res=0,tmp;\n\tfor(int&i=iter[u];~i;i=g[i].nxt)\n\t  if(g[i].c&&d[v=g[i].v]>d[u]&&(tmp=Dfs(v,std::min(f,g[i].c)))){\n\t\tg[i].c-=tmp,g[i^1].c+=tmp;\n\t\tf-=tmp,res+=tmp;\n\t\tif(!f)return res;\n\t  }\n\treturn res;\n}\ninline int Maxflow(){\n\tint res=0;\n\tfor(;;){\n\t  if(!Bfs())return res;\n\t  for(int u=1;u<=T;u++)iter[u]=head[u];\n\t  res+=Dfs(S,n-1);\n\t}\n}\nvoid Ans(int u){\n\tvis[u]=1;\n\tfor(int i=0;i<e[u].size();i++)if(!vis[f[e[u][i]]])\n\t  x[e[u][i]]=u,Ans(f[e[u][i]]);\n}\nint main(){\n\tint u;\n\tscanf(\"%d\",&n);\n\tS=n+n-1,T=n+n;\n\tfor(u=1;u<=T;u++)head[u]=-1;\n\tfor(int i=1;i<n;i++){\n\t  scanf(\"%d\",&m);\n\t  for(;m--;){\n\t\tscanf(\"%d\",&u);\n\t\tif(u<n)Insert(u,i+n-1);\n\t\te[u].push_back(i);\n\t  }\n\t  Insert(i+n-1,T);\n\t}\n\tfor(u=1;u<n;u++)Insert(S,u);\n\tif(Maxflow()!=n-1)return 0*puts(\"-1\");\n\tfor(int u=1;u<n;u++)\n\t  for(int i=head[u];~i;i=g[i].nxt)if(!g[i].c)\n\t\tf[g[i].v-n+1]=u;\n\tAns(n);\n\tfor(int u=1;u<=n;u++)if(!vis[u])return 0*puts(\"-1\");\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",x[i],f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n  return 0;\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;Gap[0]=n;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\n\nstruct UnionFind // UnionFind Tree (0-indexed)\n{\n    vector<int> par, rank;\n    UnionFind(int N) : par(N), rank(N) { REP(i, N) par[i] = i; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (rank[x] < rank[y]) par[x] = y; else par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    vector<set<int>> ves(N);\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        for (auto v : w) ves[i].insert(v);\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        wm[i] = w[0];\n        for (auto v : w) if (v != w[0]) a.add_edge(i, N + v, 10);\n    }\n    REP(i, N) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    lint mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 9) ans.push_back(pint(wm[from], ed.to - N));\n        }\n\n        if(ans.size() != N - 1) exit(1);\n        UnionFind uf(N + 1);\n        for (auto pa : ans) uf.unite(pa.first, pa.second);\n        REP(i, N) if (!uf.same(1, i + 1)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].first)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].second)) exit(1);\n\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\tint tot = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) {\n\t\t\t\twrite(i), putchar(' ');\n\t\t\t\twrite(par[par[i]]), putchar('\\n');\n\t\t\t\ttot++;\n\t\t\t} \n\t\t}\n\t\tif (tot != n - 1) {\n\t\t\twhile (true) tot++;\n\t\t}\n\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge { int to, cap, rev, id; };\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n    vector<int> level, iter;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n        level = vector<int>(N);\n        iter = vector<int>(N);\n    }\n\n    //0idcap\n    void add_Directed_edge(int from, int to, int cap, int id = -1){\n        G[from].push_back((edge){to, cap, (int)G[to].size(), -1});\n        G[to].push_back((edge){from, 0, (int)G[from].size() - 1, id});\n    }\n\n    void bfs(int s){\n        memset(&level[0], -1, sizeof(level[0]) * level.size());\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while(!que.empty()){\n            int v = que.front(); que.pop();\n            REP(i, G[v].size()){\n                edge &e = G[v][i];\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    int dfs(int v, int t, int f){\n        if(v == t) return f;\n        for(int &i = iter[v]; i < G[v].size(); i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                int d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int max_flow(int s, int t){\n        int flow = 0;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            memset(&iter[0], 0, sizeof(iter[0]) * iter.size());\n            int f;\n            while((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    //max_flow(s, t)\n    vector<int> calc_flow(int max_id){\n        vector<int> flow(max_id + 1, -1);\n        REP(v, N) for(auto e: G[v]) if(e.id >= 0) flow[e.id] = e.cap;\n        return flow;\n    }\n\n};\n\nvoid dfs(int v, vector<pairs> &es, pairs &ans, bools &used){\n    used[v] = true;\n    for(Pii q: es[v]) if(!used[q.f]){\n        ans[q.s] = Pii(v, q.f);\n        dfs(q.f, es, ans, used);\n    }\n}\n\nsigned main(){\n\n    int N; cin >> N;\n    vec c(N - 1);\n    mat w(N - 1);\n    REP(i, N - 1){\n        cin >> c[i];\n        w[i].resize(c[i]);\n        cin >> w[i];\n        REP(j, c[i]) w[i][j]--;\n    }\n\n    Graph G(2 * N + 2);\n    int s = 2 * N, t = s + 1;\n    REP(i, N - 1){\n        G.add_Directed_edge(s, i, 1);\n        G.add_Directed_edge(i + N, t, 1);\n    }\n\n    int e = 0;\n    pairs info;\n    REP(i, N - 1){\n        for(int x: w[i]) if(x != N - 1){\n            G.add_Directed_edge(i, x + N, 1, e);\n            e++;\n            info.pb(Pii(i, x + N));\n        }\n    }\n    int f = G.max_flow(s, t);\n    vec flow = G.calc_flow(e - 1);\n\n    if(f != N - 1){\n        Return(-1);\n    }\n\n    vector<pairs> es(N);\n    REP(k, e) if(flow[k] == 1){\n        int i = info[k].f, x = info[k].s - N;\n        for(int y: w[i]){\n            es[y].pb(Pii(x, i));\n        }\n    }\n    bools used(N, false);\n    pairs ans(N - 1);\n    dfs(N - 1, es, ans, used);\n\n    REP(i, N) if(!used[i]){\n        Return(-1);\n    }\n    REP(i, N - 1) cout << ans[i].f + 1 << \" \" << ans[i].s + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MN 201000\n#define MM 801000\n\nint h[MN], nxt[MM], to[MM], cap[MM], K = 1;\nint iter[MN], d[MN], q[MN], hh = 0, tt = 0;\nstd::vector<int> B[MN];\nint x[MN], y[MN];\nbool used[MN]; int mat[MN];\n\nvoid ins(int u, int v, int c) {nxt[++K] = h[u]; h[u] = K; to[K] = v; cap[K] = c;}\nvoid insw(int u, int v, int c) {ins(u, v, c); ins(v, u, 0);}\n\nbool bfs(int S, int T)\n{\n\tmemset(d, 0, sizeof(d));\n\thh = tt = 0; d[S] = 1; q[tt++] = S;\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t\tif(cap[i] && !d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\tif(to[i] == T) return 1;\n\t\t\t\tq[tt++] = to[i];\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int T, int f)\n{\n\tif(u == T) return f;\n\tint used = 0;\n\tfor(int &i = iter[u]; i; i = nxt[i])\n\t\tif(cap[i] && d[to[i]] == d[u] + 1)\n\t\t{\n\t\t\tint w = dfs(to[i], T, std::min(f - used, cap[i]));\n\t\t\tif(w)\n\t\t\t{\n\t\t\t\tcap[i] -= w; cap[i ^ 1] += w; used += w; \n\t\t\t\tif(used == f) return f;\n\t\t\t}\n\t\t}\n\treturn used;\n}\n\nint dinic(int S, int T)\n{\n\tint flow = 0;\n\twhile(bfs(S, T))\n\t{\n\t\tmemcpy(iter, h, sizeof(h));\n\t\tint f;\n\t\twhile(f = dfs(S, T, 1e9)) flow += f;\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint S = 2 * n, T = S + 1; \n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint o; scanf(\"%d\", &o);\n\t\tfor(int j = 1; j <= o; j++) \n\t\t{\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\tB[k].push_back(i);\n\t\t\tinsw(i, n - 1 + k, 1); \n\t\t}\n\t\tinsw(S, i, 1);\n\t}\n\tfor(int i = n; i < 2 * n; i++) insw(i, T, 1);\n\tif(dinic(S, T) != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = h[i]; j; j = nxt[j])\n\t\t\tif(!cap[j] && n <= to[j] && to[j] < 2 * n) mat[i] = to[j] - n + 1;\n\tfor(int i = 1; i < n; i++) used[mat[i]] = 1;\n\thh = tt = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) q[tt++] = i; \n\tmemset(used, 0, sizeof(used));\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = 0; i < B[u].size(); i++)\n\t\t{\n\t\t\tif(!used[B[u][i]]) \n\t\t\t{\n\t\t\t\tused[B[u][i]] = 1;\n\t\t\t\tx[B[u][i]] = mat[B[u][i]]; y[B[u][i]] = u;\n\t\t\t\tq[tt++] = mat[B[u][i]];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i < n; i++) if(!used[i]) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        ans += dfs(s,t,inf);\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , bel[N] , n;\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 2;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1 ){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t\tbel[e[j].to] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"_-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nconst int N=1e6+5;\nint n,s,ans,now=1,v[N],w[N],cr[N],vi[N],dis[N],nex[N],head[N];\nvoid addedges(int x,int y,int z){\n\tnex[++now]=head[x],w[now]=z;\n\thead[x]=now,v[now]=y;\n}\nvoid add(int x,int y,int z){\n\taddedges(x,y,z);\n\taddedges(y,x,0);\n}\nqueue<int>que;\nbool bfs(){\n\tfor(int i=0;i<=s;i++)\tcr[i]=head[i];\n\tfor(int i=0;i<s;i++)\tdis[i]=0;\n\tdis[s]=1,que.push(s);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tfor(int i=head[x];i;i=nex[i]){\n\t\t\tif(w[i]&&!dis[v[i]]){\n\t\t\t\tdis[v[i]]=dis[x]+1;\n\t\t\t\tque.push(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[0];\n}\nint dfs(int x,int f){\n\tint ans=0;\n\tif(!x||!f)\treturn f;\n\tfor(int &i=cr[x];i;i=nex[i])\n\t\tif(w[i]&&dis[v[i]]==dis[x]+1){\n\t\t\tint d=dfs(v[i],min(w[i],f));\n\t\t\tif(!d)\tcontinue;\n\t\t\tans+=d,w[i]-=d;\n\t\t\tw[i^1]+=d,f-=d;\n\t\t\tif(!f)\tbreak;\n\t\t}\n\tif(!ans)\tdis[x]=-1;\n\treturn ans;\n}\nint bl[N],fa[N];\nvector<int>b[N];\nint main(){\n\tscanf(\"%d\",&n),s=n*2;\n\tfor(int i=1,si,x;i<n;i++){\n\t\tscanf(\"%d\",&si),add(s,i+n,1);\n\t\twhile(si--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tb[x].push_back(i+n);\n\t\t\tif(x!=1)\tadd(i+n,x,1);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\tadd(i,0,1);\n\n\twhile(bfs())\n\twhile(int d=dfs(s,inf))\tans+=d;\n\n\tif(ans!=n-1)\tputs(\"-1\"),exit(0);\n\tfor(int i=n+1;i<s;i++)\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t\tif(!w[j])\tbl[i]=v[j];\n\tque.push(1);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tint si=b[x].size();\n\t\tfor(int i=0;i<si;i++)\n\t\t\tif(!vi[b[x][i]]){\n\t\t\t\tfa[b[x][i]]=x,vi[b[x][i]]=1;\n\t\t\t\tque.push(bl[b[x][i]]);\n\t\t\t}\n\t}\n\tfor(int i=n+1;i<s;i++)\n\t\tprintf(\"%d %d\\n\",fa[i],bl[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU \n// #pragma GCC optimize(\"O3\")  // CPU \n// #pragma GCC optimize(\"unroll-loops\")  // \n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// \n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nvector<int>rev[110000];\nint n;\nvector<int>g[210000];\nint t[210000];\nint L[110000];\nint R[110000];\nvoid dfs(int a){\n\tt[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tint to=g[a][i];\n\t\tif(t[to])continue;\n\t\tif(to<a-1){\n\t\t\tR[to]=a-n+1;\n\t\t}else{\n\t\t\tL[a]=to-n+1;\n\t\t}\n\t\tdfs(to);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t\trev[c].push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=0;i<a-1;i++){\n\t\t// std::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tif(0==v[i][j])continue;\n\t\t\t// printf(\"[%d] [%d]\\n\",i,v[i][j]);\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\t// printf(\"%d %d\\n\",i,to);\n\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\tg[v[i][k]+a-1].push_back(i);\n\t\t\t\t}\n\t\t\t\tg[i].push_back(to);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++)L[i]=R[i]-1;\n\tdfs(a-1);\n\tfor(int i=0;i<a-1;i++){\n\t\tif(L[i]==-1||R[i]==-1){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",L[i]+1,R[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nstruct edge {\n\tint to, cap, rev;\n\n\tedge() {}\n\tedge(int to, int cap, int rev): to(to), cap(cap), rev(rev) {}\n};\n\nstruct max_flow {\n\tint n, S, T;\n\tvector<vector<edge> > g;\n\n\tmax_flow() {}\n\tmax_flow(int N): n(N) { g.resize(N); }\n\tmax_flow(int N, int s, int t): n(N), S(s), T(t) { g.resize(N); }\n\n\tinline void add_edge(int from, int to, int cap) {\n\t\tg[from].push_back(edge(to, cap, g[to].size()));\n\t\tg[to].push_back(edge(from, 0, g[from].size() - 1));\n\t\treturn;\n\t}\n\n\tinline int dinic() {\n\t\tvector<int> dst(n), iter(n);\n\t\tauto bfs = [&]() {\n\t\t\tfill(dst.begin(), dst.end(), -1);\n\t\t\tqueue<int> q;\n\t\t\tq.push(S);\n\t\t\tdst[S] = 0;\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint u = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (auto &e: g[u]) if(e.cap && !~dst[e.to]) dst[e.to] = dst[u] + 1, q.push(e.to);\n\t\t\t}\n\t\t\treturn dst[T] != -1;\n\t\t};\n\t\tint ret = 0;\n\t\twhile(bfs()) {\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tfunction<int(int, int)> dfs = [&](int u, int f) {\n\t\t\t\tif(u == T) return f;\n\t\t\t\tint t = f;\n\t\t\t\tfor (int &i = iter[u]; i < g[u].size(); ++i) {\n\t\t\t\t\tauto &e = g[u][i];\n\t\t\t\t\tif(e.cap && dst[e.to] == dst[u] + 1) {\n\t\t\t\t\t\tint F = dfs(e.to, min(t, e.cap));\n\t\t\t\t\t\te.cap -= F;\n\t\t\t\t\t\tg[e.to][e.rev].cap += F;\n\t\t\t\t\t\tt -= F;\n\t\t\t\t\t\tif(!t) return f;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn f - t;\n\t\t\t};\n\t\t\tstatic const int oo = INT_MAX;\n\t\t\tfor (int f = dfs(S, oo); f; f = dfs(S, oo)) ret += f;\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<vector<int> > apr(n + 1);\n\tmax_flow flow(n * 2, 0, 1);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint sz, foo = i + n;\n\t\tcin >> sz;\n\t\tflow.add_edge(foo, 1, 1);\n\t\tflow.add_edge(0, i + 1, 1);\n\t\twhile(sz--) {\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tflow.add_edge(u, foo, 1);\n\t\t\tapr[u].push_back(foo);\n\t\t}\n\t}\n\tif(flow.dinic() != n - 1) { cout << \"-1\\n\"; return 0; }\n\tvector<int> rem(n * 2, -1), con(n * 2, -1);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u = i + n;\n\t\tfor (auto &e: flow.g[u]) if(e.cap && e.to >= 2 && e.to <= n) rem[u] = e.to;\n\t\tif(!~rem[u]) { cout << \"-1\\n\"; return 0; }\n\t}\n\tqueue<int> q;\n\tq.push(1);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i: apr[u]) if(!~con[i]) {\n\t\t\tq.push(rem[i]);\n\t\t\tcon[i] = u;\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u = i + n;\n\t\tif(!~rem[u] || !~con[u]) { cout << \"-1\\n\"; return 0; }\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tint u = i + n;\n\t\tcout << rem[u] << ' ' << con[u] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\ntemplate<class A, class B> A operator+=(A& l, const B& r) { return l = l+r; }\ntemplate<class A, class B> A operator-=(A& l, const B& r) { return l = l-r; }\ntemplate<class A, class B> A operator*=(A& l, const B& r) { return l = l*r; }\ntemplate<class A, class B> A operator/=(A& l, const B& r) { return l = l/r; }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; trav(a,x) pr(!fst?\", \":\"\",a), fst = 0; \n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); } \n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modInt {\n    T val;\n    T mod = 0;\n    // static const T mod = MOD;\n\n    void normalize() {\n        if (mod == 0) return;\n        val %= mod; if (val < 0) val += mod;\n    }\n    modInt(T v = 0, T m = 0) : val(v), mod(m) { normalize(); }\n    // modInt(T v = 0, T m = 0) : val(v) { normalize(); }\n\n    explicit operator T() const { return val; }\n    friend ostream& operator<<(ostream& os, const modInt& a) { return os << a.val; }\n    friend bool operator==(const modInt& a, const modInt& b) { return a.val == b.val; }\n    friend bool operator!=(const modInt& a, const modInt& b) { return !(a == b); }\n\n    friend void check(modInt& a, modInt& b) { // make sure all operations are valid\n        // comment out if mod is static const\n        if (a.mod > 0 && b.mod > 0) { assert(a.mod == b.mod); return; }\n        T mod = max(a.mod,b.mod); if (mod == 0) mod = MOD;\n        if (a.mod != mod) { a.mod = mod; a.normalize(); }\n        if (b.mod != mod) { b.mod = mod; b.normalize(); }\n    }\n    friend modInt operator+(modInt a, modInt b) {\n        check(a,b); a.val += (T)b;\n        if (a.val >= a.mod) a.val -= a.mod;\n        return a;\n    }\n    friend modInt operator-(modInt a, modInt b) {\n        check(a,b); a.val -= (T)b; \n        if (a.val < 0) a.val += a.mod; \n        return a;\n    }\n    friend modInt operator-(const modInt& a) { return modInt(0)-a; }\n\n    friend modInt operator*(modInt a, modInt b) {\n        check(a,b); a.val = (ll)a.val*(T)b%a.mod; return a;\n    }\n    friend modInt exp(modInt a, ll p) {\n        modInt ans(1,a.mod);\n        for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modInt inv(const modInt& a) {\n        return {invGeneral(a.val,a.mod),a.mod};\n        // return exp(b,b.mod-2) if prime\n    }\n    friend modInt operator/(modInt a, modInt b) { \n        check(a,b); return a*inv(b); \n    }\n};\n\ntypedef modInt<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\ntemplate<int SZ> struct Dinic {\n    struct Edge { int v, rev; ll flow, cap; };\n\n    vector<Edge> adj[SZ];\n\n    void addEdge(int u, int v, ll cap) {\n        Edge a{v, sz(adj[v]), 0, cap}, b{u, sz(adj[u]), 0, 0};\n        adj[u].pb(a), adj[v].pb(b);\n    }\n\n    int ST, EN, level[SZ], ind[SZ];\n\n    bool bfs() { // level = shortest distance from source\n        // after computing flow, edges {u,v} such that level[u] \\neq -1, level[v] = -1 are part of min cut\n        F0R(i,SZ) level[i] = -1, ind[i] = 0;\n        level[ST] = 0;\n\n        queue<int> q; q.push(ST);\n        while (sz(q)) {\n            int u = q.front(); q.pop();\n            trav(e,adj[u]) if (level[e.v] < 0 && e.flow < e.cap) {\n                level[e.v] = level[u] + 1;\n                q.push(e.v);\n            }\n        }\n\n        return level[EN] >= 0;\n    }\n\n    ll sendFlow(int s, ll flow) {\n        if (s == EN) return flow;\n\n        for (  ; ind[s] < sz(adj[s]); ind[s] ++) {\n            Edge& e = adj[s][ind[s]];\n\n            if (level[e.v] != level[s]+1 || e.flow == e.cap) continue;\n            ll f = sendFlow(e.v, min(flow, e.cap - e.flow));\n\n            if (f) { // saturate at least one edge\n                e.flow += f; adj[e.v][e.rev].flow -= f;\n                return f;\n            }\n        }\n\n        return 0;\n    }\n\n    ll maxFlow(int _ST, int _EN) {\n        ST = _ST, EN = _EN;\n        if (ST == EN) return -1;\n        ll tot = 0;\n        while (bfs()) while (auto flow = sendFlow(ST, LLONG_MAX)) tot += flow;\n        return tot;\n    }\n};\n\nDinic<200002> D;\nint N, match[MX];\nbool vis[MX], done[MX];\npi ans[MX];\n\nvoid dfs(int x) {\n    vis[x] = 1;\n    trav(t,D.adj[x+N]) if (t.flow == 0 && 1 <= t.v && t.v < N) {\n        if (!vis[match[t.v]]) {\n            ans[t.v] = {match[t.v],x};\n            dfs(match[t.v]);\n        }\n    }\n}\n\nint main() {\n    setIO(); re(N);\n    FOR(i,1,N) {\n        D.addEdge(0,i,1);\n        int c; re(c); \n        F0R(j,c) {\n            int w; re(w);\n            D.addEdge(i,N+w,1);\n        }\n    }\n    FOR(i,N+1,2*N+1) D.addEdge(i,2*N+1,1);\n    if (D.maxFlow(0,2*N+1) != N-1) {\n        ps(-1);\n        exit(0);\n    }\n    FOR(i,1,N) {\n        trav(t,D.adj[i]) if (N+1 <= t.v && t.v <= 2*N && t.flow > 0) {\n            match[i] = t.v-N;\n            done[match[i]] = 1;\n        }\n    }\n    FOR(i,1,N+1) if (!done[i]) {\n        dfs(i);\n        break;\n    }\n    FOR(i,1,N) if (ans[i].f == 0) {\n        ps(-1);\n        exit(0);\n    }\n    FOR(i,1,N) ps(ans[i].f,ans[i].s);\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define re register int\n#define F(x,y,z) for(re x=y;x<=z;x++)\n#define FOR(x,y,z) for(re x=y;x>=z;x--)\ntypedef long long ll;\n#define I inline void\n#define IN inline int\n#define STS system(\"pause\")\n#define C(x,y) memset(x,y,sizeof(x))\ntemplate<class U>I read(U &res){\n\tres=0;register U g=1;register char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-')g=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)){\n\t\tres=(res<<3)+(res<<1)+(ch^48);\n\t\tch=getchar();\n\t}\n\tres*=g;\n}\nconst int INF=1e9+7;\nvector<int>v[101000];\nstruct E{int to,nt,w;}e[808000];\n#define T e[k].to\nint n,m,p,head[202000],dis[202000],X,tot=-1,S,D,cur[202000];\nint a[202000],b[202000],vis[202000][2];\nqueue<int>q;\nIN B_1(){\n\tC(dis,-1);dis[S]=0;q.push(S);\n\tmemcpy(cur,head,sizeof(head));\n\twhile(!q.empty()){\n\t\tp=q.front();q.pop();\n\t\tfor(re k=head[p];k!=-1;k=e[k].nt){\n\t\t\tif(dis[T]==-1&&e[k].w>0){dis[T]=dis[p]+1;q.push(T);}\n\t\t}\n\t}\n\treturn dis[D]!=-1;\n} \nIN D_1(int x,int lim){\n\tif(x==D||!lim)return lim;\n\tre flow=0,ext;\n\tfor(re &k=cur[x];k!=-1;k=e[k].nt){\n\t\tif(dis[x]+1==dis[T]&&e[k].w>0){\n\t\t\text=D_1(T,min(lim,e[k].w));\n\t\t\tif(!ext)continue;\n\t\t\tflow+=ext;lim-=ext;\n\t\t\te[k].w-=ext;e[k^1].w+=ext;\n\t\t\tif(!lim)break;\n\t\t}\n\t}\n\tif(lim)dis[x]=-1;\n\treturn flow;\n}\nI add(int x,int y,int w){\n\te[++tot].to=y;\n\te[tot].nt=head[x];\n\thead[x]=tot;\n\te[tot].w=w;\n\te[++tot].to=x;\n\te[tot].nt=head[y];\n\thead[y]=tot;\n\te[tot].w=0;\n}\nIN dinic(){re res=0;while(B_1())res+=D_1(S,INF);return res;}\nint main(){\n\tread(n);tot=-1;C(head,-1);S=0;D=(n<<1);\n\tF(i,1,n-1){\n\t\tread(m);add(S,n+i,1);add(i,D,1);\n\t\tF(j,1,m){read(X);add(n+i,X,1);v[X].emplace_back(i);}\n\t}\n\tadd(n,D,1);\n\tif(dinic()<n-1){cout<<\"-1\";return 0;}\n\tF(i,1,n-1){\n\t\tfor(re k=head[n+i];k!=-1;k=e[k].nt){\n\t\t\tif(T&&(!e[k].w))a[i]=T,vis[T][0]=1;\n\t\t}\n\t}\n\tF(i,1,n)if(!vis[i][0])q.push(i);\n\tm=0;\n\twhile(!q.empty()){\n\t\tp=q.front();q.pop();m++;\n\t\tfor(auto k:v[p]){\n\t\t\tif(!vis[k][1]){vis[k][1]=1;b[k]=p;q.push(a[k]);}\n\t\t}\n\t}\n\tif(m<n){cout<<\"-1\";return 0;}\n\tF(i,1,n-1)cout<<a[i]<<\" \"<<b[i]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline int solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\tint link = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tlink++;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn link;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif (solve() < n - 1) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 8e5 + 10, maxm = maxn;\nint to[maxm], nxt[maxm], head[maxn], cap[maxm], e, dep[maxn], flow[maxm], vis[maxn], s, t, cur[maxn];\npair<int, int> p[maxn];\n\nvoid add(int x, int y, int z)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0;\n}\n\nint bfs()\n{\n\tfor(int i = s; i <= t; ++i) dep[i] = 0;\n\tqueue<int> Q;\n\tdep[s] = 1; Q.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(!dep[v] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dep[t]) \n\t{\n\t\tfor(int i = s; i <= t; ++i) cur[i] = head[i];\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint dfs(int x, int a)\n{\n\tif(x == t || a == 0) return a;\n\tint FLOW = 0, f;\n\tfor(int &i = cur[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif(dep[v] == dep[x] + 1 && (f = dfs(v, min(a, cap[i] - flow[i]))) > 0)\n\t\t{\n\t\t\tFLOW += f;\n\t\t\ta -= f;\n\t\t\tflow[i] += f; flow[i ^ 1] -= f;\n\t\t\tif(!a) return FLOW;\n\t\t}\n\t}\n\treturn FLOW;\n}\n\nint main()\n{\n\n\tint n = read();\n\te = 1; s = 0; t = n + n;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint m = read();\n\t\tfor(int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\n\tfor(int i = 2; i <= n; ++i) add(s, i, 1);\n\tfor(int i = n + 1; i <= n + n - 1; ++i) add(i, t, 1);\n\n\tint All = 0;\n\twhile(bfs()) All += dfs(s, 0x3f3f3f3f);\n\tif(All != n - 1) return puts(\"-1\"), 0;\n\tfor(int u = 2; u <= n; ++u)\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(cap[i] == flow[i] && to[i] != s)\n\t\t\tp[to[i]].x = u;\n\n\tqueue<int> Q; Q.push(1);\n\tint fg = n - 1;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(to[i] != s && !vis[to[i]])\n\t\t\tp[to[i]].y = u, vis[to[i]] = 1, Q.push(p[to[i]].x), --fg;\n\t}\n\tif(fg) return puts(\"-1\"), 0;\n\n\tfor(int i = n + 1; i <= n + n - 1; ++i) printf(\"%d %d\\n\", p[i].x, p[i].y);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\n// O(V^2 E)\nstruct Dinic {\n    using F = ll;\n    static constexpr F INF = numeric_limits<F>::max();\n\n    struct Edge {\n        int to, rev;\n        F cap;\n        Edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev){};\n    };\n\n    using E = Edge;\n\n    VV<E> g;\n    V<int> level, iter;\n\n    Dinic() {}\n    Dinic(int n) : g(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, F cap) {\n        g[from].emplace_back(to, cap, (int)g[to].size());\n        g[to].emplace_back(from, 0, (int)g[from].size() - 1);\n    }\n\n    void bfs(int s) {\n        fill(ALL(level), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (auto& e : g[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    F dfs(int v, int t, F f) {\n        if (v == t) return f;\n        for (int& i = iter[v]; i < g[v].size(); i++) {\n            auto& e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                F d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    F max_flow(int s, int t) {\n        F flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(ALL(iter), 0);\n            F f;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    VV<int> E(N);\n    rep(i, N - 1) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int x;\n            cin >> x;\n            --x;\n            E[i].pb(x);\n        }\n    }\n\n    rep(r, N) {  // special\n        Dinic flow(N + N + 2);\n        int s = N * 2, t = s + 1;\n        rep(i, N - 1) {\n            flow.add_edge(i + N, t, 1);\n            for (int x : E[i])\n                if (x != r) {\n                    flow.add_edge(x, i + N, 1);\n                }\n        }\n        rep(i, N) { flow.add_edge(s, i, 1); }\n        int f = flow.max_flow(s, t);\n        if (f != N - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct Edge {\n  int t,f,next;\n  Edge() {}\n  Edge(int a,int b,int c):t(a),f(b),next(c) {}\n};\n\nEdge e[1000000];\nint head[200005],vs,vt,tot=-1;\n\ninline void addEdge(int x,int y,int z) {\n  e[++tot]=Edge(y,z,head[x]);\n  head[x]=tot;\n  e[++tot]=Edge(x,0,head[y]);\n  head[y]=tot;\n}\n\nnamespace Flow {\n\t\nint d[200005],cur[200005];\nqueue <int> q;\n\nbool bfs() {\n  while (!q.empty()) q.pop();\n  memset(d,255,sizeof(d));\n  d[vs]=0;cur[vs]=head[vs];\n  q.push(vs);\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tfor(int i=head[x];i!=-1;i=e[i].next)\n  \t  if (e[i].f&&d[e[i].t]==-1) {\n  \t  \t  int u=e[i].t;\n  \t  \t  d[u]=d[x]+1;\n  \t  \t  cur[u]=head[u];\n  \t  \t  if (u==vt) return 1;\n  \t  \t  q.push(u);\n\t\t}\n  }\n  return 0;\n}\n\nint dfs(int x,int a) {\n  if (x==vt||!a) return a;\n  int ans=0;\n  for(int &i=cur[x];i!=-1;i=e[i].next)\n    if (e[i].f&&d[e[i].t]==d[x]+1) {\n    \tint u=e[i].t;\n    \tint f=dfs(u,min(a,e[i].f));\n    \tif (f) {\n    \t\te[i].f-=f;\n    \t\te[i^1].f+=f;\n    \t\tans+=f;\n    \t\ta-=f;\n    \t\tif (!a) break;\n\t\t}\n\t}\n  return ans;\n} \n\nint maxflow() {\n  int ans=0;\n  while (bfs())\n    ans+=dfs(vs,inf);\n  return ans;\n}\n\t\n}\n\nvector <int> bel[100005];\nbool vis1[100005],vis2[100005];\nint id[100005],nxt[100005];\n\nqueue <int> q;\n\nbool solve(int n) {\n  for(int i=1;i<n;i++)\n    for(int j=head[n+i];j!=-1;j=e[j].next)\n      if (e[j].t&&!e[j].f) {\n      \tint u=e[j].t;\n      \tid[i]=u;\n      \tvis1[u]=1;\n\t  }\n  for(int i=1;i<=n;i++)\n    if (!vis1[i]) q.push(i);\n  int cnt=0;\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tcnt++;\n  \tfor(int i=0;i<bel[x].size();i++)\n  \t  if (!vis2[bel[x][i]]) {\n  \t  \t  int u=bel[x][i];\n  \t  \t  vis2[u]=1;\n  \t  \t  nxt[u]=x;\n  \t  \t  q.push(id[u]);\n\t\t}\n  }\n  return cnt==n;\n}\n\nint main() {\n  memset(head,255,sizeof(head));\n  int n;\n  scanf(\"%d\",&n);\n  vs=0;vt=2*n;\n  for(int i=1;i<n;i++) {\n  \tint x;\n  \tscanf(\"%d\",&x);\n  \taddEdge(vs,n+i,1);\n  \tfor(int j=1;j<=x;j++) {\n  \t\tint y;\n  \t\tscanf(\"%d\",&y);\n  \t\taddEdge(n+i,y,1);\n  \t\tbel[y].push_back(i);\n\t  }\n  }\n  for(int i=1;i<=n;i++) addEdge(i,vt,1);\n  if (Flow::maxflow()<n-1) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  if (!solve(n)) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  for(int i=1;i<n;i++) printf(\"%d %d\\n\",id[i],nxt[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,F[N],vis[N];\nvector<int> go[N];\n\nnamespace flow {\n\tconst int V = 200020, E = 1000004;\n\tint S, T, tot = 1, fst[V], nxt[E], to[E], flow[E], lvl[V];\n\t\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; flow[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; flow[tot] = 0;\n\t}\n\t\n\tint bfs() {\n\t\tqueue<int> q;\n\t\tfor(int i = 0; i <= T; i ++)\n\t\t\tlvl[i] = 0;\n\t\tq.push(S); lvl[S] = 1;\n\t\tint u, v;\n\t\twhile (!q.empty()) {\n\t\t\tu = q.front(); q.pop();\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (flow[i] && !lvl[v = to[i]]) {\n\t\t\t\t\tlvl[v] = lvl[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t}\n\t\treturn lvl[T];\n\t}\n\t\n\tint dinic(int u, int f) {\n\t\tif (u == T)\n\t\t\treturn f;\n\t\tint v, k = f;\n\t\tfor (int i = fst[u]; i && k; i = nxt[i])\n\t\t\tif (flow[i] && lvl[v = to[i]] == lvl[u] + 1) {\n\t\t\t\tint t = dinic(v, min(k, flow[i]));\n\t\t\t\tif (!t)\n\t\t\t\t\tlvl[v] = 0;\n\t\t\t\telse\n\t\t\t\t\tk -= t, flow[i] -= t, flow[i ^ 1] += t;\n\t\t\t}\n\t\treturn f - k;\n\t}\n\t\n\tint mf() {\n\t\tint res = 0;\n\t\twhile(bfs()) res += dinic(S, 2e9);\n\t\treturn res;\n\t}\n\t\n\tvoid getmatch() {\n\t\tfor(int s = 1; s < n; ++s)\n\t\t\tfor(int i = fst[s]; i; i = nxt[i])\n\t\t\t\tif(to[i] != S && !flow[i]) {\n\t\t\t\t\tF[s] = to[i] - n; break;\n\t\t\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tflow::S=2*n+1;\n\tflow::T=2*n+2;\n\tfor(int i=1,d,x; i<n; i++)\n\t{\n\t\tflow::addedge(flow::S,i,1);\n\t\tscanf(\"%d\",&d);\n\t\tfor(int j=1; j<=d; ++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tgo[x].push_back(i);\n\t\t\tif(x!=1)\n\t\t\t\tflow::addedge(i,n+x,1);\n\t\t}\n\t}\n\tfor(int i=2; i<=n; i++)\n\t\tflow::addedge(n+i,flow::T,1);\n\tint f=flow::mf();\n\tif(f<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tflow::getmatch();\n\tvector<pair<int,int>> out;\n\tout.resize(n);\n\tqueue<int> q;\n\tq.push(1);\n\tvis[1]=true;\n\twhile(!q.empty()) {\n\t\tint u=q.front(); q.pop();\n\t\tfor(auto &v:go[u]) if(!vis[F[v]]) {\n\t\t\tvis[F[v]]=true;\n\t\t\tout[v]=make_pair(u,F[v]);\n\t\t\tq.push(F[v]);\n\t\t}\n\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tif(!p->first){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tprintf(\"%d %d\\n\",p->first,p->second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;\n}E[MAXN * 20];\nint N,head[MAXN * 2],sumE = 1,S,T,tot,lev[MAXN * 2],cur[MAXN * 2],ch[MAXN],fa[MAXN];\nvector<int> v[MAXN];\nbool vis[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c) {\n    add(u,v,c);add(v,u,0);\n}\nbool BFS() {\n    static int que[MAXN * 2],ql,qr;\n    que[ql = qr = 1] = S;\n    for(int i = 1 ; i <= T ; ++i) lev[i] = -1,cur[i] = head[i];\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    int v = E[i].to;\n\t    if(E[i].cap > 0 && lev[v] == -1) {\n\t\tlev[v] = lev[u] + 1;\n\t\tif(v == T) return true;\n\t\tque[++qr] = v;\n\t    }\n\t}\n    }\n    return false;\n}\nint dfs(int u,int aug) {\n    if(u == T) return aug;\n    int flow = 0;\n    for(int &i = cur[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(E[i].cap > 0 && lev[v] > lev[u]) {\n\t    int t = dfs(v,min(E[i].cap,aug - flow));\n\t    flow += t;E[i].cap -= t;E[i ^ 1].cap += t;\n\t    if(flow == aug) break;\n\t}\n    }\n    if(flow != aug) lev[u] = -1;\n    return flow;\n}\nint Dinic() {\n    int res = 0;\n    while(BFS()) {\n\tres += dfs(1,0x7fffffff);\n    }\n    return res;\n}\nvoid Init() {\n    read(N);\n    S = 1;\n    for(int i = 1 ; i < N ; ++i) {\n\taddtwo(S,i + N,1);\n\tint c,w;\n\tread(c);\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    read(w);\n\t    if(w != 1) addtwo(i + N,w,1);\n\t    v[w].pb(i);\n\t}\n    }\n    T = 2 * N;\n    for(int i = 2 ; i <= N ; ++i) addtwo(i,T,1);\n}\nvoid construct() {\n    static int que[MAXN],ql,qr;\n    que[ql = qr = 1] = 1;\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(auto t : v[u]) {\n\t    if(!vis[t]) {\n\t\tvis[t] = 1;\n\t\tfa[ch[t]] = u;\n\t\tque[++qr] = ch[t];\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    if(Dinic() != N - 1) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= N - 1 ; ++i) {\n\tint u = i + N;\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(v > 1 && E[j].cap == 0) {ch[i] = v;break;}\n\t}\n    }\n    construct();\n    for(int i = 1 ; i < N ; ++i) {\n\tif(!vis[i]) {puts(\"-1\");return;}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tout(fa[ch[i]]);space;out(ch[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>ans[200005];\nint beg = -1;\nbool in[400005];\n\n//O(E sqrt V)\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph, rev;\n  vector< int > dist, match, revmatch;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), rev(m), match(m, -1), revmatch(n,-1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    rev[v].push_back(u);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        revmatch[a] = b;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n  \n  void put_ans() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        ans[match[i]].pb(i);\n      }\n      else{\n      \tbeg = i;\n      }\n    }\n  }\n  \n  void DFS(int cur,bool right){\n      //cout << cur << \" \" << right << endl;\n  \tif(right){\n  \t\t\n  \t\tfor(int i=0;i<rev[cur].size();i++){\n  \t\t\tif(match[cur] == rev[cur][i]) continue;\n  \t\t\tint to = rev[cur][i];\n  \t\t\t//cout << to << endl;\n  \t\t\tif(in[to]) continue;\n  \t\t\tin[to] = 1;\n  \t\t\tans[to].pb(cur);\n  \t\t\t//cout << to << \" \" << cur << endl;\n  \t\t\t//cout << to << endl;\n  \t\t\tDFS(to,false);\n  \t\t}\n  \t}\n  \telse{\n  \t\t\n\t\tfor(int i=0;i<graph[cur].size();i++){\n  \t\t\tif(match[graph[cur][i]] != cur) continue;\n  \t\t\tint to = graph[cur][i];\n  \t\t\tif(in[to+200001]) continue;\n  \t\t\tin[to+200001] = 1;\n  \t\t\tDFS(to,true);\n  \t\t}\n  \t}\n  }\n};\n\nint n;\nvector<int>vec[200005];\n\nint par[200005],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tHopcroftKarp bm(n-1,n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\trep(j,a){\n\t\t\tint x; scanf(\"%d\",&x); x--;\n\t\t\tvec[i].pb(x);\n\t\t\tbm.add_edge(i,x);\n\t\t}\n\t}\n\tint v = bm.bipartite_matching(); \n\tbm.put_ans();\n\tif(beg != -1) bm.DFS(beg,true);\n\tinit();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ans[i].size() != 2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tint x = ans[i][0], y = ans[i][1];\n\t\tif(same(x,y)){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tunite(x,y);\n\t}\n//\tputs(\"YES\");\n\trep(i,n-1) cout << ans[i][0]+1 << \" \" << ans[i][1]+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint n,S,T,fir[200010],head[200010],dep[200010],dis[1000010],nxt[1000010],w[1000010],id=1;\nvoid link(int a,int b,int c){\n\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c;\n\tnxt[++id]=fir[b],fir[b]=id,dis[id]=a,w[id]=0;\n}\nint que[200010],hd,tl,el[100010];\nstd::vector<pr>E[100010];\nbool BFS(){\n\thd=tl=0;memset(dep,0,sizeof dep);\n\tdep[S]=1;que[tl++]=S;\n\twhile(hd^tl){\n\t\tint x=que[hd++];\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t\tif(w[i]&&!dep[dis[i]])\n\t\t\t\tdep[dis[i]]=dep[x]+1,que[tl++]=dis[i];\n\t}\n\treturn dep[T];\n}\nint Dinic(int x,int maxflow){\n\tif(x==T)return maxflow;\n\tint ret=0;\n\tfor(int&i=head[x];i;i=nxt[i])\n\t\tif(w[i]&&dep[dis[i]]==dep[x]+1){\n\t\t\tint d=Dinic(dis[i],std::min(maxflow-ret,w[i]));\n\t\t\tw[i]-=d,w[i^1]+=d,ret+=d;if(ret==maxflow)break;\n\t\t}\n\treturn ret;\n}\nint match[100010],fa[100010],set[1000010];\nint ax[100010],ay[100010];\nvoid DFS(int x){\n\tfor(int i=fir[x];i;i=nxt[i])\n\t\tif(w[i]&&dis[i]!=S&&!fa[match[dis[i]-n]]){\n\t\t\tfa[match[dis[i]-n]]=x;\n\t\t\tset[match[dis[i]-n]]=dis[i]-n;\n\t\t\tDFS(match[dis[i]-n]);\n\t\t}\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi();\n\tfor(int i=1;i<n;++i){\n\t\tint o=gi(),x;E[i].resize(o);\n\t\tfor(int j=0;j<o;++j)link(x=gi(),i+n,1),E[i][j]={id,x};\n\t}\n\tS=n+n,T=n+n+1;\n\tfor(int i=1;i<=n;++i)link(S,i,1),el[i]=id;\n\tfor(int i=n+1;i<n+n;++i)link(i,T,1);\n\tint flow=0;\n\twhile(BFS())memcpy(head,fir,sizeof head),flow+=Dinic(S,1e9);\n\tif(flow<n-1)puts(\"-1\"),exit(0);\n\tint r=0;\n\tfor(int i=1;i<=n;++i)if(!w[el[i]])r=i;\n\tfor(int i=1;i<n;++i)for(pr j:E[i])if(w[j.fi])match[i]=j.se;\n\tfa[r]=-1;DFS(r);\n\tint cnt=0;for(int i=1;i<=n;++i)cnt+=!!fa[i];\n\tif(cnt<n)puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;++i)if(~fa[i])ax[set[i]]=i,ay[set[i]]=fa[i];\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ax[i],ay[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fa[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[dy[y]]) {\n\t\t\tfa[dy[y]] = x;\n\t\t\tdfs(dy[y]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t}\n\tfor(int i=n-1;i>=0;--i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nint cur;\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v] == cur) {\n        return false;\n    }\n    used[v] = cur;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int i = 0; i + 1 < n; ++i) {\n        ++cur;\n        dfs(i);\n    }\n    /*for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }*/\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MN = 200010;\n\nint N;\nvector<int> adj[MN];\nint vis[MN], U[MN], V[MN];\n\nvoid dfs(int u) {\n    vis[u] = 1;\n\n    for(int i = 0; i < adj[u].size(); i++) {\n        int v = adj[u][i];\n        if(vis[v]) continue;\n        if(u < N) {\n            U[v - N] = u;\n            dfs(v);\n        }\n        else {\n            V[u - N] = v;\n            dfs(v);\n            return;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n\n    for(int i = 0; i < N - 1; i++) {\n        int k; scanf(\"%d\", &k);\n\n        for(int j = 0; j < k; j++) {\n            int t; scanf(\"%d\", &t);\n            t--;\n\n            adj[N + i].push_back(t);\n            adj[t].push_back(N + i);\n        }\n    }\n\n    memset(U, -1, sizeof(U));\n    memset(V, -1, sizeof(V));\n    dfs(0);\n    for(int i = 0; i < N - 1; i++) if(U[i] == -1 || V[i] == -1) {\n        printf(\"-1\");\n        return 0;\n    }\n    for(int i = 0; i < N - 1; i++) {\n        printf(\"%d %d\\n\", U[i] + 1, V[i] + 1);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nconst int N = 100179;\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define SZ 2333333\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define ad_de ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n;\nvector<int> t[SZ],g[SZ];\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t\tsort(t[i].begin(),t[i].end());\n\t}\n\tN=n+n-1+2; S=N-1; T=N;\n\tfor(int i=2;i<=n;++i)\n\t\tad_de(S,i,1);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\tad_de(t[i][j],i+n,1),g[i].pb(M);\n\t\tad_de(i+n,T,1);\n\t}\n\tint s=dinic();\n\tif(s!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\tif(cap[g[i][j-1]])\n\t\t\t\tprintf(\"%d %d\\n\",t[i][0],t[i][j]);\n}"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa, adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005];\nvoid bfstree(int s){\n\tqueue<int > q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\tfor(auto t:adj[s]){\n\t\t\tif(!vis[t]){\n\t\t\t\tif(dist[t]>=dist[s]+1){\n\t\t\t\t\tq.push(t);\n\t\t\t\t\tp[t]=s;\n\t\t\t\t\tdist[t]=dist[s]+1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\tmatch[btoa[i]]=1;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb(btoa[i]);\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << btoa[i] << \" \" << p[btoa[i]] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, M = 8e5 + 5;\n\nstruct edge_t { int u, v, next, cap, flow; } G[M];\n\nvector <int> adj[N];\nqueue <int> q;\nint head[N], nowhead[N], d[N];\nint n, m, s, t, tot = 1;\n\ninline void addedge(int u, int v, int cap) {\n\tG[++tot] = (edge_t) {u, v, head[u], cap, 0}, head[u] = tot;\n\tG[++tot] = (edge_t) {v, u, head[v], 0, 0}, head[v] = tot;\n}\n\nint bfs() {\n\tmemset(d, 0, sizeof(d));\n\td[s] = 1; q.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (!d[v] && G[i].cap > G[i].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\n\nint dfs(int u, int Flow) {\n\tif (u == t || !Flow) return Flow;\n\tint f, flow = 0;\n\tfor (int &i = nowhead[u]; i; i = G[i].next) {\n\t\tint v = G[i].v;\n\t\tif (d[v] == d[u] + 1 && (f = dfs(v, min(Flow, G[i].cap - G[i].flow))) > 0) {\n\t\t\tG[i].flow += f; G[i ^ 1].flow -= f;\n\t\t\tflow += f; Flow -= f;\n\t\t\tif (!Flow) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint dinic() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemcpy(nowhead, head, sizeof(nowhead));\n\t\tans += dfs(s, 0x7fffffff);\n\t}\n\treturn ans;\n}\n\nint fa[N], vis[N], match[N], cnt;\n\nvoid dfs1(int u) {\n\tfor (auto v : adj[u]) {\n\t\tif (!vis[match[v]]) {\n\t\t\tvis[match[v]] = 1;\n\t\t\tfa[match[v]] = u;\n\t\t\t++cnt;\n\t\t\tdfs1(match[v]);\n\t\t}\n\t}\n}\n\nint main() {\n\tread(n); s = 0; t = 2 * n;\n\tfor (int i = 1; i < n; i++) {\n\t\tread(m);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x; read(x);\n\t\t\tadj[i].push_back(x + n - 1);\n\t\t\tadj[x + n - 1].push_back(i);\n\t\t\taddedge(i, x + n - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) addedge(s, i, 1);\n\tfor (int i = n; i < 2 * n; i++) addedge(i, t, 1);\n\tif (dinic() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint rt = 0;\n\tfor (int i = head[n * 2]; i; i = G[i].next) {\n\t\tif (G[i].flow == 0) {\n\t\t\trt = G[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int u = 1; u < n; u++) {\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (n <= v && v < n * 2 && G[i].flow) match[u] = v;\n\t\t}\n\t}\n\tvis[rt] = 1; dfs1(rt);\n\tif (cnt != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tprint(match[i] - n + 1, ' ');\n\t\tprint(fa[match[i]] - n + 1, '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\treturn 0;\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=1600010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nint lst[200005], to[2000005], pre[2000005], cap[2000005], tot;\nint dep[200005], que[200005], fst[200005];\ninline void add_edge(int u, int v, int _cap)\n{\n\t// printf(\"%d %d %d\\n\", u, v, _cap);\n\tauto add = [&] (int x, int y, int c)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = c;\n\t\tlst[x] = tot++;\n\t};\n\tadd(u, v, _cap);\n\tadd(v, u, 0);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tint he = 0, ta = 0;\n\tque[ta++] = s;\n\twhile (he < ta)\n\t{\n\t\tint u = que[he++];\n\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t{\n\t\t\tif (cap[i] && dep[to[i]] == -1)\n\t\t\t{\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t\tque[ta++] = to[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tint ans = 0;\n\tfor (int i = fst[u]; ~i; i = pre[i])\n\t{\n\t\tif (cap[i] && dep[to[i]] == dep[u] + 1)\n\t\t{\n\t\t\tint res = dfs(to[i], t, std::min(rem - ans, cap[i]));\n\t\t\tcap[i] -= res;\n\t\t\tcap[i ^ 1] += res;\n\t\t\tif (cap[i])\n\t\t\t\tfst[u] = i;\n\t\t\tans += res;\n\t\t\tif (ans == rem)\n\t\t\t\treturn ans;\n\t\t}\n\t}\n\tif (!ans)\n\t\tdep[u] = -1;\n\treturn ans;\n}\ninline int dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t))\n\t{\n\t\tmemcpy(fst, lst, sizeof(lst));\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nstd::vector<int> vec[200005], bel[200005];\nint fa[200005], rep[200005];\nbool vis[200005];\nint add(int u)\n{\n\tint res = 1;\n\tvis[u] = true;\n\tfor (int x : bel[u])\n\t{\n\t\tif (!vis[rep[x]])\n\t\t{\n\t\t\tfa[x] = u;\n\t\t\tres += add(rep[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC029-F.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint len;\n\t\tscanf(\"%d\", &len);\n\t\twhile (len--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tif (--u)\n\t\t\t\tadd_edge(i + 1, u + n - 1, 1);\n\t\t\tvec[i].pb(u);\n\t\t\tbel[u].pb(i);\n\t\t}\n\t\tadd_edge(0, i + 1, 1);\n\t\tadd_edge(i + n, n + n, 1);\n\t}\n\tif (dinic(0, n + n) != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = lst[i]; ~j; j = pre[j])\n\t\t{\n\t\t\tif (to[j] && !cap[j])\n\t\t\t\trep[i - 1] = to[j] - n + 1;\n\t\t}\n\t}\n\tif (add(0) != n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", fa[i] + 1, rep[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 2e5+5;\n\ntypedef ll Flow;\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\n\nstruct PushRelabel {\n\tvector<vector<Edge>> g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\n\nint n, m[MAXN], r[MAXN];\nvector<int> e[MAXN], g[MAXN];\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tPushRelabel mf(2*n+1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tmf.add_edge(0, i+1, 1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tmf.add_edge(i+1, x+n, 1);\n\tfor (int i = n; i < 2*n; ++i)\n\t\tmf.add_edge(i, 2*n, 1);\n\tint fl = mf.maxflow(0, 2*n);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\treturn 0;\n\tauto h = mf.g;\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 1) {\n\t\t\t\tm[i] = e.dest-n;\n\t\t\t\tr[e.dest-n] = i;\n\t\t\t\ts -= (e.dest - n);\n\t\t\t\t// cout << i << ' ' << m[i]+1 << endl;\n\t\t\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 0) {\n\t\t\t\t// cout << e.dest - n << ' ' << m[i] << endl;\n\t\t\t\tg[e.dest - n].push_back(m[i]);\n\t\t\t}\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e5 + 10;\nconst int INF = 1e9;\n\nstruct Edge {\n  int u, v, cap, flow;\n};\n\nnamespace Max_flow {\n\nvector<Edge> E;\nvector<int> G[N];\n\nint S, T, n, d[N];\n\nvoid init(int _n, int _s, int _t) {\n  n = _n, S = _s, T = _t;\n  for (int i = 0; i <= n; i++) G[i].clear();\n  E.clear();\n}\n\nvoid addedge(int u, int v, int cap) {\n  E.push_back((Edge) {u, v, cap, 0});\n  E.push_back((Edge) {v, u, 0, 0});\n  int m = E.size();\n  G[u].push_back(m - 2);\n  G[v].push_back(m - 1);\n}\n\nbool bfs() {\n  for (int i = 0; i <= n; i++) d[i] = 0;\n  d[S] = 1;\n  queue<int> q;\n  q.push(S);\n  while (q.size()) {\n    int u = q.front(); q.pop();\n    for (int i : G[u]) {\n      if (E[i].cap > E[i].flow && !d[E[i].v]) {\n        d[E[i].v] = d[u] + 1;\n        q.push(E[i].v);\n      }\n    }\n  }\n  return d[T];\n}\n\nint dfs(int u, int a) {\n  if (!a || u == T) return a;\n  int flow = 0;\n  for (int i : G[u]) {\n    if (d[E[i].v] != d[u] + 1) continue;\n    int f = dfs(E[i].v, min(E[i].cap - E[i].flow, a));\n    flow += f;\n    a -= f;\n    E[i].flow += f;\n    E[i ^ 1].flow -= f;\n  }\n  if (!flow) d[u] = 0;\n  return flow;\n}\n\nint max_flow() {\n  int flow = 0;\n  while (bfs()) {\n    flow += dfs(S, INF);\n  }\n  return flow;\n}\n\n}\n\nint n, c[N], p[N], q[N], vis[N];\nvector<int> g[N], bel[N];\n\nint main() {\n  scanf(\"%d\", &n);\n  Max_flow::init(2 * n + 1, 0, 2 * n + 1);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d\", &c[i]);\n    g[i].resize(c[i]);\n    Max_flow::addedge(0, i, 1);\n    for (int j = 0; j < c[i]; j++) {\n      scanf(\"%d\", &g[i][j]);\n      bel[g[i][j]].push_back(i);\n      Max_flow::addedge(i, g[i][j] + n, 1);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    Max_flow::addedge(i + n, 2 * n + 1, 1);\n  }\n  if (Max_flow::max_flow() != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (Edge e : Max_flow::E) {\n    if (e.u <= n && e.v > n && e.cap == e.flow) {\n      p[e.u] = e.v - n;\n      vis[e.v - n] = 1;\n    }\n  }\n  queue<int> tmp;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) tmp.push(i);\n    vis[i] = 0;\n  }\n  int cnt = 0;\n  while (tmp.size()) {\n    cnt++;\n    int u = tmp.front(); tmp.pop();\n    for (int i : bel[u]) if (!vis[i]) {\n      vis[i] = 1;\n      q[i] = u;\n      tmp.push(p[i]);\n    }\n  }\n  if (cnt != n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", p[i], q[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nbitset<maxn> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    auto o = (q[x] & q[y]);\n    for (int i = o._Find_first(); i < o.size(); i = o._Find_next(i)) {\n        g.erase({d[i], i});\n        d[i]--;\n        g.insert({d[i], i});\n    }\n    q[x] |= q[y];\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (w != tos) {\n                y = i;\n                break;\n            }\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 2333333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t}\n\tfor(int i=n-1;i>=0;--i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n/*\nstruct E {\n    int to, rev, cap;\n};\nVV<E> g;\nauto add_edge = [&](int from, int to, int cap) {\n    g[from].push_back(E{to, int(g[to].size()), cap});\n    g[to].push_back(E{from, int(g[from].size())-1, 0});\n};\n*/\n\ntemplate<class C>\nstruct MaxFlow {\n    C flow;\n    V<char> dual;  // false: S-side true: T-side\n};\n\ntemplate<class C, class E>\nstruct MFExec {\n    static constexpr C INF = numeric_limits<C>::max();\n    C eps;\n    VV<E>& g;\n    int s, t;\n    V<int> level, iter;\n\n    C dfs(int v, C f) {\n        if (v == t) return f;\n        C res = 0;\n        for (int& i = iter[v]; i < int(g[v].size()); i++) {\n            E& e = g[v][i];\n            if (e.cap <= eps || level[v] >= level[e.to]) continue;\n            C d = dfs(e.to, min(f, e.cap));\n            e.cap -= d;\n            g[e.to][e.rev].cap += d;\n            res += d;\n            f -= d;\n            if (f == 0) break;\n        }\n        return res;\n    }\n\n    MaxFlow<C> info;\n    MFExec(VV<E>& _g, int _s, int _t, C _eps)\n            : eps(_eps), g(_g), s(_s), t(_t) {\n        int N = int(g.size());\n\n        C& flow = (info.flow = 0);\n        while (true) {\n            queue<int> que;\n            level = V<int>(N, -1);\n            level[s] = 0;\n            que.push(s);\n            while (!que.empty()) {\n                int v = que.front(); que.pop();\n                for (E e: g[v]) {\n                    if (e.cap <= eps || level[e.to] >= 0) continue;\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n            if (level[t] == -1) break;\n            iter = V<int>(N, 0);\n            while (true) {\n                C f = dfs(s, INF);\n                if (!f) break;\n                flow += f;\n            }\n        }\n        for (int i = 0; i < N; i++) info.dual.push_back(level[i] == -1);\n    }\n};\n\ntemplate<class C, class E>\nMaxFlow<C> get_mf(VV<E>& g, int s, int t, C eps) {\n    return MFExec<C, E>(g, s, t, eps).info;\n}\n\nvoid imp() {\n    cout << -1 << endl;\n    exit(0);\n}\n\nstruct E {\n    int to, rev, cap;\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << setprecision(20) << fixed;\n    int n;\n    cin >> n;\n    int v = n + n - 1 + 2;\n    VV<E> g(v);\n    int sv = n + n - 1, tv = sv + 1;\n\n    auto add_edge = [&](int from, int to, int cap) {\n        g[from].push_back(E{to, int(g[to].size()), cap});\n        g[to].push_back(E{from, int(g[from].size())-1, 0});\n    };\n\n    for (int i = 0; i < n-1; i++) {\n        add_edge(sv, i, 1);\n    }\n    for (int i = 0; i < n; i++) {\n        add_edge(n - 1 + i, tv, 1);\n    }\n\n    for (int i = 0; i < n-1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x; x--;\n            add_edge(i, n - 1 + x, 1);\n        }\n    }\n    auto mf = get_mf<int>(g, sv, tv, 0);\n    if (mf.flow != n-1) imp();\n\n    V<int> mt1(n - 1, -1), mt2(n - 1, -1);\n    VV<int> g2(v);\n    auto add_e2 = [&](int s, int t) {\n        //cerr << \"E2 \" << s << \" -> \" << t << endl;\n        g2[s].push_back(t);\n    };\n    for (int i = n - 1; i < n + n - 1; i++) {\n        for (auto e: g[i]) {\n            if (e.to < n - 1) {\n                if (e.cap) {\n                    mt1[e.to] = i - (n - 1);\n                    add_e2(e.to, i);\n                } else {\n                    add_e2(i, e.to);\n                }\n            } else if (e.to == tv) {\n                if (e.cap) {\n                    cerr << \"FIND Unused : \" << i - (n - 1) << endl;\n                    add_e2(tv, i);\n                }\n            } else assert(false);\n        }\n    }\n\n    V<int> prev(v, -1);\n    queue<int> q;\n    q.push(tv);\n    prev[tv] = -2;\n    while (!q.empty()) {\n        int p = q.front(); q.pop();\n        for (int d: g2[p]) {\n            if (prev[d] != -1) continue;\n            prev[d] = p;\n            q.push(d);\n        }\n    }\n    for (int i = 0; i < n - 1; i++) {\n        if (prev[i] == -1) imp();\n        mt2[i] = prev[i] - (n - 1);\n        cout << mt1[i] + 1 << \" \" << mt2[i] + 1 << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) {\n\t\t\t\twrite(i), putchar(' ');\n\t\t\t\twrite(par[par[i]]), putchar('\\n');\n\t\t\t} \n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F> struct dinic {\n    static constexpr F inf = numeric_limits<F>::has_infinity ?\n        numeric_limits<F>::infinity() : numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return { res, flow };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    int src = 0, snk = 2 * N;\n    dinic<int> g(2 * N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        g.arc(src, i, 1);\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        g.arc(N + i, snk, 1);\n\n        int sz, w;\n        cin >> sz;\n        for (int j = 0; j < sz; j++) {\n            cin >> w;\n            g.arc(w, N + i, 1);\n        }\n    }\n\n    auto max_flow = g.max_flow(src, snk);\n    int F = get<0>(max_flow);\n    vi flow = get<1>(max_flow);\n\n    if (F != N - 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int root;\n    for (int e : g.adj[src]) {\n        if (flow[e] == 0) {\n            root = g.dest[e];\n            break;\n        }\n    }\n\n    vi vis(g.V);\n    vis[src] = -1;\n    vis[snk] = -1;\n    vis[root] = root;\n\n    queue<int> bfs({ root });\n    while (!bfs.empty()) {\n        int loc = bfs.front();\n        bfs.pop();\n        for (int e : g.adj[loc]) {\n            if (!vis[g.dest[e]] && (loc > N && flow[e] == -1 || loc <= N && flow[e] == 0)) {\n                vis[g.dest[e]] = loc;\n                bfs.push(g.dest[e]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> res(N - 1);\n    for (int i = 1; i <= N; i++) {\n        if (i == root) continue;\n        if (!vis[i]) { cout << -1 << endl; return 0; }\n        res[vis[i] - N - 1] = { i, vis[vis[i]] };\n    }\n\n    for (auto e : res) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 1, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tif(Dinic() != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; bl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nvector<int> adj[MaxN];\nint N;\nbool visited[MaxN];\nint match_left[MaxN], match_right[MaxN];\nVI rev_adj[MaxN];\n\nbool DfsMatch(int v) {\n  if (visited[v]) { return false; }\n  visited[v] = true;\n  for (int s : adj[v]) {\n    if (match_right[s] == -1 || DfsMatch(match_right[s])) {\n      match_right[s] = v;\n      match_left[v] = s;\n      return true;\n    }\n  }\n  return false;\n}\n\nint Matching() {\n  fill_n(match_left, N, -1);\n  fill_n(match_right, N, -1);\n  int size = 0;\n  bool has_incr;\n  do {\n    has_incr = false;\n    fill_n(visited, N, false);\n    for (int i = 0; i < N; ++i)\n      if (match_left[i] == -1 && !visited[i] && DfsMatch(i)) {\n        ++size;\n        has_incr = true;\n      }\n  } while (has_incr);\n  return size;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  for (int i = 1; i <= N - 1; ++i) {\n    int sz;\n    cin >> sz;\n    for (int j = 0; j < sz; ++j) {\n      int v; cin >> v;\n      --v;\n      adj[i].PB(v);\n      rev_adj[v].PB(i);\n    }\n    adj[0].PB(i - 1);\n  }\n\n  if (Matching() != N) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  for (int i = 0; i < N; ++i)\n    debug(i, match_left[i]);\n\n  vector<PII> edges(N - 1);\n  int num_edges = 0;\n  queue<int> Q;\n  vector<bool> vis_set(N);\n  vector<bool> vis_vert(N);\n\n  Q.push(match_left[0]);\n  vis_set[0] = true;\n  vis_vert[match_left[0]] = true;\n\n  while (!Q.empty()) {\n    const int v = Q.front();\n    Q.pop();\n\n    for (int set_id : rev_adj[v]) {\n      if (vis_set[set_id]) { continue; }\n      vis_set[set_id] = true;\n      const int s = match_left[set_id];\n      assert(!vis_vert[s]);\n      vis_vert[s] = true;\n      debug(set_id, v, s);\n      edges[set_id - 1] = make_pair(v, s);\n      ++num_edges;\n      Q.push(s);\n    }\n  }\n\n  if (num_edges != N - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  for (auto &edge : edges)\n    cout << edge.st + 1 << \" \" << edge.nd + 1 << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define SZ 2333333\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define ad_de ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n;\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n#define mp make_pair\nvector<int> t[SZ],g[SZ],vv[SZ];\npii ans[SZ];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b),\n\t\t\tvv[b].pb(i);\n\t\tsort(t[i].begin(),t[i].end());\n\t}\n\tset<int> v; v.insert(1);\n\tvector<int> u; u.pb(1);\n\tset<int> done;\n\tN=n+n+2; S=N-1; T=N;\n\twhile(done.size()<n-1)\n\t{\n\t\tint s=done.size();\n\t\tset<int> iq;\n\t\tset<int> NS;\n\t\tNS.insert(S); NS.insert(T);\n\t\tfor(auto g:u)\n\t\t\tfor(auto h:vv[g])\n\t\t\t{\n\t\t\t\tif(done.count(h)) continue;\n\t\t\t\tiq.insert(h);\n\t\t\t}\n\t\tif(!iq.size())\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tmap<pii,int> tmp;\n\t\tstatic int GS[SZ];\n\t\tfor(auto h:iq)\n\t\t{\n\t\t\tint cn=0,gs=0;\n\t\t\tfor(auto w:t[h])\n\t\t\t\tif(v.count(w)) gs=w;\n\t\t\tGS[h]=gs;\n\t\t\tfor(auto w:t[h])\n\t\t\t\tif(!v.count(w))\n\t\t\t\t{\n\t\t\t\t\tif(!NS.count(w))\n\t\t\t\t\t\tNS.insert(w),\n\t\t\t\t\t\tad_de(S,w,1);\n\t\t\t\t\t++cn; ad_de(w,h+n,1);\n\t\t\t\t\ttmp[pii(h,w)]=M;\n\t\t\t\t}\n\t\t\tad_de(h+n,T,1);\n\t\t\tNS.insert(h+n);\n\t\t}\n\t\tu.clear(); \n\t\tint ss=dinic();\n\t\tfor(auto h:iq)\n\t\t{\n\t\t\tint okk=0;\n\t\t\tfor(auto w:t[h])\n\t\t\t\tif(!v.count(w)&&cap[tmp[pii(h,w)]])\n\t\t\t\t{\n\t\t\t\t\tdone.insert(h); okk=1;\n\t\t\t\t\tans[h]=pii(GS[h],w);\n\t\t\t\t}\n\t\t\tif(!okk)\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tM=1;\n\t\tfor(auto t:NS) fst[t]=0;\n\t\tfor(auto h:iq) v.insert(ans[h].se),u.pb(ans[h].se);\n\t\tif(done.size()==s)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nint n,S,T,d[100010],ans,a[100010],b[100010];\nvector<int> v[100010];\nint cnt=1,head[200010],to[800010],nxt[800010],w[800010];\nbool used[100010];\nvoid add(int x,int y,int z)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n\tw[cnt]=z;\n}\nvoid ins(int x,int y,int z)\n{\n\tadd(x,y,z);\n\tadd(y,x,0);\n}\nbool bfs()\n{\n\tfor (int i=S;i<=T;i++)\n\t{\n\t\td[i]=-1;\n\t}\n\tqueue<int> q;\n\td[S]=0;\n\tq.push(S);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tif (x==T)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif (w[i] && d[y]==-1)\n\t\t\t{\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x,int f)\n{\n\tint res=0;\n\tif (x==T)\n\t{\n\t\treturn f;\n\t}\n\tfor (int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif (w[i] && d[y]==d[x]+1)\n\t\t{\n\t\t\tint tmp=dfs(y,min(f-res,w[i]));\n\t\t\tw[i]-=tmp;\n\t\t\tw[i^1]+=tmp;\n\t\t\tres+=tmp;\n\t\t\tif (res==f)\n\t\t\t{\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\tif (!res)\n\t{\n\t\td[x]=-1;\n\t}\n\treturn res;\n}\nvoid dinic()\n{\n\twhile (bfs())\n\t{\n\t\tans+=dfs(S,inf);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tS=1;\n\tT=2*n;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tif (x!=1)\n\t\t\t{\n\t\t\t\tins(x,n+i,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tins(S,i,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tins(n+i,T,1);\n\t}\n\tdinic();\n\tif (ans!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=n+1;i<2*n;i++)\n\t{\n\t\tfor (int j=head[i];j;j=nxt[j])\n\t\t{\n\t\t\tif (!w[j])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i-n]=to[j];\n\t\t}\n\t}\n\tqueue<int> q;\n\tused[1]=true;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=0;i<v[x].size();i++)\n\t\t{\n\t\t\tint y=v[x][i];\n\t\t\tif (!used[a[y]])\n\t\t\t{\n\t\t\t\tused[a[y]]=true;\n\t\t\t\tq.push(a[y]);\n\t\t\t\tb[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tbool f=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tf&=used[i];\n\t}\n\tif (!f)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",a[i],b[i]);\n\t}\n\treturn 0;\n}\n//\n//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nstruct edge{\n\tint y,next,c;\n}s[N<<4];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[st]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tif(t==tot) break;\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t}\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(c[P[c[x]][i]]!=c[x] && !las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2+N*4];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N*2],BZ,dis[N*2];\nEDGE *cur[N*2];\n#define rev(ei) (e+(int((ei)-e)^1))\nbool getdis(){\n\tstatic int q[N*2];\n\tmemcpy(cur,last,sizeof(EDGE*)*(T+1));\n\tmemset(dis,0,sizeof(int)*(T+1));\n\tdis[S]=1;\n\tq[1]=S;\n\tint head=1,tail=1;\n\twhile (head<=tail){\n\t\tint x=q[head++];\n\t\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\t\tif (ei->c && !dis[ei->to]){\n\t\t\t\tdis[ei->to]=dis[x]+1;\n\t\t\t\tq[++tail]=ei->to;\n\t\t\t}\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]==dis[x]+1){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (getdis()){\n\t\tint tmp;\n\t\tdo{\n\t\t\ttmp=dfs(S,INF);\n\t\t\tr+=tmp;\n\t\t}\n\t\twhile (tmp);\n\t}\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define inf 1<<30\n#define sqr(x) ((x)*(x))\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next,f;\n}e[N*10];\nint head[N*2],tot=1,S,T;\nint dis[N*2],q[N*2];\nvoid add(int x,int y,int v){\n\te[++tot]=(edge){y,head[x],v};\n\thead[x]=tot;\n\te[++tot]=(edge){x,head[y],0};\n\thead[y]=tot;\n}\nbool bfs(){\n\tFor(i,1,T) dis[i]=-1;\n\tq[0]=1; q[1]=S; dis[S]=1;\n\tFor(h,1,q[0])\n\t\tfor (int i=head[q[h]];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]==-1&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[q[h]]+1;\n\t\t\t\tif (e[i].to==T) return 1;\n\t\t\t\tq[++q[0]]=e[i].to;\n\t\t\t}\n\treturn 0;\n}\nint dfs(int x,int flow){\n\tif (x==T) return flow;\n\tint k,rest=flow;\n\tfor (int i=head[x];i&&rest;i=e[i].next)\n\t\tif (dis[e[i].to]==dis[x]+1&&e[i].f){\n\t\t\tk=dfs(e[i].to,min(rest,e[i].f));\n\t\t\te[i].f-=k; e[i^1].f+=k; rest-=k;\n\t\t}\n\tif (rest) dis[x]=-1;\n\treturn flow-rest;\n}\nvector<int> v[N],V[N];\nint cnt,n;\nint fa[N],mat[N];\nbool vis[N];\nvoid dfs(int x){\n\t++cnt; vis[x]=1;\n\tfor (auto i:V[x])\n\t\tif (!vis[mat[i]]){\n\t\t\tfa[i]=x;\n\t\t\tdfs(mat[i]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=2*n; T=2*n+1;\n\tFor(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tv[i].resize(cnt);\n\t\tFor(j,0,cnt-1){\n\t\t\tscanf(\"%d\",&v[i][j]);\n\t\t\tif (v[i][j]!=1)\n\t\t\t\tadd(i+n,v[i][j],1);\n\t\t\tV[v[i][j]].PB(i);\n\t\t}\n\t}\n\tFor(i,2,n)\n\t\tadd(i,T,1);\n\tint flow=0;\n\tfor (;bfs();flow+=dfs(S,inf));\n\tif (flow!=n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tfor (int j=head[i+n];j;j=e[j].next)\n\t\t\tif (e[j].to<S&&!e[j].f)\n\t\t\t\tmat[i]=e[j].to;\n\tdfs(1);\n\tif (cnt!=n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",mat[i],fa[i]);\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i]);\n    }\n    queue < int > q;\n    q.push(n);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 800008\n#define N 200002\nint A[N],B[M],C[M],F[M],S,T,a[N],b[M],c[M],e[N],h[N],l,n,q[N],r,t;bool D[M],d[M];\ninline void add(int u,int v){b[++t]=a[u],c[a[u]=t]=v,d[t]=true,b[++t]=a[v],c[a[v]=t]=u;}\ninline bool bfs()\n{\n\tmemset(h+1,-1,T<<2),*h=l=0,*q=S,r=1;\n\twhile(l<r)for(int u=q[l++],i=a[u];i;i=b[i])if(d[i]&&h[c[i]]<0)h[q[r++]=c[i]]=h[u]+1;\n\treturn h[T]>=0;\n}\nbool dfs(int u)\n{\n\tif(u==T)return true;\n\tfor(int&i=e[u];i;i=b[i])if(d[i]&&dfs(c[i]))return d[i]=false,d[i^1]=true;\n\treturn false; \n}\nvoid ans(int u)\n{\n\tD[u]=true;\n\tfor(int&i=A[u];i;i=B[i])if(!D[C[i]])t++,F[C[i]]=u,ans(C[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n),T=n<<1;\n\tfor(int i=t=1,u,v;i<n;i++)for(scanf(\"%d\",&u);u--;)scanf(\"%d\",&v),add(n+i,v);\n\tfor(int i=2;i<=n;i++)add(i,T);\n\tfor(int i=1;i<n;i++)add(S,n+i);\n\tfor(t=0;bfs();)for(memcpy(e,a,T+1<<2);dfs(S);t++);\n\tif(t!=n-1)return 0*puts(\"-1\");\n\tfor(int i=2;i<=n;i++)while(a[i]=b[a[i]])if(d[a[i]])e[c[a[i]]-n]=i;\n\tfor(int i=t=1;i<n;i++)while(a[n+i]=b[a[n+i]])if(d[a[n+i]])B[++t]=A[c[a[n+i]]],C[A[c[a[n+i]]]=t]=e[i];\n\tif(t=0,ans(1),t!=n-1)return 0*puts(\"-1\");\n\telse for(int i=1;i<n;i++)printf(\"%d %d\\n\",F[e[i]],e[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, c, u;\n\nvector<int> edge[216000];\nvector<int> ans[216000];\nbool come[216000];\n\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tedge[i].push_back(n + u);\n\t\t\tedge[n+u].push_back(i);\n\t\t}\t\n\t}\n\tdfs(n+1);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(root);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = 0x3f3f3f3f;\n\nnamespace flow {\nstruct edge_t {\n  int to, cap, rev;\n\n  edge_t(int t, int c, int r) {\n    to = t;\n    cap = c;\n    rev = r;\n  }\n};\n\nint n, source, sink, answer;\nvector<vector<edge_t>> adj;\nvector<int> dist, current;\n\nvoid init(int v, int s, int t) {\n  n = v;\n  source = s;\n  sink = t;\n  answer = 0;\n  adj.clear();\n  adj.resize(n);\n  dist.resize(n);\n  current.resize(n);\n}\n\nvoid add(int x, int y, int c) {\n  adj[x].push_back(edge_t(y, c, adj[y].size()));\n  adj[y].push_back(edge_t(x, 0, adj[x].size() - 1));\n}\n\nbool bfs() {\n  queue<int> q;\n  for (int i = 0; i < n; ++i) {\n    dist[i] = -1;\n  }\n  dist[source] = 0;\n  q.push(source);\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto e : adj[x]) {\n      if (e.cap && !~dist[e.to]) {\n        dist[e.to] = dist[x] + 1;\n        if (e.to == sink) {\n          return true;\n        }\n        q.push(e.to);\n      }\n    }\n  }\n  return false;\n}\n\nint dfs(int x, int f) {\n  if (x == sink) {\n    return f;\n  }\n  for (int &i = current[x]; ~i; --i) {\n    edge_t &e = adj[x][i];\n    if (e.cap && dist[e.to] == dist[x] + 1) {\n      int w = dfs(e.to, min(e.cap, f));\n      if (w) {\n        e.cap -= w;\n        adj[e.to][e.rev].cap += w;\n        return w;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow() {\n  while (bfs()) {\n    for (int i = 0; i < n; ++i) {\n      current[i] = adj[i].size() - 1;\n    }\n    while (true) {\n      int flow = dfs(source, inf);\n      if (!flow) {\n        break;\n      }\n      answer += flow;\n    }\n  }\n  return answer;\n}\n}\n\nusing flow::source;\nusing flow::sink;\nusing flow::init;\nusing flow::add;\nusing flow::adj;\nusing flow::max_flow;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  scanf(\"%d\", &n);\n  vector<vector<int>> a(n - 1);\n  vector<vector<int>> v(n);\n  init(n * 2, n * 2 - 2, n * 2 - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    int s;\n    scanf(\"%d\", &s);\n    a[i].resize(s);\n    add(source, i, 1);\n    for (int j = 0; j < s; ++j) {\n      scanf(\"%d\", &a[i][j]);\n      --a[i][j];\n      v[a[i][j]].push_back(i);\n      if (a[i][j]) {\n        add(i, a[i][j] - 1 + n - 1, 1);\n      }\n    }\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    add(i + n - 1, sink, 1);\n  }\n  if (max_flow() != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  vector<int> match(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (auto e : adj[i]) {\n      if (e.to < n * 2 - 2 && !e.cap) {\n        match[i] = e.to - (n - 1) + 1;\n      }\n    }\n  }\n  vector<bool> visit(n);\n  vector<int> parent(n - 1);\n  int cc = 0;\n  function<void(int)> insert = [&](int x) {\n    ++cc;\n    visit[x] = true;\n    for (auto i : v[x]) {\n      if (!visit[match[i]]) {\n        parent[i] = x;\n        insert(match[i]);\n      }\n    }\n  };\n  insert(0);\n  if (cc != n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    printf(\"%d %d\\n\", match[i] + 1, parent[i] + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, M = 200005, inf = 0x3f3f3f3f;\nint n, p[N], fa[N];\nvector<int> E[N], F[N];\n\nnamespace flow {\n\tconst int V = 2 * N, E = 2 * (M + 2 * N);\n\tint ans, S, T, tot = 1, nxt[E], fst[V], to[E], f[E], cur[V], d[V];\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; f[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; f[tot] = 0;\n\t}\n\tbool bfs() {\n\t\tstatic int q[E];\n\t\tint st = 0, ed = 0;\n\t\tq[ed++] = S;\n\t\tfor (int i = 1; i <= T; i++) d[i] = -1, cur[i] = fst[i];\n\t\td[S] = 0;\n\t\twhile (st < ed) {\n\t\t\tint u = q[st++];\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (f[i] && d[to[i]] == -1) {\n\t\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\t\tif (to[i] == T) return true;\n\t\t\t\t\tq[ed++] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint aug(int u, int flow) {\n\t\tif (u == T || !flow) return flow;\n\t\tint used = 0;\n\t\tfor (int &i = cur[u], w; i; i = nxt[i])\n\t\t\tif (d[to[i]] == d[u] + 1 && (w = aug(to[i], min(f[i], flow - used)))) {\n\t\t\t\tf[i] -= w, f[i ^ 1] += w;\n\t\t\t\tif ((used += w) == flow) break;\n\t\t\t}\n\t\tif (!used) d[u] = -1;\n\t\treturn used;\n\t}\n\tint dinic() {\n\t\twhile (bfs()) ans += aug(S, inf);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs(int u) {\n\tfor (int v : F[u])\n\t\tif (!fa[p[v]]) {\n\t\t\tfa[p[v]] = u;\n\t\t\tdfs(p[v]);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tflow::S = 2 * (n - 1) + 1, flow::T = 2 * (n - 1) + 2;\n\tfor (int i = 1, k; i < n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tE[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tscanf(\"%d\", &E[i][j]);\n\t\t\tif (E[i][j] != n)\n\t\t\t\tflow::addedge(E[i][j], n - 1 + i, 1);\n\t\t\tF[E[i][j]].push_back(i);\n\t\t}\n\t\tflow::addedge(flow::S, i, 1);\n\t\tflow::addedge(n - 1 + i, flow::T, 1);\n\t}\n\tint x = flow::dinic();\n\tif (x != n - 1) return !puts(\"-1\");\n\tfor (int i = 2; i <= flow::tot; i += 2)\n\t\tif (!flow::f[i] && flow::to[i] != flow::T && flow::to[i ^ 1] != flow::S)\n\t\t\tp[flow::to[i] - n + 1] = flow::to[i ^ 1];\n\tfa[n] = -1, dfs(n);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!fa[i]) return !puts(\"-1\");\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", fa[p[i]], p[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\nreturn printf(\"-1\"), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nstd::mt19937 rnd(time(NULL));\n#define rand rnd\n#define pr std::pair<int,int>\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\ntemplate<class T>void cxk(T&a,T b){a=a>b?a:b;}\ntemplate<class T>void cnk(T&a,T b){a=a<b?a:b;}\n#ifdef mod\nint pow(int x,int y){\n\tint ret=1;\n\twhile(y){\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\ntemplate<class Ta,class Tb>void inc(Ta&a,Tb b){a=a+b>=mod?a+b-mod:a+b;}\ntemplate<class Ta,class Tb>void dec(Ta&a,Tb b){a=a>=b?a-b:a+mod-b;}\n#endif\nint n,S,T,fir[200010],head[200010],dep[200010],dis[1000010],nxt[1000010],w[1000010],id=1;\nvoid link(int a,int b,int c){\n\tnxt[++id]=fir[a],fir[a]=id,dis[id]=b,w[id]=c;\n\tnxt[++id]=fir[b],fir[b]=id,dis[id]=a,w[id]=0;\n}\nint que[200010],hd,tl,el[100010];\nstd::vector<pr>E[100010];\nbool BFS(){\n\thd=tl=0;memset(dep,0,sizeof dep);\n\tdep[S]=1;que[tl++]=S;\n\twhile(hd^tl){\n\t\tint x=que[hd++];\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t\tif(w[i]&&!dep[dis[i]])\n\t\t\t\tdep[dis[i]]=dep[x]+1,que[tl++]=dis[i];\n\t}\n\treturn dep[T];\n}\nint Dinic(int x,int maxflow){\n\tif(x==T)return maxflow;\n\tint ret=0;\n\tfor(int&i=head[x];i;i=nxt[i])\n\t\tif(w[i]&&dep[dis[i]]==dep[x]+1){\n\t\t\tint d=Dinic(dis[i],std::min(maxflow-ret,w[i]));\n\t\t\tw[i]-=d,w[i^1]+=d,ret+=d;if(ret==maxflow)break;\n\t\t}\n\treturn ret;\n}\nint match[100010],fa[100010],set[1000010];\nint ax[100010],ay[100010];\nvoid DFS(int x){\n\tfor(int i=fir[x];i;i=nxt[i])\n\t\tif(w[i]&&dis[i]!=S&&!fa[match[dis[i]-n]]){\n\t\t\tfa[match[dis[i]-n]]=x;\n\t\t\tset[match[dis[i]-n]]=dis[i]-n;\n\t\t\tDFS(match[dis[i]-n]);\n\t\t}\n}\nint main(){\n#ifdef LOCAL\n\tfreopen(\"in.in\",\"r\",stdin);\n\t//freopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi();\n\tfor(int i=1;i<n;++i){\n\t\tint o=gi(),x;E[i].resize(o);\n\t\tfor(int j=0;j<o;++j)link(x=gi(),i+n,1),E[i][j]={id,x};\n\t}\n\tS=n+n,T=n+n+1;\n\tfor(int i=1;i<=n;++i)link(S,i,1),el[i]=id;\n\tfor(int i=n+1;i<n+n;++i)link(i,T,1);\n\tint flow=0;\n\twhile(BFS())memcpy(head,fir,sizeof head),flow+=Dinic(S,1e9);\n\tif(flow<n-1)puts(\"-1\"),exit(0);\n\tint r=0;\n\tfor(int i=1;i<=n;++i)if(!w[el[i]])r=i;\n\tfor(int i=1;i<n;++i)for(pr j:E[i])if(w[j.fi])match[i]=j.se;\n\tfa[r]=-1;DFS(r);\n\tint cnt=0;for(int i=1;i<=n;++i)cnt+=!!fa[i];\n\tif(cnt<n)puts(\"-1\"),exit(0);\n\tfor(int i=1;i<=n;++i)if(~fa[i])ax[set[i]]=i,ay[set[i]]=fa[i];\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",ax[i],ay[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        printf(\"%d %d\\n\",u,v);\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]),g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace flow{\n\tconst int _ = 1e6 + 7 , __ = 1e7 + 7;\n\tstruct Edge{int end , upEd , f;}Ed[__];\n\tint head[_] , dep[_] , cur[_] , cntEd = 1 , S , T;\n\n\tvoid addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}\n\tvoid addE(int a , int b , int c){addEd(a , b , c); addEd(b , a , 0);}\n\t\n\tqueue < int > q;\n\tbool bfs(){\n\t\tmemset(dep , 0 , sizeof(int) * (T + 1)); while(!q.empty()) q.pop();\n\t\tdep[S] = 1; q.push(S);\n\t\twhile(!q.empty()){\n\t\t\tint t = q.front(); q.pop();\n\t\t\tfor(int i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && !dep[Ed[i].end]){\n\t\t\t\t\tdep[Ed[i].end] = dep[t] + 1;\n\t\t\t\t\tif(Ed[i].end == T){memcpy(cur , head , sizeof(int) * (T + 1)); return 1;}\n\t\t\t\t\tq.push(Ed[i].end);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dfs(int x , int mn){\n\t\tif(x == T) return mn;\n\t\tint sum = 0;\n\t\tfor(int &i = cur[x] ; i ; i = Ed[i].upEd)\n\t\t\tif(Ed[i].f && dep[Ed[i].end] == dep[x] + 1){\n\t\t\t\tint t = dfs(Ed[i].end , min(mn - sum , Ed[i].f));\n\t\t\t\tsum += t; Ed[i].f -= t; Ed[i ^ 1].f += t;\n\t\t\t\tif(sum == mn) break;\n\t\t\t}\n\t\treturn sum;\n\t}\n\n\tint Dinic(int s , int t){int sum = 0; S = s; T = t; while(bfs()) sum += dfs(s , 1e9); return sum;}\n}using namespace flow;\n\nint read(){\n\tint a = 0; char c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();}\n\treturn a;\n}\n\nint N , pos[200003] , E[200003][2]; vector < int > id[200003];\n\nint main(){\n\tN = read();\n\tfor(int i = 2 ; i <= N ; ++i) addE(0 , i , 1);\n\tfor(int i = 1 ; i < N ; ++i){\n\t\taddE(N + i , N + N , 1);\n\t\tfor(int p , x = read() ; x ; --x){addE(p = read() , i + N , 1); id[p].push_back(i);}\n\t}\n\tif(Dinic(0 , N + N) != N - 1){puts(\"-1\"); return 0;}\n\tfor(int i = 2 ; i <= N ; ++i)\n\t\tfor(int j = head[i] ; j ; j = Ed[j].upEd)\n\t\t\tif(Ed[j].end > N && !Ed[j].f){pos[Ed[j].end - N] = i; break;}\n\tqueue < int > q; q.push(1);\n\twhile(!q.empty()){\n\t\tint t = q.front(); q.pop();\n\t\tfor(auto x : id[t]) if(pos[x]){E[x][0] = t; E[x][1] = pos[x]; q.push(pos[x]); pos[x] = 0;}\n\t}\n\tfor(int i = 1 ; i < N ; ++i) printf(\"%d %d\\n\" , E[i][0] , E[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nvector<int> E[N],in[N];\nnamespace Graph{\n\tconst int inf = 1e9;\n\tvector<pair<int,int> > ans;\n\tint n,tot,t,head[N],b[N],vis[N],cur[N];\n\tstruct edge{int v,nxt,f;}e[N*4];\n\tvoid init(int m){\n\t\tn=m;t=2*n+1;tot=1;\n\t}\n\tvoid add(int x,int y,int z){\n\t\te[++tot]={y,head[x],z};\n\t\thead[x]=tot;\n\t\te[++tot]={x,head[y],0};\n\t\thead[y]=tot;\n\t}\n\tbool bfs(){\n\t\tmemset(b,0,sizeof(b));b[0]=1;\n\t\tqueue<int> q;q.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&!b[e[i].v]){\n\t\t\t\t\tb[e[i].v]=b[u]+1;\n\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t}\n\t\t}\n\t\treturn b[t];\n\t}\n\tint dfs(int x,int flow){\n\t\tif(!flow||x==t) return flow;\n\t\tint f=flow,tmp;\n\t\tfor(int &i=cur[x];i;i=e[i].nxt)\n\t\t\tif(b[e[i].v]==b[x]+1&&(tmp=dfs(e[i].v,min(e[i].f,f)))){\n\t\t\t\tf-=tmp;e[i].f-=tmp;e[i^1].f+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\treturn flow-f;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tans+=dfs(0,inf);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(int x){\n\t\tvis[x]=1;\n\t\tvector<int> v;\n\t\tfor(int p:in[x])\n\t\t\tfor(int i=head[p+n];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&e[i].v!=t) v.push_back(e[i].v);\n\t\tfor(int p:v) if(!vis[p]){\n\t\t\tans.emplace_back(x,p);\n\t\t\tsolve(p);\n\t\t}\n\t}\n\tvoid print(){\n\t\tif(ans.size()!=n-1){puts(\"-1\");return;}\n\t\tfor(auto&pr:ans)\n\t\t\tprintf(\"%d %d\\n\",pr.first,pr.second);\n\t}\n}\nint n;\nint main(){\n\tread(n);\n\tGraph::init(n);\n\tfor(int i=1;i<n;i++){\n\t\tint k;read(k);\n\t\twhile(k--){\n\t\t\tint x;read(x);\n\t\t\tE[i].push_back(x);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int x:in[i]) Graph::add(i,x+n,1);\n\t\tGraph::add(0,i,1);\n\t}\n\tfor(int i=1;i<n;i++) Graph::add(i+n,Graph::t,1);\n\tif(Graph::Dinic()<n-1){puts(\"-1\");return 0;}\n\tGraph::solve(1);\n\tGraph::print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace max_flow {\n\nconst int max_v = 200222, inf = 1000111222;\n\nstruct edge {\n    int to, residual_capacity;\n\n    edge(int to, int residual_capacity): to(to), residual_capacity(residual_capacity) {\n    }\n};\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid add_edge(int u, int v, int capacity) {\n    g[u].push_back(edges.size());\n    edges.push_back({v, capacity});\n    g[v].push_back(edges.size());\n    edges.push_back({u, 0});\n}\n\nint h[max_v], num[max_v];\n\nbool bfs(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        h[i] = -1;\n    }\n    h[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int id : g[v]) {\n            if (edges[id].residual_capacity && h[edges[id].to] == -1) {\n                h[edges[id].to] = h[v] + 1;\n                q.push(edges[id].to);\n            }\n        }\n    }\n    return h[t] != -1;\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) {\n        return f;\n    }\n    for (int &i = num[v]; i < g[v].size(); ++i) {\n        const int id = g[v][i];\n        if (edges[id].residual_capacity && h[v] + 1 == h[edges[id].to]) {\n            int res = dfs(edges[id].to, t, min(f, edges[id].residual_capacity));\n            if (res) {\n                edges[id].residual_capacity -= res;\n                edges[id ^ 1].residual_capacity += res;\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(int s, int t) {\n    int res = 0;\n    while (bfs(s, t)) {\n        memset(num, 0, sizeof(num));\n        while (int f = dfs(s, t, inf)) {\n            res += f;\n        }\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], ans[max_n], used[max_n];\nvector<int> g[max_n], g2[max_n];\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    int s = 2 * n - 1, t = 2 * n;\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        max_flow::add_edge(s, i, 1);\n        for (int to : g[i]) {\n            max_flow::add_edge(i, n - 1 + to, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        max_flow::add_edge(n - 1 + i, t, 1);\n    }\n    int f = max_flow::dinic(s, t);\n    memset(p, -1, sizeof(p));\n    memset(nxt, -1, sizeof(nxt));\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int id : max_flow::g[i]) {\n            const auto &e = max_flow::edges[id];\n            if (e.to != s && e.residual_capacity == 0) {\n                nxt[i] = e.to - n + 1;\n                p[nxt[i]] = i;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) u[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (u[i]) q.push(u[i]), ++k, fa[getfa(g[k] = s)] = getfa(h[k] = u[i]), u[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 2e5+5;\n\ntypedef int Flow;\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\n\nstruct PushRelabel {\n\tvector<vector<Edge>> g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\n\nint n, m[MAXN], r[MAXN];\nvector<int> e[MAXN], g[MAXN];\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tPushRelabel mf(2*n+1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tmf.add_edge(0, i+1, 1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tmf.add_edge(i+1, x+n, 1);\n\tfor (int i = n; i < 2*n; ++i)\n\t\tmf.add_edge(i, 2*n, 1);\n\tint fl = mf.maxflow(0, 2*n);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tauto h = mf.g;\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 1) {\n\t\t\t\tm[i] = e.dest-n;\n\t\t\t\tr[e.dest-n] = i;\n\t\t\t\ts -= (e.dest - n);\n\t\t\t\t// cout << i << ' ' << m[i]+1 << endl;\n\t\t\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 0) {\n\t\t\t\t// cout << e.dest - n << ' ' << m[i] << endl;\n\t\t\t\tg[e.dest - n].push_back(m[i]);\n\t\t\t}\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nvoid cl(int i) {\n    set<int> o;\n    swap(o, q[i]);\n}\n\nvoid cel() {\n    set<pair<int, int> > o;\n    swap(g, o);\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++)\n        p[i] = i, r[i] = 0, cl(i);\n    cel();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < a[i].size(); j++)\n            q[a[i][j]].insert(i);\n        d[i] = a[i].size();\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            return;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n    exit(0);\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    double ts = clock();\n    cin >> n;\n    if (n > 1000)\n        exit(1);\n    return 0;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n    }\n    while ((clock() - ts) / CLOCKS_PER_SEC < 3.7) {\n        solve();\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < a[i].size(); j++)\n                swap(a[i][j], a[i][rnd() % (j + 1)]);\n    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,inf=1e9;\nint n,c,p[N],q[N];vector<int> a[N];\nstruct edge{int u,v,c,f;};\nstruct Dinic{\n    vector<edge> e;\n    vector<int> G[N];queue<int> q;\n    int cur[N],d[N],n,m,s,t;bool vis[N];\n    inline void add(int u,int v,int c){\n        //printf(\"%d %d %d\\n\",u,v,c);\n        e.pb((edge){u,v,c,0});e.pb((edge){v,u,0,0});\n        m=e.size();G[u].pb(m-2);G[v].pb(m-1);\n    }\n    bool bfs(){\n        memset(d,0,sizeof(d));memset(vis,0,sizeof(vis));vis[s]=1;q.push(s);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int &x:G[u]){\n                edge &E=e[x];\n                if(E.c>E.f&&!vis[E.v]) d[E.v]=d[u]+1,vis[E.v]=1,q.push(E.v);\n            }\n        }\n        return vis[t];\n    }\n    int dfs(int u,int a){\n        if(u==t||!a) return a;\n        int flow=0,f;\n        for(int &i=cur[u];i<(int)G[u].size();++i){\n            edge &E=e[G[u][i]];\n            if(d[E.v]==d[u]+1&&(f=dfs(E.v,min(a,E.c-E.f)))){\n                E.f+=f;e[G[u][i]^1].f-=f;\n                flow+=f;a-=f;if(!a) break;\n            }\n        }\n        return flow;\n    }\n    int max_flow(int s,int t){\n        this->s=s;this->t=t;\n        int flow=0;\n        while(bfs()){memset(cur,0,sizeof(cur));flow+=dfs(s,inf);}\n        return flow;\n    }\n}G,H;\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);int S=1,T=2*n+1;G.n=H.n=T;\n    rep(i,1,n-1) G.add(1,i+1,1),H.add(1,i+1,1);\n    rep(i,1,n-1){\n        scanf(\"%d\",&c);a[i].resize(c);\n        rep(j,0,c-1) scanf(\"%d\",&a[i][j]),G.add(i+1,a[i][j]+n,1);\n    }\n    rep(i,1,n-1) G.add(i+n,T,1);\n    rep(i,2,n) H.add(i+n,T,1);\n    int t=G.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    //puts(\"dsynb\");\n    rep(i,2,n){\n        for(int &x:G.G[i]){\n            edge &e=G.e[x];\n            if(e.v>1&&!e.f) H.add(i,e.v,1);\n            else p[i]=e.v-n;\n        }\n    }\n    t=H.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    rep(i,2,n){\n        for(int &x:H.G[i]){\n            edge &e=H.e[x];\n            if(e.v>1&&e.f) q[i]=e.v-n;\n        }\n    }\n    rep(i,2,n) printf(\"%d %d\\n\",p[i],q[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next,f;\n}e[N*10];\nint head[N*2],tot=1;\nint dis[N*2],q[N*2];\nint n,S,T,sum;\nint fa[N],mat[N],vis[N];\nvector<int> vec[N],adj[N];\nvoid add(int x,int y,int f){\n\te[++tot]=(edge){y,head[x],f};\n\thead[x]=tot;\n\te[++tot]=(edge){x,head[y],0};\n\thead[y]=tot;\n}\nbool bfs(){\n\tFor(i,1,T) dis[i]=-1;\n\tint h=0,t=1;\n\tq[1]=S; dis[S]=0;\n\twhile (h!=t){\n\t\tint x=q[++h];\n\t\tfor (int i=head[x];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]==-1&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[x]+1;\n\t\t\t\tq[++t]=e[i].to;\n\t\t\t\tif (e[i].to==T) return 1;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int x,int flow){\n\tif (x==T) return flow;\n\tint k,rest=flow;\n\tfor (int i=head[x];i;i=e[i].next)\n\t\tif (dis[e[i].to]==dis[x]+1&&e[i].f){\n\t\t\tk=dfs(e[i].to,min(rest,e[i].f));\n\t\t\te[i].f-=k; e[i^1].f+=k; rest-=k;\n\t\t}\n\tif (rest) dis[x]=-1;\n\treturn flow-rest;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor (auto i:vec[x])\n\t\tif (!vis[mat[i]]){\n\t\t\tfa[i]=x;\n\t\t\tdfs(mat[i]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=2*n; T=2*n+1;\n\tFor(i,1,n-1){\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tadd(n+i,T,1);\n\t\tFor(j,1,cnt){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tadd(x,n+i,1);\n\t\t\tvec[x].PB(i);\n\t\t\t//adj[i].PB(x);\n\t\t}\n\t}\n\tFor(i,2,n)\n\t\tadd(S,i,1);\n\tfor (;bfs();sum+=dfs(S,1<<30));\n\tif (sum!=n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tfor (int j=head[n+i];j;j=e[j].next)\n\t\t\tif (e[j].f==1&&e[j].to<=n)\n\t\t\t\tmat[i]=e[j].to;\n\tdfs(1);\n\tFor(i,1,n) if (!vis[i])\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nstruct edge{\n\tint y,next,c;\n}s[N<<3];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[st]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tif(t==tot) break;\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t}\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(c[P[c[x]][i]]!=c[x] && !las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\\n\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,M=800005,oo=1e9;\nstruct edge{\n\tint di,nxt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N];\nPI an[N];\ninline void aedge(int a,int b,int c){\n\te[++nedge].nxt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void ins(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=0;i<N;i++)deep[i]=oo;\n    for(int i=0;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nxt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nxt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\nint dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nvector<int> v[N>>1];\nint match[N>>1];\nint main(){\n\tint n=read(),s=n,t=n+1;\n\tFor(i,1,n-1){\n\t\tint c=read();\n\t\tins(s,i,1); ins(n+i+1,t,1);\n\t\tFor(j,1,c){int t=read(); v[t].pb(i); if(t>1)ins(i,t+n,1);}\n\t}\n\tint ans=dinic(s,t); \n\tif(ans!=n-1)GG();\n\tFor(i,1,n-1)for(int j=son[i];j;j=e[j].nxt)if(!e[j].di){match[i]=e[j].ed-n; break;}\n\tqueue<int> q; q.push(1);\n\twhile(q.size()){\n\t\tint t=q.front(); q.pop(); \n\t\tfor(auto i:v[t])if(match[i]){\n\t\t\tq.push(match[i]);  ans--;\n\t\t\tan[i]=mp(t,match[i]);\n\t\t\tmatch[i]=0;\n\t\t}\n\t}\n\tif(ans)GG();\n\tFor(i,1,n-1){wri(an[i].fi);writeln(an[i].se);}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5;\nint n, lk[maxn + 10], vis[maxn + 10], clk;\nint l[maxn + 10], r[maxn + 10];\nvector<int> g[maxn + 10];\n\nbool dfs(int p) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tif (!lk[e] || dfs(lk[e])) {\n\t\t\t\tlk[e] = p; return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid getans(int p, int lst) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (e != lst && vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tl[e] = p; r[e] = lk[e];\n\t\t\tgetans(lk[e], e);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint k; scanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\trandom_shuffle(g[i].begin(), g[i].end());\n\tfor (int i = 1; i < n; ++i) {\n\t\t++clk;\n\t\tif (!dfs(i)) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\t}\n\t++clk;\n\tgetans(n, 0); \n\tfor (int i = 1; i < n; ++i)\n\t\tif (!l[i]) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", l[i], r[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) u[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (u[i]) q.push(u[i]), fa[getfa(g[i] = s)] = getfa(h[i] = u[i]), u[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5;\nint n, lk[maxn + 10], vis[maxn + 10], clk;\nint l[maxn + 10], r[maxn + 10];\nvector<int> g[maxn + 10];\n\nbool dfs(int p) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tif (!lk[e] || dfs(lk[e])) {\n\t\t\t\tlk[e] = p; return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid getans(int p, int lst) {\n\tfor (int i = 0; i < (int)g[p].size(); ++i) {\n\t\tint e = g[p][i];\n\t\tif (e != lst && vis[e] != clk) {\n\t\t\tvis[e] = clk;\n\t\t\tl[e] = p; r[e] = lk[e];\n\t\t\tgetans(lk[e], e);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; ++i) {\n\t\tint k; scanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\t++clk;\n\t\tif (!dfs(i)) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\t}\n\t++clk;\n\tgetans(n, 0); \n\tfor (int i = 1; i < n; ++i)\n\t\tif (!l[i]) {\n\t\t\tprintf(\"-1\"); return 0;\n\t\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", l[i], r[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tvis[v2[x][i]]=1;\n\t\tson[x].push_back(ma[v2[x][i]]);\n\t\tdfs(ma[v2[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200010\n#define M 1000010\n#define maxn 200010\n#define INF 2147483647\nusing namespace std;\nvector<int> node[maxn], pos[maxn];\nvector<pair<int, int> > res;\nint id[2][maxn], s = 1, t = 2, cnt = 2, head[N], nxt[M], a[M], r[M], level[N];\nint cur[N], edge, sum, ch[maxn], used[maxn], pre[maxn], dl[N];\nvoid create(int u, int v, int t)\n{\n\tedge++; a[edge] = v; nxt[edge] = head[u]; head[u] = edge; r[edge] = t;\n}\nvoid build()\n{\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tlevel[i] = 0;\n\t\tcur[i] = head[i];\n\t}\n\tint lef = 1, righ = 1;\n\tlevel[s] = 1;\n\tdl[1] = s;\n\twhile (lef <= righ)\n\t{\n\t\tint u = dl[lef];\n\t\tfor (int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = a[i];\n\t\t\tif (r[i] && level[v] == 0)\n\t\t\t{\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tdl[++righ] = v;\n\t\t\t}\n\t\t}\n\t\tlef++;\n\t}\n}\nint dinic(int u, int flow)\n{\n\tif (u == t) return flow;\n\tint ans = 0;\n\tfor (int i = cur[u]; i; i = nxt[i])\n\t{\n\t\tint v = a[i];\n\t\tif (r[i] && level[v] == level[u] + 1)\n\t\t{\n\t\t\tint low = dinic(v, min(flow, r[i]));\n\t\t\tans += low; flow -= low;\n\t\t\tr[i] -= low; if (i % 2) r[i + 1] += low; else r[i - 1] += low;\n\t\t}\n\t}\n\tif (ans == 0) level[u] = -1;\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tid[1][i] = ++cnt;\n\t\tcreate(cnt, t, 1); create(t, cnt, 0);\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tid[0][i] = ++cnt;\n\t\tcreate(s, cnt, 1); create(cnt, s, 0);\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tnode[i].push_back(x);\n\t\t\tpos[x].push_back(i);\n\t\t\tif (x != 1)\n\t\t\t{\n\t\t\t\tcreate(id[0][i], id[1][x], 1);\n\t\t\t\tcreate(id[1][x], id[0][i], 0);\n\t\t\t}\n\t\t}\n\t}\n\tbuild();\n\twhile (level[t])\n\t{\n\t\tsum += dinic(s, INF);\n\t\tbuild();\n\t}\n\tif (sum != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u = id[0][i];\n\t\tfor (int j = head[u]; j; j = nxt[j])\n\t\t{\n\t\t\tint v = a[j];\n\t\t\tif (v >= id[1][1] && r[j] == 0) {ch[i] = v - id[1][1] + 1; break;}\n\t\t}\n\t}\n\tint cnt = 1;\n\tpre[1] = 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tint u = pre[i], len = pos[u].size();\n\t\tfor (int j = 0; j <= len - 1; j++)\n\t\t{\n\t\t\tint x = pos[u][j];\n\t\t\tif (used[x] == 0)\n\t\t\t{\n\t\t\t\tused[x] = 1;\n\t\t\t\tres.push_back(make_pair(u, ch[x]));\n\t\t\t\tpre[++cnt] = ch[x];\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n) puts(\"-1\");\n\telse\n\tfor (int i = 0; i <= n - 2; i++)\n\t\tprintf(\"%d %d\\n\", res[i].first, res[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\nvector<int> r;\nvector<int> z;\n\nint ccc = 0;\n\nbool dfs(int x) {\n//    cout << x << \"\\n\";\n    if (z[x] == ccc) return false;\n    z[x] = ccc;\n    for (int y : g[x]) {\n        if (r[y] == -1 || dfs(r[y])) {\n            r[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    g.resize(n);\n    r.assign(n, -1);\n    z.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x;\n            x--;\n            g[x].push_back(i);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::random_shuffle(g[i].begin(), g[i].end());\n    }\n\n    int ff = -1;\n    for (int i = 0; i < n; i++) {\n        ccc++;\n        bool ok = false;\n        for (int y : g[i]) {\n            if (r[y] == -1) {\n                r[y] = i;\n                ok = true;\n                break;\n            }\n        }\n        if (!ok) {\n            if (!dfs(i)) {\n                if (ff == -1) {\n                    ff = i;\n                } else {\n                    cout << -1 << \"\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n\n//    for (int i = 0; i < n - 1; i++) {\n//        cout << r[i] << \"\\n\";\n//    }\n\n    vector<int> q;\n    vector<bool> zz(n);\n    q.push_back(ff);\n    vector<pair<int, int>> res(n - 1);\n    for (int i = 0; i < q.size(); i++) {\n        int x = q[i];\n        for (int c : g[x]) {\n            if (!zz[c]) {\n                zz[c] = true;\n                q.push_back(r[c]);\n                res[c] = {r[c], x};\n            }\n        }\n    }\n\n    if (q.size() < n) {\n        cout << \"-1\\n\";\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            cout << res[i].first + 1 << \" \" << res[i].second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 222222\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint E = MAX_V / 2;\nint s = MAX_V - 2;\nint g = MAX_V - 1;\nint mp[MAX_V/2];\nint rmp[MAX_V/2];\nbool used[MAX_V/2];\nbool visited[MAX_V/2];\n\nvector<vector<int>> v(MAX_V / 2);\nvector<vector<int>> nv(MAX_V / 2);\nvector<pair<int,pair<int,int>>> ans;\n\nvoid dfs(int num){\n\tvisited[num] = true;\n\tREP(i,nv[num].size()){\n\t\tif(!visited[nv[num][i]]){\n\t\t\tans.PB(MP(rmp[nv[num][i]], MP(num, nv[num][i])));\n\t\t\tdfs(nv[num][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tREP(i,n) {\n\t\tif(i != n -1)add_edge(s,i,1);\n\t\tadd_edge(E+i,g,1);\n\t}\n\t\t\n\tREP(i,n-1){\n\t\t\n\t\tint e;cin >> e;\n\t\tREP(j,e){\n\t\t\tint tmp;cin >> tmp;tmp--;\n\t\t\tv[i].EB(tmp);\n\t\t\tadd_edge(i, E+tmp, 1);\n\t\t}\n\t}\n\t\n\tint seica = Dinic(s, g);\n\tif(seica != n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,n-1) {\n\t\tREP(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0){\n\t\t\t\tmp[i] = G[i][j].to - E;\n\t\t\t\trmp[mp[i]] = i;\n\t\t\t\tused[mp[i]] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n-1){\n\t\tREP(j,v[i].size()){\n\t\t\tif(v[i][j] != mp[i])nv[v[i][j]].EB(mp[i]);\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(!used[i])dfs(i);\n\t}\n\t\n\tif(ans.size() == n-1){\n\t\tsort(ALL(ans));\n\t\tREP(i,ans.size()){\n\t\t\tcout << ans[i].SE.FI + 1 << \" \" << ans[i].SE.SE + 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<ctype.h>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f,oo = inf;\n#define pc putchar\n#define RG register\n#define gc getchar\ninline ll read(){\n\tRG ll x=0,f=1;RG char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tif(x<0)x=-x,pc('-');\n\tif(x>=10)write(x/10);\n\tputchar(x%10+'0');\n}\n#define rd read\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define rep(i,a,b) for(RG int i=(a);i<(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define y1 ________y1\n#define int ll\n#define N 1000005\n#define M 4000005\nstruct Edge{\n\tint to,nxt,cap;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap):to(to),nxt(nxt),cap(cap){};\n}edge[M*2];\nint first[N],cur[N],nume;\nvoid Addedge(int a,int b,int c){\n\tedge[nume] = Edge(b,first[a],c);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0);first[b] = nume++;\n}\nint q[N],dis[N],S,T,n,m,tot;\nbool bfs(){\n\tint front,rear;\n\tfront = rear = 0;\n\tmemset(dis,-1,sizeof(dis));\n\tq[rear++] = T;dis[T] = 1;\n\twhile(front < rear){\n\t\tint u = q[front++];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tint v=edge[e].to;\n\t\t\tif(edge[e^1].cap && dis[v]==-1){\n\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\tq[rear++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[S] != -1;\n}\nint dfs(int u,int flow){\n\tif(u==T) return flow;\n\tint used = 0,d;\n\tfor(int &e = cur[u];~e;e=edge[e].nxt){\n\t\tint v=edge[e].to;\n\t\tif(dis[u] == dis[v] + 1 && edge[e].cap && (d = dfs(v,min(flow-used,edge[e].cap)))){\n\t\t\tedge[e].cap -= d;\n\t\t\tedge[e^1].cap += d;\n\t\t\tused += d;\n\t\t}\n\t\tif(used == flow) break;\n\t}\n\tif(!used) dis[u] = -1;\n\treturn used;\n}\nint dinic(){\n\tll ans = 0;\n\twhile(bfs()){\n\t\tRep(i,1,tot) cur[i] = first[i];\n\t\tans += dfs(S,inf);\n\t}\n\treturn ans;\n}\nint id[N],Id[N],x[N];\nvector<int> g[N];\nsigned main(){\n\tmem(first,-1);nume = 0;\n\tn = read();\n\ttot = 0;\n\tS = ++tot;\n\tT = ++tot;\n\tRep(i,2,n){\n\t\tid[i] = ++tot;\n\t\tAddedge(id[i],T,1);\n\t}\n\tRep(i,1,n-1){\n\t\tId[i] = ++tot;\n\t\tAddedge(S,Id[i],1);\n\t\t//v[i] . resize(read());\n\t\tint t = read();\n\t\trep(j,0,t){\n\t\t\tint t = read();\n\t\t\tif(t != 1) Addedge(Id[i],id[t],1);\n\t\t\tg[t] . push_back(i);\n\t\t}\n\t}\n\tif(dinic() != n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tRep(i,1,n-1){\n\t\tint u = Id[i];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(e%2==0 && !edge[e].cap){\n//\t\t\t\tprintf(\"{%d %d}\\n\",u,edge[e].to);\n\t\t\t\tx[i] = edge[e].to - 1;\n\t\t\t}// \n\t\t}\n\t}\n\tqueue<int> Q;\n\tstatic int vis[N],y[N];\n\tQ.push(1);vis[1]=true;\n\twhile(!Q.empty()){\n\t\tint u = Q.front();Q.pop();\n\t\tfor(auto v:g[u]){\n\t\t//\tprintf(\"{%d)\\n\",x[v]);\n\t\t\tif(!vis[x[v]]){\n\t\t\t\tvis[x[v]] = u;\n\t\t\t\tQ.push(x[v]);\n\t\t\t\ty[v] = u;\n//\t\t\t\tprintf(\"%d %d\\n\",u,x[v]);\n\t\t\t}\n\t\t}\n\t}\n\tRep(i,1,n-1){\n\t\twrite(x[i]),pc(' '),write(y[i]),pc('\\n');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;\n}E[MAXN * 20];\nint N,head[MAXN * 2],sumE = 1,S,T,tot,lev[MAXN * 2],cur[MAXN * 2],ch[MAXN],fa[MAXN];\nvector<int> v[MAXN];\nbool vis[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c) {\n    add(u,v,c);add(v,u,0);\n}\nbool BFS() {\n    static int que[MAXN * 2],ql,qr;\n    que[ql = qr = 1] = S;\n    for(int i = 1 ; i <= T ; ++i) lev[i] = -1,cur[i] = head[i];\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    int v = E[i].to;\n\t    if(E[i].cap > 0 && lev[v] == -1) {\n\t\tlev[v] = lev[u] + 1;\n\t\tif(v == T) return true;\n\t\tque[++qr] = v;\n\t    }\n\t}\n    }\n    return false;\n}\nint dfs(int u,int aug) {\n    if(u == T) return aug;\n    int flow = 0;\n    for(int &i = cur[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(E[i].cap > 0 && lev[v] > lev[u]) {\n\t    int t = dfs(v,min(E[i].cap,aug - flow));\n\t    flow += t;E[i].cap -= t;E[i ^ 1].cap += t;\n\t    if(flow == aug) break;\n\t}\n    }\n    if(flow != aug) lev[u] = -1;\n    return flow;\n}\nint Dinic() {\n    int res = 0;\n    while(BFS()) {\n\tint x;\n\tdo {\n\t    x = dfs(1,0x7fffffff);\n\t    res += x;\n\t}while(x);\n    }\n    return res;\n}\nvoid Init() {\n    read(N);\n    S = 1;\n    for(int i = 1 ; i < N ; ++i) {\n\taddtwo(S,i + N,1);\n\tint c,w;\n\tread(c);\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    read(w);\n\t    if(w != 1) addtwo(i + N,w,1);\n\t    v[w].pb(i);\n\t}\n    }\n    T = 2 * N;\n    for(int i = 2 ; i <= N ; ++i) addtwo(i,T,1);\n}\nvoid construct() {\n    static int que[MAXN],ql,qr;\n    que[ql = qr = 1] = 1;\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(auto t : v[u]) {\n\t    if(!vis[t]) {\n\t\tvis[t] = 1;\n\t\tfa[ch[t]] = u;\n\t\tque[++qr] = ch[t];\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    if(Dinic() != N - 1) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= N - 1 ; ++i) {\n\tint u = i + N;\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(v > 1 && E[j].cap == 0) {ch[i] = v;break;}\n\t}\n    }\n    construct();\n    for(int i = 1 ; i < N ; ++i) {\n\tif(!vis[i]) {puts(\"-1\");return;}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tout(fa[ch[i]]);space;out(ch[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],u[N],v[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,e) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; u[m]=i; v[m]=id[j]; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,m) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU \n// #pragma GCC optimize(\"O3\")  // CPU \n// #pragma GCC optimize(\"unroll-loops\")  // \n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// \n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nvector<int>rev[110000];\nint n;\nvector<int>g[210000];\nint t[210000];\nint L[110000];\nint R[110000];\nvoid dfs(int a){\n\tt[a]=1;\n\tfor(int i=0;i<g[a].size();i++){\n\t\tint to=g[a][i];\n\t\tif(t[to])continue;\n\t\tif(to<a-1){\n\t\t\tR[to]=a-n+1;\n\t\t}else{\n\t\t\tL[a]=to-n+1;\n\t\t}\n\t\tdfs(to);\n\t}\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t\trev[c].push_back(i);\n\t\t}\n\t}\n\n\tfor(int i=0;i<a-1;i++){\n\t\t// std::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tif(0==v[i][j])continue;\n\t\t\t// printf(\"[%d] [%d]\\n\",i,v[i][j]);\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\tfor(int k=0;k<v[i].size();k++){\n\t\t\t\t\tg[v[i][k]+a-1].push_back(i);\n\t\t\t\t}\n\t\t\t\tg[i].push_back(to+a-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++)L[i]=R[i]-1;\n\tdfs(a-1);\n\tfor(int i=0;i<a-1;i++){\n\t\tif(L[i]==-1||R[i]==-1){\n\t\t\tprintf(\"-1\\n\");return 0;\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",L[i]+1,R[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline int solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\tint link = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tlink++;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn link;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif (solve() < n - 1)\n\t\treturn 0;\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nnamespace NetworkFlow {\n\tconst int INF = 2e9;\n\tconst int MAXP = 2e5 + 5;\n\tstruct edge {\n\t\tint dest, flow;\n\t\tunsigned pos;\n\t};\n\tvector <edge> a[MAXP];\n\tint tot, s, t, dist[MAXP];\n\tunsigned curr[MAXP];\n\tvoid addedge(int x, int y, int z) {\n\t\ta[x].push_back((edge) {y, z, a[y].size()});\n\t\ta[y].push_back((edge) {x, 0, a[x].size() - 1});\n\t}\n\tint dinic(int pos, int limit) {\n\t\tif (pos == t) return limit;\n\t\tint used = 0, tmp;\n\t\tfor (unsigned &i = curr[pos]; i < a[pos].size(); i++)\n\t\t\tif (a[pos][i].flow != 0 && dist[pos] + 1 == dist[a[pos][i].dest] && (tmp = dinic(a[pos][i].dest, min(limit - used, a[pos][i].flow)))) {\n\t\t\t\tused += tmp;\n\t\t\t\ta[pos][i].flow -= tmp;\n\t\t\t\ta[a[pos][i].dest][a[pos][i].pos].flow += tmp;\n\t\t\t\tif (used == limit) return used;\n\t\t\t}\n\t\treturn used;\n\t}\n\tbool bfs() {\n\t\tstatic int q[MAXP];\n\t\tint l = 0, r = 0;\n\t\tmemset(dist, 0, sizeof(dist));\n\t\tdist[s] = 1, q[0] = s;\n\t\twhile (l <= r) {\n\t\t\tint tmp = q[l];\n\t\t\tfor (unsigned i = 0; i < a[tmp].size(); i++)\n\t\t\t\tif (dist[a[tmp][i].dest] == 0 && a[tmp][i].flow != 0) {\n\t\t\t\t\tq[++r] = a[tmp][i].dest;\n\t\t\t\t\tdist[q[r]] = dist[tmp] + 1;\n\t\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\treturn dist[t] != 0;\n\t}\n\tint flow() {\n\t\tint ans = 0;\n\t\twhile (bfs()) {\n\t\t\tmemset(curr, 0, sizeof(curr));\n\t\t\tans += dinic(s, INF);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid getmatch(int n, int *match) {\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tfor (auto x : a[i])\n\t\t\t\tif (x.dest > n && x.flow == 0) {\n\t\t\t\t\tmatch[i] = x.dest - n;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t}\n}\nbool vis[MAXN], used[MAXN];\nint n, match[MAXN];\npair <int, int> ans[MAXN];\nvector <int> a[MAXN], b[MAXN];\nint main() {\n\tread(n);\n\tNetworkFlow :: s = 1;\n\tNetworkFlow :: t = n * 2 + 1;\n\tfor (int i = 2; i <= n; i++) {\n\t\tint k; read(k);\n\t\tNetworkFlow :: addedge(1, i, 1);\n\t\twhile (k--) {\n\t\t\tint x; read(x);\n\t\t\ta[i].push_back(x);\n\t\t\tb[x].push_back(i);\n\t\t\tNetworkFlow :: addedge(i, x + n, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tNetworkFlow :: addedge(i + n, n * 2 + 1, 1);\n\tif (NetworkFlow :: flow() < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tNetworkFlow :: getmatch(n, match);\n\tfor (int i = 1; i <= n; i++)\n\t\tvis[i] = true;\n\tfor (int i = 2; i <= n; i++)\n\t\tvis[match[i]] = false;\n\tqueue <int> q;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (vis[i]) {\n\t\t\tfor (auto x : b[i]) {\n\t\t\t\tq.push(x);\n\t\t\t\tused[x] = true;\n\t\t\t}\n\t\t}\n\twhile (!q.empty()) {\n\t\tint tmp = q.front();\n\t\tfor (auto x : a[tmp])\n\t\t\tif (vis[x]) {\n\t\t\t\tans[tmp] = make_pair(x, match[tmp]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tvis[match[tmp]] = true;\n\t\tfor (auto x : b[match[tmp]])\n\t\t\tif (!used[x]) {\n\t\t\t\tq.push(x);\n\t\t\t\tused[x] = true;\n\t\t\t}\n\t\tq.pop();\n\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tif (ans[i].first == 0) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i = 2; i <= n; i++)\n\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst int INF = int(1e9);\nconst int MX = 222222;\n\nstruct edge\n{\n\tint to,cap,rev;\n\tedge(int to=0,int cap=0,int rev=0):to(to),cap(cap),rev(rev){}\n};\nvector <edge> vec[MX];\nint level[MX];\nint iter[MX];\n\nvoid addedge(int s,int t,int c) //adds an edge of cap c to the flow graph\n{\n\tint S=vec[s].size(),T=vec[t].size();\n\tvec[s].push_back(edge(t,c,T));\n\tvec[t].push_back(edge(s,0,S));\n}\nvoid bfs(int s)\n{\n\tmemset(level,-1,sizeof(level));\n\tqueue <int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i=0;i<vec[v].size();i++)\n\t\t{\n\t\t\tedge&e=vec[v][i];\n\t\t\tif (e.cap>0&&level[e.to]<0)\n\t\t\t{\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\nll flow_dfs(int v,int t,ll f)\n{\n\tif (v==t) return f;\n\tfor(int &i=iter[v];i<vec[v].size();i++)\n\t{\n\t\tedge &e=vec[v][i];\n\t\tif (e.cap>0&&level[v]<level[e.to])\n\t\t{\n\t\t\tll d=flow_dfs(e.to,t,min(f,ll(e.cap)));\n\t\t\tif (d>0)\n\t\t\t{\n\t\t\t\te.cap-=d;\n\t\t\t\tvec[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nll maxflow(int s,int t) //finds max flow using dinic from s to t\n{\n\tll flow = 0;\n\twhile(1)\n\t{\n\t\tbfs(s);\n\t\tif (level[t]<0) return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\twhile (1)\n\t\t{\n\t\t\tll f=flow_dfs(s,t,INF);\n\t\t\tif(f==0) break;\n\t\t\tflow += f;\n\t\t}\n\t}\n}\n\nvi A[222222];\nvi contained[222222];\nbool visited[222222];\nii chosen[222222];\nint match[222222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tint s = MX-1; int e = MX-2;\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tchosen[i]=mp(-1,-1);\n\t\tint k; cin>>k;\n\t\taddedge(s,i,1);\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint u; cin>>u; u--;\n\t\t\taddedge(i,u+n,1);\n\t\t\tA[i].pb(u); contained[u].pb(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) addedge(i+n,e,1);\n\tint maxmatch = maxflow(s,e);\n\tif(maxmatch!=n-1)\n\t{\n\t\tcout<<-1<<'\\n'; return 0;\n\t}\n\tset<int> S;\n\tfor(int i=0;i<n;i++) S.insert(i);\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tfor(auto X:vec[i])\n\t\t{\n\t\t\tif(X.to-n>=0&&X.to-n<n&&X.cap==0)\n\t\t\t{\n\t\t\t\tmatch[i]=X.to-n; S.erase(match[i]); break;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> q;\n\tq.push((*S.begin()));\n\twhile(!q.empty())\n\t{\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v:contained[u])\n\t\t{\n\t\t\tif(visited[v]) continue;\n\t\t\t//cerr<<\"CHOOSE \"<<v<<\" : \"<<u<<' '<<match[v]<<'\\n';\n\t\t\tchosen[v] = mp(u, match[v]);\n\t\t\tvisited[v]=1;\n\t\t\tq.push(match[v]);\n\t\t}\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tif(chosen[i].fi<0){cout<<-1<<'\\n'; return 0;}\n\t}\n\tfor(int i=0;i<n-1;i++)\n\t{\n\t\tcout<<chosen[i].fi+1<<' '<<chosen[i].se+1<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    for (int to : g[v]) {\n        if (dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..: :::::::-`        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n#define aimbot\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--) \n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a % b == 0) return 0;\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\n\nint n;\nvector<vector<int>> g;\nvector<int> rez;\nvector<int> sc;\nvector<bool> used;\n\nbool ktun(int v) {\n\tused[v] = true;\n\tfor (int sub : g[v]) {\n\t\tif (rez[sub] == -1) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int sub : g[v]) {\n\t\tif (used[rez[sub]]) continue;\n\t\tif (ktun(rez[sub])) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\t\n\tg.resize(n);\n\trez.resize(n - 1, -1);\n\tsc.resize(n - 1, -1);\n\tf(i, n - 1) {\n\t\tint k;\n\t\tscan k;\n\t\tf(j, k) {\n\t\t\tint x;\n\t\t\tscan x;\n\t\t\tx--;\n\t\t\tg[x].pb(i);\n\t\t}\n\t}\n\tused = vector<bool>(n, false);\n\tf(i, n) {\n\t\tif (ktun(i)) {\n\t\t\tused = vector<bool>(n, false);\n\t\t}\n\t}\n\tset<int> all;\n\tf(i, n) {\n\t\tall.insert(i);\n\t}\n\tvector<int> id(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (rez[i] == -1) {\n\t\t\tprint -1;\n\t\t\treturn 0;\n\t\t}\n\t\tid[rez[i]] = i;\n\t\tall.erase(rez[i]);\n\t}\n\tused = vector<bool>(n, false);\n\tdeque<int> deq{*all.begin()};\n\tused[deq[0]] = true;\n\twhile (!deq.empty()) {\n\t\tint v = deq[0];\n\t\tdeq.pop_front();\n\t\tfor (int sub : g[v]) {\n\t\t\tif (used[rez[sub]]) continue;\n\t\t\tused[rez[sub]] = true;\n\t\t\tsc[sub] = v;\n\t\t\tdeq.pb(rez[sub]);\n\t\t}\n\t}\n\tif (used != vector<bool>(n, true)) {\n\t\tprint -1;\n\t\treturn 0;\n\t}\n\tf(i, n - 1) {\n\t\tprint rez[i] + 1, sc[i] + 1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200100;\nstruct T {\n\tint to, nxt, v;\n} way[maxn << 1];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n\tway[++num] = {y, h[x], v}, h[x] = num;\n\tway[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n\tstd::queue<int> q;\n\tfor(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n\tfor(q.push(s), dis[s] = 0;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n\t\t\tdis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n\t}\n\treturn dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n\tif(s == t || !lim) return lim;\n\tint ans = 0, mn;\n\tfor(int & i = head[s];i;i = way[i].nxt)\n\t\tif(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n\t\t\tway[i].v -= mn;\n\t\t\tway[i ^ 1].v += mn;\n\t\t\tans += mn; lim -= mn;\n\t\t\tif(!lim) break;\n\t\t}\n\treturn ans;\n}\ninline int dinic(int s,int t) {\n\tint ans = 0;\n\tfor(;bfs(s,t);) ans += dfs(s,t,1e9);\n\treturn ans;\n}\nint n;\nstd::vector<int> v[maxn];\nstd::vector<int> to[maxn];\nint id[maxn], fa[maxn];\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1,x,a;i < n;++i) {\n\t\tstd::cin >> x, adde(0, i, 1);\n\t\tfor(;x--;) {\n\t\t\tstd::cin >> a, v[i].push_back(a);\n\t\t\tif(a != n) adde(i, a + n, 1);\n\t\t}\n\t}\n\tfor(int i = 1;i < n;++i) adde(i + n,n + n + 1,1);\n\tif(dinic(0,n + n + 1) != n - 1) {\n\t\tstd::cout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i <= n;++i) for(int j = h[i + n];j;j=way[j].nxt) if(way[j].v == 1 && way[j].to < n)\n\t\tid[way[j].to] = i;\n\tfor(int i = 1;i < n;++i) for(int j : v[i])\n\t\tto[j].push_back(id[i]);\n\tstd::queue<int> q; \n\tfor(q.push(n), fa[n] = 1;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i : to[t]) if(!fa[i])\n\t\t\tq.push(i), fa[i] = t;\n\t}\n\tif(std::count(fa + 1,fa + n + 1,0)) {\n\t\tstd::cout << - 1 << '\\n';\n\t} else {\n\t\tfor(int i = 1;i < n;++i) std::cout << fa[i] << ' ' << i << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G2;\nint n, Deg[N_], UF[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nvector<int>TP[N_];\nint Num[N_], Q[N_], head, tail, vis[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG2.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\n\t\tG2.Add_Edge(G2.source, i, 1);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tTP[a].push_back(i);\n\t\t\tif (a != 1) {\n\t\t\t\tG2.Add_Edge(i, n - 1 + a, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif(i!=1)G2.Add_Edge(n - 1 + i, G2.sink, 1);\n\t}\n\tG2.Dinic();\n\tfor (i = 2; i <= n; i++) {\n\t\tfor (auto &x : G2.G[n - 1 + i]) {\n\t\t\tEdge tp = G2.E[x];\n\t\t\tif (tp.f) {\n\t\t\t\tNum[tp.e] = i;\n\t\t\t}\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : TP[x]) {\n\t\t\tif (!vis[t]) {\n\t\t\t\tRes[t][0] = x;\n\t\t\t\tRes[t][1] = Num[t];\n\t\t\t\tQ[++tail] = Num[t];\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (tail!=n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nconst int N=1e6+5;\nint n,s,ans,now=1,v[N],w[N],cr[N],vi[N],dis[N],nex[N],head[N];\nvoid addedges(int x,int y,int z){\n\tnex[++now]=head[x],w[now]=z;\n\thead[x]=now,v[now]=y;\n}\nvoid add(int x,int y,int z){\n\taddedges(x,y,z);\n\taddedges(y,x,0);\n}\nqueue<int>que;\nbool bfs(){\n\tfor(int i=0;i<=s;i++)\tcr[i]=head[i];\n\tfor(int i=0;i<s;i++)\tdis[i]=0;\n\tdis[s]=1,que.push(s);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tfor(int i=head[x];i;i=nex[i]){\n\t\t\tif(w[i]&&!dis[v[i]]){\n\t\t\t\tdis[v[i]]=dis[x]+1;\n\t\t\t\tque.push(v[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[0];\n}\nint dfs(int x,int f){\n\tint ans=0;\n\tif(!x||!f)\treturn f;\n\tfor(int &i=cr[x];i;i=nex[i])\n\t\tif(w[i]&&dis[v[i]]==dis[x]+1){\n\t\t\tint d=dfs(v[i],min(w[i],f));\n\t\t\tif(!d)\tcontinue;\n\t\t\tans+=d,w[i]-=d;\n\t\t\tw[i^1]+=d,f-=d;\n\t\t\tif(!f)\tbreak;\n\t\t}\n\tif(!ans)\tdis[x]=-1;\n\treturn ans;\n}\nint bl[N];\nvector<int>b[N];\nint main(){\n\t//freopen(\"1.out\",\"w\",stdout);\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),s=n*2;\n\tfor(int i=1,si,x;i<n;i++){\n\t\tscanf(\"%d\",&si),add(s,i+n,1);\n\t\twhile(si--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tb[x].push_back(i+n);\n\t\t\tif(x!=1)\tadd(i+n,x,1);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\tadd(i,0,1);\n\n\twhile(bfs())\n\twhile(int d=dfs(s,inf))\tans+=d;\n\n\tif(ans!=n-1)\tputs(\"-1\"),exit(0);\n\tfor(int i=n+1;i<s;i++)\n\t\tfor(int j=head[i];j;j=nex[j])\n\t\t\tif(!w[j])\tbl[i]=v[j];\n\tque.push(1);\n\twhile(!que.empty()){\n\t\tint x=que.front();\tque.pop();\n\t\tint si=b[x].size();\n\t\tfor(int i=0;i<si;i++)\n\t\t\tif(!vi[b[x][i]]){\n\t\t\t\tprintf(\"%d %d\\n\",x,bl[b[x][i]]);\n\t\t\t\tvi[b[x][i]]=1,que.push(bl[b[x][i]]);\n\t\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint n;\nvector<edge> G[200005];\nint S, T;\nllint level[200005], iter[200005];\n\nvector<llint> revG[200005];\nllint succ[200005];\nbool used[200005];\nvector<P> avec;\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nvoid dfs2(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tavec.push_back(P(v, succ[revG[v][i]]));\n\t\tdfs2(succ[revG[v][i]]);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint c, w;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> w;\n\t\t\tadd_edge(i, n+w, 1);\n\t\t\trevG[w].push_back(i);\n\t\t}\n\t}\n\tS = 2*n+1, T = 2*n+2;\n\t\n\tfor(int i = 1; i <= n-1; i++) add_edge(S, i, 1);\n\tfor(int i = 1; i <= n; i++) add_edge(n+i, T, 1);\n\t\n\tllint ans = 0, flow;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(level[T] >= inf) break;\n\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\twhile(1){\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t}\n\tif(ans < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].to == S) continue;\n\t\t\tif(G[i][j].cap == 0) succ[i] = G[i][j].to-n;\n\t\t}\n\t}\n\tint r;\n\tfor(int i = 0; i < G[T].size(); i++){\n\t\tif(G[T][i].cap == 0){\n\t\t\tr = G[T][i].to-n;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdfs2(r);\n\t\n\tif(avec.size() < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 0; i < avec.size(); i++){\n\t\tcout << avec[i].first << \" \" << avec[i].second << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint cnt=1,head[MAXN],cur[MAXN],d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool BFS(){\n\tmemset(d,0,sizeof(d)),d[S]=1;queue<int>q;q.push(S);\n\tfor(int x;!q.empty();){\n\t\tx=q.front(),q.pop();\n\t\tfor(int i=head[x],y;i;i=edges[i].next)\n\t\t\tif(!d[y=edges[i].to]&&edges[i].w)d[y]=d[x]+1,q.push(y);\n\t}return d[T];\n}int DFS(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(d[y=edges[i].to]==d[x]+1&&edges[i].w){\n\t\tk=DFS(y,min(dist,edges[i].w)),edges[i].w-=k,edges[i^1].w+=k,z+=k,dist-=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(BFS())memcpy(cur,head,sizeof(head)),ans+=DFS(S,1e9);return ans;}\n//struct Edge{int to,next,w;}edges[MAXM];\n//int head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\n//inline void add(int x,int y,int w){\n//\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n//\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n//}inline bool bfs(){\n//\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n//\tfor(int x;!q.empty();q.pop())\n//\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n//\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n//\treturn d[T];\n//}int dfs(int x,int dist){\n//\tif(x==T||!dist)return dist;int z=0;\n//\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n//\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n//\t\tif(!dist)break;\n//\t}return z;\n//}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\treturn 0;\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n//\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const inf=1e8;\nint n,target[800005],pre[800005],last[200005],cap[800005],tot=1,maxflow,\ncur[200005],s,t,dis[200005],ans[200005],ans2[200005];\nbool visited[200005];\nqueue<int>q;\nvoid add(int x,int y,int z)\n{\n\ttarget[++tot]=y;\n\tpre[tot]=last[x];\n\tlast[x]=tot;\n\tcap[tot]=z;\n\ttarget[++tot]=x;\n\tpre[tot]=last[y];\n\tlast[y]=tot;\n}\nbool bfs()\n{\n\tfor(int i=1;i<=t;i++)dis[i]=inf,cur[i]=last[i];\n\tcur[0]=last[0];\n\tq.push(0);\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=last[now];i;i=pre[i])\n\t\t{\n\t\t\tif(cap[i]&&dis[target[i]]==inf)\n\t\t\t{\n\t\t\t\tdis[target[i]]=dis[now]+1;\n\t\t\t\tq.push(target[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=inf;\n}\nint dfs(int x,int lim)\n{\n\tif((!lim)||x==t)return lim;\n\tint flow=0;\n\tfor(int i=cur[x];i;cur[x]=i,i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(cap[i]&&dis[target[i]]==dis[x]+1)\n\t\t{\n\t\t\tint d=dfs(target[i],min(lim,cap[i]));\n\t\t\tcap[i]-=d;\n\t\t\tcap[i^1]+=d;\n\t\t\tflow+=d;\n\t\t\tlim-=d;\n\t\t\tif(!lim)return flow;\n\t\t}\n\t}\n\treturn flow;\n}\nvoid dinic()\n{\n\twhile(bfs())maxflow+=dfs(s,inf);\n}\nvoid getans(int x,int fa)\n{\n\t//cout<<x<<endl;\n\tif(x>n)visited[x]=1;\n\tfor(int i=last[x];i;i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(x<=n)\n\t\t{\n\t\t\tif(tar==s||tar==t)continue;\n\t\t\tif(!visited[tar])\n\t\t\t{\n\t\t\t\tgetans(tar,x);\n\t\t\t\t//return;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tar==t||(!cap[i]))continue;\n\t\t\tans[++ans[0]]=fa;\n\t\t\tans2[ans[0]]=tar;\n\t\t\tgetans(tar,tar);\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main()\n{\n\tint x,T;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&T);\n\t\twhile(T--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tadd(x,i+n,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)add(0,i,1);\n\tfor(int i=n+1;i<n*2;i++)add(i,n*2,1);\n\tt=n*2,s=0;\n\tdinic();\n\tif(maxflow<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint st;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor(int j=last[i];j;j=pre[j])\n\t\t{\n\t\t\t//cout<<i<<\" \"<<target[j]<<\" \"<<cap[j]<<endl;\n\t\t\tif(target[j]>n&&(!cap[j]))\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgetans(st,st);\n\tif(ans[0]!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=ans[0];i++)printf(\"%d %d\\n\",ans[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\n\nint n;\n\ninline void failed(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<int> G[N];\nbool vis[N];\nint match[N];\nint pref[N];\nstack<int> stk;\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<G[x].size();i++){\n\t\tint v=G[x][i];if(vis[v])continue;\n\t\tvis[v]=1;stk.push(v);\n\t\tif(!pref[v] || dfs(pref[v])){\n\t\t\tmatch[x] = v;\n\t\t\tpref[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint s[N];\ntypedef pair<int,int> pi;\nvector<pi> tr;\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<n;i++){\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int j=1,e;j<=c;j++){\n\t\t\tscanf(\"%d\",&e);\n\t\t\tG[e].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\t// cout << i << \":\";\n\t\tif(!dfs(i))failed();\n\t\twhile(stk.size()){\n\t\t\t// cout << stk.top();\n\t\t\tvis[stk.top()]=0;\n\t\t\tstk.pop();\n\t\t}\n\t\t// cout << \"?\" << endl;\n\t}\n\tqueue<int> q;\n\tfor(size_t i=0;i<G[1].size();i++){\n\t\ts[G[1][i]]=1;\n\t\tq.push(G[1][i]);\n\t}\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tint v = pref[u];\n\t\ttr.push_back(pi(v,s[u]));\n\t\tfor(size_t i=0;i<G[v].size();i++){\n\t\t\tif(!s[G[v][i]])s[G[v][i]]=v,q.push(G[v][i]);\n\t\t}\n\t}\n\tif((int)tr.size()<n-1){\n\t\tfailed();\n\t}\n\tfor(size_t i=0;i<tr.size();i++){\n\t\tprintf(\"%d %d\\n\",tr[i].first,tr[i].second);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back({x,i,mxfl::adde(x,i+n,1)});\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[1]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200005;\nconst int ME = 500005;\nconst int oo = 123123123;\n\ntemplate<typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate<typename T> void read(T &x)\n{\n\tx = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v, c;\n\n\tEDGE (const int &v0 = 0, const int &c0 = 0) : v(v0), c(c0) {}\n};\n\nstruct GRAPH\t//\n{\n\tEDGE e[ME];\n\tint fst[MX], nxt[ME], lnum;\n\tint dep[MX],q[MX];          //bfs \n\n\tvoid addeg(int nu, int nv, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\tfst[nu] = lnum;\n\t\te[lnum] = EDGE(nv, nc);\n\t}\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tint bfs(int frm,int to)     //\n\t{\n\t\tint h=0,t=1,x,y;\n\t\tmemset(dep,0xff,sizeof(dep));\n\t\tq[++h]=frm;\n\t\tdep[frm]=0;\n\t\twhile(h>=t)\n\t\t{\n\t\t\tx=q[t++];\n\t\t\tfor(int i=fst[x];i!=-1;i=nxt[i])\n\t\t\t{\n\t\t\t\ty=e[i].v;\n\t\t\t\tif(dep[y]==-1&&e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tq[++h]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dep[to]>=0);    //\n\t}\n\n\tint cur[MX];                //\n\tint dinic(int x,int mn,int tar)\n\t{\n\t\tif(x==tar)return mn;\n\t\tint y,a,now=0;\n\t\tfor(int &i=cur[x];i!=-1;i=nxt[i])   //\"int &i=\"\n\t\t{\n\t\t\ty=e[i].v;\n\t\t\tif(e[i].c&&dep[y]==dep[x]+1)\n\t\t\t{\n\t\t\t\ta=dinic(y,min(mn-now,e[i].c),tar);\n\t\t\t\tnow+=a;                     //\n\t\t\t\te[i].c-=a,e[i^1].c+=a;      // dinic \n\t\t\t\tif(mn==now)return now;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\n\tint mxflow(int s, int t)\n\t{\n\t\tint tot=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemmove(cur,fst,sizeof(fst));\n\t\t\ttot+=dinic(s,+oo,t);\n\t\t}\n\t\treturn tot;\n\t}\n} G;\n\nint n;\nint global_s, global_t;\n\nvoid input()\n{\n\tG.init();\n\tread(n);\n\tglobal_s = n*2, global_t = n*2+1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint c, x;\n\t\tread(c);\n\t\tfor(int j=1; j<=c; j++)\n\t\t{\n\t\t\tread(x);\n\t\t\tG.addeg(x, n+i, 1);\n\t\t\tG.addeg(n+i, x, 0);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tG.addeg(global_s, i, 1);\n\t\tG.addeg(i, global_s, 0);\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tG.addeg(n+i, global_t, 1);\n\t\tG.addeg(global_t, n+i, 0);\n\t}\n}\n\nint frm[MX];\n\nvoid dfs(int x, int f)\n{\n\tfrm[x] = f;\n\tfor(int i=G.fst[x]; ~i; i=G.nxt[i])\n\t\tif(G.e[i].c && !frm[G.e[i].v])\n\t\t\tdfs(G.e[i].v, x);\n}\n\nvoid work()\n{\n\tif(G.mxflow(global_s, global_t) != n-1) puts(\"-1\");\n\telse\n\t{\n\t\tint root = 0;\n\t\tfor(int i=G.fst[global_s]; ~i; i=G.nxt[i])\n\t\t\tif(G.e[i].c)\n\t\t\t\troot = G.e[i].v;\n\t\tdfs(root, -1);\n\t\tbool fucked = 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tif(!frm[i])\n\t\t\t\tfucked = 1;\n\t\tif(fucked) puts(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++)\n\t\t\t\tif(i != root)\n\t\t\t\t\tprintf(\"%d %d\\n\", i, frm[frm[i]]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200005;\nconst int MAXM = 400005;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint S, T, level[MAXN], q[MAXN], head, tail;\n\nstruct Edge {\n\tint v, w, nxt;\n} e[MAXM << 1];\nint first[MAXN], used[MAXN], eCnt;\n\ninline void AddEdge(int u, int v, int w) {\n\te[++eCnt].v = v;\n\te[eCnt].w = w;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\ninline void Add(int u, int v, int w) {\n\tAddEdge(u, v, w);\n\tAddEdge(v, u, 0);\n}\n\ninline int Match(int u) {\n\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\tif (e[i].v != T && e[i].w) return e[i].v;\n\t}\n\treturn 0;\n}\n\nbool BFS() {\n\tfor (int i = 1; i <= T; ++i) {\n\t\tlevel[i] = -1;\n\t\tused[i] = first[i];\n\t}\n\tlevel[S] = 0;\n\tq[head = tail = 1] = S;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tif (u == T) return 1;\n\t\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && level[v] == -1) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++tail] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint DFS(int u, int flow) {\n\tif (u == T) return flow;\n\tint ret = 0;\n\tfor (int i = used[u]; i; i = e[i].nxt, used[u] = i) {\n\t\tint v = e[i].v;\n\t\tif (e[i].w && level[v] == level[u] + 1) {\n\t\t\tint tmp = DFS(v, min(flow, e[i].w));\n\t\t\te[i].w -= tmp;\n\t\t\te[i ^ 1].w += tmp;\n\t\t\tflow -= tmp;\n\t\t\tret += tmp;\n\t\t\tif (!flow) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Dinic() {\n\tint ret = 0;\n\twhile (BFS()) {\n\t\tret += DFS(S, INF);\n\t}\n\treturn ret;\n}\n\nint n, son[MAXN], fa[MAXN];\nvector<int> ine[MAXN];\n\nvoid init() {\n\tread(n);\n\teCnt = S = 1, T = n * 2;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint siz; read(siz);\n\t\tAdd(S, n + i, 1);\n\t\tfor (int j = 1; j <= siz; ++j) {\n\t\t\tint x; read(x);\n\t\t\tine[x].push_back(i);\n\t\t\tif (x == 1) continue;\n\t\t\tAdd(n + i, x, 1);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tAdd(i, T, 1);\n\t}\n}\n\nvoid solve() {\n\tif (Dinic() < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tson[Match(i) - n] = i;\n\t}\n\tq[head = tail = 1] = 1;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tfor (auto v : ine[u]) {\n\t\t\tif (fa[v]) continue;\n\t\t\tfa[v] = u;\n\t\t\tq[++tail] = son[v];\n\t\t}\n\t}\n\tif (tail < n) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tprintf(\"%d %d\\n\", fa[i], son[i]);\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 20];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int i=h[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[u]=v-n;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+99,M=61e4;\ninline int min(const int&a,const int&b){return a<b?a:b;}\nstruct graph{\n\tstruct edge{int to,next,f;}e[M<<1];\n\tint h[N],cur[N],xb;\n\tinline void addedge(int x,int y,int z){\n\t\te[++xb]=(edge){y,h[x],z};h[x]=xb;\n\t\te[++xb]=(edge){x,h[y],0};h[y]=xb;\n\t}\n\tint S,T,d[N],n;\n\tinline bool bfs(){\n\t\tstatic int q[N];int t=0,w=1;q[1]=S;\n\t\tmemset(d+1,0,n<<2);d[S]=1;\n\t\tfor(;t<w;){\n\t\t\tint u=q[++t];\n\t\t\tfor(int i=h[u];i;i=e[i].next)if(e[i].f && !d[e[i].to])\n\t\t\t\td[e[i].to]=d[u]+1,q[++w]=e[i].to;\n\t\t}\n\t\treturn d[T];\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==T)return f;\n\t\tint ans=0,&i=cur[x],t;\n\t\tfor(;i;i=e[i].next)if(e[i].f && d[e[i].to]==d[x]+1){\n\t\t\tif(t=dfs(e[i].to,min(f,e[i].f))){\n\t\t\t\tans+=t,e[i].f-=t;e[i^1].f+=t;f-=t;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tinline int dinic(int s,int t){\n\t\tint ans=0;S=s;T=t;\n\t\tfor(;bfs();ans+=dfs(s,1<<30))memcpy(cur+1,h+1,n<<2);\n\t\treturn ans;\n\t}\n}g;\nint n,i,j,fa[N],bel[N],u1[N],v1[N];\nvector<int>v[N],vv[N];\nvoid dfs(int x){\n\tauto t=v[x];v[x].clear();\n\tfor(int y:t)if(!fa[y])fa[y]=x,dfs(y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tg.n=n*2;g.xb=1;\n\tfor(i=2;i<=n;++i)g.addedge(n-2+i,g.n,1);\n\tfor(i=1;i<n;++i){\n\t\tscanf(\"%d\",&j);vv[i].resize(j);\n\t\tfor(int&x:vv[i]){scanf(\"%d\",&x);if(x>1)g.addedge(i,n-2+x,1);}\n\t\tg.addedge(g.n-1,i,1);\n\t}\n\tif(g.dinic(g.n-1,g.n)<n-1){puts(\"-1\");return 0;}\n\tfor(i=1;i<n;++i){\n\t\tfor(j=g.h[i];g.e[j].f;j=g.e[j].next);\n\t\tint x=g.e[j].to-(n-2);bel[x]=i;\n//cerr<<x<<' '<<i<<endl;\n\t\tfor(int y:vv[i])if(y!=x)v[y].push_back(x);\n\t}\n\tdfs(1);\n\tfor(i=1,j=0;i<=n;++i)j+=!fa[i];\n\tif(j>1){puts(\"-1\");return 0;}\n\tfor(i=2;i<=n;++i)u1[bel[i]]=i,v1[bel[i]]=fa[i];\n//\tfor(i=1;i<=n;++i)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\tfor(i=1;i<n;++i)printf(\"%d %d\\n\",u1[i],v1[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define db long double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define EB emplace_back\n#define fi first\n#define se second\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define UPD(x,y) (((x)+=(y))>=mo?x-=mo:233)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n \n#define inf 1<<30\n#define sqr(x) ((x)*(x))\nusing namespace std;\nconst int N=100005;\nstruct edge{\n\tint to,next,f;\n}e[N*10];\nint head[N*2],tot=1,S,T;\nint dis[N*2],q[N*2];\nvoid add(int x,int y,int v){\n\te[++tot]=(edge){y,head[x],v};\n\thead[x]=tot;\n\te[++tot]=(edge){x,head[y],v};\n\thead[y]=tot;\n}\nbool bfs(){\n\tFor(i,1,T) dis[i]=-1;\n\tq[0]=1; q[1]=S; dis[S]=1;\n\tFor(h,1,q[0])\n\t\tfor (int i=head[q[h]];i;i=e[i].next)\n\t\t\tif (dis[e[i].to]==-1&&e[i].f){\n\t\t\t\tdis[e[i].to]=dis[q[h]]+1;\n\t\t\t\tif (e[i].to==T) return 1;\n\t\t\t\tq[++q[0]]=e[i].to;\n\t\t\t}\n\treturn 0;\n}\nint dfs(int x,int flow){\n\tif (x==T) return flow;\n\tint k,rest=flow;\n\tfor (int i=head[x];i&&rest;i=e[i].next)\n\t\tif (dis[e[i].to]==dis[x]+1&&e[i].f){\n\t\t\tk=dfs(e[i].to,min(rest,e[i].f));\n\t\t\te[i].f-=k; e[i^1].f+=k; rest-=k;\n\t\t}\n\tif (rest) dis[x]=-1;\n\treturn flow-rest;\n}\nvector<int> v[N],V[N];\nint cnt,n;\nint fa[N],mat[N];\nbool vis[N];\nvoid dfs(int x){\n\t++cnt; vis[x]=1;\n\tfor (auto i:V[x])\n\t\tif (!vis[mat[i]]){\n\t\t\tfa[i]=x;\n\t\t\tdfs(mat[i]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=2*n; T=2*n+1;\n\tFor(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tv[i].resize(cnt);\n\t\tFor(j,0,cnt-1){\n\t\t\tscanf(\"%d\",&v[i][j]);\n\t\t\tif (v[i][j]!=1)\n\t\t\t\tadd(i+n,v[i][j],1);\n\t\t\tV[v[i][j]].PB(i);\n\t\t}\n\t}\n\tFor(i,2,n)\n\t\tadd(i,T,1);\n\tint flow=0;\n\tfor (;bfs();flow+=dfs(S,inf));\n\tif (flow!=n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tfor (int j=head[i+n];j;j=e[j].next)\n\t\t\tif (e[j].to<S&&!e[j].f)\n\t\t\t\tmat[i]=e[j].to;\n\tdfs(1);\n\tif (cnt!=n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",mat[i],fa[i]);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=2147483647;\n#define N 100005\nint n,m,S,T,cc=1,hd[1000005],iter[1000005],d[1000005],vis[N],t[N],t1[N],t2[N];\nvector<int>g[N];\nstruct E{int v,nxt,w;}e[1000005];\nvoid add(int u,int v,int w){e[++cc]=(E){v,hd[u],w};hd[u]=cc;e[++cc]=(E){u,hd[v],0};hd[v]=cc;}\nbool bfs()\n{\n\tfor(int i=1;i<=T;i++)d[i]=inf;\n\tqueue<int>q;q.push(S);d[S]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=hd[x];i;i=e[i].nxt)if(e[i].w&&d[e[i].v]==inf){d[e[i].v]=d[x]+1;q.push(e[i].v);}\n\t}\n\treturn d[T]<inf;\n}\nint dfs(int x,int f)\n{\n\tif(!f||x==T)return f;\n\tint sf=0;\n\tfor(int &i=iter[x];i;i=e[i].nxt)if(e[i].w&&d[e[i].v]==d[x]+1)\n\t{\n\t\tint ff=dfs(e[i].v,min(f,e[i].w));\n\t\tif(ff){e[i].w-=ff;e[i^1].w+=ff;f-=ff;sf+=ff;}\n\t}\n\treturn sf;\n} \nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tmemcpy(iter,hd,sizeof(iter));\n\t\tint f;while(f=dfs(S,inf))ans+=f;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);S=1;T=2*n;\n\tfor(int i=2;i<=n;i++)add(S,i,1);\n\tfor(int i=n+1;i<2*n;i++)add(i,T,1);\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tg[x].push_back(i);\n\t\t\tif(x>1)add(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic()!=n-1){puts(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)for(int j=hd[i];j;j=e[j].nxt)if(!e[j].w)t[i]=e[j].v-n+1;\n\tqueue<int>q;q.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor(int i=0;i<g[x].size();i++)\n\t\t{\n\t\t\tint y=g[x][i];\n\t\t\tif(vis[y])continue;\n\t\t\tvis[y]=1;t1[y]=x;t2[y]=t[y];\n\t\t\tq.push(t[y]);\n\t\t} \n\t}\n\tfor(int i=2;i<=n;i++)if(!t1[i]){puts(\"-1\");return 0;}\n\tfor(int i=2;i<=n;i++)printf(\"%d %d\\n\",t1[i],t2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\nint vt[N*2],tim;\nint cur[N*2];\n\nbool bfs(){\n\ttim++;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tvt[st]=tim;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt){\n\t\t\tint y=e[p].x;\n\t\t\tif (vt[y]<tim&&e[p].f){\n\t\t\t\tvt[y]=tim;\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tque[++ta]=y;\n\t\t\t}\n\t\t}\n\t}\n\treturn vt[ed]==tim;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int &p=cur[x];p;p=e[p].nxt)\n\tif (e[p].f&&vt[e[p].x]==tim&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs()){\n\t\tfo(i,0,n*2+1)cur[i]=h[i];\n\t\tint tmp=aug(st,INF);\n\t\twhile(tmp){\n\t\t\tret+=tmp;\n\t\t\ttmp=aug(st,INF);\n\t\t}\n\t}\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\nstruct Bipartite_matching{\n\tint V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\tBipartite_matching(int N){\n\t\tV=N;\n\t\tG.assign(V,vector<int>());\n\t\tmatch.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\tvoid add_edge(int v,int u){\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tbool dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res=0;\n\t\tfill(all(match),-1);\n\t\trep(v,V){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(all(used),false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tint N;\n\tcin>>N;\n\tVV<int> A(N-1);\n\tVV<int> v2as(N);\n\trep(i,N-1){\n\t\tint K;\n\t\tcin>>K;\n\t\trep(j,K){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tx--;\n\t\t\tA[i].pb(x);\n\t\t\tv2as[x].pb(i);\n\t\t}\n\t}\n\tBipartite_matching BM(N-1+N);\n\trep(i,N-1){\n\t\tfor(int v:A[i]) BM.add_edge(i,v+N-1);\n\t}\n\tint f = BM.max_matching();\n\tif(f != N-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tV<int> match(N-1);\n\trep(i,N-1) match[i] = BM.match[i] - (N-1);\n\n\t\n\tVV<int> ans(N-1,V<int>(2,-1));\n\trep(i,N-1) ans[i][0] = match[i];\n\n\tint r = 0;\n\trep(i,N) r ^= i;\n\trep(i,N-1) r ^= match[i];\n\tqueue<int> que;\n\tque.push(r);\n\t\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i: v2as[v]) if(ans[i][0] != v && ans[i][1] == -1){\n\t\t\tans[i][1] = v;\n\t\t\tque.push(ans[i][0]);\n\t\t}\n\t}\n\trep(i,N-1) if(ans[i][1] == -1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,N-1) cout<<ans[i][0]+1<<\" \"<<ans[i][1]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1000010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int i = head[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        if (a == 0)\n            d[e[i].v] = 0;\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], vis[100010], to[100010], ans[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue <int> q;\n    q.push(n);\n    vis[n] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (e[i].c == 0 && !::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 4e5, inf = 1e9;\nint n, tot, ter[maxn + 3], wei[maxn + 3], nxt[maxn + 3], lnk[maxn + 3];\nint cur[maxn + 3], dep[maxn + 3], num[maxn + 3], ans[maxn + 3];\nbool vis[maxn + 3];\nvector<int> S[maxn + 3], V[maxn + 3], G[maxn + 3];\n\nint adj(int x) {\n\treturn x & 1 ? x + 1 : x - 1;\n}\n\nint add(int u, int v, int w) {\n\tter[++tot] = v, wei[tot] = w;\n\tnxt[tot] = lnk[u], lnk[u] = tot;\n\treturn tot;\n}\n\nint add_f(int u, int v) {\n\tint t = add(u, v, 1);\n\treturn add(v, u, 0), t;\n}\n\nbool bfs() {\n\tqueue<int> Q;\n\tQ.push(1);\n\tmemset(dep, -1, sizeof(dep));\n\tdep[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = lnk[u], v, w; i; i = nxt[i]) {\n\t\t\tv = ter[i], w = wei[i];\n\t\t\tif ((~dep[v]) || !w) continue;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tQ.push(v);\n\t\t}\n\t}\n\treturn ~dep[n * 2];\n}\n\nint dfs(int u, int t, int lft) {\n\tif (u == t) {\n\t\treturn lft;\n\t}\n\tint ret = 0;\n\tfor (int &i = cur[u], v, w; i && ret < lft; i = nxt[i]) {\n\t\tv = ter[i], w = wei[i];\n\t\tif (w && dep[u] + 1 == dep[v]) {\n\t\t\tint x = dfs(v, t, min(lft - ret, w));\n\t\t\twei[i] -= x, wei[adj(i)] += x, ret += x;\n\t\t}\n\t}\n\tif (ret < lft) {\n\t\tdep[u] = -1;\n\t}\n\treturn ret;\n}\n\nint flow() {\n\tint ret = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur, lnk, sizeof(cur));\n\t\tret += dfs(1, n * 2, inf);\n\t}\n\treturn ret;\n}\n\nvoid dfs(int u) {\n\tvis[u] = true;\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tv = G[u][i];\n\t\tif (vis[v]) continue;\n\t\tans[v] = u;\n\t\tdfs(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, m; i <= n - 1; i++) {\n\t\tscanf(\"%d\", &m);\n\t\tS[i].resize(m), V[i].resize(m);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &S[i][j]);\n\t\t\tif (S[i][j] != 1) {\n\t\t\t\tV[i][j] = add_f(S[i][j], i + n);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tadd_f(1, i);\n\t}\n\tfor (int i = n + 1; i < n * 2; i++) {\n\t\tadd_f(i, n * 2);\n\t}\n\tif (flow() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint x = 0;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != 1 && !wei[V[i][j]]) {\n\t\t\t\tx = S[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum[i] = x;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != x) {\n\t\t\t\tG[S[i][j]].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tputs(\"-1\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tprintf(\"%d %d\\n\", ans[num[i]], num[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 200010;\nconst int INF = 2147483600;\n\nint N;\n\nint Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],C[MAXN<<1],cnt; \ninline void addedge(int u,int v,int c){\n\tNode[cnt]=v; Next[cnt]=Root[u]; C[cnt]=c; Root[u]=cnt++;\n}\ninline void insert(int u,int v,int c){\n\taddedge(u,v,c); addedge(v,u,0);\n}\nint S,T; int dis[MAXN+1];\ninline bool BFS(){\n\tfor(int i=S;i<=T;i++) dis[i]=0;\n\tqueue<int> que; que.push(S); dis[S]=1;\n\twhile(!que.empty()){\n\t\tint k=que.front();\n\t\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\t\tint v=Node[x]; \n\t\t\tif(C[x]>0&&!dis[v]) dis[v]=dis[k]+1,que.push(v); \n\t\t} que.pop();\n\t} \n\treturn (dis[T]?1:0);\n}\ninline int DFS(int k,int t){\n\tif(k==T) {return t;} int ret=0;\n\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\tint v=Node[x]; if(C[x]>0&&dis[v]==dis[k]+1){\n\t\t\tint d=DFS(v,min(t,C[x]));\n\t\t\tC[x]-=d; C[x^1]+=d; ret+=d; t-=d;\n\t\t\tif(!t) return ret;\n\t\t}\n\t} if(!ret) dis[k]=0;\n\treturn ret;\n}\nint nod;\nqueue<int> que; int vis[MAXN+1],chs[MAXN+1],root;\nvector<int> vec[MAXN+1]; int P[MAXN+1];\ninline void Add(int k){\n\t++nod; for(int i=0,sz=vec[k].size();i<sz;i++){\n\t\tint j=vec[k][i];\n\t\tif(!vis[j]&&chs[j]!=k) vis[j]=k,que.push(j); \n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); T=2*N,S=0;\n\tmemset(Root,-1,sizeof(Root));\n\tfor(int i=1;i<N;i++){\n\t\tP[i]=read();\n\t\tinsert(S,i,1);\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tint x=read();\n\t\t\tvec[x].push_back(i);\n\t\t\tinsert(i,x+N-1,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) insert(i+N-1,T,1);\n\tint sum=0; while(BFS()) sum+=DFS(S,INF);\n\tif(sum!=N-1){ puts(\"-1\"); return 0; }\n\tint id=1; int now=0;\n\tfor(int i=1;i<N;i++){\n\t\tnow+=2;\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tif(!C[now]) chs[i]=Node[now]-(N-1);\n\t\t\tnow+=2;\n\t\t}\n\t}\n\twhile(now<cnt) {\n\t\tif(C[now]) {\n\t\t\troot=id; break;\n\t\t} now+=2; ++id;\n\t} \n\tAdd(root);\n\twhile(!que.empty()){ int k=que.front();  Add(chs[k]); que.pop(); }\n\tif(nod!=N){ puts(\"-1\"); return 0; }\n\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\",chs[i],vis[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--, q[a[i][j]].insert(i);\n        sort(a[i].begin(), a[i].end());\n        reverse(a[i].begin(), a[i].end());\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nconst int N = 100179;\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);return 0;\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UF {\n\tvi t;\n\tUF(int n){\n\t\tt.resize(n, -1);\n\t}\n\tint find(int a){\n\t\treturn t[a]<0 ? a : t[a] = find(t[a]);\n\t}\n\tbool same(int a, int b){\n\t\treturn find(a) == find(b);\n\t}\n\tvoid uni(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return;\n\t\tif(t[a] < t[b]) swap(a,b);\n\t\tt[b] += t[a];\n\t\tt[a] = b;\n\t}\n\tint ss(int a){\n\t\treturn -t[find(a)];\n\t}\n};\n\nvoid fail(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid rem(vector<pii> &v, pii p){\n\trep(i,0,sz(v)) if(v[i]==p){\n\t\tv.erase(v.begin()+i);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tint m = n-1;\n\n\tvector<vi> es(m);\n\ttrav(v, es){\n\t\tint c;\n\t\tcin >> c;\n\t\tv.resize(c);\n\t\ttrav(x, v) cin >> x, --x;\n\t}\n\tvector<vector<pii>> gr(n);\n\tvector<pii> uv(m);\n\tvector<bool> used(m, false);\n\tUF uf(n);\n\trep(i,0,m){\n\t\tint u = es[i][0];\n\t\ttrav(v, es[i]) if(!uf.same(v, u)){\n\t\t\tuf.uni(v, u);\n\t\t\tuv[i] = pii(u, v);\n\t\t\tgr[v].emplace_back(u, i);\n\t\t\tgr[u].emplace_back(v, i);\n\t\t\tused[i] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tset<pii> s;\n\trep(i,0,m) if(!used[i])\n\t\ts.insert(pii(uf.ss(es[i][0]),i));\n\n\tvi pix(n);\n\tvector<bool> vis(m, false);\n\t\n\twhile(!s.empty()){\n\t\tauto it = s.begin();\n\t\tpii pa = *it;\n\t\ts.erase(it);\n\t\tint l = pa.second;\n\t\tint v0 = es[l][0];\n\n\t\tif(pa.first != uf.ss(v0)){\n\t\t\ts.insert(pii(uf.ss(v0),l));\n\t\t\tcontinue;\n\t\t}\n\t\tpix[v0] = -1;\n\t\tstack<int> st;\n\t\tst.push(v0);\n\n\t\twhile(!st.empty()){\n\t\t\tint v = st.top(); st.pop();\n\t\t\trep(i,0,sz(gr[v])){\n\t\t\t\tint u, q;\n\t\t\t\ttie(u,q) = gr[v][i];\n\t\t\t\tif(q == pix[v]) continue;\n\t\t\t\tpix[u] = q;\n\t\t\t\tst.push(u);\n\t\t\t}\n\t\t}\n\n\t\tvi todo;\n\n\t\tfunction<bool(int)> rek = [&](int q){\n\t\t\tif(q < 0 || vis[q]) return false;\n\t\t\tvis[q] = true;\n\t\t\ttodo.push_back(q);\n\t\t\tint v = uv[q].first;\n\t\t\tif(pix[v]==q) v = uv[q].second;\n\t\t\tint w = uv[q].first^uv[q].second^v;\n\n\t\t\ttrav(u, es[q]) if(!uf.same(v, u)){\n\t\t\t\tuf.uni(v,u);\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(rek(pix[v])) return true;\n\t\t\ttrav(u, es[q]) if(rek(pix[u])){\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\ttrav(v, es[l]) if(rek(pix[v])){\n\t\t\tgr[v0].emplace_back(v,l);\n\t\t\tgr[v].emplace_back(v0,l);\n\t\t\tuv[l] = pii(v, v0);\n\t\t\tgoto bar;\n\t\t}\n\t\tfail();\n\t\tbar:\n\t\ttrav(q, todo) vis[q] = false;\n\n\t}\n\n\trep(i,0,m) cout << 1+uv[i].first << ' ' << 1+uv[i].second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=200005,M=1000020,inf=0x3f3f3f3f;\nint read(){\n\tint f=1,g=0;\n\tchar ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-1;\n\tfor (;isdigit(ch);ch=getchar()) g=g*10+ch-'0';\n\treturn f*g;\n}\nint cnt,n,m,S,T,ans[N],ansu[N],h[N];\nvector<int> a[N],b[N];\nint fir[N],firr[N],siz;\nstruct edge{int u,v,w,nex;}e[M];\nvoid add(int u,int v,int w){\n\te[++siz]=(edge){u,v,w,fir[u]};fir[u]=siz;\n\te[++siz]=(edge){v,u,0,fir[v]};fir[v]=siz;\n}\nint dist[N],que[N];\nvoid dec(int x,int fl){e[x].w-=fl;e[x^1].w+=fl;}\nbool bfs(){\n\tmemset(dist,0x3f,4*(cnt+1));\n\tint l=1,r=1;que[l]=S;dist[S]=0;\n\twhile (l<=r){\n\t\tint x=que[l];\n\t\tfor (int i=fir[x];i;i=e[i].nex)\n\t\tif ((e[i].w)&&(dist[e[i].v]>dist[x]+1)){\n\t\t\tque[++r]=e[i].v;\n\t\t\tdist[e[i].v]=dist[x]+1;\n\t\t}\n\t\tl++;\n\t}\n\treturn dist[T]!=inf;\n}\nint dfs(int x,int flow,int &T){\n\tif (x==T) return flow;\n\tint fl=0,t=0;\n\tfor (int i=firr[x];i;i=e[i].nex)\n\tif (e[i].w&&(dist[e[i].v]>dist[x])){\n\t\tt=dfs(e[i].v,min(flow-fl,e[i].w),T);\n\t\tdec(i,t);fl+=t;\n\t\tif (fl==flow) {firr[x]=i;return fl;}\n\t}\n\tfirr[x]=0;\n\treturn fl;\n}\nint dinic(){\n\tint flow=0;\n\twhile (bfs()){\n\t\tfor (int i=0;i<=cnt;i++) firr[i]=fir[i];\n\t\tflow+=dfs(S,inf,T);\n\t\t//cerr<<flow<<endl;\n\t}\n\treturn flow;\n}\nvoid check(int x){\n\th[x]=1;\n\tfor (auto i : b[x])\n\tif (!h[ans[i]]){ansu[i]=x;check(ans[i]);}\n}\nint main(){\n//\tfreopen(\"1.in\",\"r\",stdin);\n\tsiz=1;\n\tn=read();S=1,T=cnt=n*2;\n\tfor (int i=2;i<=n;i++) add(S,i,1);\n\tfor (int i=1;i<n;i++) add(i+n,T,1);\n\tfor (int i=1;i<n;i++){\n\t\tint m=read();\n\t\twhile (m--){\n\t\t\tint x=read();a[i].push_back(x);\n\t\t\tb[x].push_back(i);\n\t\t\tif (x!=1) add(x,i+n,1);\n\t\t}\n\t}\n\tif (dinic()!=n-1){puts(\"-1\");return 0;}\n\tfor (int i=2;i<=siz;i++)\n\tif ((!e[i].w)&&(e[i].u>=1)&&(e[i].u<=n)&&(e[i].v>n)&&(e[i].v<n+n)) ans[e[i].v-n]=e[i].u;\n\tcheck(1);\n\tfor (int i=1;i<=n;i++) if (!h[i]) {puts(\"-1\");return 0;}\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ansu[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nset<int> E[N],app[N];\nvector<pii> ans;\nset<pii> s;\nint n,c,w;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tread(c);\n\t\trep(j,1,c){\n\t\t\tread(w);\n\t\t\tE[i].insert(w);\n\t\t\tapp[w].insert(i);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts.insert(mp(app[i].size(),i));\n\t}\n\twhile(s.size()>=2){\n\t\tint x=s.begin()->se;\n\t\ts.erase(s.begin());\n\t\tif(!app[x].size())GG();\n\t\tint k=*app[x].begin();\n\t\tfor(auto t:app[x])\n\t\t\tif(E[t].size()<E[k].size())k=t;\n\t\tif(E[k].size()<app[x].size())GG();\n\t\tif(E[k].size()<2)GG();\n\t\tint U=*E[k].begin();\n\t\tint V=*(--E[k].end());\n\t\tif(x==U)ans.pb(mp(x,V));\n\t\telse ans.pb(mp(x,U));\n\t\tE[k].erase(x);\n\t\tapp[x].erase(k);\n\t\tfor(auto y:E[k]){\n\t\t\ts.erase(mp(app[y].size(),y));\n\t\t\tapp[y].erase(k);\n\t\t\ts.insert(mp(app[y].size(),y));\n\t\t}\n\t\tfor(auto t:app[x])\n\t\t\tE[t].erase(x);\n\t}\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct edge {\n\tint v, cap, rev;\n\tedge(int a, int b, int c) : v(a), cap(b), rev(c) {}\n};\nvector<edge> adj[200005];\nint lst[200005], dep[200005];\nvoid add(int x, int y, int c)\n{\n\tadj[x].emplace_back(y, c, (int)adj[y].size());\n\tadj[y].emplace_back(x, 0, (int)adj[x].size() - 1);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tqueue<int> que;\n\tque.push(s);\n\twhile (!que.empty()) {\n\t\tint u = que.front();\n\t\tque.pop();\n\t\tfor (edge &e : adj[u]) {\n\t\t\tif (e.cap && dep[e.v] == -1) {\n\t\t\t\tdep[e.v] = dep[u] + 1;\n\t\t\t\tque.push(e.v);\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int c)\n{\n\tif (u == t) {\n\t\treturn c;\n\t}\n\tint res = 0;\n\tfor (int &i = lst[u]; i >= 0; i--) {\n\t\tauto &e = adj[u][i];\n\t\tif (e.cap && dep[e.v] == dep[u] + 1) {\n\t\t\tint x = dfs(e.v, t, min(c - res, e.cap));\n\t\t\te.cap -= x;\n\t\t\tadj[e.v][e.rev].cap += x;\n\t\t\tres += x;\n\t\t\tif (res == c) {\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\tif (!res) {\n\t\tdep[u] = 0;\n\t}\n\treturn res;\n}\nint dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t)) {\n\t\tfor (int i = 0; i <= t; i++) {\n\t\t\tlst[i] = (int)adj[i].size() - 1;\n\t\t}\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nvector<int> have[200005];\nint ans[200005], node[200005];\nbool in[200005];\nint dfs(int u)\n{\n\tint res = 1;\n\tin[u] = true;\n\tfor (int x : have[u]) {\n\t\tif (!in[node[x]]) {\n\t\t\tans[x] = u;\n\t\t\tres += dfs(node[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\thave[--x].push_back(i);\n\t\t\tif (x) {\n\t\t\t\tadd(i + 1, x + n - 1, 1);\n\t\t\t}\n\t\t}\n\t\tadd(0, i + 1, 1);\n\t\tadd(i + n, n * 2, 1);\n\t}\n\tif (dinic(0, n * 2) != n - 1) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (edge &e : adj[i]) {\n\t\t\tif (e.v != 0 && !e.cap) {\n\t\t\t\tnode[i - 1] = e.v - n + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (dfs(0) != n) {\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tcout << ans[i] + 1 << \" \" << node[i] + 1 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[201010];\nint match[201010];\nbool used[201010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        assert(false);\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint n,s,t;\nint tot,rd[200005],sz[200005],bg[200005],ed[200005],use[200005];\nint h[200005],fr[1000005],to[1000005],f[1000005],cnt=1;\nvoid add(int x,int y,int z)\n{\n\tfr[++cnt]=h[x];\n\th[x]=cnt;\n\tto[cnt]=y;\n\tf[cnt]=z;\n}\nint dis[200005];\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[now];i;i=fr[i])\n\t\t{\n\t\t\tif(f[i]&&dis[to[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[now]+1;\n\t\t\t\tif(to[i]==t)return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now)\n{\n\tif(now==t)return 1;\n\tfor(int i=use[now];i;i=fr[i])\n\t{\n\t\tuse[now]=i;\n\t\tif(dis[to[i]]==dis[now]+1&&f[i])\n\t\t{\n\t\t\tint r=dfs(to[i]);\n\t\t\tif(!r)dis[to[i]]=-1;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\t//cout<<now<<' '<<to[i]<<endl;\n\t\t\t\tf[i]=0;\n\t\t\t\tf[i^1]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=0;i<=t;i++)use[i]=h[i];\n\t\twhile(dfs(s))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nint bel[100005],rt,g[100005][2],fa[100005];\nvoid dfs1(int now)\n{\n\tcnt++;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(!fa[to[i]])\n\t\t{\n\t\t\tfa[to[i]]=now;\n\t\t\tg[bel[to[i]]][0]=now;g[bel[to[i]]][1]=to[i];\n\t\t\tdfs1(to[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&sz[i]);\n\t\tbg[i]=tot+1;\n\t\tfor(int j=1;j<=sz[i];j++)\n\t\t{\n\t\t\tscanf(\"%d\",&rd[tot+1]);\n\t\t\ttot++;\n\t\t}\n\t\ted[i]=tot;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tt=2*n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t\tfor(int j=bg[i];j<=ed[i];j++)\n\t\t{\n\t\t\tadd(rd[j],i+n,1);\n\t\t\tadd(i+n,rd[j],0);\n\t\t}\n\t}\n\tint flow=dinic();\n\t//cout<<flow<<endl;\n\tif(flow!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=h[i];j;j=fr[j])\n\t\t{\n\t\t\t//cout<<i<<' '<<to[j]<<endl;\n\t\t\tif(to[j]!=s&&f[j]==0)\n\t\t\t{\n\t\t\t\tbel[i]=to[j]-n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!bel[i])rt=i;\n\t\t//cout<<i<<' '<<bel[i]<<endl;\n\t}\n\tmemset(h,0,sizeof(h));\n\tcnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=rt)\n\t\t{\n\t\t\tfor(int j=bg[bel[i]];j<=ed[bel[i]];j++)\n\t\t\t{\n\t\t\t\tif(rd[j]!=i)add(rd[j],i,0);\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tdfs1(rt);\n\t//cout<<cnt<<endl;\n\tif(cnt!=n)printf(\"-1\");\n\telse\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",g[i][0],g[i][1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n, s, t;\nint hd[400005], nx[1000006], to[1000006], c[1000006], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid fadd(int f, int t, int c) { add(f, t, c), add(t, f, 0); }\n\nint dep[400005];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= t; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i]) {\n            if (!c[i] || dep[v = to[i]]) continue;\n            dep[v] = dep[u] + 1, q.push(v);\n        }\n    }\n    return dep[t];\n}\n\nint iter[400005];\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v, d; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        if (d = dfs(v, min(dist, c[i]))) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= t; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\n\nvector<int> e[400005];\nint p[400005];\nstruct Res {\n    int u, v;\n} res[400005];\nbool get_res() {\n    for (int u = 1; u < n; ++u)\n        for (int i = hd[u]; i; i = nx[i])\n            if (to[i] != s && c[i] == 0) p[u] = to[i] - n + 1;\n\n    int sum = 0;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        ++sum, q.pop();\n        for (int i = 0, v; i < e[u].size(); ++i)\n            if (p[v = e[u][i]]) res[v] = (Res){u, p[v]}, q.push(p[v]), p[v] = 0;\n    }\n    return sum == n;\n}\n\nint main() {\n    n = read(), s = 2 * n - 1, t = 2 * n, cnt = 1;\n    for (int i = 1; i < n; ++i) fadd(i + n - 1, t, 1);\n    for (int i = 1, c, u; i < n; ++i) {\n        c = read(), fadd(s, i, 1);\n        while (c--) {\n            if ((u = read()) != n) fadd(i, u + n - 1, 1);\n            e[u].push_back(i);\n        }\n    }\n    if (Dinic() < n - 1) return puts(\"-1\"), 0;\n    if (!get_res()) return puts(\"-1\"), 0;\n\n    for (int i = 1; i < n; ++i) printf(\"%d %d\\n\", res[i].u, res[i].v);\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define pb push_back\n#define SZ 2333333\ntypedef long long ll;\nint fst[SZ],nxt[SZ],vb[SZ],cap[SZ],ff[SZ],M=1,N=0;\n#define ad_de ad_dl\nvoid _ad_dl(int a,int b,int c) {++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;cap[M]=c;}\nvoid ad_dl(int a,int b,int c)\n{_ad_dl(a,b,c); _ad_dl(b,a,0);}\nint S,T,q[SZ],d[SZ];\nbool bfs()\n{\n    memset(d,-1,4*(N+1));\n    d[T]=0; q[1]=T; int h=1,t=2;\n    while(h!=t)\n    {\n        int cur=q[h++];\n        for(int e=fst[cur];e;e=nxt[e])\n        {\n            int b=vb[e];\n            if(d[b]==-1&&cap[e^1])\n            {\n                d[b]=d[cur]+1, q[t++]=b;\n                if(b==S) return 1;\n            }\n        }\n    }\n    return d[S]!=-1;\n}\nint dfs(int x,int f)\n{\n    if(f<=0) return 0;\n    if(x==T) return f;\n    int ca=0;\n    for(int& e=fst[x];e;e=nxt[e])\n    {\n        int b=vb[e];\n        if(d[b]+1!=d[x]) continue;\n        int w=dfs(b,(cap[e]<f-ca)?cap[e]:(f-ca));\n        cap[e]-=w; cap[e^1]+=w; ca+=w;\n        if(ca==f) break;\n    }\n    if(!ca) d[x]=-1;\n    return ca;\n}\n#define inf 2e9+3\nint dinic()\n{\n    int ans=0;\n    memcpy(ff,fst,4*(N+1));\n    while(bfs())\n    {\n        ans+=dfs(S,inf);\n        memcpy(fst,ff,4*(N+1));\n    }\n    return ans;\n}\nint n;\n#define fi first\n#define se second\ntypedef pair<int,int> pii;\n#define mp make_pair\nvector<int> t[SZ],g[SZ],u[SZ];\nint fa[SZ],mat[SZ];\npii ts[SZ];\nvoid dfs(int x)\n{\n\tfor(auto s:u[x])\n\t{\n\t\tif(!mat[s]) continue;\n\t\tint p=mat[s];\n\t\tts[s]=pii(x,p);\n\t\tmat[s]=0;dfs(p);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b),\n\t\t\tt[i].pb(b),\n\t\t\tu[b].pb(i);\n\t}\n\tN=n+n+2; S=N-1; T=N;\n\tfor(int i=2;i<=n;++i)\n\t\tad_de(S,i,1);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tfor(auto s:t[i])\n\t\t\tad_de(s,i+n,1),g[i].pb(M);\n\t\tad_de(i+n,T,1);\n\t}\n\tint s=dinic();\n\tif(s!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(int j=0;j<t[i].size();++j)\n\t\t\tif(cap[g[i][j]])\n\t\t\t\tmat[i]=t[i][j];\n\tfa[1]=-1; dfs(1);\n\tfor(int i=1;i<n;++i)\n\t\tif(!ts[i].fi)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",ts[i].fi,ts[i].se);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nvoid init(){\n\tqueue<int> Q;\n\t++u[d[t]=1];Q.push(t);\n\twhile(!Q.empty()){\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=fr[x];i;i=nex[i])if(wi[i]&&!d[vi[i]]){\n\t\t\t++u[d[vi[i]]=d[x]+1];Q.push(vi[i]);\n\t\t}\n\t}\n}\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]]==0)d[s]=t+3;else ++u[++d[x]];\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;init();\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//const int MOD=1e9+7;\nconst int MOD=998244353;\n\nconst double PI=3.14159265359;\n\nclass Edge{\n    public:\n    int cap,flow,dest;\n    bool inGraph;\n    Edge *flEdgePair, *resEdgePair;\n    Edge(int _dest, int _cap, bool ing, int _flow=0):dest(_dest),inGraph(ing),\n    cap(_cap), flow(_flow){}\n    \n    void addFlow(int fl){\n        cap-=fl;\n        resEdgePair->cap+=fl;\n        if(inGraph) flEdgePair->flow+=fl;\n        else flEdgePair->flow-=fl;\n    }\n};\n\nclass Dinic{\n    public:\n    vector<vector<Edge*>> flow, res;\n    vector<int> dists, preds;\n    \n    int S,n,T;\n    Dinic(vector<vector<pair<int,int>>>& net):S(0), n(net.size()), T(n-1){\n        flow.resize(n);\n        res.resize(n);\n        dists.resize(n);\n        preds.resize(n);\n\t\tfill(preds.begin(), preds.end(),-1);\n        \n        for(int i=0; i<n; i++){\n            for(auto p:net[i]){\n                Edge* e1=new Edge(p.first, p.second, true);\n                Edge* e2=new Edge(i, 0, false);\n                Edge* e3=new Edge(p.first, p.second, true);\n                \n                e1->flEdgePair=e3;\n                e2->flEdgePair=e3;\n                e1->resEdgePair=e2;\n                e2->resEdgePair=e1;\n                flow[i].push_back(e3);\n                res[i].push_back(e1);\n                res[p.first].push_back(e2);\n            }\n        }\n    }\n    bool bfs(){\n        fill(dists.begin(), dists.end(),-1);\n        queue<int> q;\n        q.push(S);\n        dists[S]=0;\n        while(q.size()){\n            int cur=q.front();\n            q.pop();\n            for(auto e:res[cur]){\n                if(e->cap && dists[e->dest]==-1){\n                    dists[e->dest]=dists[cur]+1;\n                    q.push(e->dest);\n                }\n            }\n        }\n        return dists[T]!=-1;\n    }\n    \n    void dfs(){\n        vector<int> ep(n);\n        vector<bool> dead(n);\n        while(!dead[S]){\n            //vector<int> preds(n,-1);\n            stack<int> st;\n            st.push(0);\n            while(st.size()){\n                int cur=st.top();\n                //cout<<cur<<endl;\n                if(cur==T) break;\n                while(ep[cur]<res[cur].size() && (dead[res[cur][ep[cur]]->dest] ||\n                dists[res[cur][ep[cur]]->dest]!=dists[cur]+1 || \n                res[cur][ep[cur]]->cap==0)){\n                    ep[cur]++;\n                }\n                if(ep[cur]==res[cur].size()){\n                    dead[cur]=true;\n                    st.pop();\n                }\n                else{\n                    preds[res[cur][ep[cur]]->dest]=cur;\n                    st.push(res[cur][ep[cur]]->dest);\n                }\n            }\n            if(st.size() && st.top()==T){\n                //cout<<st.size()<<endl;\n                int flVal=1e9;\n                int cur=T;\n                while(cur!=S){\n                    //cout<<cur<<endl;\n                    cur=preds[cur];\n                    flVal=min(flVal,res[cur][ep[cur]]->cap);\n                }\n                cur=T;\n                while(cur!=S){\n                    cur=preds[cur];\n                    res[cur][ep[cur]]->addFlow(flVal);\n                }\n            }\n            else{\n                dead[S]=true;\n            }\n            \n        }\n        \n    }\n    \n    vector<vector<Edge*>> maxflow(){\n        //bfs();\n        //dfs();\n        while(bfs()){\n            dfs();\n        }\n        return flow;\n    }\n    \n    \n};\n\n\n\nint main(){\n    \n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    \n    int n;\n    cin>>n;\n    \n    vector<vector<int>> e(n);\n    \n    for(int i=1; i<n; i++){\n        int t;\n        cin>>t;\n        e[i].resize(t);\n        for(int& j:e[i]) cin>>j;\n    }\n    \n    vector<vector<pair<int,int>>> net(2*n+1);\n    for(int i=1; i<=n; i++){\n        net[0].push_back({i,1});\n    }\n    for(int i=1; i<n; i++){\n        net[n+i].push_back({2*n,1});\n        for(int j:e[i]){\n            net[j].push_back({i+n,1});\n        }\n    }\n    /*\n    for(int i=0; i<=2*n; i++){\n        cout<<i<<\":\\n\";\n        for(auto p:net[i]){\n            cout<<p.first<<' ';\n        }\n        cout<<'\\n';\n    }\n    */\n    \n    Dinic din(net);\n    auto f=din.maxflow();\n    int fl=0;\n    \n    int start=-1;\n    \n    \n    for(auto e:f[0]){\n        fl+=e->flow;\n        if(!(e->flow)) start=e->dest;\n    }\n    if(fl!=n-1){\n        cout<<-1;\n        //cout<<fl<<endl;\n        return 0;\n    }\n    \n    queue<int> q;\n    q.push(start);\n    vector<int> preds(2*n+1,-1);\n    while(q.size()){\n        int cur=q.front();\n        q.pop();\n        for(auto e:din.res[cur]){\n            if(e->dest && e->cap && preds[e->dest]==-1){\n                preds[e->dest]=cur;\n                q.push(e->dest);\n            }\n        }\n    }\n    for(int i=n+1; i<2*n; i++){\n        if(preds[i]==-1){\n            cout<<-1;\n            return 0;\n        }\n    }\n    \n    vector<int> ans1(n);\n    for(int i=1; i<=n; i++){\n        for(auto e:f[i]){\n            if(e->flow){\n                ans1[e->dest-n]=i;\n            }\n        }\n    }\n    \n    for(int i=1; i<n; i++){\n        cout<<ans1[i]<<' '<<preds[i+n]<<'\\n';\n    }\n    \n    \n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nvector<int> vis, deg, match, lmatch;\nvector<array<int, 2>> res;\nvector<int> adj[1<<17];\ndsu tmp(0);\nvoid process(int v) {\n\tvis[v] = 1;\n\tfor(auto u : adj[v]) if(match[u] != -1 && !vis[match[u]]) {\n\t\ttmp.unite(match[u], v);\n\t\tres[u] = {match[u], v};\n\t\tprocess(match[u]);\n\t}\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\ttmp = (n);\n\tdeg = vector<int>(n);\n\tmatch.resize(n, -1);\n\tlmatch.resize(n, -1);\n\tvis.resize(n);\n\tint kk = 0;\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j, assert(j-1 < n), deg[j-1]++, adj[j-1].push_back(kk);\n\t\tkk++;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching();\n\tres.resize(n-1);\n\tset<int> q;\n\tfor(int i = 0; i < n; i++) q.insert(i);\n\tfor(auto [i, x] : matching) {\n\t\tmatch[i-1] = x-n;\n\t\tlmatch[x-n] = i-1;\n\t\tq.erase(match[i-1]);\n\t}\n\tprocess(*q.begin());\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a << \" \" << b << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9+7;\nconst int N=1e5+2;\nint mat[N],par[N];\nstruct Dinic \n{\n   int n, s, t;\n   struct Edge \n   {\n      int to, cap, flow, rev;\n      Edge(int to = 0, int cap = 0, int flow = 0, int rev = 0) :\n         to(to), cap(cap), flow(flow), rev(rev) {}\n   };\n   vector <int> d;\n   vector <int> ptr;\n   vector<vector<Edge>> g;\n \n   Dinic(int n = 0, int s = 0, int t = 0) :\n      n(n), s(s), t(t), d(n + 2), ptr(n + 2), g(n + 2) {}\n   void addEdge(int u, int v, int cap) \n   {\n      g[u].emplace_back(v, cap, 0, g[v].size());\n      g[v].emplace_back(u, 0, 0, g[u].size() - 1);\n   }\n \n   bool bfs() \n   {\n      fill(d.begin(), d.end(), -1);\n      fill(ptr.begin(), ptr.end(), 0);\n \n      queue <int> q;\n      d[s] = 0;\n      q.push(s);\n      while (!q.empty()) \n      {\n         int u = q.front();\n         q.pop();\n         for (auto e : g[u]) \n         {\n            if (d[e.to] == -1 && e.cap > e.flow) \n            {\n               d[e.to] = d[u] + 1;\n               q.push(e.to);\n            }\n         }\n      }\n      return d[t] != -1;\n   }\n \n   int dfs(int u, int flow) \n   {\n      if (u == t) \n      {\n         return flow;\n      }\n      for (int &i = ptr[u]; i < (int)g[u].size(); i++) \n      {\n         auto &e = g[u][i];\n         if (e.cap <= e.flow || d[e.to] != d[u] + 1) \n            continue;\n         int nxt = dfs(e.to, min(flow, e.cap - e.flow));\n         if (nxt) \n         {\n            e.flow += nxt;\n            g[e.to][e.rev].flow -= nxt;\n            return nxt;\n         }\n      }\n      return 0;\n   }\n   int maxFlow() \n   {\n      int ans = 0;\n      while (bfs()) \n      {\n         while(true)\n         {\n            int now = dfs(s, inf);\n            if (now) ans += now;\n            else break;\n         }\n      }\n      return ans;\n   }\n   void trace(){\n   \t    for(int i=2;i<=(n-1)/2;i++){\n\t     for(int j=0;j<g[i].size();j++){\n\t     \t//cout<<g[i][j].cap<<' '<<g[i][j].flow<<' '<<i<<' '<<g[i][j].to<<endl;\n\t     \tif(g[i][j].cap==g[i][j].flow&&g[i][j].cap>0){\n\t     \t\tmat[g[i][j].to-(n-1)/2]=i;\n\t\t\t }\n\t\t }\n\t    }\n   }\n};\nvector<int> lis[N];\nbool used[N];\nvoid dfs1(int x){\n\tused[x]=true;\n\tfor(int i=0;i<lis[x].size();i++){\n\t\tif(!used[mat[lis[x][i]]]){\n\t\t\tused[mat[lis[x][i]]]=true;\n\t\t\tpar[lis[x][i]]=x;\n\t\t\tdfs1(mat[lis[x][i]]);\n\t\t}\n\t}\n}\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,i,j,k,l;\n\tcin>>n;\n\tDinic dn(2*n+1,n+1,2*n+1);\n\tfor(i=2;i<=n;i++){\n\t\tcin>>j;\n\t\twhile(j--){\n\t\t\tcin>>k;\n\t\t\tlis[k].push_back(i);\n\t\t\tif(k!=1){\n\t\t\t\tdn.addEdge(k,n+i,1);\n\t\t\t}\n\t\t}\n\t\tdn.addEdge(n+1,i,1);\n\t\tdn.addEdge(i+n,2*n+1,1);\n\t}\n\tif(dn.maxFlow()!=n-1){\n\t\tcout<<\"-1\";\n\t\treturn 0;\n\t}\n\tdn.trace();\n//\tfor(i=1;i<=n;i++){\n//\t\tcout<<mat[i]<<endl;\n//\t}\n\tdfs1(1);\n\tfor(i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tcout<<\"-1\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(i=2;i<=n;i++){\n\t\tcout<<par[i]<<' '<<mat[i]<<'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 222222\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint E = MAX_V / 2;\nint s = MAX_V - 2;\nint g = MAX_V - 1;\nint mp[MAX_V/2];\nbool used[MAX_V/2];\nbool visited[MAX_V/2];\n\nvector<vector<int>> v(MAX_V / 2);\nvector<vector<int>> nv(MAX_V / 2);\nvector<pair<int,int>> ans;\n\nvoid dfs(int num){\n\tvisited[num] = true;\n\tREP(i,nv[num].size()){\n\t\tif(!visited[nv[num][i]]){\n\t\t\tans.EB(num, nv[num][i]);\n\t\t\tdfs(nv[num][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tREP(i,n) {\n\t\tif(i != n -1)add_edge(s,i,1);\n\t\tadd_edge(E+i,g,1);\n\t}\n\t\t\n\tREP(i,n-1){\n\t\t\n\t\tint e;cin >> e;\n\t\tREP(j,e){\n\t\t\tint tmp;cin >> tmp;tmp--;\n\t\t\tv[i].EB(tmp);\n\t\t\tadd_edge(i, E+tmp, 1);\n\t\t}\n\t}\n\t\n\tint seica = Dinic(s, g);\n\t//cout << \"seica is \" << seica << endl;\n\tif(seica != n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,n-1) {\n\t\tREP(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0){\n\t\t\t\tmp[i] = G[i][j].to - E;\n\t\t\t\tused[mp[i]] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n-1){\n\t\tREP(j,v[i].size()){\n\t\t\tif(v[i][j] != mp[i])nv[v[i][j]].EB(mp[i]);\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(!used[i])dfs(i);\n\t}\n\t\n\t//cout << \"ans is \" << ans.size() << endl;\n\t//SHOW1d(used,n);\n\tif(ans.size() == n-1){\n\t\tREP(i,ans.size()){\n\t\t\tcout << ans[i].FI + 1 << \" \" << ans[i].SE + 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nstruct UF {\n\tvi t;\n\tUF(int n){\n\t\tt.resize(n, -1);\n\t}\n\tint find(int a){\n\t\treturn t[a]<0 ? a : t[a] = find(t[a]);\n\t}\n\tbool same(int a, int b){\n\t\treturn find(a) == find(b);\n\t}\n\tvoid uni(int a, int b){\n\t\ta = find(a), b = find(b);\n\t\tif(a == b) return;\n\t\tif(t[a] < t[b]) swap(a,b);\n\t\tt[b] += t[a];\n\t\tt[a] = b;\n\t}\n\tint ss(int a){\n\t\treturn -t[find(a)];\n\t}\n};\n\nvoid fail(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid rem(vector<pii> &v, pii p){\n\trep(i,0,sz(v)) if(v[i]==p){\n\t\tv.erase(v.begin()+i);\n\t\treturn;\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\tint m = n-1;\n\n\tvector<vi> es(m);\n\ttrav(v, es){\n\t\tint c;\n\t\tcin >> c;\n\t\tv.resize(c);\n\t\ttrav(x, v) cin >> x, --x;\n\t}\n\tvector<vector<pii>> gr(n);\n\tvector<pii> uv(m);\n\tvector<bool> used(m, false);\n\tUF uf(n);\n\tvi perm(m);\n\tiota(all(perm), 0);\n\trandom_shuffle(all(perm));\n\ttrav(i, perm){\n\t\tint u = es[i][0];\n\t\ttrav(v, es[i]) if(!uf.same(v, u)){\n\t\t\tuf.uni(v, u);\n\t\t\tuv[i] = pii(u, v);\n\t\t\tgr[v].emplace_back(u, i);\n\t\t\tgr[u].emplace_back(v, i);\n\t\t\tused[i] = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tset<pii> s;\n\trep(i,0,m) if(!used[i])\n\t\ts.insert(pii(uf.ss(es[i][0]),i));\n\n\tvi pix(n);\n\tvector<bool> vis(m, false);\n\t\n\twhile(!s.empty()){\n\t\tauto it = s.begin();\n\t\tpii pa = *it;\n\t\ts.erase(it);\n\t\tint l = pa.second;\n\t\tint v0 = es[l][0];\n\n\t\tif(pa.first != uf.ss(v0)){\n\t\t\ts.insert(pii(uf.ss(v0),l));\n\t\t\tcontinue;\n\t\t}\n\t\tpix[v0] = -1;\n\t\tstack<int> st;\n\t\tst.push(v0);\n\n\t\twhile(!st.empty()){\n\t\t\tint v = st.top(); st.pop();\n\t\t\trep(i,0,sz(gr[v])){\n\t\t\t\tint u, q;\n\t\t\t\ttie(u,q) = gr[v][i];\n\t\t\t\tif(q == pix[v]) continue;\n\t\t\t\tpix[u] = q;\n\t\t\t\tst.push(u);\n\t\t\t}\n\t\t}\n\n\t\tvi todo;\n\n\t\tfunction<bool(int)> rek = [&](int q){\n\t\t\tif(q < 0 || vis[q]) return false;\n\t\t\tvis[q] = true;\n\t\t\ttodo.push_back(q);\n\t\t\tint v = uv[q].first;\n\t\t\tif(pix[v]==q) v = uv[q].second;\n\t\t\tint w = uv[q].first^uv[q].second^v;\n\n\t\t\ttrav(u, es[q]) if(!uf.same(v, u)){\n\t\t\t\tuf.uni(v,u);\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif(rek(pix[v])) return true;\n\t\t\ttrav(u, es[q]) if(rek(pix[u])){\n\t\t\t\trem(gr[v], pii(w,q));\n\t\t\t\trem(gr[w], pii(v,q));\n\t\t\t\tuv[q] = pii(u,v);\n\t\t\t\tgr[u].emplace_back(v,q);\n\t\t\t\tgr[v].emplace_back(u,q);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t\ttrav(v, es[l]) if(rek(pix[v])){\n\t\t\tgr[v0].emplace_back(v,l);\n\t\t\tgr[v].emplace_back(v0,l);\n\t\t\tuv[l] = pii(v, v0);\n\t\t\tgoto bar;\n\t\t}\n\t\tfail();\n\t\tbar:\n\t\ttrav(q, todo) vis[q] = false;\n\n\t}\n\n\trep(i,0,m) cout << 1+uv[i].first << ' ' << 1+uv[i].second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\tassert(la == n - 1);\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        while ( (f = dfs(s,t,inf) ) > 0 ) ans += f;\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , n;\n\nint main(){\n\t\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<ctype.h>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int inf = 0x3f3f3f3f,oo = inf;\n#define pc putchar\n#define RG register\n#define gc getchar\ninline ll read(){\n\tRG ll x=0,f=1;RG char c=gc();\n\tfor(;!isdigit(c);c=gc())if(c=='-')f=-1;\n\tfor(;isdigit(c);c=gc())x=(x<<1)+(x<<3)+(c^48);\n\treturn x*f;\n}\nvoid write(ll x){\n\tif(x<0)x=-x,pc('-');\n\tif(x>=10)write(x/10);\n\tputchar(x%10+'0');\n}\n#define rd read\n#define mem(x,v) memset(x,v,sizeof(x))\n#define pb push_back\n#define mp make_pair\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-(x)))\n#define rep(i,a,b) for(RG int i=(a);i<(b);++i)\n#define Rep(i,a,b) for(RG int i=(a);i<=(b);++i)\n#define fin(x) {freopen(#x\".in\",\"r\",stdin);}\n#define y1 ________y1\n#define int ll\n#define N 1000005\n#define M 4000005\nstruct Edge{\n\tint to,nxt,cap;\n\tEdge(){}\n\tEdge(int to,int nxt,int cap):to(to),nxt(nxt),cap(cap){};\n}edge[M*2];\nint first[N],cur[N],nume;\nvoid Addedge(int a,int b,int c){\n\tedge[nume] = Edge(b,first[a],c);first[a] = nume++;\n\tedge[nume] = Edge(a,first[b],0);first[b] = nume++;\n}\nint q[N],dis[N],S,T,n,m,tot;\nbool bfs(){\n\tint front,rear;\n\tfront = rear = 0;\n\tmemset(dis,-1,sizeof(dis));\n\tq[rear++] = T;dis[T] = 1;\n\twhile(front < rear){\n\t\tint u = q[front++];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tint v=edge[e].to;\n\t\t\tif(edge[e^1].cap && dis[v]==-1){\n\t\t\t\tdis[v] = dis[u] + 1;\n\t\t\t\tq[rear++] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[S] != -1;\n}\nint dfs(int u,int flow){\n\tif(u==T) return flow;\n\tint used = 0,d;\n\tfor(int &e = cur[u];~e;e=edge[e].nxt){\n\t\tint v=edge[e].to;\n\t\tif(dis[u] == dis[v] + 1 && edge[e].cap && (d = dfs(v,min(flow-used,edge[e].cap)))){\n\t\t\tedge[e].cap -= d;\n\t\t\tedge[e^1].cap += d;\n\t\t\tused += d;\n\t\t}\n\t\tif(used == flow) break;\n\t}\n\tif(!used) dis[u] = -1;\n\treturn used;\n}\nint dinic(){\n\tll ans = 0;\n\twhile(bfs()){\n\t\tRep(i,1,tot) cur[i] = first[i];\n\t\tans += dfs(S,inf);\n\t}\n\treturn ans;\n}\nint id[N],Id[N],x[N];\nvector<int> g[N];\nsigned main(){\n\tmem(first,-1);nume = 0;\n\tn = read();\n\ttot = 0;\n\tS = ++tot;\n\tT = ++tot;\n\tRep(i,2,n){\n\t\tid[i] = ++tot;\n\t\tAddedge(id[i],T,1);\n\t}\n\tRep(i,1,n-1){\n\t\tId[i] = ++tot;\n\t\tAddedge(S,Id[i],1);\n\t\t//v[i] . resize(read());\n\t\tint t = read();\n\t\trep(j,0,t){\n\t\t\tint t = read();\n\t\t\tif(t != 1) Addedge(Id[i],id[t],1);\n\t\t\tg[t] . push_back(i);\n\t\t}\n\t}\n\tif(dinic() != n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tRep(i,1,n-1){\n\t\tint u = Id[i];\n\t\tfor(int e=first[u];~e;e=edge[e].nxt){\n\t\t\tif(e%2==0 && !edge[e].cap){\n//\t\t\t\tprintf(\"{%d %d}\\n\",u,edge[e].to);\n\t\t\t\tx[i] = edge[e].to - 1;\n\t\t\t}// \n\t\t}\n\t}\n\tqueue<int> Q;\n\tstatic bool vis[N];\n\tQ.push(1);vis[1]=true;\n\twhile(!Q.empty()){\n\t\tint u = Q.front();Q.pop();\n\t\tfor(auto v:g[u]){\n\t\t//\tprintf(\"{%d)\\n\",x[v]);\n\t\t\tif(!vis[x[v]]){\n\t\t\t\tvis[x[v]] = true;\n\t\t\t\tQ.push(x[v]);\n\t\t\t\tprintf(\"%d %d\\n\",u,x[v]);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],pos[N],vis[N],dis[N << 1],cur[N << 1];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline bool bfs() {\n\tqueue <int> q;\n\tmemset(dis,0,sizeof(dis));\n\tq.push(S),dis[S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front();q.pop();\n\t\tif(x == T) return true;\n\t\tfor(int i = beg[x];i;i = nex[i])\n\t\t\tif(!dis[to[i]] && flow[i]) {\n\t\t\t\tdis[to[i]] = dis[x] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int &i = cur[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] + 1 == dis[to[i]]) {\n\t\t\tint val = dfs(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\treturn f - res;\n}\n\nint main() {\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\twhile(bfs()) {\n\t\tmemcpy(cur,beg,sizeof(cur));\n\t\tans += dfs(S,INF);\n\t}\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <memory>\n#include <cassert>\n#include <set>\n\nusing namespace std;\n\nstruct MaxFlow{\n  typedef long long ll;\n  const ll INF = 1e18;\n  struct Edge{\n    int u,v;\n    ll c,rc;\n    shared_ptr<ll> flow;\n    Edge(int _u, int _v, ll _c, ll _rc = 0):u(_u),v(_v),c(_c),rc(_rc){\n    }\n  };\n  struct FlowTracker{\n    ll cap, rcap;\n    shared_ptr<ll> flow;\n    bool dir;\n    FlowTracker(ll _cap, ll _rcap, shared_ptr<ll> _flow, int _dir):cap(_cap),rcap(_rcap),flow(_flow),dir(_dir){ }\n    ll rem() const {\n      if(dir == 0){\n        return cap-*flow;\n      }\n      else{\n        return rcap+*flow;\n      }\n    }\n    void add_flow(ll f){\n      if(dir == 0)\n        *flow += f;\n      else\n        *flow -= f;\n      assert(*flow <= cap);\n      assert(-*flow <= rcap);\n    }\n    operator ll() const { return rem(); }\n    void operator-=(ll x){ add_flow(x); }\n    void operator+=(ll x){ add_flow(-x); }\n  };\n  int source,sink;\n  vector<vector<int> > adj;\n  vector<vector<FlowTracker> > cap;\n  vector<Edge> edges;\n  MaxFlow(int _source, int _sink):source(_source),sink(_sink){\n    assert(source != sink);\n  }\n  int add_edge(int u, int v, ll c, ll rc = 0){\n    edges.push_back(Edge(u,v,c,rc));\n    return edges.size()-1;\n  }\n  vector<int> now,lvl;\n  void prep(){\n    int max_id = max(source, sink);\n    for(auto edge : edges)\n      max_id = max(max_id, max(edge.u, edge.v));\n    adj.resize(max_id+1);\n    cap.resize(max_id+1);\n    now.resize(max_id+1);\n    lvl.resize(max_id+1);\n    for(auto &edge : edges){\n      auto flow = make_shared<ll>(0);\n      adj[edge.u].push_back(edge.v);\n      cap[edge.u].push_back(FlowTracker(edge.c, edge.rc, flow, 0));\n      if(edge.u != edge.v){\n        adj[edge.v].push_back(edge.u);\n        cap[edge.v].push_back(FlowTracker(edge.c, edge.rc, flow, 1));\n      }\n      assert(cap[edge.u].back() == edge.c);\n      edge.flow = flow;\n    }\n  }\n  bool dinic_bfs(){\n    fill(now.begin(),now.end(),0);\n    fill(lvl.begin(),lvl.end(),0);\n    lvl[source] = 1;\n    vector<int> bfs(1,source);\n    for(int i = 0; i < (int) bfs.size(); ++i){\n      int u = bfs[i];\n      for(int j = 0; j < (int) adj[u].size(); ++j){\n        int v = adj[u][j];\n        if(cap[u][j] > 0 && lvl[v] == 0){\n          lvl[v] = lvl[u]+1;\n          bfs.push_back(v);\n        }\n      }\n    }\n    return lvl[sink] > 0;\n  }\n  ll dinic_dfs(int u, ll flow){\n    if(u == sink)\n      return flow;\n    while(now[u] < (int) adj[u].size()){\n      int v = adj[u][now[u]];\n      if(lvl[v] == lvl[u] + 1 && cap[u][now[u]] != 0){\n        ll res = dinic_dfs(v,min(flow,(ll)cap[u][now[u]]));\n        if(res > 0){\n          cap[u][now[u]] -= res;\n          return res;\n        }\n      }\n      ++now[u];\n    }\n    return 0;\n  }\n  ll calc_max_flow(){\n    prep();\n    ll ans = 0;\n    while(dinic_bfs()){\n      ll cur = 0;\n      do{\n        cur = dinic_dfs(source,INF);\n        ans += cur;\n      }while(cur > 0);\n    }\n    return ans;\n  }\n  ll flow_on_edge(int edge_index){\n    assert(edge_index < (int) edges.size());\n    return *edges[edge_index].flow;\n  }\n};\n\n// auto mf = MaxFlow(1,n);\n// arguments source and sink, memory usage\n// O(largest node index + input size), sink\n// doesn't need to be last index\n// int edge_index;\n// for(int i = 0; i < m; ++i){\n//    int a,b,c;\n//    cin >> a >> b >> c;\n//mf.add\\_edge(a,b,c); // for directed edges\n//      edge_index = mf.add_edge(a,b,c,c); // store edge index if care about flow value\n//   }\n//  cout << mf.calc_max_flow() << '\\n';\n//cout << mf.flow\\_on\\_edge(edge\\_index) << endl; // return flow on this edge\n//}\n\nvoid failure () {\n  cout << -1 << endl;\n  exit(0);\n}\n\nconst int MAX_N = 1e5 + 5;\n\nvector<int> adj [MAX_N]; // adj[v] is the set of edgesets v is in\n\nconst int HYPER = 1e5 + 5;\nconst int SOURCE = 2e5 + 10;\nconst int SINK = SOURCE + 1;\n\nint adder [MAX_N];\nint match [MAX_N]; // match[e] is the v matching to edgeset e\n\nint main () {\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n\n  auto mf = MaxFlow(SOURCE, SINK);\n\n  vector<pair<pair<int, int>, int>> edges; // <<vertex, edgeset>, mf idx>\n  for (int i = 1; i < n; i++) {\n    int cnt;\n    cin >> cnt;\n\n    for (int j = 0; j < cnt; j++) {\n      int v;\n      cin >> v;\n\n      adj[v].push_back(i);\n      int idx = mf.add_edge(v, HYPER + i, 1);\n      edges.push_back({{v, i}, idx});\n    }\n  }\n\n  for (int i = 1; i <= n; i++) {\n    mf.add_edge(SOURCE, i, 1);\n  }\n\n  for (int i = 1; i < n; i++) {\n    mf.add_edge(HYPER + i, SINK, 1);\n  }\n\n  int flow = mf.calc_max_flow();\n  if (flow != n - 1) failure();\n  \n  set<int> freevs;\n  for (int i = 1; i <= n; i++) {\n    freevs.insert(i);\n  }\n\n  for (auto e : edges) {\n    if (mf.flow_on_edge(e.second) == 1) {\n      match[e.first.second] = e.first.first;\n      freevs.erase(e.first.first);\n    }\n  }\n\n  int start = *freevs.begin();\n\n  set<int> esets;\n  for (int e : adj[start]) {\n    esets.insert(e);\n    adder[e] = start;\n  }\n\n  vector<pair<int, int>> ans;\n  for (int i = 0; i < n - 1; i++) {\n    if (esets.empty()) failure();\n\n    int E = *esets.begin();\n    esets.erase(E);\n\n    int v = match[E];\n    for (int e : adj[v]) {\n      if (adder[e] == 0) {\n        esets.insert(e);\n        adder[e] = v;\n      }\n    }\n\n    ans.push_back({v, adder[E]});\n  }\n\n  for (auto pr : ans) {\n    cout << pr.first << \" \" << pr.second << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 1e5 + 10;\n\nvector<int> E[maxn];\nint ord[maxn], u[maxn], v[maxn], par[maxn];\n\nint F(int u) { return par[u] == u ? u : par[u] = F(par[u]); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tauto BEG = clock();\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tord[i] = i;\n\t\tint sz;\n\t\tcin >> sz;\n\t\tE[i].resize(sz);\n\t\tfor (int j = 0; j < sz; ++j) cin >> E[i][j], --E[i][j];\n\t}\n\trandom_shuffle(ord, ord + n - 1);\n\tfor (int i = 0; i < n; ++i) par[i] = i;\n\tfor (int _i = 0; _i < n - 1; ++_i) {\n\t\tint i = ord[_i];\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tint u = E[i][0], anc = F(u), rem = -1;\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tfor (int v: E[i]) {\n\t\t\tif(F(v) != anc) {\n\t\t\t\trem = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(~rem) {\n\t\t\t::u[i] = u;\n\t\t\t::v[i] = rem;\n\t\t\tpar[F(u)] = F(rem);\n\t\t}\n\t\telse {\n\t\t\tif(1. * (clock() - BEG) > 3.6 * CLOCKS_PER_SEC) { puts(\"-1\"); return 0; }\n\t\t\tbool flag = 0;\n\t\t\tfor (int _j = _i - 1; ~_j; --_j) {\n\t\t\t\tint j = ord[_j];\n\t\t\t\tif(F(::u[j]) == anc) {\n\t\t\t\t\tint nrem = -1;\n\t\t\t\t\tfor (int v: E[ord[j]]) if(F(v) != anc) { nrem = v; break; }\n\t\t\t\t\tif(~nrem) {\n\t\t\t\t\t\t::v[j] = nrem;\n\t\t\t\t\t\tpar[F(::u[j])] = F(::v[j]);\n\t\t\t\t\t\t::u[i] = E[i][0];\n\t\t\t\t\t\t::v[i] = E[i][1];\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) { puts(\"-1\"); return 0; }\n\t\t}\n#ifdef DEBUGg\n\t\tcout << i << endl;\n\t\tfor (int i = 0; i < n - 1; ++i) cout << ::u[i] + 1 << ' ' << v[i] + 1 << endl;\n\t\tcout << '\\n';\n#endif\n\t}\n\tfor (int i = 0; i < n - 1; ++i) cout << u[i] + 1 << ' ' << v[i] + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FO(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define fo(i,j,k) for(int i=(j),end_i=(k);i<=end_i;i++)\n#define ff(i,j,k) for(int i=(j),end_i=(k);i< end_i;i++)\n#define fd(i,j,k) for(int i=(j),end_i=(k);i>=end_i;i--)\n#define DEBUG(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(x) (x).begin(),(x).end()\n#define cle(x) memset(x,0,sizeof(x))\n#define lowbit(x) ((x)&-(x))\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define lb long db\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ninline int read()\n{\n\tint x=0; char ch=getchar(); bool f=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\n#define CASET fo(___,1,read())\n\nconst int N=200010;\nconst int M=2000000;\nnamespace Dinic{\n\tconst int inf=2e9;\n\tint s,t;\n\tint head[N],cur[N],ne[M],ver[M],val[M],tot=1;\n\tint d[N];\n\tqueue<int> q;\n\tinline void add(int x,int y,int v)\n\t{\n\t\tver[++tot]=y; val[tot]=v; ne[tot]=head[x]; head[x]=tot;\n\t\tver[++tot]=x; val[tot]=0; ne[tot]=head[y]; head[y]=tot;\n\t}\n\tinline bool bfs()\n\t{\n\t\tfo(i,0,t) cur[i]=head[i];\n\t\tfor(;!q.empty();q.pop());\n\t\tfo(i,0,t) d[i]=-1; q.push(s); d[s]=0;\n\t\tfor(int u,v;!q.empty();)\n\t\t{\n\t\t\tu=q.front(); q.pop();\n\t\t\tfor(int i=head[u];i;i=ne[i])\n\t\t\t\tif(val[i]&&d[v=ver[i]]==-1)\n\t\t\t\t{\n\t\t\t\t\td[v]=d[u]+1,q.push(v);\n\t\t\t\t\tif(v==t) return 1;\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int flow)\n\t{\n\t\tif(!flow||u==t) return flow;\n\t\tint res=flow,r,v;\n\t\tfor(int &i=cur[u];i;i=ne[i])\n\t\t\tif(val[i]&&d[v=ver[i]]==d[u]+1)\n\t\t\t{\n\t\t\t\tr=dfs(v,min(res,val[i]));\n\t\t\t\tif(!r) continue;\n\t\t\t\tval[i]-=r; val[i^1]+=r;\n\t\t\t\tres-=r; if(!res) break;\n\t\t\t}\n\t\treturn flow-res;\n\t}\n\tint dinic()\n\t{\n\t\tint flow=0;\n\t\twhile(bfs()) flow+=dfs(s,inf);\n\t\treturn flow;\n\t}\n}\nusing namespace Dinic;\nint n;\nint X[N],Y[N],cnt;\nbool vis[N];\nvoid dfs(int u)\n{\n\tfor(int i=head[u],v;i;i=ne[i])\n\t\tif((v=ver[i])!=s&&!vis[v-n])\n\t\t{\n\t\t\tvis[v-n]=1;\n\t\t\tfor(int j=head[v];j;j=ne[j])\n\t\t\t\tif(val[j])\n\t\t\t\t\tcnt++,X[v-n]=u,Y[v-n]=ver[j],dfs(ver[j]);\n\t\t}\n}\nint main()\n{\n\tn=read();\n\tDinic::t=2*n;\n\ts=0; t=2*n;\n\tff(i,n+1,2*n) CASET add(read(),i,1);\n\tfo(i,1,n) add(s,i,1);\n\tff(i,n+1,2*n) add(i,t,1);\n\tif(dinic()!=n-1) return puts(\"-1\")&0;\n\tint root;\n\tfor(int i=head[0];i;i=ne[i]) if(val[i]) root=ver[i];\n\tdfs(root);\n\tif(cnt!=n-1) return puts(\"-1\")&0;\n\tff(i,1,n) printf(\"%d %d\\n\",X[i],Y[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tvis[v2[x][i]]=1;\n\t\tson[x].push_back(ma[v2[x][i]]);\n\t}\n\tfor(int i=0;i<(int)son[x].size();i++)dfs(son[x][i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstring>\n#include<cmath>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint read()\n{\n\tchar c=getchar();\n\tint res=0;\n\twhile(c<'0'||c>'9') c=getchar();\n\twhile(c>='0'&&c<='9') res=(res<<1)+(res<<3)+(c^48),c=getchar();\n\treturn res;\n}\nint n,h[200005],cnt=1,pre[200005],s,t,p[200005],num;\nvector<int> e[200005];\nstruct que\n{\n\tint x,y;\n}hs[200005];\nstruct Edge\n{\n\tint to,next,d;\n}w[800005];\nvoid add(int x,int y,int d)\n{\n\tw[++cnt]=(Edge){y,h[x],d};\n\th[x]=cnt;\n\tw[++cnt]=(Edge){x,h[y],0};\n\th[y]=cnt;\n}\nbool bfs()\n{\n\tmemset(pre,0,sizeof(pre));\n\tpre[s]=1;\n\tqueue<int> q;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[u];i;i=w[i].next)\n\t\t{\n\t\t\tint to=w[i].to;\n\t\t\tif(w[i].d&&!pre[to])\n\t\t\t{\n\t\t\t\tpre[to]=pre[u]+1;\n\t\t\t\tif(to==t) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int x,int p)\n{\n\tif(x==t||!p) return p;\n\tint r=p;\n\tfor(int i=h[x];i;i=w[i].next)\n\t{\n\t\tint to=w[i].to;\n\t\tif(r&&w[i].d&&pre[to]==pre[x]+1)\n\t\t{\n\t\t\tint p2=dfs(to,min(r,w[i].d));\n\t\t\tif(p2)\n\t\t\t{\n\t\t\t\tw[i].d-=p2,w[i^1].d+=p2;\n\t\t\t\tr-=p2;\n\t\t\t}\n\t\t\tif(!r) return p;\n\t\t}\n\t}\n\tif(r==p) pre[x]=0;\n\treturn p-r;\n}\nint Dinic()\n{\n\tint ans=0;\n\twhile(bfs()) ans+=dfs(s,0x3f3f3f3f);\n\treturn ans;\n}\nbool Solve()\n{\n\tfor(int i=1;i<n;i++)\n\tfor(int j=h[i];j;j=w[j].next)\n\t{\n\t\tint to=w[j].to;\n\t\tif(!to) continue;\n\t\tif(!w[j].d) p[i]=to-n+1;\n\t}\n\tqueue<int> q;\n\tq.push(n);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tnum++;\n\t\tint sz=e[u].size();\n\t\tfor(int i=0;i<sz;i++)\n\t\t{\n\t\t\tint x=e[u][i];\n\t\t\tif(p[x]) hs[x]=((que){u,p[x]}),q.push(p[x]),p[x]=0;\n\t\t}\n\t}\n\treturn num==n;\n}\nint main()\n{\n\tn=read();\n\ts=0,t=2*n-1;\n\tfor(int i=1;i<=n-1;i++) add(s,i,1),add(i+n-1,t,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint num=read();\n\t\twhile(num--)\n\t\t{\n\t\t\tint x=read();\n\t\t\tif(x!=n) add(i,x+n-1,1);\n\t\t\te[x].push_back(i);\n\t\t}\n\t}\n\tif(Dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",hs[i].x,hs[i].y);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200100;\n\nvector<int> g[N];\n\nbool mark[N];\nint match[N];\nint n;\n\nbool dfs(int v) {\n  if (mark[v]) {\n    return false;\n  }\n  mark[v] = true;\n  for (int to : g[v]) {\n    if (match[to] == -1 || dfs(match[to])) {\n      match[to] = v;\n      match[n + v] = to;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching() {\n  memset(match, -1, sizeof match);\n  while (true) {\n    memset(mark, false, sizeof mark);\n    bool done = true;\n    for (int i = 0; i < n - 1; i++) {\n      if (match[n + i] == -1) {\n        done &= !dfs(i);\n      }\n    }\n    if (done) {\n      break;\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n - 1; i++) {\n    res += (match[n + i] != -1);\n  }\n  return res;\n}\n\nvector<pair<int, int>> ed;\n\nvoid make(int v) {\n  mark[v] = 1;\n  for (int to : g[n + v]) {\n    if (!mark[to]) {\n      ed.emplace_back(v, match[to]);\n      make(match[to]);\n    }\n  }\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int c;\n    cin >> c;\n    while (c--) {\n      int x;\n      cin >> x;\n      --x;\n      g[i].push_back(x);\n      g[n + x].push_back(i);\n    }\n  }\n  if (matching() != n - 1) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int root = -1;\n  for (int i = 0; i < n; i++) {\n    if (match[i] == -1) {\n      root = i;\n      break;\n    }\n  }\n  memset(mark, 0, sizeof mark);\n  make(root);\n  if ((int) ed.size() != n - 1) {\n    cout << -1 << '\\n';\n  } else {\n    for (auto e : ed) {\n      cout << e.first + 1 << \" \" << e.second + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Author:xht37\n#include <bits/stdc++.h>\n\n#define ui unsigned int\n#define ll long long\n#define ul unsigned ll\n#define ld long double\n\n#define pi pair <int, int>\n#define fi first\n#define se second\n#define mp make_pair\n\n#define ls (p << 1)\n#define rs (ls | 1)\n#define md ((t[p].l + t[p].r) >> 1)\n\n#define vi vector <int>\n#define pb push_back\n#define pq priority_queue\n\n#define dbg(x) cerr << #x\" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#define fl(x) freopen(x\".in\", \"r\", stdin), freopen(x\".out\", \"w\", stdout)\n\nusing namespace std;\n\nnamespace io {\n\tconst int SI = 1 << 21 | 1;\n\tchar IB[SI], *IS, *IT, OB[SI], *OS = OB, *OT = OS + SI - 1, c, ch[100];\n\tint f, t;\n\t#define gc() (IS == IT ? (IT = (IS = IB) + fread(IB, 1, SI, stdin), IS == IT ? EOF : *IS++) : *IS++)\n\tinline void flush() {\n\t\tfwrite(OB, 1, OS - OB, stdout), OS = OB;\n\t}\n\tinline void pc(char x) {\n\t\t*OS++ = x;\n\t\tif (OS == OT) flush();\n\t}\n\n\ttemplate <class I>\n\tinline void rd(I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + (c & 15), c = gc());\n\t\tx *= f;\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y) {\n\t\trd(x), rd(y);\n\t}\n\ttemplate <class I>\n\tinline void rd(I &x, I &y, I &z) {\n\t\trd(x), rd(y), rd(z);\n\t}\n\ttemplate <class I>\n\tinline void rda(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) rd(a[i]);\n\t}\n\tinline void rdc(char &c) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t}\n\tinline void rds(char *s, int &n) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (n = 0; c >= 33 && c <= 126; s[++n] = c, c = gc());\n\t\ts[n+1] = '\\0';\n\t}\n\tinline void rds(string &s) {\n\t\tfor (c = gc(); c < 33 || c > 126; c = gc());\n\t\tfor (s.clear(); c >= 33 && c <= 126; s.pb(c), c = gc());\n\t}\n\n\ttemplate <class I>\n\tinline void print(I x, char k = '\\n') {\n\t\tif (!x) pc('0');\n\t\tif (x < 0) pc('-'), x = -x;\n\t\twhile (x) ch[++t] = x % 10 + '0', x /= 10;\n\t\twhile (t) pc(ch[t--]);\n\t\tpc(k);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y) {\n\t\tprint(x, ' '), print(y);\n\t}\n\ttemplate <class I>\n\tinline void print(I x, I y, I z) {\n\t\tprint(x, ' '), print(y, ' '), print(z);\n\t}\n\ttemplate <class I>\n\tinline void printa(I *a, int n) {\n\t\tfor (int i = 1; i <= n; i++) print(a[i], \" \\n\"[i==n]);\n\t}\n\tinline void printc(char c) {\n\t\tpc(c);\n\t}\n\tinline void prints(char *s, int n) {\n\t\tfor (int i = 1; i <= n; i++) pc(s[i]);\n\t\tpc('\\n');\n\t}\n\tinline void prints(string s) {\n\t\tint n = s.length();\n\t\twhile (t < n) pc(s[t++]);\n\t\tpc('\\n'), t = 0;\n\t}\n\tstruct Flush {\n\t\t~Flush() {\n\t\t\tflush();\n\t\t}\n\t} flusher;\n}\nusing io::rd;\nusing io::rda;\nusing io::rdc;\nusing io::rds;\nusing io::print;\nusing io::printa;\nusing io::printc;\nusing io::prints;\n\nnamespace Dinic {\n\tconst int N = 2e5 + 7, M = 2e6 + 7;\n\tconst ll inf = 1e18;\n\tint n, S, T, d[N];\n\tint h[N], hi[N], e[M], t[M], tot;\n\tll f[M], mxf;\n\n\tinline void add(int x, int y, ll z, bool o = 1) {\n\t\te[++tot] = y, f[tot] = z, t[tot] = h[x], h[x] = tot;\n\t\tif (o) add(y, x, 0, 0);\n\t}\n\n\tinline bool bfs() {\n\t\tfor (int i = 1; i <= n; i++) d[i] = 0;\n\t\tqueue<int> q;\n\t\tq.push(S), d[S] = 1;\n\t\twhile (q.size()) {\n\t\t\tint x = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = h[x]; i; i = t[i]) {\n\t\t\t\tint y = e[i];\n\t\t\t\tll z = f[i];\n\t\t\t\tif (d[y] || !z) continue;\n\t\t\t\tq.push(y), d[y] = d[x] + 1;\n\t\t\t\tif (y == T) return 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll dfs(int x, ll now = inf) {\n\t\tif (x == T) return now;\n\t\tll rst = now;\n\t\tfor (int &i = hi[x]; i; i = t[i]) {\n\t\t\tint y = e[i];\n\t\t\tll z = f[i];\n\t\t\tif (d[y] != d[x] + 1 || !z) continue;\n\t\t\tll k = dfs(y, min(z, rst));\n\t\t\tif (!k) d[y] = 0;\n\t\t\telse f[i] -= k, f[i^1] += k, rst -= k;\n\t\t\tif (!rst) break;\n\t\t}\n\t\treturn now - rst;\n\t}\n\n\tinline void main() {\n\t\twhile (bfs()) {\n\t\t\tfor (int i = 1; i <= n; i++) hi[i] = h[i];\n\t\t\tll now;\n\t\t\twhile ((now = dfs(S))) mxf += now;\n\t\t}\n\t}\n\n\tinline void init(int _n, int _S, int _T) {\n\t\tn = _n, S = _S, T = _T, tot = 1, mxf = 0;\n\t\tfor (int i = 1; i <= n; i++) h[i] = 0; \n\t}\n}\nusing Dinic::add;\n\nconst int N = 1e5 + 7;\nint n, f[N], fa[N], id[N];\nset<int> e[N], g[N];\nbool v[N];\npi ans[N];\n\nint main() {\n\trd(n), Dinic::init(2 * n, 1, 2 * n);\n\tfor (int i = 1, c, x; i < n; i++) {\n\t\tadd(1, i + 1, 1), add(i + n, 2 * n, 1);\n\t\trd(c);\n\t\twhile (c--) {\n\t\t\trd(x), e[i].insert(x), g[x].insert(i);\n\t\t\tif (x == 1) continue;\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\tDinic::main();\n\tif (Dinic::mxf != n - 1) return print(-1), 0;\n\tfor (int x = 1; x < n; x++)\n\t\tfor (int i = Dinic::h[x+n]; i; i = Dinic::t[i])\n\t\t\tif (Dinic::e[i] <= n && Dinic::f[i]) f[x] = Dinic::e[i];\n\tqueue<int> q;\n\tq.push(1);\n\twhile (q.size()) {\n\t\tint x = q.front();\n\t\tq.pop();\n\t\tfor (int y : g[x])\n\t\t\tif (!v[y]) v[y] = 1, fa[f[y]] = x, id[f[y]] = y, q.push(f[y]);\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tif (!v[i]) return print(-1), 0;\n\tfor (int i = 2; i <= n; i++) ans[id[i]] = mp(fa[i], i);\n\tfor (int i = 1; i < n; i++) print(ans[i].fi, ans[i].se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\trep(i, 1, n - 1) assert(bl[i] > 1 && bl[i] <= n);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    for (int it = 0; it < n - 1; it++) {\n      assert(!q.empty());\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v + 1, done + 1);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back({x,i,mxfl::adde(x,i+n,1)});\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#define debug(x) cerr << #x << ':' << x << '\\n'\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\ntemplate<class T> class Dinic {\n\tstruct edge {\n\t\tint to;\n\t\tT cap, icap;\n\t\tint rev;\n\t};\n\tvector<vector<edge>> graph;\n\tvector<int> level, iter;\npublic:\n\tDinic(int n) {\n\t\tgraph = vector<vector<edge>>(n, vector<edge>());\n\t\tlevel = iter = vector<int>(n);\n\t}\n\tvoid add_edge(int from, int to, T cap) {\n\t\tgraph[from].push_back({ to,cap,cap,(int)graph[to].size() });\n\t\tgraph[to].push_back({ from,0,0,(int)graph[from].size() - 1 });\n\t}\n\tvoid bfs(int s) {\n\t\tfor (int &i : level) i = -1;\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < graph[v].size(); i++) {\n\t\t\t\tedge &e = graph[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tT dfs(int v, int t, T f) {\n\t\tif (v == t) return f;\n\t\tfor (int &i = iter[v]; i < graph[v].size(); i++) {\n\t\t\tedge &e = graph[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tT d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tT max_flow(int s, int t) {\n\t\tT flow = 0;\n\t\twhile (true) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0) return flow;\n\t\t\tfor (int &i : iter) i = 0;\n\t\t\tT f = 0;\n\t\t\twhile ((f = dfs(s, t, inf)) > 0) flow += f;\n\t\t}\n\t}\n\tvector<P> bipartite_matching(int s, int t) {\n\t\tvector<P> res;\n\t\tmax_flow(s, t);\n\t\tfor (int i = 0; i < graph.size(); i++) {\n\t\t\tif (i == s) continue;\n\t\t\tfor (edge e : graph[i]) {\n\t\t\t\tif (e.cap == 0 && e.icap == 1 && e.to != t) {\n\t\t\t\t\tres.push_back({ i,e.to });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tint n;\n\tcin >> n;\n\tDinic<int> flow(2 * n + 2);\n\tvector<vector<int>> pl(n, vector<int>());\n\trep(i, n - 1) {\n\t\tint sz;\n\t\tcin >> sz;\n\t\trep(j, sz) {\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tv--;\n\t\t\tpl[v].pb(i);\n\t\t\tflow.add_edge(i, n + v, 1);\n\t\t}\n\t}\n\trep(i, n) {\n\t\tflow.add_edge(2 * n, i, 1);\n\t\tflow.add_edge(n + i, 2 * n + 1, 1);\n\t}\n\tvector<P> match = flow.bipartite_matching(2 * n, 2 * n + 1);\n\tsort(all(match));\n\tif (match.size() != n - 1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tvector<P> ans(n - 1);\n\trep(i, n - 1) ans[i].first = match[i].second - n;\n\tvector<bool> ap(n);\n\trep(i, n - 1) ap[ans[i].first] = true;\n\tint st = -1;\n\trep(i, n) if (!ap[i]) st = i;\n\tvector<bool> vis(n), use(n - 1);\n\tvis[st] = true;\n\tqueue<int> que;\n\tque.push(st);\n\twhile (!que.empty()) {\n\t\tint q = que.front(); que.pop();\n\t\tfor (int i : pl[q]) {\n\t\t\tif (!use[i] && !vis[ans[i].first]) {\n\t\t\t\tans[i].second = q;\n\t\t\t\tuse[i] = true;\n\t\t\t\tvis[ans[i].first] = true;\n\t\t\t\tque.push(ans[i].first);\n\t\t\t}\n\t\t}\n\t}\n\tbool ok = true;\n\trep(i, n) if (!vis[i]) ok = false;\n\tif (ok) rep(i, n - 1) cout << ans[i].first + 1 << ' ' << ans[i].second + 1 << '\\n';\n\telse cout << \"-1\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn << 1];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[201010];\nint match[201010];\nbool used[201010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=8e5+9,inf=1e8;\n\tint head[N],nex[N],to[N],fl[N],cnt=1;\n\tinline void add(int u,int v,int flow){\n\t//\tcout<<u<<\" \"<<v<<\" \"<<flow<<endl;\n\t\tnex[++cnt]=head[u],head[u]=cnt,to[cnt]=v,fl[cnt]=flow;\n\t\tnex[++cnt]=head[v],head[v]=cnt,to[cnt]=u,fl[cnt]=0;\n\t}\n\tint S,T,dist[N],cur[N];\n\tqueue<int> q;\n\tinline bool bfs(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=T;i++) dist[i]=inf;\n\t\tq.push(S),dist[S]=0;\n\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tif(u==T) return 1;\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(fl[i] && dist[to[i]]==inf){\n\t\t\t\t\tdist[to[i]]=dist[u]+1;\n\t\t\t\t\tq.push(to[i]);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tinline int dfs(int u,int flow){\n\t\tif(u==T) return flow;\n\t\tint rest=flow,k;\n\t\tfor(int &i=cur[u];rest && i;i=nex[i])\n\t\t\tif(fl[i] && dist[to[i]]==dist[u]+1){\n\t\t\t\tk=dfs(to[i],min(fl[i],flow));\n\t\t\t\tfl[i]-=k,fl[i^1]+=k,rest-=k;\n\t\t\t}\n\t\treturn flow-rest;\n\t}\n\n\tint n,mat[N],vis[N];\n\tvector<int> pos[N],E[N],ans[N];\n\tinline bool fortry(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!mat[i+n-1]){q.push(i);break;}\n\n\t\tint tot=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();tot++;\n\t\t\tfor(int i=0;i<pos[u].size();i++) if(!vis[pos[u][i]]){\n\t\t\t\tint id=pos[u][i];\n\t\t\t\tvis[pos[u][i]]=1,ans[id].push_back(mat[id]-n+1),ans[id].push_back(u);\n\t\t\t\tq.push(mat[id]-n+1);\n\t\t\t}\n\t\t}\n\t\tif(tot!=n) return 0;\n\t\treturn 1;\n\t}\n\tint main(){\n\t\tn=read<int>();\n\t\tS=n-1+n+1,T=S+1;\n\t\tfor(int t=1;t<n;t++){\n\t\t\tint k=read<int>();\n\t\t\tfor(int i=1;i<=k;i++){\n\t\t\t\tint u=read<int>();\n\t\t\t\tE[t].push_back(u),pos[u].push_back(t);\n\t\t\t\tadd(t,u+n-1,1);\n\t\t\t}\n\t\t\tadd(S,t,1);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+n-1,T,1);\n\t\tint mxfl=0;\n\t\twhile(bfs()){\n\t\t\tfor(int i=1;i<=T;i++) cur[i]=head[i];\n\t\t\tint d;\n\t\t\tdo{d=dfs(S,inf),mxfl+=d;}while(d);\n\t\t}\n\t\tif(mxfl!=n-1) puts(\"-1\"),exit(0);\n\t\tfor(int u=1;u<n;u++)\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(!fl[i]){mat[u]=to[i],mat[to[i]]=u;break;}\n\t\tif(!fortry()) puts(\"-1\"),exit(0);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][0]);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, tot = 0;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n), g(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j) {\n      fnd[--e[i][j]].push_back(i);\n      if (j) {\n        g[e[i][j]].push_back(e[i][0]);\n        g[e[i][0]].push_back(e[i][j]);\n      }\n    }\n    tot += c;\n  }\n  vector<int> from(n - 1, -1), dfn(n, -1);\n  int tm = 0;\n  function<void(int)> dfs = [&](int u) {\n    dfn[u] = tm++;\n    for (int v : g[u])\n      if (dfn[v] == -1)\n        dfs(v);\n  };\n  dfs(0);\n  if (count(dfn.begin(), dfn.end(), -1)) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    int myn = e[i][0];\n    for (size_t j = 1; j < e[i].size(); ++j)\n      if (dfn[e[i][j]] < dfn[myn])\n        myn = e[i][j];\n    from[i] = myn;\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i])\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i)\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i] && eref[i][j].get())\n        cout << (from[i] + 1) << ' ' << (e[i][j] + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// constructor(n)\n// addEdge(a, b) // bipartite graph (undirected)\n// === build() returns max flow ===\n// O(VE) but very fast\n// match[i] = some or -1\n// === restoreMinVertexCover() ===\n// O(V + E)\n// vertexCovered[i] = 1 or 0\n// === restoreMaxStableSet() ===\n// alias of previous\n// stable[i] = 1 or 0\n// === restoreMinEdgeCover() ===\n// O(V + E)\n// isolated cannot be covered\n// match2[i] = 1 or 0\n/// --- BipartiteMatching Library {{{ ///\nstruct BipartiteMatching {\n  int n;\n  vector< vector< int > > g;\n  BipartiteMatching(int n) : n(n), g(n) {}\n  void addEdge(int a, int b) {\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  vector< int > match;\n\nprivate:\n  vector< int > used;\n\npublic:\n  int build() {\n    match = vector< int >(n, -1);\n    int flow = 0;\n    for(int i = 0; i < n; i++) {\n      if(match[i] < 0) {            ///\n        used = vector< int >(n, 0); ///\n        if(dfs(i)) flow++;\n      }\n    }\n    return flow;\n  }\n  vector< int > vertexCovered;\n  vector< int > stable;\n  inline void restoreMaxStableSet() { restoreMinVertexCover(); }\n  void restoreMinVertexCover() {\n    vertexCovered = vector< int >(n);\n    stable = vector< int >(n, 1);\n    vector< int > used0(n), used1(n);\n    vector< int > color(n);\n    vector< int > red(n);\n    for(int i = 0; i < n; i++)\n      if(!used0[i]) {\n        // bfs\n        queue< int > q0;\n        queue< int > q1;\n        q0.emplace(i);\n        used0[i] = 1;\n        while(q0.size()) {\n          int j = q0.front();\n          q0.pop();\n          if(color[j] == 0 && match[j] == -1) q1.emplace(j);\n          for(int k : g[j])\n            if(!used0[k]) {\n              used0[k] = 1;\n              color[k] = color[j] ^ 1;\n              q0.emplace(k);\n            }\n        }\n        used1[i] = 1;\n        while(q1.size()) {\n          int j = q1.front();\n          q1.pop();\n          red[j] = 1;\n          if(color[j] == 1) {\n            if(match[j] != -1) q1.emplace(match[j]);\n          } else {\n            for(int k : g[j])\n              if(!used1[k] && k != match[j]) {\n                used1[k] = 1;\n                q1.emplace(k);\n              }\n          }\n        }\n      }\n    for(int i = 0; i < n; i++)\n      if(color[i] ^ red[i] ^ 1) vertexCovered[i] = 1, stable[i] = 0;\n  }\n  vector< int > match2;\n  void restoreMinEdgeCover() {\n    match2 = match;\n    for(int i = 0; i < n; i++)\n      if(match2[i] == -1) {\n        for(int j : g[i])\n          if(match2[j] == -1) {\n            match2[i] = j;\n            match2[j] = i;\n            break;\n          }\n      }\n  }\n\nprivate:\n  bool dfs(int v) {\n    if(used[v]) return false; ///\n    used[v] = 1;\n    for(int u : g[v])\n      if(match[u] < 0 || dfs(match[u])) {\n        match[v] = u;\n        match[u] = v;\n        return true;\n      }\n    return false;\n  }\n};\n/// }}}--- ///\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := x\n\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// \n// kk\n//  (k+1) \n//  k \n// n-1\n\n//  E_i has i \n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} \n// N\n// N\n\n// DFS\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  BipartiteMatching eca(n - 1 + n);\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      eca.addEdge(i, n - 1 + x);\n    }\n  }\n  int sz = eca.build();\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(int i = 0; i < n - 1; i++) {\n    int v = eca.match[i] - (n - 1);\n    ans[i][0] = v;\n    found[v] = 1;\n  }\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, c, u;\n\nvector<int> edge[108000];\nvector<int> ans[108000];\nbool come[108000];\n\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tedge[i].push_back(n + u);\n\t\t\tedge[n+u].push_back(i);\n\t\t}\t\n\t}\n\tdfs(n+1);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef HOME\n#define db(x) cerr << #x << \" = \" << x << endl\n#define db3(x, y, z) cerr << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define db2(x, y) cerr << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl\n#define dbv(a) cerr << #a << \" = \"; for (auto xxx: a) cerr << xxx  << \" \"; cerr << endl\n#else\n#define db(x) ;\n#define db3(x, y, z) ;\n#define db2(x, y) ;\n#define dbv(a) ;\n#endif\n\nusing namespace std;\ntypedef long long ll;\ntypedef double dbl;\n\n\nconst int INF = 1.01e9;\n\n\n\nstruct Edge {\n    int to, cap, flow;\n};\n\nstruct Graph {\n    int n;\n    vector<vector<int> > e;\n    vector<Edge> edges;\n    vector<int> d, c;\n\n    Graph() {}\n    Graph(int _n) {\n        n = _n;\n        e.resize(n);\n    }\n\n    void addEdge(int from, int to, int cap) {\n        e[from].push_back(edges.size());\n        edges.push_back(Edge({to, cap, 0}));\n        e[to].push_back(edges.size());\n        edges.push_back(Edge({from, 0, 0}));\n    }\n\n    bool bfs() {\n        d.assign(n, INF);\n        c.assign(n, 0);\n        vector<int> q(n);\n        int qL = 0, qR = 0;\n        d[0] = 0;\n        q[qR++] = 0;\n        while (qL < qR) {\n            int v = q[qL++];\n            for (int i = 0; i < (int)e[v].size(); i++) {\n                Edge cur = edges[e[v][i]];\n                if (d[cur.to] > d[v] + 1 && cur.flow < cur.cap) {\n                    d[cur.to] = d[v] + 1;\n                    q[qR++] = cur.to;\n                }\n            }\n        }\n        return d[n - 1] != INF;\n    }\n\n    int dfs(int v, int flow) {\n        if (v == n - 1) return flow;\n        if (flow == 0) return 0;\n        for (int &i = c[v]; i < (int)e[v].size(); i++) {\n            Edge cur = edges[e[v][i]];\n            if (d[cur.to] != d[v] + 1) continue;\n            int pushed = dfs(cur.to, min(flow, cur.cap - cur.flow));\n            if (pushed > 0) {\n                edges[e[v][i]].flow += pushed;\n                edges[e[v][i] ^ 1].flow -= pushed;\n                return pushed;\n            }\n        }\n        return 0;\n    }\n\n    ll flow() {\n        ll flow = 0;\n        while (bfs()) {\n            while (int pushed = dfs(0, INF)) {\n                flow += pushed;\n            }\n        }\n        return flow;\n    }\n};\n\nvoid print(vector<pair<int, int>> a) {\n    if (a.empty()) printf(\"%d\\n\", -1);\n    else for (auto o : a) printf(\"%d %d\\n\", o.first + 1, o.second + 1);\n}\n\nvector<pair<int, int>> solve(vector<vector<int>> a) {\n    int n = a.size() + 1;\n\n    Graph gr(1 + n-1 + n + 1);\n    for (int i = 0; i < n-1; i++) {\n        gr.addEdge(0, 1 + i, 1);\n    }\n    for (int i = 0; i < n-1; i++) {\n        for (int x : a[i]) {\n            gr.addEdge(1 + i, 1 + n-1 + x, 1);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        gr.addEdge(1 + n-1 + i, 1 + n-1 + n, 1);\n    }\n    int fl = gr.flow();\n\n    if (fl != n-1) {\n        return vector<pair<int, int>>();\n    }\n\n    vector<pair<int, int>> e1, e2;\n    for (int i = 0; i < n-1; i++) {\n        for (auto id : gr.e[1 + i]) {\n            auto ed = gr.edges[id];\n            if (ed.to >= 1 + n-1 && ed.to < 1 + n-1 + n) {\n                if (ed.flow > 0) {\n                    e1.push_back({i, ed.to - (1 + n-1)});\n                } else {\n                    e2.push_back({i, ed.to - (1 + n-1)});\n                }\n            }\n        }\n    }\n    assert(e1.size() == n-1);\n\n    vector<int> cov(n);\n    for (auto o : e1) cov[o.second] = 1;\n\n    vector<int> ncov;\n    for (int i = 0; i < n; i++) if (cov[i] == 0) ncov.push_back(i);\n    assert(ncov.size() == 1);\n\n    vector<vector<int>> g(n + n-1);\n    for (auto ed : e1) {\n        g[ed.first].push_back(n-1 + ed.second);\n    }\n    for (auto ed : e2) {\n        g[n-1 + ed.second].push_back(ed.first);\n    }\n\n    vector<char> vis(n-1 + n);\n\n    function<void(int)> dfs = [&](int v) {\n        //cerr << v << endl;\n        vis[v] = 1;\n        for (int to : g[v]) {\n            if (!vis[to]) {\n                if (v >= n-1) {\n                    e1.push_back({to, v - (n-1)});\n                }\n                dfs(to);\n            }\n        }\n    };\n    dfs(n-1 + ncov[0]);\n\n    if ((int)e1.size() != 2 * (n - 1)) {\n        return vector<pair<int, int>>();\n    }\n    sort(e1.begin(), e1.end());\n\n    vector<pair<int, int>> ans;\n    for (int i = 0; i < (int)e1.size(); i += 2) {\n        assert(e1[i].first == e1[i + 1].first);\n        ans.push_back({e1[i].second, e1[i + 1].second});\n    }\n\n    {\n        vector<int> p(n);\n        iota(p.begin(), p.end(), 0);\n        function<int(int)> get = [&](int x) {\n            if (x == p[x]) return x;\n            return p[x] =get(p[x]);\n        };\n        auto uni = [&](int u, int v) {\n            u = get(u);\n            v = get(v);\n            if (u == v) return 0;\n            p[v] = u;\n            return  1;\n        };\n        assert((int)ans.size() == n - 1);\n        for (int i = 0; i < n-1; i++) {\n            assert(find(a[i].begin(), a[i].end(), ans[i].first) != a[i].end());\n            assert(find(a[i].begin(), a[i].end(), ans[i].second) != a[i].end());\n            assert(uni(ans[i].first, ans[i].second));\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n#ifdef HOME\n    assert(freopen(\"in\", \"r\", stdin));\n#endif\n\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        vector<vector<int>> a(n - 1);\n        for (int i = 0; i < n - 1; i++) {\n            int k;\n            scanf(\"%d\", &k);\n            a[i].resize(k);\n            for (int j = 0; j < k; j++) {\n                scanf(\"%d\", &a[i][j]);\n                a[i][j]--;\n            }\n        }\n\n        print(solve(a));\n    }\n\n#ifdef HOME\n    cerr << \"time: \" << clock() * 1.0 / CLOCKS_PER_SEC << endl;\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MN 200010\n#define MM 800010\n#define inf 999999999\nusing namespace std;\nint fr[MN],dy[MN],ne[MM],v[MM],w[MM],bs=0;\nvoid add(int a,int b,int c)\n{\n\tv[bs]=b;\n\tw[bs]=c;\n\tne[bs]=fr[a];\n\tfr[a]=bs++;\n}\nvoid addb(int a,int b,int c)\n{\n\tadd(a,b,c);\n\tadd(b,a,0);\n}\nint dl[MN],jl[MN],N,S,T;bool bk[MN];\nbool bfs()\n{\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tbk[i]=false;\n\t\tjl[i]=inf;\n\t}\n\tbk[S]=true;jl[S]=0;\n\tint he=0,ta=1;dl[0]=S;\n\twhile(he<ta)\n\t{\n\t\tint u=dl[he++];\n\t\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t\t{\n\t\t\tif(w[i]>0&&!bk[v[i]])\n\t\t\t{\n\t\t\t\tbk[v[i]]=true;\n\t\t\t\tjl[v[i]]=jl[u]+1;\n\t\t\t\tdl[ta++]=v[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn jl[T]<inf;\n}\nint dfs(int u,int z)\n{\n\tif(u==T)\n\t\treturn z;\n\tfor(int &i=dy[u];i!=-1;i=ne[i])\n\t{\n\t\tif(w[i]>0&&jl[v[i]]==jl[u]+1)\n\t\t{\n\t\t\tint t=dfs(v[i],z<w[i]?z:w[i]);\n\t\t\tif(t!=-1)\n\t\t\t{\n\t\t\t\tw[i]-=t;\n\t\t\t\tw[i^1]+=t;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint dinic()\n{\n\tint jg=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tdy[i]=fr[i];\n\t\twhile(1)\n\t\t{\n\t\t\tint t=dfs(S,inf);\n\t\t\tif(t==-1)\n\t\t\t\tbreak;\n\t\t\tjg+=t;\n\t\t}\n\t}\n\treturn jg;\n}\nvector<int> ve[100010],to[100010];\nint pp[100010],fa[100010];\nvoid dfs2(int u,int f)\n{\n\tif(bk[u])return;\n\tfa[u]=f;bk[u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],u);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint s,a;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<s;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tN=n*2+1;S=N-1;T=N;\n\tfor(int i=1;i<=N;i++)\n\t\tfr[i]=-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\taddb(S,i,1);\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t\taddb(i,ve[i][j]+n-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\taddb(i+n-1,T,1);\n\tif(dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbk[i]=false;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=fr[i];j!=-1;j=ne[j])\n\t\t{\n\t\t\tint t=v[j];\n\t\t\tif(t>n-1&&w[j]==0)\n\t\t\t{\n\t\t\t\tpp[i]=t-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t{\n\t\t\tif(ve[i][j]!=pp[i])\n\t\t\t\tto[ve[i][j]].push_back(pp[i]);\n\t\t}\n\t\tbk[pp[i]]=true;\n\t}\n\tint ro=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!bk[i])\n\t\t{\n\t\t\tro=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)bk[i]=false;\n\tdfs2(ro,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=ro&&fa[i]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t\tprintf(\"%d %d\\n\",pp[i],fa[pp[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)  cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tcout<<i<<' '<<i+1<<endl;\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cctype>\nconst int N=100007;\nstd::vector<int>e[N];std::queue<int>q;\nint vis[N],mat[N],tam[N];\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nint dfs(int u,int root)\n{\n    for(int v:e[u]) if(vis[v]^root) if(vis[v]=root,!mat[v]||dfs(mat[v],root)) return mat[v]=u;\n    return 0;\n}\nint main()\n{\n    int n=read();\n    for(int i=1;i<n;++i) for(int j=read();j;--j) e[read()].push_back(i);\n    for(int i=2;i<=n;++i) if(!dfs(i,i)) return puts(\"-1\"),0;\n    q.push(1);\n    for(int i=1,u;i<=n;++i)\n    {\n\tif(q.empty()) return puts(\"-1\"),0;\n\tu=q.front(),q.pop();\n\tfor(int v:e[u]) if(!tam[v]) tam[v]=u,q.push(mat[v]);\n    }\n    for(int i=1;i<n;++i) printf(\"%d %d\\n\",tam[i],mat[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[N<<1],got[N<<1],tak[N<<1];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[tot]=x,b[tot]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint father[N],get[N];\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][15];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n//\tif(total2%2==1)\n//\tprintf(\"%d %d %d\\n\",x,y,z);\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n//\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (y>TT) continue;\n\t\t\tif (v[i]>0&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{ \n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y>TT) continue;\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tif (i==6&&y==11)\n\t\t\t{\n\t\t\t\tT++;T--;\n\t\t\t}\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic(int start)\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(start,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nvoid dfs2(int k,int fa)\n{\n\tfor (int i=head2[k+n];i;i=nexts2[i])\n\t{\n\t\tint y=edge2[i];\n\t\tif (father[y]==0)\n\t\t{\n\t\t\tfather[y]=k;\n\t\t\tdfs2(get[y],k);\n\t\t}\n\t}\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic(SS);\n\tif (maxflow==sum)\n\t{\n\t\ttotal1=1;\n\t\tSS=S=0;TT=T=2*n+1;\n\t\tmemset(head,0,sizeof(head));\n\t\tmemset(nexts,0,sizeof(nexts));\n\t\tmemset(edge,0,sizeof(edge));\n\t\tmemset(v,0,sizeof(v));\n\t\ttotal2=1;\n\t\tmemset(head2,0,sizeof(head2));\n\t\tmemset(edge2,0,sizeof(edge2));\n\t\tmemset(nexts2,0,sizeof(nexts2));\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tinsert(SS,i,1);\n\t\t\tinsert(i,SS,0);\n\t\t//\tprintf(\"%d %d %d\\n\",SS,i,1); \n\t\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t\t{\n\t\t\t\tinsert2(s[i][j]+n,i,0,0);\n\t\t\t\tif (s[i][j]==1) continue;\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,s[i][j]+n,1);\n\t\t\t\tinsert(i,s[i][j]+n,1);\n\t\t\t\tinsert(s[i][j]+n,i,0);\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tinsert(i+n,TT,1);\n\t\t\tinsert(TT,i+n,0);\n\t\t//\tprintf(\"%d %d %d\\n\",i+n,TT,1);\n\t\t}\n\t\tmaxflow=re_dinic(SS);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tfor (int j=head[i];j;j=nexts[j])\n\t\t\t{\n\t\t\t\tint y=edge[j];\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,y,v[j^1]);\n\t\t\t\tif (j%2==0&&v[j]==0)\n\t\t\t\t{\n\t\t\t\t\tget[i]=y-n;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tmemset(father,0,sizeof(father));\n\t\t//stotal=0;\n\t\tdfs2(1,0);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",get[i],father[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=200000+10,inf=0x3f3f3f3f;\nint n,e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<1],to[MAXN<<1],out[MAXN<<1],cap[MAXN<<1],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nPII side[MAXN];\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tside[v]=mp(mh[v],x),vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,1,n-1)printf(\"%d %d\\n\",side[i].ft,side[i].sd);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\tconst int N = 2e5 + 5, INF = 0x3f3f3f3f;\n\n\tint n, s, t, Head[N], dep[N], cur[N], mat[N], from[N];\n\tstruct edge { int to, next, w; } E[N << 2];\n\tvector<int> Bel[N >> 1]; \n\n\tinline void add(const int u, const int v)\n\t{\n\t\tstatic int ec = 1;\n\t\tE[++ec] = (edge){v, Head[u], 1};\n\t\tHead[u] = ec;\n\t\tE[++ec] = (edge){u, Head[v], 0};\n\t\tHead[v] = ec;\n\t}\n\n\tbool bfs()\n\t{\n\t\tmemcpy(cur, Head, sizeof(int[t + 1]));\n\t\tmemset(dep, 0, sizeof(int[t + 1]));\n\t\tstatic queue<int> q;\n\t\tq.push(s);\n\t\tdep[s] = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = Head[u], v; i; i = E[i].next)\n\t\t\t\tif (E[i].w && !dep[v = E[i].to])\n\t\t\t\t\tdep[v] = dep[u] + 1, q.push(v);\n\t\t}\n\t\treturn dep[t];\n\t}\n\n\tint dfs(const int u, const int mn)\n\t{\n\t\tif (u == t || !mn)\n\t\t\treturn mn;\n\t\tint v, w, used = 0;\n\t\tfor (int &i = cur[u]; i; i = E[i].next)\n\t\t\tif (E[i].w && dep[v = E[i].to] == dep[u] + 1)\n\t\t\t{\n\t\t\t\tw = dfs(v, min(mn - used, E[i].w));\n\t\t\t\tused += w;\n\t\t\t\tE[i].w -= w;\n\t\t\t\tE[i ^ 1].w += w;\n\t\t\t\tif (used == mn)\n\t\t\t\t\treturn used;\n\t\t\t}\n\t\tif (!used)\n\t\t\tdep[u] = -1;\n\t\treturn used;\n\t}\n\n\tint Dinic()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t\tans += dfs(s, INF);\n\t\treturn ans;\n\t}\n\n\tbool search()\n\t{\n\t\tstatic queue<int> q;\n\t\tq.push(n);\n\t\tfrom[n] = -1;\n\t\tint cnt = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(), p;\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\tfor (int i : Bel[x])\n\t\t\t\tif (!from[p = mat[i]])\n\t\t\t\t\tfrom[p] = x, q.push(p);\n\t\t}\n\t\treturn cnt == n;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1, c, j; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &j);\n\t\t\t\tif (j != n)\n\t\t\t\t\tadd(j, i + n);\n\t\t\t\tBel[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\ts = n + n, t = s + 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tadd(s, i), add(i + n, t);\n\t\tint flow = Dinic();\n\t\tif (flow != n - 1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor (int u = 1; u < n; u++)\n\t\t\t\tfor (int i = Head[u + n]; i; i = E[i].next)\n\t\t\t\t\tif (E[i].w == 1 && E[i].to < n)\n\t\t\t\t\t{\n\t\t\t\t\t\tmat[u] = E[i].to;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!search())\n\t\t\t\tputs(\"-1\");\n\t\t\telse\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tprintf(\"%d %d\\n\", i, from[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nnamespace DinicFlows {\n\ttypedef long long LL;\n\tconst LL Inf = 0x3f3f3f3f3f3f3f3f;\n\tconst int MN = 200005, MM = 400005;\n\t\n\tint N, S, T;\n\tint h[MN], iter[MN], nxt[MM * 2], to[MM * 2], tot; LL w[MM * 2];\n\t\n\tinline void SetST(int, int);\n\tinline void Init(int _N) {\n\t\tN = _N, tot = 1;\n\t\tfor (int i = 1; i <= N; ++i) h[i] = 0;\n\t\tSetST(_N - 1, _N);\n\t}\n\tinline void SetST(int _S, int _T) { S = _S, T = _T; }\n\t\n\tinline void ins(int u, int v, LL x) { nxt[++tot] = h[u], to[tot] = v, w[tot] = x, h[u] = tot; }\n\tinline void insw(int u, int v, LL w1 = Inf, LL w2 = 0) {\n\t\tif (!u) u = S; if (!v) v = T;\n\t\tins(u, v, w1), ins(v, u, w2);\n\t}\n\t\n\tint lv[MN], que[MN], l, r;\n\t\n\tinline bool Lvl() {\n\t\tfor (int i = 1; i <= N; ++i) lv[i] = 0;\n\t\tlv[S] = 1;\n\t\tque[l = r = 1] = S;\n\t\twhile (l <= r) {\n\t\t\tint u = que[l++];\n\t\t\tfor (int i = h[u]; i; i = nxt[i])\n\t\t\t\tif (w[i] && !lv[to[i]]) {\n\t\t\t\t\tlv[to[i]] = lv[u] + 1;\n\t\t\t\t\tque[++r] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn lv[T] != 0;\n\t}\n\t\n\tLL Flow(int u, LL f) {\n\t\tif (u == T) return f;\n\t\tLL d = 0, s = 0;\n\t\tfor (int &i = iter[u]; i; i = nxt[i])\n\t\t\tif (w[i] && lv[to[i]] == lv[u] + 1) {\n\t\t\t\td = Flow(to[i], std::min(f, w[i]));\n\t\t\t\tf -= d, s += d;\n\t\t\t\tw[i] -= d, w[i ^ 1] += d;\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\treturn s;\n\t}\n\t\n\tinline LL Dinic() {\n\t\tLL Ans = 0;\n\t\twhile (Lvl()) {\n\t\t\tfor (int i = 1; i <= N; ++i) iter[i] = h[i];\n\t\t\tAns += Flow(S, Inf);\n\t\t}\n\t\treturn Ans;\n\t}\n}\nusing DinicFlows::h;\nusing DinicFlows::to;\nusing DinicFlows::nxt;\nusing DinicFlows::w;\nusing DinicFlows::insw;\n\nconst int MN = 100005;\n\nint N, mch[MN], vis[MN];\nint eu[MN], ev[MN], M;\n\nvoid DFS(int u) {\n\tfor (int j = h[u]; j; j = nxt[j]) {\n\t\tif (to[j] == N + N || vis[to[j] - N]) continue;\n\t\tint id = to[j] - N;\n\t\tvis[id] = 1;\n\t\tfor (int k = h[to[j]]; k; k = nxt[k]) if(w[k])\n\t\t\t++M, eu[id] = u, ev[id] = to[k], DFS(to[k]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tDinicFlows::Init(N + N + 1);\n\tfor (int i = 1; i <= N; ++i) insw(0, i, 1);\n\tfor (int i = 1, c, x; i < N; ++i) {\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) scanf(\"%d\", &x), insw(x, N + i, 1);\n\t\tinsw(N + i, 0, 1);\n\t}\n\tif (DinicFlows::Dinic() != N - 1) return puts(\"-1\"), 0;\n\tint Root = 0;\n\tfor (int i = h[N + N]; i; i = nxt[i]) if (w[i]) Root = to[i];\n\tDFS(Root);\n\tif (M != N - 1) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < N; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[101010];\nint match[101010];\nbool used[101010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: wxyww\n* @Date: 2020-04-01 11:25:14\n* @Last Modified time: 2020-04-01 11:48:30\n*/\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 200010;\nll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nvector<int>t[N];\nqueue<int>q;\nint V[N],U[N];\nvector<int>::iterator it;\nstruct node {\n\tint v,nxt,w;\n}e[N << 1];\nint head[N],ejs = 1,cur[N];\nvoid add(int u,int v,int w) {\n\te[++ejs].v = v;e[ejs].nxt = head[u];head[u] = ejs;e[ejs].w = w;\n\te[++ejs].v = u;e[ejs].nxt = head[v];head[v] = ejs;e[ejs].w = 0;\n}\nint dep[N],S,T;\nint bfs() {\n\tq.push(S);\n\tmemset(dep,0,sizeof(dep));\n\tdep[S] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!dep[v] && e[i].w) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T];\n}\nint dfs(int u,int now) {\n\tif(u == T) return now;\n\tint ret = 0;\n\tfor(int &i = cur[u];i;i = e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif(dep[v] == dep[u] + 1 && e[i].w) {\n\t\t\tint k = dfs(v,min(now - ret,e[i].w));\n\t\t\te[i].w -= k;\n\t\t\te[i ^ 1].w += k;\n\t\t\tret += k;\n\t\t\tif(ret == now) return ret;\n\t\t}\n\t}\n\treturn ret;\n}\nint dinic() {\n\tint ret = 0;\n\twhile(bfs()) {\n\t// puts(\"!!!!\");\n\t\tmemcpy(cur,head,sizeof(cur));\n\t\tret += dfs(S,10000000);\n\t}\n\treturn ret;\n}\nint flag[N];\nint main() {\n\tint n = read();\n\tS = 1,T = n + n;\n\tfor(int i = 2;i <= n;++i)\n\t\tadd(S,i,1);\n\tfor(int i = n + 1;i < n + n;++i)\n\t\tadd(i,T,1);\n\tfor(int i = 2;i <= n;++i) {\n\t\tint tot = read();\n\t\tfor(int j = 1;j <= tot;++j) {\n\t\t\tint x = read();\n\t\t\tt[x].push_back(i);\n\t\t\tif(x == 1) continue;\n\t\t\tadd(i,x + n - 1,1);\n\t\t}\n\t}\n\n\tif(dinic() != n - 1) {\n\t\tputs(\"-1\");return 0;\n\t}\n\n\n\tfor(int u = 2;u <= n;++u)\n\t\tfor(int i = head[u];i;i = e[i].nxt)\n\t\t\tif(!e[i].w)\n\t\t\t\tV[u] = e[i].v - n + 1;\n\n\t// for(int i = 2;i <= n;++i) printf(\"%d \",V[i]);\n\t// puts(\"\");\n\n\tq.push(S);\n\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tfor(it = t[u].begin();it != t[u].end();++it) {\n\t\t\t\tif(flag[*it]) continue;\n\t\t\t\tflag[*it] = 1;\n\t\t\t\tU[*it] = u;\n\t\t\t\tq.push(V[*it]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tif(!U[i]) {\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,a,b) for(int i=(a),_ed=(b);i<=_ed;++i)\n#define DREP(i,a,b) for(int i=(a),_ed=(b);i>=_ed;--i)\n#define mp(x,y) make_pair((x),(y))\n#define sz(x) (int)(x).size()\n#define pb push_back\ntypedef long long ll;\ntypedef pair<int,int> pii;\ninline int read(){\n    register int x=0,f=1;register char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-')f=0;ch=getchar();}\n    while(isdigit(ch)){x=x*10+(ch^'0');ch=getchar();}\n    return f?x:-x;\n}\n\nconst int N=1e5+5,inf=0x3f3f3f3f;\nint n,s,t,head[N<<1],num=1;\nstruct edge{int to,flo,next;} e[N*10];\ninline void add(int u,int v){\n    e[++num]=(edge){v,1,head[u]},head[u]=num;\n    e[++num]=(edge){u,0,head[v]},head[v]=num;\n}\n\nint dis[N<<1];\nbool bfs(){\n    queue<int> q;\n    memset(dis,0,sizeof dis);\n    q.push(s),dis[s]=1;\n    while(!q.empty()){\n\tint u=q.front();q.pop();\n\tfor(int i=head[u];i;i=e[i].next){\n\t    int v=e[i].to;if(dis[v]||!e[i].flo)continue;\n\t    dis[v]=dis[u]+1,q.push(v);\n\t}\n    }\n    return dis[t];\n}\nint dfs(int u,int lim){\n    if(u==t||!lim)return lim;\n    int flow=0;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(dis[v]!=dis[u]+1||!e[i].flo)continue;\n\tint f=dfs(v,min(lim,e[i].flo));\n\te[i].flo-=f,e[i^1].flo+=f;\n\tlim-=f,flow+=f;\n\tif(!lim)break;\n    }\n    return flow;\n}\nint Netflow(){\n    int ans=0;\n    while(bfs())ans+=dfs(s,inf);\n    return ans;\n}\n\nint fa[N<<1],vis[N<<1],cnt;\npii ans[N];\nvoid serch(int u,int pa){\n    cnt+=u<=n,vis[u]=1,fa[u]=pa;\n    for(int i=head[u];i;i=e[i].next){\n\tint v=e[i].to;if(vis[v]||!e[i].flo)continue;\n\tserch(v,u);\n    }\n}\n\nint main(){\n    //freopen(\"in.in\",\"r\",stdin);\n    n=read();s=n+n,t=s+1;\n    REP(i,1,n)add(s,i);\n    REP(i,1,n-1)add(n+i,t);\n    REP(i,1,n-1)REP(c,1,read()){int u=read();add(u,n+i);}\n    if(Netflow()<n-1)return puts(\"-1\"),0;\n    int rt=0;\n    for(int i=head[s];i;i=e[i].next)if(e[i].flo){rt=e[i].to;break;}\n    serch(rt,0);\n    if(cnt<n)return puts(\"-1\"),0;\n    REP(i,1,n)if(i!=rt){\n\tint id=fa[i],p=fa[id];\n\tans[id-n]=mp(p,i);\n    }\n    REP(i,1,n-1)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg {\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int i=head[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()) {\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\nvector<pii>ans;\nint main(){\n    ios::sync_with_stdio(0);\n    int n;cin>>n;\n    rep(i,1,n-1) {\n        int c;cin>>c;\n        rep(j,1,c) {\n            int u;cin>>u;E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        cout<<\"-1\";return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans.pb(mk(u,set_match));\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        cout<<\"-1\";return 0;\n    }\n    for(int i=0;i<ans.size();i++) {\n        cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, tot = 0;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n    tot += c;\n  }\n  vector<int> from(n - 1, -1);\n  vector<bool> vis(n);\n  queue<int> q;\n  vis[0] = true;\n  q.push(0);\n  while (!q.empty()) {\n    int u = q.front(); q.pop();\n    for (int id : fnd[u]) {\n      if (from[id] != -1) continue;\n      from[id] = u;\n      for (int v : e[id])\n        if (!vis[v]) {\n          vis[v] = true;\n          q.push(v);\n        }\n    }\n  }\n  if (count(vis.begin(), vis.end(), false)) {\n    puts(\"-1\");\n    return 0;\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i])\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 0; i < n - 1; ++i)\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != from[i] && eref[i][j].get())\n        cout << (from[i] + 1) << ' ' << (e[i][j] + 1) << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nset<int> E[N],app[N];\nvector<pii> ans;\nset<pii> s;\nint n,c,w;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tread(c);\n\t\trep(j,1,c){\n\t\t\tread(w);\n\t\t\tE[i].insert(w);\n\t\t\tapp[w].insert(i);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts.insert(mp(app[i].size(),i));\n\t}\n\twhile(s.size()>=2){\n\t\tint x=s.begin()->se;\n\t\ts.erase(s.begin());\n\t\tif(!app[x].size())GG();\n\t\tint k=*app[x].begin();\n\t\tif(E[k].size()<app[x].size())GG();\n\t\tif(E[k].size()<2)GG();\n\t\tint U=*E[k].begin();\n\t\tint V=*(--E[k].end());\n\t\tif(x==U)ans.pb(mp(x,V));\n\t\telse ans.pb(mp(x,U));\n\t\tE[k].erase(x);\n\t\tapp[x].erase(k);\n\t\tfor(auto y:E[k]){\n\t\t\ts.erase(mp(app[y].size(),y));\n\t\t\tapp[y].erase(k);\n\t\t\ts.insert(mp(app[y].size(),y));\n\t\t}\n\t\tfor(auto t:app[x])\n\t\t\tE[t].erase(x);\n\t}\n\tfor(auto x:ans)\n\t\tprintf(\"%d %d\\n\",x.fi,x.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2], Q[Max_N], U[Max_N * 2], V[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 1;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u), Father[Get_Father(u)] = i;\n\t\t\tif (u != 1)\n\t\t\t\tG::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 1;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(1))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tQ[Q[0] = 1] = 1;\n\t\tfor (int u, ft = 1;ft <= Q[0];)\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = 0, t;i < In[u].size();++i)\n\t\t\t\tif (!done[t = In[u][i]])\n\t\t\t\t{\n\t\t\t\t\tdone[t] = true;\n\t\t\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\t\t\tU[t] = u, V[t] = v, Q[++Q[0]] = v;\n\t\t\t\t}\n\t\t}\n\t\tfor (int i = N + 1;i <= N + (N - 1);++i)\n\t\t\tprint(U[i]), putc(' '), print(V[i]), putc('\\n');\n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\treturn 0;\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tprintf(\"%d %d\\n\",x,ma[v2[x][i]]);\n\t\tvis[v2[x][i]]=1;\n\t\tson[x].push_back(ma[v2[x][i]]);\n\t}\n\tfor(int i=0;i<(int)son[x].size();i++)dfs(son[x][i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=2;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tif(x!=1)add(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=2;x<=n;x++)\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz)ma[w[i].to-n]=x;\n\tdfs(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MN 200010\n#define MM 800010\n#define inf 999999999\nusing namespace std;\nint fr[MN],ne[MM],v[MM],w[MM],bs=0;\nvoid add(int a,int b,int c)\n{\n\tv[bs]=b;\n\tw[bs]=c;\n\tne[bs]=fr[a];\n\tfr[a]=bs++;\n}\nvoid addb(int a,int b,int c)\n{\n\tadd(a,b,c);\n\tadd(b,a,0);\n}\nint dl[100010],jl[100010],N,S,T;bool bk[100010];\nbool bfs()\n{\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tbk[i]=false;\n\t\tjl[i]=inf;\n\t}\n\tbk[S]=true;jl[S]=0;\n\tint he=0,ta=1;dl[0]=S;\n\twhile(he<ta)\n\t{\n\t\tint u=dl[he++];\n\t\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t\t{\n\t\t\tif(w[i]>0&&!bk[v[i]])\n\t\t\t{\n\t\t\t\tbk[v[i]]=true;\n\t\t\t\tjl[v[i]]=jl[u]+1;\n\t\t\t\tdl[ta++]=v[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn jl[T]<inf;\n}\nint dfs(int u,int z)\n{\n\tif(u==T)\n\t\treturn z;\n\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t{\n\t\tif(w[i]>0&&jl[v[i]]==jl[u]+1)\n\t\t{\n\t\t\tint t=dfs(v[i],z<w[i]?z:w[i]);\n\t\t\tif(t!=-1)\n\t\t\t{\n\t\t\t\tw[i]-=t;\n\t\t\t\tw[i^1]+=t;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint dinic()\n{\n\tint jg=0;\n\twhile(bfs())\n\t{\n\t\twhile(1)\n\t\t{\n\t\t\tint t=dfs(S,inf);\n\t\t\tif(t==-1)\n\t\t\t\tbreak;\n\t\t\tjg+=t;\n\t\t}\n\t}\n\treturn jg;\n}\nvector<int> ve[100010],to[100010];\nint pp[100010],fa[100010];\nvoid dfs2(int u,int f)\n{\n\tif(bk[u])return;\n\tfa[u]=f;bk[u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],u);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint s,a;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<s;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tN=n*2+1;S=N-1;T=N;\n\tfor(int i=1;i<=N;i++)\n\t\tfr[i]=-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\taddb(S,i,1);\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t\taddb(i,ve[i][j]+n-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\taddb(i+n-1,T,1);\n\tif(dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbk[i]=false;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=fr[i];j!=-1;j=ne[j])\n\t\t{\n\t\t\tint t=v[j];\n\t\t\tif(t>n-1&&w[j]==0)\n\t\t\t{\n\t\t\t\tpp[i]=t-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t{\n\t\t\tif(ve[i][j]!=pp[i])\n\t\t\t\tto[ve[i][j]].push_back(pp[i]);\n\t\t}\n\t\tbk[pp[i]]=true;\n\t}\n\tint ro=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!bk[i])\n\t\t{\n\t\t\tro=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)bk[i]=false;\n\tdfs2(ro,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=ro&&fa[i]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t\tprintf(\"%d %d\\n\",pp[i],fa[pp[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],min(flow-used,c[i]));\n\t\tif(v)used+=v,c[i]-=v,c[i^1]+=v,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<set>\n#include<vector>\n#include<map>\n#include<queue>\n\n#define N 300005\n#define M 2000005\n\n#define ls (t<<1)\n#define rs ((t<<1)|1)\n#define mid ((l+r)>>1)\n\n#define mk make_pair\n#define pb push_back\n#define fi first\n#define se second\n\nusing namespace std;\n\nint i,j,m,n,p,k,st,ed,c,x,S[N],T[N],fox[N],k1=1,Q[N];\n\nvector<int>v[N],G[N];\n\nint dis[N];\n\nstruct Node{\n\t\t\tint ed,before,flow;\n}s[M];\n\nvoid add(int x,int y,int flow)\n{\n\t\ts[++k1].ed=y; s[k1].before=fox[x]; fox[x]=k1; s[k1].flow=flow;\n\t\ts[++k1].ed=x; s[k1].before=fox[y]; fox[y]=k1; s[k1].flow=0;\n}\n\nconst int inf=(int)1e9;\n\nint bfs()\n{\n\t\tint i;\n\t\tQ[Q[0]=1]=st; memset(dis,-1,sizeof(dis)); dis[st]=0;\n\t\tfor (int l=1;l<=Q[0]&&dis[ed]==-1;++l)\n\t\t{\n\t\t\t\tint p=Q[l];\n\t\t\t\tfor (i=fox[p];i;i=s[i].before)\n\t\t\t\t{\n\t\t\t\t\t\t\tint k=s[i].ed;\n\t\t\t\t\t\t\tif (dis[k]!=-1||!s[i].flow) continue;\n\t\t\t\t\t\t\tdis[k]=dis[p]+1;\n\t\t\t\t\t\t\tQ[++Q[0]]=k;\n\t\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=-1;\n}\n\nint dfs(int x,int flow)\n{\n\t\tif (x==ed) return flow;\n\t\tint i,nowans=0,a;\n\t\tfor (i=fox[x];i&&flow;i=s[i].before)\n\t\t{\n\t\t\t\tint p=s[i].ed;\n\t\t\t\tif (dis[p]!=dis[x]+1||!s[i].flow) continue;\n\t\t\t\ta=dfs(p,min(flow,s[i].flow));\n\t\t\t\tnowans+=a;\n\t\t\t\tflow-=a;\n\t\t\t\ts[i].flow-=a;\n\t\t\t\ts[i^1].flow+=a; \n\t\t}\n\t\tif (!nowans) dis[x]=-1;\n\t\treturn nowans;\t\n}\n\nint maxflow()\n{\n\t\tint ans=0;\n\t\twhile (bfs()) ans+=dfs(st,inf);\n\t\treturn ans;\n}\n\nint main()\n{\n\t\tscanf(\"%d\",&n); st=n*2+1; ed=st+1;\n\t\tfor (i=1;i<n;++i)\n\t\t{\n\t\t\t\tscanf(\"%d\",&c);\n\t\t\t\tfor (;c--;)\n\t\t\t\t{\n\t\t\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\t\t\tv[i].pb(x); \n\t\t\t\t\t\tif (x>1) add(x,i+n,1);\n\t\t\t\t}\n\t\t}\n\t\tfor (i=2;i<=n;++i) add(st,i,1);\n\t\tfor (i=1;i<n;++i) add(i+n,ed,1);\n\t\tif (maxflow()!=n-1)\n\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (i=2;i<=n;++i)\n\t\t\tfor (j=fox[i];j;j=s[j].before)\n\t\t\t\tif (s[j].ed<=2*n&&s[j].flow==0) T[s[j].ed-n]=i;\n\t\tfor (i=1;i<n;++i)\n\t\t{\n\t\t\t\t for (j=0;j<(int)v[i].size();++j)\n\t\t\t\t {\n\t\t\t\t \t\t\tint p=v[i][j];\n\t\t\t\t \t\t\tif (p==T[i]) continue;\n\t\t\t\t \t\t\tG[p].pb(i); \n\t\t\t\t }\n\t\t}\n\t\tQ[Q[0]=1]=1;\n\t\tfor (int l=1;l<=Q[0];++l)\n\t\t{\n\t\t\t\t\tint p=Q[l];\n\t\t\t\t\tfor (i=0;i<(int)G[p].size();++i)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tint k=G[p][i];\n\t\t\t\t\t\t\tif (S[k]) continue;\n\t\t\t\t\t\t\tS[k]=p; Q[++Q[0]]=T[k];\n\t\t\t\t\t}\n\t\t}\t\n\t\tif (Q[0]!=n) \n\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t}\n\t\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",S[i],T[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        while ( (f = dfs(s,t,inf) ) > 0 ) ans += f;\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , n;\n\nint main(){\n\t\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i] || sem[i] == apo[i]) return puts(\"-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int i=h[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[u]=v-n;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[N+3];\nvector<pair<int,pii> > ans;\nint mch[N+3];\nbool vis[N+3];\nint que[N+3];\nint n;\n\nbool bfs()\n{\n\tint hd = 1,tl = 1; que[1] = 1; vis[1] = true;\n\twhile(hd<=tl)\n\t{\n\t\tint u = que[hd]; hd++;\n\t\tfor(int o=0; o<adj[u].size(); o++)\n\t\t{\n\t\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\t\tif(vis[mch[v]]) continue;\n\t\t\tque[++tl] = mch[v]; vis[v] = vis[mch[v]] = true;\n\t\t\tans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\t}\n\t}\n\tif(tl<n) {return false;}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tif(!bfs()) {puts(\"-1\"); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\tdsu tmp(n);\n\tvector<int> deg(n+1);\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j, assert(j-1 < n), deg[j-1]++;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching(), res(n-1);\n\tsort(all(matching), [&](auto a, auto b) {\n\t\treturn f[a[0]-1].size() < f[b[0]-1].size();\n\t});\n\tfor(auto [i, x] : matching) {\n\t\t//cout << i << \" \" << x << endl;\n\t\tx -= n-1;\n\t\tsort(all(f[i-1]), [&](auto a, auto b) {\n\t\t\treturn deg[a-1] < deg[b-1];\n\t\t});\n\t\tfor(auto y : f[i-1]) if(!tmp.con(x-1, y-1)) {\n\t\t\ttmp.unite(x-1, y-1);\n\t\t\tres[i-1] = {x, y};\n\t\t\tbreak;\n\t\t}\n\t\tfor(auto y : f[i-1]) deg[y-1]--;\n\t}\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a << \" \" << b << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define M 1000010\n#define inf 1e9\nusing namespace std;\nint n,num,cnt,s,t,h[M],head[M],son[M],vis[M];\nvector<int>S[M],P[M];\nqueue<int>Que;\nstruct node{int x,y,id;}f[M];\nstruct edge{int next,to,dis;}e[M<<1];\nbool cmp(node a,node b) {return a.id<b.id;}\nvoid add(int from,int to,int dis) {\n\te[num]=(edge){head[from],to,dis};\n\thead[from]=num++;\n}\nbool bfs() {\n\tqueue<int>Q;Q.push(s);\n\tmemset(h,0,sizeof(h)),h[s]=1;\n\twhile(!Q.empty()) {\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis>0&&!h[e[i].to])\n\t\t\t\tQ.push(e[i].to),h[e[i].to]=h[x]+1;\n\t}\n\treturn h[t];\n}\nint dfs(int x,int dis) {\n\tif(x==t) return dis;int sum=0;\n\tfor(int i=head[x];i;i=e[i].next) {\n\t\tint to=e[i].to;\n\t\tif(e[i].dis&&h[to]==h[x]+1) {\n\t\t\tint diss=dfs(to,min(e[i].dis,dis));\n\t\t\tdis-=diss;sum+=diss;\n\t\t\te[i].dis-=diss;e[i^1].dis+=diss;\n\t\t\tif(!dis) break;\n\t\t}\n\t}\n\tif(!sum) h[x]=-1;\n\treturn sum;\n}\nint dinic() {\n\tint tot=0;\n\twhile(bfs()) \n\t\ttot+=dfs(s,inf);\n\treturn tot;\n}\nint main() {\n\tscanf(\"%d\",&n);s=0,t=2*n;\n\tfor(int i=1;i<n;i++) {\n\t\tint sum;scanf(\"%d\",&sum);\n\t\tfor(int j=1;j<=sum;j++) {\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tS[i+n].push_back(x);\n\t\t\tadd(i+n,x,0),add(x,i+n,1);\n\t\t\tP[x].push_back(i+n);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) add(i,s,0),add(s,i,1);\n\tfor(int i=n+1;i<n+n;i++) add(t,i,0),add(i,t,1);\n\tint ans=dinic();\n\tif(ans!=n-1) {puts(\"-1\");return 0;}\n\tfor(int x=n+1;x<n+n;x++)\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis&&e[i].to!=t)\n\t\t\t\tson[x]=e[i].to;\n\tQue.push(1);\n\twhile(!Que.empty()) {\n\t\tint x=Que.front();Que.pop();\n\t\tfor(int i=0;i<P[x].size();i++) {\n\t\t\tint to=P[x][i];\n\t\t\tif(!vis[to]) {\n\t\t\t\tvis[to]=true;\n\t\t\t\tQue.push(son[to]);\n\t\t\t\tf[++cnt]=(node){x,son[to],to};\n\t\t\t}\n\t\t}\n\t}\n\tsort(f+1,f+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    vector<pair<int, int>> ee;\n    int pp[maxn];\n    bool viss[maxn];\n\n    inline void getans() {\n        ee.clear();\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee.emplace_back(now, pp[jh]);\n                    q.push(pp[jh]);\n                }\n            }\n        }\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        getans();\n        if ((int) ee.size() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (auto x : ee) {\n            writesp(x.first), writeln(x.second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sz(a) int(a.size())\n#define clr(a) memset(a,0,sizeof(a))\n#define all(a) a.begin(),a.end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=5e5+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint to[N<<1],ww[N<<1],nxt[N<<1],h[N],dep[N],cur[N],s,t,tot=1;\nvoid adde(int u,int v,int w) {\n    to[++tot]=v,ww[tot]=w,nxt[tot]=h[u],h[u]=tot;\n    to[++tot]=u,ww[tot]=0,nxt[tot]=h[v],h[v]=tot;\n}\nint bfs() {\n    memset(dep,0,sizeof(dep));\n    queue<int> q;q.push(s);dep[s]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=h[u];i;i=nxt[i]) {\n            int v=to[i];\n            if(!dep[v]&&ww[i]) {\n                dep[v]=dep[u]+1,q.push(v);\n                if(v==t) return 1;\n            }\n        }\n    }\n    return 0;\n}\nint dfs(int u,int flow) {\n    if(u==t) return flow;\n    int ret=0;\n    for(int &i=cur[u];i;i=nxt[i]) {\n        int v=to[i];\n        if(dep[v]==dep[u]+1&&ww[i]) {\n            int d=dfs(v,min(flow,ww[i]));\n            ww[i]-=d,ww[i^1]+=d,ret+=d,flow-=d;\n            if(!flow) break;\n        }\n    }\n    if(!ret) dep[u]=0;\n    return ret;\n}\nint dinic() {\n    int ret=0;\n    while(bfs()) {\n        memcpy(cur,h,sizeof(h));\n        ret+=dfs(s,inf);\n    }\n    return ret;\n}\nint n,mat[N],vis[N],fa[N],cnt=0;\nvector<int> pos[N];\nvoid insert(int u) {\n    vis[u]=1,++cnt;\n    for(int i:pos[u])\n        if(mat[i]&&!vis[mat[i]]) fa[mat[i]]=u,insert(mat[i]);\n}\nint main() {\n    n=gi(),s=0,t=2*n+1;\n    for(int i=1;i<n;i++) {\n        int c=gi(),w;\n        adde(s,i,1);\n        for(int j=1;j<=c;j++) w=gi(),pos[w].pb(i),adde(i,w+n,1);\n    }\n    for(int i=2;i<=n;i++) adde(i+n,t,1);\n    if(dinic()!=n-1) return puts(\"-1\"),0;\n    for(int u=1;u<=n;u++) {\n        for(int i=h[u];i;i=nxt[i]) {\n            int v=to[i];\n            if(n+2<=v&&v<=n+n&&!ww[i]) mat[u]=v-n;\n        }\n    }\n    insert(1);\n    if(cnt!=n) return puts(\"-1\"),0;\n    for(int i=1;i<=n;i++) if(mat[i]) printf(\"%d %d\\n\",fa[mat[i]],mat[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\tconst int N = 2e5 + 5, INF = 0x3f3f3f3f;\n\n\tint n, s, t, Head[N], dep[N], cur[N], mat[N], from[N];\n\tpair<int, int> R[N];\n\tstruct edge { int to, next, w; } E[N << 2];\n\tvector<int> Bel[N >> 1]; \n\n\tinline void add(const int u, const int v)\n\t{\n\t\tstatic int ec = 1;\n\t\tE[++ec] = (edge){v, Head[u], 1};\n\t\tHead[u] = ec;\n\t\tE[++ec] = (edge){u, Head[v], 0};\n\t\tHead[v] = ec;\n\t}\n\n\tbool bfs()\n\t{\n\t\tmemcpy(cur, Head, sizeof(int[t + 1]));\n\t\tmemset(dep, 0, sizeof(int[t + 1]));\n\t\tstatic queue<int> q;\n\t\tq.push(s);\n\t\tdep[s] = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = Head[u], v; i; i = E[i].next)\n\t\t\t\tif (E[i].w && !dep[v = E[i].to])\n\t\t\t\t\tdep[v] = dep[u] + 1, q.push(v);\n\t\t}\n\t\treturn dep[t];\n\t}\n\n\tint dfs(const int u, const int mn)\n\t{\n\t\tif (u == t || !mn)\n\t\t\treturn mn;\n\t\tint v, w, used = 0;\n\t\tfor (int &i = cur[u]; i; i = E[i].next)\n\t\t\tif (E[i].w && dep[v = E[i].to] == dep[u] + 1)\n\t\t\t{\n\t\t\t\tw = dfs(v, min(mn - used, E[i].w));\n\t\t\t\tused += w;\n\t\t\t\tE[i].w -= w;\n\t\t\t\tE[i ^ 1].w += w;\n\t\t\t\tif (used == mn)\n\t\t\t\t\treturn used;\n\t\t\t}\n\t\tif (!used)\n\t\t\tdep[u] = -1;\n\t\treturn used;\n\t}\n\n\tint Dinic()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t\tans += dfs(s, INF);\n\t\treturn ans;\n\t}\n\n\tbool search()\n\t{\n\t\tstatic queue<int> q;\n\t\tq.push(n);\n\t\tfrom[n] = -1;\n\t\tint cnt = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(), p;\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\tfor (int i : Bel[x])\n\t\t\t\tif (!from[p = mat[i]])\n\t\t\t\t{\n\t\t\t\t\tR[i] = make_pair(x, p);\n\t\t\t\t\tfrom[p] = x;\n\t\t\t\t\tq.push(p);\n\t\t\t\t}\n\t\t}\n\t\treturn cnt == n;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1, c, j; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &j);\n\t\t\t\tif (j != n)\n\t\t\t\t\tadd(j, i + n);\n\t\t\t\tBel[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\ts = n + n, t = s + 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tadd(s, i), add(i + n, t);\n\t\tint flow = Dinic();\n\t\tif (flow != n - 1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor (int u = 1; u < n; u++)\n\t\t\t\tfor (int i = Head[u + n]; i; i = E[i].next)\n\t\t\t\t\tif (E[i].w == 1 && E[i].to < n)\n\t\t\t\t\t\tmat[u] = E[i].to;\n\t\t\tif (!search())\n\t\t\t\tputs(\"-1\");\n\t\t\telse\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tprintf(\"%d %d\\n\", R[i].first, R[i].second);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(dep[lb[y]]==dep[o]+1&&c[y])\n\tif(flow(lb[y])){\n\t\tc[y]=0;\n\t\tc[y^1]=1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[re[lb[y]]][0]=o;\n\t\tbb[re[lb[y]]][1]=lb[y];\n\t\t++oo;\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false) returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  ll build(int s, int t) {\n    vector< int > level(n);\n    ll flow = 0;\n    while(bfs(s, level), level[t] > 0) {\n      ll newflow = dfs(s, t, inf, level);\n      if(newflow == 0) break;\n      flow += newflow;\n      if(flow >= inf) return inf;\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] == -1 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e18;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := x\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// \n// kk\n//  (k+1) \n//  k \n// n-1\n\n//  E_i has i \n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} \n// N\n// N\n\n// DFS\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = long long;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v]){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        vector<ll> level(N,inf);\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%lld\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%lld\" , &c);\n        rep(i,0,c){\n            scanf (\"%lld\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%lld %lld\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ull = uint64_t;\nusing ll = int64_t;\nusing ld = long double;\n\nconst int N = 200228;\nvector<int> e[N];\nvector<int> erev[N];\n\nint n;\n\nint p[N];\nint pr[N];\n\nint w[N];\nint curv;\n\nint av[N], au[N];\n\nvoid nein() {\n    cout << -1 << \"\\n\";\n    exit(0);\n}\n\nbool dfs(int v) {\n    if (w[v] == curv) {\n        return false;\n    }\n\n    w[v] = curv;\n\n    for (int u: e[v]) {\n        if (p[u] == 0) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    for (int u: e[v]) {\n        if (dfs(u)) {\n            p[u] = v;\n            return true;\n        }\n    }\n\n    return false;\n}\n\nbool go[N];\n\nvoid dfsgo(int v) {\n    go[v] = true;\n    for (int u: erev[v]) {\n        if (!go[pr[u]]) {\n            av[u] = v;\n            au[u] = pr[u];\n            dfsgo(pr[u]);\n        }\n    }\n}\n\nint main() {\n#ifdef BZ\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); cout.setf(ios::fixed); cout.precision(20);\n\n    cin >> n;\n\n    for (curv = 1; curv < n; ++curv) {\n        int s;\n        cin >> s;\n        e[curv].resize(s);\n        for (int& v: e[curv]) {\n            cin >> v;\n            erev[v].push_back(curv);\n        }\n\n        if (!dfs(curv)) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n        pr[p[i]] = i;\n    }\n\n    int root = 1;\n    while (p[root]) {\n        ++root;\n    }\n\n    dfsgo(root);\n    for (int i = 1; i <= n; ++i) {\n        if (!go[i]) {\n            nein();\n        }\n    }\n\n    for (int i = 1; i < n; ++i) {\n        cout << av[i] << \" \" << au[i] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=400000+10,inf=0x3f3f3f3f;\nint n,fa[MAXN],e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<1],to[MAXN<<1],out[MAXN<<1],cap[MAXN<<1],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tfa[mh[v]]=x,vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,n)printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jump, and you will find out how to unfold your wings as you fall.\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=1e5+10,Src=maxn-3,Snk=maxn-2,inf=1e8;\n\nvector<pii>v[maxn];\nvector<int>vid[maxn];\nbool mark[maxn];\npii ans[maxn];\nint n,h[maxn],pt[maxn];\n\nvoid add_edge(int a,int b){\n    vid[a].PB(sz(v[b]));\n    vid[b].PB(sz(v[a]));\n    v[a].PB({b,1});\n    v[b].PB({a,0});\n}\n\nbool bfs(){\n    memset(mark,0,sizeof mark);\n    queue<int>q; q.push(Src); mark[Src]=1;\n    while(sz(q)){\n\tint u=q.front();\n\tif(u==Snk) return 1;\n\tq.pop();\n\tfor(pii p:v[u]){\n\t    if(p.S>0 && mark[p.F]==0){\n\t\th[p.F]=h[u]+1;\n\t\tmark[p.F]=1;\n\t\tq.push(p.F);\n\t    }\n\t}\n    }\n    return 0;\n}\nint dfs(int u,int flw=inf){\n    if(u==Snk) return flw;\n    int ans=0,&i=pt[u];\n    while(i<sz(v[u])){\n\tint y=v[u][i].F,&w=v[u][i].S,&w2=v[y][vid[u][i]].S;\n\tif(w>0 && h[u]+1==h[y]){\n\t    int num=dfs(y,min(flw-ans,w));\n\t    w-=num,w2+=num,ans+=num;\n\t    if(ans==flw) return ans;\n\t}\n\t++i;\n    }\n    return ans;\n}\nint flow(){\n    int ans=0;\n    while(bfs()){\n\tmemset(pt,0,sizeof pt);\n\tans+=dfs(Src);\n    }\n    return ans;\n}\n\nvoid go(int u,int par=-1){\n    mark[u]=1;\n    if(u>=n && u!=Src && u!=Snk){\n\tint y=-1;\n\tfor(pii p:v[u]){\n\t    if(p.S!=0)\n\t\ty=p.F;\n\t}\n\tans[u-n]={par+1,y+1};\n    }\n    for(pii p:v[u]){\n\tif(p.S!=0 && mark[p.F]==0)\n\t    go(p.F,u);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie();\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n\tint N;cin>>N;\n\twhile(N--){\n\t    int x;cin>>x;\n\t    add_edge(--x,i+n);\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tadd_edge(Src,i);\n    }\n    for(int i=n;i<2*n-1;i++){\n\tadd_edge(i,Snk);\n    }\n    int num=flow();\n    if(num!=n-1) return cout<<-1<<endl,0;\n    memset(mark,0,sizeof mark);\n    go(Src);\n    for(int i=0;i<n-1;i++){\n\tif(ans[i].F==0)\n\t    return cout<<-1<<endl,0;\n    }\n    for(int i=0;i<n-1;i++){\n\tcout<<ans[i].F<<\" \"<<ans[i].S<<\"\\n\";\n    }\n}\n\n// Deathly mistakes:\n//  * Read the problem curfully.\n//  * Check maxn.\n//  * Overflows.\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = lis[i - 1], v = pre[u];\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint n;\nstruct data{\n    int to,nxt,c;\n}mp[1000100];\nint head[500500],cnt=1;\nint cur[500500];\nvoid link(int x,int y,int c)\n{\n    mp[++cnt].to=y;\n    mp[cnt].nxt=head[x];\n    mp[cnt].c=c;\n    head[x]=cnt;\n}\nvoid add(int x,int y,int c){link(x,y,c);link(y,x,0);}\nint s,t;\nint dis[500500];\nqueue<int>q;\nbool BFS()\n{\n    for(int i=0;i<=t;++i)dis[i]=0;\n    dis[s]=1;q.push(s);\n    int u,v;\n    while(!q.empty())\n    {\n        u=q.front();q.pop();\n        for(int i=head[u];i;i=mp[i].nxt)\n            if(mp[i].c&&!dis[mp[i].to])\n            {\n                v=mp[i].to;\n                q.push(v);\n                dis[v]=dis[u]+1;\n            }\n    }\n    return dis[t];\n}\nint dfs(int x,int f)\n{\n    if(x==t)return f;\n    int rf=0,fl;\n    for(int& i=cur[x];i;i=mp[i].nxt)\n        if(mp[i].c&&dis[mp[i].to]==dis[x]+1)\n        {\n            fl=dfs(mp[i].to,min(mp[i].c,f));\n            if(fl)\n            {\n                f-=fl;\n                rf+=fl;\n                mp[i].c-=fl;\n                mp[i^1].c+=fl;\n                if(!f)break;\n            }\n        }\n    return rf;\n}\nint Dinic()\n{\n    int maxflow=0,flow;\n    while(BFS())\n    {\n        for(int i=1;i<=t;++i)cur[i]=head[i];\n        while(flow=dfs(s,inf))maxflow+=flow;\n    }\n    return maxflow;\n}\n\nvector<int>bel[100100];\nint par[100100];\nbool book[100100];\nint ed[100100][2],ted;\nvoid solve()\n{\n    int x,v;\n    for(x=2;x<=n;++x)\n    {\n        for(int i=head[x];i;i=mp[i].nxt)\n            if(mp[i].to>n&&mp[i].to<n*2&&!mp[i].c)\n                par[mp[i].to-n]=x;\n    }\n    q.push(1);\n    int siz;\n    while(!q.empty())\n    {\n        x=q.front();q.pop();\n        siz=bel[x].size();\n        for(int i=0;i<siz;++i)\n            if(!book[par[bel[x][i]]])\n            {\n                v=par[bel[x][i]];\n                book[v]=1;\n                q.push(v);\n                ed[bel[x][i]][0]=x;\n                ed[bel[x][i]][1]=v;\n                ted++;\n            }\n    }\n    if(ted!=n-1)puts(\"-1\"),exit(0);\n    for(int i=1;i<n;++i)printf(\"%d %d\\n\",ed[i][0],ed[i][1]);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    s=n*2;t=s+1;\n    int siz,xx;\n    for(int i=1;i<n;++i)\n    {\n        add(i+n,t,1);\n        scanf(\"%d\",&siz);\n        for(int j=1;j<=siz;++j)\n        {\n            scanf(\"%d\",&xx);\n            bel[xx].push_back(i);\n            if(xx!=1) add(xx,i+n,1);\n        }\n    }\n    for(int i=1;i<=n;++i)add(s,i,1);\n    int flow=Dinic();\n    if(flow!=n-1)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//\n//10^5210^5\n//\nnamespace MF{\n\t#define MAXN 252521\n\t#define MAXM 364364//2\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//S\n\t//levS(AOJ2396verify)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//\nbool used[200100];//\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111],u[111111],v[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n)\n\t{\n\t\t::u[pa-n]=gp;\n\t\t::v[pa-n]=u;\n\t}\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=2;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=1;i<n;++i)if(!u[i])return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],pre[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t\tpre[y]=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tflow++;\n\t\t\tfor (int x=T;x!=S;x=e[pre[x]].x){\n\t\t\t\te[pre[x]].cap^=1;\n\t\t\t\te[pre[x]^1].cap^=1;\n\t\t\t}\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5 + 10;\nconst int INF = 1e9;\n\nstruct Edge {\n  int u, v, cap, flow;\n};\n\nnamespace Max_flow {\n\nvector<Edge> E;\nvector<int> G[N];\n\nint S, T, n, d[N];\n\nvoid init(int _n, int _s, int _t) {\n  n = _n, S = _s, T = _t;\n  for (int i = 0; i <= n; i++) G[i].clear();\n  E.clear();\n}\n\nvoid addedge(int u, int v, int cap) {\n  E.push_back((Edge) {u, v, cap, 0});\n  E.push_back((Edge) {v, u, 0, 0});\n  int m = E.size();\n  G[u].push_back(m - 2);\n  G[v].push_back(m - 1);\n}\n\nbool bfs() {\n  for (int i = 0; i <= n; i++) d[i] = 0;\n  d[S] = 1;\n  queue<int> q;\n  q.push(S);\n  while (q.size()) {\n    int u = q.front(); q.pop();\n    for (int i : G[u]) {\n      if (E[i].cap > E[i].flow && !d[E[i].v]) {\n        d[E[i].v] = d[u] + 1;\n        q.push(E[i].v);\n      }\n    }\n  }\n  return d[T];\n}\n\nint dfs(int u, int a) {\n  if (!a || u == T) return a;\n  int flow = 0;\n  for (int i : G[u]) {\n    if (d[E[i].v] != d[u] + 1) continue;\n    int f = dfs(E[i].v, min(E[i].cap - E[i].flow, a));\n    flow += f;\n    a -= f;\n    E[i].flow += f;\n    E[i ^ 1].flow -= f;\n  }\n  if (!flow) d[u] = 0;\n  return flow;\n}\n\nint max_flow() {\n  int flow = 0;\n  while (bfs()) {\n    flow += dfs(S, INF);\n  }\n  return flow;\n}\n\n}\n\nint n, c[N], p[N], q[N], vis[N];\nvector<int> g[N], bel[N];\n\nint main() {\n  scanf(\"%d\", &n);\n  Max_flow::init(2 * n + 1, 0, 2 * n + 1);\n  for (int i = 1; i < n; i++) {\n    scanf(\"%d\", &c[i]);\n    g[i].resize(c[i]);\n    Max_flow::addedge(0, i, 1);\n    for (int j = 0; j < c[i]; j++) {\n      scanf(\"%d\", &g[i][j]);\n      bel[g[i][j]].push_back(i);\n      Max_flow::addedge(i, g[i][j] + n, 1);\n    }\n  }\n  for (int i = 1; i <= n; i++) {\n    Max_flow::addedge(i + n, 2 * n + 1, 1);\n  }\n  if (Max_flow::max_flow() != n - 1) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (Edge e : Max_flow::E) {\n    if (e.u <= n && e.v > n && e.cap == e.flow) {\n      p[e.u] = e.v - n;\n      vis[e.v - n] = 1;\n    }\n  }\n  queue<int> tmp;\n  for (int i = 1; i <= n; i++) {\n    if (!vis[i]) tmp.push(i);\n    vis[i] = 0;\n  }\n  int cnt = 0;\n  while (tmp.size()) {\n    cnt++;\n    int u = tmp.front(); tmp.pop();\n    for (int i : bel[u]) if (!vis[i]) {\n      vis[i] = 1;\n      q[i] = u;\n      tmp.push(p[i]);\n    }\n  }\n  if (cnt != n) {\n    puts(\"-1\");\n    return 0;\n  }\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", p[i], q[i]);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 200000;\nconst int M = N << 4;\n\nint S, T;\n\nstruct edge {\n    int to, nxt, cap;\n};\n\nedge e[M + 5];\nint st[N + 5], ecnt = 1;\n\nvoid addedge(int u, int v, int c) {\n    e[++ ecnt] = (edge) { v, st[u], c }, st[u] = ecnt;\n    e[++ ecnt] = (edge) { u, st[v], 0 }, st[v] = ecnt;\n}\n\nint cur[N + 5], dis[N + 5];\n\nbool bfs() {\n    static int que[N + 5];\n    int head = 0, tail = 0;\n\n    memset(dis, 0xff, sizeof dis);\n    dis[que[tail ++] = S] = 0;\n\n    while(head < tail) {\n        int x = que[head ++];\n        for(int i = st[x]; i; i = e[i].nxt) if(e[i].cap) {\n            int y = e[i].to;\n            if(dis[y] == -1) {\n                dis[y] = dis[x] + 1;\n                que[tail ++] = y;\n            }\n        }\n    }\n    return ~dis[T];\n}\n\nint dfs(int x, int flow) {\n    if(x == T || !flow) {\n        return flow;\n    }\n\n    int res = 0;\n    for(int &i = cur[x]; i; i = e[i].nxt) {\n        int y = e[i].to, aug;\n        if(dis[y] == dis[x] + 1 && (aug = dfs(y, std::min(e[i].cap, flow)))) {\n            res += aug;\n            flow -= aug;\n            e[i].cap -= aug;\n            e[i ^ 1].cap += aug;\n            if(!flow) break;\n        }\n    }\n    return res;\n}\n\nint max_flow() {\n    int ans = 0;\n    while(bfs()) {\n        memcpy(cur, st, sizeof (int) * (T + 1));\n        ans += dfs(S, oo);\n    }\n    return ans;\n}\n\nint n, cnt;\npii ans[N + 5];\nint mat[N + 5];\nbool vis[N + 5];\nvector<int> g[N + 5];\n\nvoid dfs(int u) {\n    for(auto v : g[u]) if(!vis[v]) {\n        ++ cnt;\n        vis[v] = true;\n        ans[v - n] = mp(u, mat[v]);\n        dfs(mat[v]);\n    }\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    S = n << 1, T = S + 1;\n    for(int i = 2; i <= n; ++i) {\n        addedge(S, i, 1);\n    }\n\n    for(int i = 1; i < n; ++i) {\n        static int c, x;\n\n        for(read(c); c--; ) {\n            read(x);\n            g[x].pb(i + n);\n            addedge(x, i + n, 1);\n        }\n        addedge(i + n, T, 1);\n    }\n\n    int mf = max_flow();\n\n    if(mf < n - 1) return !puts(\"-1\");\n\n    for(int i = 2; i <= n; ++i) {\n        for(int j = st[i]; j; j = e[j].nxt) {\n            int t = e[j].to;\n            if(!e[j].cap && t > n && t < 2*n) {\n                mat[t] = i;\n                break;\n            }\n        }\n    }\n\n    dfs(1);\n\n    if(cnt < n - 1) {\n        puts(\"-1\");\n    } else {\n        for(int i = 1; i < n; ++i) {\n            printf(\"%d %d\\n\", ans[i].fst, ans[i].snd);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int i=head[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()) {\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e6, inf = 1e9;\nint n, tot, ter[maxn + 3], wei[maxn + 3], nxt[maxn + 3], lnk[maxn + 3];\nint cur[maxn + 3], dep[maxn + 3], num[maxn + 3], ans[maxn + 3];\nbool vis[maxn + 3];\nvector<int> S[maxn + 3], V[maxn + 3], G[maxn + 3];\n\nint adj(int x) {\n\treturn x & 1 ? x + 1 : x - 1;\n}\n\nint add(int u, int v, int w) {\n\tter[++tot] = v, wei[tot] = w;\n\tnxt[tot] = lnk[u], lnk[u] = tot;\n\treturn tot;\n}\n\nint add_f(int u, int v) {\n\tint t = add(u, v, 1);\n\treturn add(v, u, 0), t;\n}\n\nbool bfs() {\n\tqueue<int> Q;\n\tQ.push(1);\n\tmemset(dep, -1, sizeof(dep));\n\tdep[1] = 0;\n\twhile (!Q.empty()) {\n\t\tint u = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = lnk[u], v, w; i; i = nxt[i]) {\n\t\t\tv = ter[i], w = wei[i];\n\t\t\tif ((~dep[v]) || !w) continue;\n\t\t\tdep[v] = dep[u] + 1;\n\t\t\tQ.push(v);\n\t\t}\n\t}\n\treturn ~dep[n * 2];\n}\n\nint dfs(int u, int t, int lft) {\n\tif (u == t) {\n\t\treturn lft;\n\t}\n\tint ret = 0;\n\tfor (int &i = cur[u], v, w; i && ret < lft; i = nxt[i]) {\n\t\tv = ter[i], w = wei[i];\n\t\tif (w && dep[u] + 1 == dep[v]) {\n\t\t\tint x = dfs(v, t, min(lft - ret, w));\n\t\t\twei[i] -= x, wei[adj(i)] += x, ret += x;\n\t\t}\n\t}\n\tif (ret < lft) {\n\t\tdep[u] = -1;\n\t}\n\treturn ret;\n}\n\nint flow() {\n\tint ret = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur, lnk, sizeof(cur));\n\t\tret += dfs(1, n * 2, inf);\n\t}\n\treturn ret;\n}\n\nvoid dfs(int u) {\n\tvis[u] = true;\n\tfor (int i = 0, v; i < G[u].size(); i++) {\n\t\tv = G[u][i];\n\t\tif (vis[v]) continue;\n\t\tans[v] = u;\n\t\tdfs(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1, m; i <= n - 1; i++) {\n\t\tscanf(\"%d\", &m);\n\t\tS[i].resize(m), V[i].resize(m);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tscanf(\"%d\", &S[i][j]);\n\t\t\tif (S[i][j] != 1) {\n\t\t\t\tV[i][j] = add_f(S[i][j], i + n);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tadd_f(1, i);\n\t}\n\tfor (int i = n + 1; i < n * 2; i++) {\n\t\tadd_f(i, n * 2);\n\t}\n\tif (flow() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint x = 0;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != 1 && !wei[V[i][j]]) {\n\t\t\t\tx = S[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnum[i] = x;\n\t\tfor (int j = 0; j < S[i].size(); j++) {\n\t\t\tif (S[i][j] != x) {\n\t\t\t\tG[S[i][j]].push_back(x);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) {\n\t\t\tputs(\"-1\");\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tprintf(\"%d %d\\n\", ans[num[i]], num[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,\n\t\t\tvi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\n\nvector<vector<int> > g;\nvector<int> btoa;\n\nvector<vector<pair<int,int> > > edges;\nint main(){\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tbtoa.resize(n, -1);\n\tfor(int i = 1; i < n; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tfor(int a = 0; a < c; a++){\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\td--;\n\t\t\tg[i].push_back(d);\n\t\t}\n\t}\n\tg[0].push_back(0);\n\tif(hopcroftKarp(g, btoa) < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> a(n);\n\tvector<int> b(n);\n\tfor(int i = 0; i < n; i++){\n\t\ta[btoa[i]] = i;\n\t}\n\n\tedges.resize(n);\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int r : g[i]){\n\t\t\tedges[r].push_back({a[i], i});\n\t\t}\n\t}\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint s = 0;\n\tvector<int> vis(n, 0);\n\tvis[0] = 1;\n\tint cnt = 1;\n\twhile(s < bfs.size()){\n\t\tint x = bfs[s];\n\t\ts++;\n\t\tfor(auto r : edges[x]){\n\t\t\tif(vis[r.first]) continue;\n\t\t\tvis[r.first] = 1;\n\t\t\tcnt++;\n\t\t\tb[r.second] = x;\n\t\t\tbfs.push_back(r.first);\n\t\t}\n\t}\n\tif(cnt < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tcout << a[i] + 1 << \" \" << b[i] + 1 << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace IO {\n\tconst int SIZE = 1 << 20;\n\tchar buf[SIZE + 10], *iS, *iT;\n\tinline char Getc() {\n\t\treturn iS == iT && (iT = (iS = buf) + fread(buf, 1, SIZE, stdin), iS == iT) ? EOF : *iS++;\n\t}\n\ttemplate <class TT>\n\tinline void Read(TT &x) {\n\t\tx = 0; register char cc = '\\0'; TT fff = 1;\n\t\tfor (; cc < '0' || cc > '9'; cc = Getc())\n\t\t\tif (cc == '-') fff = -1;\n\t\tfor (; cc >= '0' && cc <= '9'; cc = Getc())\n\t\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\t\tx *= fff;\n\t}\n}\nusing IO::Read;\n\nconst int N = 2e5 + 10, M = 1e6 + 10;\n\nvector<int> bel[N];\nvector<pair<int, int> > bufans; int Connect[N]; bool vis[N];\nint n, tot, stp, edp, hd, tl, fans, Q[N + 10], dep[N], Cur[N], Head[N], Next[M], Adj[M], W[M];\n\ninline void Addedge(int x, int y, int z) {\n/*\n\tprintf(\"%d %d %d\\n\", x, y, z);\n*/\n\tNext[++tot] = Head[x]; Head[x] = tot; Adj[tot] = y; W[tot] = z;\n\tNext[++tot] = Head[y]; Head[y] = tot; Adj[tot] = x; W[tot] = 0;\n}\n\ninline bool BFS() {\n\tfill(dep, dep + 1 + edp, -1), hd = tl = 0;\n\tQ[++tl] = stp, dep[stp] = 0;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\tfor (int e = Head[x]; e; e = Next[e])\n\t\t\tif (W[e] > 0 && dep[Adj[e]] == -1) {\n\t\t\t\tdep[Adj[e]] = dep[x] + 1;\n\t\t\t\tQ[++tl] = Adj[e];\n\t\t\t}\n\t}\n\treturn dep[edp] != -1;\n}\n\nint DFS(int x, int mxflow) {\n\tif (x == edp || !mxflow) return mxflow;\n\tfor (int &e = Cur[x]; e; e = Next[e])\n\t\tif (W[e] > 0 && dep[Adj[e]] == dep[x] + 1) {\n\t\t\tint ntflow = DFS(Adj[e], min(mxflow, W[e]));\n\t\t\tif (ntflow > 0) {\n\t\t\t\tW[e] -= ntflow;\n\t\t\t\tW[e ^ 1] += ntflow;\n\t\t\t\treturn ntflow;\n\t\t\t}\n\t\t}\n\treturn 0; /* star! */\n}\n\ninline void Dinic() {\n\tfans = 0;\n\twhile (BFS()) {\n\t\tint nflow = 0;\n\t\tcopy(Head, Head + 1 + edp, Cur);\n\t\twhile ((nflow = DFS(stp, 0x3f3f3f3f)) != 0)\n\t\t\tfans += nflow;\n\t}\n}\n\ninline void Extend(int x) {\n\tfor (int j = 0; j < (int)bel[x].size(); ++j)\n\t\tif (!vis[bel[x][j]]) {\n\t\t\tbufans.push_back(make_pair(x, Connect[bel[x][j]]));\n\t\t\tvis[bel[x][j]] = true, Q[++tl] = Connect[bel[x][j]];\n\t\t}\n}\n\ninline void Solve() {\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int e = Head[n + i]; e; e = Next[e])\n\t\t\tif (Adj[e] <= n && W[e] > 0)\n\t\t\t\tConnect[n + i] = Adj[e];\n\thd = tl = 0;\n\tQ[++tl] = 1;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\tExtend(x);\n\t}\n}\n\nint main()\n{\n\tRead(n), tot = 1 /* !!! */;\n\tstp = 2 * n, edp = 2 * n + 1;\n\tfor (int i = 2; i <= n; ++i) Addedge(stp, i, 1);\n\tfor (int i = 1; i < n; ++i) Addedge(n + i, edp, 1);\n\tfor (int i = 1, ilen; i < n; ++i) {\n\t\tRead(ilen);\n\t\tfor (int j = 1, x; j <= ilen; ++j) {\n\t\t\tRead(x);\n\t\t\tbel[x].push_back(n + i);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i)\n\t\tfor (int j = 0; j < (int)bel[i].size(); ++j /* not i */)\n\t\t\tAddedge(i, bel[i][j], 1);\n\tDinic();\n\tif (fans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tSolve();\n\tif ((int)bufans.size() < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int j = 0; j < (int)bufans.size(); ++j)\n\t\tprintf(\"%d %d\\n\", bufans[j].first, bufans[j].second);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, M = 8e5 + 5;\n\nstruct edge_t { int u, v, next, cap, flow; } G[M];\n\nvector <int> adj[N];\nqueue <int> q;\nint head[N], nowhead[N], d[N];\nint n, m, s, t, tot = 1;\n\ninline void addedge(int u, int v, int cap) {\n\tG[++tot] = (edge_t) {u, v, head[u], cap, 0}, head[u] = tot;\n\tG[++tot] = (edge_t) {v, u, head[v], 0, 0}, head[v] = tot;\n}\n\nint bfs() {\n\tmemset(d, 0, sizeof(d));\n\td[s] = 1; q.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (!d[v] && G[i].cap > G[i].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\n\nint dfs(int u, int Flow) {\n\tif (u == t || !Flow) return Flow;\n\tint f, flow = 0;\n\tfor (int &i = nowhead[u]; i; i = G[i].next) {\n\t\tint v = G[i].v;\n\t\tif (d[v] == d[u] + 1 && (f = dfs(v, min(Flow, G[i].cap - G[i].flow))) > 0) {\n\t\t\tG[i].flow += f; G[i ^ 1].flow -= f;\n\t\t\tflow += f; Flow -= f;\n\t\t\tif (!Flow) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint dinic() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemcpy(nowhead, head, sizeof(nowhead));\n\t\tans += dfs(s, 0x7fffffff);\n\t}\n\treturn ans;\n}\n\nint fa[N], vis[N], match[N], cnt;\n\nint main() {\n\tread(n); s = 0; t = 2 * n;\n\tfor (int i = 1; i < n; i++) {\n\t\tread(m);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x; read(x);\n\t\t\tadj[i].push_back(x + n - 1);\n\t\t\tadj[x + n - 1].push_back(i);\n\t\t\taddedge(i, x + n - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) addedge(s, i, 1);\n\tfor (int i = n; i < 2 * n; i++) addedge(i, t, 1);\n\tif (dinic() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint rt = 0;\n\tfor (int i = head[n * 2]; i; i = G[i].next) {\n\t\tif (G[i].flow == 0) {\n\t\t\trt = G[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int u = 1; u < n; u++) {\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (n <= v && v < n * 2 && G[i].flow) match[u] = v;\n\t\t}\n\t}\n\tq.push(rt); vis[rt] = 1;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (auto v : adj[u]) {\n\t\t\tif (!vis[match[v]]) {\n\t\t\t\tvis[match[v]] = 1;\n\t\t\t\tfa[match[v]] = u;\n\t\t\t\t++cnt;\n\t\t\t\tq.push(match[v]);\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tprint(match[i] - n + 1, ' ');\n\t\tprint(fa[match[i]] - n + 1, '\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nvector<int> E[N],in[N];\nnamespace Graph{\n\tconst int inf = 1e9;\n\tvector<pair<int,int> > ans;\n\tint n,tot,t,head[N],b[N],vis[N],cur[N];\n\tstruct edge{int v,nxt,f;}e[N*2];\n\tvoid init(int m){\n\t\tn=m;t=2*n+1;tot=1;\n\t}\n\tvoid add(int x,int y,int z){\n\t\te[++tot]={y,head[x],z};\n\t\thead[x]=tot;\n\t\te[++tot]={x,head[y],0};\n\t\thead[y]=tot;\n\t}\n\tbool bfs(){\n\t\tmemset(b,0,sizeof(b));b[0]=1;\n\t\tqueue<int> q;q.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&!b[e[i].v]){\n\t\t\t\t\tb[e[i].v]=b[u]+1;\n\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t}\n\t\t}\n\t\treturn b[t];\n\t}\n\tint dfs(int x,int flow){\n\t\tif(!flow||x==t) return flow;\n\t\tint f=flow,tmp;\n\t\tfor(int &i=cur[x];i;i=e[i].nxt)\n\t\t\tif(b[e[i].v]==b[x]+1&&(tmp=dfs(e[i].v,min(e[i].f,f)))){\n\t\t\t\tf-=tmp;e[i].f-=tmp;e[i^1].f+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\treturn flow-f;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tans+=dfs(0,inf);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(int x){\n\t\tvis[x]=1;\n\t\tvector<int> v;\n\t\tfor(int p:in[x])\n\t\t\tfor(int i=head[p+n];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&e[i].v!=t) v.push_back(e[i].v);\n\t\tfor(int p:v) if(!vis[p]){\n\t\t\tans.emplace_back(x,p);\n\t\t\tsolve(p);\n\t\t}\n\t}\n\tvoid print(){\n\t\tif(ans.size()!=n-1){puts(\"-1\");return;}\n\t\tfor(auto&pr:ans)\n\t\t\tprintf(\"%d %d\\n\",pr.first,pr.second);\n\t}\n}\nint n;\nint main(){\n\tread(n);\n\tGraph::init(n);\n\tfor(int i=1;i<n;i++){\n\t\tint k;read(k);\n\t\twhile(k--){\n\t\t\tint x;read(x);\n\t\t\tE[i].push_back(x);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int x:in[i]) Graph::add(i,x+n,1);\n\t\tGraph::add(0,i,1);\n\t}\n\tfor(int i=1;i<n;i++) Graph::add(i+n,Graph::t,1);\n\tif(Graph::Dinic()<n-1){puts(\"-1\");return 0;}\n\tGraph::solve(1);\n\tGraph::print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        ans += dfs(s,t,inf);\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , bel[N] , n;\n\nint main(){\n//\tfreopen(\"in04.txt\",\"r\",stdin);\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1 && e[j].to != 1){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t\tbel[e[j].to] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tq.push(1);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"_-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nint cur;\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v] == cur) {\n        return false;\n    }\n    used[v] = cur;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (p[to] == -1) {\n                p[to] = i;\n                nxt[i] = to;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            ++cur;\n            dfs(i);\n        }\n    }\n    /*for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }*/\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 100010\n#define T n+n+1\n#define add(x,y,z) addedge(x,y,z),addedge(y,x,0)\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nint head[N],tot=1,cur[N],vis[N],dis[N],n,p[N],fa[N],s; vector<int> v[N];\nstruct Edge{int v,next,f,w;}edge[N*10]; queue<int> q;\ninline void addedge(int x,int y,int z){edge[++tot]=Edge{y,head[x],0,z};head[x]=tot;}\ninline int bfs()\n{\tmemset(vis,0,sizeof(vis)); memcpy(cur,head,sizeof(cur)); q.push(0); vis[0]=1;\n\twhile(!q.empty())\n\t{\tint x=q.front(); q.pop();\n\t\tfor(rint i=head[x];i;i=edge[i].next)\n\t\tif(!vis[to]&&edge[i].f<edge[i].w) dis[to]=dis[x]+1,vis[to]=1,q.push(to);\n\t}\n\treturn vis[T];\n}\nint dfs(int x,int res)\n{\tif(x==T||!res) return res; int flow=0,f;\n\tfor(rint &i=cur[x];i;i=edge[i].next)\n\tif(dis[to]==dis[x]+1&&(f=dfs(to,min(res,edge[i].w-edge[i].f))))\n\t{edge[i].f+=f;edge[i^1].f-=f;res-=f;flow+=f;if(!res)break;}\n\treturn flow;\n}\ninline int dinic(){int A=0;while(bfs())A+=dfs(0,INT_MAX);return A;}\nvoid dfs(int x){vis[x]=1;s++;for(auto y:v[x])if(!vis[p[y]])fa[y]=x,dfs(p[y]);}\nint main()\n{\tint m,x; cin>>n; for(rint i=1;i<=n;i++) add(n+i,T,1);\n\tfor(rint i=1;i<n;add(0,i,1),i++)\n\tfor(scanf(\"%d\",&m);m--;){scanf(\"%d\",&x),v[x].push_back(i);if(x!=1)add(i,n+x,1);}\n\tif(dinic()!=n-1) return !printf(\"-1\");\n\tfor(rint j=1;j<n;j++)\n\tfor(rint i=head[j];i;i=edge[i].next) if(n<to&&to<=n+n&&edge[i].f) p[j]=to-n;\n\tdfs(1); if(s!=n) return !printf(\"-1\");\n\tfor(rint i=1;i<n;i++) printf(\"%d %d\\n\",fa[i],p[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define maxn 200010\n#define left _left\n#define right _right\nvector <int> adj[maxn];\nset <int> st[maxn];\nint left[maxn], right[maxn], vis[maxn], n;\n\n\nbool dfs (int v){\n\tif (vis[v]) return 0;\n\tvis[v]=1;\n\tfor (int i=0; i<adj[v].size(); i++){\n\t\tint nt= adj[v][i];\n\t\tif (right[nt]==-1 or dfs(right[nt])){\n\t\t\tright[nt]=v;\n\t\t\tleft[v]=nt;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint match (){\n\tmemset(left, -1, sizeof(left));\n\tmemset(right, -1, sizeof(right));\n\tint res=0;\n\twhile(1){\n\t\tint ok= 0;\n\t\tfor (int i=1; i<=n; i++) vis[i]=0;\n\t\tfor (int i=1; i<=n; i++){\n\t\t\tif (left[i]==-1 and !vis[i] and dfs(i)){\n\t\t\t\tres++;\n\t\t\t\tok=1;\n\t\t\t}\n\t\t}\n\t\tif (!ok) break;\n\t}\n\treturn res;\n}\n\nint par[maxn], tk[maxn];\n\nint U[maxn], V[maxn];\n\nint main(){\n\tint x, y;\n\tcin>>n;\n\tfor (int i=1; i<n; i++){\n\t\tcin>>x;\n\t\twhile (x--){\n\t\t\tcin>>y;\n\t\t\tst[i].insert(y);\n\t\t\tadj[y].push_back(i);\n\n\t\t}\n\t}\n\tif(match()<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tint root;\n\tfor (int i=1; i<=n; i++){\n\t\tif (left[i]==-1) root=i;\n\t}\n\ttk[root]=1;\n\tqueue <int> Q;\n\tmemset(par, -1, sizeof(par));\n\tpar[root]=root;\n\tQ.push(root);\n\tfor (int i=0; i<adj[root].size(); i++){\n\t\tint nst= adj[root][i];\n\t\tst[nst].erase(st[nst].find(root));\n\t}\n\twhile(!Q.empty()){\n\t\tint v= Q.front(), ok=0;\n\t\tfor (int i=0; i<adj[v].size(); i++){\n\t\t\tint nst= adj[v][i], nt= right[nst];\n\t\t\tif (tk[nt]) continue;\n\t\t\tok=1;\n\t\t\tpar[nt]= v;\n\t\t\ttk[nt]=1;\n\t\t\tU[nst]= nt;\n\t\t\tV[nst]= v;\n\t\t\tQ.push(nt);\n\t\t}\n\t\tif (!ok) Q.pop();\n\t}\n\tfor (int i=1; i<=n; i++){\n\t\tif (par[i]<0){\n\t\t\tcout<<-1<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1; i<n; i++) cout<<U[i]<<\" \"<<V[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n \n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n \ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n \n// ========================================================================= //\n \nint main() {\n    ios::sync_with_stdio(false);\n \n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n \n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n \n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n \n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i)) {\n                    was = 1; pv[i] = 1; }\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n \n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n \n    vector<ipair> es(n - 1);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es[s] = {v, nv};\n            ++cnt;\n            dfs(nv);\n        }\n    };\n    dfs(root);\n \n    if (cnt != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma comment(linker, \"/STACK:134217728\")\n\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <memory>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\ntypedef long long Int;\ntypedef pair<int,int> PII;\ntypedef vector<int> VInt;\n\n#define FOR(i, a, b) for(i = (a); i < (b); ++i)\n#define RFOR(i, a, b) for(i = (a) - 1; i >= (b); --i)\n#define CLEAR(a, b) memset(a, b, sizeof(a))\n#define SIZE(a) int((a).size())\n#define ALL(a) (a).begin(),(a).end()\n#define PB push_back\n#define MP make_pair\n\nVInt EV[1 << 18];\nVInt ES[1 << 18];\nint PV[1 << 18];\nint PS[1 << 18];\nint B[1 << 18];\nPII R[1 << 18];\nint gMark;\n\nint dfs(int s)\n{\n\tif (B[s] == gMark) return 0;\n\tB[s] = gMark;\n\tfor (auto it = ES[s].begin(); it != ES[s].end(); ++it)\n\t{\n\t\tif(PV[*it] == -1 || dfs(PV[*it]) != 0)\n\t\t{\n\t\t\tPV[*it] = s;\n\t\t\tPS[s] = *it;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint f(int n)\n{\n\tgMark = 0;\n\tCLEAR(B, -1);\n\tCLEAR(PV, -1);\n\tCLEAR(PS, -1);\n\tint i, j;\n\tFOR(i, 0, n - 1)\n\t\tif(PS[i] == -1)\n\t\t{\n\t\t\t++gMark;\n\t\t\tif (dfs(i) == 0)\n\t\t\t\treturn 0;\n\t\t}\n\n\n\tVInt bv(n, 0);\n\tVInt bs(n, 0);\n\tFOR(i, 0, n)\n\t\tif (PV[i] == -1)\n\t\t\tbreak;\n\n\tbv[i] = 1;\n\tqueue<PII> q;\n\tfor (auto it = EV[i].begin(); it != EV[i].end(); ++it) q.push(PII(i, *it));\n\tFOR(i, 1, n)\n\t{\n\t\twhile (!q.empty() && bs[q.front().second] != 0) q.pop();\n\t\tif (q.empty()) return 0;\n\t\tint v = q.front().first;\n\t\tint s = q.front().second;\n\t\tint w = PS[s];\n\t\tbs[s] = 1;\n\t\tbv[w] = 1;\n\t\tR[s] = PII(v, w);\n\t\tfor (auto it = EV[w].begin(); it != EV[w].end(); ++it) q.push(PII(w, *it));\n\t}\n\n\treturn 1;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tint i, j;\n\tFOR(i, 0, n - 1)\n\t{\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tFOR(j, 0, m)\n\t\t{\n\t\t\tint a;\n\t\t\tscanf(\"%d\", &a);\n\t\t\t--a;\n\t\t\tEV[a].push_back(i);\n\t\t\tES[i].push_back(a);\n\t\t}\n\t}\n\n\tif(f(n) == 0) printf(\"-1\\n\");\n\telse FOR(i, 0, n - 1) printf(\"%d %d\\n\", R[i].first + 1, R[i].second + 1);\n\treturn 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=z,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||!c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    puts(\"-1\");exit(0);\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int INF=0x3f3f3f3f;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\ninline int read() {\n\tint x=0; char ch;\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile('0'<=ch&&ch<='9')x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+2*NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tinline void AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int Aug(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tint sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min(e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tint Flow;\n\tint ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tn=read();\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c,u;i<n;i++) {\n\t\tc=read();\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1;j<=c;j++) {\n\t\t\tu=read();\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e_orig[a].PB(Edge{b, cap, SZ(e_orig[b])});\n    e_orig[b].PB(Edge{a, bi_dir * cap, SZ(e_orig[a]) - 1});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n\n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n    for (int i = 0; i <= n; i++) {\n      dis[i] = n + 1;\n    }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e_orig.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<int> halko;\n    for (auto edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        halko.PB(edge.v - n);\n      }\n    }\n    assert(SZ(halko) == 2);\n    for (auto x : halko) {\n      cout<<x<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\nvector<int> r;\nvector<int> z;\n\nint ccc = 0;\n\nbool dfs(int x) {\n//    cout << x << \"\\n\";\n    if (z[x] == ccc) return false;\n    z[x] = ccc;\n    for (int y : g[x]) {\n        if (r[y] == -1 || dfs(r[y])) {\n            r[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    g.resize(n);\n    r.assign(n, -1);\n    z.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x;\n            x--;\n            g[x].push_back(i);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        std::random_shuffle(g[i].begin(), g[i].end());\n    }\n\n    int ff = -1;\n    for (int i = 0; i < n; i++) {\n        ccc++;\n        bool ok = false;\n        for (int y : g[i]) {\n            if (r[y] == -1) {\n                r[y] = i;\n                ok = true;\n            }\n        }\n        if (!ok) {\n            if (!dfs(i)) {\n                if (ff == -1) {\n                    ff = i;\n                } else {\n                    cout << -1 << \"\\n\";\n                    return 0;\n                }\n            }\n        }\n    }\n\n//    for (int i = 0; i < n - 1; i++) {\n//        cout << r[i] << \"\\n\";\n//    }\n\n    vector<int> q;\n    vector<bool> zz(n);\n    q.push_back(ff);\n    vector<pair<int, int>> res(n - 1);\n    for (int i = 0; i < q.size(); i++) {\n        int x = q[i];\n        for (int c : g[x]) {\n            if (!zz[c]) {\n                zz[c] = true;\n                q.push_back(r[c]);\n                res[c] = {r[c], x};\n            }\n        }\n    }\n\n    if (q.size() < n) {\n        cout << \"-1\\n\";\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            cout << res[i].first + 1 << \" \" << res[i].second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=2147483647;\nstruct Edge\n{\n\tint to;\n\tint next;\n\tint flow;\n}e[1000005];\nint n,m,s,t,edgenum=1,head[1000005],dep[1000005],cur[1000005],match[100005],pa[100005];\nbool flag[100005];\nvector<int>root[100005];\nqueue<int>q;\nvoid add(int u,int v,int f)\n{\n\te[++edgenum].flow=f;\n\te[edgenum].to=v;\n\te[edgenum].next=head[u];\n\thead[u]=edgenum;\n}\nbool bfs()\n{\n\twhile(!q.empty())q.pop();\n\tmemset(dep,0,sizeof(dep));\n\tdep[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int hd=head[node];hd;hd=e[hd].next)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(e[hd].flow==0)continue;\n\t\t\tif(!dep[to])\n\t\t\t{\n\t\t\t\tdep[to]=dep[node]+1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\tif(dep[t])return 1;\n\t}\n\treturn 0;\n}\nint dfs(int node,int nowf)\n{\n\tif(node==t)return nowf;\n\tif(nowf==0)return 0;\n\tfor(int&hd=cur[node];hd;hd=e[hd].next)\n\t{\n\t\tint to=e[hd].to;\n\t\tif(e[hd].flow==0)continue;\n\t\tif(dep[to]==dep[node]+1)\n\t\t{\n\t\t\tint d=dfs(to,min(nowf,e[hd].flow));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te[hd].flow-=d;\n\t\t\t\te[hd^1].flow+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic()\n{\n\tint ans=0,d;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;i++)\n\t\t  cur[i]=head[i];\n\t\twhile(d=dfs(s,INF))\n\t\t  ans+=d;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=1,t=2*n;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tfor(int i=n+1;i<2*n;i++)\n\t{\n\t\tadd(i,t,1);\n\t\tadd(t,i,0);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint size;\n\t\tscanf(\"%d\",&size);\n\t\twhile(size--)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\troot[x].push_back(i);\n\t\t\tx--;\n\t\t\tif(x==0)continue;\n\t\t\tadd(i,x+n,1);\n\t\t\tadd(x+n,i,0);\n\t\t}\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  for(int hd=head[i];hd;hd=e[hd].next)\n\t\tif(e[hd].flow==0)\n\t\t  match[i]=e[hd].to-n+1;\n\twhile(!q.empty())q.pop();\n\tq.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<root[node].size();i++)\n\t\t{\n\t\t\tif(flag[root[node][i]])continue;\n\t\t\tflag[root[node][i]]=1;\n\t\t\tpa[match[root[node][i]]]=node;\n\t\t\tq.push(match[root[node][i]]);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\tif(!pa[i])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  printf(\"%d %d\\n\",pa[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nconst int N = 202020;\n\n// bpm forked from 'https://atcoder.jp/contests/agc029/submissions/3802895'\nstruct bpm{\n\tvector<int> gph[N];\n\tint dis[N], l[N], r[N], vis[N];\n\tvoid clear(){ for(int i=0; i<N; i++) gph[i].clear();\t}\n\tvoid add_edge(int l, int r){ gph[l].push_back(r); }\n\tbool bfs(int n){\n\t\tqueue<int> que;\n\t\tbool ok = 0;\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(l[i] == -1 && !dis[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdis[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &i : gph[x]){\n\t\t\t\tif(r[i] == -1) ok = 1;\n\t\t\t\telse if(!dis[r[i]]){\n\t\t\t\t\tdis[r[i]] = dis[x] + 1;\n\t\t\t\t\tque.push(r[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tbool dfs(int x){\n\t\tif(vis[x]) return 0;\n\t\tvis[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(r[i] == -1 || (!vis[r[i]] && dis[r[i]] == dis[x] + 1 && dfs(r[i]))){\n\t\t\t\tl[x] = i; r[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match(int n){\n\t\tmemset(l, -1, sizeof(l));\n\t\tmemset(r, -1, sizeof(r));\n\t\tint ret = 0;\n\t\twhile(bfs(n)){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tfor(int i=0; i<n; i++) if(l[i] == -1 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool chk[N + N];\n\tvoid rdfs(int x, int n){\n\t\tif(chk[x]) return;\n\t\tchk[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tchk[i + n] = 1;\n\t\t\trdfs(r[i], n);\n\t\t}\n\t}\n\tvector<int> getcover(int n, int m){ // solve min. vertex cover\n\t\tmatch(n);\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor(int i=0; i<n; i++) if(l[i] == -1) rdfs(i, n);\n\t\tvector<int> v;\n\t\tfor(int i=0; i<n; i++) if(!chk[i]) v.push_back(i);\n\t\tfor(int i=n; i<n+m; i++) if(chk[i]) v.push_back(i);\n\t\treturn v;\n\t}\n \n}bpm;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) bpm.add_edge(i, u);\n                }\n        }\n        int cnt = bpm.match(n);\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        vector<bool> used2(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used2[en]) {\n                        used2[en] = true;\n                        ans[en] = make_pair(bpm.l[en], u);\n                        que.push(bpm.l[en]);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=200010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tvector<pair<int,int> >ans;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans.push_back(make_pair(u,link[v]));\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,0,SZ(ans)-1)cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=400010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N],ans[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans[link[v]]=u;\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,1,n-1)cout<<ans[link[i]]<<\" \"<<link[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\tdsu tmp(n);\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching(), res(n-1);\n\tfor(auto [i, x] : matching) {\n\t\t//cout << i << \" \" << x << endl;\n\t\tx -= n-1;\n\t\tfor(auto y : f[i-1]) if(!tmp.con(x-1, y-1)) {\n\t\t\ttmp.unite(x-1, y-1);\n\t\t\tres[i-1] = {x, y};\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a << \" \" << b << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int inf=1000000000;\nint n,m,cnt,id[100001],p[100001],P[100001],hd[200101],cur[200101],dis[200101],q[200101],l,r,K,x,fa[100001],ans,nw;\nstruct node{int to,next,c;}e[1000001];\nvector<int> v[100001];\nbool bo[200101];\n\nint ask(int x) {return fa[x]==x?x:fa[x]=ask(fa[x]);}\nbool cmp(int a,int b) {return v[a].size()<v[b].size();}\n\nvoid addedge(int x,int y,int c) \n{\n\te[++cnt]=(node){y,hd[x],c},hd[x]=cnt;\n\te[++cnt]=(node){x,hd[y],0},hd[y]=cnt;\n}\n\nbool bfs()\n{\n\tfor (int i=1; i<=n+n+1; i++) dis[i]=inf;\n\tq[l=r=1]=1,dis[1]=0,memset(bo,0,sizeof(bo)),bo[1]=1;\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\tif (e[i].c&&!bo[e[i].to]) bo[e[i].to]=1,q[++r]=e[i].to,dis[e[i].to]=dis[x]+1;\n\t\tl++;\n\t}\n\treturn dis[n+n+1]<inf;\n}\n\nbool dinic(int x)\n{\n\tif (x==n+n+1) return 1;\n\tfor (int &i=cur[x]; i; i=e[i].next)\n\t\tif (e[i].c&&dis[e[i].to]==dis[x]+1&&dinic(e[i].to)) \n\t\t\treturn e[i].c--,e[i^1].c++,1;\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),cnt=1;\n\tmemset(hd,0,sizeof(hd));\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&K),v[i].clear(),id[i]=i;\n\t\tfor (int j=1; j<=K; j++) scanf(\"%d\",&x),v[i].push_back(x);\n\t}\n\tsort(id+1,id+n,cmp);\n\tfor (int i=1; i<n; i++) addedge(1,i+1,1);\n\tfor (int i=1; i<=n; i++) addedge(i+n,n+n+1,1);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int siz=v[i].size(),j=0; j<siz; j++) \n\t\t\taddedge(i+1,v[i][j]+n,1);\n\tans=0;\n\twhile (bfs())\n\t{\n\t\tfor (int i=1; i<=n+n+1; i++) cur[i]=hd[i];\n\t\twhile (dinic(1)) ans++;\n\t}\n\tif (ans!=n-1) return puts(\"-1\"),0;\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=hd[i+1]; j; j=e[j].next)\n\t\t\tif (!e[j].c) {p[i]=e[j].to-n; break;}\n\tfor (int i=1; i<=n; i++) fa[i]=i;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tP[id[i]]=0;\n\t\tfor (int j=0,siz=v[id[i]].size(); j<siz; j++)\n\t\t\tif (ask(v[id[i]][j])!=ask(p[id[i]])) {P[id[i]]=v[id[i]][j]; break;}\n\t\tif (!P[id[i]]) return puts(\"-1\"),0;\n\t\tfa[ask(P[id[i]])]=ask(p[id[i]]);\n\t}\n\tfor (int i=1; i<n; i++) printf(\"%d %d\\n\",p[i],P[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n, s, t;\nint hd[400005], nx[1000006], to[1000006], c[1000006], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid fadd(int f, int t, int c) { add(f, t, c), add(t, f, 0); }\n\nint dep[400005];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= t; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i]) {\n            if (!c[i] || dep[v = to[i]]) continue;\n            dep[v] = dep[u] + 1, q.push(v);\n        }\n    }\n    return dep[t];\n}\n\nint iter[400005];\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v, d; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        if (d = dfs(v, min(dist, c[i]))) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= t; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\n\nvector<int> e[400005];\nint p[400005];\nstruct Res {\n    int u, v;\n} res[400005];\nbool get_res() {\n    for (int u = 1; u < n; ++u) {\n        for (int i = hd[u]; i; i = nx[i])\n            if (to[i] != s && c[i] == 0) p[u] = to[i] - n + 1;\n        cerr << \"#\" << u << ' ' << p[u] << endl;\n    }\n\n    int sum = 0;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        ++sum, q.pop();\n        for (int i = 0, v; i < e[u].size(); ++i)\n            if (p[v = e[u][i]]) res[v] = (Res){u, p[v]}, q.push(p[v]), p[v] = 0;\n    }\n    return sum == n;\n}\n\nint main() {\n    n = read(), s = 2 * n - 1, t = 2 * n, cnt = 1;\n    for (int i = 1; i < n; ++i) fadd(i + n - 1, t, 1);\n    for (int i = 1, c, u; i < n; ++i) {\n        c = read(), fadd(s, i, 1);\n        while (c--) {\n            if ((u = read()) != n) fadd(i, u + n - 1, 1);\n            e[u].push_back(i);\n        }\n    }\n    if (Dinic() < n - 1) return puts(\"-1\"), 0;\n    if (!get_res()) return puts(\"-1\"), 0;\n\n    for (int i = 1; i < n; ++i) printf(\"%d %d\\n\", res[i].u, res[i].v);\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]),g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),1;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=5e5+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nint p[N],fa[N];\nint get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}\npii ans[N];\nint la;\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n)fa[i]=i;\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(get(x)!=p[i]){\n                ans[++la]={x,p[i]},fa[p[i]]=x;\n                //printf(\"x=%d\\n\",x);\n                break;\n            }\n        }\n    }\n    if(la<n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tlong long int ans=0;\n\tint B_start=-1;\n\tint B_serch=-1;\n\tfor(int i=0;i<s.size()-1;i++){\n\t\tif(s[i]=='B'){\n\t\t\tB_start=i;\n\t\t\tB_serch=i;\n\t\t\tbreak;\n\t\t}\n\t\t\t\n\t}\n\tif(B_start==-1){\n\t\tcout << \"0\" <<endl;\n\t\treturn 0;\n\t}else{\n\t\tfor(int i=B_serch;i<s.size()-1;i++){\n\t\t\tif(s[i]=='W'){\n\t\t\t\tans+=(i-B_start);\n\t\t\t\tB_start++;\n\t\t\t\tB_serch=i;\n\t\t\t\ts[i]='B';\n\t\t\t\ts[B_start]='W';\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t\treturn 0;\n\t}\n}\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i]);\n    }\n    queue < int > q;\n    q.push(1);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 2; i <= n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 2; i <= n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);h=t=0;q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F> struct dinic {\n    static constexpr F inf = numeric_limits<F>::has_infinity ?\n        numeric_limits<F>::infinity() : numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return make_tuple(res, flow);\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    int src = 0, snk = 2 * N;\n    dinic<int> g(2 * N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        g.arc(src, i, 1);\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        g.arc(N + i, snk, 1);\n\n        int sz, w;\n        cin >> sz;\n        for (int j = 0; j < sz; j++) {\n            cin >> w;\n            g.arc(w, N + i, 1);\n        }\n    }\n\n    auto max_flow = g.max_flow(src, snk);\n    int F = get<0>(max_flow);\n    vi flow = get<1>(max_flow);\n\n    if (F != N - 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int root;\n    for (int e : g.adj[src]) {\n        if (flow[e] == 0) {\n            root = g.dest[e];\n            break;\n        }\n    }\n\n    vi vis(g.V);\n    vis[src] = -1;\n    vis[snk] = -1;\n    vis[root] = root;\n\n    queue<int> bfs({ root });\n    while (!bfs.empty()) {\n        int loc = bfs.front();\n        bfs.pop();\n        for (int e : g.adj[loc]) {\n            if (!vis[g.dest[e]] && (loc > N && flow[e] == -1 || loc <= N && flow[e] == 0)) {\n                vis[g.dest[e]] = loc;\n                bfs.push(g.dest[e]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> res(N - 1);\n    for (int i = 1; i <= N; i++) {\n        if (i == root) continue;\n        if (!vis[i]) { cout << -1 << endl; return 0; }\n        res[vis[i] - N - 1] = { i, vis[vis[i]] };\n    }\n\n    for (auto e : res) {\n        cout << e.first << \" \" << e.second << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int Q=1<<17;\nint link[Q],q[Q],hd=1,tl=0;\nint pt[Q],vis[Q];\nvector<int> g[Q];\nbool Find(int x,int tim)\n{\n\tif(vis[x]==tim)return 0;\n\tvis[x]=tim;\n\tfor(int t=0;t<g[x].size();t++){\n\t\tint y=g[x][t];\n\t\tif((!link[y])||Find(link[y],tim)){\n\t\t\tlink[y]=x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++){\n\t\tint tmp,x;\n\t\tscanf(\"%d\",&tmp);\n\t\twhile(tmp--)scanf(\"%d\",&x),g[x].push_back(i);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t\tif(!Find(i,i))return puts(\"-1\")&0;\n\tq[++tl]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(hd>tl)return puts(\"-1\")&0;\n\t\tint x=q[hd++];\n\t\tfor(int t=0;t<g[x].size();t++){\n\t\t\tint st=g[x][t];\n\t\t\tif(pt[st])continue;\n\t\t\tpt[st]=x;\n\t\t\tq[++tl]=link[st];\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",min(pt[i],link[i]),max(pt[i],link[i]));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_];\nvector<int>A[N_], B[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", A[i][0], A[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[N],maxflow;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],v2[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tfor(int i=0;i<(int)v2[x].size();i++)\n\t{\n\t\tif(vis[v2[x][i]])continue;\n\t\tprintf(\"%d %d\\n\",x,ma[v2[x][i]]);\n\t\tvis[v2[x][i]]=1;\n\t\tdfs(ma[v2[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=2;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[i].push_back(x),v2[x].push_back(i);\n\t\t\tif(x!=1)add(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=2;x<=n;x++)\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz)ma[w[i].to-n]=x;\n\tdfs(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[v-n]=u;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\ntemplate<class V> class MaxFlow_dinic {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 404040;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tvoid bfs(int cur) {\n\t\tMINUS(lev);\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()) {\n\t\t\tint v=q.front(); q.pop();\n\t\t\tITR(e,E[v]) if(e->cap>0 && lev[e->to]<0) lev[e->to]=lev[v]+1, q.push(e->to);\n\t\t}\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tif(from==to) return cf;\n\t\tfor(;itr[from]<E[from].size();itr[from]++) {\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0 && lev[from]<lev[e->to]) {\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0) {\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tZERO(itr);\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl+=tf;\n\t\t}\n\t}\n};\n\nint N;\nvector<int> E[202020];\nvector<int> F[202020];\nint repv[202020];\nMaxFlow_dinic<int> mf;\nint did[303030];\npair<int,int> R[202020];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x;\n\t\tmf.add_edge(0,1+i,1);\n\t\twhile(x--) {\n\t\t\tcin>>y;\n\t\t\tE[i].push_back(y);\n\t\t\tF[y].push_back(i);\n\t\t\tmf.add_edge(1+i,y+101010,1);\n\t\t}\n\t}\n\tfor(i=2;i<=N;i++) mf.add_edge(i+101010,303030,1);\n\t\n\tif(F[1].empty() || mf.maxflow(0,303030)!=N-1) return _P(\"-1\\n\");\n\tfor(i=2;i<=N;i++) {\n\t\tFORR(e,mf.E[i+101010]) if(e.cap && e.to<101010) {\n\t\t\trepv[e.to-1]=i;\n\t\t}\n\t}\n\t\n\tqueue<int> Q;\n\tQ.push(1);\n\twhile(Q.size()) {\n\t\tx=Q.front();\n\t\tQ.pop();\n\t\tFORR(f,F[x]) if(did[f]==0) {\n\t\t\tdid[f]=x;\n\t\t\tR[f].first=x;\n\t\t\tR[f].second=repv[f];\n\t\t\tQ.push(repv[f]);\n\t\t}\n\t}\n\tFOR(i,N-1) cout<<R[i].first<<\" \"<<R[i].second<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo { (t*=10)+=ch-'0'; ch=getchar(); } while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int INF=(1e9);\nconst int maxn=200010;\nint n,m[maxn],s,t,cur[maxn];\nint level[maxn],tot;\nint ans,flow[maxn*4];\nint head[maxn],nxt[maxn*4];\nint to[maxn*4];\nqueue<int> q;\nvector<int> g[maxn];\nvoid Add_edge(int a,int b,int c) {\n\ttot++; nxt[tot]=head[a];\n\thead[a]=tot; to[tot]=b; flow[tot]=c;\n}\nvoid add_edge(int a,int b,int c) {\n\tAdd_edge(a,b,c);\n\tAdd_edge(b,a,0);\n}\nbool bfs() {\n\tq=queue<int>();\n\tmemset(level,-1,sizeof(level));\n\tfor (int i=1;i<=t;i++) cur[i]=head[i];\n\tq.push(s);\n\tlevel[s]=0;\n\twhile (!q.empty()) {\n\t\tint a=q.front(),b; q.pop();\n\t\tfor (register int i=head[a];i;i=nxt[i]) {\n\t\t\tb=to[i];\n\t\t\tif (flow[i]>0&&level[b]==-1) {\n\t\t\t\tlevel[b]=level[a]+1;\n\t\t\t\tq.push(b);\n\t\t\t}\n\t\t}\n\t}\n\treturn level[t]!=-1;\n}\nint dfs(int x,int rest) {\n\tif (x==t) return rest;\n\tint used=0;\n\tfor (register int i=cur[x];i;i=nxt[i]) {\n\t\tcur[x]=i;\n\t\tint y=to[i];\n\t\tif (flow[i]>0&&level[y]==level[x]+1) {\n\t\t\tint tflow=dfs(y,min(flow[i],rest-used));\n\t\t\tused+=tflow;\n\t\t\tflow[i]-=tflow;\n\t\t\tflow[i^1]+=tflow;\n\t\t\tif (rest-used==0) break;\n\t\t}\n\t}\n\tif (!used) level[x]=-1;\n\treturn used;\n}\nbool vis[maxn];\npair<int,int> Ans[maxn];\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (!vis[m[v]]) Ans[v]=make_pair(u,m[v]),dfs(m[v]);\n\t}\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); tot=1;\n\ts=n*2+1,t=n*2+2;\n\tint x,y;\n\tfor (int i=1;i<n;i++) {\n\t\tadd_edge(s,i,1);\n\t\tread(x);\n\t\twhile (x--) {\n\t\t\tread(y);\n\t\t\tg[y].push_back(i);\n\t\t\tif (y>1) add_edge(i,y+n,1);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) add_edge(i+n,t,1);\n\twhile (bfs()) ans+=dfs(s,INF);\n\tif (ans!=n-1) { printf(\"-1\\n\"); return 0; }\n\tfor (int i=1;i<n;i++)\n\tfor (int j=head[i];j;j=nxt[j])\n\t\tif (!flow[j]&&to[j]!=s) {\n\t\t\tm[i]=to[j]-n; break;\n\t\t}\n\tdfs(1);\n\tfor (int i=1;i<n;i++) if (!Ans[i].first) { printf(\"-1\\n\"); return 0; }\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",Ans[i].first,Ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\n\nint main(){\n\tint N;\n\tcin>>N;\n\tVV<int> A(N-1);\n\tVV<int> v2as(N);\n\trep(i,N-1){\n\t\tint K;\n\t\tcin>>K;\n\t\trep(j,K){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tx--;\n\t\t\tA[i].pb(x);\n\t\t\tv2as[x].pb(i);\n\t\t}\n\t}\n\tMaxFlow MF(N-1+N+2);\n\trep(i,N-1){\n\t\tfor(int v:A[i]) MF.add_edge(i,v+N-1,1);\n\t}\n\tint S = N-1+N;\n\tint T = S+1;\n\trep(i,N-1) MF.add_edge(S,i,1);\n\trep(i,N) MF.add_edge(i+N-1,T,1);\n\tint f = MF.max_flow(S,T);\n\tif(f != N-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tV<int> match(N-1);\n\trep(i,N-1){\n\t\tfor(auto e: MF.G[i]) if(N-1 <= e.to && e.to < N-1+N && e.cap == 0){\n\t\t\tmatch[i] = e.to - (N-1);\n\t\t}\n\t}\n\n\t\n\tVV<int> ans(N-1,V<int>(2,-1));\n\trep(i,N-1) ans[i][0] = match[i];\n\n\tint r = 0;\n\trep(i,N) r ^= i;\n\trep(i,N-1) r ^= match[i];\n\tqueue<int> que;\n\tque.push(r);\n\t\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i: v2as[v]) if(ans[i][0] != v && ans[i][1] == -1){\n\t\t\tans[i][1] = v;\n\t\t\tque.push(ans[i][0]);\n\t\t}\n\t}\n\trep(i,N-1) if(ans[i][1] == -1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,N-1) cout<<ans[i][0]+1<<\" \"<<ans[i][1]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint father[N],getsp[N];\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][15];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n//\tif(total2%2==1)\n//\tprintf(\"%d %d %d\\n\",x,y,z);\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n//\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (y>TT) continue;\n\t\t\tif (v[i]>0&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{ \n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (y>TT) continue;\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tif (i==6&&y==11)\n\t\t\t{\n\t\t\t\tT++;T--;\n\t\t\t}\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic(int start)\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(start,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nvoid dfs2(int k,int fa)\n{\n\tfor (int i=head2[k+n];i;i=nexts2[i])\n\t{\n\t\tint y=edge2[i];\n\t\tif (father[y]==0)\n\t\t{\n\t\t\tfather[y]=k;\n\t\t\tdfs2(getsp[y],k);\n\t\t}\n\t}\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic(SS);\n\tif (maxflow==sum)\n\t{\n\t\ttotal1=1;\n\t\tSS=S=0;TT=T=2*n+1;\n\t\tmemset(head,0,sizeof(head));\n\t\tmemset(nexts,0,sizeof(nexts));\n\t\tmemset(edge,0,sizeof(edge));\n\t\tmemset(v,0,sizeof(v));\n\t\ttotal2=1;\n\t\tmemset(head2,0,sizeof(head2));\n\t\tmemset(edge2,0,sizeof(edge2));\n\t\tmemset(nexts2,0,sizeof(nexts2));\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tinsert(SS,i,1);\n\t\t\tinsert(i,SS,0);\n\t\t//\tprintf(\"%d %d %d\\n\",SS,i,1); \n\t\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t\t{\n\t\t\t\tinsert2(s[i][j]+n,i,0,0);\n\t\t\t\tif (s[i][j]==1) continue;\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,s[i][j]+n,1);\n\t\t\t\tinsert(i,s[i][j]+n,1);\n\t\t\t\tinsert(s[i][j]+n,i,0);\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<=n;i++)\n\t\t{\n\t\t\tinsert(i+n,TT,1);\n\t\t\tinsert(TT,i+n,0);\n\t\t//\tprintf(\"%d %d %d\\n\",i+n,TT,1);\n\t\t}\n\t\tmaxflow=re_dinic(SS);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tfor (int j=head[i];j;j=nexts[j])\n\t\t\t{\n\t\t\t\tint y=edge[j];\n\t\t\t//\tprintf(\"%d %d %d\\n\",i,y,v[j^1]);\n\t\t\t\tif (j%2==0&&v[j]==0)\n\t\t\t\t{\n\t\t\t\t\tgetsp[i]=y-n;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tmemset(father,0,sizeof(father));\n\t\t//stotal=0;\n\t\tdfs2(1,0);\n\t\tfor (int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",getsp[i],father[i]);\n\t\t}\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=2*::Maxn,Maxm=4*::Maxn;\n\tint S,T,cnt,h[Maxn],cur[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T||!Maxflow)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int&p=cur[x];p;p=e[p].next){\n\t\t\tif(!Maxflow)break;\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,h,sizeof(h));\n\t\t\tans+=dfs(S,INT_MAX);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\n//struct Edge{int to,next,w;}edges[MAXM];\n//int cnt=1,head[MAXN],cur[MAXN],d[MAXN],S,T;\n//inline void add(int x,int y,int w){\n//\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n//\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n//}inline bool BFS(){\n//\tmemset(d,0,sizeof(d)),d[S]=1;queue<int>q;q.push(S);\n//\tfor(int x;!q.empty();){\n//\t\tx=q.front(),q.pop();\n//\t\tfor(int i=head[x],y;i;i=edges[i].next)\n//\t\t\tif(!d[y=edges[i].to]&&edges[i].w)d[y]=d[x]+1,q.push(y);\n//\t}return d[T];\n//}int DFS(int x,int dist){\n//\tif(x==T||!dist)return dist;int z=0;\n//\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(d[y=edges[i].to]==d[x]+1&&edges[i].w){\n//\t\tk=DFS(y,min(dist,edges[i].w)),edges[i].w-=k,edges[i^1].w+=k,z+=k,dist-=k;\n//\t\tif(!dist)break;\n//\t}return z;\n//}inline int Dinic(){int ans=0;while(BFS())memcpy(cur,head,sizeof(head)),ans+=DFS(S,1e9);return ans;}\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head)),d[S]=1;\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200100;\nstruct T {\n\tint to, nxt, v;\n} way[maxn << 4];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n\tway[++num] = {y, h[x], v}, h[x] = num;\n\tway[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n\tstd::queue<int> q;\n\tfor(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n\tfor(q.push(s), dis[s] = 0;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n\t\t\tdis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n\t}\n\treturn dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n\tif(s == t || !lim) return lim;\n\tint ans = 0, mn;\n\tfor(int & i = head[s];i;i = way[i].nxt)\n\t\tif(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n\t\t\tway[i].v -= mn;\n\t\t\tway[i ^ 1].v += mn;\n\t\t\tans += mn; lim -= mn;\n\t\t\tif(!lim) break;\n\t\t}\n\treturn ans;\n}\ninline int dinic(int s,int t) {\n\tint ans = 0;\n\tfor(;bfs(s,t);) ans += dfs(s,t,1e9);\n\treturn ans;\n}\nint n;\nstd::vector<int> v[maxn];\nstd::vector<int> to[maxn];\nint id[maxn], fa[maxn];\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1,x,a;i < n;++i) {\n\t\tstd::cin >> x, adde(0, i, 1);\n\t\tfor(;x--;) {\n\t\t\tstd::cin >> a, v[i].push_back(a);\n\t\t\tif(a != n) adde(i, a + n, 1);\n\t\t}\n\t}\n\tfor(int i = 1;i < n;++i) adde(i + n,n + n + 1,1);\n\tif(dinic(0,n + n + 1) != n - 1) {\n\t\tstd::cout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i <= n;++i) for(int j = h[i + n];j;j=way[j].nxt) if(way[j].v == 1 && way[j].to < n)\n\t\tid[way[j].to] = i;\n\tfor(int i = 1;i < n;++i) for(int j : v[i])\n\t\tto[j].push_back(id[i]);\n\tstd::queue<int> q; \n\tfor(q.push(n), fa[n] = 1;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i : to[t]) if(!fa[i])\n\t\t\tq.push(i), fa[i] = t;\n\t}\n\tif(std::count(fa + 1,fa + n + 1,0)) {\n\t\tstd::cout << - 1 << '\\n';\n\t} else {\n\t\tfor(int i = 1;i < n;++i) std::cout << fa[i] << ' ' << i << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=1e9;\nint n,S,T,d[200010],ans,a[100010],b[100010];\nvector<int> v[100010];\nint cnt=1,head[200010],to[800010],nxt[800010],w[800010];\nbool used[100010];\nvoid add(int x,int y,int z)\n{\n\tcnt++;\n\tto[cnt]=y;\n\tnxt[cnt]=head[x];\n\thead[x]=cnt;\n\tw[cnt]=z;\n}\nvoid ins(int x,int y,int z)\n{\n\tadd(x,y,z);\n\tadd(y,x,0);\n}\nbool bfs()\n{\n\tfor (int i=S;i<=T;i++)\n\t{\n\t\td[i]=-1;\n\t}\n\tqueue<int> q;\n\td[S]=0;\n\tq.push(S);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tif (x==T)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tif (w[i] && d[y]==-1)\n\t\t\t{\n\t\t\t\td[y]=d[x]+1;\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x,int f)\n{\n\tint res=0;\n\tif (x==T)\n\t{\n\t\treturn f;\n\t}\n\tfor (int i=head[x];i;i=nxt[i])\n\t{\n\t\tint y=to[i];\n\t\tif (w[i] && d[y]==d[x]+1)\n\t\t{\n\t\t\tint tmp=dfs(y,min(f-res,w[i]));\n\t\t\tw[i]-=tmp;\n\t\t\tw[i^1]+=tmp;\n\t\t\tres+=tmp;\n\t\t\tif (res==f)\n\t\t\t{\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\t}\n\tif (!res)\n\t{\n\t\td[x]=-1;\n\t}\n\treturn res;\n}\nvoid dinic()\n{\n\twhile (bfs())\n\t{\n\t\tans+=dfs(S,inf);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tS=1;\n\tT=2*n;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tif (x!=1)\n\t\t\t{\n\t\t\t\tins(x,n+i,1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tins(S,i,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tins(n+i,T,1);\n\t}\n\tdinic();\n\tif (ans!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=n+1;i<2*n;i++)\n\t{\n\t\tfor (int j=head[i];j;j=nxt[j])\n\t\t{\n\t\t\tif (!w[j])\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i-n]=to[j];\n\t\t}\n\t}\n\tqueue<int> q;\n\tused[1]=true;\n\tq.push(1);\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor (int i=0;i<v[x].size();i++)\n\t\t{\n\t\t\tint y=v[x][i];\n\t\t\tif (!used[a[y]])\n\t\t\t{\n\t\t\t\tused[a[y]]=true;\n\t\t\t\tq.push(a[y]);\n\t\t\t\tb[y]=x;\n\t\t\t}\n\t\t}\n\t}\n\tbool f=true;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tf&=used[i];\n\t}\n\tif (!f)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",a[i],b[i]);\n\t}\n\treturn 0;\n}\n//\n//"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nvector<pair<int,int> > Ans;\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tAns.push_back(make_pair(u,ma[s]));\n\t\t}\n\t}\n\tif((int)Ans.size()!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=0;i<n-1;i++)\n\t\tprintf(\"%d %d\\n\",Ans[i].first,Ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nnamespace DinicFlows {\n\ttypedef long long LL;\n\tconst LL Inf = 0x3f3f3f3f3f3f3f3f;\n\tconst int MN = 200005, MM = 400005;\n\t\n\tint N, S, T;\n\tint h[MN], iter[MN], nxt[MM * 2], to[MM * 2], tot; LL w[MM * 2];\n\t\n\tinline void SetST(int, int);\n\tinline void Init(int _N) {\n\t\tN = _N, tot = 1;\n\t\tfor (int i = 1; i <= N; ++i) h[i] = 0;\n\t\tSetST(_N - 1, _N);\n\t}\n\tinline void SetST(int _S, int _T) { S = _S, T = _T; }\n\t\n\tinline void ins(int u, int v, LL x) { nxt[++tot] = h[u], to[tot] = v, w[tot] = x, h[u] = tot; }\n\tinline void insw(int u, int v, LL w1 = Inf, LL w2 = 0) {\n\t\tif (!u) u = S; if (!v) v = T;\n\t\tins(u, v, w1), ins(v, u, w2);\n\t}\n\t\n\tint lv[MN], que[MN], l, r;\n\t\n\tinline bool Lvl() {\n\t\tfor (int i = 1; i <= N; ++i) lv[i] = 0;\n\t\tlv[S] = 1;\n\t\tque[l = r = 1] = S;\n\t\twhile (l <= r) {\n\t\t\tint u = que[l++];\n\t\t\tfor (int i = h[u]; i; i = nxt[i])\n\t\t\t\tif (w[i] && !lv[to[i]]) {\n\t\t\t\t\tlv[to[i]] = lv[u] + 1;\n\t\t\t\t\tque[++r] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn lv[T] != 0;\n\t}\n\t\n\tLL Flow(int u, LL f) {\n\t\tif (u == T) return f;\n\t\tLL d = 0, s = 0;\n\t\tfor (int &i = iter[u]; i; i = nxt[i])\n\t\t\tif (w[i] && lv[to[i]] == lv[u] + 1) {\n\t\t\t\td = Flow(to[i], std::min(f, w[i]));\n\t\t\t\tf -= d, s += d;\n\t\t\t\tw[i] -= d, w[i ^ 1] += d;\n\t\t\t\tif (!f) break;\n\t\t\t}\n\t\treturn s;\n\t}\n\t\n\tinline LL Dinic() {\n\t\tLL Ans = 0;\n\t\twhile (Lvl()) {\n\t\t\tfor (int i = 1; i <= N; ++i) iter[i] = h[i];\n\t\t\tAns += Flow(S, Inf);\n\t\t}\n\t\treturn Ans;\n\t}\n}\nusing DinicFlows::h;\nusing DinicFlows::to;\nusing DinicFlows::nxt;\nusing DinicFlows::w;\nusing DinicFlows::insw;\n\nconst int MN = 100005;\n\nint N, mch[MN], vis[MN];\nint eu[MN], ev[MN], M;\n\nvoid DFS(int u) {\n\tfor (int j = h[u]; j; j = nxt[j]) {\n\t\tif (to[j] == N + N || vis[to[j] - N]) continue;\n\t\tvis[to[j] - N] = 1;\n\t\tfor (int k = h[to[j]]; k; k = nxt[k]) if(w[k])\n\t\t\teu[++M] = u, ev[M] = to[k], DFS(to[k]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tDinicFlows::Init(N + N + 1);\n\tfor (int i = 1; i <= N; ++i) insw(0, i, 1);\n\tfor (int i = 1, c, x; i < N; ++i) {\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) scanf(\"%d\", &x), insw(x, N + i, 1);\n\t\tinsw(N + i, 0, 1);\n\t}\n\tif (DinicFlows::Dinic() != N - 1) return puts(\"-1\"), 0;\n\tint Root = 0;\n\tfor (int i = h[N + N]; i; i = nxt[i]) if (w[i]) Root = to[i];\n\tDFS(Root);\n\tif (M != N - 1) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < N; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) {\n\t\t\t\twrite(i), putchar(' ');\n\t\t\t\twrite(par[par[i]]), putchar('\\n');\n\t\t\t} \n\t\t}\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 1000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//fuck my life I'm such a miserable retard\n//fuck my life it's past midnight\n//fuck my life I don't usually stay up this late\n//fuck my life it's all just because I can't solve this problem\n//fuck my life I don't think it's that hard\n//fuck my life I'm just being stupid\n//fuck my life I hope I get AC with this shit\n//fuck my life I cant prove it\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\nusing namespace std;\nusing ll = long long;\nconst int maxn = 10100, mod = 1e9 + 7, inf = 1<<30;\ntemplate<typename T, int dir>\nstruct dinic {\n\tstruct edge {\n\t\tint from, to;\n\t\tT r, c;\n\t\tedge(int from, int to, T c) : from(from), to(to), r(0), c(c) {}\n\t};\n\tvector<edge> e;\n\tvector<vector<int>> g;\n\tvector<int> h, pos;\n\tint n, s, t;\n\tdinic(int n, int s, int t) : n(n), s(s), t(t) {\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int u, int v, T c) {\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, c));\n\t\tswap(u, v);\n\t\tg[u].push_back(e.size());\n\t\te.push_back(edge(u, v, dir?0:c));\n\t}\n\tbool bfs() {\n\t\th.assign(n, -1);\n\t\th[t] = 0;\n\t\tqueue<int> q;\n\t\tfor(q.push(t); !q.empty(); q.pop()) {\n\t\t\tint u = q.front();\n\t\t\tfor(auto i : g[u]) if(int v = e[i].to; h[v] == -1 && e[i^1].c - e[i^1].r > 0) {\n\t\t\t\th[v] = h[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t\treturn h[s] != -1;\n\t}\n\tT dfs(int v, T cap = inf) {\n\t\tif(v == t) return cap;\n\t\tfor(int &xi = pos[v]; xi < g[v].size(); xi++) {\n\t\t\tint x = g[v][xi];\n\t\t\tint i = e[x].to;\n\t\t\tif(h[v]-h[i] != 1 || e[x].c-e[x].r <= 0) continue;\n\t\t\tT f = dfs(i, min(cap, e[x].c-e[x].r));\n\t\t\tif(!f) continue;\n\t\t\te[x].r += f;\n\t\t\te[x^1].r -= f;\n\t\t\treturn f;\n\t\t}\n\t\treturn 0;\n\t}\n\tT findflow() {\n\t\tT flow = 0, c;\n\t\twhile(bfs()) {\n\t\t\tpos.assign(n, 0);\n\t\t\twhile(c = dfs(s)) flow += c;\n\t\t}\n\t\treturn flow;\n\t}\n\tvector<array<int, 2>> getmatching() {\n\t\tvector<array<int, 2>> matching;\n\t\tfor(auto i : e) {\n\t\t\tif(i.from == s || i.to == t || i.r != 1) continue;\n\t\t\tmatching.push_back({i.from, i.to});\n\t\t}\n\t\treturn matching;\n\t}\n};\nstruct dsu {\n\tvector<int> r, p;\n\tdsu(int n) : r(n, 1), p(n) { iota(all(p), 0); }\n\tvoid unite(int i, int j) {\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return;\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tp[j] = i;\n\t\tr[i] += r[j];\n\t}\n\tint con(int i, int j) {\n\t\treturn par(i) == par(j);\n\t}\n\tint par(int i) {\n\t\treturn i != p[i] ? p[i] = par(p[i]) : i;\n\t}\n};\nint n;\nvector<int> vis, deg, match, lmatch;\nvector<array<int, 2>> res;\nvector<int> adj[1<<17];\ndsu tmp(0);\nvoid process(int v) {\n\tvis[v] = 1;\n\tfor(auto u : adj[v]) if(match[u] != -1 && !vis[match[u]]) {\n\t\ttmp.unite(match[u], v);\n\t\tres[u] = {match[u], v};\n\t\tprocess(match[u]);\n\t}\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tvector<vector<int>> f(n-1);\n\tint s = n+1;\n\ttmp = (n);\n\tdeg = vector<int>(n);\n\tmatch.resize(n, -1);\n\tlmatch.resize(n, -1);\n\tvis.resize(n);\n\tint kk = 0;\n\tfor(auto &i : f) {\n\t\tint t;cin >> t;\n\t\ts += t;\n\t\ti.resize(t);\n\t\tfor(auto &j : i) cin >> j, assert(j-1 < n), deg[j-1]++, adj[j-1].push_back(kk);\n\t\tkk++;\n\t}\n\tdinic<int, 1> d(s, 0, s-1);\n\tmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\tfor(int i = 1; i < n; i++) {\n\t\td.add_edge(0, i, 1);\n\t\tfor(auto j : f[i-1]) {\n\t\t\td.add_edge(i, n - 1 + j, 1);\n\t\t}\n\t}\n\tfor(int i = n; i < 2*n; i++) d.add_edge(i, s - 1, 1);\n\tif(d.findflow() != n-1) return cout << -1, 0;\n\tvector<array<int, 2>> matching = d.getmatching();\n\tres.resize(n-1);\n\tset<int> q;\n\tfor(int i = 0; i < n; i++) q.insert(i);\n\tfor(auto [i, x] : matching) {\n\t\tmatch[i-1] = x-n;\n\t\tlmatch[x-n] = i-1;\n\t\tq.erase(match[i-1]);\n\t}\n\tprocess(*q.begin());\n\tif(tmp.r[tmp.par(0)] != n) return cout << -1, 0;\n\tfor(auto [a, b] : res) cout << a+1 << \" \" << b+1 << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 202000, M = 1020000, inf = 0x3f3f3f3f;\nint n,m,S,T,head[N],to[M],nxt[M],cap[M],edgenum=1;\nVi a[N],b[N];\nvoid addedge(int u, int v, int c){\n\tto[++edgenum]=v;cap[edgenum]=c;\n\tnxt[edgenum]=head[u];head[u]=edgenum;\n}\ninline void add(int u, int v, int c){addedge(u,v,c);addedge(v,u,0);}\nint q[N],dis[N],cur[N],match[N],ans[N];\ninline bool bfs(){\n\tmemset(dis,inf,4*(T+2));dis[T]=0;\n\tint f=0,r=1;q[f]=T;\n\twhile(f!=r){\n\t\tint u=q[f++];\n\t\tL(i,u)if(cap[i^1]&&dis[to[i]]==inf){\n\t\t\tdis[to[i]]=dis[u]+1;q[r++]=to[i];if(to[i]==S)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(int u, int flow){\n\tif(u==T||!flow)return flow;\n\tint res=0;\n\tfor(register int &i=cur[u];i;i=nxt[i])if(cap[i]&&dis[u]==dis[to[i]]+1){\n\t\tint tmp=dfs(to[i],min(flow,cap[i]));\n\t\tres+=tmp;flow-=tmp;cap[i]-=tmp;cap[i^1]+=tmp;if(!flow)break;\n\t}\n\treturn res;\n}\ninline int dinic(){\n\tint res=0;\n\twhile(bfs()){\n\t\tmemcpy(cur,head,4*(T+2));res+=dfs(S,inf);\n\t}\n\treturn res;\n}\nvoid GG(){puts(\"-1\");exit(0);}\nbool vis[N];\nvoid solve(){\n\tvis[1]=1;int f=0,r=1;q[f]=1;\n\twhile(f!=r){\n\t\tint u=q[f++];\n\t\trep(t,0,SZ(b[u])-1)if(!vis[match[b[u][t]]]){\n\t\t\tans[b[u][t]]=u;vis[match[b[u][t]]]=1;q[r++]=match[b[u][t]];\n\t\t}\n\t}\n}\nint main() {\n\tread(n);S=2*n+1;T=S+1;\n\trep(i,1,n-1){\n\t\tadd(S,n+i,1);\n\t\tint l;read(l);rep(j,1,l){\n\t\t\tint x;read(x);a[i].pb(x);if(x>1)add(n+i,x,1);\n\t\t\tb[x].pb(i);\n\t\t}\n\t}\n\trep(i,2,n)add(i,T,1);if(dinic()!=n-1)GG();\n\trep(u,1,n-1)L(i,n+u)if(!cap[i]&&to[i]>=2&&to[i]<=n)match[u]=to[i];\n\tsolve();\n\trep(i,1,n)if(!vis[i])GG();\n\trep(i,1,n-1)printf(\"%d %d\\n\",match[i],ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num,ans[N];\nconst int inf=0x3f3f3f3f;\nvector<int>v[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1,ans[v[x][i]]=x;\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&n+1<=w[i].to&&w[i].to<=n+n-1)\n\t\t\t\tma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",ans[i],ma[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, hed[N + N], to[N + N], nxt[N + N], val[N + N];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = hed[u]; i; i = nxt[i])\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = hed[u]; i; i = nxt[i])\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\treturn 0;\n}\nint Dinic() {\n\tint flow = 0;\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n;\n\trep(i, 1, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != 1) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tif(Dinic() != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(1);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; bl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) {\n\t\t\tif(!vis[bl[v]]) {\n\t\t\t\tvis[bl[v]] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t\t}\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 400050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn];\nint cur[maxn];\n\nqueue<int> q;\n\nbool bfs()\n{\n    memset(d,0x3f,sizeof(d));\n    d[vs]=1;\n    q.push(vs);\n    while (!q.empty())\n    {\n        int i=q.front();    q.pop();\n        for (int k=head[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (!cost[k]||d[j]<=d[i]+1)   continue;\n            d[j]=d[i]+1;\n            q.push(j);\n        }\n    }\n    return d[vt]<=vt;\n}\n\nint dfs(int i,int f)\n{\n    // cout<<\"dfs:\"<<i<<\"(\"<<d[i]<<\")\"<<f<<endl;\n    if (i==vt)  return f;\n    int tf=0;\n    for (int &k=cur[i];~k;k=nxt[k])\n    {\n        int j=edge[k];\n        if (!cost[k]||d[j]!=d[i]+1) continue;\n        int t=dfs(j,1);\n        cost[k]-=t,cost[k^1]+=t;\n        f-=t,tf+=t;\n        if (!f) break;\n    }\n    return tf;\n}\n\nint isap()\n{\n    int ans=0;\n    while (bfs())\n    {\n        for (int i=1;i<=vt;++i)\n            cur[i]=head[i];\n        ans+=dfs(vs,maxn);\n    }\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nbool init(){\n\tqueue<int> Q;\n\tmemset(d,0,sizeof d);\n\td[s]=1;Q.push(s);\n\twhile(!Q.empty()){\n\t\tint x=Q.front();Q.pop();\n\t\tcur[x]=fr[x];\n\t\tfor(int i=fr[x];i;i=nex[i])if(wi[i]&&!d[vi[i]]){\n\t\t\td[vi[i]]=d[x]+1;Q.push(vi[i]);\n\t\t}\n\t}\n\treturn d[t]!=0;\n}\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]+1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}return fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;;\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(init())res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201000;\n\nint chosen[N];\n\nnamespace MF {\n  struct Edge {\n    int v, flow, ne;\n  }e[N << 3];\n\n  int fi[N], tot, S, T, V, cur[N], dis[N], q[N];\n\n  void Init(int s, int t, int v) {\n    S = s; T = t; V = v;\n    tot = 1;\n    for(int i = 0; i < V; i++) {\n      fi[i] = 0;\n    }\n  }\n\n  void Add(int x, int y, int w) {\n    e[++tot] = {y, w, fi[x]};\n    fi[x] = tot;\n    e[++tot] = {x, 0, fi[y]};\n    fi[y] = tot;\n  }\n  \n  bool Bfs(void) {\n    for(int i = 0; i < V; i++) {\n      dis[i] = 0;\n    }\n    int h = 1, t = 0;\n    q[++t] = S;\n    dis[S] = 1;\n    while(h <= t) {\n      int x = q[h++];\n      for(int i = fi[x]; i; i = e[i].ne) {\n\tif(e[i].flow && !dis[e[i].v]) {\n\t  dis[e[i].v] = dis[x] + 1;\n\t  q[++t] = e[i].v;\n\t}\n      }\n    }\n    return dis[T];\n  }\n\n  int Dfs(int x, int f) {\n    if(x == T) {\n      return f;\n    }\n    int used = 0;\n    for(int &i = cur[x]; i; i = e[i].ne) {\n      if(e[i].flow && dis[e[i].v] == dis[x] + 1) {\n\tint t = Dfs(e[i].v, min(f - used, e[i].flow));\n\tused += t;\n\te[i].flow -= t;\n\te[i ^ 1].flow += t;\n\tif(used == f) {\n\t  return used;\n\t}\n      }\n    }\n    dis[x] = -1;\n    return used;\n  }\n\n  int Solve(void) {\n    int ans = 0;\n    while(Bfs()) {\n      for(int i = 0; i < V; i++) {\n\tcur[i] = fi[i];\n      }\n      ans += Dfs(S, 1e9);\n    }\n    for(int i = 1; i < (V >> 1); i++) {\n      for(int j = fi[i]; j; j = e[j].ne) {\n\tif(!e[j].flow) {\n\t  ::chosen[i] = e[j].v - (V >> 1) + 1;\n\t}\n      }\n    }\n    return ans;\n  }\n}\n\nint n, q[N], full[N];\npair<int, int> ans[N];\nvector<int> in[N];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  MF::Init(0, n << 1 ^ 3, n << 1);\n  for(int i = 1, k; i < n; i++) {\n    scanf(\"%d\", &k);\n    for(int j = 0, x; j < k; j++) {\n      scanf(\"%d\", &x);\n      x--;\n      if(x) {\n\tMF::Add(i, x + n - 1, 1);\n      }\n      in[x].push_back(i);\n    }\n  }\n  for(int i = 1; i < n; i++) {\n    MF::Add(MF::S, i, 1);\n    MF::Add(i + n - 1, MF::T, 1);\n  }\n  if(MF::Solve() < n - 1) {\n    return puts(\"-1\"), 0;\n  }\n  int h = 1, t = 0;\n  q[++t] = 0;\n  while(h <= t) {\n    int x = q[h++];\n    for(int y : in[x]) {\n      if(full[y]) {\n\tcontinue;\n      }\n      full[y] = 1;\n      q[++t] = chosen[y];\n      ans[y] = {x, chosen[y]};\n    }\n  }\n  if(t < n) {\n    puts(\"-1\");\n  } else {\n    for(int i = 1; i < n; i++) {\n      printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ui unsigned int\n#define ull unsigned long long\n#define db long double\n#define pii pair<ll,int>\n#define X first\n#define Y second\n#define mp make_pair\n#define pb push_back\n#define vi vector<int>\n#define vii vector<vi>\n#define lb lower_bound\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define per(i,b,a) for(int i=(b);i>=(a);--i)\n#define rep0(i,a,b) for(int i=(a);i<(b);++i)\n#define fore(i,a) for(int i=0;i<a.size();++i)\n#define gc() getchar()\n#define ls x<<1,l,m\n#define rs x<<1|1,m+1,r\ninline ll rd()\n{\n\tll x=0;char c=gc();while(!isdigit(c))c=gc();\n\twhile(isdigit(c))x=x*10+c-48,c=gc();return x;\n}\nconst int N=200005,inf=1e9+7;\nint n,S,T,tt,cc,nn,hd[N],q[N],d[N],iter[N],a[N],vis[N];pii ans[N];\nstruct E{int v,nxt,w;}e[N*8];\ninline void add(int u,int v,int w){e[++cc]=(E){v,hd[u],w};hd[u]=cc;e[++cc]=(E){u,hd[v],0};hd[v]=cc;}\ninline bool bfs(int S)\n{\n\trep(i,1,tt)d[i]=inf,iter[i]=hd[i];\n\tint ql=0,qr=0;q[++qr]=S;d[S]=0;\n\twhile(ql<qr)\n\t{\n\t\tint x=q[++ql];\n\t\tfor(int i=hd[x],y;i;i=e[i].nxt)if(e[i].w&&d[y=e[i].v]==inf){d[y]=d[x]+1;q[++qr]=y;}\n\t} \n\treturn d[T]<inf;\n}\nint dfs(int x,int f)\n{\n\tif(x==T||!f)return f;int sf=0;\n\tfor(int&i=iter[x];i;i=e[i].nxt)if(e[i].w&&d[e[i].v]==d[x]+1)\n\t{\n\t\tint w=dfs(e[i].v,min(f,e[i].w));\n\t\tif(w)\n\t\t{\n\t\t\te[i].w-=w;e[i^1].w+=w;\n\t\t\tf-=w;sf+=w;if(!f)break;\n\t\t}\n\t} \n\treturn sf;\n}\nvoid dfs(int x)\n{\n\tfor(int i=hd[x];i;i=e[i].nxt)if(e[i].v!=S&&!vis[e[i].v-n])\n\t{\n\t\tnn++;int t=e[i].v-n;vis[t]=1;\n\t\tans[t]=mp(x,a[t]);dfs(a[t]);\n\t} \n}\nint main()\n{\n\tn=rd();S=n+n;T=n+n+1;tt=T;cc=1;\n\trep(i,1,n-1)\n\t{\n\t\tint m=rd();\n\t\trep(j,1,m)add(rd(),n+i,1);\n\t\tadd(S,i+1,1);add(n+i,T,1);\n\t}\n\tint f=0;\n\twhile(bfs(S))f+=dfs(S,inf);\n\tif(f!=n-1){puts(\"-1\");return 0;}\n\tfor(int i=n+1;i<n+n;i++)for(int j=hd[i];j;j=e[j].nxt)if(e[j].w&&e[j].v<=n)a[i-n]=e[j].v;\n\tdfs(1);\n\tif(nn<n-1){puts(\"-1\");return 0;}\n\trep(i,1,n-1)printf(\"%d %d\\n\",ans[i].X,ans[i].Y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\t//dmp(s);\n\t\tfor(auto t:adj[s]){\n\t\t\tif(t.fs<=0)return;\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\ta[t.sc]=t.fs;\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\nfor(int i=1;i<=n-1;i++){\n\tmatch[btoa[i]]=i;\n}\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\t//match[btoa[i]]=i;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({match[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\n//dmp(sum);\n//assert(sum>=n);\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << a[i] << \" \" << b[i] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct vertex {\n\tint estart;\n\tint ecur;\n\tint dist;\n} v[300003];\nstruct edge {\n\tint enext,to;\n\tint cap;\n} e[1000003];int en;\nvoid addedge(int a,int b,int cap)\n{\n\te[en].enext = v[a].estart;e[en].to = b;e[en].cap = cap;v[a].estart = en++;\n\te[en].enext = v[b].estart;e[en].to = a;e[en].cap = 0;v[b].estart = en++;\n}\nint start, end;\nint dfs(int i,int cap)\n{\n\tif(i == end) return cap;\n\tint flow = 0;\n\tfor(int &j = v[i].ecur;j != -1;j = e[j].enext) {\n\t\tint to = e[j].to;\n\t\tif(e[j].cap == 0 || v[to].dist != v[i].dist + 1) continue;\n\t\tint val = dfs(to,std::min(cap,e[j].cap));\n\t\tflow += val;cap -= val;e[j].cap -= val;e[j^1].cap += val;\n\t\tif(cap == 0) break;\n\t}\n\treturn flow;\n}\nint n,m;\nstruct vertex2 {\n\tstd::vector<int> inset;\n\tbool vis;\n} v2[100003];\nstd::vector<std::pair<int,int> > ans;\nint match[100003];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < 2*n+1;++i) {\n\t\tv[i].estart = -1;\n\t}\n\tstart = 2*n-1, end = 2*n;\n\t// root = 0\n\tfor(int i = 1;i < n;++i) {\n\t\taddedge(start,i,1);\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j = 0;j < c;++j) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);--k;\n\t\t\tv2[k].inset.push_back(i);\n\t\t\tif(k != 0) addedge(k,n+i,1);\n\t\t}\n\t\taddedge(n+i,end,1);\n\t}\n\tint flow = 0;\n\tfor(;;) {\n\t\tfor(int i = 0;i < 2*n+1;++i) {\n\t\t\tv[i].dist = -1;\n\t\t\tv[i].ecur = v[i].estart;\n\t\t}\n\t\tv[start].dist = 0;\n\t\tstd::queue<int> q;\n\t\tq.push(start);\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = v[cur].estart;j != -1;j = e[j].enext) {\n\t\t\t\tif(e[j].cap == 0) continue;\n\t\t\t\tint to = e[j].to;\n\t\t\t\tif(v[to].dist == -1) {\n\t\t\t\t\tv[to].dist = v[cur].dist + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v[end].dist == -1) break;\n\t\tflow += dfs(start,999999);\n\t}\n\tif(flow != n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint x = n+i;\n\t\tmatch[i] = -1;\n\t\tfor(int j = v[x].estart;j != -1;j = e[j].enext) {\n\t\t\tif(e[j].to >= 1 && e[j].to < n && e[j].cap == 1) {\n\t\t\t\tmatch[i] = e[j].to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(match[i] != -1);\n\t}\n\t\n\t{\n\t\tstd::queue<int> q;\n\t\tq.push(0);v2[0].vis = true;\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = 0;j < v2[cur].inset.size();++j) {\n\t\t\t\tint to = v2[cur].inset[j];\n\t\t\t\tif(!v2[match[to]].vis) {\n\t\t\t\t\tans.emplace_back(cur,match[to]);\n\t\t\t\t\tv2[match[to]].vis = true;\n\t\t\t\t\tq.push(match[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ans.size() == n-1) {\n\t\t\tfor(int i = 0;i < n-1;++i) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t\t} else {\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// #undef DEBUG\n// #define DEBUG\n// DEBUG {{{\n#include <array>\n#include <deque>\n#include <iostream>\n#include <list>\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <valarray>\n#include <vector>\n// clang-format off\ntemplate<int n, class...T> typename enable_if<(n>=sizeof...(T))>::type _ot(ostream &, tuple<T...> const &){}\ntemplate<int n, class...T> typename enable_if<(n< sizeof...(T))>::type _ot(ostream & os, tuple<T...> const & t){ os << (n==0?\"\":\", \") << get<n>(t); _ot<n+1>(os, t); }\ntemplate<class...T> ostream & operator<<(ostream &o, tuple<T...> const &t){ o << \"(\"; _ot<0>(o, t); o << \")\"; return o; }\ntemplate<class T, class U> ostream & operator<<(ostream &o, pair<T, U> const &p) { o << \"(\" << p.first << \", \" << p.second << \")\"; return o; }\ntemplate < class T > ostream &operator<<(ostream &o, const stack<T> &a) { o << \"{\"; for(auto tmp = a; tmp.size(); tmp.pop()) o << (a.size() == tmp.size() ? \"\" : \", \") << tmp.top(); o << \"}\"; return o; }\ntemplate <class T, class Container, class Compare > ostream &operator<<(ostream &os, priority_queue<T, Container, Compare> a) { os << \"{ (top) \"; while(a.size()) os << a.top() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\ntemplate <class T, class Container > ostream &operator<<(ostream &os, queue<T, Container> a) { os << \"{ \"; while(a.size()) os << a.front() << (a.size() == 1 ? \"\" : \", \"), a.pop(); os << \" }\"; return os; }\n#ifdef DEBUG\n#if !defined(DEBUG_OUT)\n#define DEBUG_OUT cerr\n#endif\n#if !defined(DEBUG_LEFT)\n#define DEBUG_LEFT \"\\e[1;36m\"\n#endif\n#if !defined(DEBUG_RIGHT)\n#define DEBUG_RIGHT \":\\e[m\"\n#endif\n#define dump(...) [&](){auto __debug_tap=make_tuple(__VA_ARGS__);DEBUG_OUT<<DEBUG_LEFT<<__LINE__ << DEBUG_RIGHT << \" \" <<#__VA_ARGS__<<\" = \"<<__debug_tap<<endl;}()\ntemplate < class T > inline void dump2D(T &d, size_t sizey, size_t sizex) { for(size_t i = 0; i < sizey; i++) { DEBUG_OUT << \"\\t\"; for(size_t j = 0; j < sizex; j++) DEBUG_OUT << d[i][j] << (j + 1 == sizex ? \"\" : \"\\t\"); DEBUG_OUT << endl; } }\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { o << \"{\"; for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \", \") << *ite; o << \"}\"; return o; }\n#else\n#define dump(...) (42)\n#define dump2D(...) (42)\ntemplate < class T, class = typename iterator_traits< decltype(begin(T())) >::value_type, class = typename enable_if<!is_same<T, string>::value>::type > ostream &operator<<(ostream &o, const T &a) { for(auto ite = begin(a); ite != end(a); ++ite) o << (ite == begin(a) ? \"\" : \" \") << *ite; return o; }\n#endif\n// clang-format on\n// }}}\n\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false) returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  ll build(int s, int t) {\n    vector< int > level(n);\n    ll flow = 0;\n    while(bfs(s, level), level[t] >= 0) {\n      ll newflow;\n      while((newflow = dfs(s, t, inf, level)) > 0) {\n        flow += newflow;\n        if(flow >= inf) return inf;\n      }\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] < 0 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e18;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := x\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// \n// kk\n//  (k+1) \n//  k \n// n-1\n\n//  E_i has i \n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} \n// N\n// N\n\n// DFS\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace max_flow {\n\nconst int max_v = 200222, inf = 1000111222;\n\nstruct edge {\n    int to, residual_capacity;\n\n    edge(int to, int residual_capacity): to(to), residual_capacity(residual_capacity) {\n    }\n};\n\nvector<edge> edges;\nvector<int> g[max_v];\n\nvoid add_edge(int u, int v, int capacity) {\n    g[u].push_back(edges.size());\n    edges.push_back({v, capacity});\n    g[v].push_back(edges.size());\n    edges.push_back({u, 0});\n}\n\nint h[max_v];\n\nbool bfs(int s, int t) {\n    for (int i = 0; i <= t; ++i) {\n        h[i] = -1;\n    }\n    h[s] = 0;\n    queue<int> q;\n    q.push(s);\n    while (!q.empty()) {\n        int v = q.front();\n        q.pop();\n        for (int id : g[v]) {\n            if (edges[id].residual_capacity && h[edges[id].to] == -1) {\n                h[edges[id].to] = h[v] + 1;\n                q.push(edges[id].to);\n            }\n        }\n    }\n    return h[t] != -1;\n}\n\nint dfs(int v, int t, int f) {\n    if (v == t) {\n        return f;\n    }\n    for (int id : g[v]) {\n        if (edges[id].residual_capacity  && h[v] + 1 == h[edges[id].to]) {\n            int res = dfs(edges[id].to, t, min(f, edges[id].residual_capacity));\n            if (res) {\n                edges[id].residual_capacity -= res;\n                edges[id ^ 1].residual_capacity += res;\n                return res;\n            }\n        }\n    }\n    return 0;\n}\n\nint dinic(int s, int t) {\n    int res = 0;\n    while (bfs(s, t)) {\n        while (int f = dfs(s, t, inf)) {\n            res += f;\n        }\n    }\n    return res;\n}\n\n}\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], ans[max_n], used[max_n];\nvector<int> g[max_n], g2[max_n];\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    int s = 2 * n - 1, t = 2 * n;\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        max_flow::add_edge(s, i, 1);\n        for (int to : g[i]) {\n            max_flow::add_edge(i, n - 1 + to, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        max_flow::add_edge(n - 1 + i, t, 1);\n    }\n    int f = max_flow::dinic(s, t);\n    memset(p, -1, sizeof(p));\n    memset(nxt, -1, sizeof(nxt));\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int id : max_flow::g[i]) {\n            const auto &e = max_flow::edges[id];\n            if (e.to != s && e.residual_capacity == 0) {\n                nxt[i] = e.to - n + 1;\n                p[nxt[i]] = i;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv, is_forb;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e[a].PB(Edge{b, cap, SZ(e[b]), 0});\n    e[b].PB(Edge{a, bi_dir * cap, SZ(e[a]) - 1, 0});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    //e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n\n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n    for (int i = 0; i <= n; i++) {\n      dis[i] = n + 1;\n    }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        if (edge.is_forb) { continue; }\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      if (e[v][i].is_forb) { continue; }\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<int> halko;\n    for (int ii = 0; ii < SZ(gr.e[i]); ii++) {\n      auto edge = gr.e[i][ii];\n    //for (auto& edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        debug(i, edge.v);\n        int poszlo = Dinic::kInf - edge.c;\n        gr.e[i][ii].c = 0;\n        gr.e[edge.v][edge.inv].c = 0;\n        assert(gr.e[source][i - 1].v == i);\n        gr.e[source][i - 1].c += poszlo;\n        assert(gr.e[i][0].v == source);\n        gr.e[i][0].c -= poszlo;\n        assert(gr.e[edge.v][0].v == sink);\n        gr.e[edge.v][0].c += poszlo;\n        assert(gr.e[sink][edge.v - n - 1].v == edge.v);\n        gr.e[sink][edge.v - n - 1].c -= poszlo;\n        int new_flow = gr.MaxFlow(source, sink);\n        if (new_flow == poszlo) {\n          debug(\"wywal\");\n        } else {\n          halko.PB(edge.v - n);\n          gr.e[i][ii].c = Dinic::kInf;\n          gr.e[edge.v][edge.inv].c = 0;\n          int newer_flow = gr.MaxFlow(source, sink);\n          //debug(new_flow, new_flow, poszlo);\n          assert(new_flow + newer_flow == poszlo);\n        }\n        //halko.PB({edge.v - n, );\n      } else {\n        gr.e[i][ii].c = 0;\n      } \n    }\n//     vector<int> filter;\n//     for (auto v : halko) {\n//       \n//       \n//     }\n    debug(halko);\n    assert(SZ(halko) == 2);\n    for (auto x : halko) {\n      cout<<x<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint read();\nint n, s, t;\nint hd[400005], nx[1000006], to[1000006], c[1000006], cnt;\nvoid add(int f, int t, int cap) {\n    nx[++cnt] = hd[f], hd[f] = cnt, to[cnt] = t, c[cnt] = cap;\n}\nvoid fadd(int f, int t, int c) { add(f, t, c), add(t, f, 0); }\n\nint dep[400005];\nqueue<int> q;\nbool bfs() {\n    for (int i = 1; i <= t; ++i) dep[i] = 0;\n    dep[s] = 1, q.push(s);\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int i = hd[u], v; i; i = nx[i]) {\n            if (!c[i] || dep[v = to[i]]) continue;\n            dep[v] = dep[u] + 1, q.push(v);\n        }\n    }\n    return dep[t];\n}\n\nint iter[400005];\nint dfs(int u, int dist) {\n    if (u == t) return dist;\n    for (int &i = iter[u], v, d; i; i = nx[i]) {\n        if (!c[i] || dep[v = to[i]] != dep[u] + 1) continue;\n        if (d = dfs(v, min(dist, c[i]))) return c[i] -= d, c[i ^ 1] += d, d;\n    }\n    return 0;\n}\nint Dinic() {\n    int rt = 0, d;\n    while (bfs()) {\n        for (int i = 1; i <= t; ++i) iter[i] = hd[i];\n        while (d = dfs(s, 10000000)) rt += d;\n    }\n    return rt;\n}\n\nvector<int> e[400005];\nint p[400005];\nstruct Res {\n    int u, v;\n} res[400005];\nbool get_res() {\n    for (int u = 1; u < n; ++u)\n        for (int i = hd[u]; i; i = nx[i])\n            if (to[i] != s && c[i] == 0) p[u] = to[i] - n + 1;\n\n    int sum = 0;\n    q.push(n);\n    while (!q.empty()) {\n        int u = q.front();\n        ++sum, q.pop();\n        for (int i = 0, v; i < e[u].size(); ++i)\n            if (p[v = e[u][i]]) res[v] = (Res){u, p[v]}, q.push(p[v]), p[v] = 0;\n    }\n    return sum == n;\n}\n\nint main() {\n    n = read(), s = 2 * n - 1, t = 2 * n, cnt = 1;\n    for (int i = 1; i < n; ++i) fadd(i + n - 1, t, 1);\n    for (int i = 1, c, u; i < n; ++i) {\n        c = read(), fadd(s, i, 1);\n        while (c--) {\n            if ((u = read()) != n) fadd(i, u + n - 1, 1);\n            e[u].push_back(i);\n        }\n    }\n    if (Dinic() < n - 1) return puts(\"-1\"), 0;\n    if (!get_res()) return puts(\"-1\"), 0;\n\n    for (int i = 1; i < n; ++i) printf(\"%d %d\\n\", res[i].u, res[i].v);\n\n    return 0;\n}\nconst int _SIZE = 1 << 22;\nchar ibuf[_SIZE], *iS = ibuf, *iT = ibuf;\n#define gc                                                         \\\n    (iS == iT ? iT = ((iS = ibuf) + fread(ibuf, 1, _SIZE, stdin)), \\\n     (iS == iT ? EOF : *iS++) : *iS++)\nint read() {\n    int x = 0, f = 1;\n    char c = gc;\n    while (!isdigit(c)) f = (c == '-') ? -1 : f, c = gc;\n    while (isdigit(c)) x = x * 10 + c - '0', c = gc;\n    return x * f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G2;\nint n, Deg[N_], UF[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nvector<int>TP[N_];\nint Num[N_], Q[N_], head, tail, vis[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG2.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\n\t\tG2.Add_Edge(G2.source, i, 1);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tTP[a].push_back(i);\n\t\t\tif (a != 1) {\n\t\t\t\tG2.Add_Edge(i, n - 1 + a, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tif(i!=1)G2.Add_Edge(n - 1 + i, G2.sink, 1);\n\t}\n\tG2.Dinic();\n\tif (G2.flow != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 2; i <= n; i++) {\n\t\tfor (auto &x : G2.G[n - 1 + i]) {\n\t\t\tEdge tp = G2.E[x];\n\t\t\tif (tp.f) {\n\t\t\t\tNum[tp.e] = i;\n\t\t\t}\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : TP[x]) {\n\t\t\tif (!vis[t]) {\n\t\t\t\tRes[t][0] = x;\n\t\t\t\tRes[t][1] = Num[t];\n\t\t\t\tQ[++tail] = Num[t];\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tif (tail!=n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 210000;\nconst int INF = 1000000000;\n \nstruct edge {\n    int a, b, cap, flow;\n};\n \nint nv, s, t, d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n \nvoid addEdge (int a, int b, int cap) {\n    edge e1 = { a, b, cap, 0 };\n    edge e2 = { b, a, 0, 0 };\n    g[a].push_back ((int) e.size());\n    e.push_back (e1);\n    g[b].push_back ((int) e.size());\n    e.push_back (e2);\n}\n \nbool bfs() {\n    int qh=0, qt=0;\n    q[qt++] = s;\n    memset (d, -1, nv * sizeof d[0]);\n    d[s] = 0;\n    while (qh < qt && d[t] == -1) {\n        int v = q[qh++];\n        for (size_t i=0; i<g[v].size(); ++i) {\n            int id = g[v][i],\n                to = e[id].b;\n            if (d[to] == -1 && e[id].flow < e[id].cap) {\n                q[qt++] = to;\n                d[to] = d[v] + 1;\n            }\n        }\n    }\n    return d[t] != -1;\n}\n \nint dfs (int v, int flow) {\n    if (!flow)  return 0;\n    if (v == t)  return flow;\n    for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n        int id = g[v][ptr[v]],\n            to = e[id].b;\n        if (d[to] != d[v] + 1)  continue;\n        int pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n        if (pushed) {\n            e[id].flow += pushed;\n            e[id^1].flow -= pushed;\n            return pushed;\n        }\n    }\n    return 0;\n}\n\nvector<bool> visited;\nvector<int> via;\n\nvoid dfs2(int v) {\n  visited[v] = true;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    int id = g[v][i];\n    int to = e[id].b;\n    if (!visited[to] && e[id].flow < e[id].cap) {\n      via[to] = v;\n      dfs2(to);\n    }\n  }\n}\n \nint dinic() {\n    int flow = 0;\n    for (;;) {\n        if (!bfs())  break;\n        memset (ptr, 0, nv * sizeof ptr[0]);\n        while (int pushed = dfs (s, INF))\n            flow += pushed;\n    }\n    return flow;\n}\n\nint main() {\n        int n; scanf(\"%d\", &n);\n        nv = 2 * n + 1;\n        s = nv - 2;\n        t = nv - 1;\n        vector<int> left(n);\n        for (int i = 0; i < n; ++i) {\n            left[i] = i;\n            addEdge(s, left[i], 1);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int cur = n + i;\n            int count; scanf(\"%d\", &count);\n            addEdge(cur, t, 1);\n            for (int j = 0; j < count; ++j) {\n                int a; scanf(\"%d\", &a);\n                addEdge(left[a - 1], cur, 1);\n            }\n        }\n        int flow = dinic();\n        if (flow != n - 1) {\n            \n                printf(\"-1\\n\");\n                return 0;\n        }\n        visited = vector<bool>(nv);\n        via = vector<int>(nv);\n        dfs2(s);\n        for (int v : left) {\n            if (!visited[v]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n        vector<int> first(n - 1);\n        vector<int> second(n - 1);\n        for (int v : left) {\n            if (via[v] == s) continue;\n            int u = via[via[v]];\n            first[via[v] - n] = v + 1;\n            second[via[v] - n] = u + 1;\n        }\n        for (int i = 0; i < n - 1; ++i)           {\n            printf(\"%d %d\\n\", first[i], second[i]);\n        }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Author -- Frame\n\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n\n#define lowbit(x) ((x)&(-x))\n#define Finline __inline__ __attribute__ ((always_inline))\n#define DEBUG fprintf(stderr,\"Running on Line %d in Function %s\\n\",__LINE__,__FUNCTION__)\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n\nconst int inf=0x3f3f3f3f,Inf=0x7fffffff;\nconst ll INF=0x7fffffffffffffff;\nconst double eps=1e-10;\n\ntemplate <typename _Tp>_Tp gcd(const _Tp &a,const _Tp &b){return (!b)?a:gcd(b,a%b);}\ntemplate <typename _Tp>Finline _Tp abs(const _Tp &a){return a>=0?a:-a;}\ntemplate <typename _Tp>Finline _Tp max(const _Tp &a,const _Tp &b){return a<b?b:a;}\ntemplate <typename _Tp>Finline _Tp min(const _Tp &a,const _Tp &b){return a<b?a:b;}\ntemplate <typename _Tp>Finline void chmax(_Tp &a,const _Tp &b){(a<b)&&(a=b);}\ntemplate <typename _Tp>Finline void chmin(_Tp &a,const _Tp &b){(b<a)&&(a=b);}\ntemplate <typename _Tp>Finline bool _cmp(const _Tp &a,const _Tp &b){return abs(a-b)<=eps;}\ntemplate <typename _Tp>Finline void read(_Tp &x)\n{\n\tregister char ch(getchar());\n\tbool f(false);\n\twhile(ch<48||ch>57) f|=ch==45,ch=getchar();\n\tx=ch&15,ch=getchar();\n\twhile(ch>=48&&ch<=57) x=(((x<<2)+x)<<1)+(ch&15),ch=getchar();\n\tif(f) x=-x;\n}\ntemplate <typename _Tp,typename... Args>Finline void read(_Tp &t,Args &...args)\n{\n\tread(t);read(args...);\n}\nFinline int read_str(char *s)\n{\n\tregister char ch(getchar());\n\twhile(ch==' '||ch=='\\r'||ch=='\\n') ch=getchar();\n\tregister char *tar=s;\n\t*tar=ch,ch=getchar();\n\twhile(ch!=' '&&ch!='\\r'&&ch!='\\n'&&ch!=EOF) *(++tar)=ch,ch=getchar();\n\treturn tar-s+1;\n}\n\nconst int N=200015;\ntemplate<typename _Tp>\nclass flow{\npublic:\n\tstruct edge{\n\t\tint v,nxt;\n\t\t_Tp w;\n\t}c[N<<3];\n\tint front[N],edge_cnt;\n\tFinline flow(){memset(front,255,sizeof(front)),edge_cnt=-1;}\n\tint cur[N],dep[N],S,T;\n\tint _q[N],_l,_r;\n\tint node_cnt;\n\tFinline void add(int u,int v,_Tp w)\n\t{\n\t\tc[++edge_cnt]=(edge){v,front[u],w},front[u]=edge_cnt;\n\t\tc[++edge_cnt]=(edge){u,front[v],0},front[v]=edge_cnt;\n\t}\n\tbool bfs()\n\t{\n\t\tmemset(dep,255,(node_cnt+3)<<2);\n\t\tmemcpy(cur,front,(node_cnt+3)<<2);\n\t\tdep[S]=0;\n\t\t_q[_l=_r=1]=S;\n\t\twhile(_l!=_r+1)\n\t\t{\n\t\t\tint x=_q[_l++];\n\t\t\tfor(int i=front[x];~i;i=c[i].nxt)\n\t\t\t{\n\t\t\t\tif(c[i].w&&!~dep[c[i].v])\n\t\t\t\t{\n\t\t\t\t\tdep[c[i].v]=dep[x]+1;\n\t\t\t\t\t_q[++_r]=c[i].v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ~dep[T];\n\t}\n\t_Tp dfs(int x,int flow)\n\t{\n\t\tif(x==T||!flow) return flow;\n\t\t_Tp f=0,rf;\n\t\tfor(int &i=cur[x];~i;i=c[i].nxt)\n\t\t{\n\t\t\tif(dep[c[i].v]==dep[x]+1&&(rf=dfs(c[i].v,min(flow,c[i].w))))\n\t\t\t{\n\t\t\t\tflow-=rf,f+=rf;\n\t\t\t\tc[i].w-=rf,c[i^1].w+=rf;\n\t\t\t\tif(!flow) return f;\n\t\t\t}\n\t\t}\n\t\treturn f;\n\t}\n\t_Tp dinic()\n\t{\n\t\t_Tp ans=0;\n\t\twhile(bfs()) ans+=dfs(S,inf);\n\t\t// inf changes when _Tp != int\n\t\treturn ans;\n\t}\n\tbool vis[N];\n\tint to[N];\n\tint n;\n\tstd::pair<int,int> ans[N];\n\tint cnt=0;\n\tvoid dfs(int x)\n\t{\n\t\tfor(int i=front[x];~i;i=c[i].nxt)\n\t\t{\n\t\t\tif(c[i].v<n+n&&!vis[c[i].v-n])\n\t\t\t{\n\t\t\t\t++cnt;\n\t\t\t\tans[c[i].v-n]=std::make_pair(x,to[c[i].v-n]);\n\t\t\t\tvis[c[i].v-n]=true;\n\t\t\t\tdfs(to[c[i].v-n]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid solve(int _n)\n\t{\n\t\tn=_n;\n\t\tint root=0;\n\t\tfor(int i=front[S];~i;i=c[i].nxt)\n\t\t{\n\t\t\tif(c[i].w)\n\t\t\t{\n\t\t\t\troot=c[i].v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<n;++i)\n\t\t{\n\t\t\tfor(int _=front[i+n];~_;_=c[_].nxt)\n\t\t\t{\n\t\t\t\tif(c[_].v<=n&&c[_].w)\n\t\t\t\t{\n\t\t\t\t\tto[i]=c[_].v;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(root);\n\t\tif(cnt!=n-1)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=1;i<n;++i) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\t}\n\t}\n};\nflow<int> F;\nint main()\n{\n\tint n;\n\tread(n);\n\tint x,y;\n\tF.S=n+n,F.T=n+n+1;\n\tF.node_cnt=n+n+1;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tread(x);\n\t\tfor(int j=1;j<=x;++j)\n\t\t{\n\t\t\tread(y);\n\t\t\tF.add(y,i+n,1);\n\t\t}\n\t\tF.add(i+n,F.T,1);\n\t\tF.add(F.S,i,1);\n\t}\n\tF.add(F.S,n,1);\n\tint ans=F.dinic();\n\tif(ans!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tF.solve(n);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define pb push_back\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define MEM(i,j) memset(i,j,sizeof i)\n#define ALL(v) v.begin(),v.end()\n#define DB(a,s,e) {for(int i=s;i<e;++i) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int MAXN=2e5+50,INF=1e9;\nstruct Maxflow{\n\tstruct edge{\n\t\tint to,cap,flow,rev;\n\t};\n\tvector<edge> G[MAXN];\n\tint dis[MAXN],cur[MAXN],s,t;\n\tint dfs(int u,int cap){\n\t\tif(u==t||!cap) return cap;\n\t\tfor(int &i=cur[u];i<G[u].size();++i){\n\t\t\tauto &e=G[u][i];\n\t\t\tif(dis[e.to]==dis[u]+1&&e.flow!=e.cap){\n\t\t\t\tint df=dfs(e.to,min(cap,e.cap-e.flow));\n\t\t\t\tif(df){\n\t\t\t\t\te.flow+=df,G[e.to][e.rev].flow-=df;\n\t\t\t\t\treturn df;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[u]=-1;\n\t\treturn 0;\n\t}\n\tbool bfs(){\n\t\tMEM(dis,-1);\n\t\tqueue<int> q;\n\t\tq.push(s),dis[s]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto e:G[u])\n\t\t\t\tif(!~dis[e.to]&&e.flow!=e.cap)\n\t\t\t\t\tq.push(e.to),dis[e.to]=dis[u]+1;\n\t\t}\n\t\treturn dis[t]!=-1;\n\t}\n\tint maxflow(int _s,int _t){\n\t\ts=_s,t=_t;\n\t\tint flow=0,df;\n\t\twhile(bfs()){\n\t\t\tMEM(cur,0);\n\t\t\twhile(df=dfs(s,INF)) flow+=df;\n\t\t}\n\t\treturn flow;\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;++i) G[i].clear();\n\t}\n\tvoid add_edge(int a,int b,int cap){\n\t\tG[a].pb(edge{b,cap,0,G[b].size()});\n\t\tG[b].pb(edge{a,0,0,G[a].size()-1});\n\t}\n}Dinic;\n\nint match[200005],n,ans[100005];\nvector<int> G[100005];\nbitset<100005> vis;\n\nvoid dfs(int u,int f)\n{\n\tvis[u]=1,ans[u]=f;\n\tfor(int i:G[u])\n\t\tif(!vis[i])\n\t\t\tdfs(i,u);\n}\n\nint main()\n{jizz\n\tint t,x,s;\n\tcin >> n,Dinic.init(2*n+1);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tcin >> t;\n\t\twhile(t--)\n\t\t\tcin >> x,Dinic.add_edge(i+n,x,1);\n\t}\n\tfor(int i=1;i<n;++i)\n\t\tDinic.add_edge(2*n,i+n,1);\n\tfor(int i=1;i<=n;++i)\n\t\tDinic.add_edge(i,0,1);\n\tif(Dinic.maxflow(2*n,0)!=n-1)\n\t\treturn cout << \"-1\\n\",0;\n\tfor(int i=1;i<n;++i)\n\t\tfor(auto e:Dinic.G[i+n])\n\t\t\tif(e.cap==e.flow&&e.to<=n)\n\t\t\t{\n\t\t\t\tmatch[i+n]=e.to,match[e.to]=i;\n\t\t\t\t//cout << i << \"-\" << e.to << \"\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i=1;i<=n;++i)\n\t\tif(!match[i])\n\t\t{\n\t\t\ts=i,match[i]=n,match[n+n]=i;\n\t\t\tbreak;\n\t\t}\n\tfor(int i=1;i<n;++i)\n\t\tfor(auto e:Dinic.G[i+n])\n\t\tif(e.to<=n&&match[e.to]!=i)\n\t\t\t\tG[match[e.to]].pb(i);//,cout << \"add edge \" << match[e.to] << \"->\" << i << \"\\n\";\n\tdfs(n,-1);\n\tfor(int i=1;i<=n;++i)\n\t\tif(!vis[i])\n\t\t\treturn cout << \"-1\\n\",0;\n\tfor(int i=1;i<n;++i)\n\t\tcout << match[i+n] << \" \" << match[ans[i]+n] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\nconst int N=1e5+1, V=2e5, E=8e5;\nint n, m, to[E], cap[E], head[V], next[E], cur[V], queue[V], dis[V], u[N], v[N], tot;\nbool vis[N];\nstd::vector<int> in[N];\nvoid add_edge(int u, int v, int w) {\n\tto[m]=v, cap[m]=w, next[m]=head[u], head[u]=m++;\n\tto[m]=u, cap[m]=0, next[m]=head[v], head[v]=m++;\n}\nbool bfs() {\n\tint *qhead=queue, *qtail=queue;\n\tmemset(dis, -1, 2*n*sizeof(int));\n\tdis[*qtail++=n]=true;\n\twhile(qhead!=qtail) {\n\t\tint u=*qhead++;\n\t\tfor(int i=head[u]; ~i; i=next[i])\n\t\t\tif(dis[to[i]]==-1&&cap[i^1]) {\n\t\t\t\tdis[*qtail++=to[i]]=dis[u]+1;\n\t\t\t\tif(to[i]==0) return true;\n\t\t\t}\n\t}\n\treturn false;\n}\nint dfs(int x, int lim) {\n\tif(x==n) return lim;\n\tint rem=lim;\n\tfor(int &i=cur[x]; ~i; i=next[i])\n\t\tif(cap[i]&&dis[to[i]]==dis[x]-1) {\n\t\t\tint t=dfs(to[i], std::min(lim, cap[i]));\n\t\t\tcap[i]-=t, cap[i^1]+=t;\n\t\t\tif((rem-=t)==0) return lim;\n\t\t}\n\treturn lim-rem;\n}\nvoid sol(int x) {\n\tvis[x]=true;\n\t++tot;\n\tfor(int y: in[x]) {\n\t\tint z=u[y];\n\t\tif(z!=x&&!vis[z]) v[y]=x, sol(z);\n\t}\n}\nint main() {\n\tn=rd();\n\tmemset(head, -1, 2*n*sizeof(int));\n\tfor(int i=1; i<n; ++i) add_edge(0, i, 1), add_edge(n+i, n, 1);\n\tfor(int i=1; i<n; ++i) {\n\t\tint c=rd();\n\t\twhile(c--) {\n\t\t\tint j=rd();\n\t\t\tin[j].emplace_back(i);\n\t\t\tif(j!=n) add_edge(j, n+i, 1);\n\t\t}\n\t}\n\tint flow=0;\n\twhile(bfs()) {\n\t\tmemcpy(cur, head, 2*n*sizeof(int));\n\t\tflow+=dfs(0, 1e9);\n\t}\n\tif(flow!=n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i)\n\t\tfor(int j=head[n+i]; ~j; j=next[j])\n\t\t\tif(cap[j]) u[i]=to[j];\n\tsol(n);\n\tif(tot<n) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i) printf(\"%d %d\\n\", u[i], v[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <set>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100]; set<int> W[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tif (N == 2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t\tW[x].insert(i);\n\t\t}\n\t}\n\n\tfor (int i=1;i<=N;i++){\n\t\tif (W[i].size() == 0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstack<int> s;\n\tfor (int i=0;i<N-1;i++){\n\t\tint c = 0;\n\t\tfor (int x : G[i]) if (W[x].size() == 1) c++;\n\t\tif (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if (c == 1){\n\t\t\ts.push(i);\n\t\t}\n\t}\n\n\twhile (!s.empty()){\n\t\tint i = s.top(), v = 0, c = 0; s.pop();\n\t\tfor (int x : G[i]){\n\t\t\tif (W[x].size() == 1) v = x, c++;\n\t\t\tW[x].erase(i);\n\t\t\tif (W[x].size() == 1) s.push(*W[x].begin());\n\t\t}\n\t\tif (c == 1){\n\t\t\tint x = v;\n\t\t\tint y = G[i][0]==v?G[i][1]:G[i][0];\n\t\t\tX[i] = x; Y[i] = y;\n\t\t}\n\t\telse if (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[i].clear();\n\t}\n\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++) if (!G[i].empty()){\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsrand(time(NULL));\n\tfor (int t=0;t<1000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi E[N],e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\tE[i].pb(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\");\n\trep(i,1,n-1){\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\t}\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n-1)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,\n\t\t\tvi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\n\nvector<vector<int> > g;\nvector<int> btoa;\n\nvector<vector<pair<int,int> > > edges;\nint main(){\n\tint n;\n\tcin >> n;\n\tg.resize(n);\n\tbtoa.resize(n, -1);\n\tfor(int i = 1; i < n; i++){\n\t\tint c;\n\t\tcin >> c;\n\t\tfor(int a = 0; a < c; a++){\n\t\t\tint d;\n\t\t\tcin >> d;\n\t\t\td--;\n\t\t\tg[i].push_back(d);\n\t\t}\n\t}\n\tg[0].push_back(0);\n\tif(hopcroftKarp(g, btoa) < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tvector<int> a(n);\n\tvector<int> b(n);\n\ta = btoa;\n\n\tedges.resize(n);\n\tfor(int i = 1; i < n; i++){\n\t\tfor(int r : g[i]){\n\t\t\tedges[r].push_back({a[i], i});\n\t\t}\n\t}\n\tvector<int> bfs;\n\tbfs.push_back(0);\n\tint s = 0;\n\tvector<int> vis(n, 0);\n\tvis[0] = 1;\n\tint cnt = 1;\n\twhile(s < bfs.size()){\n\t\tint x = bfs[s];\n\t\ts++;\n\t\tfor(auto r : edges[x]){\n\t\t\tif(vis[r.first]) continue;\n\t\t\tvis[r.first] = 1;\n\t\t\tcnt++;\n\t\t\tb[r.second] = x;\n\t\t\tbfs.push_back(r.first);\n\t\t}\n\t}\n\tif(cnt < n){\n\t\tcout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1; i < n; i++){\n\t\tcout << a[i] + 1 << \" \" << b[i] + 1 << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0&&di[a[y].nu]==di[x]+1){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)  cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tcout<<i<<' '<<i+1<<endl;\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005, Inf = 1 << 30;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nint n;\nqueue<int> q;\nvector<int> vec[maxn];\nint eu[maxn], ev[maxn], vis[maxn];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn << 3];\nint s, t, h[maxn << 1], cur[maxn << 1], dis[maxn << 1], mat[maxn << 1], tot = 1;\n\ninline void add(int u, int v, int w)\n{\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nbool bfs()\n{\n\tstatic int l, r, q[maxn << 1];\n\tmemset(dis + 1, 0, sizeof(int) * t);\n\tl = 0; q[r = 1] = s; dis[s] = 1;\n\twhile (l < r) {\n\t\tint u = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!dis[v] && e[i].cap) dis[v] = dis[u] + 1, q[++r] = v;\n\t}\n\treturn dis[t];\n}\n\nint dfs(int u, int a)\n{\n\tif (u == t || !a) return a;\n\tint f, flow = 0;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (dis[v] == dis[u] + 1 && (f = dfs(v, min(a, e[i].cap)))) {\n\t\t\tflow += f; a -= f;\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint max_flow()\n{\n\tint res = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * t);\n\t\tres += dfs(s, Inf);\n\t}\n\tfor (int u = 1; u < n; ++u)\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!e[i].cap && v != s) {mat[u] = v; mat[v] = u; break;}\n\treturn res;\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int c, w, i = 1; i < n; ++i) {\n\t\tc = gi();\n\t\twhile (c--) {\n\t\t\tw = gi(); vec[w].push_back(i);\n\t\t\tif (w != n) add(w, i + n - 1, 1);\n\t\t}\n\t}\n\ts = n * 2 - 1; t = s + 1;\n\tfor (int i = 1; i < n; ++i) add(s, i, 1), add(i + n - 1, t, 1);\n\t\n\tif (max_flow() != n - 1) return puts(\"-1\"), 0;\n\tint cnt = 0; q.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); ++cnt;\n\t\tfor (int e : vec[u])\n\t\t\tif (!vis[e]) vis[e] = 1, q.push(mat[e + n - 1]), eu[e] = u, ev[e] = mat[e + n - 1];\n\t}\n\tif (cnt != n) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define Rint register int\nusing namespace std;\nconst int N = 200003, M = N << 2, INF = 0x3f3f3f3f;\nint n, S, T, head[N], to[M], nxt[M], w[M], dep[N], cur[N], q[N], f, r, ans[2][N], m;\nbool vis[N];\ntemplate<typename T>\ninline void read(T &x){\n    int ch = getchar(); x = 0;\n    for(;ch < '0' || ch > '9';ch = getchar());\n    for(;ch >= '0' && ch <= '9';ch = getchar()) x = x * 10 + ch - '0';\n}\ninline void add(int a, int b, int c){\n    static int cnt = 1;\n    to[++ cnt] = b; nxt[cnt] = head[a]; head[a] = cnt; w[cnt] = c;\n    to[++ cnt] = a; nxt[cnt] = head[b]; head[b] = cnt; w[cnt] = 0;\n}\ninline bool bfs(){\n    memset(dep, -1, sizeof dep);\n    memcpy(cur, head, sizeof cur);\n    dep[S] = f = r = 0; q[r ++] = S;\n    while(f < r){\n        int u = q[f ++];\n        for(Rint i = head[u];i;i = nxt[i])\n            if(dep[to[i]] == -1 && w[i]){\n                dep[to[i]] = dep[u] + 1; q[r ++] = to[i];\n            }\n    }\n    return ~dep[T];\n}\ninline int dfs(int x, int lim){\n    if(!lim || x == T) return lim;\n    int flow = 0, f;\n    for(Rint i = cur[x];i;i = nxt[i]){\n        cur[x] = i;\n        if(dep[to[i]] == dep[x] + 1 && (f = dfs(to[i], min(lim, w[i])))){\n            flow += f; lim -= f; w[i] -= f; w[i ^ 1] += f;\n            if(!lim) break;\n        }\n    }\n    return flow;\n}\ninline int dinic(){\n    int ans = 0;\n    while(bfs()) ans += dfs(S, INF);\n    return ans;\n}\ninline void dfs(int x){\n    for(Rint i = head[x];i;i = nxt[i]) if(to[i] != S && !vis[to[i] - n]){\n        int u = to[i] - n; vis[u] = true;\n        for(Rint j = head[to[i]];j;j = nxt[j]) if(w[j]){\n            ++ m; ans[0][u] = x; ans[1][u] = to[j]; dfs(to[j]); break;\n        }\n    }\n}\nint main(){\n    read(n); S = n << 1; T = S + 1;\n    for(Rint i = 1;i <= n;++ i) add(S, i, 1);\n    for(Rint i = 1, x, u;i < n;++ i){\n        read(x); add(n + i, T, 1);\n        while(x --){read(u); add(u, n + i, 1);}\n    }\n    if(dinic() != n - 1) return puts(\"-1\"), 0;\n    for(Rint i = head[S];i;i = nxt[i]) if(w[i]){dfs(to[i]); break;}\n    if(m != n - 1) return puts(\"-1\"), 0;\n    for(Rint i = 1;i < n;++ i) printf(\"%d %d\\n\", ans[0][i], ans[1][i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\nint sum;\n\nint dg(int x, int flow) {\n\tif(x == T) {\n\t\tsum += flow;\n\t\treturn flow;\n\t}\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] == d[to[i]] + 1 && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(sum == n - 1 || use == flow) return use;\n\t\t}\n\tcur[x] = fi[x];\n\tif(!(-- co[d[x]])) d[S] = T;\n\t++ co[++ d[x]];\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tsum = 0;\n\tco[0] = T; while(d[S] < T) dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\ntemplate<typename tn> void read(tn &a){\n\ttn x=0,f=1; char c=' ';\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\ta=x*f;\n}\nconst int N = 201000;\nvector<int> E[N],in[N];\nnamespace Graph{\n\tconst int inf = 1e9;\n\tvector<pair<int,int> > ans;\n\tint n,tot,t,head[N],b[N],vis[N],cur[N];\n\tstruct edge{int v,nxt,f;}e[N*4];\n\tvoid init(int m){\n\t\tn=m;t=2*n+1;tot=1;\n\t\tans.resize(n);\n\t}\n\tvoid add(int x,int y,int z){\n\t\te[++tot]={y,head[x],z};\n\t\thead[x]=tot;\n\t\te[++tot]={x,head[y],0};\n\t\thead[y]=tot;\n\t}\n\tbool bfs(){\n\t\tmemset(b,0,sizeof(b));b[0]=1;\n\t\tqueue<int> q;q.push(0);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&!b[e[i].v]){\n\t\t\t\t\tb[e[i].v]=b[u]+1;\n\t\t\t\t\tq.push(e[i].v);\n\t\t\t\t}\n\t\t}\n\t\treturn b[t];\n\t}\n\tint dfs(int x,int flow){\n\t\tif(!flow||x==t) return flow;\n\t\tint f=flow,tmp;\n\t\tfor(int &i=cur[x];i;i=e[i].nxt)\n\t\t\tif(b[e[i].v]==b[x]+1&&(tmp=dfs(e[i].v,min(e[i].f,f)))){\n\t\t\t\tf-=tmp;e[i].f-=tmp;e[i^1].f+=tmp;\n\t\t\t\tif(!f) break;\n\t\t\t}\n\t\treturn flow-f;\n\t}\n\tint Dinic(){\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,head,sizeof(cur));\n\t\t\tans+=dfs(0,inf);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(int x){\n\t\tvis[x]=1;\n\t\tfor(int p:in[x])\n\t\t\tfor(int i=head[p+n];i;i=e[i].nxt)\n\t\t\t\tif(e[i].f&&e[i].v!=t){\n\t\t\t\t\tif(vis[e[i].v]) continue;\n\t\t\t\t\tans[p]=make_pair(x,e[i].v);\n\t\t\t\t\tsolve(e[i].v);\n\t\t\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i=1;i<n;i++) if(!ans[i].first){puts(\"-1\");return;}\n\t\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t}\n}\nint n;\nint main(){\n\tread(n);\n\tGraph::init(n);\n\tfor(int i=1;i<n;i++){\n\t\tint k;read(k);\n\t\twhile(k--){\n\t\t\tint x;read(x);\n\t\t\tE[i].push_back(x);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\tfor(int x:in[i]) Graph::add(i,x+n,1);\n\t\tGraph::add(0,i,1);\n\t}\n\tfor(int i=1;i<n;i++) Graph::add(i+n,Graph::t,1);\n\tif(Graph::Dinic()<n-1){puts(\"-1\");return 0;}\n\tGraph::solve(1);\n\tGraph::print();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint n, c, u;\n\nvector<int> edge[108000];\nvector<int> ans[216000];\nbool come[216000];\n\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tedge[i].push_back(n + u);\n\t\t\tedge[n+u].push_back(i);\n\t\t}\t\n\t}\n\tdfs(n+1);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 3e5 + 50, M = 2e6 + 50;\ncs int INF = 1e9 + 7;\nint n, S, T, fi[N], nxt[M], to[M], w[M], ec=1;\nvoid adde(int x, int y, int z){\n\tnxt[++ec]=fi[x], fi[x]=ec, to[ec]=y, w[ec]=z;\n\tnxt[++ec]=fi[y], fi[y]=ec, to[ec]=x, w[ec]=0;\n} int eu[N], ev[N], ct, d[N];\nbool bfs(){\n\tqueue<int> q; q.push(S); \n\tmemset(d,-1,sizeof(d)); d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x],v;e;e=nxt[e]) if(w[e]){\n\t\t\tv=to[e]; if(d[v]==-1){\n\t\t\t\td[v]=d[x]+1; q.push(v);\n\t\t\t\tif(v==T) return true;\n\t\t\t}\n\t\t}\n\t} return false;\n}\nint dfs(int u, int flw){\n\tif(u==T) return flw; int ans = 0;\n\tfor(int e=fi[u],v;e;e=nxt[e])\n\tif(d[v=to[e]]==d[u]+1){\n\t\tint dt=dfs(v,min(w[e],flw));\n\t\tans+=dt; flw-=dt;\n\t\tw[e]-=dt; w[e^1]+=dt; if(!flw) break;\n\t} if(flw) d[u]=-1; return ans;\n}\nint dinic(){ int flw = 0; while(bfs()) flw += dfs(S,INF); return flw; }\nint main(){\n\t#ifdef FSYolanda\n\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1,k,x; i<n; i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1; j<=k; j++) \n\t\tscanf(\"%d\",&x), adde(x,i+n,1);\n\t} S=0, T=n+n;\n\tfor(int i=1; i<=n; i++) adde(S,i,1);\n\tfor(int i=1; i<n; i++) adde(i+n,T,1);\n\tint flw = dinic();\n\tif(flw < n-1) return puts(\"-1\"),0;\n\t\n\tstatic int tr[N];\n\tfor(int i=n+1; i<n+n; i++)\n\tfor(int e=fi[i];e;e=nxt[e]) \n\tif(to[e]!=T&&w[e]) tr[i]=to[e];\n\t\n\tqueue<int> q;\n\tfor(int e=fi[S];e;e=nxt[e])\n\tif(w[e]) q.push(to[e]);\n\t\n\tstatic bool ban[N];\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x];e;e=nxt[e]) \n\t\tif(to[e]!=S&&!ban[to[e]]){\n\t\t\teu[++ct]=x; ev[ct]=tr[to[e]];\n\t\t\tq.push(tr[to[e]]); ban[to[e]]=true;\n\t\t}\n\t} if(ct<n-1) return puts(\"-1\"),0;\n\tfor(int i=1; i<n; i++) cout<<eu[i]<<\" \"<<ev[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    for (int it = 0; it < n - 1; it++) {\n      assert(!q.empty());\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v, done);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++){\n\t\t\tcout<<i<<' '<<i+1<<endl;\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int i=h[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[u]=v-n;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(v),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define M 400010\n#define inf 1e9\nusing namespace std;\nint n,num,cnt,s,t,h[M],head[M],son[M],vis[M];\nvector<int>S[M],P[M];\nqueue<int>Que;\nstruct node{int x,y;}f[M];\nstruct edge{int next,to,dis;}e[M<<1];\nvoid add(int from,int to,int dis) {\n\te[num]=(edge){head[from],to,dis};\n\thead[from]=num++;\n}\nbool bfs() {\n\tqueue<int>Q;Q.push(s);\n\tmemset(h,0,sizeof(h)),h[s]=1;\n\twhile(!Q.empty()) {\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis>0&&!h[e[i].to])\n\t\t\t\tQ.push(e[i].to),h[e[i].to]=h[x]+1;\n\t}\n\treturn h[t];\n}\nint dfs(int x,int dis) {\n\tif(x==t) return dis;int sum=0;\n\tfor(int i=head[x];i;i=e[i].next) {\n\t\tint to=e[i].to;\n\t\tif(e[i].dis&&h[to]==h[x]+1) {\n\t\t\tint diss=dfs(to,min(e[i].dis,dis));\n\t\t\tdis-=diss;sum+=diss;\n\t\t\te[i].dis-=diss;e[i^1].dis+=diss;\n\t\t\tif(!dis) break;\n\t\t}\n\t}\n\tif(!sum) h[x]=-1;\n\treturn sum;\n}\nint dinic() {\n\tint tot=0;\n\twhile(bfs()) \n\t\ttot+=dfs(s,inf);\n\treturn tot;\n}\nint main() {\n\tscanf(\"%d\",&n);s=0,t=2*n;\n\tfor(int i=1;i<n;i++) {\n\t\tint sum;scanf(\"%d\",&sum);\n\t\tfor(int j=1;j<=sum;j++) {\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tS[i+n].push_back(x);\n\t\t\tadd(i+n,x,0),add(x,i+n,1);\n\t\t\tP[x].push_back(i+n);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) add(i,s,0),add(s,i,1);\n\tfor(int i=n+1;i<n+n;i++) add(t,i,0),add(i,t,1);\n\tint ans=dinic();\n\tif(ans!=n-1) {puts(\"-1\");return 0;}\n\tfor(int x=n+1;x<n+n;x++)\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis&&e[i].to!=t)\n\t\t\t\tson[x]=e[i].to;\n\tQue.push(1);\n\twhile(!Que.empty()) {\n\t\tint x=Que.front();Que.pop();\n\t\tfor(int i=0;i<P[x].size();i++) {\n\t\t\tint to=P[x][i];\n\t\t\tif(!vis[to]) {\n\t\t\t\tvis[to]=true;\n\t\t\t\tQue.push(son[to]);\n\t\t\t\tf[++cnt]=(node){x,son[to]};\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t}\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsort(v.begin(),v.end());\n\n\tsrand(time(NULL));\n\tfor (int t=0;t<3000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5,INF=(1<<29),SZ=2*N+10;\n\nstruct EDGE{\n    int to,cap;\n    EDGE *nxt,*rev;\n    EDGE(){}\n    EDGE(int _t,int _c,EDGE *_n,EDGE *_r):to(_t),cap(_c),nxt(_n),rev(_r){}\n};\nstruct GRAPH{\n    EDGE edg[4*N*2+10],*head[SZ],*ncnt;\n    GRAPH(){ncnt=edg;}\n    void AddEdge(int u,int v,int cap){\n        EDGE *p=++ncnt,*q=++ncnt;\n        *p=EDGE(v,cap,head[u],q);head[u]=p;\n        *q=EDGE(u,  0,head[v],p);head[v]=q;\n    }\n    EDGE* operator [](int id){return head[id];}\n};\nGRAPH Gr;\nEDGE *cop[SZ];\nint dis[SZ];\nvector< pair<int,int> > lnk[N+3];\nint n,S,T,tot;\nvector<int> tset[N+3];\nint ans[N+3][2];\nbool vis[N+3];\n\nint Aug(int u,int in){\n    if(u==T) return in;\n    int out=0;\n    while(cop[u]){\n        EDGE *it=cop[u];cop[u]=cop[u]->nxt;\n        int v=it->to;\n        if(dis[v]!=dis[u]+1 || it->cap<=0) continue;\n        int tov=Aug(v,min(in-out,it->cap));\n        it->cap-=tov;it->rev->cap+=tov;\n        out+=tov;\n        if(out==in) break;\n    }\n    return out;\n}\nbool BFS(){\n    for(int i=1;i<=T;i++) dis[i]=-1,cop[i]=Gr[i];\n    queue<int> que;que.push(S);dis[S]=0;\n    while(!que.empty()){\n        int u=que.front();que.pop();\n        for(EDGE *it=Gr[u];it;it=it->nxt){\n            int v=it->to;\n            if(dis[v]!=-1 || it->cap<=0) continue;\n            dis[v]=dis[u]+1;\n            if(v==T) return true;\n            que.push(v);\n        }\n    }\n    return false;\n}\nint Dinic(){\n    int res=0;\n    while(BFS())\n        res+=Aug(S,INF);\n    return res;\n}\nvoid DFS(int u){\n    vis[u]=true;tot++;\n    for(int i=(int)lnk[u].size()-1;i>=0;i--){\n        int v=lnk[u][i].first,id=lnk[u][i].second;\n        if(ans[id][0] || vis[v]) continue;\n        ans[id][0]=u;ans[id][1]=v;\n        DFS(v);\n    }\n}\nint main(){\n    // freopen(\"input.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    S=n*2;T=S+1;\n    for(int i=2;i<=n;i++) Gr.AddEdge(S,i,1);\n    for(int i=1;i<n;i++) Gr.AddEdge(i+n,T,1);\n    for(int i=1;i<n;i++){\n        int num;scanf(\"%d\",&num);\n        while(num--){\n            int u;scanf(\"%d\",&u);\n            Gr.AddEdge(u,n+i,1);\n            tset[i].push_back(u);\n        }\n    }\n    int res=Dinic();\n    if(res<n-1) printf(\"-1\\n\");\n    else{\n        for(int i=1;i<n;i++){\n            int E=i+n,u=-1;\n            for(EDGE *it=Gr[E];it && u==-1;it=it->nxt)\n                if(it->cap)\n                    u=it->to;\n            for(int j=(int)tset[i].size()-1;j>=0;j--)\n                if(tset[i][j]!=u){\n                    int v=tset[i][j];\n                    lnk[u].emplace_back(v,i);\n                    lnk[v].emplace_back(u,i);\n                }\n        }\n        DFS(1);\n        if(tot<n) printf(\"-1\\n\");\n        else\n            for(int i=1;i<n;i++)\n                printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],min(flow-used,c[i]));\n\t\tif(v)used+=v,c[i]-=v,c[i^1]+=v,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,print(x,num[i]),q[++t]=num[i];\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n)p[u]=gp;\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=1;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=2;i<=n;++i)if(!p[i])return puts(\"-1\"),0;\n\tfor(int i=2;i<=n;++i)printf(\"%d %d\\n\",p[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T>inline T read(){\n\tT f=0,x=0;char c=getchar();\n\twhile(!isdigit(c)) f=c=='-',c=getchar();\n\twhile(isdigit(c)) x=x*10+c-48,c=getchar();\n\treturn f?-x:x;\n}\nnamespace run{\n\tconst int N=4e5+9,inf=1e8;\n\tint head[N],nex[N],to[N],fl[N],cnt=1;\n\tinline void add(int u,int v,int flow){\n\t//\tcout<<u<<\" \"<<v<<\" \"<<flow<<endl;\n\t\tnex[++cnt]=head[u],head[u]=cnt,to[cnt]=v,fl[cnt]=flow;\n\t\tnex[++cnt]=head[v],head[v]=cnt,to[cnt]=u,fl[cnt]=0;\n\t}\n\tint S,T,dist[N],cur[N];\n\tqueue<int> q;\n\tinline bool bfs(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=T;i++) dist[i]=inf;\n\t\tq.push(S),dist[S]=0;\n\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tif(u==T) return 1;\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(fl[i] && dist[to[i]]==inf){\n\t\t\t\t\tdist[to[i]]=dist[u]+1;\n\t\t\t\t\tq.push(to[i]);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tinline int dfs(int u,int flow){\n\t\tif(u==T) return flow;\n\t\tint rest=flow,k;\n\t\tfor(int &i=cur[u];rest && i;i=nex[i])\n\t\t\tif(fl[i] && dist[to[i]]==dist[u]+1){\n\t\t\t\tk=dfs(to[i],min(fl[i],flow));\n\t\t\t\tfl[i]-=k,fl[i^1]+=k,rest-=k;\n\t\t\t}\n\t\treturn flow-rest;\n\t}\n\n\tint n,mat[N],vis[N];\n\tvector<int> pos[N],E[N],ans[N];\n\tinline bool fortry(){\n\t\twhile(!q.empty()) q.pop();\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!mat[i+n-1]){q.push(i);break;}\n\n\t\tint tot=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();tot++;\n\t\t\tfor(int i=0;i<pos[u].size();i++) if(!vis[pos[u][i]]){\n\t\t\t\tint id=pos[u][i];\n\t\t\t\tvis[pos[u][i]]=1,ans[id].push_back(mat[id]-n+1),ans[id].push_back(u);\n\t\t\t\tq.push(mat[id]-n+1);\n\t\t\t}\n\t\t}\n\t\tif(tot!=n) return 0;\n\t\treturn 1;\n\t}\n\tint main(){\n\t\tn=read<int>();\n\t\tS=n-1+n+1,T=S+1;\n\t\tfor(int t=1;t<n;t++){\n\t\t\tint k=read<int>();\n\t\t\tfor(int i=1;i<=k;i++){\n\t\t\t\tint u=read<int>();\n\t\t\t\tE[t].push_back(u),pos[u].push_back(t);\n\t\t\t\tadd(t,u+n-1,1);\n\t\t\t}\n\t\t\tadd(S,t,1);\n\t\t}\n\t\tfor(int i=1;i<=n;i++) add(i+n-1,T,1);\n\t\tint mxfl=0;\n\t\twhile(bfs()){\n\t\t\tfor(int i=1;i<=T;i++) cur[i]=head[i];\n\t\t\tint d;\n\t\t\tdo{d=dfs(S,inf),mxfl+=d;}while(d);\n\t\t}\n\t\tif(mxfl!=n-1) puts(\"-1\"),exit(0);\n\t\tfor(int u=1;u<n;u++)\n\t\t\tfor(int i=head[u];i;i=nex[i])\n\t\t\t\tif(!fl[i]){mat[u]=to[i],mat[to[i]]=u;break;}\n\t\tif(!fortry()) puts(\"-1\"),exit(0);\n\t\tfor(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][0]);\n\t\treturn 0;\n\t}\n}\nint main(){\n#ifdef my\n\tfreopen(\".in\",\"r\",stdin);\n\tfreopen(\".out\",\"w\",stdout);\n#endif\n\treturn run::main();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &i : x) cin >> i;\n\t\ta.pb({x, i});\n\t}\n\tsort(all(a), [](auto i, auto j) {\n\t\treturn i.first.size() < j.first.size();\n\t});\n\trans.resize(n-1);\n\tdsu d(n);\n\tfor(auto [i, idx] : a) {\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tif(d.r[d.par(1)] != n) return cout << -1, 0;\n\texit(-1);\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=z,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint y=mat[to[i]];\n\tif(!y||v[y]||!c[i]) continue;\n\tan[++ta][0]=x,an[ta][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5,INF=(1<<29),SZ=2*N+10;\n\nstruct EDGE{\n    int to,cap;\n    EDGE *nxt,*rev;\n    EDGE(){}\n    EDGE(int _t,int _c,EDGE *_n,EDGE *_r):to(_t),cap(_c),nxt(_n),rev(_r){}\n};\nstruct GRAPH{\n    EDGE edg[4*N*2+10],*head[SZ],*ncnt;\n    GRAPH(){ncnt=edg;}\n    void AddEdge(int u,int v,int cap){\n        EDGE *p=++ncnt,*q=++ncnt;\n        *p=EDGE(v,cap,head[u],q);head[u]=p;\n        *q=EDGE(u,  0,head[v],p);head[v]=q;\n    }\n    EDGE* operator [](int id){return head[id];}\n};\nGRAPH Gr;\nEDGE *cop[SZ];\nint dis[SZ];\nvector< pair<int,int> > lnk[N+3];\nint n,S,T,tot;\nvector<int> tset[N+3];\nint ans[N+3][2];\nbool vis[N+3];\n\nint Aug(int u,int in){\n    if(u==T) return in;\n    int out=0;\n    while(cop[u]){\n        EDGE *it=cop[u];cop[u]=cop[u]->nxt;\n        int v=it->to;\n        if(dis[v]!=dis[u]+1 || it->cap<=0) continue;\n        int tov=Aug(v,min(in-out,it->cap));\n        it->cap-=tov;it->rev->cap+=tov;\n        out+=tov;\n        if(out==in) break;\n    }\n    return out;\n}\nbool BFS(){\n    for(int i=1;i<=T;i++) dis[i]=-1,cop[i]=Gr[i];\n    queue<int> que;que.push(S);dis[S]=0;\n    while(!que.empty()){\n        int u=que.front();que.pop();\n        for(EDGE *it=Gr[u];it;it=it->nxt){\n            int v=it->to;\n            if(dis[v]!=-1 || it->cap<=0) continue;\n            dis[v]=dis[u]+1;\n            if(v==T) return true;\n            que.push(v);\n        }\n    }\n    return false;\n}\nint Dinic(){\n    int res=0;\n    while(BFS())\n        res+=Aug(S,INF);\n    return res;\n}\nvoid DFS(int u){\n    vis[u]=true;tot++;\n    for(int i=(int)lnk[u].size()-1;i>=0;i--){\n        int v=lnk[u][i].first,id=lnk[u][i].second;\n        if(ans[id][0] || vis[v]) continue;\n        ans[id][0]=u;ans[id][1]=v;\n        DFS(v);\n    }\n}\nint main(){\n    // freopen(\"input.txt\",\"r\",stdin);\n    scanf(\"%d\",&n);\n    S=n*2;T=S+1;\n    for(int i=2;i<=n;i++) Gr.AddEdge(S,i,1);\n    for(int i=1;i<n;i++) Gr.AddEdge(i+n,T,1);\n    for(int i=1;i<n;i++){\n        int num;scanf(\"%d\",&num);\n        while(num--){\n            int u;scanf(\"%d\",&u);\n            Gr.AddEdge(u,n+i,1);\n            tset[i].push_back(u);\n        }\n    }\n    int res=Dinic();\n    if(res<n-1) printf(\"-1\\n\");\n    else{\n        for(int i=1;i<n;i++){\n            int E=i+n,u=-1;\n            for(EDGE *it=Gr[E];it && u==-1;it=it->nxt)\n                if(it->cap)\n                    u=it->to;\n            for(int j=(int)tset[i].size()-1;j>=0;j--)\n                if(tset[i][j]!=u){\n                    int v=tset[i][j];\n                    lnk[u].emplace_back(v,i);\n                    lnk[v].emplace_back(u,i);\n                }\n        }\n        DFS(1);\n        if(tot<n) printf(\"-1\\n\");\n        else\n            for(int i=1;i<n;i++)\n                printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int MaxN=100010,inf=1<<30;\nint N;\nstruct edge{int to,cap;edge*rev,*next;}E[MaxN*8],*ne=E,*fir[MaxN*2],*cur[MaxN*2];\nvoid link(int a,int b,int c){\n\t*ne=(edge){b,c,ne+1,fir[a]};fir[a]=ne++;\n\t*ne=(edge){a,0,ne-1,fir[b]};fir[b]=ne++;\n}\nint Q[MaxN*2],D[MaxN*2];\nint dfs(int i,int c){\n\tif(i==1||!c)return c;\n\tint fl=0,f;\n\tfor(edge*&e=cur[i];e&&c;e=e->next)\n\t\tif(e->cap&&D[e->to]==D[i]-1&&(f=dfs(e->to,c<e->cap?c:e->cap)))\n\t\t\tfl+=f,e->cap-=f,e->rev->cap+=f,c-=f;\n\treturn fl;\n}\nint u[MaxN],v[MaxN];\nint mf(){\n\tfor(int f=0;;f+=dfs(0,inf)){\n\t\tfor(int i=0;i<=N*2;i++)D[i]=0,cur[i]=fir[i];\n\t\tfor(int*h=Q,*t=Q+(D[*h=1]=1);h<t;h++)\n\t\t\tfor(edge*e=fir[*h];e;e=e->next)\n\t\t\t\tif(e->rev->cap&&!D[e->to]){\n\t\t\t\t\tD[*t++=e->to]=D[*h]+1;\n\t\t\t\t\tif(f==N-1)*h<=N?u[*h]=e->to-N:v[e->to]=*h-N;\n\t\t\t\t} \n\t\tif(!*D)return f;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&N);\n\tfor(int i=2;i<=N;i++){\n\t\tint c,w;\n\t\tscanf(\"%d\",&c);\n\t\tlink(0,i,1);\n\t\twhile(c--)scanf(\"%d\",&w),link(i,N+w,inf);\n\t}\n\tfor(int i=N+1;i<=N*2;i++)link(i,1,1);\n\tif(mf()<N-1)return puts(\"-1\"),0;\n\tfor(int i=2;i<=N;i++)if(!D[i])return puts(\"-1\"),0;\n\tfor(int i=2;i<=N;i++)printf(\"%d %d\\n\",u[i],v[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500015;\nconst int INF = (int) 1e9;\nint e_num = 1, S, T;\nint hed[maxn], dep[maxn];\nstruct Edge {\n  int from, to, nxt, c;\n} edge[maxn * 4];\nvoid addedge(int from, int to, int c) {\n  edge[++e_num] = (Edge){from, to, hed[from], c};\n  hed[from] = e_num;\n}\nvoid adde(int from, int to, int c) {\n  addedge(from, to, c);\n  addedge(to, from, 0);\n}\nint que[maxn + 5], head = 0, tail = 0;\nbool bfs() {\n  head = tail = 0;\n  que[tail++] = S;\n  for (int i = S; i <= T; i++) dep[i] = 0;\n  dep[S] = 1;\n  while (head != tail) {\n    int cur = que[head++]; head %= maxn;\n    for (int i = hed[cur]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (!dep[to] && edge[i].c) {\n        dep[to] = dep[cur] + 1;\n        que[tail++] = to; tail %= maxn;\n      }\n    }\n  }\n  return dep[T];\n}\nint dfs(int x, int flow) {\n  if (x == T) return flow;\n  int ret = 0;\n  for (int i = hed[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (dep[to] == dep[x] + 1 && edge[i].c) {\n      int tmp = dfs(to, std::min(flow, edge[i].c));\n      edge[i].c -= tmp;\n      edge[i ^ 1].c += tmp;\n      flow -= tmp;\n      ret += tmp;\n      if (!flow) {\n        break;\n      }\n    }\n  }\n  if (!ret) dep[x] = 0;\n  return ret;\n}\nint dinic() {\n  int ret = 0;\n  while (bfs()) {\n    ret += dfs(S, INF);\n  }\n  return ret;\n}\n\nconst int N = 100233;\nint n, visit[N], son[N], fa[N];\nvector<int> e[N], g[N];\nint main() {\n  scanf(\"%d\", &n);\n  S = 0, T = n * 2 + 1;\n  for (int i = 1, t, x; i < n; i++) {\n    adde(S, i, 1);\n    scanf(\"%d\", &t);\n    while (t--) {\n      scanf(\"%d\", &x);\n      e[i].push_back(x);\n      g[x].push_back(i);\n      if (x > 1) adde(i, x + n, 1);\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    adde(i + n, T, 1);\n  }\n  int p = dinic();\n  if (p < n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    for (int e = hed[i]; e; e = edge[e].nxt) {\n      if (edge[e].to > n && !edge[e].c) {\n        son[i] = edge[e].to - n;\n      }\n    }\n  }\n  queue<int> q;\n  for (auto x : g[1]) {\n    q.push(x);\n    visit[x] = 1;\n    fa[x] = 1;\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto y : g[son[x]]) {\n      if (!visit[y]) {\n        q.push(y);\n        visit[y] = 1;\n        fa[y] = son[x];\n      }\n    }\n  }\n  if (accumulate(visit + 1, visit + n, 0) != n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", fa[i], son[i]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int> q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\t//dmp(s);\n\t\tfor(auto t:adj[s]){\n\t\t\t//if(t.fs<=0)return;\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t\t\t//b[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\tx--;\n\t\tg[i].pb(x);\n\t}\n}\ng[0].pb(0);\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\nfor(int i=1;i<=n-1;i++){\n\tmatch[btoa[i]]=i;\n}\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\t//match[btoa[i]]=i;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({match[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s=1;\nbfstree(0);\nfor(int i=0;i<n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\n//dmp(sum);\n//assert(sum>=n);\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << match[i]+1 << \" \" << b[i]+1 << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\treturn 0;\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1, G2;\nint n, Deg[N_], UF[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nvector<int>TP[N_];\nint Num[N_], Q[N_], head, tail, vis[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tG2.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tG2.Add_Edge(G2.source, i, 1);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tTP[a].push_back(i);\n\t\t\tif (a != 1) {\n\t\t\t\tG2.Add_Edge(i, n - 1 + a, 1);\n\t\t\t}\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tG1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\t\tif(i!=1)G2.Add_Edge(n - 1 + i, G2.sink, 1);\n\t}\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tG2.Dinic();\n\tfor (i = 2; i <= n; i++) {\n\t\tfor (auto &x : G2.G[n - 1 + i]) {\n\t\t\tEdge tp = G2.E[x];\n\t\t\tif (tp.f) {\n\t\t\t\tNum[tp.e] = i;\n\t\t\t}\n\t\t}\n\t}\n\tQ[++tail] = 1;\n\twhile (head < tail) {\n\t\tint x = Q[++head];\n\t\tfor (auto &t : TP[x]) {\n\t\t\tif (!vis[t]) {\n\t\t\t\tRes[t][0] = x;\n\t\t\t\tRes[t][1] = Num[t];\n\t\t\t\tQ[++tail] = Num[t];\n\t\t\t\tvis[t] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false)\n//   - returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  vector< int > level;\n  vector<size_t> itr;\n  ll build(int s, int t) {\n    level.resize(n);\n    itr.resize(n);\n    ll flow = 0, newflow;\n    while(bfs(s), level[t] >= 0) {\n      itr.assign(n, 0);\n      while((newflow = dfs(s, t, inf)) > 0) {\n        flow += newflow;\n        if(flow >= inf) return inf;\n      }\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s) {\n    fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(level[edge.To(i)] < 0 && edge.Cap(i) > 0) {\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int v, int t, ll flow) {\n    if(v == t) return flow;\n    for(size_t &i = itr[v]; i < g[v].size(); ++i) {\n      Edge& edge = edges[g[v][i]];\n      if(edge.Cap(v) > 0 && level[edge.To(v)] > level[v]) {\n        ll newflow = dfs(edge.To(v), t, min(flow, edge.Cap(v)));\n        if(newflow == 0) continue;\n        edge.Cap(v) -= newflow;\n        edge.Rev(v) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e9;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := x\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// \n// kk\n//  (k+1) \n//  k \n// n-1\n\n//  E_i has i \n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} \n// N\n// N\n\n// DFS\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// I need some holiday\n// But I don't wish that everyday is holiday\n// Because I didn't bear the pain\n// Because it wasn't a true freedom\n//         Orangestar\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int UI;\ntypedef pair<int, int> pii;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define MP make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline int chkmin(T &a, const T &b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline int chkmax(T &a, const T &b) { return b > a ? a = b, 1 : 0; }\ntemplate<typename T> inline T sqr(const T &val) { return val * val; }\n\nnamespace fastIO\n{\n\tconst int MAX_BUFFER_SIZE = 1 << 16;\n\n\tchar buffer[MAX_BUFFER_SIZE], *cur = buffer, *ed = buffer;\n\n\tinline char getc() { return cur == ed && (ed = (cur = buffer) + fread(buffer, 1, MAX_BUFFER_SIZE, stdin), cur == ed) ? EOF : *cur++; }\n}\nusing fastIO::getc;\n\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getc());\n\tfor(; !isdigit(ch); ch = getc()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getc()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ninline char *read_str(char *s)\n{\n\tregister char ch(getc());\n\twhile(!isgraph(ch)) ch = getc();\n\tfor(; isgraph(ch); ch = getc()) *s++ = ch;\n\t*s = '\\0';\n\treturn s;\n}\n\n// END tpl.\n\nconst int MAXN = (int) 1e5;\n\nnamespace FLOW\n{\n\tconst int INF = (int) 1e9;\n\tconst int MAXV = MAXN * 2, MAXE = MAXN * 8;\n\n\tint cnt;\n\n\tinline int new_node() { return ++cnt; }\n\n\tstruct edge\n\t{\n\t\tint v, c, nxt;\n\n\t\tedge() { }\n\t\tedge(int _v, int _c, int _nxt): v(_v), c(_c), nxt(_nxt) { }\n\t};\n\n\tedge e[MAXE * 2 + 5];\n\tint st[MAXV + 5], edge_cnt;\n\n\tinline void init() { cnt = 0, memset(st, -1, sizeof st), edge_cnt = 0; }\n\tinline int add_edge(int u, int v, int c, int type = 1)\n\t{\n\t\te[edge_cnt] = edge(v, c, st[u]), st[u] = edge_cnt++;\n\t\tif(type) add_edge(v, u, 0, 0);\n\t\treturn st[u];\n\t}\n\n\tint d[MAXV + 5];\n\n\tinline int BFS(int S, int T)\n\t{\n\t\tstatic queue<int> q;\n\t\tfor(int i = 1; i <= cnt; ++i) d[i] = -1;\n\n\t\td[S] = 0, q.push(S);\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\n\t\t\tfor(int i = st[u]; ~i; i = e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].c > 0 && d[v] == -1) d[v] = d[u] + 1, q.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn d[T] != -1;\n\t}\n\n\tint cur[MAXV + 5];\n\n\tinline int dfs(int u, int low, int T)\n\t{\n\t\tif(u == T) return low;\n\n\t\tint sum = 0;\n\t\tfor(int &i = cur[u]; ~i; i = e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v, k = 0;\n\t\t\tif(e[i].c > 0 && d[v] == d[u] + 1 && (k = dfs(v, min(low, e[i].c), T)) > 0)\n\t\t\t{\n\t\t\t\te[i].c -= k, e[i ^ 1].c += k;\n\t\t\t\tsum += k, low -= k;\n\t\t\t\tif(low == 0) break;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\n\tinline int solve(int S, int T)\n\t{\n\t\tint flow = 0;\n\t\twhile(BFS(S, T))\n\t\t{\n\t\t\tfor(int i = 1; i <= cnt; ++i) cur[i] = st[i];\n\t\t\tfor(int k = dfs(S, INF, T); k > 0; k = dfs(S, INF, T)) flow += k;\n\t\t}\n\t\treturn flow;\n\t}\n}\n\nint n;\n\nvector<int> E[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i < n; ++i) for(int N = read<int>(); N--; ) E[i].push_back(read<int>());\n}\n\nint d[MAXN + 5], id[MAXN + 5];\nvector<int> ids[MAXN + 5];\n\nint fa[MAXN + 5];\n\ninline int dfs(int u)\n{\n\tint res = 1;\n\tfor(auto v0 : ids[u]) if(!fa[v0])\n\t{\n\t\tint v = d[v0];\n\t\tfa[v0] = u;\n\t\tres += dfs(v);\n\t}\n\treturn res;\n}\n\ninline void solve()\n{\n\tFLOW::init();\n\n\tstatic unordered_map<int, int> eid[MAXN + 5];\n\tstatic int X[MAXN + 5], Y[MAXN + 5];\n\n\tconst int S = FLOW::new_node(), T = FLOW::new_node();\n\tfor(int i = 1; i < n; ++i) FLOW::add_edge(S, X[i] = FLOW::new_node(), 1);\n\tfor(int i = 1; i < n; ++i) FLOW::add_edge(Y[i] = FLOW::new_node(), T, 1);\n\n\tfor(int i = 1; i < n; ++i) for(auto j : E[i]) if(j != n)\n\t\teid[i][j] = FLOW::add_edge(X[i], Y[j], 1);\n\n\tif(FLOW::solve(S, T) != n - 1) { puts(\"-1\"); return; }\n\n\tfor(int i = 1; i < n; ++i)\n\t\tfor(auto j : E[i]) if(eid[i].count(j) && FLOW::e[eid[i][j]].c == 0)\n\t\t{\n\t\t\td[i] = j, id[j] = i;\n\t\t\tbreak;\n\t\t}\n\n\tfor(int i = 1; i < n; ++i) for(auto j : E[i]) ids[j].push_back(i);\n\tif(dfs(n) != n) { puts(\"-1\"); return; }\n\tfor(int i = 1; i < n; ++i) printf(\"%d %d\\n\", d[i], fa[i]);\n}\n\nint main()\n{\n#ifdef K_ON\n\tfreopen(\"F.in\", \"r\", stdin);\n\tfreopen(\"F.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 200002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[5*MAX_N], visited[MAX_N], rev[MAX_N];\nint source, target, d[MAX_N], f[5*MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    queue<int> qu;\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\nconst int N=4e5+5,M=1.2e6+5;\nint n,m,d,e,s,t,he[N],nh[N],to[N],nx[N],le[N],\ntd[N],qu[N],hd,tl,ds[N],a;\ninline void wk(int x,int y)\n{\n\t++e,to[e]=y,le[e]=1,nx[e]=he[x],he[x]=e;\n\t++e,to[e]=x,le[e]=0,nx[e]=he[y],he[y]=e;\n}\ninline int bfs()\n{\n\tmemset(ds,0,16*n+4),memcpy(nh,he,16*n+4),ds[s]=1,qu[hd=tl=1]=s;\n\tfor(;hd<=tl;++hd)for(int x=qu[hd],i=he[x],y;i;i=nx[i])if(le[i]&&!ds[y=to[i]])\n\t\tds[y]=ds[x]+1,qu[++tl]=y;\n\treturn ds[t];\n}\nint dfs(int x,int z)\n{\n\tif(x==t)return 1;\n\tfor(int&i=nh[x],y,g;i;i=nx[i])\n\t\tif(ds[y=to[i]]==ds[x]+1&&le[i]&&(i&1||x&1||x<=t||y-n!=z)&&dfs(y,!(i&1)&&y&1&&y>t?x:z))\n\t\t{\n\t\t\tle[i]=0,le[i^1]=1;\n\t\t\tif(!(i&1)&&!(x&1)&&x>t)td[x]=y;\n\t\t\tif(!(i&1)&&y&1&&y>t)td[y]=x;\n\t\t\tif(x!=s)return 1;\n\t\t}\n\treturn 0;\n}\nint main()\n{\n\tscanf(\"%d\",&n),d=2*n+2,e=1,s=2*n+1,t=2*n+2;\n\tfor(int i=1;i<=n;++i)wk(s,i),wk(n+i,t);\n\tfor(int i=1,x;i<n;++i)\n\t{\n\t\tscanf(\"%d\",&x),++d,++d,wk(d-1,d);\n\t\tfor(int i=1,y;i<=x;++i)\n\t\t\tscanf(\"%d\",&y),wk(y,d-1),wk(d,n+y);\n\t}\n\twhile(bfs())\n\t\tdfs(2*n+1,0);\n\tfor(int i=1;i<n;++i)\n\t\tif(!td[t+2*i-1]||!td[t+2*i])\n\t\t\treturn printf(\"-1\"),0;\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",td[t+2*i-1],td[t+2*i]-n);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n//\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;struct edge{int to,next,rem;}e[1000005];\nqueue<int> q;pair<int,int> p[100005];vector<int> bel[100005];\nint tot=1,s,t,n,last[1000005],dep[1000005],nxt[1000005],lst[1000005];\ninline void adde(int u,int v,int d) {e[++tot]=(edge){v,last[u],d},last[u]=tot;return;}\ninline void inse(int u,int v) {return adde(u,v,1),adde(v,u,0);}\ninline bool bfs(void) {\n\tmemset(dep,0,sizeof dep),dep[s]=1;\n\twhile (!q.empty()) q.pop();q.push(s);\n\twhile (!q.empty()) {int cur=q.front();q.pop();\n\t\tfor (int i=last[cur];i;i=e[i].next) {int ot=e[i].to;\n\t\t\tif (e[i].rem&&!dep[ot]) dep[ot]=dep[cur]+1,q.push(ot);\n\t\t}\n\t}return dep[t];\n}int dfs(int u,int lim) {int rtv=0,d;if (u==t) return lim;\n\tfor (int&i=lst[u];i&&rtv<lim;i=e[i].next) {int ot=e[i].to;\n\t\tif (e[i].rem&&dep[ot]==dep[u]+1) {\n\t\t\td=dfs(ot,min(e[i].rem,lim-rtv));\n\t\t\te[i].rem-=d,e[i^1].rem+=d,rtv+=d;\n\t\t}\n\t}if (!rtv) dep[u]=0;return rtv;\n}inline int prt(void) {int cnt=n;\n\tfor (int i=1;i<n;++i) for (int j=last[i];j;j=e[j].next) {\n\t\tint ot=e[j].to;if (ot&&!e[j].rem) nxt[i]=ot-n;\n\t}while (!q.empty()) q.pop();q.push(n);\n\twhile (!q.empty()) {int cur=q.front();q.pop(),--cnt;\n\t\tfor (int i:bel[cur]) if (nxt[i])\n\t\t\tp[i]=make_pair(cur,nxt[i]),q.push(nxt[i]),nxt[i]=0;\n\t}return cnt;\n}int main() {int m,u,fl=0;scanf(\"%d\",&n),s=0,t=n<<1;\n\tfor (int i=1;i<n;++i) inse(s,i),inse(n+i,t);\n\tfor (int i=1;i<n;++i) {scanf(\"%d\",&m);\n\t\twhile (m--) {scanf(\"%d\",&u);\n\t\t\tif (u^n) inse(i,n+u);bel[u].push_back(i);\n\t\t}\n\t}while (bfs()) memcpy(lst,last,sizeof last),fl+=dfs(s,0x3f3f3f3f);\n\tif (fl^(n-1)) return 0*puts(\"-1\");if (prt()) return 0*puts(\"-1\");\n\tfor (int i=1;i<n;++i) printf(\"%d %d\\n\",p[i].first,p[i].second);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\nconst int N=1e5+6,V=2e5+6;\nstruct edge{int v,c,nxt;}g[800003];\nint n,m,head[V],k,iter[V],S,T,d[V],q[V],l,r,f[N],x[N],vis[N];\nstd::vector<int>e[N];\ninline void Insert(int u,int v){\n\tg[k]=(edge){v,1,head[u]},head[u]=k++;\n\tg[k]=(edge){u,0,head[v]},head[v]=k++;\n}\ninline bool Bfs(){\n\tint u,v;\n\tfor(u=1;u<=T;u++)d[u]=0;\n\td[q[l=r=0]=S]=1;\n\tfor(;l<=r;){\n\t  u=q[l++];\n\t  for(int i=head[u];~i;i=g[i].nxt)if(g[i].c&&!d[v=g[i].v])\n\t\td[v]=d[u]+1,q[++r]=v;\n\t}return d[T];\n}\nint Dfs(int u,int f){\n\tif(!f||u==T)return f;\n\tint v,res=0,tmp;\n\tfor(int&i=iter[u];~i;i=g[i].nxt)\n\t  if(g[i].c&&d[v=g[i].v]>d[u]&&(tmp=Dfs(v,std::min(f,g[i].c)))){\n\t\tg[i].c-=tmp,g[i^1].c+=tmp;\n\t\tf-=tmp,res+=tmp;\n\t\tif(!f)return res;\n\t  }\n\treturn res;\n}\ninline int Maxflow(){\n\tint res=0;\n\tfor(;;){\n\t  if(!Bfs())return res;\n\t  for(int u=1;u<=T;u++)iter[u]=head[u];\n\t  res+=Dfs(S,n-1);\n\t}\n}\nvoid Ans(int u){\n\tvis[u]=1;\n\tfor(int i=0;i<e[u].size();i++)if(!vis[f[e[u][i]]])\n\t  x[e[u][i]]=u,Ans(f[e[u][i]]);\n}\nint main(){\n\tint u;\n\tscanf(\"%d\",&n);\n\tS=n+n-1,T=n+n;\n\tfor(u=1;u<=T;u++)head[u]=-1;\n\tfor(int i=1;i<n;i++){\n\t  scanf(\"%d\",&m);\n\t  for(;m--;){\n\t\tscanf(\"%d\",&u);\n\t\tif(u<n)Insert(u,i+n-1);\n\t\te[u].push_back(i);\n\t  }\n\t  Insert(i+n-1,T);\n\t}\n\tfor(u=1;u<n;u++)Insert(S,u);\n\tif(Maxflow()!=n-1)return 0*puts(\"-1\");\n\tfor(int u=1;u<n;u++)\n\t  for(int i=head[u];~i;i=g[i].nxt)if(!g[i].c)\n\t\tf[g[i].v-n+1]=u;\n\tAns(n);\n\tfor(int u=1;u<=n;u++)if(!vis[u])return 0*puts(\"-1\");\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",x[i],f[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tputs(\"-1\"); return 0;\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    if(flow.used[i] == -1 || flow.used[p[i]] == -1) {\n      cout << -1 << endl;\n      return 0;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1)/*,bel[x].push_back(i)*/;\n\t}Rep(i,1,n)add(i,T,1);\n\treturn 0;\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=400005;\nvector<int> bel[N];\nint cur[N],from[N],S,T,ne[N],a[N],b[N],dis[N],flag[N],x,y,n,m,fi[N],tot,zz[N],sl[N];\nqueue<int>Q;\nvoid jb(int x,int y,int z){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n\tsl[tot]=z;\n\tne[++tot]=fi[y];\n\tfi[y]=tot;\n\tzz[tot]=x;\n\tsl[tot]=0;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,-1,sizeof dis);\n\tdis[S]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]==-1){\n\t\t\t\tdis[zz[i]]=dis[now]+1;\n\t\t\t\tQ.push(zz[i]);\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&dis[zz[i]]==dis[x]+1&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\ty-=b;\n\t\t\ts+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=0;T=2*n;\n\ttot=1;\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tjb(S,i+n,1);\n\t\twhile (x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tjb(i+n,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)jb(i,T,1);\n\tint ans=0;\n\twhile (bfs()){\n\t\tfor (int i=S;i<=T;i++)cur[i]=fi[i];\n\t\tans+=dfs(S,1e9);\n\t}\n\tif (ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=fi[i+n];j;j=ne[j])\n\t\t\tif (zz[j]&&!sl[j]){\n\t\t\t\tflag[zz[j]]=1;\n\t\t\t\tb[i]=zz[j];\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])Q.push(i);\n\tans=0;\n\tmemset(flag,0,sizeof flag);\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tans++;\n\t\tfor (int i=0;i<bel[now].size();i++)\n\t\t\tif (!flag[bel[now][i]]){\n\t\t\t\tflag[bel[now][i]]=1;\n\t\t\t\ta[bel[now][i]]=now;\n\t\t\t\tQ.push(b[bel[now][i]]);\n\t\t\t}\n\t}\n\tif (ans!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define title \"title\"\n#define ll long long\n#define ull unsigned ll\n#define fix(x) fixed<<setprecision(x)\n#define pii pair<int,int>\n#define vint vector<int>\n#define pb push_back\nusing namespace std;\nvoid Freopen(){\n\tfreopen(title\".in\",\"r\",stdin);\n\tfreopen(title\".out\",\"w\",stdout);\n}\nint read(){\n\tint g=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||'9'<ch){if(ch=='-')f=-1;ch=getchar();}\n\twhile('0'<=ch&&ch<='9'){g=g*10+ch-'0';ch=getchar();}\n\treturn g*f;\n}\nconst int N=1e5+5;\nconst int INF=1e9;\nstruct Edge{\n\tint to,ne,c;\n}e[N<<4];\nstruct Line{\n\tint x,y;\n}line[N];\nint h[N<<1],cnt=1,dis[N<<1],n,S,T,id[N];\nvint G[N];\nvoid add(int x,int y,int c){\n\te[++cnt]=Edge{y,h[x],c};\n\th[x]=cnt;\n\te[++cnt]=Edge{x,h[y],0};\n\th[y]=cnt;\n}\nbool bfs(int S,int T){\n\tqueue<int>q;\n\tfor(int i=1;i<=T;i++)dis[i]=0;\n\tdis[S]=1;q.push(S);\n\twhile(q.size()){\n\t\tint x=q.front();q.pop();\n\t\tif(x==T)return true;\n\t\tfor(int i=h[x];i;i=e[i].ne){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]||!e[i].c)continue;\n\t\t\tdis[y]=dis[x]+1;\n\t\t\tq.push(y);\n\t\t}\n\t}return false;\n}\nint dfs(int x,int maxn,int T){\n\tif(x==T||!maxn)return maxn;\n\tint dt=0,re=0;\n\tfor(int i=h[x];i;i=e[i].ne){\n\t\tint y=e[i].to;\n\t\tif(dis[y]!=dis[x]+1||!e[i].c)continue;\n\t\tdt=dfs(y,min(maxn,e[i].c),T);\n\t\tif(!dt)dis[y]=0;\n\t\te[i].c-=dt,e[i^1].c+=dt;\n\t\tmaxn-=dt,re+=dt;\n\t\tif(!maxn)return re;\n\t}return re;\n}\nint dinic(int S,int T){\n\tint re=0;\n\twhile(bfs(S,T))re+=dfs(S,INF,T);\n\treturn re;\n}\nbool solve(){\n\tfor(int x=1;x<n;x++)for(int i=h[x];i;i=e[i].ne){\n\t\tint y=e[i].to;\n\t\tif(y==S||e[i].c)continue;\n\t\tid[x]=y-n+1;\n\t}int su=0;\n\tqueue<int>q;q.push(n);\n\twhile(q.size()){\n\t\tint x=q.front();\n\t\tsu++;q.pop();\n\t\tint siz=G[x].size();\n\t\tfor(int i=0;i<siz;i++){\n\t\t\tint t=G[x][i];\n\t\t\tif(id[t])line[t]=Line{x,id[t]},q.push(id[t]),id[t]=0;\n\t\t}\n\t}return su==n;\n}\nsigned main(){\n\tn=read(),S=(n<<1)-1,T=S+1;\n\tfor(int i=1;i<n;i++)add(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint nu=read();\n\t\tadd(S,i,1);\n\t\tfor(int j=1;j<=nu;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n)add(i,x+n-1,1);\n\t\t\tG[x].pb(i);\n\t\t}\n\t}\n\tif(dinic(S,T)!=n-1)return puts(\"-1\"),signed();\n\tif(!solve())return puts(\"-1\"),signed();\n\tfor(int i=1;i<n;i++)cout<<line[i].x<<' '<<line[i].y<<'\\n';\n\treturn signed();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n\nusing namespace std;\n\ntypedef long long ll;\n\nmt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n\nstruct edge\n{\n    int a, b, cap, ind;\n};\n\nconst int N = 4e5 + 7;\n\nvector <int> g[N];\nvector <edge> e;\n\nvoid add(int a, int b, int c, int ind)\n{\n    g[a].push_back(e.size());\n    e.push_back({a, b, c, ind});\n}\n\nvoid add_edge(int a, int b, int c, int ind)\n{\n    add(a, b, c, ind);\n    add(b, a, 0, -1);\n}\n\nint dist[N];\nint ptr[N];\n\nint s, t;\n\nint dfs(int v, int fl = 1e9)\n{\n    if (v == t)\n    {\n        return fl;\n    }\n    for (int &i = ptr[v]; i < (int) g[v].size(); i++)\n    {\n        int ind = g[v][i];\n        if (dist[e[ind].b] == dist[v] + 1 && e[ind].cap > 0)\n        {\n            int go = dfs(e[ind].b, min(fl, e[ind].cap));\n            if (go)\n            {\n                e[ind].cap -= go;\n                e[ind ^ 1].cap += go;\n                return go;\n            }\n        }\n    }\n    return 0;\n}\n\nbool bfs()\n{\n    for (int i = 0; i <= t; i++)\n    {\n        dist[i] = -1;\n        ptr[i] = 0;\n    }\n    queue <int> q;\n    q.push(s);\n    dist[s] = 0;\n    while (!q.empty())\n    {\n        int v = q.front();\n        q.pop();\n        for (int ind : g[v])\n        {\n            if (e[ind].cap > 0 && dist[e[ind].b] == -1)\n            {\n                dist[e[ind].b] = dist[v] + 1;\n                q.push(e[ind].b);\n            }\n        }\n    }\n    return dist[t] != -1;\n}\n\nint main()\n{\n#ifdef ONPC\n    freopen(\"a.in\", \"r\", stdin);\n#endif\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    s = n + n;\n    t = n + n + 1;\n    int edg = 0;\n    vector <vector <int> > g(n);\n    vector <vector <int> > gr(n);\n    for (int i = 0; i < n - 1; i++)\n    {\n        add_edge(s, i, 1, -1);\n        int e;\n        cin >> e;\n        while (e--)\n        {\n            int v;\n            cin >> v;\n            v--;\n            g[i].push_back(v);\n            gr[v].push_back(i);\n            add_edge(i, n - 1 + v, 1, edg++);\n        }\n    }\n    for (int i = 0; i < n; i++) add_edge(n - 1 +  i, t, 1, -1);\n    int ans = 0;\n    while (bfs())\n    {\n        while (int x = dfs(s, 1e9))\n        {\n            ans += x;\n        }\n    }\n    if (ans != n - 1)\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    vector <int> mt(n - 1, -1);\n    vector <int> rmt(n, -1);\n    vector <int> op(n - 1, -1);\n    for (auto c : e)\n    {\n        if (c.ind != -1 && c.cap == 0)\n        {\n            int a = c.a, b = c.b - (n - 1);\n            mt[a] = b;\n            rmt[b] = a;\n        }\n    }\n    set <int> q;\n    for (int i = 0; i < n; i++) if (rmt[i] == -1) q.insert(i);\n    set <int> t;\n    for (int i = 0; i < n - 1; i++) t.insert(i);\n    while (!q.empty())\n    {\n        int who = *q.begin();\n        q.erase(who);\n        vector <int> del;\n        for (int ok : gr[who])\n        {\n            if (t.count(ok))\n            {\n                q.insert(mt[ok]);\n                op[ok] = who;\n                del.push_back(ok);\n            }\n        }\n        for (int x : del) t.erase(x);\n    }\n    if (*min_element(op.begin(), op.end()) == -1)\n    {\n        cout << -1 << '\\n';\n        return 0;\n    }\n    for (int i = 0; i < n - 1; i++)\n    {\n        cout << mt[i] + 1 << ' ' << op[i] + 1 << '\\n';\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=100005;\nstruct edge\n{\n\tint to,nxt;\n}e[N]; int n,x,y,cnt,head[N],frm[N],tim[N],pre[N],q[N];\ninline void addedge(CI x,CI y)\n{\n\te[++cnt]=(edge){y,head[x]}; head[x]=cnt;\n}\n#define to e[i].to\ninline bool find(CI now,CI t)\n{\n\tfor (RI i=head[now];i;i=e[i].nxt) if (tim[to]!=t)\n\tif (tim[to]=t,!frm[to]||find(frm[to],t)) return frm[to]=now,1; return 0;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),i=1;i<n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=x;++j) scanf(\"%d\",&y),addedge(y,i);\n\tfor (i=2;i<=n;++i) if (!find(i,i)) return puts(\"-1\"),0;\n\tRI H=0,T=1; q[1]=1; while (H<T)\n\t{\n\t\tint now=q[++H]; for (i=head[now];i;i=e[i].nxt)\n\t\tif (!pre[to]) pre[to]=now,q[++T]=frm[to];\n\t}\n\tif (T!=n) return puts(\"-1\"),0;\n\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",pre[i],frm[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define N 500001\nusing namespace std;\nint n,du[N];\nvector<int>point[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tpoint[i].resize(p+1);\n\t\tpoint[i][0]=p;\n\t\tfor (int j=1;j<=p;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpoint[i][j]=x;\n\t\t\tdu[x]++;\n\t\t}\n\t}\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint times=0;\n\t\tfor (int j=1;j<=point[i][0];j++)\n\t\t{\n\t\t\tif (du[point[i][j]]==1) times++;\n\t\t}\n\t\tif (times>1)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (du[i]==0){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\n\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] == d[to[i]] + 1 && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\tcur[x] = fi[x];\n\tif(!(-- co[d[x]])) d[S] = T;\n\t++ co[++ d[x]];\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\tco[0] = T; while(d[S] < T) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=100005;\nset<int> E[N],app[N];\nint A[N],B[N];\nset<pii> s;\nint n,c,w;\n\nvoid GG(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n-1){\n\t\tread(c);\n\t\trep(j,1,c){\n\t\t\tread(w);\n\t\t\tE[i].insert(w);\n\t\t\tapp[w].insert(i);\n\t\t}\n\t}\n\trep(i,1,n){\n\t\ts.insert(mp(app[i].size(),i));\n\t}\n\twhile(s.size()>=2){\n\t\tint x=s.begin()->se;\n\t\ts.erase(s.begin());\n\t\tif(!app[x].size())GG();\n\t\tint k=*app[x].begin();\n\t\tfor(auto t:app[x])\n\t\t\tif(E[t].size()<E[k].size())k=t;\n\t\tif(E[k].size()<app[x].size())GG();\n\t\tif(E[k].size()<2)GG();\n\t\tint U=*E[k].begin();\n\t\tint V=*(--E[k].end());\n\t\tif(x==U)A[k]=x,B[k]=V;\n\t\telse A[k]=x,B[k]=U;\n\t\tE[k].erase(x);\n\t\tapp[x].erase(k);\n\t\tfor(auto y:E[k]){\n\t\t\ts.erase(mp(app[y].size(),y));\n\t\t\tapp[y].erase(k);\n\t\t\ts.insert(mp(app[y].size(),y));\n\t\t}\n\t\tfor(auto t:app[x])\n\t\t\tE[t].erase(x);\n\t}\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",A[i],B[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--, q[a[i][j]].insert(i);\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.FF(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n2020.03.15\n\n\n\n bfs \n\n#endif\n#include <cstdio>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nint head[maxn << 1], nxt[maxn << 3], to[maxn << 3], cap[maxn << 3], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f;\n\t\twhile((f = dinic(s, t)))\n\t\t\tflow += f;\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[to[i] - n] = u;\n\t\t\t\tansy[to[i] - n] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back(make_tuple(x,i,mxfl::adde(x,i+n,1)));\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=2*::Maxn,Maxm=4*::Maxn;\n\tint S,T,cnt,h[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs())ans+=dfs(S,INT_MAX);\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\n#define MAX_V 222222\nstruct edge{int to;long long cap,rev;};\n\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,long long cap){\n\tG[from].push_back((edge){to,cap,G[to].size()});\n\tG[to].push_back((edge){from,0,G[from].size()-1});\n}\n\nvoid bfs(int s){\n\tmemset(level,-1,sizeof(level));\n\tqueue<int> que;\n\tlevel[s] = 0;\n\tque.push(s);\n\twhile(!que.empty())\t{\n\t\tint v = que.front();que.pop();\n\t\tfor(int i = 0;i < G[v].size();++i){\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[e.to] < 0){\n\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\tque.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int v ,int t,long long f){\n\tif(v == t)return f;\n\tfor(int &i = iter[v];i < G[v].size() ;++i){\n\t\tedge &e = G[v][i];\n\t\tif(e.cap > 0 && level[v] < level[e.to]){\n\t\t\tlong long d = dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d > 0){\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nlong long Dinic(int s,int t){\n\tlong long flow = 0;\n\twhile(1){\n\t\tbfs(s);\n\t\tif(level[t] < 0)return flow;\n\t\tmemset(iter,0,sizeof(iter));\n\t\tlong long f;while((f = dfs(s,t,INF)) > 0)flow += f;\n\t}\n}\n\nint E = MAX_V / 2;\nint s = MAX_V - 2;\nint g = MAX_V - 1;\nint mp[MAX_V/2];\nint rmp[MAX_V/2];\nbool used[MAX_V/2];\nbool visited[MAX_V/2];\n\nvector<vector<int>> v(MAX_V / 2);\nvector<vector<int>> nv(MAX_V / 2);\nvector<pair<int,pair<int,int>>> ans;\n\nvoid dfs(int num){\n\tvisited[num] = true;\n\tREP(i,nv[num].size()){\n\t\tif(!visited[nv[num][i]]){\n\t\t\tans.PB(MP(rmp[nv[num][i]], MP(num, nv[num][i])));\n\t\t\tdfs(nv[num][i]);\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\tint n;cin >> n;\n\tREP(i,n) {\n\t\tif(i != n -1)add_edge(s,i,1);\n\t\tadd_edge(E+i,g,1);\n\t}\n\t\t\n\tREP(i,n-1){\n\t\t\n\t\tint e;cin >> e;\n\t\tREP(j,e){\n\t\t\tint tmp;cin >> tmp;tmp--;\n\t\t\tv[i].EB(tmp);\n\t\t\tadd_edge(i, E+tmp, 1);\n\t\t}\n\t}\n\t\n\tint seica = Dinic(s, g);\n\t//cout << \"seica is \" << seica << endl;\n\tif(seica != n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tREP(i,n-1) {\n\t\tREP(j,G[i].size()){\n\t\t\tif(G[i][j].cap == 0){\n\t\t\t\tmp[i] = G[i][j].to - E;\n\t\t\t\trmp[mp[i]] = i;\n\t\t\t\tused[mp[i]] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tREP(i,n-1){\n\t\tREP(j,v[i].size()){\n\t\t\tif(v[i][j] != mp[i])nv[v[i][j]].EB(mp[i]);\n\t\t}\n\t}\n\t\n\tREP(i,n){\n\t\tif(!used[i])dfs(i);\n\t}\n\t\n\t//cout << \"ans is \" << ans.size() << endl;\n\t//SHOW1d(used,n);\n\t//SHOW1d(mp,n);\n\t//SHOW1d(rmp,n);\n\tif(ans.size() == n-1){\n\t\tsort(ALL(ans));\n\t\tREP(i,ans.size()){\n\t\t\tcout << ans[i].SE.FI + 1 << \" \" << ans[i].SE.SE + 1 << endl;\n\t\t}\n\t}\n\telse {\n\t\tcout << -1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU \n// #pragma GCC optimize(\"O3\")  // CPU \n// #pragma GCC optimize(\"unroll-loops\")  // \n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// \n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nvector<int>rev[110000];\nint ans[110000];\nint fr[110000];\nint t[210000];\nint n;\nvoid dfs(int a){\n\tt[a]=1;\n\tif(a<n-1){\n\t\tfor(int i=0;i<v[a].size();i++){\n\t\t\tint to=v[a][i]+n-1;\n\t\t\tif(t[to])continue;\n\t\t\tdfs(to);\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<rev[a-n+1].size();i++){\n\t\t\tint to=rev[a-n+1][i];\n\t\t\tif(t[to])continue;\n\t\t\tfr[to]=a-n+1;\n\t\t\tdfs(to);\n\t\t}\n\t}\n\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tn=a;\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t\trev[c].push_back(i);\n\t\t}\n\t}\n\tdfs(a);\n\tfor(int i=0;i<a-1;i++){\n\t\t// std::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=0;j<v[i].size();j++){\n\t\t\tif(fr[i]==v[i][j])continue;\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\tans[i]=to-(a-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",fr[i]+1,ans[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 1e5 + 5;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nbool vis[MAXN];\nint n, f[MAXN], size[MAXN]; vector <int> a[MAXN];\nset <int> b[MAXN]; set <pair <int, int>> st;\npair <int, int> ans[MAXN];\nint find(int x) {\n\tif (f[x] == x) return x;\n\telse return f[x] = find(f[x]);\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n - 1; i++) {\n\t\tint k; read(k); size[i] = k;\n\t\tst.insert(make_pair(k, i));\n\t\twhile (k--) {\n\t\t\tint x; read(x);\n\t\t\ta[i].push_back(x);\n\t\t\tb[x].insert(i);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tf[i] = i;\n\twhile (!st.empty()) {\n\t\tif ((*st.begin()).first == 1) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tint tmp = (*st.begin()).second, tx = 0, ty = 0;\n\t\tvis[tmp] = true, st.erase(st.begin());\n\t\tfor (auto x : a[tmp])\n\t\t\tif (find(x) != find(a[tmp][0])) {\n\t\t\t\ttx = x, ty = a[tmp][0];\n\t\t\t\tans[tmp] = make_pair(tx, ty);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tint x = find(tx), y = find(ty);\n\t\tif (b[x].size() < b[y].size()) swap(x, y); f[y] = x;\n\t\tfor (auto v : b[y]) {\n\t\t\tif (b[x].count(v)) {\n\t\t\t\tif (!vis[v]) {\n\t\t\t\t\tst.erase(make_pair(size[v], v));\n\t\t\t\t\tst.insert(make_pair(--size[v], v));\n\t\t\t\t}\n\t\t\t} else b[x].insert(v);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\nint n,S,T;\nint fa[N],match[N];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\tscanf(\"%d\",&m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\tscanf(\"%d\",&k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tgap[0]=T;\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,2,n){\n\t\tprintf(\"%d %d\\n\",fa[i],i);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[orig[1]]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\tfor(auto t : occ[orig[0]]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\n\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] == d[to[i]] + 1 && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\tcur[x] = fi[x];\n\tif(!(-- co[d[x]])) d[S] = T;\n\t++ co[++ d[x]];\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\trandom_shuffle(e[i].begin(), e[i].end());\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\tco[0] = T; while(d[S] < T) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\ntypedef unsigned long long lu;\ntypedef long long li;\ntypedef pair<int, int> pii;\nconst int mod = 1e9 + 7;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x = Sub(x - y); }\ninline int Mul(int x, int y) { return (int)((lu)x * y % mod); }\ninline int Mul(int x, int y, int z) { return (int)((lu)x * y % mod * z % mod); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) { return Pow(x, mod - 2); }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\n\n// ----------------------------------------\n\nnamespace dinic {\n  const int maxn = 1e5, maxm = 1e6;\n  typedef int FlowType;\n  const FlowType inf_f = ~0U >> 1;\n\n  void Init(int n);\n  void AddEdge(int u, int v, FlowType cap, li id);\n  FlowType Solve(int s, int t);\n  vector< pair<li, FlowType> > Result(void);\n}\n\nnamespace dinic {\n  struct Edge {\n    int v;\n    li id;\n    FlowType cap, cap0;\n  } edge[maxm << 1];\n\n  int n, m, s, t;\n  vector<int> g[maxn];\n\n  void Init(int _n) {\n    n = _n, m = 0;\n    for (int i = 0; i < n; ++i) g[i].clear();\n  }\n\n  void AddEdge(int u, int v, FlowType c, li id = -1) {\n    g[u].push_back(m);\n    edge[m++] = (Edge){v, id, c, c};\n    g[v].push_back(m);\n    edge[m++] = (Edge){u, id, 0, 0};\n  }\n\n  int iter[maxn], dist[maxn];\n\n  bool Bfs(void) {\n    queue<int> que;\n    que.push(s);\n    FILL(dist, n, -1);\n    dist[s] = 0;\n    while (!que.empty()) {\n      int u = que.front(); que.pop();\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap && dist[e.v] == -1) {\n          dist[e.v] = dist[u] + 1;\n          que.push(e.v);\n        }\n      }\n    }\n    return dist[t] >= 0;\n  }\n\n  FlowType Dfs(int u, FlowType f) {\n    if (u == t) return f;\n    FlowType sum = 0;\n    for (int &i = iter[u]; i < g[u].size(); ++i) {\n      Edge &e = edge[g[u][i]], &rev = edge[g[u][i] ^ 1];\n      if (e.cap && dist[e.v] == dist[u] + 1) {\n        FlowType res = Dfs(e.v, min(f - sum, e.cap));\n        e.cap -= res;\n        rev.cap += res;\n        if ((sum += res) == f) break;\n      }\n    }\n    return sum;\n  }\n\n  FlowType Solve(int _s, int _t) {\n    s = _s, t = _t;\n    FlowType ans = 0;\n    while (Bfs()) {\n      FILL(iter, n, 0);\n      ans += Dfs(s, inf_f);\n    }\n    return ans;\n  }\n\n  vector< pair<li, FlowType> > Result(void) {\n    vector< pair<li, FlowType> > ans;\n    for (int u = 0; u < n; ++u) {\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap < e.cap0 && e.id != -1) {\n          ans.push_back(make_pair(e.id, e.cap0 - e.cap));\n        }\n      }\n    }\n    return ans;\n  }\n}\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\nint n;\nvector<int> E[maxn];\nvector<int> F[maxn];\n\nint match[maxn], par[maxn];\nint A[maxn], B[maxn];\n\nvoid NoSolution(void) {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    while (c--) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      E[i].push_back(x);\n      F[x].push_back(i);\n    }\n  }\n\n  // root = 0\n  int L = 0, R = n, S = R + n - 1, T = S + 1, N = T + 1;\n  dinic::Init(N);\n  for (int i = 1; i < n; ++i) {\n    dinic::AddEdge(S, L + i, 1, -1);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    dinic::AddEdge(R + i, T, 1, -1);\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j : F[i]) {\n      dinic::AddEdge(L + i, R + j, 1, (li)i * n + j);\n    }\n  }\n  int flow = dinic::Solve(S, T);\n  if (flow < n - 1) NoSolution();\n\n  vector< pair<li, int> > way = dinic::Result();\n  for (pair<li, int> p : way) {\n    int x = (int)(p.first / n), y = (int)(p.first % n);\n    match[y] = x;\n  }\n\n  queue<int> que;\n  que.push(0);\n  FILL(par, n, -1);\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (int j : F[u]) {\n      int i = match[j];\n      if (par[i] == -1) {\n        par[i] = u;\n        A[j] = i;\n        B[j] = u;\n        que.push(i);\n      }\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    if (par[i] == -1) NoSolution();\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    printf(\"%d %d\\n\", A[i] + 1, B[i] + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nconst int N=500010;\nint n,m,i,j,k,ans[N][2],d[N],head,tail,cnt,x,fa[N];\nvector<int> a[N];\nset<int> b[N],c,e[N];\nbool ok[N];\nint find(int x){\n\tif (x==fa[x]) return x; else {fa[x]=find(fa[x]);return fa[x];}\n}\nvoid pp(int x,int y){\n\tint i=find(x),j=find(y);fa[i]=j;\n}\nvoid doit(int x){ans[++cnt][0]=x;ok[x]=true;set<int>::iterator it=b[x].begin();c.erase(x);\n\tfor (int i=0;i<a[*it].size();i++) if (find(a[*it][i])!=find(x)){ans[cnt][1]=a[*it][i];break;}int xx=*it;\n\tfor (int i=0;i<a[xx].size();i++){b[a[xx][i]].erase(xx);\n\tif (b[a[xx][i]].size()==1&&!ok[a[xx][i]]) d[++tail]=a[xx][i],\n\tc.erase(a[xx][i]);}pp(ans[cnt][0],ans[cnt][1]);\n}\nint main(){\n\tscanf(\"%d\",&n);for (i=1;i<=n-1;i++){scanf(\"%d\",&m);for (j=1;j<=m;j++) scanf(\"%d\",&x),a[i].push_back(x),b[x].insert(i);}\n\tfor (i=1;i<=n;i++) c.insert(i);for (i=1;i<=n;i++) fa[i]=i;\n\thead=1;tail=0;for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) d[++tail]=i,c.erase(i);\n\t//for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) doit(i);\n\twhile (cnt!=n-1){\n\t\twhile (head<=tail&&cnt!=n-1){\n\t\t\tx=d[head];if (b[x].size()==0){printf(\"-1\\n\");return 0;} else doit(x);head++;\n\t\t}\n\t\tif (cnt!=n-1) doit(*c.begin());\n\t}for (i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans[i][0],ans[i][1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\n\nstruct UnionFind // UnionFind Tree (0-indexed)\n{\n    vector<int> par, rank;\n    UnionFind(int N) : par(N), rank(N) { REP(i, N) par[i] = i; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (rank[x] < rank[y]) par[x] = y; else par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    vector<set<int>> ves(N);\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        for (auto v : w) ves[i].insert(v);\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        UnionFind uf(N + 1);\n        for (auto pa : ans) uf.unite(pa.first, pa.second);\n        REP(i, N) if (!uf.same(1, i + 1)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].first)) exit(1);\n        REP(i, N - 1) if (!ves[i + 1].count(ans[i].second)) exit(1);\n\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size();i<len;i++)if(!vis2[bel[x][i]]){\n\t\t\tvis2[bel[x][i]]=1,nxt[bel[x][i]]=x,q.push(id[bel[x][i]]);\n\t\t}\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    ////////\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\twhile(d[s]<t+2)copy(fr+1,fr+t+1,cur+1),res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tclr(vis),flow+=dfs(S,INF);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nvector<int> hv[200005];\nstruct edge\n{\n\tint to, cap, rev;\n}E[400005];\nvector<int> G[200005];\n\nvoid add_edge(int u, int v, int c)\n{\n\tE[m].to = v;\n\tE[m].cap = c;\n\tE[m].rev = m ^ 1;\n\tG[u].push_back(m ++);\n\tE[m].to = u;\n\tE[m].cap = 0;\n\tE[m].rev = m ^ 1;\n\tG[v].push_back(m ++);\n}\n\nint dis[200005], cur[200005];\nbool bfs()\n{\n\trep1(i, 2 * n) dis[i] = -1;\n\tqueue<int> que;\n\tque.push(0);\n\tdis[0] = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i, G[v].size()) {\n\t\t\tint ce = G[v][i];\n\t\t\tif(E[ce].cap > 0 && dis[E[ce].to] == -1) {\n\t\t\t\tque.push(E[ce].to);\n\t\t\t\tdis[E[ce].to] = dis[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2 * n] == -1) return false;\n\trep(i, 2 * n + 1) cur[i] = 0;\n\treturn true;\n}\n\nint dfs(int v, int maxf)\n{\n\tif(v == 2 * n) return maxf;\n\tif(maxf == 0) return 0;\n\tint ret = 0;\n\tfor(; cur[v] < G[v].size(); cur[v] ++) {\n\t\tint ce = G[v][cur[v]];\n\t\tif(dis[E[ce].to] == dis[v] + 1 && E[ce].cap > 0) {\n\t\t\tint cf = dfs(E[ce].to, min(maxf - ret, E[ce].cap));\n\t\t\tE[ce].cap -= cf;\n\t\t\tE[E[ce].rev].cap += cf;\n\t\t\tret += cf;\n\t\t\tif(ret == maxf) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint lp[200005], par[200005];\n\nint dinic()\n{\n\tint ret = 0;\n\twhile(bfs()) ret += dfs(0, INF);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n - 1) {\n\t\tint cs;\n\t\tscanf(\"%d\", &cs);\n\t\thv[i].resize(cs);\n\t\trep(j, cs) {\n\t\t\tscanf(\"%d\", &hv[i][j]);\n\t\t\tadd_edge(hv[i][j], i + n, 1);\n\t\t}\n\t\tadd_edge(i + n, n * 2, 1);\n\t}\n\trep1(i, n) add_edge(0, i, 1);\n\tif(dinic() != n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\trep1(i, n) if(dis[i] == -1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\t\n\trep1(i, 2 * n - 1) rep(j, G[i].size()) {\n\t\tint ce = G[i][j];\n\t\tif(E[ce].cap == 0 && dis[E[ce].to] == dis[i] - 1) {\n\t\t\tpar[i] = E[ce].to;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\trep1(i, n) if(par[i] != 0) lp[par[i] - n] = i;\n\trep1(i, n - 1) printf(\"%d %d\\n\", par[i + n], lp[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for (int i = a; i <= b; i++)\n#define per(i, a, b) for (int i = a; i >= b; i--)\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef long long ll;\n\ntemplate <typename _T>\ninline void read(_T &f) {\n\tf = 0; _T fu = 1; char c = getchar();\n\twhile (c < '0' || c > '9') { if (c == '-') { fu = -1; } c = getchar(); }\n\twhile (c >= '0' && c <= '9') { f = (f << 3) + (f << 1) + (c & 15); c = getchar(); }\n\tf *= fu;\n}\n\ntemplate <typename T>\nvoid print(T x) {\n\tif (x < 0) putchar('-'), x = -x;\n\tif (x < 10) putchar(x + 48);\n\telse print(x / 10), putchar(x % 10 + 48);\n}\n\ntemplate <typename T>\nvoid print(T x, char t) {\n\tprint(x); putchar(t);\n}\n\nconst int N = 2e5 + 5, M = 8e5 + 5;\n\nstruct edge_t { int u, v, next, cap, flow; } G[M];\n\nvector <int> adj[N];\nqueue <int> q;\nint head[N], nowhead[N], d[N];\nint n, m, s, t, tot = 1;\n\ninline void addedge(int u, int v, int cap) {\n\tG[++tot] = (edge_t) {u, v, head[u], cap, 0}, head[u] = tot;\n\tG[++tot] = (edge_t) {v, u, head[v], 0, 0}, head[v] = tot;\n}\n\nint bfs() {\n\tmemset(d, 0, sizeof(d));\n\td[s] = 1; q.push(s);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (!d[v] && G[i].cap > G[i].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[t];\n}\n\nint dfs(int u, int Flow) {\n\tif (u == t || !Flow) return Flow;\n\tint f, flow = 0;\n\tfor (int &i = nowhead[u]; i; i = G[i].next) {\n\t\tint v = G[i].v;\n\t\tif (d[v] == d[u] + 1 && (f = dfs(v, min(Flow, G[i].cap - G[i].flow))) > 0) {\n\t\t\tG[i].flow += f; G[i ^ 1].flow -= f;\n\t\t\tflow += f; Flow -= f;\n\t\t\tif (!Flow) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint dinic() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\tmemcpy(nowhead, head, sizeof(nowhead));\n\t\tans += dfs(s, 0x7fffffff);\n\t}\n\treturn ans;\n}\n\nint fa[N], vis[N], match[N], cnt;\n\nint main() {\n\tread(n); s = 0; t = 2 * n;\n\tfor (int i = 1; i < n; i++) {\n\t\tread(m);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tint x; read(x);\n\t\t\tadj[i].push_back(x + n - 1);\n\t\t\tadj[x + n - 1].push_back(i);\n\t\t\taddedge(i, x + n - 1, 1);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) addedge(s, i, 1);\n\tfor (int i = n; i < 2 * n; i++) addedge(i, t, 1);\n\tif (dinic() != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint rt = 0;\n\tfor (int i = head[n * 2]; i; i = G[i].next) {\n\t\tif (G[i].flow == 0) {\n\t\t\trt = G[i].v;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int u = 1; u < n; u++) {\n\t\tfor (int i = head[u]; i; i = G[i].next) {\n\t\t\tint v = G[i].v;\n\t\t\tif (n <= v && v < n * 2 && G[i].flow) match[u] = v;\n\t\t}\n\t}\n\tq.push(rt); vis[rt] = 1;\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (auto v : adj[u]) {\n\t\t\tif (!vis[match[v]]) {\n\t\t\t\tvis[match[v]] = 1;\n\t\t\t\tfa[match[v]] = u;\n\t\t\t\t++cnt;\n\t\t\t\tq.push(match[v]);\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = n; i < 2 * n; i++) {\n\t\tif (fa[i]) {\n\t\t\tprint(fa[i] - n + 1, ' ');\n\t\t\tprint(i - n + 1, '\\n');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2+N*4];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N*2],BZ,dis[N*2];\nEDGE *cur[N*2];\n#define rev(ei) (e+(int((ei)-e)^1))\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]+1==dis[x]){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\tif (!--gap[dis[x]])\n\t\tBZ=0;\n\t++dis[x];\n\t++gap[dis[x]];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (BZ)\n\t\tr+=dfs(S,INF);\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nnamespace flow {\n    struct Edge {\n        int nv, f, c;\n    };\n    vector<Edge> edges;\n    vector<vector<int>> e;\n    vector<int> dist;\n    vector<int> pos;\n\n    void init(int n) {\n        e.resize(n);\n        dist.resize(n);\n        pos.resize(n);\n    }\n\n    void addEdge(int v1, int v2, int c) {\n        e[v1].push_back(sz(edges));\n        edges.push_back({v2, 0, c});\n        e[v2].push_back(sz(edges));\n        edges.push_back({v1, 0, 0});\n    }\n\n    int dfs(int v, int t, int cur) {\n        if (v == t)\n            return cur;\n        while (pos[v] != sz(e[v])) {\n            int ei = e[v][pos[v]];\n            Edge &ce = edges[ei];\n            int nv = ce.nv;\n            int cf = ce.c - ce.f;\n            if (dist[nv] - dist[v] != 1 || cf == 0) {\n                ++pos[v];\n                continue;\n            }\n            int nf = dfs(nv, t, min(cur, cf));\n            if (nf == 0) {\n                ++pos[v];\n                continue;\n            }\n            ce.f += nf;\n            edges[ei ^ 1].f -= nf;\n            return nf;\n        }\n        return 0;\n    }\n\n    bool bfs(int s, int t) {\n        static vector<int> q;\n        q.clear();\n        q.push_back(s);\n        memset(dist.data(), 0x3f, sizeof(int) * sz(dist));\n        dist[s] = 0;\n        for (int i = 0; i < sz(q); ++i) {\n            int v = q[i];\n            int cd = dist[v];\n            for (int ei : e[v]) {\n                Edge const& ce = edges[ei];\n                int cf = ce.c - ce.f;\n                int nv = ce.nv;\n                if (cf == 0 || dist[nv] != IINF)\n                    continue;\n                dist[nv] = cd + 1;\n                if (nv == t)\n                    return true;\n                q.push_back(nv);\n            }\n        }\n        return false;\n    }\n\n    int maxflow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            while (true) {\n                memset(pos.data(), 0, sizeof(int) * sz(pos));\n                int f = dfs(s, t, IINF);\n                if (f == 0)\n                    break;\n                ans += f;\n            }\n        }\n        return ans;\n    }\n}\n\nconst int N = 100179;\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    flow::init(n + (n-1) + 2);\n    int vs = n + (n-1), vt = n + (n-1) + 1;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n            flow::addEdge(x, n + i, 1);\n        }\n    }\n    for (int i = 0; i < n; ++i)\n        flow::addEdge(vs, i, 1);\n    for (int i = 0; i < n - 1; ++i)\n        flow::addEdge(n + i, vt, 1);\n\n    int ans = flow::maxflow(vs, vt);\n    if (ans != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n\n    vector<int> pv(n, -1), ps(n - 1, -1);\n    for (int v = 0; v < n; ++v)\n        for (int ei : flow::e[v]) {\n            auto const& ce = flow::edges[ei];\n            if (ce.f == 1) {\n                pv[v] = ce.nv - n;\n                ps[ce.nv - n] = v;\n            }\n        }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == -1)\n            root = i;\n\n    vector<char> visv(n, 0);\n    vector<ipair> es(n - 1);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es[s] = {v, nv};\n            ++cnt;\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (cnt != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=500005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi E[N],e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\tE[i].pb(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\");\n\trep(i,1,n-1)\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<int> a(2 * N + 2);\n\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf < N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\n\nbool bfs(){\n\tfo(i,1,ed)dis[i]=-1;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (dis[e[p].x]==-1&&e[p].f){\n\t\t\tdis[e[p].x]=dis[x]+1;\n\t\t\tque[++ta]=e[p].x;\n\t\t}\n\t}\n\treturn dis[ed]!=-1;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs())ret+=aug(st,INF);\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\tscanf(\"%d\",&m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\tscanf(\"%d\",&k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tgap[0]=T;\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nnamespace TYC\n{\n\tconst int N = 2e5 + 5, INF = 0x3f3f3f3f;\n\n\tint n, s, t, Head[N], dep[N], cur[N], mat[N], from[N];\n\tstruct edge { int to, next, w; } E[N << 2];\n\tvector<int> Bel[N >> 1]; \n\n\tinline void add(const int u, const int v)\n\t{\n\t\tstatic int ec = 1;\n\t\tE[++ec] = (edge){v, Head[u], 1};\n\t\tHead[u] = ec;\n\t\tE[++ec] = (edge){u, Head[v], 0};\n\t\tHead[v] = ec;\n\t}\n\n\tbool bfs()\n\t{\n\t\tmemcpy(cur, Head, sizeof(int[t + 1]));\n\t\tmemset(dep, 0, sizeof(int[t + 1]));\n\t\tstatic queue<int> q;\n\t\tq.push(s);\n\t\tdep[s] = 1;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = Head[u], v; i; i = E[i].next)\n\t\t\t\tif (E[i].w && !dep[v = E[i].to])\n\t\t\t\t\tdep[v] = dep[u] + 1, q.push(v);\n\t\t}\n\t\treturn dep[t];\n\t}\n\n\tint dfs(const int u, const int mn)\n\t{\n\t\tif (u == t || !mn)\n\t\t\treturn mn;\n\t\tint v, w, used = 0;\n\t\tfor (int &i = cur[u]; i; i = E[i].next)\n\t\t\tif (E[i].w && dep[v = E[i].to] == dep[u] + 1)\n\t\t\t{\n\t\t\t\tw = dfs(v, min(mn - used, E[i].w));\n\t\t\t\tused += w;\n\t\t\t\tE[i].w -= w;\n\t\t\t\tE[i ^ 1].w += w;\n\t\t\t\tif (used == mn)\n\t\t\t\t\treturn used;\n\t\t\t}\n\t\tif (!used)\n\t\t\tdep[u] = -1;\n\t\treturn used;\n\t}\n\n\tint Dinic()\n\t{\n\t\tint ans = 0;\n\t\twhile (bfs())\n\t\t\tans += dfs(s, INF);\n\t\treturn ans;\n\t}\n\n\tbool search()\n\t{\n\t\tstatic queue<int> q;\n\t\tq.push(n);\n\t\tint cnt = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tint x = q.front(), p;\n\t\t\tq.pop();\n\t\t\tcnt++;\n\t\t\tfor (int i : Bel[x])\n\t\t\t\tif (!from[p = mat[i]])\n\t\t\t\t\tfrom[p] = x, q.push(p);\n\t\t}\n\t\treturn cnt == n;\n\t}\n\n\tvoid work()\n\t{\n\t\tscanf(\"%d\", &n);\n\t\tfor (int i = 1, c, j; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &c);\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &j);\n\t\t\t\tif (j != n)\n\t\t\t\t\tadd(j, i + n);\n\t\t\t\tBel[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\ts = n + n, t = s + 1;\n\t\tfor (int i = 1; i < n; i++)\n\t\t\tadd(s, i), add(i + n, t);\n\t\tint flow = Dinic();\n\t\tif (flow != n - 1)\n\t\t\tputs(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor (int u = 1; u < n; u++)\n\t\t\t\tfor (int i = Head[u + n]; i; i = E[i].next)\n\t\t\t\t\tif (E[i].w && E[i].to <= n)\n\t\t\t\t\t{\n\t\t\t\t\t\tmat[u] = E[i].to;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\tif (!search())\n\t\t\t\tputs(\"-1\");\n\t\t\telse\n\t\t\t\tfor (int i = 1; i < n; i++)\n\t\t\t\t\tprintf(\"%d %d\\n\", i, from[i]);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tTYC::work();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(val[i]*e[i][j-1]>=mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,inf=1e9;\nint n,c,p[N],q[N],id[N],x;vector<int> a[N];\nstruct edge{int u,v,c,f;};\nstruct Dinic{\n    vector<edge> e;\n    vector<int> G[N];queue<int> q;\n    int cur[N],d[N],n,m,s,t,ma[N],cnt,p[N],_n;bool vis[N];\n    inline void add(int u,int v,int c){\n        //printf(\"%d %d %d\\n\",u,v,c);\n        e.pb((edge){u,v,c,0});e.pb((edge){v,u,0,0});\n        m=e.size();G[u].pb(m-2);G[v].pb(m-1);\n    }\n    bool bfs(){\n        memset(d,0,sizeof(d));memset(vis,0,sizeof(vis));vis[s]=1;q.push(s);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int &x:G[u]){\n                edge &E=e[x];\n                if(E.c>E.f&&!vis[E.v]) d[E.v]=d[u]+1,vis[E.v]=1,q.push(E.v);\n            }\n        }\n        return vis[t];\n    }\n    int dfs(int u,int a){\n        if(u==t||!a) return a;\n        int flow=0,f;\n        for(int &i=cur[u];i<(int)G[u].size();++i){\n            edge &E=e[G[u][i]];\n            if(d[E.v]==d[u]+1&&(f=dfs(E.v,min(a,E.c-E.f)))){\n                E.f+=f;e[G[u][i]^1].f-=f;\n                flow+=f;a-=f;if(!a) break;\n            }\n        }\n        return flow;\n    }\n    int max_flow(int s,int t){\n        this->s=s;this->t=t;\n        int flow=0;\n        while(bfs()){memset(cur,0,sizeof(cur));flow+=dfs(s,inf);}\n        return flow;\n    }\n    void DFS(int u){\n        ++cnt;vis[u]=1;\n        for(int &x:G[u]){\n            edge &E=e[x];\n            if(E.v!=t&&!vis[ma[E.v]]) p[ma[E.v]-_n]=u-_n,DFS(ma[E.v]);\n        }\n    }\n    void solve(int n){\n        memset(vis,0,sizeof(vis));_n=n;\n        rep(i,2,n){\n            for(int &x:G[i]){\n                edge &E=e[x];\n                if(E.v!=s&&E.f) ma[i]=E.v;\n            }\n        }\n        DFS(n+n);\n        if(cnt!=n) puts(\"-1\");\n        else rep(i,1,n-1) printf(\"%d %d\\n\",i,p[i]);\n    }\n}G;\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);int S=1,T=2*n+1;G.n=T;\n    rep(i,1,n-1) G.add(1,i+1,1);\n    rep(i,1,n-1){\n        scanf(\"%d\",&c);\n        rep(j,0,c-1) scanf(\"%d\",&x),G.add(i+1,x+n,1);\n    }\n    rep(i,1,n-1) G.add(i+n,T,1);\n    int t=G.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    G.solve(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i&&flow;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, M = 200005, inf = 0x3f3f3f3f;\nint n, p[N], fa[N];\nvector<int> E[N], F[N];\n\nnamespace flow {\n\tconst int V = 2 * N, E = 2 * M;\n\tint ans, S, T, tot = 1, nxt[E], fst[V], to[E], f[E], cur[V], d[V];\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; f[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; f[tot] = 0;\n\t}\n\tbool bfs() {\n\t\tstatic int q[E];\n\t\tint st = 0, ed = 0;\n\t\tq[ed++] = S;\n\t\tfor (int i = 1; i <= T; i++) d[i] = -1, cur[i] = fst[i];\n\t\td[S] = 0;\n\t\twhile (st < ed) {\n\t\t\tint u = q[st++];\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (f[i] && d[to[i]] == -1) {\n\t\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\t\tif (to[i] == T) return true;\n\t\t\t\t\tq[ed++] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint aug(int u, int flow) {\n\t\tif (u == T || !flow) return flow;\n\t\tint used = 0;\n\t\tfor (int &i = cur[u], w; i; i = nxt[i])\n\t\t\tif (d[to[i]] == d[u] + 1 && (w = aug(to[i], min(f[i], flow - used)))) {\n\t\t\t\tf[i] -= w, f[i ^ 1] += w;\n\t\t\t\tif ((used += w) == flow) break;\n\t\t\t}\n\t\tif (!used) d[u] = -1;\n\t\treturn used;\n\t}\n\tint dinic() {\n\t\twhile (bfs()) ans += aug(S, inf);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs(int u) {\n\tfor (int v : F[u])\n\t\tif (!fa[p[v]]) {\n\t\t\tfa[p[v]] = u;\n\t\t\tdfs(p[v]);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tflow::S = 2 * (n - 1) + 1, flow::T = 2 * (n - 1) + 2;\n\tfor (int i = 1, k; i < n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tE[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tscanf(\"%d\", &E[i][j]);\n\t\t\tif (E[i][j] != n)\n\t\t\t\tflow::addedge(E[i][j], n - 1 + i, 1);\n\t\t\tF[E[i][j]].push_back(i);\n\t\t}\n\t\tflow::addedge(flow::S, i, 1);\n\t\tflow::addedge(n - 1 + i, flow::T, 1);\n\t}\n\tint x = flow::dinic();\n\tif (x != n - 1) return !puts(\"-1\");\n\tfor (int i = 2; i <= flow::tot; i += 2)\n\t\tif (!flow::f[i] && flow::to[i] != flow::T && flow::to[i ^ 1] != flow::S)\n\t\t\tp[flow::to[i] - n + 1] = flow::to[i ^ 1];\n\tfa[n] = -1, dfs(n);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!fa[i]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x){\n\t\tif (x==T)\n\t\t\treturn 1;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tif (dfs(y)){\n\t\t\t\t\te[i].cap^=1,e[i^1].cap^=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tclr(vis),flow+=dfs(S);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define PRINT(x...) TRACE(printf(x))\n#define WATCHR(a, b) TRACE(for (auto c=a; c!=b;) cout << *(c++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define FU(i, a, b) for (auto i = a; i < b; ++i)\n#define fu(i, b) FU(i, 0, b)\n#define FD(i, a, b) for (auto i = (b) - 1; i >= a; --i)\n#define fd(i, b) FD(i, 0, b)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nll mod(ll a, ll b) {\n  return ((a%b)+b)%b;\n}\n\nint cmp(double x, double y = 0, double tol = 1.e-7) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\nstruct graph {\n  vi dest;  // use sz(dest) as number of arcs\n  vvi adj;  // use sz(adj) as number of vertices\n  int inv(int a) { return a ^ 0x1; }\n  graph(int n = 0) {\n    adj.resize(n);\n  }\n  // Adds an arc to the graph. u is capacity, c is cost.\n  // u is only needed on flows, and c only on min-cost-flow\n  int arc(int i, int j, ll u = 1) {\n    dest.pb(j);\n    adj[i].pb(sz(dest)-1);\n    dest.pb(i);\n    adj[j].pb(sz(dest)-1);\n    cap.pb(u); // For both flows\n    cap.pb(0);\n    return sz(dest)-2;\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  // For both flows!!\n  //\n\n  vll cap, flow;\n\n  int orig(int a) { return dest[inv(a)]; }\n  ll capres(int a) { return cap[a] - flow[a]; }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Max Flow! - Dinic O(n^2 * m)\n  // don't call maxflow with ini == end\n  //\n\n  vi curAdj, d;\n\n  bool MFbfs(int s, int t) {\n    d.assign(sz(adj), INT_MAX/2);\n    curAdj = vi(sz(adj));\n    d[s] = 0;\n    queue<int> Q; Q.push(s);\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (auto i : adj[u]) {\n        int v = dest[i];\n        if (capres(i) > 0 && d[v] == INT_MAX/2) {\n          d[v] = d[u] + 1; Q.push(v);\n        }\n      }\n    }\n    return d[t] != INT_MAX/2;\n  }\n\n  ll MFdfs(int u, int t, ll f) {\n    if (u == t) return f;\n    for(int &i = curAdj[u]; i < adj[u].size(); ++i) {\n      int ar = adj[u][i], v = dest[ar];\n      if (d[v] != d[u]+1 || capres(ar) == 0) continue;\n      ll tmpF = MFdfs(v, t, min(f, capres(ar)));\n      if (tmpF) {\n        flow[ar] += tmpF;\n        flow[inv(ar)] -= tmpF;\n        return tmpF;\n      }\n    }\n    return 0;\n  }\n\n  ll maxflow(int ini, int end) {\n    flow.assign(sz(dest), 0);\n    while (MFbfs(ini, end))\n      while (MFdfs(ini, end, LLONG_MAX/2));\n    ll F = 0;\n    for (int a : adj[ini]) F += flow[a];\n    return F;\n  }\n};\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tgraph G(2 * N + 1);\n\tfu(i, N-1) G.arc(0, 1 + i, 1);\n\tfu(i, N) G.arc(N + i, 2 * N, 1);\n\n\tvvi inc(N);\n\tfu(i, N-1) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x); x--;\n\t\t\tG.arc(1 + i, N + x, 1);\n\t\t\tinc[x].push_back(i);\n\t\t}\n\t}\n\n\tif (G.maxflow(0, 2*N) != (N - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\t// find the match of each set\n\tvi match(N-1);\n\tll root = 0;\n\tfu(i, N) root += i;\n\n\tfu(i, N-1) {\n\t\tfor (int a : G.adj[1 + i])\n\t\t\tif (G.flow[a] == 1) {\n\t\t\t\tmatch[i] = G.dest[a] - N;\n\t\t\t\troot -= G.dest[a] - N;\n\t\t\t}\n\t}\n\n\tif (G.flow[2 * (N - 1) + 2 * root] != 0) while (true);\n\n\tqueue<int> Q;\n\tQ.push(root);\n\tvb mark(N, false);\n\tmark[root] = true;\n\n\tvector<pair<int, int>> ans;\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\n\t\tfor (int s : inc[x]) {\n\t\t\tint y = match[s];\n\t\t\tif (mark[y]) continue;\n\t\t\tmark[y] = true;\n\t\t\tQ.push(y);\n\t\t\tans.emplace_back(x, y);\n\t\t}\n\t}\n\n\tif (ans.size() != N - 1) printf(\"-1\\n\");\n\telse for (auto p : ans) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<ll, ll>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vii = vector<ii>;\nusing vvii = vector<vii>;\nusing vd = vector<ld>;\n\ntemplate<class T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class TIn, class TOut = null_type>\nusing order_tree = tree<TIn, TOut, less<TIn>, rb_tree_tag,\n\ttree_order_statistics_node_update>;\n// .find_by_order(int r) and .order_of_key(TIn v)\n\nconstexpr int INF = 2000000010;\nconstexpr ll LLINF = 9000000000000000010LL;\nconstexpr ld PI = acos(-1);\n\nauto now(){ return chrono::high_resolution_clock::now(); }\nusing TP = decltype(now());\t// time point\nauto duration(TP t1, TP t2){\n\treturn chrono::duration_cast<chrono::microseconds>(t2-t1).count();\n}\n\nstruct UnionFind {\n\tvi par, rank, size; int c;\n\tUnionFind(int n) : par(n), rank(n,0), size(n,1), c(n) {\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }\n\tbool same(int i, int j) { return find(i) == find(j); }\n\tint get_size(int i) { return size[find(i)]; }\n\tint count() { return c; }\n\tint merge(int i, int j) {\n\t\tif ((i = find(i)) == (j = find(j))) return -1; else --c;\n\t\tif (rank[i] > rank[j]) swap(i, j);\n\t\tpar[i] = j; size[j] += size[i];\n\t\tif (rank[i] == rank[j]) rank[j]++;\n\t\treturn j;\n\t}\n};\n\nvoid solve() {\n\tauto start = now();\n\tint N;\n\tcin >> N;\n\tvvi E(N-1);\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tint c;\n\t\tcin >> c;\n\t\tE[i].resize(c);\n\t\tfor (ll &id : E[i]) cin >> id, --id;\n\t}\n\tvi inds(N-1);\n\tiota(inds.begin(), inds.end(), 0);\n\tsort(inds.begin(), inds.end(), [&E](int l, int r) { return E[l].size() < E[r].size(); });\n\n\twhile (duration(start, now()) < 1500000) {\n\t\tbool ok = true;\n\t\tvii edges(N-1);\n\t\tUnionFind uf(N);\n\t\tfor (size_t l = 0, r = 0; ok && l < inds.size(); l = r) {\n\t\t\twhile (r < inds.size() && E[inds[l]].size() == E[inds[r]].size()) ++r;\n\t\t\tshuffle(inds.begin()+l, inds.begin()+r, mt19937(0x94949));\n\n\t\t\tfor (size_t i = l; i < r; ++i) {\n\t\t\t\tint x = inds[i];\n\t\t\t\tunordered_set<int> sn;\n\t\t\t\tvi vec;\n//\t\t\t\tcerr << \"Trying E[\" << x << \"] = {\";\n\t\t\t\tfor (int v : E[x]) {\n\t\t\t\t\tint id = uf.find(v);\n//\t\t\t\t\tcerr << \"(\"<<v<<\", \"<<id<<\") \";\n\t\t\t\t\tif (sn.find(id) != sn.end()) continue;\n\t\t\t\t\tsn.insert(id);\n\t\t\t\t\tvec.push_back(v);\n\t\t\t\t}\n//\t\t\t\tcerr << \"}\" << endl;\n\t\t\t\tif (sn.size() == 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tcerr << \"Final vec:\"; for (int k : vec) cerr << ' ' << k; cerr << endl;\n\t\t\t\tint a = rand() % vec.size(), b;\n\t\t\t\tdo { b = rand() % vec.size(); } while (a == b);\n\t\t\t\ta = vec[a], b = vec[b];\n\t\t\t\tif (a > b) swap(a, b);\n\t\t\t\tuf.merge(a, b);\n\t\t\t\tedges[x] = {a, b};\n\t\t\t}\n\t\t}\n\t\tif (!ok) continue;\n\t\tfor (int i = 0; i < N-1; ++i)\n\t\t\tcout << 1+edges[i].first << ' ' << 1+edges[i].second << '\\n';\n\t\treturn;\n\t}\n\n\tcout << -1 << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(12);\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: wxyww\n* @Date: 2020-04-01 11:25:14\n* @Last Modified time: 2020-04-01 11:49:33\n*/\n#include<cstdio>\n#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\nconst int N = 1000010;\nll read() {\n\tll x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9') {\n\t\tif(c=='-') f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9') {\n\t\tx=x*10+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nvector<int>t[N];\nqueue<int>q;\nint V[N],U[N];\nvector<int>::iterator it;\nstruct node {\n\tint v,nxt,w;\n}e[N << 1];\nint head[N],ejs = 1,cur[N];\nvoid add(int u,int v,int w) {\n\te[++ejs].v = v;e[ejs].nxt = head[u];head[u] = ejs;e[ejs].w = w;\n\te[++ejs].v = u;e[ejs].nxt = head[v];head[v] = ejs;e[ejs].w = 0;\n}\nint dep[N],S,T;\nint bfs() {\n\tq.push(S);\n\tmemset(dep,0,sizeof(dep));\n\tdep[S] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!dep[v] && e[i].w) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[T];\n}\nint dfs(int u,int now) {\n\tif(u == T) return now;\n\tint ret = 0;\n\tfor(int &i = cur[u];i;i = e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif(dep[v] == dep[u] + 1 && e[i].w) {\n\t\t\tint k = dfs(v,min(now - ret,e[i].w));\n\t\t\te[i].w -= k;\n\t\t\te[i ^ 1].w += k;\n\t\t\tret += k;\n\t\t\tif(ret == now) return ret;\n\t\t}\n\t}\n\treturn ret;\n}\nint dinic() {\n\tint ret = 0;\n\twhile(bfs()) {\n\t// puts(\"!!!!\");\n\t\tmemcpy(cur,head,sizeof(cur));\n\t\tret += dfs(S,10000000);\n\t}\n\treturn ret;\n}\nint flag[N];\nint main() {\n\tint n = read();\n\tS = 1,T = n + n;\n\tfor(int i = 2;i <= n;++i)\n\t\tadd(S,i,1);\n\tfor(int i = n + 1;i < n + n;++i)\n\t\tadd(i,T,1);\n\tfor(int i = 2;i <= n;++i) {\n\t\tint tot = read();\n\t\tfor(int j = 1;j <= tot;++j) {\n\t\t\tint x = read();\n\t\t\tt[x].push_back(i);\n\t\t\tif(x == 1) continue;\n\t\t\tadd(i,x + n - 1,1);\n\t\t}\n\t}\n\n\tif(dinic() != n - 1) {\n\t\tputs(\"-1\");return 0;\n\t}\n\n\n\tfor(int u = 2;u <= n;++u)\n\t\tfor(int i = head[u];i;i = e[i].nxt)\n\t\t\tif(!e[i].w)\n\t\t\t\tV[u] = e[i].v - n + 1;\n\n\t// for(int i = 2;i <= n;++i) printf(\"%d \",V[i]);\n\t// puts(\"\");\n\n\tq.push(S);\n\n\twhile(!q.empty()) {\n\t\tint u = q.front();q.pop();\n\t\tfor(int i = head[u];i;i = e[i].nxt) {\n\t\t\tfor(it = t[u].begin();it != t[u].end();++it) {\n\t\t\t\tif(flag[*it]) continue;\n\t\t\t\tflag[*it] = 1;\n\t\t\t\tU[*it] = u;\n\t\t\t\tq.push(V[*it]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tif(!U[i]) {\n\t\t\tputs(\"-1\");return 0;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;++i) {\n\t\tprintf(\"%d %d\\n\",U[i],V[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=S; dis[S]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[T]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]+1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nconst int N=500010;\nint n,m,i,j,k,ans[N][2],d[N],head,tail,cnt,x;\nvector<int> a[N];\nset<int> b[N],c;\nbool ok[N];\nvoid doit(int x){ans[++cnt][0]=x;ok[x]=true;set<int>::iterator it=b[x].begin();c.erase(x);\n\tfor (int i=0;i<a[*it].size();i++) if (!ok[a[*it][i]]){ans[cnt][1]=a[*it][i];break;}int xx=*it;\n\tfor (int i=0;i<a[xx].size();i++){b[a[xx][i]].erase(xx);\n\tif (b[a[xx][i]].size()==1&&!ok[a[xx][i]]) d[++tail]=a[xx][i],\n\tc.erase(a[xx][i]);}\n}\nint main(){\n\tscanf(\"%d\",&n);for (i=1;i<=n-1;i++){scanf(\"%d\",&m);for (j=1;j<=m;j++) scanf(\"%d\",&x),a[i].push_back(x),b[x].insert(i);}\n\tfor (i=1;i<=n;i++) c.insert(i);\n\thead=1;tail=0;for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) d[++tail]=i,c.erase(i);\n\t//for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) doit(i);\n\twhile (cnt!=n-1){\n\t\twhile (head<=tail&&cnt!=n-1){\n\t\t\tx=d[head];if (b[x].size()==0){printf(\"-1\\n\");return 0;} else doit(x);head++;\n\t\t}\n\t\tif (cnt!=n-1) doit(*c.begin());\n\t}for (i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans[i][0],ans[i][1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N],BZ,dis[N];\nEDGE *cur[N];\n#define rev(ei) (e+(int((ei)-e)^1))\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]+1==dis[x]){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\tif (!--gap[dis[x]])\n\t\tBZ=0;\n\t++dis[x];\n\t++gap[dis[x]];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (BZ)\n\t\tr+=dfs(S,INF);\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int maxn = 200100;\nstruct T {\n\tint to, nxt, v;\n} way[maxn << 4];\nint h[maxn], head[maxn], num = 1;\ninline void adde(int x,int y,int v) {\n\tway[++num] = {y, h[x], v}, h[x] = num;\n\tway[++num] = {x, h[y], 0}, h[y] = num;\n}\nint dis[maxn];\ninline bool bfs(int s,int t) {\n\tstd::queue<int> q;\n\tfor(int i = s;i <= t;++i) dis[i] = - 1, head[i] = h[i];\n\tfor(q.push(s), dis[s] = 0;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i = h[t];i;i = way[i].nxt) if(way[i].v && dis[way[i].to] < 0) \n\t\t\tdis[way[i].to] = dis[t] + 1, q.push(way[i].to);\n\t}\n\treturn dis[t] >= 0;\n}\ninline int dfs(int s,int t,int lim) {\n\tif(s == t || !lim) return lim;\n\tint ans = 0, mn;\n\tfor(int & i = head[s];i;i = way[i].nxt)\n\t\tif(dis[way[i].to] == dis[s] + 1 && (mn = dfs(way[i].to, t, std::min(lim, way[i].v)))) {\n\t\t\tway[i].v -= mn;\n\t\t\tway[i ^ 1].v += mn;\n\t\t\tans += mn; lim -= mn;\n\t\t\tif(!lim) break;\n\t\t}\n\treturn ans;\n}\ninline int dinic(int s,int t) {\n\tint ans = 0;\n\tfor(;bfs(s,t);) ans += dfs(s,t,1e9);\n\treturn ans;\n}\nint n;\nstd::vector<int> v[maxn];\nstd::vector<int> to[maxn];\nstd::pair<int,int> ans[maxn];\nint id[maxn], fa[maxn], idx[maxn];\nint main(){\n\tstd::ios::sync_with_stdio(false),std::cin.tie(0);\n\tstd::cin >> n;\n\tfor(int i = 1,x,a;i < n;++i) {\n\t\tstd::cin >> x, adde(0, i, 1);\n\t\tfor(;x--;) {\n\t\t\tstd::cin >> a, v[i].push_back(a);\n\t\t\tif(a != n) adde(i, a + n, 1);\n\t\t}\n\t}\n\tfor(int i = 1;i < n;++i) adde(i + n,n + n + 1,1);\n\tif(dinic(0,n + n + 1) != n - 1) {\n\t\tstd::cout << -1 << '\\n';\n\t\treturn 0;\n\t}\n\tfor(int i = 1;i < n;++i) for(int j = h[i + n];j;j=way[j].nxt) if(way[j].v == 1 && way[j].to < n) {\n\t\tid[way[j].to] = i;\n\t\tidx[i] = way[j].to;\n\t}\n\tfor(int i = 1;i < n;++i) for(int j : v[i])\n\t\tto[j].push_back(id[i]);\n\tstd::queue<int> q; \n\tfor(q.push(n), fa[n] = 1;!q.empty();) {\n\t\tint t = q.front(); q.pop();\n\t\tfor(int i : to[t]) if(!fa[i]) {\n\t\t\tq.push(i), fa[i] = t;\n\t\t\tans[idx[i]] = {i, t};\n\t\t}\n\t}\n\tif(std::count(fa + 1,fa + n + 1,0)) {\n\t\tstd::cout << - 1 << '\\n';\n\t} else {\n\t\tfor(int i = 1;i < n;++i) std::cout << ans[i].first << ' ' << ans[i].second << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nint main()\n{\n\tprintf(\"-1\\n\");\t\n} "
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nint head[maxn << 1], nxt[maxn << 3], to[maxn << 3], cap[maxn << 3], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f;\n\t\twhile((f = dinic(s, t)))\n\t\t\tflow += f;\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[to[i] - n] = u;\n\t\t\t\tansy[to[i] - n] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\nint y[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n\tfo(i,1,T)y[i]=la[i];\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(;y[o];y[o]=ne[y[o]])\n\tif(dep[lb[y[o]]]==dep[o]+1&&c[y[o]])\n\tif(flow(lb[y[o]])){\n\t\tc[y[o]]=0;\n\t\tc[y[o]^1]=1;\n\t\treturn 1;\n\t}\n\tdep[o]=-1;\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[re[lb[y]]][0]=o;\n\t\tbb[re[lb[y]]][1]=lb[y];\n\t\t++oo;\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nvoid cl(int i) {\n    set<int> o;\n    swap(o, q[i]);\n}\n\nvoid cel() {\n    set<pair<int, int> > o;\n    swap(g, o);\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++)\n        p[i] = i, r[i] = 0, cl(i);\n    cel();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < a[i].size(); j++)\n            q[a[i][j]].insert(i);\n        d[i] = a[i].size();\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            return;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n    exit(0);\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    double ts = clock();\n    cin >> n;\n    if (n > 10)\n        exit(1);\n    return 0;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n    }\n    while ((clock() - ts) / CLOCKS_PER_SEC < 3.7) {\n        solve();\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < a[i].size(); j++)\n                swap(a[i][j], a[i][rnd() % (j + 1)]);\n    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <type_traits>\nusing namespace std;\n\nusing ll=int64_t;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) x.begin(),x.end()\nauto& errStream=cerr;\n#ifdef LOCAL\n#define cerr (cerr<<\"-- line \"<<__LINE__<<\" -- \")\n#else\nclass CerrDummy{}cerrDummy;\ntemplate<class T>\nCerrDummy& operator<<(CerrDummy&cd,const T&){\n\treturn cd;\n}\nusing charTDummy=char;\nusing traitsDummy=char_traits<charTDummy>;\nCerrDummy& operator<<(CerrDummy&cd,basic_ostream<charTDummy,traitsDummy>&(basic_ostream<charTDummy,traitsDummy>&)){\n\treturn cd;\n}\n#define cerr cerrDummy\n#endif\n#define REACH cerr<<\"reached\"<<endl\n#define DMP(x) cerr<<#x<<\":\"<<x<<endl\n#define ZERO(x) memset(x,0,sizeof(x))\n#define ONE(x) memset(x,-1,sizeof(x))\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nll read(){\n\tll i;\n\tscanf(\"%\"  SCNd64,&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(ll x,int suc=1){\n\tprintf(\"%\" PRId64,x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341000];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341000];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(b<a)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\n#define CAPITAL\nvoid Yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid No(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nconst int Nmax=100010;\n\nnamespace MaxFlow{\n\tusing CapType=int;\n\tstruct Edge{\n\t\tint to,rev;\n\t\tCapType cap;\n\t};\n\tvector<vector<Edge>> g;\n\tvi itr,level;\n\tvoid Init(int n){\n\t\tg.assign(n,vector<Edge>());\n\t\titr.assign(n,0);\n\t\tlevel.assign(n,0);\n\t}\n\tvoid AddEdge(int from,int to,CapType cap){\n\t\tg[from].PB({to,(int)g[to].size(),cap});\n\t\tg[to].PB({from,(int)g[from].size()-1,0});\n\t}\n\tvoid bfs(int s){\n\t\tfill(level.begin(),level.end(),-1);\n\t\tlevel[s]=0;\n\t\tqueue<int> q;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();q.pop();\n\t\t\tfor(auto e:g[v])if(e.cap>0&&level[e.to]==-1){\n\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\tq.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n\tCapType dfs(int v,int t,CapType f){\n\t\tif(v==t)\n\t\t\treturn f;\n\t\tCapType res=0;\n\t\tfor(int&i=itr[v];i<(int)g[v].size();i++){\n\t\t\tEdge& e=g[v][i];\n\t\t\tif(e.cap>0&&level[e.to]==level[v]+1){\n\t\t\t\tCapType d=dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\t\t\tres+=d;\n\t\t\t\t\tf-=d;\n\t\t\t\t\tif(f<=0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\tCapType Calc(int s,int t){\n\t\tCapType flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]==-1)\n\t\t\t\treturn flow;\n\t\t\tfill(itr.begin(),itr.end(),0);\n\t\t\tflow+=dfs(s,t,inf);\n\t\t}\n\t}\n\tvi Get(){\n\t\tint s=(int(g.size())-2)/2;\n\t\tvi res(s);\n\t\tREP(i,s){\n\t\t\tfor(auto e:g[1+i]){\n\t\t\t\tif(e.cap==0)\n\t\t\t\t\tres[i]=e.to-1-s;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}\n\nvoid Impossible(){\n\tprint(-1);\n\texit(0);\n}\n\nvi g[Nmax];\nint par[Nmax];\nbool vis[Nmax];\nvoid dfs(int v,int p){\n\tif(vis[v])return;\n\tvis[v]=true;\n\tpar[v]=p;\n\tfor(auto to:g[v])\n\t\tdfs(to,v);\n}\n\nsigned main(){\n\tint n=read();\n\tvector<vi> e(n-1);\n\tREP(i,n-1){\n\t\tint c=read();\n\t\te[i].resize(c);\n\t\tREP(j,c)\n\t\t\te[i][j]=read()-1;\n\t}\n\t\n\tMaxFlow::Init(1+n-1+n-1+1);\n\tREP(i,n-1){\n\t\tMaxFlow::AddEdge(0,1+i,1);\n\t}\n\tREP(i,n-1){\n\t\tMaxFlow::AddEdge(1+n-1+i,1+n-1+n-1,1);\n\t}\n\tREP(i,n-1){\n\t\tREP(j,e[i].size())if(e[i][j]>0){\n\t\t\tMaxFlow::AddEdge(1+e[i][j]-1,1+n-1+i,1);\n\t\t}\n\t}\n\tint f=MaxFlow::Calc(0,1+n-1+n-1);\n\tcerr<<f<<endl;\n\tif(f<n-1){\n\t\tImpossible();\n\t}\n\t\n\tvi match=MaxFlow::Get();\n\tcerr<<match<<endl;\n\tREP(i,n-1){\n\t\tfor(auto v:e[match[i]])\n\t\t\tif(i+1!=v)\n\t\t\t\tg[v].PB(i+1);\n\t}\n\t\n\tdfs(0,-1);\n\tREP(i,n)if(!vis[i])\n\t\tImpossible();\n\t\n\tvector<pi> ans(n-1);\n\tREP(i,n-1){\n\t\tans[match[i]]=pi(i+1,par[i+1]);\n\t}\n\t\n\tREP(i,n-1){\n\t\tprint(ans[i].first+1,2);\n\t\tprint(ans[i].second+1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, cur, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v] == cur) {\n        return false;\n    }\n    used[v] = cur;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        ++cur;\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nvector<pii> g[N];\npii ans[N];\nint p[N],vis[N],use[N],la;\nvoid dfs(int u){\n    vis[u]=1;\n    for(pii v:g[u])if(!vis[v.fi]&&!use[v.se]){\n        use[v.se]=1;\n        ans[v.se]={u,v.fi};\n        ++la;\n        dfs(v.fi);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb({p[i],i});//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(la!=n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v]){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        vector<ll> level(N,inf);\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a, b) memset(a, b, sizeof(a))\n#define mcpy(a, b) memcpy(a, b, sizeof(a))\nusing namespace std;\ntypedef long long LL;\nconst int MAXN = 200005;\nconst int MAXM = 400005;\nconst int INF = 0x3f3f3f3f;\n\ntemplate <typename T> inline void read(T &AKNOI) {\n\tT x = 0, flag = 1;\n\tchar ch = getchar();\n\twhile (!isdigit(ch)) {\n\t\tif (ch == '-') flag = -1;\n\t\tch = getchar();\n\t}\n\twhile (isdigit(ch)) {\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}\n\tAKNOI = flag * x;\n}\n\nint S, T, level[MAXN], q[MAXN], head, tail;\n\nstruct Edge {\n\tint v, w, nxt;\n} e[MAXM << 1];\nint first[MAXN], eCnt;\n\ninline void AddEdge(int u, int v, int w) {\n\te[++eCnt].v = v;\n\te[eCnt].w = w;\n\te[eCnt].nxt = first[u];\n\tfirst[u] = eCnt;\n}\n\ninline void Add(int u, int v, int w) {\n\tAddEdge(u, v, w);\n\tAddEdge(v, u, 0);\n}\n\ninline int Match(int u) {\n\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\tif (e[i].v != T && e[i].w) return e[i].v;\n\t}\n\treturn 0;\n}\n\nbool BFS() {\n\tfor (int i = 1; i <= T; ++i) {\n\t\tlevel[i] = -1;\n\t}\n\tlevel[S] = 0;\n\tq[head = tail = 1] = S;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tif (u == T) return 1;\n\t\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\t\tint v = e[i].v;\n\t\t\tif (e[i].w && level[v] == -1) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++tail] = v;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint DFS(int u, int flow) {\n\tif (u == T) return flow;\n\tint ret = 0;\n\tfor (int i = first[u]; i; i = e[i].nxt) {\n\t\tint v = e[i].v;\n\t\tif (e[i].w && level[v] == level[u] + 1) {\n\t\t\tint tmp = DFS(v, min(flow, e[i].w));\n\t\t\te[i].w -= tmp;\n\t\t\te[i ^ 1].w += tmp;\n\t\t\tflow -= tmp;\n\t\t\tret += tmp;\n\t\t\tif (!flow) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint Dinic() {\n\tint ret = 0;\n\twhile (BFS()) {\n\t\tret += DFS(S, INF);\n\t}\n\treturn ret;\n}\n\nint n, son[MAXN], fa[MAXN];\nvector<int> ine[MAXN];\n\nvoid init() {\n\tread(n);\n\teCnt = S = 1, T = n * 2;\n\tfor (int i = 1; i < n; ++i) {\n\t\tint siz; read(siz);\n\t\tAdd(S, n + i, 1);\n\t\tfor (int j = 1; j <= siz; ++j) {\n\t\t\tint x; read(x);\n\t\t\tine[x].push_back(i);\n\t\t\tif (x == 1) continue;\n\t\t\tAdd(n + i, x, 1);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tAdd(i, T, 1);\n\t}\n}\n\nvoid solve() {\n\tif (Dinic() < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tson[Match(i) - n] = i;\n\t}\n\tq[head = tail = 1] = 1;\n\twhile (head <= tail) {\n\t\tint u = q[head++];\n\t\tfor (auto v : ine[u]) {\n\t\t\tif (fa[v]) continue;\n\t\t\tfa[v] = u;\n\t\t\tq[++tail] = son[v];\n\t\t}\n\t}\n\tif (tail < n) {\n\t\tputs(\"-1\");\n\t\treturn;\n\t}\n\tfor (int i = 1; i < n; ++i) {\n\t\tprintf(\"%d %d\\n\", fa[i], son[i]);\n\t}\n}\n\nint main() {\n\tinit();\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint n;\nvector<edge> G[200005];\nint S, T;\nllint level[200005], iter[200005];\n\nvector<llint> revG[200005];\nllint pred[200005], succ[200005];\nbool used[200005];\nvector<P> avec;\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nvoid dfs2(int v)\n{\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tpred[revG[v][i]] = v;\n\t\tused[revG[v][i]] = true;\n\t\tdfs2(succ[revG[v][i]]);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint c, w;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> w;\n\t\t\tadd_edge(i, n+w, 1);\n\t\t\trevG[w].push_back(i);\n\t\t}\n\t}\n\tS = 2*n+1, T = 2*n+2;\n\t\n\tfor(int i = 1; i <= n-1; i++) add_edge(S, i, 1);\n\tfor(int i = 1; i <= n; i++) add_edge(n+i, T, 1);\n\t\n\tllint ans = 0, flow;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(level[T] >= inf) break;\n\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\twhile(1){\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t}\n\tif(ans < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].to == S) continue;\n\t\t\tif(G[i][j].cap == 0) succ[i] = G[i][j].to-n;\n\t\t}\n\t}\n\tint r;\n\tfor(int i = 0; i < G[T].size(); i++){\n\t\tif(G[T][i].cap == 0){\n\t\t\tr = G[T][i].to-n;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdfs2(r);\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tif(pred[i] == 0 || succ[i] == 0){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcout << pred[i] << \" \" << succ[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint next[N],head[N],edge[N],v[N],next2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnext[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnext2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=next[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=next2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=200005,INF=1e9;\nstruct edge\n{\n\tint to,nxt,v;\n}e[N<<2]; int n,x,y,cnt=1,head[N],frm[N],pre[N],q[N],s,t;\ninline void addedge(CI x,CI y,CI z)\n{\n    e[++cnt]=(edge){y,head[x],z}; head[x]=cnt;\n    e[++cnt]=(edge){x,head[y],0}; head[y]=cnt;\n}\n#define to e[i].to\nnamespace NF //Network Flow\n{\n    int cur[N],q[N],dep[N];\n    inline bool BFS(CI s,CI t)\n    {\n        RI H=0,T=1; memset(dep,0,t+1<<2); q[dep[s]=1]=s;\n        while (H<T)\n        {\n            int now=q[++H]; for (RI i=head[now];i;i=e[i].nxt)\n            if (to!=1&&e[i].v&&!dep[to]) dep[to]=dep[now]+1,q[++T]=to;\n        }\n        return dep[t];\n    }\n    inline int DFS(CI now,CI tar,int dis)\n    {\n        if (now==tar) return dis; int ret=0;\n        for (RI& i=cur[now];i&&dis;i=e[i].nxt)\n        if (to!=1&&e[i].v&&dep[to]==dep[now]+1)\n        {\n            int dist=DFS(to,tar,min(dis,e[i].v));\n            dis-=dist; ret+=dist; e[i].v-=dist; e[i^1].v+=dist;\n        }\n        if (!ret) dep[now]=0; return ret;\n    }\n    inline int Dinic(CI s,CI t,int ret=0)\n    {\n        while (BFS(s,t)) memcpy(cur,head,t+1<<2),ret+=DFS(s,t,INF);\treturn ret;\n    }\n};\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),i=1;i<n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=x;++j) scanf(\"%d\",&y),addedge(y,n+i,1);\n\tfor (s=0,t=n<<1,i=1;i<=n;++i) addedge(s,i,1); for (i=1;i<n;++i) addedge(n+i,t,1);\n\tif (NF::Dinic(s,t)!=n-1) return puts(\"-1\"),0;\n\tfor (j=2;j<=n;++j) for (i=head[j];i;i=e[i].nxt) if (to>n&&!e[i].v) frm[to-n]=j;\n\tRI H=0,T=1; q[1]=1; while (H<T)\n\t{\n\t\tint now=q[++H]; for (i=head[now];i;i=e[i].nxt)\n\t\tif (to>n&&!pre[to-n]) pre[to-n]=now,q[++T]=frm[to-n];\n\t}\n\tif (T!=n) return puts(\"-1\"),0;\n\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",pre[i],frm[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,M=800005,oo=1e9;\nstruct edge{\n\tint di,nxt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N];\ninline void aedge(int a,int b,int c){\n\te[++nedge].nxt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void ins(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=0;i<N;i++)deep[i]=oo;\n    for(int i=0;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nxt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nxt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\nint dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nvector<int> v[N>>1];\nint match[N>>1];\nvector<PI> an;\nint main(){\n\tint n=read(),s=n,t=n+1;\n\tFor(i,1,n-1){\n\t\tint c=read();\n\t\tFor(j,1,c){int t=read(); v[t].pb(i); if(t>1)ins(i,t+n,1);}\n\t\tins(s,i,1); ins(n+i+1,t,1);\n\t}\n\tint ans=dinic(s,t); \n\tif(ans!=n-1)GG();\n\tFor(i,1,n-1)for(int j=son[i];j;j=e[j].nxt)if(!e[j].di){match[i]=e[j].ed-n; break;}\n\tqueue<int> q; q.push(1);\n\twhile(q.size()){\n\t\tint t=q.front(); q.pop();\n\t\tfor(auto i:v[t])if(match[i]){\n\t\t\tq.push(match[i]); \n\t\t\tan.pb(mp(t,match[i]));\n\t\t\tmatch[i]=0;\n\t\t}\n\t}\n\tif(an.size()<n-1)GG();\n\tfor(auto i:an){wri(i.fi);writeln(i.se);}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]),g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\n\nvoid failure(){cout<<-1<<lf;exit(0);}\n\nvector<int> e[_];\nint n,ed[_]={0},via[_]={0};\n\nint dfs(int x,int who)\n{\n\tif(ed[x]==who)return 0;\n\ted[x]=who;\n\tfor(auto b:e[x])if(!via[b] || dfs(via[b],who)){via[b]=x;return 1;}\n\treturn 0;\n}\n\nint es[_]={0};\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<n;i++)for(int j=ty();j>=1;j--)e[ty()].emplace_back(i);\n\tfor(int i=2;i<=n;i++)if(!dfs(i,i))failure();\n\n\tqueue<int> q;\n\tq.emplace(1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(q.empty())failure();\n\t\tint a=q.front();q.pop();\n\t\tfor(auto b:e[a])if(!es[b])es[b]=a,q.emplace(via[b]);\n\t}\n\tfor(int i=1;i<n;i++)cout<<es[i]<<' '<<via[i]<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct Edge {\n\tint t,f,next;\n\tEdge() {}\n\tEdge(int a,int b,int c):t(a),f(b),next(c) {}\n};\n\nEdge e[1000000];\nint head[200005],vs,vt,tot=-1;\n\ninline void addEdge(int x,int y,int z) {\n\te[++tot]=Edge(y,z,head[x]);\n\thead[x]=tot;\n\te[++tot]=Edge(x,0,head[y]);\n\thead[y]=tot;\n}\n\nnamespace Flow {\n\n\tint d[200005],cur[200005];\n\tqueue <int> q;\n\n\tbool bfs() {\n\t\twhile (!q.empty()) q.pop();\n\t\tmemset(d,255,sizeof(d));\n\t\td[vs]=0;\n\t\tcur[vs]=head[vs];\n\t\tq.push(vs);\n\t\twhile (!q.empty()) {\n\t\t\tint x=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=head[x]; i!=-1; i=e[i].next)\n\t\t\t\tif (e[i].f&&d[e[i].t]==-1) {\n\t\t\t\t\tint u=e[i].t;\n\t\t\t\t\td[u]=d[x]+1;\n\t\t\t\t\tcur[u]=head[u];\n\t\t\t\t\tif (u==vt) return 1;\n\t\t\t\t\tq.push(u);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dfs(int x,int a) {\n\t\tif (x==vt||!a) return a;\n\t\tint ans=0;\n\t\tfor(int &i=cur[x]; i!=-1; i=e[i].next)\n\t\t\tif (e[i].f&&d[e[i].t]==d[x]+1) {\n\t\t\t\tint u=e[i].t;\n\t\t\t\tint f=dfs(u,min(a,e[i].f));\n\t\t\t\tif (f) {\n\t\t\t\t\te[i].f-=f;\n\t\t\t\t\te[i^1].f+=f;\n\t\t\t\t\tans+=f;\n\t\t\t\t\ta-=f;\n\t\t\t\t\tif (!a) break;\n\t\t\t\t}\n\t\t\t}\n\t\treturn ans;\n\t}\n\n\tint maxflow() {\n\t\tint ans=0;\n\t\twhile (bfs())\n\t\t\tans+=dfs(vs,inf);\n\t\treturn ans;\n\t}\n\n}\n\nvector <int> bel[100005];\nbool vis1[100005],vis2[100005];\nint id[100005],nxt[100005];\n\nqueue <int> q;\n\nbool solve(int n) {\n\tfor(int i=1; i<n; i++)\n\t\tfor(int j=head[n+i]; j!=-1; j=e[j].next)\n\t\t\tif (e[j].t&&!e[j].f) {\n\t\t\t\tint u=e[j].t;\n\t\t\t\tid[i]=u;\n\t\t\t\tvis1[u]=1;\n\t\t\t}\n\tfor(int i=1; i<=n; i++)\n\t\tif (!vis1[i]) q.push(i);\n\tint cnt=0;\n\twhile (!q.empty()) {\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tcnt++;\n\t\tfor(int i=0; i<bel[x].size(); i++)\n\t\t\tif (!vis2[bel[x][i]]) {\n\t\t\t\tint u=bel[x][i];\n\t\t\t\tvis2[u]=1;\n\t\t\t\tnxt[u]=x;\n\t\t\t\tq.push(id[u]);\n\t\t\t}\n\t}\n\treturn cnt==n;\n}\n\nint main() {\n\tmemset(head,255,sizeof(head));\n\tint n;\n\tscanf(\"%d\",&n);\n\tvs=0;\n\tvt=2*n;\n\tfor(int i=1; i<n; i++) {\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\taddEdge(vs,n+i,1);\n\t\tfor(int j=1; j<=x; j++) {\n\t\t\tint y;\n\t\t\tscanf(\"%d\",&y);\n\t\t\taddEdge(n+i,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++) addEdge(i,vt,1);\n\tif (Flow::maxflow()<n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tif (!solve(n)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; i++) printf(\"%d %d\\n\",id[i],nxt[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\n#pragma GCC target(\"avx2\")\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<ll>& cap){\n\n    if (v == g) return maxflow;\n    cap[v] = 0;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.emplace_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[nex] == 1)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n    vector<ll> level(N,inf);\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.emplace_back(s);\n        rep(i,0,N) level[i] = inf;\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.emplace_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<ll> cap(N,1);\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].emplace_back(wtmp);\n            vtoc[wtmp].emplace_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.emplace_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.emplace_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la, fr[N], id[N]; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\ninline bool cmp(const int &x, const int &y) { return fr[x] < fr[y]; }\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i] - n + 1, x = to[i ^ 1];\n\t\tif(x == s || x >= n || y <= 1 || y > n) continue;\n\t\tbl[x] = y;\n\t}\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v], fr[la] = v, id[la] = la;\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\tsort(id + 1, id + la + 1, cmp);\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[id[i]], ay[id[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 200050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn],gap[maxn];\nint cur[maxn],prt[maxn];\n\nint isap()\n{\n    for (int i=1;i<=vt;++i) cur[i]=head[i],++gap[d[i]=0];\n    int i=vs,ans=0;\n    while (d[vs]<vt)\n    {\n        if (i==vt)\n        {\n            for (++ans;i!=vs;i=edge[prt[i]^1])\n                // cout<<\"path:\"<<i<<endl,\n                --cost[prt[i]],++cost[prt[i]^1];\n            // cout<<\"path:\"<<vs<<endl<<endl;\n        }\n\n        bool flag=0;\n        for (int k=cur[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (cost[k]&&d[i]==d[j]+1)\n            {\n                flag=1;\n                cur[i]=prt[j]=k;\n                i=j;\n                break;\n            }\n        }\n\n        if (flag)   continue;\n\n        if (--gap[d[i]]==0) break;\n        d[i]=vt;\n        for (int k=head[i];~k;k=nxt[k])\n            if (cost[k])\n                d[i]=min(d[i],d[edge[k]]+1);\n        ++gap[d[i]];\n        cur[i]=head[i];\n        if (i!=vs)\n            i=edge[prt[i]^1];\n    }\n    // cout<<\"isap:\"<<ans<<endl;\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nstd::vector<int> set[maxn];\n\nint head[maxn << 1], nxt[maxn << 2], to[maxn << 2], cap[maxn << 2], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f = dinic(s, t);\n\t\twhile(f) {\n\t\t\tflow += f;\n\t\t\tf = dinic(s, t);\n\t\t}\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\tprintf(\"%d %d\\n\", u, match[to[i] - n]);\n\t\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint n,s,t;\nint tot,rd[200005],sz[200005],bg[200005],ed[200005];\nint h[200005],fr[1000005],to[1000005],f[1000005],cnt=1;\nvoid add(int x,int y,int z)\n{\n\tfr[++cnt]=h[x];\n\th[x]=cnt;\n\tto[cnt]=y;\n\tf[cnt]=z;\n}\nint dis[200005];\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[now];i;i=fr[i])\n\t\t{\n\t\t\tif(f[i]&&dis[to[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[now]+1;\n\t\t\t\tif(to[i]==t)return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now)\n{\n\tif(now==t)return 1;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(dis[to[i]]==dis[now]+1&&f[i])\n\t\t{\n\t\t\tint r=dfs(to[i]);\n\t\t\tif(!r)dis[to[i]]=-1;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\t//cout<<now<<' '<<to[i]<<endl;\n\t\t\t\tf[i]=0;\n\t\t\t\tf[i^1]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\twhile(dfs(s))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nint bel[100005],rt,g[100005][2],fa[100005];\nvoid dfs1(int now)\n{\n\tcnt++;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(!fa[to[i]])\n\t\t{\n\t\t\tfa[to[i]]=now;\n\t\t\tg[bel[to[i]]][0]=now;g[bel[to[i]]][1]=to[i];\n\t\t\tdfs1(to[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&sz[i]);\n\t\tbg[i]=tot+1;\n\t\tfor(int j=1;j<=sz[i];j++)\n\t\t{\n\t\t\tscanf(\"%d\",&rd[tot+1]);\n\t\t\ttot++;\n\t\t}\n\t\ted[i]=tot;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tt=2*n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t\tfor(int j=bg[i];j<=ed[i];j++)\n\t\t{\n\t\t\tadd(rd[j],i+n,1);\n\t\t\tadd(i+n,rd[j],0);\n\t\t}\n\t}\n\tint flow=dinic();\n\t//cout<<flow<<endl;\n\tif(flow!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=h[i];j;j=fr[j])\n\t\t{\n\t\t\t//cout<<i<<' '<<to[j]<<endl;\n\t\t\tif(to[j]!=s&&f[j]==0)\n\t\t\t{\n\t\t\t\tbel[i]=to[j]-n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!bel[i])rt=i;\n\t\t//cout<<i<<' '<<bel[i]<<endl;\n\t}\n\tmemset(h,0,sizeof(h));\n\tcnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=rt)\n\t\t{\n\t\t\tfor(int j=bg[bel[i]];j<=ed[bel[i]];j++)\n\t\t\t{\n\t\t\t\tif(rd[j]!=i)add(rd[j],i,0);\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tdfs1(rt);\n\t//cout<<cnt<<endl;\n\tif(cnt!=n)printf(\"-1\");\n\telse\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",g[i][0],g[i][1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate<class T> inline void read(T &x){\n  x=0; register char c=getchar(); register bool f=0;\n  while(!isdigit(c))f^=c=='-',c=getchar();\n  while(isdigit(c))x=x*10+c-'0',c=getchar(); if(f)x=-x;\n}\ntemplate<class T> inline void print(T x){\n  if(x<0)putchar('-'),x=-x;\n  if(x>9)print(x/10); putchar(x%10+'0');\n}\ntemplate<class T> inline void print(T x,char c){print(x),putchar(c);}\nconst int N=1e5+10;\nint n,id_node[N],id_set[N],match[N],used[N];\nstd::queue<int> q;\nstd::vector<int> a[N],e[N];\nstd::vector<std::pair<int,int>> ans;\ninline void no_solution(){puts(\"-1\"),exit(0);}\ntemplate<int N,int M> struct Dinic{\n  int s/**/,t/*&&*/,tot/**/,cur[N],hed[N],dep[N],to[M<<1],val[M<<1],nxt[M<<1];\n  Dinic(){tot=0,memset(hed,-1,sizeof(hed));}\n  inline void add(int u,int v,int w){\n    // printf(\"%d %d %d\\n\",u,v,w);\n    nxt[tot]=hed[u],to[tot]=v,val[tot]=w,hed[u]=tot++;\n    nxt[tot]=hed[v],to[tot]=u,val[tot]=0,hed[v]=tot++;\n  }\n  bool bfs(){\n    static int u,l,r,q[N]; memset(dep+1,0,t<<2),l=r=dep[s]=1,q[1]=s;\n    while(l<=r&&(u=q[l++]))for(int i=hed[u];~i;i=nxt[i])\n      if(val[i]&&!dep[to[i]])dep[to[i]]=dep[u]+1,q[++r]=to[i];\n    return dep[t];\n  }\n  int dfs(int u,int d){\n    if(u==t)return d; int s=0;\n    for(int &i=cur[u];~i;i=nxt[i])if(val[i]&&dep[to[i]]==dep[u]+1)\n      if(int e=dfs(to[i],std::min(d-s,val[i]))){s+=e,val[i]-=e,val[i^1]+=e;if(s==d)return s;}\n    return s?s:dep[s]=0;\n  }\n  int dinic(){int r=0;while(bfs())memcpy(cur+1,hed+1,t<<2),r+=dfs(s,1e9);return r;}\n  int findout(int u){for(int i=hed[u];~i;i=nxt[i])if(!val[i]&&to[i]!=s&&to[i]!=t)return to[i];return -1;}\n};\nDinic<N,N*2> flow;\nint main(){\n#ifdef memset0\n  freopen(\"1.in\",\"r\",stdin);\n#endif\n  read(n);\n  for(int i=1,m;i<n;i++){\n    read(m),a[i].resize(m);\n    for(int j=0,x;j<m;j++)read(a[i][j]),e[a[i][j]].push_back(i);\n  }\n  for(int i=1;i<=n;i++)id_node[i]=++flow.t;\n  for(int i=1;i<n;i++)id_set[i]=++flow.t;\n  flow.s=++flow.t,++flow.t;\n  for(int i=2;i<=n;i++){\n    flow.add(flow.s,id_node[i],1);\n  }\n  for(int i=1;i<n;i++){\n    flow.add(id_set[i],flow.t,1);\n    for(int u:a[i])flow.add(id_node[u],id_set[i],1);\n  }\n  if(flow.dinic()!=n-1)no_solution();\n  // for(int i=2;i<=n;i++)printf(\"%d > %d\\n\",i,flow.findout(i));\n  for(int i=2;i<=n;i++)match[flow.findout(i)-n]=i;\n  q.push(1);\n  while(q.size()){\n    int u=q.front(); q.pop();\n    for(int v:e[u])if(!used[v]){\n      ans.push_back(std::make_pair(u,match[v]));\n      used[v]=1,q.push(match[v]);\n    }\n  }\n  if(ans.size()!=n-1)no_solution();\n  for(int i=0;i<n-1;i++)print(ans[i].first,' '),print(ans[i].second,'\\n');\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint const inf=1e8;\nint n,target[800005],pre[800005],last[200005],cap[800005],tot=1,maxflow,\ncur[200005],s,t,dis[200005],ans[200005],ans2[200005];\nbool visited[200005];\nqueue<int>q;\nvoid add(int x,int y,int z)\n{\n\ttarget[++tot]=y;\n\tpre[tot]=last[x];\n\tlast[x]=tot;\n\tcap[tot]=z;\n\ttarget[++tot]=x;\n\tpre[tot]=last[y];\n\tlast[y]=tot;\n}\nbool bfs()\n{\n\tfor(int i=1;i<=t;i++)dis[i]=inf,cur[i]=last[i];\n\tcur[0]=last[0];\n\tq.push(0);\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=last[now];i;i=pre[i])\n\t\t{\n\t\t\tif(cap[i]&&dis[target[i]]==inf)\n\t\t\t{\n\t\t\t\tdis[target[i]]=dis[now]+1;\n\t\t\t\tq.push(target[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t]!=inf;\n}\nint dfs(int x,int lim)\n{\n\tif((!lim)||x==t)return lim;\n\tint flow=0;\n\tfor(int i=cur[x];i;cur[x]=i,i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(cap[i]&&dis[target[i]]==dis[x]+1)\n\t\t{\n\t\t\tint d=dfs(target[i],min(lim,cap[i]));\n\t\t\tcap[i]-=d;\n\t\t\tcap[i^1]+=d;\n\t\t\tflow+=d;\n\t\t\tlim-=d;\n\t\t\tif(!lim)return flow;\n\t\t}\n\t}\n\treturn flow;\n}\nvoid dinic()\n{\n\twhile(bfs())maxflow+=dfs(s,inf);\n}\nvoid getans(int x,int fa)\n{\n\t//cout<<x<<endl;\n\tvisited[x]=1;\n\tfor(int i=last[x];i;i=pre[i])\n\t{\n\t\tint tar=target[i];\n\t\tif(x<=n)\n\t\t{\n\t\t\tif(tar==s||tar==t)continue;\n\t\t\tif(!visited[tar])\n\t\t\t{\n\t\t\t\tgetans(tar,x);\n\t\t\t\t//return;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(tar==t||(!cap[i]))continue;\n\t\t\t++ans[0];\n\t\t\tans[x-n]=fa;\n\t\t\tans2[x-n]=tar;\n\t\t\tgetans(tar,tar);\n\t\t\treturn;\n\t\t}\n\t}\n}\nint main()\n{\n\tint x,T;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&T);\n\t\twhile(T--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tadd(x,i+n,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)add(0,i,1);\n\tfor(int i=n+1;i<n*2;i++)add(i,n*2,1);\n\tt=n*2,s=0;\n\tdinic();\n\tif(maxflow<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint st;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tbool flag=1;\n\t\tfor(int j=last[i];j;j=pre[j])\n\t\t{\n\t\t\t//cout<<i<<\" \"<<target[j]<<\" \"<<cap[j]<<endl;\n\t\t\tif(target[j]>n&&(!cap[j]))\n\t\t\t{\n\t\t\t\tflag=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t{\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tgetans(st,st);\n\tif(ans[0]!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=ans[0];i++)printf(\"%d %d\\n\",ans[i],ans2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\nusing namespace std;\nconst int N=2e5+5,M=2e6;\n\nint n,m,e,S,T,h,t,q[N],lev[N],ax[N],ay[N],o[N];\nint to[M],nx[M],cap[M],hd[N],it[N],sze=1;\nstd::vector<int> g[N];\n\nil void add(int u,int v,int c){to[++sze]=v,nx[sze]=hd[u],cap[sze]=c,hd[u]=sze;}\n\nil void ins(int u,int v,int c){add(u,v,c),add(v,u,0);}\n\nil int bfs()\n{\n\tmemset(lev,0,4*T+4); int i,u,v; q[h=t=lev[S]=1]=S;\n\twhile (h<=t) for (i=hd[u=q[h++]]; i; i=nx[i])\n        if (cap[i]&&!lev[v=to[i]]) lev[v]=lev[u]+1,q[++t]=v;\n\treturn lev[T];\n}\n\nil int dfs(int u,int f)\n{\n\tif (u==T) return f; int z,v,res=0;\n\tfor (int &i=it[u]; i; i=nx[i])\n\t\tif (lev[v=to[i]]==lev[u]+1&&cap[i]&&(z=dfs(v,min(f-res,cap[i]))))\n\t\t{\n\t\t\tcap[i]-=z,cap[i^1]+=z,res+=z;\n\t\t\tif (res==f) break;\n\t\t}\n\treturn res;\n}\n\nil int dinic()\n{\n\tint i,f,res=0;\n\twhile (bfs())\n    {\n        for (i=1; i<=T; i++) it[i]=hd[i];\n        while (f=dfs(S,1e9)) res+=f;\n    }\n\treturn res;\n}\n\nil int work()\n{\n    int i,u,v,s=0;\n    for (u=1; u<n; u++) for (i=hd[u]; i; i=nx[i])\n        if ((v=to[i])!=S&&!cap[i]) o[u]=v-n+1;\n    for (q[++t]=n; h<=t; )\n    {\n        u=q[h++],s++;\n        for (int v:g[u]) if (o[v])\n            ax[v]=u,ay[v]=o[v],q[++t]=o[v],o[v]=0; \n    }\n    return s==n;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),S=n+n-1,T=n+n; int i,c,x;\n    for (i=1; i<n; i++) ins(i+n-1,T,1);\n    for (i=1; i<n; i++)\n    {\n        scanf(\"%d\",&c),ins(S,i,1);\n        while (c--)\n        {\n            scanf(\"%d\",&x);\n            if (x!=n) ins(i,x+n-1,1);\n            g[x].push_back(i);\n        }\n    }\n\n    if (dinic()<n-1) return puts(\"-1\"),0;\n    if (!work()) return puts(\"-1\"),0;\n\tfor (i=1; i<n; i++) printf(\"%d %d\\n\",ax[i],ay[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e6+5;\nconst int INF = 1e9;\n\nint n;\nint fa[N];\nvector<int>pt[N],g[N];\nbool used[N];\nint he,ta;\nint que[N];\nstruct edge{\n\tint x,f,nxt;\n}e[N*10];\nint h[N],tot;\nint vis[N],tim;\nint st,ed,k;\nint id[N][2];\nint key[N],m;\nint vt[N];\nint d[N][2];\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N];\nint deq[N];\nint pu[N],t;\n\nbool bfs(){\n\tfo(i,1,t)dis[pu[i]]=-1;\n\tint he=0,ta=1;\n\tdis[deq[1]=st]=0;\n\tfor(;he<ta;){\n\t\tint x=deq[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (e[p].f&&dis[e[p].x]==-1){\n\t\t\tdis[e[p].x]=dis[x]+1;\n\t\t\tdeq[++ta]=e[p].x;\n\t\t}\n\t}\n\treturn dis[ed]!=-1;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint main(){\nprintf(\"-1\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long double ld;\n\nvi g[100009];\nvi g2[100009];\nint gsz[100009];\nint g2sz[100009];\n\nvi match;\nvi match1;\nvector<bool> seen;\nbool find(int j){\n    if (match[j] == -1) return 1;\n    seen[j] = 1; int di = match[j];\n    rep(i,0,gsz[di])\n        if (!seen[g[di][i]] && find(g[di][i])) {\n            match[g[di][i]] = di;\n            return 1;\n        }\n    return 0;\n}\nint dfs_matching(int n, int m) {\n    match.assign(m, -1);\n    rep(i,0,n) {\n        seen.assign(m, 0);\n        rep(k,0,gsz[i]){\n            if (find(g[i][k])) {\n                match[g[i][k]] = i;\n                break;\n            }\n        }\n    }\n    return m - (int)count(all(match), -1);\n}\n\nvi match2;\n\nint dfs(int v){\n    int ans = 1;\n    rep(i,0,g2sz[v]){\n        int v2 = g2[v][i];\n        if(match2[v2] == -1){\n            match2[v2] = v;\n            ans += dfs(match1[v2]);\n        }\n    }\n    return ans;\n}\n\nint main(){\n    cin.sync_with_stdio(0); cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    int n;\n    cin >> n;\n    int x,y,c;\n    rep(i,0,n-1){\n        cin >> c;\n        rep(j,0,c){\n            cin >> x;\n            x--;\n            g[i].push_back(x);\n            g2[x].push_back(i);\n        }\n    }\n    rep(i,0,n-1){\n        gsz[i] = sz(g[i]);\n    }\n    rep(i,0,n){\n        g2sz[i] = sz(g2[i]);\n    }\n\n    int mat = dfs_matching(n-1, n);\n    if(mat < n-1){\n        cout << -1 << endl;\n    }else{\n        match1.assign(n-1, -1);\n        match2.assign(n-1, -1);\n        int unm;\n        rep(i,0,n){\n            if(match[i] == -1){\n                unm = i;\n            }else{\n                match1[match[i]] = i;\n            }\n        }\n        int k = dfs(unm);\n        if(k < n){\n            cout << -1 << endl;\n        }else{\n            rep(i,0,n-1){\n                printf(\"%d %d\\n\", match1[i]+1, match2[i]+1);\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200100,MAXM=1000100,INF=0x3f3f3f3f;\nstruct Edge\n{\n\tint to,val,nxt;\n\tinline Edge() {}\n\tinline Edge(register int to,register int val,register int nxt):to(to),val(val),nxt(nxt) {}\n};\nEdge e[MAXM];\nint head[MAXN],S,T,cnt;\nint d[MAXN],cur[MAXN];\nint vis1[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];\nint N;\nqueue<int> q,q_;\nvector<int> bel[MAXN];\ninline void Addedge(register int x,register int y,register int z)\n{\n\te[++cnt]=Edge(y,z,head[x]),head[x]=cnt;\n\te[++cnt]=Edge(x,0,head[y]),head[y]=cnt;\n\treturn;\n}\ninline bool bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tmemset(d,-1,sizeof(d));\n\td[S]=0,cur[S]=head[S],q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tregister int now=q.front(); q.pop();\n\t\tfor(register int i=head[now];~i;i=e[i].nxt)\n\t\t\tif(e[i].val&&(!(~d[e[i].to])))\n\t\t\t{\n\t\t\t\tregister int to=e[i].to;\n\t\t\t\td[to]=d[now]+1,cur[to]=head[to];\n\t\t\t\tif(to==T) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(register int now,register int num)\n{\n\tif(now==T||!num) return num;\n\tregister int ans=0;\n\tfor(register int &i=cur[now];~i;i=e[i].nxt)\n\t\tif(e[i].val&&d[e[i].to]==d[now]+1)\n\t\t{\n\t\t\tregister int to=e[i].to;\n\t\t\tregister int f=dfs(to,min(num,e[i].val));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\te[i].val-=f,e[i^1].val+=f;\n\t\t\t\tans+=f,num-=f;\n\t\t\t\tif(!num) break;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\ninline int maxflow()\n{\n\tregister int ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\ninline bool solve(register int n)\n{\n\tfor(register int i=1;i<n;i++)\n\t\tfor(register int j=head[n+i];~j;j=e[j].nxt)\n\t\t\tif(e[j].to&&!e[j].val) id[i]=e[j].to,vis1[e[j].to]=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis1[i]) q_.push(i);\n\tregister int cnt_=0;\n\twhile(!q_.empty())\n\t{\n\t\tregister int now=q_.front(); q_.pop();\n\t\tcnt_++;\n\t\tfor(register int i=0;i<(int)bel[now].size();i++)\n\t\t\tif(!vis2[bel[now][i]])\n\t\t\t{\n\t\t\t\tregister int to=bel[now][i];\n\t\t\t\tvis2[to]=1,nxt[to]=now,q_.push(id[to]);\n\t\t\t}\n\t}\n\treturn cnt_==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tmemset(head,-1,sizeof(head));\n\tcin>>N;\n\tS=0,T=N<<1;\n\tfor(register int i=1,x,y;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\tAddedge(S,N+i,1);\n\t\tfor(register int j=1;j<=x;j++) cin>>y,Addedge(N+i,y,1),bel[y].push_back(i);\n\t}\n\tfor(register int i=1;i<=N;i++) Addedge(i,T,1);\n\tif(maxflow()<N-1) return puts(\"-1\"),0;\n\tif(!solve(N)) return puts(\"-1\"),0;\n\tfor(register int i=1;i<N;i++) cout<<id[i]<<\" \"<<nxt[i]<<\"\\n\";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);q[++t]=S;dis[S]=1;\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=200005,M=800005,oo=1e9;\nstruct edge{\n\tint di,nxt,ed;\n}e[M];\nint son[N],nedge,cur[N],deep[N];\ninline void aedge(int a,int b,int c){\n\te[++nedge].nxt=son[a];\n\tson[a]=nedge;\n\te[nedge].ed=b;\n\te[nedge].di=c;\n}\ninline void ins(int a,int b,int c){\n\taedge(a,b,c); aedge(b,a,0); //cout<<a<<\" \"<<b<<endl;\n}\ninline bool bfs(int s,int t){\n\tfor(int i=0;i<N;i++)deep[i]=oo;\n    for(int i=0;i<N;i++)cur[i]=son[i];\n    deep[s]=0;\n    queue<int> q;\n    q.push(s);\n    while(!q.empty()){\n        int now=q.front();q.pop();\n        for(int tmp=son[now];tmp;tmp=e[tmp].nxt)\n            if(deep[e[tmp].ed]>=oo&&e[tmp].di){deep[e[tmp].ed]=deep[now]+1,q.push(e[tmp].ed);}\n    }\n    return deep[t]<oo;\n}\nint dfs(int now,int t,int limit){\n    if(!limit||now==t) return limit;\n    int flow=0,f;\n    for(int tmp=cur[now];tmp;tmp=e[tmp].nxt){\n        cur[now]=tmp;\n        if(deep[e[tmp].ed]==deep[now]+1&&(f=dfs(e[tmp].ed,t,min(limit,e[tmp].di)))){\n            flow+=f; limit-=f; e[tmp].di-=f; e[((tmp-1)^1)+1].di+=f; if(!limit)break;\n        }\n    }\n    return flow;\n}\nint dinic(int s,int t){\n    int ans=0;\n    while(bfs(s,t))ans+=dfs(s,t,oo);\n    return ans;\n}\nvoid GG(){\n\tputs(\"-1\"); exit(0);\n}\nvector<int> v[N>>1];\nint match[N>>1];\nvector<PI> an;\nint main(){\n\tint n=read(),s=n,t=n+1;\n\tFor(i,1,n-1){\n\t\tint c=read();\n\t\tins(s,i,1); ins(n+i+1,t,1);\n\t\tFor(j,1,c){int t=read(); v[t].pb(i); if(t>1)ins(i,t+n,1);}\n\t}\n\tint ans=dinic(s,t); \n\tif(ans!=n-1)GG();\n\tFor(i,1,n-1)for(int j=son[i];j;j=e[j].nxt)if(!e[j].di){match[i]=e[j].ed-n; break;}\n\tqueue<int> q; q.push(1);\n\twhile(q.size()){\n\t\tint t=q.front(); q.pop();\n\t\tfor(auto i:v[t])if(match[i]){\n\t\t\tq.push(match[i]); \n\t\t\tan.pb(mp(t,match[i]));\n\t\t\tmatch[i]=0;\n\t\t}\n\t}\n\tif(an.size()<n-1)GG();\n\tfor(auto i:an){wri(i.fi);writeln(i.se);}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FO(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\n#define fo(i,j,k) for(int i=(j),end_i=(k);i<=end_i;i++)\n#define ff(i,j,k) for(int i=(j),end_i=(k);i< end_i;i++)\n#define fd(i,j,k) for(int i=(j),end_i=(k);i>=end_i;i--)\n#define DEBUG(x) cerr<<#x<<\"=\"<<x<<endl\n#define all(x) (x).begin(),(x).end()\n#define cle(x) memset(x,0,sizeof(x))\n#define lowbit(x) ((x)&-(x))\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define lb long db\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\ninline int read()\n{\n\tint x=0; char ch=getchar(); bool f=0;\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') f=1;\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) x=(x<<3)+(x<<1)+(ch^48);\n\treturn f?-x:x;\n}\n#define CASET fo(___,1,read())\n\nconst int N=200010;\nconst int M=2000000;\nnamespace Dinic{\n\tconst int inf=2e9;\n\tint s,t;\n\tint head[N],cur[N],ne[M],ver[M],val[M],tot=1;\n\tint d[N];\n\tqueue<int> q;\n\tinline void add(int x,int y,int v)\n\t{\n\t\tver[++tot]=y; val[tot]=v; ne[tot]=head[x]; head[x]=tot;\n\t\tver[++tot]=x; val[tot]=0; ne[tot]=head[y]; head[y]=tot;\n\t}\n\tinline bool bfs()\n\t{\n\t\tfo(i,0,t) cur[i]=head[i];\n\t\tfor(;!q.empty();q.pop());\n\t\tfo(i,0,t) d[i]=-1; q.push(s); d[s]=0;\n\t\tfor(int u,v;!q.empty();)\n\t\t{\n\t\t\tu=q.front(); q.pop();\n\t\t\tfor(int i=head[u];i;i=ne[i])\n\t\t\t\tif(val[i]&&d[v=ver[i]]==-1)\n\t\t\t\t{\n\t\t\t\t\td[v]=d[u]+1,q.push(v);\n\t\t\t\t\tif(v==t) return 1;\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int flow)\n\t{\n\t\tif(!flow||u==t) return flow;\n\t\tint res=flow,r,v;\n\t\tfor(int &i=cur[u];i;i=ne[i])\n\t\t\tif(val[i]&&d[v=ver[i]]==d[u]+1)\n\t\t\t{\n\t\t\t\tr=dfs(v,min(res,val[i]));\n\t\t\t\tif(!r) continue;\n\t\t\t\tval[i]-=r; val[i^1]+=r;\n\t\t\t\tres-=r; if(!res) break;\n\t\t\t}\n\t\treturn flow-res;\n\t}\n\tint dinic()\n\t{\n\t\tint flow=0;\n\t\twhile(bfs()) flow+=dfs(s,inf);\n\t\treturn flow;\n\t}\n}\nusing namespace Dinic;\nint n;\nvector<pair<int,int>> ans;\nbool vis[N];\nvoid dfs(int u)\n{\n\tfor(int i=head[u],v;i;i=ne[i])\n\t\tif((v=ver[i])!=s&&!vis[v-n])\n\t\t{\n\t\t\tvis[v-n]=1;\n\t\t\tfor(int j=head[v];j;j=ne[j])\n\t\t\t\tif(val[j])\n\t\t\t\t\tans.pb(mp(u,ver[j])),dfs(ver[j]);\n\t\t}\n}\nint main()\n{\n\tn=read();\n\tDinic::t=2*n;\n\ts=0; t=2*n;\n\tff(i,n+1,2*n) CASET add(read(),i,1);\n\tfo(i,1,n) add(s,i,1);\n\tff(i,n+1,2*n) add(i,t,1);\n\tif(dinic()!=n-1) return puts(\"-1\")&0;\n\tint root;\n\tfor(int i=head[0];i;i=ne[i]) if(val[i]) root=ver[i];\n\tdfs(root);\n\tif(ans.size()!=n-1) return puts(\"-1\")&0;\n\tfor(auto v:ans) printf(\"%d %d\\n\",v.fi,v.se);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2], Q[Max_N], U[Max_N * 2], V[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tQ[Q[0] = 1] = 1;\n\t\tfor (int u, ft = 1;ft <= Q[0];)\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = 0, t;i < In[u].size();++i)\n\t\t\t\tif (!done[t = In[u][i]])\n\t\t\t\t{\n\t\t\t\t\tdone[t] = true;\n\t\t\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\t\t\tU[t] = u, V[t] = v, Q[++Q[0]] = v;\n\t\t\t\t}\n\t\t}\n\t\tfor (int i = N + 1;i <= N + (N - 1);++i)\n\t\t\tprint(U[i]), putc(' '), print(V[i]), putc('\\n');\n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0),dis[i]=2,Gap[2]++;\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0),dis[i]=1,Gap[1]++;\n\tn<<=1;int ans=0;dis[S]=3;Gap[0]=Gap[3]=1;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define debug(x) cerr << #x << \" \" << (x) << endl\nusing namespace std;\n\nconst int N = 100005, M = 200005;\n\ntemplate <class T>\nvoid read (T &x) {\n\tint sgn = 1;\n\tchar ch;\n\tx = 0;\n\tfor (ch = getchar(); (ch < '0' || ch > '9') && ch != '-'; ch = getchar()) ;\n\tif (ch == '-') ch = getchar(), sgn = -1;\n\tfor (; '0' <= ch && ch <= '9'; ch = getchar()) x = x * 10 + ch - '0';\n\tx *= sgn;\n}\n\ntemplate <class T>\nvoid write (T x) {\n\tif (x < 0) putchar('-'), write(-x);\n\telse if (x < 10) putchar(x + '0');\n\telse write(x / 10), putchar(x % 10 + '0');\n}\n\nstruct edge {\n\tint to, nxt, cap;\n} graph[(N << 2) + (M << 1)];\nint head[N << 1], cur[N << 1], dep[N << 1], par[N << 1], n, s, t, cnt = 0;\nbool vis[N << 1];\nqueue<int> q;\n\nvoid addedge (int u, int v, int cap) {\n\tedge e = {v, head[u], cap};\n\tgraph[head[u] = cnt++] = e;\n}\n\nbool bfs () {\n\tfor (int i = s; i <= t; i++) cur[i] = head[i], dep[i] = -1;\n\tq.push(s), dep[s] = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\t\tint v = graph[i].to;\n\t\t\tif (graph[i].cap && dep[v] == -1) {\n\t\t\t\tq.push(v);\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t] > 0;\n}\nint dfs (int u, int rest) {\n\tif (u == t || !rest) return rest;\n\tint flow = 0;\n\tfor (int &i = cur[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (dep[v] == dep[u] + 1 && graph[i].cap) {\n\t\t\tint go = dfs(v, min(rest, graph[i].cap));\n\t\t\tgraph[i].cap -= go, graph[i ^ 1].cap += go;\n\t\t\trest -= go, flow += go;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow;\n}\n\nint maxflow () {\n\tint res = 0;\n\twhile (bfs()) res += dfs(s, n + 1);\n\treturn res;\n}\n\nvoid dfs2 (int u) {\n\tvis[u] = true;\n\tfor (int i = head[u]; ~i; i = graph[i].nxt) {\n\t\tint v = graph[i].to;\n\t\tif (graph[i].cap && !vis[v]) par[v] = u, dfs2(v);\n\t}\n}\n\nvector<pair<int, int> > e;\nint main () {\n\tread(n);\n\n\ts = 0, t = n << 1;\n\tfor (int i = s; i <= t; i++) head[i] = -1, vis[i] = false;\n\tfor (int i = 1; i <= n; i++) addedge(s, i, 1), addedge(i, s, 0);\n\n\tfor (int i = 1; i < n; i++) {\n\t\tint c;\n\t\tread(c);\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tint x;\n\t\t\tread(x);\n\t\t\taddedge(x, n + i, 1), addedge(n + i, x, 0);\n\t\t}\n\t\taddedge(n + i, t, 1), addedge(t, n + i, 0);\n\t}\n\n\tint x = maxflow();\n\tdfs2(s);\n\n\tbool flag = (x == n - 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) flag = false;\n\t}\n\n\tif (flag) {\n\t\te = vector<pair<int, int> > (n);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (par[i] != s) e[par[i] - n] = make_pair(i, par[par[i]]);\n\t\t}\n\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\twrite(e[i].first), putchar(' ');\n\t\t\twrite(e[i].second), putchar('\\n');\n\t\t}\n\n\t}\n\telse puts(\"-1\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\nusing namespace std;\nconst int N=2e5+5;\nstruct edge{int to,nxt,w;}a[N<<2];\nint n,S,T,head[N],cnt=1,dep[N],q[N],hd,tl,cur[N],fa[N],son[N];\nvector<int>E[N];\nvoid link(int u,int v){\n\ta[++cnt]=(edge){v,head[u],1};head[u]=cnt;\n\ta[++cnt]=(edge){u,head[v],0};head[v]=cnt;\n}\nbool bfs(){\n\tmemset(dep,0,sizeof(dep));\n\tdep[q[hd=tl=1]=S]=1;\n\twhile(hd<=tl)\n\t\tfor(int u=q[hd++],e=head[u];e;e=a[e].nxt)\n\t\t\tif(a[e].w&&!dep[a[e].to]){\n\t\t\t\tdep[q[++tl]=a[e].to]=dep[u]+1;\n\t\t\t\tif(a[e].to==T)return true;\n\t\t\t}\n\treturn false;\n}\nint dfs(int u,int f){\n\tif(u==T)return f;int res=0;\n\tfor(int &e=cur[u];e;e=a[e].nxt)\n\t\tif(a[e].w&&dep[a[e].to]==dep[u]+1){\n\t\t\tint d=dfs(a[e].to,min(a[e].w,f));\n\t\t\ta[e].w-=d;a[e^1].w+=d;f-=d;res+=d;\n\t\t\tif(!f)break;\n\t\t}\n\tif(!res)dep[u]=0;return res;\n}\nint dinic(){\n\tint res=0;\n\twhile(bfs())memcpy(cur,head,sizeof(cur)),res+=dfs(S,1<<30);\n\treturn res;\n}\nint main(){\n\tscanf(\"%d\",&n);S=n+n-1;T=S+1;\n\tfor(int i=1,x,y;i<n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tlink(S,i);link(i+n-1,T);\n\t\twhile(x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tif(y>1)link(i,y+n-2);\n\t\t\tE[y].push_back(i);\n\t\t}\n\t}\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)\n\t\tfor(int e=head[i];e;e=a[e].nxt)\n\t\t\tif(!a[e].w)\n\t\t\t\tson[i]=a[e].to-n+2;\n\tq[hd=tl=1]=1;\n\twhile(hd<=tl){\n\t\tint u=q[hd++];\n\t\tfor(int i:E[u])\n\t\t\tif(!fa[i])\n\t\t\t\tfa[i]=u,q[++tl]=son[i];\n\t}\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",fa[i],son[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifdef __WIN32\n#define LLFORMAT \"I64\"\n#else\n#define LLFORMAT \"ll\"\n#endif\n\nusing namespace std;\n\nconst int maxn = 1e5 + 10;\n\nvector<int> E[maxn], has[maxn];\nint ord[maxn], u[maxn], v[maxn], par[maxn];\n\nint F(int u) { return par[u] == u ? u : par[u] = F(par[u]); }\n\nint main() {\n\tios::sync_with_stdio(false);\n\tauto BEG = clock();\n\tint n;\n\tcin >> n;\n\tsrand(time(0));\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tord[i] = i;\n\t\tint sz;\n\t\tcin >> sz;\n\t\tE[i].resize(sz);\n\t\tfor (int j = 0; j < sz; ++j) cin >> E[i][j], --E[i][j];\n\t}\n\trandom_shuffle(ord, ord + n - 1);\n\tfor (int i = 0; i < n; ++i) par[i] = i;\n\tfor (int _i = 0; _i < n - 1; ++_i) {\n\t\tint i = ord[_i];\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tint u = E[i][0], anc = F(u), rem = -1;\n\t\trandom_shuffle(E[i].begin(), E[i].end());\n\t\tfor (int v: E[i]) {\n\t\t\tif(F(v) != anc) {\n\t\t\t\trem = v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(~rem) {\n\t\t\t::u[i] = u;\n\t\t\t::v[i] = rem;\n\t\t\tint fa = F(u), fb = F(rem);\n\t\t\tif(has[fa].size() < has[fb].size()) swap(fa, fb);\n\t\t\thas[fa].insert(has[fa].end(), has[fb].begin(), has[fb].end());\n\t\t\tpar[fb] = fa;\n\t\t\thas[fa].push_back(i);\n\t\t}\n\t\telse {\n\t\t\tif(1. * (clock() - BEG) > 3.6 * CLOCKS_PER_SEC) { puts(\"-1\"); return 0; }\n\t\t\tbool flag = 0;\n\t\t\tfor (int j: has[anc]) if(F(::u[j]) == anc) {\n\t\t\t\tint nrem = -1;\n\t\t\t\tfor (int v: E[j]) if(F(v) != anc) { nrem = v; break; }\n\t\t\t\tif(~nrem) {\n\t\t\t\t\t::v[j] = nrem;\n\t\t\t\t\tint fa = F(::u[j]), fb = F(::v[j]);\n#ifdef DEBUG\n\t\t\t\t\tcout << \"j = \" << j << endl;\n\t\t\t\t\tcout << ::u[j] + 1 << ' ' << ::v[j] + 1 << '\\t' << fa + 1 << ' ' << fb + 1 << endl;\n#endif\n\t\t\t\t\tif(has[fa].size() < has[fb].size()) swap(fa, fb);\n\t\t\t\t\thas[fa].insert(has[fa].end(), has[fb].begin(), has[fb].end());\n\t\t\t\t\tpar[fb] = fa;\n\t\t\t\t\thas[fa].push_back(i);\n\t\t\t\t\t::u[i] = E[i][0];\n\t\t\t\t\t::v[i] = E[i][1];\n\t\t\t\t\tflag = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!flag) { puts(\"-1\"); return 0; }\n\t\t}\n#ifdef DEBUG\n\t\tcout << \"i = \" << i << endl;\n\t\tfor (int i = 0; i < n - 1; ++i) cout << ::u[i] + 1 << ' ' << v[i] + 1 << endl;\n\t\tfor (int u = 0; u < n; ++u) cout << F(u) + 1 << ' '; cout << endl;\n\t\tcout << endl;\n#endif\n\t}\n\tfor (int i = 0; i < n - 1; ++i) cout << u[i] + 1 << ' ' << v[i] + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  vector< int > rev[200000];\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n      rev[x].emplace_back(i);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0)\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> chosen(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0 && eref[i][j].get())\n        chosen[i] = e[i][j];\n  }\n  vector<bool> vis(n);\n  vector<pair<int, int>> ans;\n  ans.reserve(n - 1);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = true;\n    for (int id : fnd[u])\n      if (chosen[id] != -1) {\n        int v = chosen[id];\n        chosen[id] = -1;\n        ans.emplace_back(u + 1, v + 1);\n        dfs(v);\n      }\n  };\n  dfs(0);\n  if (ans.size() != n - 1)\n    cout << \"-1\\n\";\n  else\n    for (const auto& pr : ans)\n      cout << pr.first << ' ' << pr.second << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201000;\n\nint chosen[N];\n\nnamespace MF {\n  struct Edge {\n    int v, flow, ne;\n  }e[N << 3];\n\n  int fi[N], tot, S, T, V, cur[N], dis[N], q[N];\n\n  void Init(int s, int t, int v) {\n    S = s; T = t; V = v;\n    tot = 1;\n    for(int i = 0; i < V; i++) {\n      fi[i] = 0;\n    }\n  }\n\n  void Add(int x, int y, int w) {\n    e[++tot] = {y, w, fi[x]};\n    fi[x] = tot;\n    e[++tot] = {x, 0, fi[y]};\n    fi[y] = tot;\n  }\n  \n  bool Bfs(void) {\n    for(int i = 0; i < V; i++) {\n      dis[i] = 0;\n    }\n    int h = 1, t = 0;\n    q[++t] = S;\n    dis[S] = 1;\n    while(h <= t) {\n      int x = q[h++];\n      for(int i = fi[x]; i; i = e[i].ne) {\n\tif(e[i].flow && !dis[e[i].v]) {\n\t  dis[e[i].v] = dis[x] + 1;\n\t  q[++t] = e[i].v;\n\t}\n      }\n    }\n    return dis[T];\n  }\n\n  int Dfs(int x, int f) {\n    if(x == T) {\n      return f;\n    }\n    int used = 0;\n    for(int &i = cur[x]; i; i = e[i].ne) {\n      if(e[i].flow && dis[e[i].v] == dis[x] + 1) {\n\tint t = Dfs(e[i].v, min(f - used, e[i].flow));\n\tused += t;\n\te[i].flow -= t;\n\te[i ^ 1].flow += t;\n\tif(used == f) {\n\t  return used;\n\t}\n      }\n    }\n    dis[x] = -1;\n    return used;\n  }\n\n  int Solve(void) {\n    int ans = 0;\n    while(Bfs()) {\n      for(int i = 0; i < V; i++) {\n\tcur[i] = fi[i];\n      }\n      ans += Dfs(S, 1e9);\n    }\n    for(int i = 1; i < (V >> 1); i++) {\n      for(int j = fi[i]; j; j = e[j].ne) {\n\tif(!e[j].flow) {\n\t  ::chosen[i] = e[j].v - (V >> 1) + 1;\n\t}\n      }\n    }\n    return ans;\n  }\n}\n\nint n, q[N], full[N];\npair<int, int> ans[N];\nvector<int> in[N];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  MF::Init(0, n * 2 - 1, n << 1);\n  for(int i = 1, k; i < n; i++) {\n    scanf(\"%d\", &k);\n    for(int j = 0, x; j < k; j++) {\n      scanf(\"%d\", &x);\n      x--;\n      if(x) {\n\tMF::Add(i, x + n - 1, 1);\n      }\n      in[x].push_back(i);\n    }\n  }\n  for(int i = 1; i < n; i++) {\n    MF::Add(MF::S, i, 1);\n    MF::Add(i + n - 1, MF::T, 1);\n  }\n  if(MF::Solve() < n - 1) {\n    return puts(\"-1\"), 0;\n  }\n  int h = 1, t = 0;\n  q[++t] = 0;\n  while(h <= t) {\n    int x = q[h++];\n    for(int y : in[x]) {\n      if(full[y]) {\n\tcontinue;\n      }\n      full[y] = 1;\n      q[++t] = chosen[y];\n      ans[y] = {x, chosen[y]};\n    }\n  }\n  if(t < n) {\n    puts(\"-1\");\n  } else {\n    for(int i = 1; i < n; i++) {\n      printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n\n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n\n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n\n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i))\n                    was = 1;\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 100000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 300000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_], vis[N_], UF[N_], vv[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)UF[i] = i;\n\tfor (i = 1; i < n; i++) {\n\t\tw[i] = { Deg[i],i };\n\t}\n\tsort(w + 1, w + n);\n\tint s = 0;\n\twhile (s!=n-1) {\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tint a = w[i].num, c = 0, u[4];\n\t\t\tif (vis[a])continue;\n\t\t\tfor (auto &t : A[a]) {\n\t\t\t\tif (!vv[Find(t)]) {\n\t\t\t\t\tvv[Find(t)] = 1;\n\t\t\t\t\tu[c++] = t;\n\t\t\t\t\tif (c > 2)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (j = 0; j < c; j++)vv[Find(u[j])] = 0;\n\t\t\tif (c == 2) {\n\t\t\t\ts++;\n\t\t\t\tvis[a] = 1;\n\t\t\t\tRes[a][0] = u[0], Res[a][1] = u[1];\n\t\t\t\tMerge(u[0], u[1]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nint main(){\n\tint n; cin >> n;\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; cin >> x;\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; cin >> y; y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tvector<int> seen(n, -2);\n\tqueue<int> q;\n\tint st = -1;\n\tfor(int i = 0; i < n; i++) if(hop.pair_l[i] == -1) st = i;\n\tif(st == -1) bad();\n\tq.push(st); seen[st] = -1;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v : hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq.push(nv);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) cout << pu[i] + 1 << \" \" << pv[i] + 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 200010\n#define M 1000010\n#define maxn 200010\n#define INF 2147483647\nusing namespace std;\nvector<int> node[maxn], pos[maxn];\nint res[maxn][2];\nint id[2][maxn], s = 1, t = 2, cnt = 2, head[N], nxt[M], a[M], r[M], level[N];\nint cur[N], edge, sum, ch[maxn], used[maxn], pre[maxn], dl[N];\nvoid create(int u, int v, int t)\n{\n\tedge++; a[edge] = v; nxt[edge] = head[u]; head[u] = edge; r[edge] = t;\n}\nvoid build()\n{\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tlevel[i] = 0;\n\t\tcur[i] = head[i];\n\t}\n\tint lef = 1, righ = 1;\n\tlevel[s] = 1;\n\tdl[1] = s;\n\twhile (lef <= righ)\n\t{\n\t\tint u = dl[lef];\n\t\tfor (int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = a[i];\n\t\t\tif (r[i] && level[v] == 0)\n\t\t\t{\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tdl[++righ] = v;\n\t\t\t}\n\t\t}\n\t\tlef++;\n\t}\n}\nint dinic(int u, int flow)\n{\n\tif (u == t) return flow;\n\tint ans = 0;\n\tfor (int i = cur[u]; i; i = nxt[i])\n\t{\n\t\tint v = a[i];\n\t\tif (r[i] && level[v] == level[u] + 1)\n\t\t{\n\t\t\tint low = dinic(v, min(flow, r[i]));\n\t\t\tans += low; flow -= low;\n\t\t\tr[i] -= low; if (i % 2) r[i + 1] += low; else r[i - 1] += low;\n\t\t}\n\t}\n\tif (ans == 0) level[u] = -1;\n\treturn ans;\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tid[1][i] = ++cnt;\n\t\tcreate(cnt, t, 1); create(t, cnt, 0);\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tid[0][i] = ++cnt;\n\t\tcreate(s, cnt, 1); create(cnt, s, 0);\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int j = 1; j <= m; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tnode[i].push_back(x);\n\t\t\tpos[x].push_back(i);\n\t\t\tif (x != 1)\n\t\t\t{\n\t\t\t\tcreate(id[0][i], id[1][x], 1);\n\t\t\t\tcreate(id[1][x], id[0][i], 0);\n\t\t\t}\n\t\t}\n\t}\n\tbuild();\n\twhile (level[t])\n\t{\n\t\tsum += dinic(s, INF);\n\t\tbuild();\n\t}\n\tif (sum != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n - 1; i++)\n\t{\n\t\tint u = id[0][i];\n\t\tfor (int j = head[u]; j; j = nxt[j])\n\t\t{\n\t\t\tint v = a[j];\n\t\t\tif (v >= id[1][1] && r[j] == 0) {ch[i] = v - id[1][1] + 1; break;}\n\t\t}\n\t}\n\tint cnt = 1;\n\tpre[1] = 1;\n\tfor (int i = 1; i <= cnt; i++)\n\t{\n\t\tint u = pre[i], len = pos[u].size();\n\t\tfor (int j = 0; j <= len - 1; j++)\n\t\t{\n\t\t\tint x = pos[u][j];\n\t\t\tif (used[x] == 0)\n\t\t\t{\n\t\t\t\tused[x] = 1;\n\t\t\t\tres[x][0] = u; res[x][1] = ch[x];\n\t\t\t\tpre[++cnt] = ch[x];\n\t\t\t}\n\t\t}\n\t}\n\tif (cnt != n) puts(\"-1\");\n\telse\n\tfor (int i = 1; i <= n - 1; i++)\n\t\tprintf(\"%d %d\\n\", res[i][0], res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <utility>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAXN = 210000;\nconst int INF = 1000000000;\n \nstruct edge {\n    int a, b, cap, flow;\n};\n \nint nv, s, t, d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n \nvoid addEdge (int a, int b, int cap) {\n    edge e1 = { a, b, cap, 0 };\n    edge e2 = { b, a, 0, 0 };\n    g[a].push_back ((int) e.size());\n    e.push_back (e1);\n    g[b].push_back ((int) e.size());\n    e.push_back (e2);\n}\n \nbool bfs() {\n    int qh=0, qt=0;\n    q[qt++] = s;\n    memset (d, -1, nv * sizeof d[0]);\n    d[s] = 0;\n    while (qh < qt && d[t] == -1) {\n        int v = q[qh++];\n        for (size_t i=0; i<g[v].size(); ++i) {\n            int id = g[v][i],\n                to = e[id].b;\n            if (d[to] == -1 && e[id].flow < e[id].cap) {\n                q[qt++] = to;\n                d[to] = d[v] + 1;\n            }\n        }\n    }\n    return d[t] != -1;\n}\n \nint dfs (int v, int flow) {\n    if (!flow)  return 0;\n    if (v == t)  return flow;\n    for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n        int id = g[v][ptr[v]],\n            to = e[id].b;\n        if (d[to] != d[v] + 1)  continue;\n        int pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n        if (pushed) {\n            e[id].flow += pushed;\n            e[id^1].flow -= pushed;\n            return pushed;\n        }\n    }\n    return 0;\n}\n\nvector<bool> visited;\nvector<int> via;\n\nvoid dfs2(int v) {\n  visited[v] = true;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    int id = g[v][i];\n    int to = e[id].b;\n    if (!visited[to] && e[id].flow < e[id].cap) {\n      via[to] = v;\n      dfs2(to);\n    }\n  }\n}\n \nint dinic() {\n    int flow = 0;\n    for (;;) {\n        if (!bfs())  break;\n        memset (ptr, 0, nv * sizeof ptr[0]);\n        while (int pushed = dfs (s, INF))\n            flow += pushed;\n    }\n    return flow;\n}\n\nint main() {\n        int n; scanf(\"%d\", &n);\n        nv = 2 * n + 1;\n        s = nv - 2;\n        t = nv - 1;\n        vector<int> left(n);\n        for (int i = 0; i < n; ++i) {\n            left[i] = i;\n            addEdge(s, left[i], 1);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int cur = n + i;\n            int count; scanf(\"%d\", &count);\n            addEdge(cur, t, 1);\n            for (int j = 0; j < count; ++j) {\n                int a; scanf(\"%d\", &a);\n                addEdge(left[a - 1], cur, 1);\n            }\n        }\n        int flow = dinic();\n        if (flow != n - 1) {\n            \n                printf(\"-1\\n\");\n                return 0;\n        }\n        visited = vector<bool>(nv);\n        via = vector<int>(nv);\n        dfs2(s);\n        for (int v : left) {\n            if (!visited[v]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n        vector<int> first(n - 1);\n        vector<int> second(n - 1);\n        for (int v : left) {\n            if (via[v] == s) continue;\n            int u = via[via[v]];\n            first[via[v] - n] = v + 1;\n            second[via[v] - n] = u + 1;\n        }\n        for (int i = 0; i < n - 1; ++i)           {\n            printf(\"%d %d\\n\", first[i], second[i]);\n        }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define REP1(u) for(int i=hd[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)  \n#define REP2(u) for(int&i=cr[u],v,c;v=e[i].v,c=e[i].c,i;i=e[i].n)  \nusing namespace std;\nconst int N=200200,M=1000100,INF=1000010000;\nint n,m,x,S,T,mxf,fl=1;\nint hd[N],cr[N],lk[N],vi[N],fa[N],X[N],Y[N],dep[N];\nqueue<int>q;\nvector<int>ve[N];\nstruct edge{int n,v,c;}e[M];\nvoid add_(int u,int v,int c){e[++fl]=(edge){hd[u],v,c};hd[u]=fl;}\nvoid adde(int u,int v){add_(u,v,1),add_(v,u,0);}\nbool bfs(){\n\tFOR(i,S,T) dep[i]=-1,cr[i]=hd[i];\n\tq.push(S);dep[S]=0;\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tREP1(u)if(c && dep[v]<0)\n\t\t\tdep[v]=dep[u]+1,q.push(v);\n\t}\n\treturn dep[T]>0;\n}\nint dfs(int u,int E){\n\tif(u==T) return E;\n\tint F=0;\n\tREP2(u)if(c && dep[v]==dep[u]+1){\n\t\tint t=dfs(v,min(E,c));\n\t\tF+=t,e[i^1].c+=t;\n\t\tE-=t,e[i^0].c-=t;\n\t\tif(!E) break;\n\t}\n\treturn F;\n}\nint main(){\n\t//freopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tFOR(i,2,n){\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tve[x].push_back(i+n-1);\n\t\t\tif(x>1) adde(x,i+n-1);\n\t\t}\n\t}\n\tS=1;T=n<<1;\n\tFOR(i,2,n) adde(S,i),adde(i+n-1,T);\n\twhile(bfs()) mxf+=dfs(S,INF);\n\tif(mxf<n-1) return puts(\"-1\"),0;\n\tFOR(x,2,n)REP1(x)if(v>S && !c) lk[v]=x;\n\tq.push(1);\n\twhile(q.size()){\n\t\tint u=q.front(),w;q.pop();\n\t\tfor(int v:ve[u])if(!vi[w=lk[v]])\n\t\t\tvi[w]=1,fa[w]=u,X[v]=u,Y[v]=w,q.push(w);\n\t}\n\tFOR(i,2,n)if(!fa[i]) return puts(\"-1\"),0;\n\tFOR(i,2,n) cout<<X[i+n-1]<<' '<<Y[i+n-1]<<'\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201000;\n\nint chosen[N];\n\nnamespace MF {\n  struct Edge {\n    int v, flow, ne;\n  }e[N << 3];\n\n  int fi[N], tot, S, T, V, cur[N], dis[N], q[N];\n\n  void Init(int s, int t, int v) {\n    S = s; T = t; V = v;\n    tot = 1;\n    for(int i = 0; i < V; i++) {\n      fi[i] = 0;\n    }\n  }\n\n  void Add(int x, int y, int w) {\n    e[++tot] = {y, w, fi[x]};\n    fi[x] = tot;\n    e[++tot] = {x, 0, fi[y]};\n    fi[y] = tot;\n  }\n  \n  bool Bfs(void) {\n    for(int i = 0; i < V; i++) {\n      dis[i] = 0;\n    }\n    int h = 1, t = 0;\n    q[++t] = S;\n    dis[S] = 1;\n    while(h <= t) {\n      int x = q[h++];\n      for(int i = fi[x]; i; i = e[i].ne) {\n\tif(e[i].flow && !dis[e[i].v]) {\n\t  dis[e[i].v] = dis[x] + 1;\n\t  q[++t] = e[i].v;\n\t}\n      }\n    }\n    return dis[T];\n  }\n\n  int Dfs(int x, int f) {\n    if(x == T) {\n      return f;\n    }\n    int used = 0;\n    for(int &i = cur[x]; i; i = e[i].ne) {\n      if(e[i].flow && dis[e[i].v] == dis[x] + 1) {\n\tint t = Dfs(e[i].v, min(f - used, e[i].flow));\n\tused += t;\n\te[i].flow -= t;\n\te[i ^ 1].flow -= t;\n\tif(used == f) {\n\t  return used;\n\t}\n      }\n    }\n    dis[x] = -1;\n    return used;\n  }\n\n  int Solve(void) {\n    int ans = 0;\n    while(Bfs()) {\n      for(int i = 0; i < V; i++) {\n\tcur[i] = fi[i];\n      }\n      ans += Dfs(S, 1e9);\n    }\n    for(int i = 1; i < (V >> 1); i++) {\n      for(int j = fi[i]; j; j = e[j].ne) {\n\tif(!e[j].flow) {\n\t  ::chosen[i] = e[j].v - (V >> 1);\n\t}\n      }\n    }\n    return ans;\n  }\n}\n\nint n, q[N], full[N];\npair<int, int> ans[N];\nvector<int> in[N];\n\nint main(void) {\n  scanf(\"%d\", &n);\n  MF::Init(0, n << 1, n << 1 | 1);\n  for(int i = 1, k; i < n; i++) {\n    scanf(\"%d\", &k);\n    for(int j = 0, x; j < k; j++) {\n      scanf(\"%d\", &x);\n      x--;\n      if(x) {\n\tMF::Add(i, x + n, 1);\n      }\n      in[x].push_back(i);\n    }\n  }\n  for(int i = 1; i < n; i++) {\n    MF::Add(MF::S, i, 1);\n    MF::Add(i + n, MF::T, 1);\n  }\n  if(MF::Solve() < n - 1) {\n    return puts(\"-1\"), 0;\n  }\n  int h = 1, t = 0;\n  q[++t] = 0;\n  while(h <= t) {\n    int x = q[h++];\n    for(int y : in[x]) {\n      if(full[y]) {\n\tcontinue;\n      }\n      full[y] = 1;\n      q[++t] = chosen[y];\n      ans[y] = {x, chosen[y]};\n    }\n  }\n  if(t < n) {\n    puts(\"-1\");\n  } else {\n    for(int i = 1; i < n; i++) {\n      printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Jump, and you will find out how to unfold your wings as you fall.\n\n#include<bits/stdc++.h>\n\n#define F first\n#define S second\n#define PB push_back\n#define sz(s) int((s).size())\n#define bit(n,k) (((n)>>(k))&1)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int maxn=2e5+10,Src=maxn-3,Snk=maxn-2,inf=1e8;\n\nvector<pii>v[maxn];\nvector<int>vid[maxn];\nbool mark[maxn];\npii ans[maxn];\nint n,h[maxn],pt[maxn];\n\nvoid add_edge(int a,int b){\n    vid[a].PB(sz(v[b]));\n    vid[b].PB(sz(v[a]));\n    v[a].PB({b,1});\n    v[b].PB({a,0});\n}\n\nbool bfs(){\n    memset(mark,0,sizeof mark);\n    queue<int>q; q.push(Src); mark[Src]=1;\n    while(sz(q)){\n\tint u=q.front();\n\tif(u==Snk) return 1;\n\tq.pop();\n\tfor(pii p:v[u]){\n\t    if(p.S>0 && mark[p.F]==0){\n\t\th[p.F]=h[u]+1;\n\t\tmark[p.F]=1;\n\t\tq.push(p.F);\n\t    }\n\t}\n    }\n    return 0;\n}\nint dfs(int u,int flw=inf){\n    if(u==Snk) return flw;\n    int ans=0,&i=pt[u];\n    while(i<sz(v[u])){\n\tint y=v[u][i].F,&w=v[u][i].S,&w2=v[y][vid[u][i]].S;\n\tif(w>0 && h[u]+1==h[y]){\n\t    int num=dfs(y,min(flw-ans,w));\n\t    w-=num,w2+=num,ans+=num;\n\t    if(ans==flw) return ans;\n\t}\n\t++i;\n    }\n    return ans;\n}\nint flow(){\n    int ans=0;\n    while(bfs()){\n\tmemset(pt,0,sizeof pt);\n\tans+=dfs(Src);\n    }\n    return ans;\n}\n\nvoid go(int u,int par=-1){\n    mark[u]=1;\n    if(u>=n && u!=Src && u!=Snk){\n\tint y=-1;\n\tfor(pii p:v[u]){\n\t    if(p.S!=0)\n\t\ty=p.F;\n\t}\n\tans[u-n]={par+1,y+1};\n    }\n    for(pii p:v[u]){\n\tif(p.S!=0 && mark[p.F]==0)\n\t    go(p.F,u);\n    }\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);cin.tie();\n    cin>>n;\n    for(int i=0;i<n-1;i++){\n\tint N;cin>>N;\n\twhile(N--){\n\t    int x;cin>>x;\n\t    add_edge(--x,i+n);\n\t}\n    }\n    for(int i=0;i<n;i++){\n\tadd_edge(Src,i);\n    }\n    for(int i=n;i<2*n-1;i++){\n\tadd_edge(i,Snk);\n    }\n    int num=flow();\n    if(num!=n-1) return cout<<-1<<endl,0;\n    memset(mark,0,sizeof mark);\n    go(Src);\n    for(int i=0;i<n-1;i++){\n\tif(ans[i].F==0)\n\t    return cout<<-1<<endl,0;\n    }\n    for(int i=0;i<n-1;i++){\n\tcout<<ans[i].F<<\" \"<<ans[i].S<<\"\\n\";\n    }\n}\n\n// Deathly mistakes:\n//  * Read the problem curfully.\n//  * Check maxn.\n//  * Overflows.\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    vector<pair<int, int>> ans(n - 1);\n    for (int it = 0; it < n - 1; it++) {\n      assert(!q.empty());\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      ans[i] = {v + 1, done + 1};\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n    for (auto x : ans) {\n      printf(\"%d %d\\n\", x.first, x.second);\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], fa[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i] < n);\n    }\n    queue < int > q;\n    q.push(n);\n    int cnt = 0;\n    while (!q.empty()) {\n        cnt++;\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!fa[e[i].v]) {\n                q.push(to[e[i].v]);\n                fa[e[i].v] = now;\n            }\n        }\n    }\n    if (cnt != n) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", fa[i], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << (x) << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\n\nstruct MaxFlow{\n\tusing D = int;\n\tconst D inf = 1e9;\n\tstruct edge{\n\t\tint to;\n\t\tD cap;\n\t\tint rev;\n\t\tedge(int to,D cap,int rev):to(to),cap(cap),rev(rev){}\n\t};\n\n\tint V;\n\tvector<vector<edge>> G;\n\tvector<int> level,iter;\n\n\tMaxFlow(int V):V(V){\n\t\tG = vector<vector<edge>>(V);\n\t\tlevel = vector<int>(V);\n\t\titer = vector<int>(V);\n\t}\n\n\tvoid add_edge(int from, int to, D cap){\n\t\tedge e1(to,cap,(int)G[to].size());\n\t\tedge e2(from,0,(int)G[from].size());\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\tvoid bfs(int s){\n\t\tlevel = vector<int>(V,-1);\n\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tD dfs(int v,int t,D f){\n\t\tif(v==t) return f;\n\t\tfor(int &i=iter[v];i<(int)G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tD d = dfs(e.to,t,min(f,e.cap));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tD max_flow(int s,int t){\n\t\tD flow=0;\n\t\twhile(true){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0) return flow;\n\t\t\titer = vector<int>(V,0);\n\t\t\tD f;\n\t\t\twhile( (f=dfs(s,t,inf))>0 ) flow+=f;\n\t\t}\n\t}\n};\n\nstruct Bipartite_matching{\n\tint V;\n\tvector< vector<int> > G;\n\tvector<int> match;\n\tvector<bool> used;\n\tBipartite_matching(int N){\n\t\tV=N;\n\t\tG.assign(V,vector<int>());\n\t\tmatch.assign(V,0);\n\t\tused.assign(V,false);\n\t}\n\tvoid add_edge(int v,int u){\n\t\tG[v].pb(u);\n\t\tG[u].pb(v);\n\t}\n\tbool dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size()){\n\t\t\tint u=G[v][i],w=match[u];\n\t\t\tif(w<0 || (!used[w] && dfs(w))){\n\t\t\t\tmatch[v]=u;\n\t\t\t\tmatch[u]=v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res=0;\n\t\tfill(all(match),-1);\n\t\trep(v,V){\n\t\t\tif(match[v]<0){\n\t\t\t\tfill(all(used),false);\n\t\t\t\tif(dfs(v)) res++;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main(){\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\t\n\tint N;\n\tcin>>N;\n\tVV<int> A(N-1);\n\tVV<int> v2as(N);\n\trep(i,N-1){\n\t\tint K;\n\t\tcin>>K;\n\t\trep(j,K){\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tx--;\n\t\t\tA[i].pb(x);\n\t\t\tv2as[x].pb(i);\n\t\t}\n\t}\n\tBipartite_matching BM(N-1+N);\n\trep(i,N-1){\n\t\tfor(int v:A[i]) BM.add_edge(i,v+N-1);\n\t}\n\tint f = BM.max_matching();\n\tif(f != N-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tV<int> match(N-1);\n\trep(i,N-1) match[i] = BM.match[i] - (N-1);\n\n\t\n\tVV<int> ans(N-1,V<int>(2,-1));\n\trep(i,N-1) ans[i][0] = match[i];\n\n\tint r = 0;\n\trep(i,N) r ^= i;\n\trep(i,N-1) r ^= match[i];\n\tqueue<int> que;\n\tque.push(r);\n\t\n\twhile(!que.empty()){\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor(int i: v2as[v]) if(ans[i][0] != v && ans[i][1] == -1){\n\t\t\tans[i][1] = v;\n\t\t\tque.push(ans[i][0]);\n\t\t}\n\t}\n\trep(i,N-1) if(ans[i][1] == -1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\trep(i,N-1) cout<<ans[i][0]+1<<\" \"<<ans[i][1]+1<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long \nusing namespace std;\nint n,s,t;\nint tot,rd[200005],sz[100005],bg[100005],ed[100005];\nint h[200005],fr[1000005],to[1000005],f[1000005],cnt=1;\nvoid add(int x,int y,int z)\n{\n\tfr[++cnt]=h[x];\n\th[x]=cnt;\n\tto[cnt]=y;\n\tf[cnt]=z;\n}\nint dis[200005];\nbool bfs()\n{\n\tmemset(dis,-1,sizeof(dis));\n\tqueue<int>q;\n\tq.push(s);\n\tdis[s]=0;\n\twhile(!q.empty())\n\t{\n\t\tint now=q.front();\n\t\tq.pop();\n\t\tfor(int i=h[now];i;i=fr[i])\n\t\t{\n\t\t\tif(f[i]&&dis[to[i]]==-1)\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[now]+1;\n\t\t\t\tif(to[i]==t)return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int now)\n{\n\tif(now==t)return 1;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(dis[to[i]]==dis[now]+1&&f[i])\n\t\t{\n\t\t\tint r=dfs(to[i]);\n\t\t\tif(!r)dis[to[i]]=-1;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\t//cout<<now<<' '<<to[i]<<endl;\n\t\t\t\tf[i]=0;\n\t\t\t\tf[i^1]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\twhile(dfs(s))\n\t\t{\n\t\t\tans++;\n\t\t}\n\t}\n\treturn ans;\n}\nint bel[100005],rt,g[100005][2],fa[100005];\nvoid dfs1(int now)\n{\n\tcnt++;\n\tfor(int i=h[now];i;i=fr[i])\n\t{\n\t\tif(!fa[to[i]])\n\t\t{\n\t\t\tfa[to[i]]=now;\n\t\t\tg[bel[to[i]]][0]=now;g[bel[to[i]]][1]=to[i];\n\t\t\tdfs1(to[i]);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&sz[i]);\n\t\tbg[i]=tot+1;\n\t\tfor(int j=1;j<=sz[i];j++)\n\t\t{\n\t\t\tscanf(\"%d\",&rd[tot+1]);\n\t\t\ttot++;\n\t\t}\n\t\ted[i]=tot;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tt=2*n;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t\tfor(int j=bg[i];j<=ed[i];j++)\n\t\t{\n\t\t\tadd(rd[j],i+n,1);\n\t\t\tadd(i+n,rd[j],0);\n\t\t}\n\t}\n\tint flow=dinic();\n\t//cout<<flow<<endl;\n\tif(flow!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=h[i];j;j=fr[j])\n\t\t{\n\t\t\t//cout<<i<<' '<<to[j]<<endl;\n\t\t\tif(to[j]!=s&&f[j]==0)\n\t\t\t{\n\t\t\t\tbel[i]=to[j]-n;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!bel[i])rt=i;\n\t\t//cout<<i<<' '<<bel[i]<<endl;\n\t}\n\tmemset(h,0,sizeof(h));\n\tcnt=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=rt)\n\t\t{\n\t\t\tfor(int j=bg[bel[i]];j<=ed[bel[i]];j++)\n\t\t\t{\n\t\t\t\tif(rd[j]!=i)add(rd[j],i,0);\n\t\t\t}\n\t\t}\n\t}\n\tcnt=0;\n\tdfs1(rt);\n\t//cout<<cnt<<endl;\n\tif(cnt!=n)printf(\"-1\");\n\telse\n\t{\n\t\tfor(int i=1;i<n;i++)\n\t\t{\n\t\t\tprintf(\"%d %d\\n\",g[i][0],g[i][1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tw[i]-=f; w[i^1]+=f; return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs())\n\t\t{\n\t\t\tfr(i,1,n) cur[i]=begin[i];\n\t\t\twhile(dfs(S,n)) ;\n\t\t}\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1;\n\t\tson[x].push_back(ma[v[x][i]]);\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&n+1<=w[i].to&&w[i].to<=n+n-1)\n\t\t\t\tma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 2e5+5;\n\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,\n\t\t\tvi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\n\nint n, m[MAXN], r[MAXN];\nvector<int> g[MAXN];\nvector<vector<int> > e;\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\te.resize(n-1);\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tvi ba(n, -1);\n\tint fl = hopcroftKarp(e, ba);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (ba[i] == -1)\n\t\t\ts = i;\n\t\telse {\n\t\t\tr[i] = ba[i];\n\t\t\tm[ba[i]] = i;\n\t\t\t// cout << ba[i] << ' ' << i << endl;\n\t\t}\n\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tif (m[i] != x) {\n\t\t\t\tg[x].push_back(m[i]);\n\t\t\t\t// cout << x << ' ' << m[i] << endl;\n\t\t\t}\n\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 0; i < n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n#define ri register int\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\t// input a signed integer\n\ttemplate <class I>\n\tinline void gi (I &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = (x << 1) + (x << 3) + (c & 15); x *= f;\n\t}\n\t// print a signed integer\n\ttemplate <class I>\n\tinline void print (I x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: gi;\nusing io :: putc;\nusing io :: print;\nconst int N=2e5+5,M=N<<3;\nint n,q[N],tmp[N],ansx[N],ansy[N];\ninline int min(ri x,ri y){\n\treturn x<y ? x:y;\n}\nstruct flow{\n\tint tot=1,head[N],nxt[M],adj[M],w[M],dep[N],q[N],cur[N],size,s,t;\n\tinline void addedge(ri x,ri y,ri z){\n\t\tnxt[++tot]=head[x];\n\t\tadj[head[x]=tot]=y;\n\t\tw[tot]=z;\n\t}\n\tinline void add(ri x,ri y,ri z){\n\t\taddedge(x,y,z);\n\t\taddedge(y,x,0);\n\t}\n\tinline bool bfs(){\n\t\tri i,l,r,x,y;\n\t\tfor(i=1;i<=size;++i) dep[i]=0;\n\t\tdep[s]=1;\n\t\tq[l=r=1]=s;\n\t\twhile(l<=r){\n\t\t\tx=q[l++];\n\t\t\tfor(i=head[x];i;i=nxt[i])\n\t\t\t\tif(w[i]&&!dep[y=adj[i]])\n\t\t\t\t\tq[++r]=y,\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t}\n\t\treturn dep[t];\n\t}\n\tinline int dfs(ri x,ri now){\n\t\tif(x==t) return now;\n\t\tri y,tmp,res=0;\n\t\tfor(int &i=cur[x];i;i=nxt[i])\n\t\t\tif(w[i]&&dep[y=adj[i]]==dep[x]+1&&(tmp=dfs(y,min(now,w[i])))){\n\t\t\t\tres+=tmp;\n\t\t\t\tw[i]-=tmp;\n\t\t\t\tw[i^1]+=tmp;\n\t\t\t\tif(!(now-=tmp)) return res;\n\t\t\t}\n\t\treturn res;\n\t}\n\tinline long long maxflow(){\n\t\tri i;\n\t\tregister long long res=0;\n\t\twhile(bfs()){\n\t\t\tfor(i=1;i<=size;++i) cur[i]=head[i];\n\t\t\tres+=dfs(s,2147483647);\n\t\t} \n\t\treturn res;\n\t}\n}flow;\nvector<pair<int,int> > v[N];\nvector<int> h[N];\ninline void bfs(){\n\tri i,l,r,x,m=0;\n\tq[l=r=1]=1;\n\twhile(l<=r){\n\t\tx=q[l++];\n\t\tfor(auto o:h[x])\n\t\t\tif(tmp[o]) ++m,ansx[o]=x,ansy[o]=tmp[o],q[++r]=tmp[o],tmp[o]=0;\n\t}\n\tif(m!=n-1) puts(\"-1\");\n\telse\n\t\tfor(i=1;i^n;++i) print(ansx[i]),putc(' '),print(ansy[i]),putc('\\n');\n}\nint main(){\n\tri c,x,i;\n\tgi(n);\n\tfor(i=1;i^n;++i){\n\t\tgi(c);\n\t\twhile(c--){\n\t\t\tgi(x);h[x].push_back(i);\n\t\t\tif(x!=1) flow.add(x,i+n,1),v[i].push_back(make_pair(x,flow.tot));\n\t\t}\n\t}\n\tflow.s=n<<1;\n\tflow.size=flow.t=n<<1|1;\n\tfor(i=2;i<=n;++i) flow.add(flow.s,i,1);\n\tfor(i=n+1;i<flow.s;++i) flow.add(i,flow.t,1);\n\tflow.maxflow();\n\tfor(i=1;i^n;++i)\n\t\tfor(auto o:v[i])\n\t\t\tif(flow.w[o.second]){\n\t\t\t\ttmp[i]=o.first;\n\t\t//\t\tprintf(\"%d %d\\n\",i,o.first);\n\t\t\t\tbreak;\n\t\t\t}\n\tbfs();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 2e5 + 10;\nconst int inf = 1e9;\nstruct E{\n    int to , nex , cap;\n}e[N * 8];int head[N] , ecnt;\n\nvoid init(){ecnt = 1;}\nvoid putin(int fr,int to,int cap) { e[++ecnt]=(E){to,head[fr],cap}; head[fr] = ecnt; }\nvoid adde (int fr,int to,int cap) { putin(fr,to,cap);putin(to,fr,0); }\n\n\nint dep[N];\nqueue <int> q;\nvoid bfs(int s,int t)\n{\n    memset(dep,-1,sizeof dep);\n    dep[s] = 0;q.push(s);\n    \n    while (!q.empty())\n    {\n        int cur = q.front();q.pop();\n        for (int j=head[cur];j;j=e[j].nex)\n        if ( e[j].cap && dep[ e[j].to ] == -1)\n        {\n            dep[ e[j].to ] = dep[ cur ] + 1;\n            q.push( e[j].to );\n        }\n        \n    }\n}\nint iter[N];\nint dfs(int o,int t,int lim)\n{\n    if (o == t || !lim) return lim;\n    \n    int flow = 0;\n\tfor (int &j = iter[o];j;j = e[j].nex)\n    if ( e[j].cap && dep[e[j].to] == dep[o] + 1)\n    {\n        int d = dfs( e[j].to , t , min(lim , e[j].cap ) ) ;\n        flow += d;\n        lim -= d;\n        e[j].cap -= d;\n        e[j^1].cap += d;\n    }\n    \n    return flow;\n}\n\nint dinic(int s,int t,int n)\n{\n    int ans = 0 , f;\n    for (;;)\n    {\n        bfs(s,t);\n//\t\tprintf(\"%d\\n\",dep[t]);\n        if (dep[t] == -1 ) return ans;\n        memcpy(iter,head,sizeof (int) * (n+1) ) ;\n        ans += dfs(s,t,inf);\n    }\n    return ans;\n}\n\nvector <int> G[N];\n\nint apo[N] , sem[N] , bel[N] , n , root;\n\nint main(){\n\tinit();\n\tscanf(\"%d\",&n);\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tint v;scanf(\"%d\",&v);\n\t\t\n\t\twhile (v--){\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tG[u].push_back(i);\n\t\t\tadde(u , i + n , 1);\t\n\t\t}\n\t\tadde(i + n , 2 * n + 1 , 1);\t\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tadde(2 * n , i , 1);\n\t}\n\t\n\tif (dinic(2 * n , 2 * n + 1 , 2 * n + 1) != n - 1) return puts(\"-1\") , 0;\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tfor (int j = head[i + n]; j; j = e[j].nex){\n\t\t\tif (e[j].cap && e[j].to != 2 * n + 1 ){\n\t\t\t\tapo[i] = e[j].to;\n\t\t\t\tbel[e[j].to] = i;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tif (!apo[i]) return puts(\"-1\") , 0;\n\t}\n\t\n\tfor (int i = 1;i <= n;i++){\n\t\tif (!bel[i]) root = i;\n\t}\n\t\n\tq.push(root);\n\twhile (!q.empty()){\n\t\tint cur = q.front();q.pop();\n\t\tfor (int u : G[cur]){\n\t\t\tif (!sem[u]){\n\t\t\t\tsem[u] = cur;\n\t\t\t\tq.push(apo[u]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1;i < n;i++){\n\t\tif (!sem[i]) return puts(\"-1\") , 0;\n\t}\n\tfor (int i = 1;i < n;i++){\n\t\tprintf(\"%d %d\\n\",apo[i],sem[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define N 100010\n#define M 200010\n#define INF 1000000000\nint n;\nstruct EDGE{\n\tint to,c;\n\tEDGE *las;\n} e[M*2];\nint ne;\nEDGE *last[N*2];\nvoid link(int u,int v,int c){\n\te[ne]={v,c,last[u]};\n\tlast[u]=e+ne++;\n}\nint S,T;\nint gap[N*2],BZ,dis[N*2];\nEDGE *cur[N*2];\n#define rev(ei) (e+(int((ei)-e)^1))\nint dfs(int x,int s){\n\tif (x==T)\n\t\treturn s;\n\tint have=0;\n\tfor (EDGE *&ei=cur[x];ei;ei=ei->las)\n\t\tif (ei->c && dis[ei->to]+1==dis[x]){\n\t\t\tint t=dfs(ei->to,min(ei->c,s-have));\n\t\t\tei->c-=t,rev(ei)->c+=t,have+=t;\n\t\t\tif (have==s) return s;\n\t\t}\n\tcur[x]=last[x];\n\tif (!--gap[dis[x]])\n\t\tBZ=0;\n\t++dis[x];\n\t++gap[dis[x]];\n\treturn have;\n}\nint flow(){\n\tgap[0]=T;\n\tBZ=1;\n\tint r=0;\n\twhile (BZ)\n\t\tr+=dfs(S,INF);\n\treturn r;\n}\nint bel[N];\nbool vis[N*2];\nint ans[N][2];\nint cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\t++cnt;\n\tfor (EDGE *ei=last[x];ei;ei=ei->las)\n\t\tif (ei->to!=S && !vis[ei->to]){\n\t\t\tvis[ei->to]=1;\n\t\t\tans[ei->to-n][0]=x;\n\t\t\tans[ei->to-n][1]=bel[ei->to-n];\n\t\t\tdfs(bel[ei->to-n]);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;++i){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor (int j=0;j<k;++j){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tlink(x,n+i,1),link(n+i,x,0);\n\t\t}\n\t}\n\tS=n+n-1+1,T=n+n-1+2;\n\tfor (int i=1;i<=n;++i)\n\t\tlink(S,i,1),link(i,S,0);\n\tfor (int i=1;i<n;++i)\n\t\tlink(n+i,T,1),link(T,n+i,0);\n\tint f=flow();\n\tif (f!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;++i)\n\t\tfor (EDGE *ei=last[n+i];ei;ei=ei->las)\n\t\t\tif (ei->to!=T && ei->c)\n\t\t\t\tbel[i]=ei->to;\n\tint r=0;\n\tfor (int i=1;i<=n;++i)\n\t\tfor (EDGE *ei=last[i];ei;ei=ei->las)\n\t\t\tif (ei->to==S && !ei->c)\n\t\t\t\tr=i;\n\tdfs(r);\n\tif (cnt<n)\n\t\tprintf(\"-1\\n\");\n\telse\n\t\tfor (int i=1;i<n;++i)\n\t\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[N],got[N],tak[N];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[tot]=x,b[tot]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  vector< int > rev[200000];\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n      rev[x].emplace_back(i);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N - 1; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\treturn 0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int maxn = 100100;\nint seen[maxn], q[maxn];\nint main(){\n\tint n; scanf(\"%d\", &n);\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; scanf(\"%d\", &x);\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; scanf(\"%d\", &y); y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tint st = n - 1, tp = 0;\n\tfor(int i = 0; i < n; i++) seen[i] = -2;\n\tq[tp++] = st; seen[st] = -1;\n\tfor(int tu = 0; tu < tp; tu++){\n\t\tint u = q[tu];;\n\t\tfor(int v : hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq[tp++] = nv;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) \n\t\tprintf(\"%d %d\\n\", pu[i] + 1, pv[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &i : x) cin >> i;\n\t\ta.pb({x, i});\n\t}\n\tsort(all(a), [](auto i, auto j) {\n\t\treturn i.first.size() < j.first.size();\n\t});\n\trans.resize(n-1);\n\tdsu d(n);\n\tfor(auto [i, idx] : a) {\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tif(d.r[d.par(1)] != n) return cout << -1, 0;\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],gap[N << 1],dis[N << 1],pos[N],vis[N];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline int isap(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = isap(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]];\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tfor(gap[0] = T;dis[S] < T;) ans += isap(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=400010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tvector<pair<int,int> >ans;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans.push_back(make_pair(u,link[v]));\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,0,SZ(ans)-1)cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_];\nvector<int>A[N_], B[N_];\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", A[i][0], A[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace flow{\n\tconst int _ = 1e6 + 7 , __ = 1e7 + 7;\n\tstruct Edge{int end , upEd , f;}Ed[__];\n\tint head[_] , dep[_] , cur[_] , cntEd = 1 , S , T;\n\n\tvoid addEd(int a , int b , int c){Ed[++cntEd] = (Edge){b , head[a] , c}; head[a] = cntEd;}\n\tvoid addE(int a , int b , int c){addEd(a , b , c); addEd(b , a , 0);}\n\t\n\tqueue < int > q;\n\tbool bfs(){\n\t\tmemset(dep , 0 , sizeof(int) * (T + 1)); while(!q.empty()) q.pop();\n\t\tdep[S] = 1; q.push(S);\n\t\twhile(!q.empty()){\n\t\t\tint t = q.front(); q.pop();\n\t\t\tfor(int i = head[t] ; i ; i = Ed[i].upEd)\n\t\t\t\tif(Ed[i].f && !dep[Ed[i].end]){\n\t\t\t\t\tdep[Ed[i].end] = dep[t] + 1;\n\t\t\t\t\tif(Ed[i].end == T){memcpy(cur , head , sizeof(int) * (T + 1)); return 1;}\n\t\t\t\t\tq.push(Ed[i].end);\n\t\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tint dfs(int x , int mn){\n\t\tif(x == T) return mn;\n\t\tint sum = 0;\n\t\tfor(int &i = cur[x] ; i ; i = Ed[i].upEd)\n\t\t\tif(Ed[i].f && dep[Ed[i].end] == dep[x] + 1){\n\t\t\t\tint t = dfs(Ed[i].end , min(mn - sum , Ed[i].f));\n\t\t\t\tsum += t; Ed[i].f -= t; Ed[i ^ 1].f += t;\n\t\t\t\tif(sum == mn) break;\n\t\t\t}\n\t\treturn sum;\n\t}\n\n\tint Dinic(int s , int t){int sum = 0; S = s; T = t; while(bfs()) sum += dfs(s , 1e9); return sum;}\n}using namespace flow;\n\nint read(){\n\tint a = 0; char c = getchar();\n\twhile(!isdigit(c)) c = getchar();\n\twhile(isdigit(c)){a = a * 10 + c - 48; c = getchar();}\n\treturn a;\n}\n\nint N , pos[200003] , E[200003][2]; vector < int > id[200003];\n\nint main(){\n\tN = read();\n\tfor(int i = 2 ; i <= N ; ++i) addE(0 , i , 1);\n\tfor(int i = 1 ; i < N ; ++i){\n\t\taddE(N + i , N + N , 1);\n\t\tfor(int p , x = read() ; x ; --x){addE(p = read() , i + N , 1); id[p].push_back(i);}\n\t}\n\tif(Dinic(0 , N + N) != N - 1){puts(\"-1\"); return 0;}\n\tfor(int i = 2 ; i <= N ; ++i)\n\t\tfor(int j = head[i] ; j ; j = Ed[j].upEd)\n\t\t\tif(Ed[j].end > N && !Ed[j].f){pos[Ed[j].end - N] = i; break;}\n\tqueue < int > q; q.push(1);\n\twhile(!q.empty()){\n\t\tint t = q.front(); q.pop();\n\t\tfor(auto x : id[t]) if(pos[x]){E[x][0] = t; E[x][1] = pos[x]; q.push(pos[x]); pos[x] = 0;}\n\t}\n\tfor(int i = 1 ; i < N ; ++i) printf(\"%d %d\\n\" , E[i][0] , E[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nstruct Unfo{int nu,we;}d[N];\nint n,p,num=1,b[N],s,t,di[N],li[N],ansn,nu,cur[N],no[N],an[N];\nbool vi[N];\nbool comp(const Unfo &a,const Unfo &b){return a.nu<b.nu;}\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0&&di[a[y].nu]==di[x]+1){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<n;i++){\n\t\tread(p);\n\t\twhile(p--){read(d[++nu].nu);d[nu].we=i;if(d[nu].nu!=1){jb(i,d[nu].nu+n,1);}}\n\t}\n\tsort(d+1,d+nu+1,comp);\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++)jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\tfor (int i=1,j=0;i<=n;i++){f[i].be=j+1;while (d[j+1].nu==i)j++;f[i].en=j;}\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t\tfor (int i=1;i<n;i++)\n\t\t\tfor (int j=b[i];j;j=a[j].ne)\n\t\t\t\tif (a[j].nu!=s&&a[j].qu==0)no[i]=a[j].nu-n;\n\t\tfor (int i=1;i<n;i++) vi[i]=true;\n\t\tint l=1,r=1;li[l]=1;\n\t\twhile (l<=r){\n\t\t\tfor (int i=f[li[l]].be;i<=f[li[l]].en;i++){\n\t\t\t\tif (vi[d[i].we]){\n\t\t\t\t\tvi[d[i].we]=false;li[++r]=no[d[i].we];\n\t\t\t\t\tan[d[i].we]=li[l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tl++;\n\t\t}\n\t\tif (r!=n)cout<<\"-1\"<<endl;\n\t\telse{\n\t\t\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",an[i],no[i]);\n\t\t}\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], cur[M], S, T;\nint q[M], q0;\n\nint bfs() {\n\tfo(i, 1, T) d[i] = 0, cur[i] = fi[i];\n\tq[q0 = 1] = S; d[S] = 1;\n\tfor(int i = 1; i <= q0; i ++) {\n\t\tint x = q[i];\n\t\tfor(int j = fi[x]; j; j = nt[j]) if(r[j])\n\t\t\tif(!d[to[j]]) d[to[j]] = d[x] + 1, q[++ q0] = to[j];\n\t} \n\treturn d[T] > 0;\n}\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] + 1 == d[to[i]] && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\twhile(bfs()) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <set>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100]; set<int> W[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tif (N == 2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t\tW[x].insert(i);\n\t\t}\n\t}\n\n\tfor (int i=1;i<=N;i++){\n\t\tif (W[i].size() == 0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tstack<int> s;\n\tfor (int i=0;i<N-1;i++){\n\t\tint c = 0;\n\t\tfor (int x : G[i]) if (W[x].size() == 1) c++;\n\t\tif (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\telse if (c == 1){\n\t\t\ts.push(i);\n\t\t}\n\t}\n\n\twhile (!s.empty()){\n\t\tint i = s.top(), v = 0, c = 0; s.pop();\n\t\tfor (int x : G[i]){\n\t\t\tif (W[x].size() == 1) v = x, c++;\n\t\t\tW[x].erase(i);\n\t\t\tif (W[x].size() == 1) s.push(*W[x].begin());\n\t\t}\n\t\tif (c == 1){\n\t\t\tint x = v;\n\t\t\tint y = G[i][0]==v?G[i][1]:G[i][0];\n\t\t\tX[i] = x; Y[i] = y;\n\t\t}\n\t\telse if (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tG[i].clear();\n\t}\n\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++) if (!G[i].empty()){\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsort(v.begin(),v.end());\n\tsrand(time(NULL));\n\tfor (int t=0;t<1000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint H, W, N;\nint A[MAX_N], B[MAX_N];\nvi Q[MAX_N];\nvi vx;\n\nint fd(int a) {\n\treturn lower_bound(all(vx), a) - vx.begin();\n}\n\nvoid solve() {\n\tcin >> H >> W >> N;\n\trep(i, 0, N) {\n\t\tcin >> A[i] >> B[i]; A[i]--; B[i]--;\n\t\tvx.pb(B[i]);\n\t}\n\tsort(all(vx));\n\tvx.erase(unique(all(vx)), vx.end());\n\trep(i, 0, N) {\n\t\tint at = fd(B[i]);\n\t\tQ[at].pb(A[i]);\n\t}\n\trep(i, 0, sz(vx)) Q[i].pb(H);\n\tint M = sz(vx);\n\trep(i, 0, M) sort(all(Q[i]));\n\tint x = 0, y = 0;\n\tint res = H;\n\trep(i, 0, M) {\n\t\tif(vx[i] == 0) MIN(res, Q[0][0]);\n\t\telse {\n\t\t\tint pre = vx[i] - 1;\n\t\t\ty += pre - x;\n\t\t\t// debug(pre, y, i, Q[i]);\n\t\t\tint at = upper_bound(all(Q[i]), y) - Q[i].begin();\n\t\t\tint d = H;\n\t\t\tint pat = fd(pre);\n\t\t\tif(pat != M && vx[pat] == pre) {\n\t\t\t\td = *upper_bound(all(Q[pat]), y);\n\t\t\t}\n\t\t\twhile(Q[i][at] == y + 1 && y + 1 < d) {\n\t\t\t\tat++;\n\t\t\t\ty++;\n\t\t\t}\n\t\t\tMIN(res, d);\n\t\t\tMIN(res, *upper_bound(all(Q[i]), y));\n\t\t\tif(y == d - 1) break;\n\t\t\tx = pre;\n\t\t}\n\t}\n\tcout << res << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define inf 2123333333\n#define pii pair<int,int>\n\nstruct node { int t,v,op,next; }a[1000010];\n\nvector<int> v[200010];\nqueue<int> q;\n\npii ans[100010];\n\nint level[200010],head[200010],cur[200010],num[200010],to[200010],n,vs,vt,tt,tot;\nbool inq[200010];\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void print(int x)\n{\n\tstatic char s[233];\n\tif (!x) { putchar('0');putchar(' ');return; }\n\tint tot=0;\n\tfor (;x;x/=10) s[++tot]=x%10+'0';\n\tfor (;tot;tot--) putchar(s[tot]);\n\tputchar(' ');\n}\n\ninline void add(int x,int y,int z)\n{\n\ta[++tot].t=y;a[tot].v=z;a[tot].op=tot+1;a[tot].next=head[x];head[x]=tot;\n\ta[++tot].t=x;a[tot].v=0;a[tot].op=tot-1;a[tot].next=head[y];head[y]=tot;\n}\n\ninline bool bfs()\n{\n\twhile (!q.empty()) q.pop();\n\tmemset(level,0,sizeof(level));\n\tq.push(vs);level[vs]=1;cur[vs]=head[vs];\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tfor (int i=head[x];i;i=a[i].next) if (a[i].v)\n\t\t{\n\t\t\tint t=a[i].t;\n\t\t\tif (level[t]) continue;\n\t\t\tlevel[t]=level[x]+1;cur[t]=head[t];\n\t\t\tif (t==vt) return true;\n\t\t\tq.push(t);\n\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int y)\n{\n\tif (x==vt||!y) return y;\n\tint res=0;\n\tfor (int &i=cur[x];i;i=a[i].next) if (a[i].v)\n\t{\n\t\tint t=a[i].t;\n\t\tif (level[t]!=level[x]+1) continue;\n\t\tint hh=dfs(t,min(y,a[i].v));\n\t\tif (!hh) continue;\n\t\tres+=hh;y-=hh;\n\t\ta[i].v-=hh;a[a[i].op].v+=hh;\n\t\tif (!y) break;\n\t}\n\treturn res;\n}\n\ninline void insert(int x)\n{\n\tfor (int t:v[x]) num[t]=x,q.push(t);\n}\n\nint main()\n{\n\tn=rd();vs=0;vt=n*2;tot=0;\n\tfor (int i=1;i<=n;i++) add(vs,i,1);\n\tfor (int i=1;i<n;i++) add(n+i,vt,1);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint k=rd();\n\t\tfor (int j=1;j<=k;j++)\n\t\t{\n\t\t\tint x=rd();\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\tint sum=0;\n\twhile (bfs()) sum+=dfs(vs,inf);\n\tif (sum<n-1) { puts(\"-1\");return 0; }\n\tint id=0;\n\tfor (int i=head[vs];i;i=a[i].next) if (a[i].v) id=a[i].t;\n\tfor (int i=1;i<=n;i++) for (int j=head[i];j;j=a[j].next) if (a[j].t>n&&!a[j].v) to[a[j].t-n]=i;\n\twhile (!q.empty()) q.pop();\n\tinsert(id);tt=0;\n\twhile (!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tif (inq[x]) continue;\n\t\tans[x]=pii(num[x],to[x]);\n\t\tinsert(to[x]);inq[x]=true;tt++;\n\t}\n\tif (tt<n-1) { puts(\"-1\");return 0; }\n\tfor (int i=1;i<=tt;i++) print(ans[i].first),print(ans[i].second),putchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int N=1000005;\nint n,i,j,k,l,tot,pt[N],tk[N],head[N],adj[N],nxt[N],flow[N],cap[N],cur[N],d[N],q[N],bg,ed;\nbool v[N];\nvector<int> bl[N];\nvoid addedge(int u,int v,int w)\n{\n\tadj[++l]=v;\n\tnxt[l]=head[u];\n\thead[u]=l;\n\tcap[l]=w;\n\tadj[++l]=u;\n\tnxt[l]=head[v];\n\thead[v]=l;\n\tcap[l]=0;\n}\nbool bfs()\n{\n\tint i;\n\tfor(i=1;i<=tot;++i)\n\t\td[i]=1<<30;\n\td[tot-1]=0;\n\tq[bg=ed=1]=tot-1;\n\twhile(bg<=ed)\n\t{\n\t\tfor(i=head[q[bg]];i;i=nxt[i])\n\t\t\tif(flow[i]<cap[i]&&d[adj[i]]==(1<<30))\n\t\t\t{\n\t\t\t\td[adj[i]]=d[q[bg]]+1;\n\t\t\t\tq[++ed]=adj[i];\n\t\t\t}\n\t\t++bg;\n\t}\n\treturn d[tot]!=(1<<30);\n}\nint dfs(int x,int a)\n{\n\tif(x==tot||a<=0)\n\t\treturn a;\n\tint g,h=0;\n\tfor(;cur[x];cur[x]=nxt[cur[x]])\n\t\tif(d[adj[cur[x]]]==d[x]+1&&(g=dfs(adj[cur[x]],min(a,cap[cur[x]]-flow[cur[x]])))>0)\n\t\t{\n\t\t\tflow[cur[x]]+=g;\n\t\t\tflow[cur[x]&1?cur[x]+1:cur[x]-1]-=g;\n\t\t\ta-=g;\n\t\t\th+=g;\n\t\t\tif(a<=0)\n\t\t\t\tbreak;\n\t\t}\n\treturn h;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ttot=2*n;\n\tfor(i=1;i<n;++i)\n\t{\n\t\tscanf(\"%d\",&k);\n\t\twhile(k--)\n\t\t{\n\t\t\tscanf(\"%d\",&j);\n\t\t\tbl[j].push_back(i);\n\t\t\tif(j<n)\n\t\t\t\taddedge(i,n-1+j,1);\n\t\t}\n\t\taddedge(tot-1,i,1);\n\t\taddedge(n-1+i,tot,1);\n\t}\n\tk=0;\n\twhile(bfs())\n\t{\n\t\tfor(i=1;i<=tot;++i)\n\t\t\tcur[i]=head[i];\n\t\tk+=dfs(tot-1,1<<30);\n\t}\n\tif(k<n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<n;++i)\n\t\tfor(j=head[i];j;j=nxt[j])\n\t\t\tif(adj[j]!=tot-1&&flow[j]==cap[j])\n\t\t\t{\n\t\t\t\tpt[i]=adj[j]-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\tq[bg=ed=1]=n;\n\tfor(i=1;i<=n;++i)\n\t\tv[i]=false;\n\tv[n]=true;\n\twhile(bg<=ed)\n\t{\n\t\tfor(i=bl[q[bg]].size()-1;i>=0;--i)\n\t\t\tif(!v[pt[bl[q[bg]][i]]])\n\t\t\t{\n\t\t\t\tq[++ed]=pt[bl[q[bg]][i]];\n\t\t\t\tv[q[ed]]=true;\n\t\t\t\ttk[bl[q[bg]][i]]=q[bg];\n\t\t\t}\n\t\t++bg;\n\t}\n\tfor(i=1;i<n;++i)\n\t\tif(!tk[i])\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(i=1;i<n;++i)\n\t\tprintf(\"%d %d\\n\",pt[i],tk[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint s[Nmax];\nint n;\nbool unlocked[Nmax];\nvector<int> v[Nmax], w[Nmax];\npair<int, int> edge[Nmax];\n\nclass Graph\n{\n    vector<int> v[Nmax];\n    bool used[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(used[node]) return 0;\n        used[node] = 1;\n\n        for(auto it : v[node])\n            if(!R[it])\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : v[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        v[x].push_back(y);\n    }\n\n    bool cuplaj()\n    {\n        bool done = 1; int i;\n        while(done)\n        {\n            done = 0;\n            for(i=1; i<=n; ++i) used[i] = 0;\n\n            for(i=1; i<=n; ++i)\n                if(!L[i]) done |= cupleaza(i);\n        }\n\n        for(i=1; i<n; ++i)\n        {\n            s[i] = R[i];\n            if(!s[i]) return 0;\n        }\n        return 1;\n    }\n\n} graph;\n\nvoid build_sol()\n{\n    queue<int> q;\n    q.push(n);\n\n    int node, nr = n-1;\n    while(q.size())\n    {\n        node = q.front();\n        q.pop();\n\n        for(auto it : w[node])\n            if(!unlocked[s[it]])\n            {\n                q.push(s[it]);\n                unlocked[s[it]] = 1;\n                edge[it] = {node, s[it]};\n                --nr;\n            }\n    }\n\n    if(nr)\n    {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    int i;\n    for(i=1; i<n; ++i) cout << edge[i].first << ' ' << edge[i].second << '\\n';\n}\n\nint main()\n{\n  //  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    int i, nr, x;\n    cin >> n;\n    for(i=1; i<n; ++i)\n    {\n        cin >> nr;\n        while(nr--)\n        {\n            cin >> x;\n            v[i].push_back(x);\n            w[x].push_back(i);\n            if(x < n) graph.add_edge(x, i);\n        }\n    }\n\n    if(!graph.cuplaj())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    build_sol();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef BZ\n#pragma GCC optimize \"-O3\"\n#endif\n#include <bits/stdc++.h>\n\n#define FASTIO\n#define ALL(v) (v).begin(), (v).end()\n#define rep(i, l, r) for (int i = (l); i < (r); ++i)\n\n#ifdef FASTIO\n#define scanf abacaba\n#define printf abacaba\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\n\n/*\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\n*/\n\nconst int MAXN = 120000;\n\nvector<int> eds[MAXN];\n\nint p[MAXN];\nint q[MAXN];\n\nint n;\n\nint was[MAXN];\n\nint dfs1(int v) {\n\twas[v] = 1;\n\tfor (int u: eds[v]) {\n\t\tif (q[u] == -1) {\n\t\t\tq[u] = v;\n\t\t\tp[v] = u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor (int u: eds[v]) {\n\t\tif (!was[q[u]]) {\n\t\t\tif (dfs1(q[u])) {\n\t\t\t\tq[u] = v, p[v] = u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nvector<int> go[MAXN];\nint up[MAXN];\n\nvoid dfs2(int v, int p) {\n\twas[v] = 1;\n\tup[v] = p;\n\tfor (int u: go[v]) {\n\t\tif (!was[u])\n\t\t\tdfs2(u, v);\n\t}\n}\n\nint main() {\n#ifdef FASTIO\n\tios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n#endif\n\tcin >> n;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint c;\n\t\tcin >> c;\n\t\tfor (int j = 0; j < c; ++j) {\n\t\t\tint x;\n\t\t\tcin >> x;\n\t\t\t--x;\n\t\t\teds[i].push_back(x);\n\t\t}\n\t}\n\tfill(p, p + n, -1);\n\tfill(q, q + n, -1);\n\tint ch = 0;\n\tdo {\n\t\tch = 0;\n\t\tmemset(was, 0, sizeof(was));\n\t\tfor (int i = 0; i < n - 1; ++i) {\n\t\t\tif (was[i] == 0 && p[i] == -1)\n\t\t\t\tch |= dfs1(i);\n\t\t}\n\t} while (ch);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (p[i] == -1) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tint st = -1;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (q[i] == -1) {\n\t\t\tst = i;\n\t\t\tq[i] = n - 1;\n\t\t}\n\tp[n - 1] = st;\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tfor (int u: eds[i]) {\n\t\t\tif (q[u] != i) {\n\t\t\t\tgo[q[u]].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(was, 0, sizeof(was));\n\tdfs2(n - 1, -1);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tif (!was[i]) {\n\t\t\tcout << -1 << \"\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tcout << p[i] + 1 << \" \" << p[up[i]] + 1 << \"\\n\";\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nstruct Dinic {\n    typedef int Flow;\n    static const Flow INF = 1<<29;\n    struct Edge {\n\tint src, dst;\n\tFlow cap;\n\tint rev;\n    };\n    typedef vector<vector<Edge> > Graph;\n    Graph G;\n    vector<int>len, iter;\n    Dinic(int N) : G(N) {}\n    void add_edge(int u, int v, Flow c) {\n\tG[u].push_back((Edge){ u, v, c, (int)G[v].size() });\n\tG[v].push_back((Edge){ v, u, 0, (int)G[u].size()-1 });\n    }\n    Flow dfs(int v, int s, Flow c) {\n\tif (v == s || c == 0) return c;\n\tFlow ret = 0;\n\tfor (int &i=iter[v]; i<(int)G[v].size(); i++) {\n\t    Edge &e = G[v][i], &re = G[e.dst][e.rev];\n\t    if (re.cap > 0 && len[v] > len[e.dst]) {\n\t\tFlow f = dfs(e.dst, s, min(c-ret, re.cap));\n\t\tret += f;\n\t\te.cap += f; re.cap -= f;\n\t\tif (ret == c) break;\n\t    }\n\t}\n\treturn ret;\n    }\n    void bfs(int s) {\n\tlen.assign(G.size(), -1);\n\tqueue<int>qu;\n\tqu.push(s);\n\tlen[s] = 0;\n\tfor (;!qu.empty();) {\n\t    int v = qu.front(); qu.pop();\n\t    for (int i=0; i<(int)G[v].size(); i++) {\n\t\tconst Edge &e = G[v][i];\n\t\tif (e.cap > 0 && len[e.dst] == -1) {\n\t\t    len[e.dst] = len[v] + 1;\n\t\t    qu.push(e.dst);\n\t\t}\n\t    }\n\t}\n    }\n    Flow _flow;\n    Flow flow(int source, int sink, Flow limit=-1) {\n\tif (limit == -1) limit = INF;\n\tFlow ret = 0;\n\twhile (true) {\n\t    bfs(source);\n\t    if (len[sink] == -1 || limit == 0) return _flow = ret;\n\t    iter.assign(G.size(), 0);\n\t    Flow tmp = dfs(sink, source, limit);\n\t    ret += tmp;\n\t    limit -= tmp;\n\t}\n    }\n};\n\nconst Dinic::Flow Dinic::INF;\nint N;\nVI E[100011];\nVI R[100011];\nVI G[100011];\nbool use[100011];\npair<int, int> ans[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint K;\n\tscanf(\"%d\", &K);\n\tE[i].resize(K);\n\tREP (j, K) scanf(\"%d\", &E[i][j]), E[i][j]--;\n    }\n\n    int RIGHT = N-1;\n    int SRC = RIGHT+N-1, SNK = SRC+1;\n    Dinic D(SNK+1);\n\n    REP (i, N-1) {\n\tG[i] = E[i];\n\tG[i].erase(remove(G[i].begin(), G[i].end(), N-1), G[i].end());\n\tEACH (e, E[i]) {\n\t    R[*e].push_back(i);\n\n\t    if (*e < N-1) D.add_edge(i, *e + RIGHT, 1);\n\t}\n\n\tD.add_edge(SRC, i, 1);\n\tD.add_edge(i+RIGHT, SNK, 1);\n    }\n\n    if (D.flow(SRC, SNK) == N-1) {\n\tVI ord; ord.reserve(N);\n\tord.push_back(N-1);\n\tuse[N-1] = true;\n\tfor (int i=0; i<(int)ord.size(); i++) {\n\t    int v = ord[i];\n\t    EACH (e, R[v]) if (!use[*e]) {\n\t\tint w;\n\t\tEACH (f, D.G[*e]) if (f->dst != SRC && f->cap == 0) {\n\t\t    w = f->dst - RIGHT;\n\t\t}\n\t\tans[*e] = make_pair(v, w);\n\t\tord.push_back(w);\n\t\tuse[*e] = true;\n\t    }\n\t}\n\n\tif ((int)ord.size() == N) {\n\t    REP (i, N-1) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t    return;\n\t}\n    }\n    puts(\"-1\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv, is_forb;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e[a].PB(Edge{b, cap, SZ(e[b]), 0});\n    e[b].PB(Edge{a, bi_dir * cap, SZ(e[a]) - 1, 0});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    //e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n\n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n//     for (int i = 0; i <= n; i++) {\n//       dis[i] = n + 1;\n//     }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        if (edge.is_forb) { continue; }\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      if (e[v][i].is_forb) { continue; }\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<int> halko;\n    for (int ii = 0; ii < SZ(gr.e[i]); ii++) {\n      auto edge = gr.e[i][ii];\n    //for (auto& edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        debug(i, edge.v);\n        int poszlo = Dinic::kInf - edge.c;\n        gr.e[i][ii].c = 0;\n        gr.e[edge.v][edge.inv].c = 0;\n        assert(gr.e[source][i - 1].v == i);\n        gr.e[source][i - 1].c += poszlo;\n        assert(gr.e[i][0].v == source);\n        gr.e[i][0].c -= poszlo;\n        assert(gr.e[edge.v][0].v == sink);\n        gr.e[edge.v][0].c += poszlo;\n        assert(gr.e[sink][edge.v - n - 1].v == edge.v);\n        gr.e[sink][edge.v - n - 1].c -= poszlo;\n        int new_flow = gr.MaxFlow(source, sink);\n        if (new_flow == poszlo) {\n          debug(\"wywal\");\n        } else {\n          halko.PB(edge.v - n);\n          gr.e[i][ii].c = Dinic::kInf;\n          gr.e[edge.v][edge.inv].c = 0;\n          int newer_flow = gr.MaxFlow(source, sink);\n          //debug(new_flow, new_flow, poszlo);\n          assert(new_flow + newer_flow == poszlo);\n        }\n        //halko.PB({edge.v - n, );\n      } else {\n        gr.e[i][ii].c = 0;\n      } \n    }\n//     vector<int> filter;\n//     for (auto v : halko) {\n//       \n//       \n//     }\n    debug(halko);\n    assert(SZ(halko) == 2);\n    for (auto x : halko) {\n      cout<<x<<\" \";\n    }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nint p[N],fa[N];\nint get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}\npii ans[N];\nint la;\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n)fa[i]=i;\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(get(x)!=p[i]){\n                ans[++la]={x,p[i]},fa[p[i]]=x;\n                //printf(\"x=%d\\n\",x);\n                break;\n            }\n        }\n    }\n    if(la<n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],pos[N],vis[N],dis[N << 1];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline bool bfs() {\n\tqueue <int> q;\n\tmemset(dis,0,sizeof(dis));\n\tq.push(S),dis[S] = 1;\n\twhile(!q.empty()) {\n\t\tint x = q.front();q.pop();\n\t\tif(x == T) return true;\n\t\tfor(int i = beg[x];i;i = nex[i])\n\t\t\tif(!dis[to[i]] && flow[i]) {\n\t\t\t\tdis[to[i]] = dis[x] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] + 1 == dis[to[i]]) {\n\t\t\tint val = dfs(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\twhile(bfs()) ans += dfs(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=z,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||!c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//\n//10^5210^5\n//\n//maxv\nconst int maxv = 512810;\n \nstruct e_t { int to, cap, rev; };\n \nint V, S, T;\nvector<e_t> adj[maxv];\n \nint rej[maxv];\nint red[maxv];\n \nvoid aedge(int i, int j, int c) {\n  adj[i].pb((e_t){j, c, adj[j].size() + (i == j ? 1 : 0)});\n  adj[j].pb((e_t){i, 0, adj[i].size() - 1});\n}\n \nvoid bfs() {\n  memset(rej, -1, sizeof(rej));\n  queue<int> q;\n  rej[S] = 0;\n  q.push(S);\n  while (!q.empty()) {\n    int v = q.front();\n    q.pop();\n    for (int i = 0; i < (int)adj[v].size(); i++) {\n      e_t &e = adj[v][i];\n      if (e.cap <= 0) continue;\n      if (rej[e.to] != -1) continue;\n      q.push(e.to);\n      rej[e.to] = rej[v] + 1;\n    }\n  }\n}\n \nint dfs(int v, int flow) {\n  if (v == T || flow == 0) return flow;\n  for (; red[v] < (int)adj[v].size(); red[v]++) {\n    e_t &e = adj[v][red[v]];\n    if (rej[e.to] <= rej[v]) continue;\n    int f = dfs(e.to, min(flow, e.cap));\n    if (f > 0) {\n      e.cap -= f;\n      adj[e.to][e.rev].cap += f;\n      return f;\n    }\n  }\n  return 0;\n}\n \nint mflow() {\n  int total = 0, fsum, f;\n  do {\n    bfs();\n    memset(red, 0, sizeof(red));\n    fsum = 0;\n    while (0 < (f = dfs(S, 1001001001))) fsum += f;\n    total += fsum;\n  } while (fsum > 0);\n  return total;\n}\n\nint p[200100];//\nbool used[200100];//\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tS=2*n-1;T=S+1;V=T+1;\n\t//MF::init(V);\n\trep(i,n-1){\n\t\taedge(S,i,1);\n\t\trep(j,v[i].size()) aedge(i,n-1+v[i][j],1);\n\t\taedge(n-1+i,T,1);\n\t}\n\t//MF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(mflow()<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\t/*rep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}*/\n\trep(i,n-1) rep(j,adj[i].size()){\n\t\tif(adj[i][j].to<S && adj[i][j].to>=n-1 && adj[i][j].cap<1) p[i]=adj[i][j].to-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define M 1000010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[M],got[M],tak[M];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[tot]=x,b[tot]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define debug(x) cerr<<#x<<\" = \"<<x\n#define sp <<\"  \"\n#define el <<endl\n#define fgx cerr<<\" ---------------------------------------------- \"<<endl\n#define uint unsigned int \n#define ULL unsigned long long\n#define DB long double\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define rint register int \ninline int read(){\n\tint nm=0; bool fh=true; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) fh^=(cw=='-');\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn fh?nm:-nm;\n}\n#define pli pair<long long,int>\n#define M 400020\n#define mod 998244353ll\nint fs[M],nt[M<<2],to[M<<2],cur[M],tg[M],tmp,r[M<<2];\nint n,S,T,vis[M],tim,q[M],hd,tl,u[M],v[M],fa[M];\ninline void add(int x,int y){\n\tnt[tmp]=fs[x],fs[x]=tmp,to[tmp]=y,r[tmp++]=1;\n\tnt[tmp]=fs[y],fs[y]=tmp,to[tmp]=x,r[tmp++]=0;\n}\ninline bool bfs(){\n\thd=tl=0,q[tl++]=S,tg[S]=++tim,vis[S]=1,cur[S]=fs[S];\n\tfor(int x=q[hd];hd<tl;x=q[++hd]) for(int y,i=fs[x];i!=-1;i=nt[i]) \n\t\tif(r[i]&&tg[y=to[i]]<tim) vis[q[tl++]=y]=vis[x]+1,tg[y]=tim,cur[y]=fs[y];\n\treturn tg[T]==tim;\n}\ninline int dfs(int x,int mxf=1){\n\tif(x==T||!mxf) return mxf; int temp=0,rc;\n\tfor(int &i=cur[x];i!=-1&&temp<mxf;i=nt[i]) if(r[i]&&vis[to[i]]==vis[x]+1&&tg[to[i]]==tim)\n\t\trc=dfs(to[i]),r[i]-=rc,r[i^1]+=rc,temp+=rc; if(!temp) tg[x]=0; return temp;\n}\ninline void solve(int x,int last){\n\tif(fa[x]>0) return; fa[x]=last;\n\tfor(int i=fs[x];i!=-1;i=nt[i]) if(!r[i]&&to[i]<S) solve(to[i],x);\n}\nint main(){\t\n\tn=read(),memset(fs,-1,sizeof(fs)),S=n+n,T=S+1; for(int i=1;i<=n;i++) add(i,T);\n\tfor(int i=1;i<n;add(S,i+n),i++) for(int ct=read();ct;--ct) add(i+n,read()); int now=0,x;\n\twhile(bfs()) now+=dfs(S,n-1); if(now<n-1){puts(\"-1\");return 0;}\n\tfor(int i=fs[T];i!=-1;i=nt[i]) if(!r[i]) x=to[i]; solve(x,0);\n\tfor(int i=1;i<=n;i++) if(i!=x) u[fa[i]-n]=i;\n\tfor(int i=1;i<n;i++) v[i]=fa[i+n];\n\tfor(int i=1;i<n;i++) if(!u[i]||!v[i]){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e6+5;\nconst int INF = 1e9;\n\nint n;\nint fa[N];\nvector<int>pt[N],g[N];\nbool used[N];\nint he,ta;\nint que[N];\nstruct edge{\n\tint x,f,nxt;\n}e[N*10];\nint h[N],tot;\nint vis[N],tim;\nint st,ed,k;\nint id[N][2];\nint key[N],m;\nint vt[N];\nint d[N][2];\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N];\nint deq[N];\nint pu[N],t;\n\nbool bfs(){\n\tfo(i,1,t)dis[pu[i]]=-1;\n\tint he=0,ta=1;\n\tdis[deq[1]=st]=0;\n\tfor(;he<ta;){\n\t\tint x=deq[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt)\n\t\tif (e[p].f&&dis[e[p].x]==-1){\n\t\t\tdis[e[p].x]=dis[x]+1;\n\t\t\tdeq[++ta]=e[p].x;\n\t\t}\n\t}\n\treturn dis[ed]!=-1;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tn=get();\n\tk=n;\n\tfo(i,1,n-1){\n\t\tint c=get();\n\t\tfo(j,1,c){\n\t\t\tint x=get();\n\t\t\tpt[i].push_back(x);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tid[i][0]=++k;id[i][1]=++k;\n\t}\n\the=0,ta=1;\n\tque[1]=1;\n\tst=++k;ed=++k;\n\tfor(;he<ta;){\n\t\ttim++;\n\t\ttot=1;\n\t\tm=0;\n\t\tint pre_ta=ta;\n\t\th[st]=h[ed]=0;\n\t\tt=2;\n\t\tpu[1]=st,pu[2]=ed;\n\t\tm=0;\n\t\tfo(i,he+1,pre_ta){\n\t\t\tint x=que[i];\n\t\t\th[x]=0;\n\t\t\tpu[++t]=x;\n\t\t\tinse(st,x,INF);\n\t\t\tfor(auto u:g[x])\n\t\t\tif (!used[u]){\n\t\t\t\tif (vis[u]<tim){\n\t\t\t\t\tpu[++t]=id[u][0],pu[++t]=id[u][1];\n\t\t\t\t\tvis[key[++m]=u]=tim;\n\t\t\t\t\tinse(id[u][0],id[u][1],1);\n\t\t\t\t\tfor(auto y:pt[u])\n\t\t\t\t\tif (y!=1&&!fa[y]){\n\t\t\t\t\t\tif (vt[y]<tim){\n\t\t\t\t\t\t\tpu[++t]=y;\n\t\t\t\t\t\t\th[y]=0;\n\t\t\t\t\t\t\tvt[y]=tim;\n\t\t\t\t\t\t\tinse(y,ed,1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinse(id[u][1],y,1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tinse(x,id[u][0],1);\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\twhile(bfs())cnt+=aug(st,INF);\n\t\tif (cnt<m)return printf(\"-1\\n\"),0;\n\t\tfo(i,1,m){\n\t\t\tint u=key[i];\n\t\t\tused[u]=1;\n\t\t\tint x=0,y=0;\n\t\t\tfor(int p=h[id[u][0]];p;p=e[p].nxt)\n\t\t\tif (e[p].f&&e[p].x>=1&&e[p].x<=n){x=e[p].x;break;}\n\t\t\tfor(int p=h[id[u][1]];p;p=e[p].nxt)\n\t\t\tif (!e[p].f&&e[p].x!=id[u][0]){y=e[p].x;break;}\n\t\t\tfa[y]=x;\n\t\t\tque[++ta]=y;\n\t\t\td[u][0]=x,d[u][1]=y;\n\t\t}\n\t\the=pre_ta;\n\t}\n\tif (ta<n)return printf(\"-1\\n\"),0;\n\tfo(i,1,n-1)printf(\"%d %d\\n\",d[i][0],d[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=2*::Maxn,Maxm=4*::Maxn;\n\tint S,T,cnt,h[Maxn],cur[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int&p=cur[x];p;p=e[p].next){\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs()){\n\t\t\tmemcpy(cur,h,sizeof(h));\n\t\t\tans+=dfs(S,INT_MAX);\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 200005\n#define M 800005\n#define inf 0x3f3f3f3f\nint tar[M], nex[M], cap[M], fir[N], cnt = 1;\nint n, m, dis[N], now[N], use[N][2];\nvector<int>A[N];\nset<int>S[N];\nqueue<int>Q;\nvoid add(int a, int b, int c)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tcap[cnt] = c;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nvoid Add(int a, int b)\n{\n\tadd(a, b, 1);\n\tadd(b, a, 0);\n}\nint aug(int s, int b, int e, int g, int augco)\n{\n\tif (s == e)\n\t\treturn augco;\n\tint augc = augco;\n\tfor (int &i = now[s]; i; i = nex[i])\n\t{\n\t\tint v = tar[i];\n\t\tif (cap[i])\n\t\t{\n\t\t\tif (dis[v] == dis[s] + 1)\n\t\t\t{\n\t\t\t\tint delta = aug(v, b, e, g, min(augc, cap[i]));\n\t\t\t\tcap[i] -= delta;\n\t\t\t\tcap[i ^ 1] += delta;\n\t\t\t\taugc -= delta;\n\t\t\t\tif (!augc)\n\t\t\t\t\treturn augco;\n\t\t\t}\n\t\t}\n\t}\n\treturn augco - augc;\n}\nbool Bfs(int s, int t)\n{\n\tmemset(dis, 0x3f, sizeof(dis));\n\tdis[s] = 0;\n\tqueue<int>que;\n\tque.push(s);\n\twhile (!que.empty())\n\t{\n\t\tint x = que.front();\n\t\tnow[x] = fir[x];\n\t\tque.pop();\n\t\tfor (int i = fir[x]; i; i = nex[i])\n\t\t{\n\t\t\tint v = tar[i];\n\t\t\tif (!cap[i])\n\t\t\t\tcontinue;\n\t\t\tif (dis[x] + 1 < dis[v])\n\t\t\t{\n\t\t\t\tdis[v] = dis[x] + 1;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t] != inf;\n}\nint sap(int b, int e, int g)\n{\n\tint flow = 0;\n\twhile (Bfs(b, e))\n\t\tflow += aug(b, b, e, g, inf);\n\treturn flow;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int j = 1; j <= t; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tS[x].insert(i);\n\t\t\tA[i].push_back(x);\n\t\t\tif (x != 1)\n\t\t\t\tAdd(i, n + x);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tAdd(2 * n + 1, i);\n\t\tAdd(n + i, 2 * n + 2);\n\t}\n\tint ans = sap(2 * n + 1, 2 * n + 2, 2 * n + 2);\n\tif (ans < n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = fir[i]; j; j = nex[j])\n\t\t{\n\t\t\tint v = tar[j];\n\t\t\tif (v > n && !cap[j])\n\t\t\t\tuse[i][0] = v - n;\n\t\t}\n\t}\n\tQ.push(1);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front();\n\t\tm++;\n\t\tQ.pop();\n\t\tset<int>::iterator it = S[x].begin();\n\t\tfor (; it != S[x].end(); it++)\n\t\t{\n\t\t\tif (!use[*it][1])\n\t\t\t{\n\t\t\t\tuse[*it][1] = x;\n\t\t\t\tQ.push(use[*it][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (m < n)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", use[i][0], use[i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\n#define pb push_back\nusing namespace std;\nconst int N=2e5+10,inf=1e9;\nint n,c,p[N],q[N],id[N],x;vector<int> a[N];\nstruct edge{int u,v,c,f;};\nstruct Dinic{\n    vector<edge> e;\n    vector<int> G[N];queue<int> q;\n    int cur[N],d[N],n,m,s,t,ma[N],cnt,p[N],_n;bool vis[N];\n    inline void add(int u,int v,int c){\n        //printf(\"%d %d %d\\n\",u,v,c);\n        e.pb((edge){u,v,c,0});e.pb((edge){v,u,0,0});\n        m=e.size();G[u].pb(m-2);G[v].pb(m-1);\n    }\n    bool bfs(){\n        memset(d,0,sizeof(d));memset(vis,0,sizeof(vis));vis[s]=1;q.push(s);\n        while(!q.empty()){\n            int u=q.front();q.pop();\n            for(int &x:G[u]){\n                edge &E=e[x];\n                if(E.c>E.f&&!vis[E.v]) d[E.v]=d[u]+1,vis[E.v]=1,q.push(E.v);\n            }\n        }\n        return vis[t];\n    }\n    int dfs(int u,int a){\n        if(u==t||!a) return a;\n        int flow=0,f;\n        for(int &i=cur[u];i<(int)G[u].size();++i){\n            edge &E=e[G[u][i]];\n            if(d[E.v]==d[u]+1&&(f=dfs(E.v,min(a,E.c-E.f)))){\n                E.f+=f;e[G[u][i]^1].f-=f;\n                flow+=f;a-=f;if(!a) break;\n            }\n        }\n        return flow;\n    }\n    int max_flow(int s,int t){\n        this->s=s;this->t=t;\n        int flow=0;\n        while(bfs()){memset(cur,0,sizeof(cur));flow+=dfs(s,inf);}\n        return flow;\n    }\n    void DFS(int u){\n        ++cnt;vis[u]=1;\n        for(int &x:G[u]){\n            edge &E=e[x];\n            if(E.v!=t&&!vis[ma[E.v]]) p[ma[E.v]-_n]=u-_n,DFS(ma[E.v]);\n        }\n    }\n    void solve(int n){\n        memset(vis,0,sizeof(vis));_n=n;\n        rep(i,2,n){\n            for(int &x:G[i]){\n                edge &E=e[x];\n                if(E.v!=s&&E.f) ma[i]=E.v;\n            }\n        }\n        DFS(n+n);\n        if(cnt!=n) puts(\"-1\");\n        else rep(i,2,n) printf(\"%d %d\\n\",ma[i]-n,p[ma[i]-n]);\n    }\n}G;\nint main(){\n    //freopen(\"in\",\"r\",stdin);\n    scanf(\"%d\",&n);int S=1,T=2*n+1;G.n=T;\n    rep(i,1,n-1) G.add(1,i+1,1);\n    rep(i,1,n-1){\n        scanf(\"%d\",&c);\n        rep(j,0,c-1) scanf(\"%d\",&x),G.add(i+1,x+n,1);\n    }\n    rep(i,1,n-1) G.add(i+n,T,1);\n    int t=G.max_flow(S,T);if(t!=n-1) return puts(\"-1\"),0;\n    G.solve(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nint cho1[MAXN+5],cho2[MAXN+5];\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\tint cnt=0;\n\twhile(!Q.empty()){\n\t\tcnt++;\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tcho1[s]=u,cho2[s]=ma[s];\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",cho1[i],cho2[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<int> a(2 * N + 2);\n\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    FOR(i, 1, N + 1) a.add_edge(N + i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    if (mf < N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0)\n            {\n                printf(\"%d %d\\n\", wm[from], ed.to - N);\n            }\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int INF=2147483647;\nstruct Edge\n{\n\tint to;\n\tint next;\n\tint flow;\n}e[1000005];\nint n,m,s,t,edgenum=1,head[1000005],dep[1000005],cur[1000005],match[100005],from[100005],to[100005];\nbool flag[100005];\nvector<int>root[100005];\nqueue<int>q;\nvoid add(int u,int v,int f)\n{\n\te[++edgenum].flow=f;\n\te[edgenum].to=v;\n\te[edgenum].next=head[u];\n\thead[u]=edgenum;\n}\nbool bfs()\n{\n\twhile(!q.empty())q.pop();\n\tmemset(dep,0,sizeof(dep));\n\tdep[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int hd=head[node];hd;hd=e[hd].next)\n\t\t{\n\t\t\tint to=e[hd].to;\n\t\t\tif(e[hd].flow==0)continue;\n\t\t\tif(!dep[to])\n\t\t\t{\n\t\t\t\tdep[to]=dep[node]+1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\tif(dep[t])return 1;\n\t}\n\treturn 0;\n}\nint dfs(int node,int nowf)\n{\n\tif(node==t)return nowf;\n\tif(nowf==0)return 0;\n\tfor(int&hd=cur[node];hd;hd=e[hd].next)\n\t{\n\t\tint to=e[hd].to;\n\t\tif(e[hd].flow==0)continue;\n\t\tif(dep[to]==dep[node]+1)\n\t\t{\n\t\t\tint d=dfs(to,min(nowf,e[hd].flow));\n\t\t\tif(d>0)\n\t\t\t{\n\t\t\t\te[hd].flow-=d;\n\t\t\t\te[hd^1].flow+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic()\n{\n\tint ans=0,d;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=t;i++)\n\t\t  cur[i]=head[i];\n\t\twhile(d=dfs(s,INF))\n\t\t  ans+=d;\n\t}\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=1,t=2*n;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t}\n\tfor(int i=n+1;i<2*n;i++)\n\t{\n\t\tadd(i,t,1);\n\t\tadd(t,i,0);\n\t}\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint size;\n\t\tscanf(\"%d\",&size);\n\t\twhile(size--)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\troot[x].push_back(i);\n\t\t\tx--;\n\t\t\tif(x==0)continue;\n\t\t\tadd(i,x+n,1);\n\t\t\tadd(x+n,i,0);\n\t\t}\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  for(int hd=head[i];hd;hd=e[hd].next)\n\t\tif(e[hd].flow==0)\n\t\t  match[i]=e[hd].to-n+1;\n\twhile(!q.empty())q.pop();\n\tq.push(1);\n\twhile(!q.empty())\n\t{\n\t\tint node=q.front();\n\t\tq.pop();\n\t\tfor(int i=0;i<root[node].size();i++)\n\t\t{\n\t\t\tif(flag[root[node][i]])continue;\n\t\t\tflag[root[node][i]]=1;\n\t\t\tfrom[root[node][i]]=node;\n\t\t\tto[root[node][i]]=match[root[node][i]];\n\t\t\tq.push(match[root[node][i]]);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++)\n\tif(!from[i])\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=2;i<=n;i++)\n\t  printf(\"%d %d\\n\",from[i],to[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],min(flow-used,c[i]));\n\t\tif(v)used+=v,c[i]-=v,c[i^1]+=v,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],gap[N << 1],dis[N << 1],pos[N],vis[N];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline int isap(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = isap(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]];\n\treturn f - res;\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"AGC029F.in\",\"r\",stdin);\n\tfreopen(\"AGC029F.out\",\"w\",stdout);\n#endif\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tfor(gap[0] = T;dis[S] < T;) ans += isap(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[++tot] = mp(x,pos[cur]),Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) {\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n        assert(to[i] < n);\n    }\n    queue < int > q;\n    q.push(n);\n    int cnt = 0;\n    while (!q.empty()) {\n        cnt++;\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    if (cnt != n) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nstruct edge { int to; ll cap; int rev; };\nstruct Dinic {\nprivate:\n\tint n;\n\tvector<vector<edge>> v;\n\tvector<int> dist, iter;\npublic:\n\tDinic(int sz) :n(sz), v(sz), dist(sz), iter(sz) {}\n\n\tvoid addedge(int from, int to, ll cap) {\n\t\tint x = v[to].size(), y = v[from].size();\n\t\tv[from].push_back({ to,cap,x });\n\t\tv[to].push_back({ from,0,y });\n\t}\n\n\tvoid bfs(int s) {\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tdist[s] = 0;\n\t\tq.push(s);\n\t\twhile (q.size()) {\n\t\t\tint x = q.front(); q.pop();\n\t\t\trep(i, v[x].size()) {\n\t\t\t\tedge& e = v[x][i];\n\t\t\t\tif (e.cap > 0 && dist[e.to] < 0) {\n\t\t\t\t\tdist[e.to] = dist[x] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll dfs(int x, int t, ll f) {\n\t\tif (x == t)return f;\n\t\tfor (int& i = iter[x]; i < (int)v[x].size(); ++i) {\n\t\t\tedge& e = v[x][i];\n\t\t\tif (e.cap > 0 && dist[x] < dist[e.to]) {\n\t\t\t\tll d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tv[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll max_flow(int s, int t) {\n\t\tll flow = 0;\n\t\twhile (1) {\n\t\t\tbfs(s);\n\t\t\tif (dist[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tll f;\n\t\t\twhile ((f = dfs(s, t, 1LL << 62)) > 0)flow += f;\n\t\t}\n\t}\n\tvector<int> query(int sup) {\n\t\tvector<int> res(sup - 1);\n\t\trep1(i, sup - 1) {\n\t\t\tfor (edge e : v[i]) {\n\t\t\t\tif (e.cap == 0 && e.to < 2 * sup - 1) {\n\t\t\t\t\tres[e.to - sup] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\nvoid solve() {\n\tint n; cin >> n;\n\tvector<vector<int>> v(n-1);\n\trep(i, n - 1) {\n\t\tint sz; cin >> sz;\n\t\tv[i].resize(sz);\n\t\trep(j, sz) {\n\t\t\tcin >> v[i][j]; v[i][j]--;\n\t\t}\n\t}\n\tDinic dc(2*n+1);\n\tint s = 2 * n - 1; int t = s + 1;\n\trep1(i, n-1) {\n\t\tdc.addedge(s, i, 1);\n\t}\n\trep(i, n - 1) {\n\t\tdc.addedge(i + n, t, 1);\n\t}\n\t\n\trep(i, n - 1)rep(j, v[i].size()) {\n\t\tif(v[i][j]>0)dc.addedge(v[i][j],i + n, 1);\n\t}\n\tint f = dc.max_flow(s, t);\n\tif (f != n - 1) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\tvector<vector<int>> loc(n);\n\trep(i, n - 1)rep(j, v[i].size()) {\n\t\tloc[v[i][j]].push_back(i);\n\t}\n\tvector<int> c = dc.query(n);\n\tvector<bool> used(n - 1, false);\n\tqueue<int> q; q.push(0);\n\tvector<P> ans(n - 1, { -1,-1 });\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\tfor (int t : loc[id]) {\n\t\t\tif (used[t])continue;\n\t\t\tans[t] = { id,c[t] };\n\t\t\tused[t] = true;\n\t\t\tq.push(c[t]);\n\t\t}\n\t}\n\trep(i, n - 1)if (ans[i].first < 0) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\t\trep(i, n - 1) {\n\t\t\tcout << ans[i].first + 1 << \" \" << ans[i].second + 1 << \"\\n\";\n\t\t}\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//cout << grandy(2, 3, false, false) << \"\\n\";\n\t//int t; cin >> t; rep(i, t)\n\t\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0)\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> chosen(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0 && eref[i][j].get())\n        chosen[i] = e[i][j];\n  }\n  vector<bool> vis(n);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = true;\n    for (int id : fnd[u])\n      if (chosen[id] != -1) {\n        int v = chosen[id];\n        chosen[id] = -1;\n        cout << (u + 1) << ' ' << (v + 1) << '\\n';\n        dfs(v);\n      }\n  };\n  dfs(0);\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=(0);i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=1000005,M=2000005,inf=1e9;\nnamespace G{\n\tstruct edge{int v,f,c,p;};\n\tvector<edge> e[N];\n\tint d[N],r[N],in[N],n,m,s,t;\n\tvoid init(int _n,int _s,int _t){\n\t\tn=_n,s=_s,t=_t,m=0;\n\t}\n\tvoid add(int a,int b,int c){\n\t\te[a].pb((edge){b,0,c,(int)e[b].size()});\n\t\te[b].pb((edge){a,0,0,(int)e[a].size()-1});\n\t}\n\tint bfs(){\n\t\tstatic int q[N]; int l=0,r=0;\n\t\tfill(d+1,d+n+1,0),d[s]=1;\n\t\tfor(l=r=0,q[r++]=s;l<r;){\n\t\t\tint u=q[l++];\n\t\t\tREP(i,e[u].size()){\n\t\t\t\tedge &v=e[u][i];\n\t\t\t\tif(!d[v.v]&&v.f<v.c){\n\t\t\t\t\td[q[r++]=v.v]=d[u]+1;\n\t\t\t\t\tif(v.v==t)return 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int u,int a){\n\t\tif(u==t)return a;\n\t\tint res=0; in[u]=1;\n\t\tfor(int &k=r[u];k<e[u].size();k++){\n\t\t\tedge &v=e[u][k];\n\t\t\tif(v.f<v.c&&d[v.v]==d[u]+1&&!in[v.v]){\n\t\t\t\tint now=dfs(v.v,min(a,v.c-v.f));\n\t\t\t\tv.f+=now,e[v.v][v.p].f-=now,res+=now;\n\t\t\t\tif(!(a-=now))break;\n\t\t\t}\n\t\t}\n\t\treturn in[u]=0,res;\n\t}\n\tint flow(){\n\t\tint res=0;\n\t\twhile(bfs()){\n\t\t\tfill(r+1,r+n+1,0);\n\t\t\tres+=dfs(s,inf);\n\t\t}\n\t\treturn res;\n\t}\n}\nint cur[N],q[N],an[N],l,r,n,a,b,S,T;\nvi e[N];\n\nint main(){\n\tread(n);\n\tS=2*n-1,T=S+1;\n\tG::init(T,S,T);\n\trep(i,1,n-1){\n\t\tG::add(S,i,1);\n\t\tG::add(i+n-1,T,1);\n\t}\n\trep(i,1,n-1){\n\t\tread(a);\n\t\trep(j,1,a){\n\t\t\tread(b);\n\t\t\te[b].pb(i);\n\t\t\tif(b<n)G::add(i,n-1+b,1);\n\t\t}\n\t}\n\tif(G::flow()!=n-1)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tfor(auto t:G::e[i])\n\t\t\tif(n<=t.v&&t.v<S&&t.f)\n\t\t\t\tcur[i]=t.v-(n-1);\n\tq[r++]=n;\n\twhile(l<r){\n\t\tint u=q[l++];\n\t\tfor(auto v:e[u]){\n\t\t\tif(an[v])continue;\n\t\t\tan[v]=u,q[r++]=cur[v];\n\t\t}\n\t}\n\tif(r<n)return puts(\"-1\"),0;\n\trep(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",cur[i],an[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define llint long long\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cap, rev;\n\tedge(llint a, llint b, llint c){\n\t\tto = a, cap = b, rev = c;\n\t}\n};\n\nllint n;\nvector<edge> G[200005];\nint S, T;\nllint level[200005], iter[200005];\n\nvector<llint> revG[200005];\nllint pred[200005], succ[200005];\nbool used[200005];\nvector<P> avec;\n\nvoid bfs(llint s)\n{\n\tfor(int i = 1; i <= T; i++) level[i] = inf;\n\tlevel[s] = 0;\n\t\n\tqueue<int> Q;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i].to;\n\t\t\tif(G[v][i].cap <= 0 || level[u] < inf) continue;\n\t\t\tlevel[u] = level[v] + 1;\n\t\t\tQ.push(u);\n\t\t}\n\t}\n}\n\nllint dfs(int v, llint f)\n{\n\tif(v == T) return f;\n\t\n\tllint ret;\n\tfor(llint &i = iter[v]; i < G[v].size(); i++){\n\t\tif(level[v] >= level[G[v][i].to] || G[v][i].cap <= 0) continue;\n\t\tret = dfs(G[v][i].to, min(f, G[v][i].cap));\n\t\tif(ret > 0){\n\t\t\tG[v][i].cap -= ret;\n\t\t\tG[G[v][i].to][G[v][i].rev].cap += ret;\n\t\t\treturn ret;\n\t\t}\n\t}\n\treturn 0;\n}\n\nvoid add_edge(int s, int t, llint cap)\n{\n\tG[s].push_back(edge(t, cap, G[t].size()));\n\tG[t].push_back(edge(s, 0, G[s].size()-1));\n}\n\nvoid dfs2(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < revG[v].size(); i++){\n\t\tif(used[revG[v][i]]) continue;\n\t\tpred[revG[v][i]] = v;\n\t\tdfs2(succ[revG[v][i]]);\n\t}\n}\n\nint main(void)\n{\n\tcin >> n;\n\tllint c, w;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> c;\n\t\tfor(int j = 0; j < c; j++){\n\t\t\tcin >> w;\n\t\t\tadd_edge(i, n+w, 1);\n\t\t\trevG[w].push_back(i);\n\t\t}\n\t}\n\tS = 2*n+1, T = 2*n+2;\n\t\n\tfor(int i = 1; i <= n-1; i++) add_edge(S, i, 1);\n\tfor(int i = 1; i <= n; i++) add_edge(n+i, T, 1);\n\t\n\tllint ans = 0, flow;\n\twhile(1){\n\t\tbfs(S);\n\t\tif(level[T] >= inf) break;\n\t\tfor(int i = 1; i <= T; i++) iter[i] = 0;\n\t\twhile(1){\n\t\t\tflow = dfs(S, inf);\n\t\t\tif(flow <= 0) break;\n\t\t\tans += flow;\n\t\t}\n\t}\n\tif(ans < n-1){\n\t\tcout << -1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tif(G[i][j].to == S) continue;\n\t\t\tif(G[i][j].cap == 0) succ[i] = G[i][j].to-n;\n\t\t}\n\t}\n\tint r;\n\tfor(int i = 0; i < G[T].size(); i++){\n\t\tif(G[T][i].cap == 0){\n\t\t\tr = G[T][i].to-n;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tdfs2(r);\n\t\n\tfor(int i = 1; i <= n-1; i++){\n\t\tif(pred[i] == 0 || succ[i] == 0){\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcout << pred[i] << \" \" << succ[i] << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+99,M=61e4;\ninline int min(const int&a,const int&b){return a<b?a:b;}\nstruct graph{\n\tstruct edge{int to,next,f;}e[M<<1];\n\tint h[N],cur[N],xb;\n\tinline void addedge(int x,int y,int z){\n\t\te[++xb]=(edge){y,h[x],z};h[x]=xb;\n\t\te[++xb]=(edge){x,h[y],0};h[y]=xb;\n\t}\n\tint S,T,d[N],n;\n\tinline bool bfs(){\n\t\tstatic int q[N];int t=0,w=1;q[1]=S;\n\t\tmemset(d+1,0,n<<2);d[S]=1;\n\t\tfor(;t<w;){\n\t\t\tint u=q[++t];\n\t\t\tfor(int i=h[u];i;i=e[i].next)if(e[i].f && !d[e[i].to])\n\t\t\t\td[e[i].to]=d[u]+1,q[++w]=e[i].to;\n\t\t}\n\t\treturn d[T];\n\t}\n\tint dfs(int x,int f){\n\t\tif(x==T)return f;\n\t\tint ans=0,&i=cur[x],t;\n\t\tfor(;i;i=e[i].next)if(e[i].f && d[e[i].to]==d[x]+1){\n\t\t\tif(t=dfs(e[i].to,min(f,e[i].f))){\n\t\t\t\tans+=t,e[i].f-=t;e[i^1].f+=t;f-=t;\n\t\t\t\tif(!f)break;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tinline int dinic(int s,int t){\n\t\tint ans=0;S=s;T=t;\n\t\tfor(;bfs();ans+=dfs(s,1<<30))memcpy(cur+1,h+1,n<<2);\n\t\treturn ans;\n\t}\n}g;\nint n,i,j,fa[N];\nvector<int>v[N],vv[N];\nvoid dfs(int x){\n\tauto t=v[x];v[x].clear();\n\tfor(int y:t)if(!fa[y])fa[y]=x,dfs(y);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tg.n=n*2;g.xb=1;\n\tfor(i=2;i<=n;++i)g.addedge(n-2+i,g.n,1);\n\tfor(i=1;i<n;++i){\n\t\tscanf(\"%d\",&j);vv[i].resize(j);\n\t\tfor(int&x:vv[i]){scanf(\"%d\",&x);if(x>1)g.addedge(i,n-2+x,1);}\n\t\tg.addedge(g.n-1,i,1);\n\t}\n\tif(g.dinic(g.n-1,g.n)<n-1){puts(\"-1\");return 0;}\n\tfor(i=1;i<n;++i){\n\t\tfor(j=g.h[i];g.e[j].f;j=g.e[j].next);\n\t\tint x=g.e[j].to-(n-2);\n\t\tfor(int y:vv[i])if(y!=x)v[y].push_back(x);\n\t}\n\tdfs(1);\n\tfor(i=1,j=0;i<=n;++i)j+=!fa[i];\n\tif(j>1){puts(\"-1\");return 0;}\n\tfor(i=1;i<=n;++i)if(fa[i])printf(\"%d %d\\n\",i,fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define il inline\nusing namespace std;\nconst int N=1e5+5,M=2e6;\n\nint n,m,e,S,T,h,t,q[N],lev[N],ax[N],ay[N],o[N];\nint to[M],nx[M],cap[M],hd[N],it[N],sze=1;\nstd::vector<int> g[N];\n\nil void add(int u,int v,int c){to[++sze]=v,nx[sze]=hd[u],cap[sze]=c,hd[u]=sze;}\n\nil void ins(int u,int v,int c){add(u,v,c),add(v,u,0);}\n\nil int bfs()\n{\n\tmemset(lev,0,4*T+4); int i,u,v; q[h=t=lev[S]=1]=S;\n\twhile (h<=t) for (i=hd[u=q[h++]]; i; i=nx[i])\n        if (cap[i]&&!lev[v=to[i]]) lev[v]=lev[u]+1,q[++t]=v;\n\treturn lev[T];\n}\n\nil int dfs(int u,int f)\n{\n\tif (u==T) return f; int z,v,res=0;\n\tfor (int &i=it[u]; i; i=nx[i])\n\t\tif (lev[v=to[i]]==lev[u]+1&&cap[i]&&(z=dfs(v,min(f-res,cap[i]))))\n\t\t{\n\t\t\tcap[i]-=z,cap[i^1]+=z,res+=z;\n\t\t\tif (res==f) break;\n\t\t}\n\treturn res;\n}\n\nil int dinic()\n{\n\tint i,f,res=0;\n\twhile (bfs())\n    {\n        for (i=1; i<=T; i++) it[i]=hd[i];\n        while (f=dfs(S,1e9)) res+=f;\n    }\n\treturn res;\n}\n\nil int work()\n{\n    int i,u,v,s=0;\n    for (u=1; u<n; u++) for (i=hd[u]; i; i=nx[i])\n        if ((v=to[i])!=S&&!cap[i]) o[u]=v-n+1;\n    for (q[++t]=n; h<=t; )\n    {\n        u=q[h++],s++;\n        for (int v:g[u]) if (o[v])\n            ax[v]=u,ay[v]=o[v],q[++t]=o[v],o[v]=0; \n    }\n    return s==n;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),S=n+n-1,T=n+n; int i,c,x;\n    for (i=1; i<n; i++) ins(i+n-1,T,1);\n    for (i=1; i<n; i++)\n    {\n        scanf(\"%d\",&c),ins(S,i,1);\n        while (c--)\n        {\n            scanf(\"%d\",&x);\n            if (x!=n) ins(i,x+n-1,1);\n            g[x].push_back(i);\n        }\n    }\n\n    if (dinic()<n-1) return puts(\"-1\"),0;\n    if (!work()) return puts(\"-1\"),0;\n\tfor (i=1; i<n; i++) printf(\"%d %d\\n\",ax[i],ay[i]);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=4e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*2];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i&&flow;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=800005;\nvector<int> bel[N];\nint cur[N],from[N],S,T,ne[N],a[N],b[N],dis[N],flag[N],x,y,n,m,fi[N],tot,zz[N],sl[N];\nqueue<int>Q;\nvoid jb(int x,int y,int z){\n\tne[++tot]=fi[x];\n\tfi[x]=tot;\n\tzz[tot]=y;\n\tsl[tot]=z;\n\tne[++tot]=fi[y];\n\tfi[y]=tot;\n\tzz[tot]=x;\n\tsl[tot]=0;\n}\nint bfs(){\n\tQ.push(S);\n\tmemset(dis,-1,sizeof dis);\n\tdis[S]=0;\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tfor (int i=fi[now];i;i=ne[i])\n\t\t\tif (sl[i]&&dis[zz[i]]==-1){\n\t\t\t\tdis[zz[i]]=dis[now]+1;\n\t\t\t\tQ.push(zz[i]);\n\t\t\t}\n\t}\n\treturn dis[T]!=-1;\n}\nint dfs(int x,int y){\n\tif (x==T)return y;\n\tint s=0,b;\n\tfor (int &i=cur[x];i;i=ne[i])\n\t\tif (sl[i]&&dis[zz[i]]==dis[x]+1&&(b=min(sl[i],dfs(zz[i],min(sl[i],y))))){\n\t\t\tsl[i]-=b;\n\t\t\tsl[i^1]+=b;\n\t\t\ty-=b;\n\t\t\ts+=b;\n\t\t\tif (!y)return s;\n\t\t}\n\treturn s;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tS=0;T=2*n;\n\ttot=1;\n\tfor (int i=1;i<n;i++){\n\t\tscanf(\"%d\",&x);\n\t\tjb(S,i+n,1);\n\t\twhile (x--){\n\t\t\tscanf(\"%d\",&y);\n\t\t\tjb(i+n,y,1);\n\t\t\tbel[y].push_back(i);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++)jb(i,T,1);\n\tint ans=0;\n\twhile (bfs()){\n\t\tfor (int i=S;i<=T;i++)cur[i]=fi[i];\n\t\tans+=dfs(S,1e9);\n\t}\n\tif (ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)\n\t\tfor (int j=fi[i+n];j;j=ne[j])\n\t\t\tif (zz[j]&&!sl[j]){\n\t\t\t\tflag[zz[j]]=1;\n\t\t\t\tb[i]=zz[j];\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])Q.push(i);\n\tans=0;\n\tmemset(flag,0,sizeof flag);\n\twhile (!Q.empty()){\n\t\tint now=Q.front();Q.pop();\n\t\tans++;\n\t\tfor (int i=0;i<bel[now].size();i++)\n\t\t\tif (!flag[bel[now][i]]){\n\t\t\t\tflag[bel[now][i]]=1;\n\t\t\t\ta[bel[now][i]]=now;\n\t\t\t\tQ.push(b[bel[now][i]]);\n\t\t\t}\n\t}\n\tif (ans!=n){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i=1;i<n;i++)printf(\"%d %d\\n\",a[i],b[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nvoid cl(int i) {\n    set<int> o;\n    swap(o, q[i]);\n}\n\nvoid cel() {\n    set<pair<int, int> > o;\n    swap(g, o);\n}\n\nvoid solve() {\n    for (int i = 0; i < n; i++)\n        p[i] = i, r[i] = 0, cl(i);\n    cel();\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < a[i].size(); j++)\n            q[a[i][j]].insert(i);\n        d[i] = a[i].size();\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (y == -1 && w != tos)\n                y = i;\n            q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            return;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n    exit(0);\n}\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    double ts = clock();\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--;\n    }\n    while ((clock() - ts) / CLOCKS_PER_SEC < 3.7) {\n        solve();\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < a[i].size(); j++)\n                swap(a[i][j], a[i][rnd() % (j + 1)]);\n    }\n    cout << -1;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\nconst int inf = 1e9;\n\nstruct edge_t {\n\tint to, cap, flow;\n\tedge_t(int to = 0,int cap = 0) : to(to), cap(cap), flow(0) {}\n};\n\nint n;\nvector<edge_t> ed;\nvector<int> g[N];\nint src, snk;\nint d[N];\nint now[N];\nint par[N], match[N];\nbool visit[N];\nvector<int> has[N];\n\nvoid add(int u,int v,int cap) {\n\tg[u].push_back(ed.size()); ed.push_back(edge_t(v, cap));\n\tg[v].push_back(ed.size()); ed.push_back(edge_t(u, 0));\n}\n\nbool bfs() {\n\tfill(d, d + 2 * n + 5, -1);\n\tfill(now, now + 2 * n + 5, 0);\n\tqueue<int> q;\t \n\td[src] = 0; q.push(src);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop();\n\t\tfor (int id : g[u]) {\n\t\t\tint v = ed[id].to;\n\t\t\tif (d[v] == -1 && ed[id].cap > ed[id].flow) {\n\t\t\t\td[v] = d[u] + 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn d[snk] != -1;\n}\n\nint dfs(int u,int flow) {\n\tif (u == snk) return flow;\n\tfor (int& i = now[u]; i < int(g[u].size()); ++i) {\n\t\tint id = g[u][i];\n\t\tint v = ed[id].to;\n\t\tif (d[v] != d[u] + 1 || ed[id].cap <= ed[id].flow) continue;\n\t\tint nxt = dfs(v, min(ed[id].cap - ed[id].flow, flow));\n\t\tif (nxt) {\n\t\t\ted[id].flow += nxt;\n\t\t\ted[id ^ 1].flow -= nxt;\n\t\t\treturn nxt;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow() {\n\tint ans = 0;\n\twhile (bfs()) {\n\t\twhile (true) {\n\t\t\tint now = dfs(src, inf);\n\t\t\tif (now) {\n\t\t\t\tans += now;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(int u) {\n\tvisit[u] = true;\n\tfor (int v : has[u]) if (visit[match[v]] == false) {\n\t\tpar[v] = u;\n\t\tsolve(match[v]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tsrc = 0, snk = n + n + 1;\n\tfor (int i = 2; i <= n; ++i) {\n\t\tint u; scanf(\"%d\", &u);\n\t\twhile (u--) {\n\t\t\tint v; scanf(\"%d\", &v);\n\t\t\thas[v].push_back(i);\n\t\t\tif (v > 1) {\n\t\t\t\tadd(v, i + n, 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tadd(src, i, 1);\n\t\tadd(i + n, snk, 1);\n\t}\n\tif (max_flow() != n - 1) {\n\t\tputs(\"-1\"); return 0;\n\t}\n\tfor (int u = 2; u <= n; ++u) {\n\t\tfor (int id : g[u]) {\n\t\t\tint v = ed[id].to;\n\t\t\tif (v && ed[id].cap == ed[id].flow) {\n\t\t\t\tmatch[v - n] = u; \n\t\t\t}\n\t\t}\n\t}\n\tsolve(1);\n\tif (accumulate(visit + 1, visit + n + 1, 0) < n) {\n\t\tputs(\"-1\"); return 0;\n\t}\n\tfor (int i = 2; i <= n; ++i) {\n\t\tprintf(\"%d %d\\n\", par[i], match[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define cs const\n#define pb push_back\nusing namespace std;\ncs int N = 3e5 + 50, M = 2e6 + 50;\ncs int INF = 1e9 + 7;\nint n, S, T, fi[N], nxt[M], to[M], w[M], ec=1;\nvoid adde(int x, int y, int z){\n\tnxt[++ec]=fi[x], fi[x]=ec, to[ec]=y, w[ec]=z;\n\tnxt[++ec]=fi[y], fi[y]=ec, to[ec]=x, w[ec]=0;\n} int eu[N], ev[N], ct, d[N];\nbool bfs(){\n\tqueue<int> q; q.push(S); \n\tmemset(d,-1,sizeof(d)); d[S]=0;\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x],v;e;e=nxt[e]) if(w[e]){\n\t\t\tv=to[e]; if(d[v]==-1){\n\t\t\t\td[v]=d[x]+1; q.push(v);\n\t\t\t\tif(v==T) return true;\n\t\t\t}\n\t\t}\n\t} return false;\n}\nint dfs(int u, int flw){\n\tif(u==T) return flw; int ans = 0;\n\tfor(int e=fi[u],v;e;e=nxt[e])\n\tif(d[v=to[e]]==d[u]+1){\n\t\tint dt=dfs(v,min(w[e],flw));\n\t\tans+=dt; flw-=dt;\n\t\tw[e]-=dt; w[e^1]+=dt; if(!flw) break;\n\t} if(flw) d[u]=-1; return ans;\n}\nint dinic(){ int flw = 0; while(bfs()) flw += dfs(S,INF); return flw; }\nint main(){\n\tfreopen(\"1.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1,k,x; i<n; i++){\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=1; j<=k; j++) \n\t\tscanf(\"%d\",&x), adde(x,i+n,1);\n\t} S=0, T=n+n;\n\tfor(int i=1; i<=n; i++) adde(S,i,1);\n\tfor(int i=1; i<n; i++) adde(i+n,T,1);\n\tint flw = dinic();\n\tif(flw < n-1) return puts(\"-1\"),0;\n\t\n\tstatic int tr[N];\n\tfor(int i=n+1; i<n+n; i++)\n\tfor(int e=fi[i];e;e=nxt[e]) \n\tif(to[e]!=T&&w[e]) tr[i]=to[e];\n\t\n\tqueue<int> q;\n\tfor(int e=fi[S];e;e=nxt[e])\n\tif(w[e]) q.push(to[e]);\n\t\n\tstatic bool ban[N];\n\twhile(!q.empty()){\n\t\tint x=q.front(); q.pop();\n\t\tfor(int e=fi[x];e;e=nxt[e]) \n\t\tif(to[e]!=S&&!ban[to[e]]){\n\t\t\teu[++ct]=x; ev[ct]=tr[to[e]];\n\t\t\tq.push(tr[to[e]]); ban[to[e]]=true;\n\t\t}\n\t} if(ct<n-1) return puts(\"-1\"),0;\n\tfor(int i=1; i<n; i++) cout<<eu[i]<<\" \"<<ev[i]<<'\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LB long double\n#define ull unsigned long long\n#define x first\n#define y second\n#define pb push_back\n#define pf push_front\n#define mp make_pair\n#define Pair pair<int,int>\n#define pLL pair<LL,LL>\n#define pii pair<double,double>\n#define LOWBIT(x) x & (-x)\n// #define LOCAL true\n\nconst int INF=2e9;\nconst LL LINF=2e16;\nconst int magic=348;\nconst int MOD=1e9+7;\nconst double eps=1e-10;\nconst double pi=acos(-1);\n\nstruct fastio\n{\n    static const int S=1e7;\n    char rbuf[S+48],wbuf[S+48];int rpos,wpos,len;\n    fastio() {rpos=len=wpos=0;}\n    inline char Getchar()\n    {\n        if (rpos==len) rpos=0,len=fread(rbuf,1,S,stdin);\n        if (!len) return EOF;\n        return rbuf[rpos++];\n    }\n    template <class T> inline void Get(T &x)\n    {\n        char ch;bool f;T res;\n        while (!isdigit(ch=Getchar()) && ch!='-') {}\n        if (ch=='-') f=false,res=0; else f=true,res=ch-'0';\n        while (isdigit(ch=Getchar())) res=res*10+ch-'0';\n        x=(f?res:-res);\n    }\n    inline void getstring(char *s)\n    {\n        char ch;\n        while ((ch=Getchar())<=32) {}\n        for (;ch>32;ch=Getchar()) *s++=ch;\n        *s='\\0';\n    }\n    inline void flush() {fwrite(wbuf,1,wpos,stdout);fflush(stdout);wpos=0;}\n    inline void Writechar(char ch)\n    {\n        if (wpos==S) flush();\n        wbuf[wpos++]=ch;\n    }\n    template <class T> inline void Print(T x,char ch)\n    {\n        char s[20];int pt=0;\n        if (x==0) s[++pt]='0';\n        else\n        {\n            if (x<0) Writechar('-'),x=-x;\n            while (x) s[++pt]='0'+x%10,x/=10;\n        }\n        while (pt) Writechar(s[pt--]);\n        Writechar(ch);\n    }\n    inline void printstring(char *s)\n    {\n        int pt=1;\n        while (s[pt]!='\\0') Writechar(s[pt++]);\n    }\n}io;\n\ntemplate<typename T> inline void check_max(T &x,T cmp) {x=max(x,cmp);}\ntemplate<typename T> inline void check_min(T &x,T cmp) {x=min(x,cmp);}\ntemplate<typename T> inline T myabs(T x) {return x>=0?x:-x;}\ntemplate<typename T> inline T gcd(T x,T y) {return y==0?x:gcd(y,x%y);}\ninline int add(int x) {if (x>=MOD) x-=MOD;return x;}\ninline int add(int x,int MO) {if (x>=MO) x-=MO;return x;}\ninline int sub(int x) {if (x<0) x+=MOD;return x;}\ninline int sub(int x,int MO) {if (x<0) x+=MO;return x;}\ninline void Add(int &x,int y) {x=add(x+y);}\ninline void Add(int &x,int y,int MO) {x=add(x+y,MO);}\ninline void Sub(int &x,int y) {x=sub(x-y);}\ninline void Sub(int &x,int y,int MO) {x=sub(x-y,MO);}\ntemplate<typename T> inline int quick_pow(int x,T y) {int res=1;while (y) {if (y&1) res=1ll*res*x%MOD;x=1ll*x*x%MOD;y>>=1;}return res;}\ntemplate<typename T> inline int quick_pow(int x,T y,int MO) {int res=1;while (y) {if (y&1) res=1ll*res*x%MO;x=1ll*x*x%MO;y>>=1;}return res;}\n\nconst int MAXN=2e5;\n\nint n;\nvector<int> a[MAXN+48];\nvector<int> v[MAXN+48];\nint u[MAXN+48];\n\nbool inq[MAXN+48];\nint head,tail,q[MAXN+48];\nint ans[MAXN+48];\n\nnamespace flow\n{\n    int head[800048],cur[800048],to[800048],nxt[800048],f[800048],tot,t;\n    inline void init() {memset(head,0,sizeof(head));tot=1;}\n    inline void addedge(int s,int t,int cap)\n    {\n        to[++tot]=t;nxt[tot]=head[s];head[s]=tot;f[tot]=cap;\n        to[++tot]=s;nxt[tot]=head[t];head[t]=tot;f[tot]=0;\n    }\n    int q[800048],Head,Tail;int depth[800048];\n    inline bool bfs()\n    {\n        for (register int i=0;i<=t;i++) depth[i]=-1;\n        depth[0]=0;q[1]=0;Head=Tail=1;\n        while (Head<=Tail)\n        {\n            int x=q[Head++];\n            for (register int i=head[x];i;i=nxt[i])\n            {\n                int y=to[i];\n                if (depth[y]==-1 && f[i])\n                {\n                    depth[y]=depth[x]+1;\n                    q[++Tail]=y;\n                }\n            }\n        }\n        if (depth[t]==-1) return false; else return true;\n    }\n    inline int dfs(int x,int maxf)\n    {\n        if (x==t || !maxf) return maxf;\n        int y,minf,now,ans=0;\n        for (register int &i=cur[x];i;i=nxt[i])\n        {\n            y=to[i];\n            if (depth[y]==depth[x]+1 && f[i])\n            {\n                minf=min(maxf-ans,f[i]);\n                now=dfs(y,minf);\n                f[i]-=now;f[i^1]+=now;ans+=now;\n            }\n            if (ans>=maxf) return ans;\n        }\n        if (!ans) depth[x]=0;\n        return ans;\n    }\n    inline int dinic()\n    {\n        int ans=0;\n        while (bfs())\n        {\n            for (register int i=0;i<=t;i++) cur[i]=head[i];\n            ans+=dfs(0,INF);\n        }\n        return ans;\n    }\n}\n\nint main ()\n{\n#ifdef LOCAL\n    double TIME=clock();\n    freopen (\"a.in\",\"r\",stdin);\n    freopen (\"a.out\",\"w\",stdout);\n    cerr<<\"Running...\"<<endl;\n#endif\n    scanf(\"%d\",&n);int num,x;\n    for (register int i=1;i<=n-1;i++)\n    {\n        scanf(\"%d\",&num);\n        while (num--)\n        {\n            scanf(\"%d\",&x);\n            a[i].pb(x);v[x].pb(i);\n        }\n    }\n    flow::init();flow::t=n+n+1;\n    for (register int i=1;i<=n-1;i++) flow::addedge(0,i,1);\n    for (register int i=2;i<=n;i++) flow::addedge(n+i,flow::t,1);\n    for (register int i=1;i<=n-1;i++)\n        for (auto to : a[i]) if (to!=1) flow::addedge(i,n+to,1);\n    int res=flow::dinic();\n    if (res!=n-1) {puts(\"-1\");return 0;}\n    for (register int i=1;i<=n-1;i++)\n        for (register int j=flow::head[i];j;j=flow::nxt[j])\n        {\n            int y=flow::to[j];\n            if (n+2<=y && y<=n+n && flow::f[j]==0) {u[i]=y-n;break;}\n        }\n    memset(inq,false,sizeof(inq));head=1;tail=0;\n    for (auto item : v[1]) q[++tail]=item,q[++tail]=1,inq[item]=true;\n    while (head<=tail)\n    {\n        int cur=q[head++],father=q[head++];\n        ans[cur]=father;\n        for (auto item : v[u[cur]]) if (!inq[item]) inq[item]=true,q[++tail]=item,q[++tail]=u[cur];\n    }\n    for (register int i=1;i<=n-1;i++) if (!ans[i]) {puts(\"-1\");return 0;}\n    for (register int i=1;i<=n-1;i++) printf(\"%d %d\\n\",u[i],ans[i]);\n    io.flush();\n#ifdef LOCAL\n    cerr<<\"Exec Time: \"<<(clock()-TIME)/CLOCKS_PER_SEC<<endl;\n#endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 210000\n#define MAXM 410000\n#define INF 2147483647\nusing namespace std;\ntemplate <typename T> inline void read(T &s)\n{\n\ts = 0;char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) s = ((s+(s<<2))<<1)+ch-'0',ch = getchar();\n}\nint hed[MAXN],ed[MAXM<<1],nxt[MAXM<<1],flow[MAXM<<1],tl=1,s,t,dep[MAXN],cur[MAXN],S,T,n,to[MAXN];\ninline void Line(int u,int v,int F)\n{\n\tnxt[++tl] = hed[u],hed[u] = tl,ed[tl] = v,flow[tl] = F;\n\tnxt[++tl] = hed[v],hed[v] = tl,ed[tl] = u,flow[tl] = 0;\n}\nqueue <int> Q;\nvector <int> In[MAXN];\ninline bool BFS(int s,int t)\n{\n\twhile(!Q.empty()) Q.pop();\n\tQ.push(s),memset(dep,0,sizeof(dep)),dep[s] = 1;\n\twhile(!Q.empty())\n\t{\n\t\tint k = Q.front();Q.pop();\n\t\tif(k == t) return 1;\n\t\tfor(int i = hed[k];i;i=nxt[i]) if(!dep[ed[i]] && flow[i])\n\t\t\tdep[ed[i]] = dep[k] + 1,Q.push(ed[i]);\n\t}\n\treturn 0;\n}\nint DFS(int u,int F,int t)\n{\n\tif(u == t) return F;\n\tfor(int fl,&i = cur[u];i;i=nxt[i]) if(flow[i] && dep[ed[i]] == dep[u] + 1)\n\t{\n\t\tif(fl = DFS(ed[i],min(F,flow[i]),t))\n\t\t\treturn flow[i] -= fl,flow[i^1] += fl,fl;\n\t}\n\treturn 0;\n}\ninline int Dinic(int s,int t)\n{\n\tint Sum = 0,tmp;\n\twhile(BFS(s,t))\n\t{\n\t\tmemcpy(cur,hed,sizeof(cur));\n\t\twhile(tmp = DFS(s,INF,t)) Sum += tmp;\n\t}\n\treturn Sum;\n}\nbool vis[MAXN];\nint fa[MAXN];\ninline void Check()\n{\n\twhile(!Q.empty()) Q.pop();\n\tQ.push(1);\n\tint Cnt = 0;\n\twhile(!Q.empty())\n\t{\n\t\tint k = Q.front();Q.pop(),Cnt++;\n\t\tfor(auto v:In[k]) if(!vis[v]) vis[v] = 1,Q.push(to[v]),fa[v] = k;\n\t}\n\tif(Cnt != n) return (void) (puts(\"-1\"));\n\tfor(int i = 1;i<n;++i) printf(\"%d %d\\n\",fa[i],to[i]);\n}\nint main()\n{\n\tread(n),S = 1,T = n * 2;\n\tfor(int i = 2;i<=n;++i) Line(S,i,1),Line(i+n-1,T,1);\n\tfor(int i = 1,El,X;i<n;++i)\n\t{\n\t\tread(El);\n\t\twhile(El--)\n\t\t{\n\t\t\tread(X),In[X].push_back(i);\n\t\t\tif(X != 1) Line(X,i+n,1);\n\t\t}\n\t}\n\tif(Dinic(S,T) != n-1) return puts(\"-1\"),0;\n\tfor(int i = 2;i<=n;++i) for(int j = hed[i];j;j=nxt[j]) if(flow[j]==0)\n\t\tto[ed[j]-n] = i;\n\tCheck();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nint main(){\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; cin >> x;\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; cin >> y; y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tcout << -1 << endl;\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tvector<int> seen(n, -2);\n\tqueue<int> q;\n\tint st = -1;\n\tfor(int i = 0; i < n; i++) if(hop.pair_l[i] == -1) st = i;\n\tif(st == -1) bad();\n\tq.push(st); seen[st] = -1;\n\twhile(!q.empty()){\n\t\tint u = q.front(); q.pop();\n\t\tfor(int v : hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq.push(nv);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) cout << pu[i] + 1 << \" \" << pv[i] + 1 << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(dep[lb[y]]==dep[o]+1&&c[y])\n\tif(flow(lb[y])){\n\t\tc[y]=0;\n\t\tc[y^1]=1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[++oo][0]=o;\n\t\tbb[oo][1]=lb[y];\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cctype>\nconst int N=100007;\nstd::vector<int>e[N];std::queue<int>q;\nint vis[N],mat[N],tam[N];\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nint dfs(int u,int root)\n{\n    for(int v:e[u]) if(vis[v]^root) if(vis[v]=root,!mat[v]||dfs(mat[v],root)) return mat[v]=u;\n    return 0;\n}\nint main()\n{\n    int n=read();\n    for(int i=1;i<n;++i) for(int j=read();j;--j) e[read()].push_back(i);\n    for(int i=2;i<=n;++i) if(!dfs(i,i)) return puts(\"-1\"),0;\n    q.push(1);\n    for(int i=1,u;i<=n;++i)\n    {\n\tif(q.empty()) return puts(\"-1\"),0;\n\tu=q.front(),q.pop();\n\tfor(int v:e[u]) if(!tam[v]) tam[v]=u,q.push(mat[v]);\n    }\n    for(int i=1;i<n;++i) printf(\"%d %d\\n\",tam[i],mat[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nint cho1[MAXN+5],cho2[MAXN+5];\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\tint cnt=0;\n\twhile(!Q.empty()){\n\t\tcnt++;\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tcho1[s]=u,cho2[s]=ma[s];\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",cho1[i],cho2[i]);\n\treturn 0;\n}\n//"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[orig[1]]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/// Kazuki Hoshino\n\n\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n#define int long long\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\ntypedef vector<pi> vpi;\n#define inf 1000000000\n#define mod 1000000007\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define trav(a, x) for(auto& a : x)\n#define sz(x) (int)(x).size()\n#define dmp(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n#define fs first\n#define sc second\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define mt make_tuple\n//#define endl '\\n'\ntypedef tree<\nint,\nnull_type,less<int>,\nrb_tree_tag,tree_order_statistics_node_update>\nordered_set;\nbool dfs(int a, int layer, const vector<vi>& g, vi& btoa,vi& A, vi& B) {\n\tif (A[a] != layer) return 0;\n\tA[a] = -1;\n\ttrav(b, g[a]) if (B[b] == layer + 1) {\n\t\tB[b] = -1;\n\t\tif (btoa[b] == -1 || dfs(btoa[b], layer+2, g, btoa, A, B))\n\t\t\treturn btoa[b] = a, 1;\n\t}\n\treturn 0;\n}\n\nint hopcroftKarp(const vector<vi>& g, vi& btoa) {\n\tint res = 0;\n\tvi A(g.size()), B(btoa.size()), cur, next;\n\tfor (;;) {\n\t\tfill(all(A), 0);\n\t\tfill(all(B), -1);\n\t\t/// Find the starting nodes for BFS (i.e. layer 0).\n\t\tcur.clear();\n\t\ttrav(a, btoa) if(a != -1) A[a] = -1;\n\t\trep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n\t\t/// Find all layers using bfs.\n\t\tfor (int lay = 1;; lay += 2) {\n\t\t\tbool islast = 0;\n\t\t\tnext.clear();\n\t\t\ttrav(a, cur) trav(b, g[a]) {\n\t\t\t\tif (btoa[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tislast = 1;\n\t\t\t\t}\n\t\t\t\telse if (btoa[b] != a && B[b] == -1) {\n\t\t\t\t\tB[b] = lay;\n\t\t\t\t\tnext.push_back(btoa[b]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (islast) break;\n\t\t\tif (next.empty()) return res;\n\t\t\ttrav(a, next) A[a] = lay+1;\n\t\t\tcur.swap(next);\n\t\t}\n\t\t/// Use DFS to scan for augmenting paths.\n\t\trep(a,0,sz(g)) {\n\t\t\tif(dfs(a, 0, g, btoa, A, B))\n\t\t\t\t++res;\n\t\t}\n\t}\n}\nstd::vector<vector<int>> g;\nstd::vector<int> btoa;\nvector<pair<int,int>> adj[100005];\nint n,c,dist[100005], p[100005], vis[100005], match[100005], a[100005],b[100005];\nvoid bfstree(int s){\n\tqueue<int > q;\n\tfor(int i=1;i<=n;i++){\n\t\tvis[i]=0;\n\t\tdist[i]=inf;\n\t}\n\tdist[s]=0;\n\tq.push(s);\n\twhile(!q.empty()){\n\t\ts = q.front();\n\t\tq.pop();\n\t\tif(vis[s])continue;\n\t\tvis[s]=1;\n\t\t//cout << s << endl;\n\t\tfor(auto t:adj[s]){\n\t\t\tif(!vis[t.fs]){\n\t\t\t\t\tq.push(t.fs);\n\t\t\t\t\ta[t.sc]=t.fs;\n\t\t\t\t\tb[t.sc]=s;\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main(){\nios::sync_with_stdio(0);\ncin.tie(0);\n\n#ifndef ONLINE_JUDGE\n//freopen(\"input.txt\", \"r\", stdin);\n//freopen(\"output.txt\", \"w\", stdout);\n#endif\n\ncin >> n;\ng.resize(2*n);\nbtoa.resize(2*n,-1);\nfor(int i=1;i<=n-1;i++){\n\tcin >> c;\n\tint x;\n\tfor(int j=1;j<=c;j++){\n\t\tcin >> x;\n\t\t//x--;\n\t\tg[i].pb(x);\n\t}\n}\nint m = hopcroftKarp(g,btoa);\n//cout << m << endl;\nif(m!=n-1){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\t//cout << btoa[i] << endl;\n\tmatch[btoa[i]]=1;\n\tfor(auto t:g[i]){\n\t\t//adj[btoa[i]].pb(t);\n\t\tadj[t].pb({btoa[i],i});\n\t\t//dmp(t);\n\t}\n}\nint sum = 0,s;\nfor(int i=1;i<=n;i++){\n\t//sum+=vis[i];\n\tif(!match[i])s=i;\n}\nbfstree(s);\nfor(int i=1;i<=n;i++){\n\tsum+=vis[i];\n\t//if(!match[i])s=i;\n}\n//cout << s << endl;\nif(sum!=n){\n\tcout << -1 << endl;\n\treturn 0;\n}\n\nfor(int i=1;i<=n-1;i++){\n\tcout << a[i] << \" \" << b[i] << endl;\n}\n\nreturn 0;}\n///....\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fa[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[dy[y]]) {\n\t\t\tfa[dy[y]] = x;\n\t\t\tdfs(dy[y]);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 1) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline void solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\tsolve();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\nconst int maxn = 200005;\nint n;\nvector<int>ntoj[maxn],jton[maxn];\nint lk[maxn],dy[maxn];\nint vis[maxn];\nbool hungary(int x,int id) {\n\tif(vis[x]==id) return 0;\n\tvis[x] = id;\n\tfor(int y:jton[x]) {\n\t\tif(!lk[y]) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfor(int y:jton[x]) {\n\t\tif(hungary(lk[y],id)) {\n\t\t\tlk[y] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nvoid wuj() {\n\tputs(\"-1\");\n\texit(0);\n}\nbool vi[maxn];\nint fa[maxn];\nvoid dfs(int x) {\n\tvi[x] = 1;\n\tfor(int y:ntoj[x]) {\n\t\tif(!vi[y]) {\n\t\t\tfa[dy[y]] = x;\n\t\t\tdfs(y);\n\t\t}\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++) {\n\t\tint sz; scanf(\"%d\",&sz);\n\t\tjton[i].resize(sz);\n\t\tfor(int j=0;j<sz;j++) {\n\t\t\tint x; scanf(\"%d\",&x);\n\t\t\tntoj[x].push_back(i);\n\t\t\tjton[i][j]=x;\n\t\t}\n\t\tif((!hungary(i,i))) wuj();\n\t}\n\tfor(int i=1;i<n;i++) {\n\t\tdy[lk[i]]=i;\n\t}\n\tint rt = 1;\n\twhile(lk[rt]) rt++;\n\tdfs(rt);\n\tfor(int i=1;i<=n;i++) {\n\t\tif(!vi[i]) wuj();\n\t}\n\tfor(int i=1;i<=n;i++) {\n\t\tif(fa[i]) printf(\"%d %d\\n\",fa[i],i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define INF 1e9\n#define N 200010\nusing namespace std;\ntemplate <typename T> void read(T &x){\n\tx=0;char c=getchar();int fh=1;\n\twhile (!isdigit(c)){if (c=='-')fh=-1;c=getchar();}\n\twhile (isdigit(c))x=x*10+c-'0',c=getchar();\n\tx*=fh;\n}\nstruct Info{int nu,ne,qu;}a[N*6];\nstruct Onfo{int be,en;}f[N];\nint n,p,num=1,b[N],d[N],s,t,di[N],li[N],ansn,nu,cur[N];\nvoid jb(int x,int y,int z){a[++num].nu=y;a[num].ne=b[x];b[x]=num;a[num].qu=z;a[++num].nu=x;a[num].ne=b[y];b[y]=num;a[num].qu=0;}\nbool bfs(){\n\tfor (int i=1;i<=t;i++) di[i]=INF;\n\tint l=1,r=1;li[l]=s;di[s]=0;\n\twhile (l<=r){\n\t\tfor (int y=b[li[l]];y;y=a[y].ne)if (di[a[y].nu]==INF&&a[y].qu!=0){di[a[y].nu]=di[li[l]]+1;li[++r]=a[y].nu;}\n\t\tl++;\n\t}\n\treturn (di[t]!=INF);\n}\nint dinic(int x,int xi){\n\tif (x==t){ansn+=xi;return xi;}\n\tint sh=0,nu;\n\tfor (int y=cur[x];y;y=a[y].ne){\n\t\tcur[x]=y;\n\t\tif (a[y].qu!=0){\n\t\t\tnu=dinic(a[y].nu,min(a[y].qu,xi-sh));\n\t\t\tsh+=nu;a[y].qu-=nu;a[y^1].qu+=nu;\n\t\t\tif (sh==xi) return sh;\n\t\t}\n\t}\n\treturn sh;\n}\nint main(){\n\tread(n);\n\tfor (int i=1;i<=n-1;i++){\n\t\tread(p);\n\t\tf[i].be=nu+1;\n\t\twhile(p--){read(d[++nu]);if(d[nu]!=1){jb(i,d[nu]+n,1);}}\n\t\tf[i].en=nu;\n\t}\n\ts=n*2+1,t=n*2+2;\n\tfor (int i=1;i<=n;i++) jb(s,i,1);\n\tfor (int i=n+1;i<=n+n;i++)jb(i,t,1);\n\twhile (bfs()){\n\t\tfor(int i=1;i<=t;i++)  cur[i]=b[i];\n\t\tdinic(s,INF);\n\t}\n\tif (ansn==n-1){\n\t}else{\n\t\tputs(\"-1\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,st,ed) for(register int i=st,i##end=ed;i<=i##end;++i)\n#define DREP(i,st,ed) for(register int i=st,i##end=ed;i>=i##end;--i)\ntypedef long long ll;\ntemplate<typename T>inline bool chkmin(T &x,T y){return (y<x)?(x=y,1):0;}\ntemplate<typename T>inline bool chkmax(T &x,T y){return (y>x)?(x=y,1):0;}\ninline int read(){\n\tint x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1)+(x<<3)+(c^'0');\n\treturn x*f;\n}\ninline ll readll(){\n\tll x;\n\tchar c;\n\tint f=1;\n\twhile((c=getchar())!='-' && (c>'9' || c<'0'));\n\tif(c=='-') f=-1,c=getchar();\n\tx=c^'0';\n\twhile((c=getchar())>='0' && c<='9') x=(x<<1ll)+(x<<3ll)+(c^'0');\n\treturn x*f;\n}\nconst int maxn=2e5+10,maxm=1e6+10,inf=0x3f3f3f3f;\nint S,T,ans;\nstruct MAX_FLOW{\n\tint e,n,Begin[maxn],Next[maxm],to[maxm],w[maxm],d[maxn],cur[maxn];\n\tinline void add_edge(int x,int y,int z){\n\t\tto[++e]=y;\n\t\tNext[e]=Begin[x];\n\t\tBegin[x]=e;\n\t\tw[e]=z;\n\t}\n\tinline void add(int x,int y,int z){\n\t\tadd_edge(x,y,z),add_edge(y,x,0);\n\t}\n\tbool bfs(){\n\t\tREP(i,1,n) d[i]=-1;\n\t\tqueue<int> q;\n\t\tq.push(S);\n\t\td[S]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor(int i=Begin[u];i;i=Next[i]) if(w[i] && d[to[i]]==-1){\n\t\t\t\td[to[i]]=d[u]+1;\n\t\t\t\tif(to[i]==T) return 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint dfs(int x,int Min){\n\t\tif(!Min || x==T) return Min;\n\t\tint num,Flow=0;\n\t\tfor(int &i=cur[x];i;i=Next[i])\n\t\t\tif(w[i] && d[to[i]]==d[x]+1 && (num=dfs(to[i],min(Min,w[i])))){\n\t\t\t\tFlow+=num,Min-=num;\n\t\t\t\tw[i]-=num,w[i^1]+=num;\n\t\t\t\tif(!Min) break;\n\t\t\t}\n\t\treturn Flow;\n\t}\n\tvoid work(){\n\t\twhile(bfs()){\n\t\t\tREP(i,1,n) cur[i]=Begin[i];\n\t\t\tans+=dfs(S,inf);\n\t\t}\n\t}\n}MF;\nvector<int> ve[maxn],num[maxn];\nint vis[maxn],w[maxn],fr[maxn];\nstruct point{\n\tint x,y;\n}E[maxn];\nint main(){\n\tint n=read();\n\tMF.e=1;\n\tMF.n=2*n-1;\n\tS=++MF.n,T=++MF.n;\n\tREP(i,1,n-1){\n\t\tint m=read();\n\t\twhile(m--){\n\t\t\tint x=read();\n\t\t\tve[x].push_back(i);\n\t\t\tMF.add(i+n,x,1);\n\t\t\tnum[x].push_back(MF.e);\n\t\t}\n\t\tMF.add(S,i+n,1);\n\t}\n\tREP(i,2,n) MF.add(i,T,1);\n\tMF.work();\n\tif(ans!=n-1) return printf(\"-1\\n\"),0;\n\tREP(i,2,n) REP(j,0,ve[i].size()-1) if(MF.w[num[i][j]]) w[ve[i][j]]=i;\n\tqueue<int> q;\n\tint cnt=0;\n\tfor(auto v:ve[1]) vis[v]=1,q.push(v),fr[v]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tE[u]=(point){fr[u],w[u]};\n\t\t++cnt;\n\t\tfor(auto v:ve[w[u]]) if(!vis[v]) q.push(v),vis[v]=1,fr[v]=w[u];\n\t}\n\tif(cnt!=n-1) return printf(\"-1\\n\"),0;\n\tREP(i,1,n-1) printf(\"%d %d\\n\",E[i].x,E[i].y);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nint p[N],fa[N];\nint get(int u){return fa[u]==u?u:fa[u]=get(fa[u]);}\npii ans[N];\nint la;\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n)fa[i]=i;\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(get(x)!=p[i]){\n                ans[++la]={x,p[i]},fa[p[i]]=x;\n                //printf(\"x=%d\\n\",x);\n                break;\n            }\n        }\n    }\n    if(la<n-1)return puts(\"-1\"),1;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace IO {\n\tconst int SIZE = 1 << 20;\n\tchar buf[SIZE + 10], *iS, *iT;\n\tinline char Getc() {\n\t\treturn iS == iT && (iT = (iS = buf) + fread(buf, 1, SIZE, stdin), iS == iT) ? EOF : *iS++;\n\t}\n\ttemplate <class TT>\n\tinline void Read(TT &x) {\n\t\tx = 0; register char cc = '\\0'; TT fff = 1;\n\t\tfor (; cc < '0' || cc > '9'; cc = Getc())\n\t\t\tif (cc == '-') fff = -1;\n\t\tfor (; cc >= '0' && cc <= '9'; cc = Getc())\n\t\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\t\tx *= fff;\n\t}\n}\nusing IO::Read;\n\nconst int N = 2e5 + 10, M = 1e6 + 10;\n\nvector<int> bel[N];\npair<int, int> bufans[N]; int ctnum, Connect[N]; bool vis[N];\nint n, tot, stp, edp, hd, tl, fans, Q[N + 10], dep[N], Cur[N], Head[N], Next[M], Adj[M], W[M];\n\ninline void Addedge(int x, int y, int z) {\n/*\n\tprintf(\"%d %d %d\\n\", x, y, z);\n*/\n\tNext[++tot] = Head[x]; Head[x] = tot; Adj[tot] = y; W[tot] = z;\n\tNext[++tot] = Head[y]; Head[y] = tot; Adj[tot] = x; W[tot] = 0;\n}\n\ninline bool BFS() {\n\tfill(dep, dep + 1 + edp, -1), hd = tl = 0;\n\tQ[++tl] = stp, dep[stp] = 0;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\tfor (int e = Head[x]; e; e = Next[e])\n\t\t\tif (W[e] > 0 && dep[Adj[e]] == -1) {\n\t\t\t\tdep[Adj[e]] = dep[x] + 1;\n\t\t\t\tQ[++tl] = Adj[e];\n\t\t\t}\n\t}\n\treturn dep[edp] != -1;\n}\n\nint DFS(int x, int mxflow) {\n\tif (x == edp || !mxflow) return mxflow;\n\tfor (int &e = Cur[x]; e; e = Next[e])\n\t\tif (W[e] > 0 && dep[Adj[e]] == dep[x] + 1) {\n\t\t\tint ntflow = DFS(Adj[e], min(mxflow, W[e]));\n\t\t\tif (ntflow > 0) {\n\t\t\t\tW[e] -= ntflow;\n\t\t\t\tW[e ^ 1] += ntflow;\n\t\t\t\treturn ntflow;\n\t\t\t}\n\t\t}\n\treturn 0; /* star! */\n}\n\ninline void Dinic() {\n\tfans = 0;\n\twhile (BFS()) {\n\t\tint nflow = 0;\n\t\tcopy(Head, Head + 1 + edp, Cur);\n\t\twhile ((nflow = DFS(stp, 0x3f3f3f3f)) != 0)\n\t\t\tfans += nflow;\n\t}\n}\n\ninline void Extend(int x) {\n\tfor (int j = 0; j < (int)bel[x].size(); ++j)\n\t\tif (!vis[bel[x][j]]) {\n\t\t\tbufans[bel[x][j] - n] = make_pair(x, Connect[bel[x][j]]);\n\t\t\tvis[bel[x][j]] = true, Q[++tl] = Connect[bel[x][j]];\n\t\t}\n}\n\ninline void Solve() {\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int e = Head[n + i]; e; e = Next[e])\n\t\t\tif (Adj[e] <= n && W[e] > 0)\n\t\t\t\tConnect[n + i] = Adj[e];\n\thd = tl = 0;\n\tQ[++tl] = 1;\n\twhile (hd != tl) {\n\t\tint x = Q[++hd];\n\t\t++ctnum;\n\t\tExtend(x);\n\t}\n}\n\nint main()\n{\n\tRead(n), tot = 1 /* !!! */;\n\tstp = 2 * n, edp = 2 * n + 1;\n\tfor (int i = 2; i <= n; ++i) Addedge(stp, i, 1);\n\tfor (int i = 1; i < n; ++i) Addedge(n + i, edp, 1);\n\tfor (int i = 1, ilen; i < n; ++i) {\n\t\tRead(ilen);\n\t\tfor (int j = 1, x; j <= ilen; ++j) {\n\t\t\tRead(x);\n\t\t\tbel[x].push_back(n + i);\n\t\t}\n\t}\n\tfor (int i = 2; i <= n; ++i)\n\t\tfor (int j = 0; j < (int)bel[i].size(); ++j /* not i */)\n\t\t\tAddedge(i, bel[i][j], 1);\n\tDinic();\n\tif (fans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tSolve();\n\tif (ctnum < n) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int j = 1; j < n; ++j)\n\t\tprintf(\"%d %d\\n\", bufans[j].first, bufans[j].second);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n\t\treturn 0;\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing pi = pair<int, int>;\nconst int MAXN = 100005;\nconst int MAXM = 100005;\n\nstruct bpm{\n\tvector<int> gph[MAXN];\n\tint dis[MAXN], l[MAXN], r[MAXM], vis[MAXN];\n\tvoid clear(){ for(int i=0; i<MAXN; i++) gph[i].clear();\t}\n\tvoid add_edge(int l, int r){ gph[l].push_back(r); }\n\tbool bfs(int n){\n\t\tqueue<int> que;\n\t\tbool ok = 0;\n\t\tmemset(dis, 0, sizeof(dis));\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(l[i] == -1 && !dis[i]){\n\t\t\t\tque.push(i);\n\t\t\t\tdis[i] = 1;\n\t\t\t}\n\t\t}\n\t\twhile(!que.empty()){\n\t\t\tint x = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &i : gph[x]){\n\t\t\t\tif(r[i] == -1) ok = 1;\n\t\t\t\telse if(!dis[r[i]]){\n\t\t\t\t\tdis[r[i]] = dis[x] + 1;\n\t\t\t\t\tque.push(r[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ok;\n\t}\n\tbool dfs(int x){\n\t\tif(vis[x]) return 0;\n\t\tvis[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tif(r[i] == -1 || (!vis[r[i]] && dis[r[i]] == dis[x] + 1 && dfs(r[i]))){\n\t\t\t\tl[x] = i; r[i] = x;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint match(int n){\n\t\tmemset(l, -1, sizeof(l));\n\t\tmemset(r, -1, sizeof(r));\n\t\tint ret = 0;\n\t\twhile(bfs(n)){\n\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\tfor(int i=0; i<n; i++) if(l[i] == -1 && dfs(i)) ret++;\n\t\t}\n\t\treturn ret;\n\t}\n\tbool chk[MAXN + MAXM];\n\tvoid rdfs(int x, int n){\n\t\tif(chk[x]) return;\n\t\tchk[x] = 1;\n\t\tfor(auto &i : gph[x]){\n\t\t\tchk[i + n] = 1;\n\t\t\trdfs(r[i], n);\n\t\t}\n\t}\n\tvector<int> getcover(int n, int m){ // solve min. vertex cover\n\t\tmatch(n);\n\t\tmemset(chk, 0, sizeof(chk));\n\t\tfor(int i=0; i<n; i++) if(l[i] == -1) rdfs(i, n);\n\t\tvector<int> v;\n\t\tfor(int i=0; i<n; i++) if(!chk[i]) v.push_back(i);\n\t\tfor(int i=n; i<n+m; i++) if(chk[i]) v.push_back(i);\n\t\treturn v;\n\t}\n\n}bpm;\n\nint n, M[MAXN];\nint proc[MAXN];\npi dap[MAXN];\n\nvector<int> E[MAXN];\nvector<int> R[MAXN];\nqueue<int> que;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<n; i++){\n\t\tint s;\n\t\tscanf(\"%d\",&s);\n\t\tE[i].resize(s);\n\t\tfor(auto &j : E[i]){\n\t\t\tscanf(\"%d\",&j);\n\t\t\tR[j].push_back(i);\n\t\t\tif(j != 1) bpm.add_edge(i, j);\n\t\t}\n\t}\n\tint x = bpm.match(n + 1);\n\tif(x != n - 1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; i++) M[i] = bpm.l[i];\n\tque.push(1);\n\tvector<pi> edg;\n\twhile(!que.empty()){\n\t\tint x = que.front();\n\t\tque.pop();\n\t\tfor(auto &j : R[x]){\n\t\t\tif(proc[j]) continue;\n\t\t\tproc[j] = 1;\n\t\t\tdap[j] = pi(M[j], x);\n\t\t\tque.push(M[j]);\n\t\t}\n\t}\n\tfor(int i=1; i<n; i++) printf(\"%d %d\\n\", dap[i].first, dap[i].second);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dinic {\n    using F = int; const static F INF = 0x3f3f3f3f; \n    //using F = long long; const static F INF = 0x3f3f3f3f3f3f3f3f; \n    struct Edge {\n        int v, bro; F cap;\n        Edge() {}\n        Edge(int _v, int _bro, F _cap) : v(_v), bro(_bro), cap(_cap) {}\n    };\n    vector<Edge> e;\n    vector<int> pos, cur;\n    int n, s, t, m;\n    Dinic(int _n, int _s, int _t) : n(_n), s(_s), t(_t), m(0) {\n        pos.assign(n, -1);\n        cur.resize(n);\n        d.resize(n);\n        e.reserve(4e5);\n    }\n    void add(int u, int v, F c=INF) {\n        assert(u < n && v < n);\n        e.emplace_back(v, pos[u], c); pos[u] = m++;\n        e.emplace_back(u, pos[v], 0); pos[v] = m++;\n    }\n    vector<int> d;\n    // build layer graph\n    bool bfs() {\n        fill(d.begin(), d.end(), -1);\n        d[s] = 0;\n        queue<int> q; q.push(s);\n        while (!q.empty()) {\n            int u = q.front(); q.pop();\n            for (int i = cur[u] = pos[u]; i != -1; i = e[i].bro) {\n                int v = e[i].v;\n                if (d[v] == -1 && e[i].cap != 0) {\n                    d[v] = d[u] + 1;\n                    q.push(v);\n                }\n            }\n        }\n        return d[t] != -1;\n    }\n    // find blocking flow\n    F dfs(int u, F lim) {\n        if (u == t) return lim;\n        F tot = 0;\n        for (int& i = cur[u]; i != -1; i = e[i].bro) {\n            int v = e[i].v;\n            if (e[i].cap != 0 && d[v] == d[u] + 1) {\n                F flow = dfs(v, min(e[i].cap, lim-tot));\n                tot += flow;\n                e[i].cap -= flow;\n                e[i^1].cap += flow;\n                if (tot == lim) return lim;\n            }\n        }\n        return tot;\n    }\n    F flow() {\n        F res = 0;\n        while (bfs()) {\n            res += dfs(s, INF);\n        }\n        return res;\n    }\n};\n\nvoid solve() {\n    int n; cin >> n;\n    int S = 0, T = 2*n;\n    Dinic mf(T+1, S, T);\n    vector<vector<int>> g(n+1);\n    vector<int> left(n);\n    vector<bool> trk(n+1, false);\n    for (int i = 1; i < n; i++) {\n        int c; cin >> c;\n        for (int _ = 0; _ < c; _++) {\n            int x; cin >> x;\n            mf.add(x, n+i, 1);\n            g[x].push_back(i);\n        }\n    }\n\n    int root = n;\n    for (int i = 1; i <= n; i++) {\n        if (i != root) mf.add(S, i, 1);\n    }\n    for (int i = 1; i < n; i++) {\n        mf.add(n+i, T, 1);\n    }\n    if (mf.flow() != n-1) {\n        cout << -1; return;\n    }\n    for (int i = 1; i < n; i++) {\n        for (int p = mf.pos[n+i]; p != -1; p = mf.e[p].bro) {\n            if (mf.e[p].cap && mf.e[p].v <= n) {\n                left[i] = mf.e[p].v;\n            }\n        }\n    }\n\n    vector<int> pa(n);\n    function<void(int)> dfs = [&](int l){\n        trk[l] = true;\n        for (int r: g[l])if(!trk[left[r]]){\n            pa[r] = l;\n            dfs(left[r]);\n        }\n    };\n    dfs(root);\n    for (int i = 1; i <= n; i++) {\n        if (!trk[i]) {\n            cout << -1; return;\n        }\n    }\n    for (int i = 1; i < n; i++) {\n        cout << pa[i] << ' ' << left[i] << \"\\n\";\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 4e5 + 10, maxm = maxn;\nint to[maxm], nxt[maxm], head[maxn], cap[maxm], e, dep[maxn], flow[maxm], vis[maxn], s, t;\npair<int, int> p[maxn];\n\nvoid add(int x, int y, int z)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0;\n}\n\nint bfs()\n{\n\tmemset(dep, 0, sizeof(dep));\n\tqueue<int> Q;\n\tdep[s] = 1; Q.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(!dep[v] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dep[t]) return 1;\n\treturn 0;\n}\n\nint dfs(int x, int a)\n{\n\tif(x == t || a == 0) return a;\n\tint FLOW = 0, f;\n\tfor(int i = head[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif(dep[v] == dep[x] + 1 && (f = dfs(v, min(a, cap[i] - flow[i]))) > 0)\n\t\t{\n\t\t\tFLOW += f;\n\t\t\ta -= f;\n\t\t\tflow[i] += f; flow[i ^ 1] -= f;\n\t\t\tif(!a) return FLOW;\n\t\t}\n\t}\n\treturn FLOW;\n}\n\nint main()\n{\n\n\tint n = read();\n\te = 1; s = 0; t = n + n;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint m = read();\n\t\tfor(int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\n\tfor(int i = 2; i <= n; ++i) add(s, i, 1);\n\tfor(int i = n + 1; i <= n + n - 1; ++i) add(i, t, 1);\n\n\twhile(bfs()) dfs(s, 0x3f3f3f3f);\n\tfor(int u = 2; u <= n; ++u)\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(cap[i] == flow[i] && to[i] != s)\n\t\t{\n\t//\t\tcout << u << ' ' << to[i] << endl;\n\t\t\tp[to[i]].x = u;\n\t\t}\n\n\tqueue<int> Q; Q.push(1);\n\tint fg = n - 1;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(to[i] != s && !vis[to[i]])\n\t\t\tp[to[i]].y = u, vis[to[i]] = 1, Q.push(p[to[i]].x), --fg;\n\t}\n\tif(fg) return puts(\"-1\"), 0;\n\n\tfor(int i = n + 1; i <= n + n - 1; ++i) printf(\"%d %d\\n\", p[i].x, p[i].y);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (int)(n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n    x = 0; char c = getchar(); int f = 0;\n    for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n    for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n    if (f) x = -x;\n}\n\nnamespace mf {\n    static const int N = 5e5;\n    static const int M = 2e6 + 233;\n    static const int inf = 1e9;\n    struct E {\n\t\tint nxt, to, fl;\n    }e[M << 1];\n    int d[N], head[N], cur[N], e_cnt = 1;\n    int n, s, t;\n    inline void init(int _n, int _s, int _t) {\n\t\tn = _n; s = _s; t = _t;\n\t\tfill(head, head + n + 1, 0);\n\t\te_cnt = 1;\n    }\n    inline void add(int u, int v, int fl) {\n\t\te[++ e_cnt] = (E) {head[u], v, fl}; head[u] = e_cnt;\n    }\n    inline void link(int u, int v, int fl) {\n\t\tadd(u, v, fl); add(v, u, 0);\n    }\n    inline bool bfs(void) {\n\t\tqueue<int> q;\n\t\tfill(d, d + n + 1, -1);\n\t\td[s] = 0; q.push(s);\n\t\twhile(!q.empty()) {\n\t\t\tint u = q.front(); q.pop();\n\t\t\tfor(int i = head[u]; i; i = e[i].nxt) if(e[i].fl) {\n\t\t\t\t\tint v = e[i].to;\n\t\t\t\t\tif(!~ d[v]) d[v] = d[u] + 1, q.push(v);\n\t\t\t\t}\n\t\t}\n\t\treturn d[t] != -1;\n    }\n    inline int dfs(int u, int f) {\n\t\tif(u == t || !f) return f;\n\t\tint used = 0, t;\n\t\tfor(int &i = cur[u]; i; i = e[i].nxt) if(e[i].fl) {\n\t\t\t\tint v = e[i].to;\n\t\t\t\tif(d[v] != d[u] + 1) continue;\n\t\t\t\tt = dfs(v, min(f - used, e[i].fl));\n\t\t\t\tused += t; e[i].fl -= t; e[i ^ 1].fl += t;\n\t\t\t\tif(used == f) break;\n\t\t\t}\n\t\tif(!used) d[u] = -1;\n\t\treturn used;\n    }\n    inline int doit(void) {\n\t\tint fl = 0;\n\t\twhile(bfs()) {\n\t\t\tmemcpy(cur, head, sizeof (int) * (n + 2));\n\t\t\tfl += dfs(s, inf);\n\t\t}\n\t\treturn fl;\n    }\n}\n\n#define GG (puts(\"-1\"), exit(0))\nconst int N = mf::N;\nint n, match[N], con[N];\nvector <int> adj[N];\n\nint main(void) {\n\tread(n);\n\tint S = n + n, T = S + 1;\n\tmf::init(T, S, T);\n\tfor (int i = 2; i <= n; i++) {\n\t\tint E = i + n - 1;\n\t\tmf::link(S, i, 1);\n\t\tmf::link(E, T, 1);\n\t\tint sz, x; read(sz);\n\t\twhile (sz--) {\n\t\t\tread(x);\n\t\t\tmf::link(x, E, 1);\n\t\t}\t\t\n\t}\n\tif (mf::doit() != n - 1) GG;\n\tfor (int i = 2; i <= mf::e_cnt; i += 2) {\n\t\tint u = mf::e[i ^ 1].to;\n\t\tint v = mf::e[i].to;\n\t\tif (!mf::e[i].fl && (2 <= u && u <= n)) {\n\t\t\tmatch[v] = u;\n\t\t} else {\n\t\t\tadj[u].push_back(v);\n\t\t}\n\t}\n\tqueue <int> Q;\n\tQ.push(1);\n\twhile (!Q.empty()) {\n\t\tint u = Q.front(); Q.pop();\n\t\tfor (int i : adj[u]) {\n\t\t\tif (con[i]) continue;\n\t\t\tcon[i] = u;\n\t\t\tQ.push(match[i]);\n\t\t}\n\t}\n\tfor (int i = n + 1; i <= n + n - 1; i++) {\n\t\tcout << con[i] << \" \" << match[i] << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\nstruct Edge{\n\tint v,c,nxt;\n}e[1000010];int tot=1;\nint first[400010];\nvoid build(int u,int v,int c)\n{\n\te[++tot]=(Edge){v,c,first[u]};\n\tfirst[u]=tot;\n\treturn ;\n}\nvoid adde(int u,int v,int c)\n{\n\tbuild(u,v,c);\n\tbuild(v,u,0);\n\treturn ;\n}\nint dep[400010];\nint S,T;\nqueue<int>q;\nbool bfs()\n{\n\tfor(int i=1;i<=T;i++)\n\t\tdep[i]=0;\n\tq.push(S);dep[S]=1;\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(e[i].c&&!dep[e[i].v])\n\t\t\t{\n\t\t\t\tdep[e[i].v]=dep[u]+1;\n\t\t\t\tq.push(e[i].v);\n\t\t\t}\n\t}\n\treturn dep[T]>0;\n}\nint cur[400010];\nint dfs(int u,int flow)\n{\n\tif(u==T)return flow;\n\tfor(int &i=cur[u];i;i=e[i].nxt)\n\t\tif(e[i].c&&dep[e[i].v]==dep[u]+1)\n\t\t{\n\t\t\tint d=dfs(e[i].v,min(flow,e[i].c));\n\t\t\tif(d){\n\t\t\t\te[i].c-=d;\n\t\t\t\te[i^1].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=T;i++)\n\t\t\tcur[i]=first[i];\n\t\tint d;\n\t\twhile(d=dfs(S,1e9))\n\t\t\tans+=d;\n\t}\n\treturn ans;\n}\nvector<int>vec[100010];\nint tos[100010],ton[100010];\nint ansu[100010],ansv[100010];\nbool book[100010];\nvoid solve(int u)\n{\n\tbook[u]=true;\n\tfor(int i=0;i<vec[u].size();i++)\n\t{\n\t\tint v=vec[u][i];\n\t\tif(v==tos[u])continue;\n\t\tif(book[ton[v]])continue;\n\t\tansu[v]=u;\n\t\tansv[v]=ton[v];\n\t\tsolve(ton[v]);\n\t}\n\treturn ;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tS=n*2;T=n*2+1;\n\tfor(int i=1;i<=n;i++)\n\t\tadde(S,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tadde(i+n,T,1);\n\t\tint num;scanf(\"%d\",&num);\n\t\twhile(num--)\n\t\t{\n\t\t\tint u;scanf(\"%d\",&u);\n\t\t\tvec[u].push_back(i);\n\t\t\tadde(u,i+n,1);\n\t\t}\n\t}\n\tif(dinic()<n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint s=0;\n\tfor(int u=1;u<=n;u++)\n\t{\n\t\tfor(int i=first[u];i;i=e[i].nxt)\n\t\t\tif(!e[i].c&&e[i].v>n&&e[i].v<S){\n\t\t\t\tint v=e[i].v-n;\n\t\t\t\ttos[u]=v;\n\t\t\t\tton[v]=u;\n\t\t\t}\n\t\tif(!tos[u])s=u;\n\t}\n\tsolve(s);\n\tfor(int i=1;i<n;i++)\n\t\tif(!ansu[i]){\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",ansu[i],ansv[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[j]) if(!used[t]) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t}\n\tfor(int i=n-1;i>=0;--i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(val[i]*e[i][j-1]>=mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define M 800008\n#define N 200002\nint A[N],B[M],C[M],F[N],S,T,a[N],b[M],c[M],e[N],h[N],l,n,q[N],r,t;bool D[N],d[M];\ninline void add(int u,int v){b[++t]=a[u],c[a[u]=t]=v,d[t]=true,b[++t]=a[v],c[a[v]=t]=u;}\ninline bool bfs()\n{\n\tmemset(h+1,-1,T<<2),*h=l=0,*q=S,r=1;\n\twhile(l<r)for(int u=q[l++],i=a[u];i;i=b[i])if(d[i]&&h[c[i]]<0)h[q[r++]=c[i]]=h[u]+1;\n\treturn h[T]>=0;\n}\nbool dfs(int u)\n{\n\tif(u==T)return true;\n\tfor(int&i=e[u];i;i=b[i])if(d[i]&&h[c[i]]==h[u]+1&&dfs(c[i]))return d[i]=false,d[i^1]=true;\n\treturn false; \n}\nvoid ans(int u)\n{\n\tD[u]=true;\n\tfor(int&i=A[u];i;i=B[i])if(!D[C[i]])t++,F[C[i]]=u,ans(C[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n),T=n<<1;\n\tfor(int i=t=1,u,v;i<n;i++)for(scanf(\"%d\",&u);u--;)scanf(\"%d\",&v),add(n+i,v);\n\tfor(int i=2;i<=n;i++)add(i,T);\n\tfor(int i=1;i<n;i++)add(S,n+i);\n\tfor(t=0;bfs();)for(memcpy(e,a,T+1<<2);dfs(S);t++);\n\tif(t!=n-1)return 0*puts(\"-1\");\n\tfor(int i=2;i<=n;i++)while(a[i]=b[a[i]])if(d[a[i]])e[c[a[i]]-n]=i;\n\tfor(int i=t=1;i<n;i++)while(a[n+i]=b[a[n+i]])if(d[a[n+i]])B[++t]=A[c[a[n+i]]],C[A[c[a[n+i]]]=t]=e[i];\n\tif(t=0,ans(1),t!=n-1)return 0*puts(\"-1\");\n\telse for(int i=1;i<n;i++)printf(\"%d %d\\n\",F[e[i]],e[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconstexpr int N = 1E5;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i)\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db long double\n\nusing namespace std;\nconst int N=1e6+10,inf=1e9;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N],nt[N],c[N],hd[N],tot=1;\nvoid adde(int x,int y,int z)\n{\n    ++tot,to[tot]=y,nt[tot]=hd[x],c[tot]=z,hd[x]=tot;\n    ++tot,to[tot]=x,nt[tot]=hd[y],c[tot]=0,hd[y]=tot;\n}\nint ps,pt,lv[N],nhd[N];\nqueue<int> q;\nbool bfs()\n{\n    memset(lv,0,sizeof(int)*(pt+1));\n    lv[ps]=1,q.push(ps);\n    while(!q.empty())\n    {\n\tint x=q.front();\n\tq.pop();\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t    int y=to[i];\n\t    if(c[i]>0&&!lv[y])\n\t\tlv[y]=lv[x]+1,q.push(y);\n\t}\n    }\n    return lv[pt];\n}\nint dfs(int x,int fw)\n{\n    if(x==pt) return fw;\n    int an=0;\n    for(int &i=nhd[x];i;i=nt[i])\n    {\n\tint y=to[i];\n\tif(c[i]>0&&lv[y]==lv[x]+1)\n\t{\n\t    int dt=dfs(y,min(c[i],fw));\n\t    c[i]-=dt,c[i^1]+=dt;\n\t    fw-=dt,an+=dt;\n\t    if(!fw) break;\n\t}\n    }\n    return an;\n}\nint dinic()\n{\n    int an=0;\n    while(bfs())\n    {\n\tmemcpy(nhd,hd,sizeof(int)*(pt+1));\n\tan+=dfs(ps,inf);\n    }\n    return an;\n}\nint n,an[N][2],ta,fe[N],mat[N],mk[N];\nbool v[N];\nvoid dd(int x)\n{\n    v[x]=1;\n    for(int i=hd[x];i;i=nt[i])\n    {\n\tint yy=to[i]-n,y=mat[to[i]];\n\tif(!y||v[y]||c[i]) continue;\n\t++ta,an[yy][0]=x,an[yy][1]=y;\n\tdd(y);\n    }\n}\n\nint main()\n{\n///\n    n=rd();\n    ps=0,pt=n+n;\n    for(int i=1;i<n;++i)\n    {\n\tadde(ps,i+n,1);\n\tint t=rd();\n\twhile(t--) adde(i+n,rd(),1);\n    }\n    for(int i=1;i<=n;++i) adde(i,pt,1),fe[i]=tot;\n    if(dinic()<n-1){puts(\"-1\");exit(0);}\n    for(int i=1;i<n;++i)\n    {\n\tfor(int j=hd[i+n];j;j=nt[j])\n\t{\n\t    int y=to[j];\n\t    if(!c[j]&&y>=1&&y<=n){mat[i+n]=y,mk[y]=1;break;}\n\t}\n    }\n    int rt=1;\n    while(mk[rt]) ++rt;\n    dd(rt);\n    if(ta<n-1){puts(\"-1\");return 0;}\n    for(int i=1;i<=ta;++i) printf(\"%d %d\\n\",an[i][0],an[i][1]);\n    return 0;\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\nint vt[N*2],tim;\n\nbool bfs(){\n\ttim++;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tvt[st]=tim;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt){\n\t\t\tint y=e[p].x;\n\t\t\tif (vt[y]<tim&&e[p].f){\n\t\t\t\tvt[y]=tim;\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tque[++ta]=y;\n\t\t\t\tif (y==ed)return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn vt[ed]==tim;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&vt[e[p].x]==tim&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs()){\n\t\tint tmp=aug(st,INF);\n\t\twhile(tmp){\n\t\t\tret+=tmp;\n\t\t\ttmp=aug(st,INF);\n\t\t}\n\t}\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 5;\nconst int INF = 0x3f3f3f3f;\nconst int N = 200010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 1, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tif(Dinic() != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; bl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=2e5+5,M=N<<3;\n\nint t[M],f[M],nxt[M],lst[N],l;\n\nvoid add(int x,int y,int z) {\n\tt[++l]=y;f[l]=z;nxt[l]=lst[x];lst[x]=l;\n\tt[++l]=x;f[l]=0;nxt[l]=lst[y];lst[y]=l;\n}\n\nint n,S,T,q[N],dis[N],p[N],fa[N];\nvector<int> to[N];\n\nbool bfs() {\n\tfo(i,S,T) dis[i]=0;dis[S]=1;\n\tint i=0,j=1;q[1]=S;\n\twhile (i<j) \n\t\trep(k,q[++i]) \n\t\t\tif (f[k]&&!dis[t[k]]) {\n\t\t\t\tdis[t[k]]=dis[q[i]]+1;\n\t\t\t\tq[++j]=t[k];\n\t\t\t}\n\treturn dis[T];\n}\n\nint dinic(int x,int y) {\n\tif (x==T) return y;\n\tint now=0;\n\trep(i,x)\n\t\tif (f[i]&&dis[t[i]]==dis[x]+1) {\n\t\t\tint k=dinic(t[i],min(y,f[i]));\n\t\t\tf[i]-=k;f[i^1]+=k;\n\t\t\ty-=k;now+=k;\n\t\t\tif (!y) break;\n\t\t}\n\tif (!now) dis[x]=-1;\n\treturn now;\n}\n\nbool vis[N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x])\n\t\tif (!vis[p[y]]) {\n\t\t\tfa[y]=x;\n\t\t\tdfs(p[y]);\n\t\t}\n}\n\nint main() {\n\tn=read();S=0;T=n<<1;l=1;\n\tfo(i,1,n-1) {\n\t\tadd(S,i,1);\n\t\tint c=read();\n\t\tfo(j,1,c) {\n\t\t\tint x=read();\n\t\t\tif (x>1) add(i,x+n-1,1);\n\t\t\tto[x].push_back(i);\n\t\t}\n\t}\n\tfo(i,1,n) add(i+n-1,T,1);\n\tint ret=0;\n\twhile (bfs()) ret+=dinic(S,1);\n\tif (ret<n-1) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) rep(j,i) if (!f[j]&&t[j]) p[i]=t[j]-n+1;\n\tdfs(1);\n\tfo(i,1,n-1) if (!fa[i]) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005, inf = 0x3f3f3f3f;\n\nint n, s, t, head[N], cur[N], tot = 1, f[N];\nstruct edge { int to, nxt, rem; } e[N << 2];\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\n\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x], 1 }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y], 0 }, head[y] = tot;\n\tif (x != s && y != t) f[find(x)] = find(y);\n}\n\nint dis[N];\nbool bfs() {\n\tstd::memset(dis, 0, sizeof dis), dis[s] = 1;\n\tstd::queue<int> q; q.push(s);\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].rem && !dis[e[i].to])\n\t\t\t\tdis[e[i].to] = dis[tmp] + 1, q.push(e[i].to);\n\t}\n\treturn dis[t] > 0;\n}\nint dinic(int x, int low) {\n\tif (x == t || !low) return low;\n\tint ans = 0, t;\n\tfor (int &i = cur[x]; i; i = e[i].nxt)\n\t\tif (e[i].rem && dis[e[i].to] > dis[x] && (t = dinic(e[i].to, std::min(low, e[i].rem)))) {\n\t\t\te[i].rem -= t, e[i ^ 1].rem += t, low -= t, ans += t;\n\t\t\tif (!low) break;\n\t\t}\n\treturn ans;\n}\n\nstd::pair<int, int> ans[N];\nint E[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n, s = 0, t = 2 * n;\n\tfor (int i = 1; i < 2 * n; ++i) f[i] = i;\n\tfor (int i = 1, c, x; i < n; ++i) {\n\t\tstd::cin >> c, link(s, i + n);\n\t\twhile (c--) std::cin >> x, link(i + n, x);\n\t}\n\tfor (int i = 2; i <= n; ++i) link(i, t);\n\tfor (int i = 1; i < 2 * n; ++i) if (find(i) != find(1))\n\t\treturn std::cout << \"-1\\n\", 0;\n\tint sum = 0;\n\twhile (bfs()) std::memcpy(cur, head, sizeof head), sum += dinic(s, inf);\n\tif (sum < n - 1) return std::cout << \"-1\\n\", 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = head[i + n]; j; j = e[j].nxt)\n\t\t\tif (e[j].to != s && !e[j].rem) E[i] = e[j].to;\n\tstatic bool vis[N];\n\tstd::queue<int> q; q.push(1), vis[1] = 1;\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].to != t && !vis[E[e[i].to - n]]) {\n\t\t\t\tvis[E[e[i].to - n]] = 1, q.push(E[e[i].to - n]);\n\t\t\t\tans[e[i].to - n] = std::make_pair(tmp, E[e[i].to - n]);\n\t\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cout << ans[i].first << ' ' << ans[i].second << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 200002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[MAX_N], visited[MAX_N], rev[MAX_N];\nint source, target, d[MAX_N], f[MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    queue<int> qu;\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 400005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 10];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <stdlib.h>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <math.h>\n#include <limits>\n#include <set>\n#include <map>\nusing namespace std;\n#define SZ 233333\nint ch[SZ][2],fa[SZ],sum[SZ],vv[SZ],mx[SZ];\nbool rev[SZ];\nbool top(int x) {return !(ch[fa[x]][0]==x||ch[fa[x]][1]==x);}\nvoid pd(int x)\n{\n    if(!rev[x]) return;\n    rev[x]=0;\n    rev[ch[x][0]]^=1;\n    rev[ch[x][1]]^=1;\n    swap(ch[x][0],ch[x][1]);\n}\nvoid upd(int x)\n{\n    sum[x]=sum[ch[x][0]]+sum[ch[x][1]]+vv[x];\n    mx[x]=max(vv[x],max(mx[ch[x][0]],mx[ch[x][1]]));\n}\nvoid rot(int x)\n{\n    if(top(x)) return;\n    int y=fa[x],c=ch[y][0]==x;\n    int f=fa[y];\n    if(!top(y)) ch[f][ch[f][1]==y]=x; //f\n    if(ch[x][c]) fa[ch[x][c]]=y;\n    ch[y][!c]=ch[x][c];\n    ch[x][c]=y; fa[x]=f; fa[y]=x;\n    upd(y); upd(x);\n}\nint ss[SZ],sn;\nvoid splay(int x)\n{\n    sn=0;\n    for(int c=x;;c=fa[c])\n    {\n        ss[++sn]=c;\n        if(top(c)) break;\n    }\n    while(sn) pd(ss[sn--]);\n    while(!top(x))\n    {\n        int y=fa[x];\n        if(!top(y))\n        {\n            if(ch[fa[y]][0]==y^ch[y][0]==x) rot(x);\n            else rot(y);\n        }\n        rot(x);\n    }\n}\nvoid access(int x)\n{\n    for(int c=0;x;c=x,x=fa[x]) splay(x), ch[x][1]=c, upd(x);\n}\nvoid makeroot(int x) {access(x); splay(x); rev[x]^=1;}\nvoid link(int a,int b) {makeroot(a); fa[a]=b;}\nvoid cut(int a,int b) {makeroot(a); access(b); splay(b); ch[b][0]=fa[a]=0;}\nint findroot(int x)\n{\n    access(x); splay(x);\n    int lc=x;\n    while(ch[lc][0]) lc=ch[lc][0];\n    splay(lc); return lc;\n}\nint getrd(int a,int b) {makeroot(a); access(b); splay(b); return b;}\nint n,N,A[SZ],B[SZ],C[SZ],gg[SZ],val[SZ];\nvector<int> t[SZ],e[SZ];\nbool ali[SZ];\nvoid wor(int i)\n{\n\t--gg[i];\n\tif(gg[i]<0) throw \"GG\";\n\tint vvv=(gg[i]>0);\n\tif(vvv==val[i]) return;\n\tval[i]=vvv;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tcut(x,e[i][j-1]);\n\t\t\tcut(y,e[i][j-1]);\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n}\n#define pb push_back\nint main()\n{\n\tscanf(\"%d\",&n);N=n;\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint a,b;\n\t\tscanf(\"%d\",&a);\n\t\twhile(a--)\n\t\t\tscanf(\"%d\",&b), t[i].pb(b);\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t\te[i].pb(++N);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tval[i]=(t[i].size()>2);\n\t\tgg[i]=t[i].size()-2;\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tint x=t[i][j-1],y=t[i][j];\n\t\t\tif(findroot(x)!=findroot(y))\n\t\t\t{\n\t\t\t\tali[e[i][j-1]]=1;\n\t\t\t\tA[e[i][j-1]]=x;\n\t\t\t\tB[e[i][j-1]]=y;\n\t\t\t\tC[e[i][j-1]]=i;\n\t\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\t\tlink(x,e[i][j-1]);\n\t\t\t\tlink(y,e[i][j-1]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint s=getrd(x,y);\n\t\t\tif(!mx[s]&&!val[i])\n\t\t\t{\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(!mx[s])\n\t\t\t{\n\t\t\t\twor(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint u=mx[s];\n\t\t\tcut(A[u],u); cut(B[u],u);\n\t\t\tali[u]=0; wor(C[u]);\n\t\t\tali[e[i][j-1]]=1;\n\t\t\tA[e[i][j-1]]=x;\n\t\t\tB[e[i][j-1]]=y;\n\t\t\tC[e[i][j-1]]=i;\n\t\t\tvv[e[i][j-1]]=mx[e[i][j-1]]=val[i]*e[i][j-1];\n\t\t\tlink(x,e[i][j-1]);\n\t\t\tlink(y,e[i][j-1]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<t[i].size();++j)\n\t\t{\n\t\t\tif(!ali[e[i][j-1]]) continue;\n\t\t\tprintf(\"%d %d\\n\",t[i][j-1],t[i][j]);\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing db = double;\nusing vi = vector<int>;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x <<'\t' << x <<endl\n#else\n#define debug(x)\n#endif\nconst int inf = 0x3f3f3f3f;\nconst db eps = 1e-8;\nconst int mod = 1e9+7;\nll qpow(ll a, ll b){\n    ll ret = 1;\n    while(b){\n        if(b&1)ret = ret*a%mod;\n        a = a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nconst int maxn = 2e5 + 7;\nconst int INF = 0x3f3f3f3f;\nstruct Edge\n{\n    int from, to, cap, flow;\n};\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;\n    vector<int> G[maxn];\n    bool vis[maxn];\n    int d[maxn];\n    int cur[maxn];\n\n    void AddEdge(int from, int to, int cap, int c = 0)\n    {\n        edges.push_back(Edge{from, to, cap, 0});\n        edges.push_back(Edge{to, from, c, 0});\n        m = edges.size();\n        G[from].push_back(m - 2);\n        G[to].push_back(m - 1);\n    }\n\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> q;\n        q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i < G[u].size(); i++)\n            {\n                Edge &e = edges[G[u][i]];\n                if (!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n    int DFS(int u, int dist)\n    {\n        if (u == t || dist == 0)\n            return dist;\n        int flow = 0, f;\n        for (int &i = cur[u]; i < G[u].size(); i++)\n        {\n            Edge &e = edges[G[u][i]];\n            if (d[u] + 1 == d[e.to] && (f = DFS(e.to, min(dist, e.cap - e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[u][i] ^ 1].flow -= f;\n                flow += f;\n                dist -= f;\n                if (!dist)\n                    break;\n            }\n        }\n        return flow;\n    }\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while (BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        debug(flow);\n        return flow;\n    }\n    void print(){\n    \tfor(auto u:edges){\n    \t\tif(u.flow==0&&u.from>n)\n    \t\tcout << u.from << \" \"<< u.to <<\" \" << u.flow <<\"\\n\";\n\t\t}\n\t}\n}net;\nint n;\nbool vis1[maxn], vis2[maxn];\nint id[maxn], nxt[maxn];\nqueue<int>q;\nvector<int>G[maxn];\nbool solve(int n){\n\tfor(int i=1; i<n; ++i){\n\t\tcout <<\"begin :\" <<i <<endl;\n\t\tfor(auto v: net.G[n+i]){\t\n\t\t\tif(net.edges[v].to && !net.edges[v].flow){\n\t\t\t\tint u = net.edges[v].to;\n\t\t\t\tid[i] = u;\n\t\t\t\tvis1[u] = 1;\n\t\t\t\t\n\t\t\t\tdebug(u);break;\n\t\t\t}\t\n\t\t} \n\t\tcout <<\"end: \"<<i <<endl;\n\t}\n\tfor(int i=1; i<=n; ++i)if(!vis1[i])q.push(i);//, vis2[i]=1;\n\tint cnt =0;\n\tdebug(q.size());\n\twhile(!q.empty()){\n\t\tint x = q.front(); q.pop();\n\t\tcnt++;\n\t\tfor(auto v:G[x]){\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v] = 1;\n\t\t\t\tnxt[v] = x;\n\t\t\t\tq.push(id[v]);\n\t\t\t} \n\t\t}\n\t}debug(cnt);\n\treturn cnt==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tnet.n = n;\n\tnet.s = 0, net.t = 2*n;\n\tfor(int i=1; i<n; ++i){\n\t\tint x;cin >> x;\n\t\tnet.AddEdge(0, n+i, 1);\n\t\tfor(int j=0, u; j<x; ++j){\n\t\t\tcin >> u;\n\t\t\tnet.AddEdge(n+i, u, 1);\n\t\t\tG[u].pb(i);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tnet.AddEdge(i, 2*n, 1);\n\t}\n\tif(net.Maxflow(net.s, net.t)<n-1){\n\t\tcout <<\"-1\\n\";return 0;\n\t}\n\tnet.print();\n\tif(!solve(n)){\n\t\tcout <<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i)cout << id[i] <<\" \"<< nxt[i] <<\"\\n\";\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 400002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[MAX_N], visited[MAX_N], rev[MAX_N];\nint source, target, d[MAX_N], f[MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    queue<int> qu;\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &i : x) cin >> i;\n\t\ta.pb({x, i});\n\t}\n\tsort(all(a), [](auto i, auto j) {\n\t\treturn i.first.size() < j.first.size();\n\t});\n\trans.resize(n-1);\n\tdsu d(n);\n\tfor(auto [i, idx] : a) {\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 400050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn],gap[maxn];\nint cur[maxn],prt[maxn];\n\nint isap()\n{\n    for (int i=1;i<=vt;++i) cur[i]=head[i],++gap[d[i]=0];\n    int i=vs,ans=0;\n    while (d[vs]<vt)\n    {\n        if (i==vt)\n        {\n            for (++ans;i!=vs;i=edge[prt[i]^1])\n                // cout<<\"path:\"<<i<<endl,\n                --cost[prt[i]],++cost[prt[i]^1];\n            // cout<<\"path:\"<<vs<<endl<<endl;\n        }\n\n        bool flag=0;\n        for (int k=cur[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (cost[k]&&d[i]==d[j]+1)\n            {\n                flag=1;\n                cur[i]=prt[j]=k;\n                i=j;\n                break;\n            }\n        }\n\n        if (flag)   continue;\n\n        if (--gap[d[i]]==0) break;\n        d[i]=vt;\n        for (int k=head[i];~k;k=nxt[k])\n            if (cost[k]&&d[edge[k]]+1<d[i])\n                cur[i]=k,d[i]=d[edge[k]]+1;\n                // d[i]=min(d[i],d[edge[k]]+1);\n        ++gap[d[i]];\n        // cur[i]=head[i];\n        if (i!=vs)\n            i=edge[prt[i]^1];\n    }\n    // cout<<\"isap:\"<<ans<<endl;\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define sort stable_sort\n#define all(x) (x).begin(),(x).end()\n#define rep(i,x) for (register int (i)=(1);(i)<=(x);(i)++)\n#define rep1(i,x,y) for (register int (i)=(x);(i)<=(y);(i)++)\n#define rep2(i,x) for (register int (i)=(x);(i)>=(1);(i)--)\n#define foreach(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\nusing namespace std;\nint n,m,i,j,s=0,t=400001,dis[400005],lk[200005],fa[200005],cnt;\nvector<int> ss[200005],adj[200005];\nstruct edg\n{\n\tint y,z;\n}ee[2000005];\nvector<int> e[400005];\nvoid add(int x,int y,int z)\n{\n\tcnt++;\n\tee[cnt*2-2]=(edg){y,z};\n\tee[cnt*2-1]=(edg){x,0};\n\te[x].pb(cnt*2-2);e[y].pb(cnt*2-1);\n}\nbool bfs(int s,int t)\n{\n\tmemset(dis,0x3f,sizeof(dis));\n\tdis[s]=0;queue<int> qx;qx.push(s);\n\twhile(!qx.empty()){\n\t\tint x=qx.front();qx.pop();\n\t\tforeach(it,e[x])if(ee[*it].z&&dis[ee[*it].y]>dis[x]+1){\n\t\t\tdis[ee[*it].y]=dis[x]+1;\n\t\t\tqx.push(ee[*it].y);\n\t\t}\n\t}\n\treturn dis[t]<dis[t+1];\n}\nint dfs(int x,int tt,int flw)\n{\n\tif(!flw||x==tt)return flw;\n\tint ans=0;\n\tforeach(it,e[x])if(ee[*it].z&&dis[ee[*it].y]==dis[x]+1){\n\t\tint t=dfs(ee[*it].y,tt,min(flw,ee[*it].z));\n\t\tans+=t;flw-=t;\n\t\tee[*it].z-=t;ee[(*it)^1].z+=t;\n\t}\n\treturn ans;\n}\nint dinic(int s,int t)\n{\n\tint ans=0;\n\twhile(bfs(s,t)){\n\t\tans+=dfs(s,t,0x3f3f3f3f);\n\t}\n\treturn ans;\n}\nvoid dfs2(int x)\n{\n\tforeach(it,adj[x]){\n\t\tif(!fa[*it]){\n\t\t\tfa[*it]=x;\n\t\t\tdfs2(*it);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\trep(i,n-1){\n\t\tint x;\n\t\tscanf(\"%d\",&x);\n\t\twhile(x--){\n\t\t\tint y;\n\t\t\tscanf(\"%d\",&y);\n\t\t\tss[i].push_back(y);\n\t\t\tif(y!=1){\n\t\t\t\tadd(y,i+n,1);\n\t\t\t}\n\t\t}\n\t}\n\trep1(i,2,n) add(s,i,1);\n\trep(i,n-1) add(i+n,t,1);\n\tif(dinic(s,t)!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(i=1;i<cnt*2;i+=2){\n\t\tif(2<=ee[i].y&&ee[i].y<=n&&n<ee[i^1].y&&ee[i^1].y<n+n&&ee[i].z){\n\t\t\tlk[ee[i^1].y-n]=ee[i].y;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tforeach(it,ss[i])if(*it!=lk[i]){\n\t\t\tadj[*it].pb(lk[i]);\n\t\t}\n\t}\n\tfa[1]=1;\n\tdfs2(1);\n\trep1(i,2,n)if(!fa[i]){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,n-1) printf(\"%d %d\\n\",lk[i],fa[lk[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2], Q[Max_N];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tQ[Q[0] = 1] = 1;\n\t\tfor (int u, ft = 1;ft <= Q[0];)\n\t\t{\n\t\t\tu = Q[ft++];\n\t\t\tfor (int i = 0, t;i < In[u].size();++i)\n\t\t\t\tif (!done[t = In[u][i]])\n\t\t\t\t{\n\t\t\t\t\tdone[t] = true;\n\t\t\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), Q[++Q[0]] = v;\n\t\t\t\t}\n\t\t}\n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);h=t=0;q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)return used++,c[i]--,c[i^1]++,pre[a[i]]=x,1; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\nusing db = double;\nusing vi = vector<int>;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\n#ifndef ONLINE_JUDGE\n#define debug(x) cout << #x <<'\t' << x <<endl\n#else\n#define debug(x)\n#endif\nconst int inf = 0x3f3f3f3f;\nconst db eps = 1e-8;\nconst int mod = 1e9+7;\nll qpow(ll a, ll b){\n    ll ret = 1;\n    while(b){\n        if(b&1)ret = ret*a%mod;\n        a = a*a%mod;\n        b>>=1;\n    }\n    return ret;\n}\nconst int maxn = 2e5 + 7;\nconst int INF = 0x3f3f3f3f;\n/*\nstruct Edge\n{\n    int from, to, cap, flow;\n};\nstruct Dinic\n{\n    int n, m, s, t;\n    vector<Edge> edges;\n    vector<int> G[maxn];\n    bool vis[maxn];\n    int d[maxn];\n    int cur[maxn];\n\n    void AddEdge(int from, int to, int cap, int c = 0)\n    {\n        edges.push_back(Edge{from, to, cap, 0});\n        edges.push_back(Edge{to, from, c, 0});\n        m = edges.size();\n        G[from].push_back(m - 2);\n        G[to].push_back(m - 1);\n    }\n\n    bool BFS()\n    {\n        memset(vis, 0, sizeof(vis));\n        queue<int> q;\n        q.push(s);\n        d[s] = 0;\n        vis[s] = 1;\n        while (!q.empty())\n        {\n            int u = q.front();\n            q.pop();\n            for (int i = 0; i < G[u].size(); i++)\n            {\n                Edge &e = edges[G[u][i]];\n                if (!vis[e.to] && e.cap > e.flow)\n                {\n                    vis[e.to] = 1;\n                    d[e.to] = d[u] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n        return vis[t];\n    }\n    int DFS(int u, int dist)\n    {\n        if (u == t || dist == 0)\n            return dist;\n        int flow = 0, f;\n        for (int &i = cur[u]; i < G[u].size(); i++)\n        {\n            Edge &e = edges[G[u][i]];\n            if (d[u] + 1 == d[e.to] && (f = DFS(e.to, min(dist, e.cap - e.flow))) > 0)\n            {\n                e.flow += f;\n                edges[G[u][i] ^ 1].flow -= f;\n                flow += f;\n                dist -= f;\n                if (!dist)\n                    break;\n            }\n        }\n        return flow;\n    }\n    int Maxflow(int s, int t)\n    {\n        this->s = s;\n        this->t = t;\n        int flow = 0;\n        while (BFS())\n        {\n            memset(cur, 0, sizeof(cur));\n            flow += DFS(s, INF);\n        }\n        debug(flow);\n        return flow;\n    }\n    void print(){\n    \tfor(auto u:edges){\n    \t\tif(u.flow==0&&u.from>n)\n    \t\tcout << u.from << \" \"<< u.to <<\" \" << u.flow <<\"\\n\";\n\t\t}\n\t}\n}net;*/\n#define maxn 250000\n#define INF 0x3f3f3f3f\n\nstruct Edge {\n  int from, to, cap, flow;\n  Edge(int u, int v, int c, int f) : from(u), to(v), cap(c), flow(f) {}\n};\n\nstruct Dinic {\n  int n, m, s, t;\n  vector<Edge> edges;\n  vector<int> G[maxn];\n  int d[maxn], cur[maxn];\n  bool vis[maxn];\n\n  void init(int n) {\n    for (int i = 0; i < n; i++) G[i].clear();\n    edges.clear();\n  }\n\n  void AddEdge(int from, int to, int cap) {\n    edges.push_back(Edge(from, to, cap, 0));\n    edges.push_back(Edge(to, from, 0, 0));\n    m = edges.size();\n    G[from].push_back(m - 2);\n    G[to].push_back(m - 1);\n  }\n\n  bool BFS() {\n    memset(vis, 0, sizeof(vis));\n    queue<int> Q;\n    Q.push(s);\n    d[s] = 0;\n    vis[s] = 1;\n    while (!Q.empty()) {\n      int x = Q.front();\n      Q.pop();\n      for (int i = 0; i < G[x].size(); i++) {\n        Edge& e = edges[G[x][i]];\n        if (!vis[e.to] && e.cap > e.flow) {\n          vis[e.to] = 1;\n          d[e.to] = d[x] + 1;\n          Q.push(e.to);\n        }\n      }\n    }\n    return vis[t];\n  }\n\n  int DFS(int x, int a) {\n    if (x == t || a == 0) return a;\n    int flow = 0, f;\n    for (int& i = cur[x]; i < G[x].size(); i++) {\n      Edge& e = edges[G[x][i]];\n      if (d[x] + 1 == d[e.to] && (f = DFS(e.to, min(a, e.cap - e.flow))) > 0) {\n        e.flow += f;\n        edges[G[x][i] ^ 1].flow -= f;\n        flow += f;\n        a -= f;\n        if (a == 0) break;\n      }\n    }\n    return flow;\n  }\n\n  int Maxflow(int s, int t) {\n    this->s = s;\n    this->t = t;\n    int flow = 0;\n    while (BFS()) {\n      memset(cur, 0, sizeof(cur));\n      flow += DFS(s, INF);\n    }\n    return flow;\n  }\n}net;\nint n;\nbool vis1[maxn], vis2[maxn];\nint id[maxn], nxt[maxn];\nqueue<int>q;\nvector<int>G[maxn];\nbool solve(int n){\n\tfor(int i=1; i<n; ++i){\n\t//\tcout <<\"begin :\" <<i <<endl;\n\t\tfor(auto v: net.G[n+i]){\t\n\t\t\tif(net.edges[v].to && net.edges[v].flow>0){\n\t\t\t\tint u = net.edges[v].to;\n\t\t\t\tid[i] = u;\n\t\t\t\tvis1[u] = 1;\n\t\t\t\t\n\t\t\t\tdebug(u);//break;\n\t\t\t}\t\n\t\t} \n\t//\tcout <<\"end: \"<<i <<endl;\n\t}\n\tfor(int i=1; i<=n; ++i)if(!vis1[i])q.push(i);//, vis2[i]=1;\n\tint cnt =0;\n\tdebug(q.size());\n\twhile(!q.empty()){\n\t\tint x = q.front(); q.pop();\n\t\tcnt++;\n\t\tfor(auto v:G[x]){\n\t\t\tif(!vis2[v]){\n\t\t\t\tvis2[v] = 1;\n\t\t\t\tnxt[v] = x;\n\t\t\t\tq.push(id[v]);\n\t\t\t} \n\t\t}\n\t}debug(cnt);\n\treturn cnt==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n;\n\tnet.n = n;\n\tnet.s = 0, net.t = 2*n;\n\tfor(int i=1; i<n; ++i){\n\t\tint x;cin >> x;\n\t\tnet.AddEdge(0, n+i, 1);\n\t\tfor(int j=0, u; j<x; ++j){\n\t\t\tcin >> u;\n\t\t\tnet.AddEdge(n+i, u, 1);\n\t\t\tG[u].pb(i);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; ++i){\n\t\tnet.AddEdge(i, 2*n, 1);\n\t}\n\tif(net.Maxflow(net.s, net.t)<n-1){\n\t\tcout <<\"-1\\n\";return 0;\n\t}\n//\tnet.print();\n\tif(!solve(n)){\n\t\tcout <<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tfor(int i=1; i<n; ++i)cout << id[i] <<\" \"<< nxt[i] <<\"\\n\";\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200100,MAXM=1000100,INF=0x3f3f3f3f;\nstruct Edge\n{\n\tint to,val,nxt;\n\tinline Edge() {}\n\tinline Edge(register int to,register int val,register int nxt):to(to),val(val),nxt(nxt) {}\n};\nEdge e[MAXM];\nint head[MAXN],S,T,cnt;\nint d[MAXN],cur[MAXN];\nint vis1[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];\nint N;\nqueue<int> q,q_;\nvector<int> bel[MAXN];\ninline void Addedge(register int x,register int y,register int z)\n{\n\te[++cnt]=Edge(y,z,head[x]),head[x]=cnt;\n\te[++cnt]=Edge(x,0,head[y]),head[y]=cnt;\n\treturn;\n}\ninline bool bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tmemset(d,-1,sizeof(d));\n\td[S]=0,cur[S]=head[S],q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tregister int now=q.front(); q.pop();\n\t\tfor(register int i=head[now];i;i=e[i].nxt)\n\t\t\tif(e[i].val&&!(~d[e[i].to]))\n\t\t\t{\n\t\t\t\tregister int to=e[i].to;\n\t\t\t\td[to]=d[now]+1,cur[to]=head[to];\n\t\t\t\tif(to==T) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(register int now,register int num)\n{\n\tif(now==T||!num) return num;\n\tregister int ans=0;\n\tfor(register int i=cur[now];i;i=e[i].nxt)\n\t\tif(e[i].val&&d[e[i].to]==d[now]+1)\n\t\t{\n\t\t\tregister int to=e[i].to,f=dfs(to,min(num,e[i].val));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\te[i].val-=f,e[i^1].val+=f;\n\t\t\t\tans+=f,num-=f;\n\t\t\t\tif(!num) break;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\ninline int maxflow()\n{\n\tregister int ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\ninline bool solve(register int n)\n{\n\tfor(register int i=1;i<n;i++)\n\t\tfor(register int j=head[n+i];j;j=e[j].nxt)\n\t\t\tif(e[j].to&&!e[j].val) id[i]=e[j].to,vis1[e[j].to]=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis1[i]) q_.push(i);\n\tregister int cnt_=0;\n\twhile(!q_.empty())\n\t{\n\t\tregister int now=q_.front(); q_.pop();\n\t\tcnt_++;\n\t\tfor(register int i=0;i<(int)bel[now].size();i++)\n\t\t\tif(!vis2[bel[now][i]]) vis2[bel[now][i]]=1,nxt[bel[now][i]]=now,q_.push(id[bel[now][i]]);\n\t}\n\treturn cnt_==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>N;\n\tS=0,T=N<<1;\n\tfor(register int i=1,x,y;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\tAddedge(S,N+i,1);\n\t\tfor(register int j=1;j<=x;j++) cin>>y,Addedge(N+i,y,1),bel[y].push_back(i);\n\t}\n\tfor(register int i=1;i<=N;i++) Addedge(i,T,1);\n\tif(maxflow()<N-1) return puts(\"-1\"),0;\n\tif(!solve(N)) return puts(\"-1\"),0;\n\tfor(register int i=1;i<N;i++) cout<<id[i]<<\" \"<<nxt[i]<<\"\\n\";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0),dis[i]=2;\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0),dis[i]=1;\n\tn<<=1;int ans=0;\n\tdis[T]=0;dis[S]=3;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cassert>\n#include <random>\n#include <iomanip>\n#include <bitset>\n#define FOR(i, n, m) for(ll i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-6;\n \ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n    os << to_string(p.first) << \" \" << to_string(p.second);\n    return os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n    REP(i, v.size()) {\n        if(i) os << \" \";\n        os << v[i];\n    }\n    return os;\n}\n \nstruct modint {\n    ll n;\npublic:\n    modint(const ll n = 0) : n((n % mod + mod) % mod) {}\n    static modint pow(modint a, int m) {\n        modint r = 1;\n        while(m > 0) {\n            if(m & 1) { r *= a; }\n            a = (a * a); m /= 2;\n        }\n        return r;\n    }\n    modint &operator++() { *this += 1; return *this; }\n    modint &operator--() { *this -= 1; return *this; }\n    modint operator++(int) { modint ret = *this; *this += 1; return ret; }\n    modint operator--(int) { modint ret = *this; *this -= 1; return ret; }\n    modint operator~() const { return (this -> pow(n, mod - 2)); } // inverse\n    friend bool operator==(const modint& lhs, const modint& rhs) {\n        return lhs.n == rhs.n;\n    }\n    friend bool operator<(const modint& lhs, const modint& rhs) {\n        return lhs.n < rhs.n;\n    }\n    friend bool operator>(const modint& lhs, const modint& rhs) {\n        return lhs.n > rhs.n;\n    }\n    friend modint &operator+=(modint& lhs, const modint& rhs) {\n        lhs.n += rhs.n;\n        if (lhs.n >= mod) lhs.n -= mod;\n        return lhs;\n    }\n    friend modint &operator-=(modint& lhs, const modint& rhs) {\n        lhs.n -= rhs.n;\n        if (lhs.n < 0) lhs.n += mod;\n        return lhs;\n    }\n    friend modint &operator*=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * rhs.n) % mod;\n        return lhs;\n    }\n    friend modint &operator/=(modint& lhs, const modint& rhs) {\n        lhs.n = (lhs.n * (~rhs).n) % mod;\n        return lhs;\n    }\n    friend modint operator+(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n + rhs.n);\n    }\n    friend modint operator-(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n - rhs.n);\n    }\n    friend modint operator*(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * rhs.n);\n    }\n    friend modint operator/(const modint& lhs, const modint& rhs) {\n        return modint(lhs.n * (~rhs).n);\n    }\n};\nistream& operator>>(istream& is, modint m) { is >> m.n; return is; }\nostream& operator<<(ostream& os, modint m) { os << m.n; return os; }\n \n#define MAX_N 1010101\nlong long extgcd(long long a, long long b, long long& x, long long& y) {\n    long long d = a;\n    if (b != 0) {\n        d = extgcd(b, a % b, y, x);\n        y -= (a / b) * x;\n    } else {\n        x = 1; y = 0;\n    }\n    return d;\n}\nlong long mod_inverse(long long a, long long m) {\n    long long x, y;\n    if(extgcd(a, m, x, y) == 1) return (m + x % m) % m;\n    else return -1;\n}\nvector<long long> fact(MAX_N+1, inf);\nlong long mod_fact(long long n, long long& e) {\n    if(fact[0] == inf) {\n        fact[0]=1;\n        if(MAX_N != 0) fact[1]=1;\n        for(ll i = 2; i <= MAX_N; ++i) {\n            fact[i] = (fact[i-1] * i) % mod;\n        }\n    }\n    e = 0;\n    if(n == 0) return 1;\n    long long res = mod_fact(n / mod, e);\n    e += n / mod;\n    if((n / mod) % 2 != 0) return (res * (mod - fact[n % mod])) % mod;\n    return (res * fact[n % mod]) % mod;\n}\n// return nCk\nlong long mod_comb(long long n, long long k) {\n    if(n < 0 || k < 0 || n < k) return 0;\n    long long e1, e2, e3;\n    long long a1 = mod_fact(n, e1), a2 = mod_fact(k, e2), a3 = mod_fact(n - k, e3);\n    if(e1 > e2 + e3) return 0;\n    return (a1 * mod_inverse((a2 * a3) % mod, mod)) % mod;\n}\n \nusing mi = modint;\n \nmi mod_pow(mi a, ll n) {\n    mi ret = 1;\n    mi tmp = a;\n    while(n > 0) {\n        if(n % 2) ret *= tmp;\n        tmp = tmp * tmp;\n        n /= 2;\n    }\n    return ret;\n}\n \nll gcd(ll a, ll b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nusing ld = long double;\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph;\n  vector< int > dist, match;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), match(m, -1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n};\n\nvoid dfs(int v, vector<set<int>>& g, vector<int>& ord) {\n    for(auto adj: g[v]) {\n        if(ord[adj] == inf) {\n            ord[adj] = ord[v] + 1;\n            dfs(adj, g, ord);\n        }\n    }\n    return;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    vector<vector<int>> w(n - 1);\n    HopcroftKarp hk(n, n - 1);\n    REP(i, n - 1) {\n        int c;\n        cin >> c;\n        vector<int> v(c);\n        REP(j, c) {\n            cin >> v[j];\n            v[j]--;\n            hk.add_edge(v[j], i);\n        }\n        w[i] = v;\n    }\n    int mx = hk.bipartite_matching();\n    if(mx <= n - 2) {\n        cout << -1 << endl;\n        return 0;\n    }\n    set<int> unused;\n    REP(i, n) unused.insert(i);\n    vector<pair<int, int>> ans(n - 1);\n    vector<set<int>> g(n);\n    REP(i, n - 1) {\n        unused.erase(hk.match[i]);\n        ans[i].first = hk.match[i];\n        for(auto elm: w[i]) {\n            if(elm == hk.match[i]) continue;\n            g[elm].insert(hk.match[i]);\n        }\n    }\n    int root = *(unused.begin());\n    vector<int> ord(n, inf);\n    ord[root] = 0;\n    dfs(root, g, ord);\n    REP(i, n) if(ord[i] == inf) {\n        cout << -1 << endl;\n        return 0;\n    }\n    REP(i, n - 1) {\n        for(auto elm: w[i]) {\n            if(ord[elm] < ord[hk.match[i]]) {\n                ans[i].second = elm;\n                break;\n            }\n        }\n    }\n    REP(i, n - 1) {\n        cout << ans[i].first + 1 << \" \" << ans[i].second + 1 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef long long LL;\n\n#define A first\n#define B second\n\nconst int MAXN = 1e5+5;\n\ntypedef ll Flow;\nstruct Edge {\n\tint dest, back;\n\tFlow f, c;\n};\n\nstruct PushRelabel {\n\tvector<vector<Edge>> g;\n\tvector<Flow> ec;\n\tvector<Edge*> cur;\n\tvector<vi> hs; vi H;\n\tPushRelabel(int n) : g(n), ec(n), cur(n), hs(2*n), H(n) {}\n\n\tvoid add_edge(int s, int t, Flow cap, Flow rcap=0) {\n\t\tif (s == t) return;\n\t\tEdge a = {t, sz(g[t]), 0, cap};\n\t\tEdge b = {s, sz(g[s]), 0, rcap};\n\t\tg[s].push_back(a);\n\t\tg[t].push_back(b);\n\t}\n\n\tvoid add_flow(Edge& e, Flow f) {\n\t\tEdge &back = g[e.dest][e.back];\n\t\tif (!ec[e.dest] && f) hs[H[e.dest]].push_back(e.dest);\n\t\te.f += f; e.c -= f; ec[e.dest] += f;\n\t\tback.f -= f; back.c += f; ec[back.dest] -= f;\n\t}\n\tFlow maxflow(int s, int t) {\n\t\tint v = sz(g); H[s] = v; ec[t] = 1;\n\t\tvi co(2*v); co[0] = v-1;\n\t\trep(i,0,v) cur[i] = g[i].data();\n\t\ttrav(e, g[s]) add_flow(e, e.c);\n\n\t\tfor (int hi = 0;;) {\n\t\t\twhile (hs[hi].empty()) if (!hi--) return -ec[s];\n\t\t\tint u = hs[hi].back(); hs[hi].pop_back();\n\t\t\twhile (ec[u] > 0)  // discharge u\n\t\t\t\tif (cur[u] == g[u].data() + sz(g[u])) {\n\t\t\t\t\tH[u] = 1e9;\n\t\t\t\t\ttrav(e, g[u]) if (e.c && H[u] > H[e.dest]+1)\n\t\t\t\t\t\tH[u] = H[e.dest]+1, cur[u] = &e;\n\t\t\t\t\tif (++co[H[u]], !--co[hi] && hi < v)\n\t\t\t\t\t\trep(i,0,v) if (hi < H[i] && H[i] < v)\n\t\t\t\t\t\t\t--co[H[i]], H[i] = v + 1;\n\t\t\t\t\thi = H[u];\n\t\t\t\t} else if (cur[u]->c && H[u] == H[cur[u]->dest]+1)\n\t\t\t\t\tadd_flow(*cur[u], min(ec[u], cur[u]->c));\n\t\t\t\telse ++cur[u];\n\t\t}\n\t}\n};\n\nint n, m[MAXN], r[MAXN];\nvector<int> e[MAXN], g[MAXN];\npii ans[MAXN]; bool vis[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n-1; ++i) {\n\t\tint s;\n\t\tcin >> s;\n\t\tfor (int j = 0; j < s; ++j) {\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\te[i].push_back(x);\n\t\t}\n\t}\n\n\tPushRelabel mf(2*n+1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tmf.add_edge(0, i+1, 1);\n\tfor (int i = 0; i < n-1; ++i)\n\t\tfor (int x : e[i])\n\t\t\tmf.add_edge(i+1, x+n, 1);\n\tfor (int i = n; i < 2*n; ++i)\n\t\tmf.add_edge(i, 2*n, 1);\n\tint fl = mf.maxflow(0, 2*n);\n\tif (fl < n-1) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\tauto h = mf.g;\n\tll s = 1LL*n*(n-1)/2;\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 1) {\n\t\t\t\tm[i] = e.dest-n;\n\t\t\t\tr[e.dest-n] = i;\n\t\t\t\ts -= (e.dest - n);\n\t\t\t\t// cout << i << ' ' << m[i]+1 << endl;\n\t\t\t}\n\t//s is unmatched\n\t// cout << s << endl;\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tfor (auto e : h[i])\n\t\t\tif (e.f == 0) {\n\t\t\t\t// cout << e.dest - n << ' ' << m[i] << endl;\n\t\t\t\tg[e.dest - n].push_back(m[i]);\n\t\t\t}\n\t//search from s\n\tqueue<int> q;\n\tq.push(s);\n\tvis[s] = 1;\n\tint ct = 1;\n\twhile (!q.empty()) {\n\t\tint t = q.front();\n\t\tq.pop();\n\t\tfor (int x : g[t]) {\n\t\t\tif (vis[x])\n\t\t\t\tcontinue;\n\t\t\tvis[x] = 1;\n\t\t\tct++;\n\t\t\tq.push(x);\n\t\t\tans[r[x]] = pii(x, t);\n\t\t\t// cout << r[x] << ' ' << x << ' ' << t << endl;\n\t\t}\n\t}\n\tif (ct < n) {\n\t\tcout << \"-1\\n\";\n\t\treturn 0;\n\t}\n\n\tfor (int i = 1; i <= n-1; ++i)\n\t\tcout << ans[i].A+1 << ' ' << ans[i].B+1 << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define N 210000\n\nint n;\nvector <int> S[N];\nint fa[N], tx[N], u[N], v[N];\n\nint gf(int k) {\n\tif (fa[k] != k)\n\t\tfa[k] = gf(fa[k]);\n\treturn fa[k];\n}\n\nvoid doit() {\n\tfor (int i = 1; i < n; i++)\n\t\ttx[i] = i;\n\trandom_shuffle(tx, tx + n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfa[i] = i;\n\tfor (int i = 1; i < n; i++) {\n\t\tbool ok = false;\n\t\tfor (int j = 1; j < (int) S[tx[i]].size(); j++)\n\t\t\tif (gf(S[tx[i]][0]) != gf(S[tx[i]][j]))\n\t\t\t\tok = true;\n\t\tif (!ok)\n\t\t\treturn ;\n\t\twhile (true) {\n\t\t\tint x = S[tx[i]][rand() % S[tx[i]].size()];\n\t\t\tint y = S[tx[i]][rand() % S[tx[i]].size()];\n\t\t\tif (gf(x) != gf(y)) {\n\t\t\t\tu[tx[i]] = x;\n\t\t\t\tv[tx[i]] = y;\n\t\t\t\tfa[gf(x)] = gf(y);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", u[i], v[i]);\n\texit(0);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++) {\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\twhile (k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tS[i].push_back(v);\n\t\t}\n\t}\n\tfor (int i = 1; i <= 100; i++) {\n\t\tdoit();\n\t}\n\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nvoid init(){\n\tqueue<int> Q;\n\t++u[d[t]=1];Q.push(t);\n\twhile(!Q.empty()){\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=fr[x];i;i=nex[i])if(wi[i]&&!d[vi[i]]){\n\t\t\t++u[d[vi[i]]=d[x]+1];Q.push(vi[i]);\n\t\t}\n\t}\n}\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]]==0)d[s]=t+3;else ++u[++d[x]];\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;init();\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\treturn 0;\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#define N 500001\nusing namespace std;\nint n,du[N];\nvector<int>point[N];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint p;\n\t\tscanf(\"%d\",&p);\n\t\tpoint[i].resize(p+1);\n\t\tpoint[i][0]=p;\n\t\tfor (int j=1;j<=p;j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tpoint[i][j]=x;\n\t\t\tdu[x]++;\n\t\t}\n\t}\n\tfor (int i=1;i<=n-1;i++)\n\t{\n\t\tint times=0;\n\t\tfor (int j=1;j<=point[i][0];j++)\n\t\t{\n\t\t\tif (du[point[i][j]]==1) times++;\n\t\t}\n\t\tif (times>1)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct hopcroft{\n\tvector<int> dist, pair_l, pair_r;\n\tvector<bool> seen;\n\tvector<vector<int>> to;\n\tint n1, n2;\n\thopcroft(int n1, int n2) : n1(n1), n2(n2){\n\t\tto.resize(n1);\n\t\tpair_l.assign(n1, -1);\n\t\tpair_r.assign(n2, -1);\n\t\tdist.resize(n1);\n\t\tseen.resize(n1);\n\t}\n\tvoid add_edge(int u, int v){\n\t\tto[u].push_back(v);\n\t}\n\tbool bfs(){\n\t\tfill(dist.begin(), dist.end(), -1);\n\t\tqueue<int> q;\n\t\tfor (int i = 0; i < n1; i++){\n\t\t\tif (pair_l[i] == -1){\n\t\t\t\tdist[i] = 0;\n\t\t\t\tq.push(i);\n\t\t\t}\n\t\t}\n\t\tbool reach_minus = false;\n\t\twhile (!q.empty()){\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int adj : to[u]){\n\t\t\t\tint radj = pair_r[adj];\n\t\t\t\tif (radj == -1){\n\t\t\t\t\treach_minus = true;\n\t\t\t\t} else if (dist[radj] == -1){\n\t\t\t\t\tdist[radj] = dist[u] + 1;\n\t\t\t\t\tq.push(radj);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn reach_minus;\n\t}\n\tbool dfs(int u){\n\t\tseen[u] = true;\n\t\tfor (int adj : to[u]){\n\t\t\tint radj = pair_r[adj];\n\t\t\tif (radj == -1 || (!seen[radj] && dist[radj] == dist[u] + 1 && dfs(radj))){\n\t\t\t\tpair_l[u] = adj;\n\t\t\t\tpair_r[adj] = u;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint max_matching(){\n\t\tint res = 0;\n\t\twhile (bfs()){\n\t\t\tfill(seen.begin(), seen.end(), false);\n\t\t\tfor (int i = 0; i < n1; i++)\n\t\t\t\tif (pair_l[i] == -1 && dfs(i))\n\t\t\t\t\tres++;\n\t\t}\n\t\treturn res;\n\t}\n};\nconst int maxn = 100100;\nint seen[maxn], q[maxn];\nint main(){\n\tint n; scanf(\"%d\", &n);\n\thopcroft hop(n, n - 1);\n\tvector<int> pu(n), pv(n);\n\tfor(int i = 0; i < n - 1; i++){\n\t\tint x; scanf(\"%d\", &x);\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tint y; scanf(\"%d\", &y); y--;\n\t\t\thop.add_edge(y, i);\n\t\t}\n\t}\n\tauto bad = [](){\n\t\tprintf(\"-1\\n\");\n\t\texit(0);\n\t};\n\tint mx = hop.max_matching();\n\tif(mx != n - 1) bad();\n\tint st = -1, tp = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(hop.pair_l[i] == -1) st = i;\n\t\tseen[i] = -2;\n\t}\n\tif(st == -1) bad();\n\tq[tp++] = st; seen[st] = -1;\n\tfor(int tu = 0; tu < tp; tu++){\n\t\tint u = q[tu];;\n\t\tfor(int v :hop.to[u]){\n\t\t\tint nv = hop.pair_r[v];\n\t\t\tif(nv != -1 && seen[nv] == -2){\n\t\t\t\tpu[v] = nv;\n\t\t\t\tpv[v] = u;\n\t\t\t\tseen[nv] = u;\n\t\t\t\tq[tp++] = nv;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) if(seen[i] == -2) bad();\n\tfor(int i = 0; i < n - 1; i++) \n\t\tprintf(\"%d %d\\n\", pu[i] + 1, pv[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nconst int N=210000,V=301000,E=2010000;\nint s,t,vtot,n,vis[N],pl[N],pr[N];\nvector<PII> ed[N];\nvector<pair<int,PII>> ans;\nVI eg[N];\nstruct edge{int v,ne;ll f;}e[E*2];int g[V],et;\nvoid ae(int u,int v,ll f){\n\te[et]={v,g[u],f};g[u]=et++;\n\te[et]={u,g[v],0};g[v]=et++;\n}\nint d[V],cu[V];\nbool lb(){\n\trep(i,0,vtot)d[i]=0,cu[i]=g[i];\n\tstatic int qu[V];\n\tint p=0,q=0;\n\tqu[q++]=s,d[s]=1;\n\twhile(p!=q){\n\t\tint u=qu[p++];\n\t\tfor (int i=g[u];~i;i=e[i].ne)if(e[i].f && !d[e[i].v]){\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tif(e[i].v==t)return 1;\n\t\t\tqu[q++]=e[i].v;\n\t\t}\n\t}return 0;\n}\nll aug(int u,ll m){\n\tif(u==t)return m;\n\tll su=0,f;\n\tfor (int i=cu[u];~i;cu[u]=i=e[i].ne)if(e[i].f && d[e[i].v]==d[u]+1){\n\t\tf=aug(e[i].v,min(m,e[i].f));\n\t\te[i].f-=f; e[i^1].f+=f;\n\t\tm-=f; su+=f;\n\t\tif(!m)break;\n\t}\n\tif(!su)d[u]=-1;\n\treturn su;\n}\nll dinic(){\n\tll su=0;\n\twhile(lb())su+=aug(s,1<<30);\n\treturn su;\n}\nvoid init(){\n\trep(i,0,vtot)g[i]=-1;\n\tet=0;\n}\n\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (auto v:eg[u]) if (v!=pr[u]&&!vis[pl[v]]) {\n\t\tans.pb(mp(v,mp(u,pl[v])));\n\t\tdfs(pl[v]);\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\ts=2*n-1, t=2*n;\n\tvtot=2*n+1;\n\tinit();\n\trep(i,0,n-1) {\n\t\tae(n+i,t,1);\n\t\tint t,x;\n\t\tscanf(\"%d\",&t);\n\t\trep(j,0,t) {\n\t\t\tscanf(\"%d\",&x);\n\t\t\t--x;\n\t\t\ted[i].pb(mp(et,x));\n\t\t\teg[x].pb(i);\n\t\t\tae(x,n+i,1);\n\t\t}\n\t}\n\trep(i,0,n) ae(s,i,1);\n\tint w=dinic();\n\tif (w!=n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,0,n) pr[i]=-1;\n\trep(i,0,n-1) {\n\t\tfor (auto p:ed[i]) {\n\t\t\tif (e[p.fi].f==0) {\n\t\t\t\tpl[i]=p.se;\n\t\t\t\tpr[p.se]=i;\n\t\t\t}\n\t\t}\n\t}\n\tint rt=-1;\n\trep(i,0,n) if (pr[i]==-1) {\n\t\trt=i;\n\t}\n\tdfs(rt);\n\tif (SZ(ans)!=n-1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tsort(all(ans));\n\tfor (auto p:ans) {\n\t\tprintf(\"%d %d\\n\",p.se.fi+1,p.se.se+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nint n;\nstruct data{\n    int to,nxt,c;\n}mp[1000100];\nint head[500500],cnt=1;\nint cur[500500];\nvoid link(int x,int y,int c)\n{\n    mp[++cnt].to=y;\n    mp[cnt].nxt=head[x];\n    mp[cnt].c=c;\n    head[x]=cnt;\n}\nvoid add(int x,int y,int c){link(x,y,c);link(y,x,0);}\nint s,t;\nint dis[500500];\nqueue<int>q;\nbool BFS()\n{\n    for(int i=0;i<=t;++i)dis[i]=0;\n    dis[s]=1;q.push(s);\n    int u,v;\n    while(!q.empty())\n    {\n        u=q.front();q.pop();\n        for(int i=head[u];i;i=mp[i].nxt)\n            if(mp[i].c&&!dis[mp[i].to])\n            {\n                v=mp[i].to;\n                q.push(v);\n                dis[v]=dis[u]+1;\n            }\n    }\n    return dis[t];\n}\nint dfs(int x,int f)\n{\n    if(x==t)return f;\n    int rf=0,fl;\n    for(int& i=cur[x];i;i=mp[i].nxt)\n        if(mp[i].c&&dis[mp[i].to]==dis[x]+1)\n        {\n            fl=dfs(mp[i].to,min(mp[i].c,f));\n            if(fl)\n            {\n                f-=fl;\n                rf+=fl;\n                mp[i].c-=fl;\n                mp[i^1].c+=fl;\n                if(!f)break;\n            }\n        }\n    return rf;\n}\nint Dinic()\n{\n    int maxflow=0,flow;\n    while(BFS())\n    {\n        for(int i=1;i<=t;++i)cur[i]=head[i];\n        while(flow=dfs(s,inf))maxflow+=flow;\n    }\n    return maxflow;\n}\n\nvector<int>bel[100100];\nint par[100100];\nbool book[100100];\nint ed[100100][2],ted;\nvoid solve()\n{\n    int x,v;\n    for(x=2;x<=n;++x)\n    {\n        for(int i=head[x];i;i=mp[i].nxt)\n            if(mp[i].to>n&&mp[i].to<n*2&&!mp[i].c)\n                par[mp[i].to-n]=x;\n    }\n    q.push(1);\n    int siz;\n    while(!q.empty())\n    {\n        x=q.front();q.pop();\n        siz=bel[x].size();\n        for(int i=0;i<siz;++i)\n            if(!book[par[bel[x][i]]])\n            {\n                v=par[bel[x][i]];\n                book[v]=1;\n                q.push(v);\n                ed[++ted][0]=x;\n                ed[ted][1]=v;\n            }\n    }\n    if(ted!=n-1)puts(\"-1\"),exit(0);\n    for(int i=1;i<n;++i)printf(\"%d %d\\n\",ed[i][0],ed[i][1]);\n}\nint main()\n{\n    scanf(\"%d\",&n);\n    s=n*2;t=s+1;\n    int siz,xx;\n    for(int i=1;i<n;++i)\n    {\n        add(i+n,t,1);\n        scanf(\"%d\",&siz);\n        for(int j=1;j<=siz;++j)\n        {\n            scanf(\"%d\",&xx);\n            bel[xx].push_back(i);\n            if(xx!=1) add(xx,i+n,1);\n        }\n    }\n    for(int i=1;i<=n;++i)add(s,i,1);\n    int flow=Dinic();\n    if(flow!=n-1)\n    {\n        puts(\"-1\");\n        return 0;\n    }\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst int maxn = 200111;\nconst int maxm = 400111*2;\nint n;\nint head[maxn], nxt[maxm], to[maxm], cap[maxm], tot=1;\nvoid add_edge(int x, int y, int c)\n{\n\tnxt[++tot] = head[x];\n\thead[x] = tot;\n\tto[tot] = y;\n\tcap[tot] = c;\n\tswap(x, y);\n\tnxt[++tot] = head[x];\n\thead[x] = tot;\n\tto[tot] = y;\n\tcap[tot] = 0;\n}\nint q[maxn], qn, dis[maxn];\nvoid bfs(int S, int N)\n{\n\tfor (int i=0; i<=N; i++) dis[i] = -1;\n\tqn = 0;\n\tq[qn++] = S;\n\tdis[S] = 0;\n\tfor (int i=0; i<qn; i++)\n\t{\n\t\tint x = q[i];\n\t\tfor (int j=head[x]; j; j=nxt[j])\n\t\t{\n\t\t\tint u = to[j];\n\t\t\tif (cap[j]&&dis[u]==-1)\n\t\t\t{\n\t\t\t\tdis[u] = dis[x]+1;\n\t\t\t\tq[qn++] = u;\n\t\t\t}\n\t\t}\n\t}\n}\nint it[maxn];\nint dfs(int x, int T, int f)\n{\n\tif (x==T) return f;\n\tint of = f;\n\tfor (int &i = it[x]; i; i=nxt[i])\n\t{\n\t\tint u = to[i];\n\t\tif (cap[i]&&dis[u]==dis[x]+1)\n\t\t{\n\t\t\tint d = dfs(u, T, min(f, cap[i]));\n\t\t\tif (d>0)\n\t\t\t{\n\t\t\t\tf -= d;\n\t\t\t\tcap[i] -= d;\n\t\t\t\tcap[i^1] += d;\n\t\t\t\tif (!f) return of;\n\t\t\t}\n\t\t}\n\t}\n\treturn of-f;\n}\nint max_flow(int S, int T, int N)\n{\n\tint flow = 0;\n\twhile (true)\n\t{\n\t\tbfs(S, N);\n\t\tif (dis[T]==-1) return flow;\n\t\tfor (int i=0; i<=N; i++) it[i] = head[i];\n\t\tint f;\n\t\twhile (f = dfs(S, T, 1e9)) flow += f;\n\t}\n}\nint mt[maxn];\nvector<int> v[maxn];\nint ans[maxn];\nint main()\n{\n\tgeti(n);\n\tint S = n+n, T = n+n+1;\n\tfor (int i=2; i<=n; i++) add_edge(S, i, 1);\n\tfor (int i=1; i<=n-1; i++)\n\t{\n\t\tadd_edge(i+n, T, 1);\n\t\tint k;\n\t\tgeti(k);\n\t\tfor (int j=1; j<=k; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tgeti(x);\n\t\t\tadd_edge(x, i+n, 1);\n\t\t\tv[x].PB(i);\n\t\t}\n\t}\n\tint f = max_flow(S, T, T);\n\tif (f!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t}\n\telse\n\t{\n\t\tfor (int i=2; i<=n; i++)\n\t\t{\n\t\t\tfor (int j=head[i]; j; j=nxt[j])\n\t\t\t{\n\t\t\t\tif (!cap[j]&&to[j]>n&&to[j]<n+n)\n\t\t\t\t{\n\t\t\t\t\tmt[to[j]-n] = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tqn = 0; q[qn++] = 1;\n\t\tfor (int i=0; i<qn; i++)\n\t\t{\n\t\t\tint x = q[i];\n\t\t\tfor (auto u: v[x])\n\t\t\t{\n\t\t\t\tif (!ans[u])\n\t\t\t\t{\n\t\t\t\t\tans[u] = x;\n\t\t\t\t\tq[qn++] = mt[u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (qn!=n)\n\t\t{\n\t\t\tputs(\"-1\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor (int i=1; i<=n-1; i++) putsii(ans[i], mt[i]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nconst int N=100005;\n\nint n,F[N],vis[N];\nvector<int> go[N];\n\nnamespace flow {\n\tconst int V = 100005, E = 1000004;\n\tint S, T, tot = 1, fst[V], nxt[E], to[E], flow[E], lvl[V];\n\t\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; flow[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; flow[tot] = 0;\n\t}\n\t\n\tint bfs() {\n\t\tqueue<int> q;\n\t\tfor(int i = 0; i <= T; i ++)\n\t\t\tlvl[i] = 0;\n\t\tq.push(S); lvl[S] = 1;\n\t\tint u, v;\n\t\twhile (!q.empty()) {\n\t\t\tu = q.front(); q.pop();\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (flow[i] && !lvl[v = to[i]]) {\n\t\t\t\t\tlvl[v] = lvl[u] + 1;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t}\n\t\treturn lvl[T];\n\t}\n\t\n\tint dinic(int u, int f) {\n\t\tif (u == T)\n\t\t\treturn f;\n\t\tint v, k = f;\n\t\tfor (int i = fst[u]; i && k; i = nxt[i])\n\t\t\tif (flow[i] && lvl[v = to[i]] == lvl[u] + 1) {\n\t\t\t\tint t = dinic(v, min(k, flow[i]));\n\t\t\t\tif (!t)\n\t\t\t\t\tlvl[v] = 0;\n\t\t\t\telse\n\t\t\t\t\tk -= t, flow[i] -= t, flow[i ^ 1] += t;\n\t\t\t}\n\t\treturn f - k;\n\t}\n\t\n\tint mf() {\n\t\tint res = 0;\n\t\twhile(bfs()) res += dinic(S, 2e9);\n\t\treturn res;\n\t}\n\t\n\tvoid getmatch() {\n\t\tfor(int s = 1; s < n; ++s)\n\t\t\tfor(int i = fst[s]; i; i = nxt[i])\n\t\t\t\tif(to[i] != S && !flow[i]) {\n\t\t\t\t\tF[s] = to[i] - n; break;\n\t\t\t\t}\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tflow::S=2*n+1;\n\tflow::T=2*n+2;\n\tfor(int i=1,d,x; i<n; i++)\n\t{\n\t\tflow::addedge(flow::S,i,1);\n\t\tscanf(\"%d\",&d);\n\t\tfor(int j=1; j<=d; ++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tgo[x].push_back(i);\n\t\t\tif(x!=1)\n\t\t\t\tflow::addedge(i,n+x,1);\n\t\t}\n\t}\n\tfor(int i=2; i<=n; i++)\n\t\tflow::addedge(n+i,flow::T,1);\n\tint f=flow::mf();\n\tif(f<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tflow::getmatch();\n\tvector<pair<int,int>> out;\n\tout.resize(n);\n\tqueue<int> q;\n\tq.push(1);\n\tvis[1]=true;\n\twhile(!q.empty()) {\n\t\tint u=q.front(); q.pop();\n\t\tfor(auto &v:go[u]) if(!vis[F[v]]) {\n\t\t\tvis[F[v]]=true;\n\t\t\tout[v]=make_pair(u,F[v]);\n\t\t\tq.push(F[v]);\n\t\t}\n\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tif(!p->first){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\tfor(auto p=out.begin()+1; p!=out.end(); ++p)\n\t\tprintf(\"%d %d\\n\",p->first,p->second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdlib>\n#define LL long long\n#define LD long double\nusing namespace std;\nconst int NN=100000 +117;\nconst int MM=1000000 +117;\nint read(){\n\tint fl=1,x;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif(c=='-'){fl=-1;c=getchar();}\n\tfor(x=0;c>='0'&&c<='9';c=getchar())\n\t\tx=(x<<3)+(x<<1)+c-'0';\n\treturn x*fl;\n}\nvoid open(){\n\tfreopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n}\nvoid close(){\n\tfclose(stdin);\n\tfclose(stdout);\n}\n\n\nint m,n;\nstruct edge{\n\tint to,rem,xt;\n}e[MM];\nint ecnt=1;\nint p[2*NN]={};\nvoid ADD(int x,int y,int rem){\n\te[++ecnt].to=y;\n\te[ecnt].rem=rem;\n\te[ecnt].xt=p[x];\n\tp[x]=ecnt;\n}\nvoid add(int x,int y,int rem){\n\tADD(x,y,rem);\n\tADD(y,x,0);\n}\nint st,fin;\nint g[2*NN]={};\nint ht[2*NN]={};\nint q[2*NN]={};\nbool bfs(int x){\n\tint std=ht[fin]+10;\n\tht[st]=std;\n\tint hd=0,tl=0;\n\tq[tl++]=st;\n\twhile(hd!=tl){\n\t\tint x=q[hd++];\n\t\tif(x==fin)break;\n\t\tfor(int pos=p[x];pos;pos=e[pos].xt){\n\t\t\tint cur=e[pos].to;\n\t\t\tif(e[pos].rem&&ht[cur]<std){\n\t\t\t\tht[cur]=ht[x]+1;\n\t\t\t\tq[tl++]=cur;\n\t\t\t}\n\t\t}\n\t}\n\treturn ht[fin]>=std;\n}\nint dfs(int x,int rem){\n\tif(x==fin)return rem;\n\tint res=0;\n\tfor(int &pos=g[x];pos;pos=e[pos].xt){\n\t\tint cur=e[pos].to;\n\t\tif(e[pos].rem&&ht[cur]==ht[x]+1){\n\t\t\tint tp=dfs(cur,min(rem,e[pos].rem));\n\t\t\tif(tp){\n\t\t\t\te[pos].rem-=tp;\n\t\t\t\te[pos^1].rem+=tp;\n\t\t\t\trem-=tp;\n\t\t\t\tres+=tp;\n\t\t\t}\n\t\t\tif(!rem)break;\n\t\t}\n\t}\n\treturn res;\n}\nint getf(){\n\tint res=0;\n\twhile(bfs(st)){\n\t\tfor(int i=1;i<=fin;++i)g[i]=p[i];\n\t\tres+=dfs(st,1e9);\n\t}\n\treturn res;\n}\nint match[NN]={};\nvector<int> t[NN]={};\nint ans[NN][2]={};\nint anscnt=0;\nbool vis[NN]={};\nvoid getres(int x){\n\tfor(int i=0;i<t[x].size();++i){\n\t\tint cur=t[x][i];\n\t\tif(!vis[cur]){\n\t\t\t++anscnt;\n\t\t\tvis[cur]=1;\n\t\t\tans[cur][0]=x;\n\t\t\tans[cur][1]=match[cur];\n\t\t\tgetres(match[cur]);\n\t\t}\n\t}\n}\nint main(){\n\t//open();\n\tn=read();\n\tst=2*n;\n\tfin=st+1;\n\tfor(int i=1;i<=n;++i)add(st,i,1);\n\tfor(int i=1;i<n;++i){\n\t\tadd(n+i,fin,1);\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;++j){\n\t\t\tint x=read();\n\t\t\tt[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\tint k=getf();\n\tif(k!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tint rt=0;\n\tfor(int i=1;i<=n;++i){\n\t\tbool fl=1;\n\t\tfor(int pos=p[i];pos;pos=e[pos].xt){\n\t\t\tint cur=e[pos].to;\n\t\t\tif(cur>n&&cur<2*n&&!e[pos].rem){\n\t\t\t\tmatch[cur-n]=i;\n\t\t\t\tfl=0;\n\t\t\t}\n\t\t}\n\t\tif(fl)rt=i;\n\t}\n\tgetres(rt);\n\tif(anscnt!=n-1){\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n-1;++i){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\tclose();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline int add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\treturn 0;\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int INF = 0x3f3f3f3f;\n\nint n, m;\nvector<int> hv[200005];\nstruct edge\n{\n\tint to, cap, rev;\n}E[800005];\nvector<int> G[200005];\n\nvoid add_edge(int u, int v, int c)\n{\n\tE[m].to = v;\n\tE[m].cap = c;\n\tE[m].rev = m ^ 1;\n\tG[u].push_back(m ++);\n\tE[m].to = u;\n\tE[m].cap = 0;\n\tE[m].rev = m ^ 1;\n\tG[v].push_back(m ++);\n}\n\nint dis[200005], cur[200005];\nbool bfs()\n{\n\trep1(i, 2 * n) dis[i] = -1;\n\tqueue<int> que;\n\tque.push(0);\n\tdis[0] = 0;\n\twhile(!que.empty()) {\n\t\tint v = que.front();\n\t\tque.pop();\n\t\trep(i, G[v].size()) {\n\t\t\tint ce = G[v][i];\n\t\t\tif(E[ce].cap > 0 && dis[E[ce].to] == -1) {\n\t\t\t\tque.push(E[ce].to);\n\t\t\t\tdis[E[ce].to] = dis[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tif(dis[2 * n] == -1) return false;\n\trep(i, 2 * n + 1) cur[i] = 0;\n\treturn true;\n}\n\nint dfs(int v, int maxf)\n{\n\tif(v == 2 * n) return maxf;\n\tif(maxf == 0) return 0;\n\tint ret = 0;\n\tfor(; cur[v] < G[v].size(); cur[v] ++) {\n\t\tint ce = G[v][cur[v]];\n\t\tif(dis[E[ce].to] == dis[v] + 1 && E[ce].cap > 0) {\n\t\t\tint cf = dfs(E[ce].to, min(maxf - ret, E[ce].cap));\n\t\t\tE[ce].cap -= cf;\n\t\t\tE[E[ce].rev].cap += cf;\n\t\t\tret += cf;\n\t\t\tif(ret == maxf) break;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint lp[200005], par[200005];\n\nint dinic()\n{\n\tint ret = 0;\n\twhile(bfs()) ret += dfs(0, INF);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\trep1(i, n - 1) {\n\t\tint cs;\n\t\tscanf(\"%d\", &cs);\n\t\thv[i].resize(cs);\n\t\trep(j, cs) {\n\t\t\tscanf(\"%d\", &hv[i][j]);\n\t\t\tadd_edge(hv[i][j], i + n, 1);\n\t\t}\n\t\tadd_edge(i + n, n * 2, 1);\n\t}\n\trep1(i, n) add_edge(0, i, 1);\n\tif(dinic() != n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\trep1(i, n) if(dis[i] == -1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\t\n\trep1(i, 2 * n - 1) rep(j, G[i].size()) {\n\t\tint ce = G[i][j];\n\t\tif(E[ce].cap == 0 && dis[E[ce].to] == dis[i] - 1) {\n\t\t\tpar[i] = E[ce].to;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\trep1(i, n) if(par[i] != 0) lp[par[i] - n] = i;\n\trep1(i, n - 1) printf(\"%d %d\\n\", par[i + n], lp[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005 , S = 0 , T = 200000;\nstruct node{int to,next,val;}e[N<<4];\nint head[N],cnt,dep[N],q[N],c[N],n;\nvoid add(int x,int y,int z){e[cnt]=(node){y,head[x],z};head[x]=cnt++;}\nvoid insert(int x,int y,int z){add(x,y,z),add(y,x,0);}\nint bfs()\n{\n\tint l=0,r=0;q[r++] = S;memset(dep,-1,sizeof(dep));dep[S] = 1;\n\twhile(l<r)\n\t{\n\t\tint x = q[l++];\n\t\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t\t{\n\t\t\tint to1=e[i].to;\n\t\t\tif(dep[to1]==-1&&e[i].val)dep[to1] = dep[x]+1 , q[r++] = to1;\n\t\t}\n\t}return dep[T] != -1;\n}\nint dfs(int x,int maxf)\n{\n\tif(x==T)return maxf;int tflow = maxf , nowf;\n\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t{\n\t\tint to1=e[i].to;\n\t\tif(dep[to1]==dep[x]+1&&e[i].val)\n\t\t{\n\t\t\tnowf = dfs(to1 , min(tflow , e[i].val) );\n\t\t\tif(nowf && x>=1 && x<=n-1 && to1) c[x]=to1-n+2;\n\t\t\te[i].val-=nowf , tflow -= nowf , e[i^1].val += nowf;\n\t\t\tif(!tflow)break;\n\t\t}\n\t}return maxf-tflow;\n}\nvector<int >v[N];\nint Dinic()\n{\n\tint sum = 0;\n\twhile(bfs())sum += dfs(S,1<<30);\n\treturn sum;\n}\nint vis[N];pair<int ,int > ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);memset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint siz; scanf(\"%d\",&siz); insert(S,i,1); insert(n+i-1,T,1);\n\t\tfor(int j=1,x;j<=siz;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x),v[x].push_back(i);\n\t\t\tif(x!=1)insert(i,n+x-2,1);\n\t\t}\n\t}\n\t// puts(\"B\");\n\tif(Dinic()==n-1)\n\t{\n\t\t// puts(\"a\");\n\t\tint l = 0 , r = 0;\n\t\tfor(int i=0;i<v[1].size();i++)\n\t\t\tq[r++] = v[1][i] , vis[v[1][i]] = 1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint x = q[l++]; ans[x] = make_pair(vis[x] , c[x]); x = c[x];\n\t\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\t\tif(!vis[v[x][i]]) q[r++] = v[x][i] , vis[v[x][i]] = x;\n\t\t}\n\t\tif(r==n-1)for(int i=1;i<n;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\telse puts(\"-1\");\n\t}else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 400010\n#define M 1000010\n#define inf 2147483647\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\nint tot=1;\nint fir[N],nex[M],got[M],tak[M];\ninline void AddEdge(int x,int y,int z) { \n    nex[++tot]=fir[x],fir[x]=tot,got[tot]=y,tak[tot]=z; \n}\nint dep[N],que[N];\ninline int bfs(int s,int t) {\n\tmemset(dep,0,sizeof(dep));\n\tint l=1,r=1;\n\tdep[s]=1,que[1]=s;\n\twhile (l<=r) {\n\t\tint x=que[l++];\n\t\tfor (int i=fir[x];i;i=nex[i]) {\n\t\t\tint y=got[i];\n\t\t\tif (dep[y] || !tak[i]) continue;\n\t\t\tdep[y]=dep[x]+1,que[++r]=y;\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int x,int t,int flow) {\n\tint rest=flow;\n\tif (x==t) return flow;\n\tfor (int i=fir[x];i && rest;i=nex[i]) {\n\t\tint y=got[i];\n\t\tif (!tak[i] || dep[y]!=dep[x]+1) continue;\n\t\tint k=dfs(y,t,min(rest,tak[i]));\n\t\tif (!k) dep[y]=0;\n\t\ttak[i]-=k,tak[i^1]+=k,rest-=k;\n\t}\n\treturn flow-rest;\n}\ninline int dinic(int s,int t) {\n    int flow=0;\n    while (bfs(s,t)) flow+=dfs(s,t,inf);\n    return flow;\n}\nvector <int> v[N];\nint mat[N],a[N],b[N];\ninline int solve(int n) {\n    int tot=0;\n    queue<int> q; q.push(n);\n    for (int i=1;i<=n-1;i++)\n        for (int j=fir[i];j;j=nex[j])\n            if (got[j]!=2*n-1 && !tak[j]) mat[i]=got[j]-n+1;\n    // for (int i=1;i<=n;i++) printf(\"%d \",mat[i]); puts(\"\");\n    while (!q.empty()) {\n        int x=q.front(); q.pop();\n        // puts(\"qwq\");\n        for (auto &u:v[x]) if (mat[u]) {\n            ++tot; a[u]=x,b[u]=mat[u]; q.push(mat[u]),mat[u]=0;\n        }\n    }\n    // cout<<tot<<endl;\n    return tot;\n}\nint main() {\n    int n=read(),s=2*n-1,t=s+1;\n    for (int i=1;i<n;i++) {\n        AddEdge(s,i,1),AddEdge(i,s,0);\n        AddEdge(t,i+n-1,0),AddEdge(i+n-1,t,1);\n        int k=read();\n        while (k--) {\n            int x=read(); v[x].push_back(i);\n            if (x==n) continue;\n            AddEdge(i,x+n-1,1),AddEdge(x+n-1,i,0);\n        }\n    }\n    // cout<<dinic(s,t)<<endl;\n    if (dinic(s,t)<n-1 || solve(n)<n-1) return puts(\"-1\"),0;\n    for (int i=1;i<=n-1;i++) printf(\"%d %d\\n\",a[i],b[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n \n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n \ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n \n// ========================================================================= //\n \nint main() {\n    ios::sync_with_stdio(false);\n \n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n \n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n \n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n \n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i))\n                    was = 1;\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n \n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n \n    vector<ipair> es(n - 1);\n    int cnt = 0;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es[s] = {v, nv};\n            ++cnt;\n            dfs(nv);\n        }\n    };\n    dfs(root);\n \n    if (cnt != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << a.X + 1 << \" \" << a.Y + 1 << \"\\n\";\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 200500\nqueue<int> tp;\nint n,m,a,head[N],cnt=1,id[N],fa[N],cur[N],dis[N],is[N],ct1;\nvector<int> st2[N];\nstruct edge{int t,next,v;}ed[N*2];\nvoid adde(int f,int t,int v){ed[++cnt]=(edge){t,head[f],v};head[f]=cnt;ed[++cnt]=(edge){f,head[t],0};head[t]=cnt;}\nbool bfs(int s,int t)\n{\n\tmemset(dis,-1,sizeof(dis));\n\tmemcpy(cur,head,sizeof(cur));\n\tdis[s]=0;\n\tqueue<int> st;st.push(s);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tfor(int i=head[a];i;i=ed[i].next)\n\t\tif(ed[i].v&&dis[ed[i].t]==-1)\n\t\t{\n\t\t\tdis[ed[i].t]=dis[a]+1,st.push(ed[i].t);\n\t\t\tif(ed[i].t==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int u,int t,int f)\n{\n\tif(u==t||!f)return f;\n\tint as=0,tp;\n\tfor(int &i=cur[u];i;i=ed[i].next)\n\tif(ed[i].v&&dis[ed[i].t]==dis[u]+1&&(tp=dfs(ed[i].t,t,min(ed[i].v,f))))\n\t{\n\t\tas+=tp,f-=tp;ed[i].v-=tp;ed[i^1].v+=tp;\n\t\tif(!f)return as;\n\t}\n\treturn as;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++)scanf(\"%d\",&a),st2[a].push_back(i),adde(a,i+n,1);\n\t}\n\tfor(int i=1;i<n;i++)adde(2*n,i+1,1),adde(i+n,2*n+1,1);\n\tint as=0;while(bfs(n*2,n*2+1))\n\tas+=dfs(n*2,n*2+1,n);\n\tif(as<n-1){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tfor(int j=head[i+n];j;j=ed[j].next)if(ed[j].v)id[i]=ed[j].t;\n\tqueue<int> st;\n\tst.push(1);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tct1++;\n\t\tfor(int j=0;j<st2[a].size();j++)if(!fa[id[st2[a][j]]])fa[id[st2[a][j]]]=a,st.push(id[st2[a][j]]);\n\t}\n\tif(ct1<n){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",fa[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>ans[200005];\nint beg = -1;\nbool in[400005];\n\n//O(E sqrt V)\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph, rev;\n  vector< int > dist, match, revmatch;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), rev(m), match(m, -1), revmatch(n,-1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    rev[v].push_back(u);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        revmatch[a] = b;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n  \n  void put_ans() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        ans[match[i]].pb(i);\n      }\n      else{\n      \tbeg = i;\n      }\n    }\n  }\n  \n  void DFS(int cur,bool right){\n      //cout << cur << \" \" << right << endl;\n  \tif(right){\n  \t\t\n  \t\tfor(int i=0;i<rev[cur].size();i++){\n  \t\t\tif(match[cur] == rev[cur][i]) continue;\n  \t\t\tint to = rev[cur][i];\n  \t\t\t//cout << to << endl;\n  \t\t\tif(in[to]) continue;\n  \t\t\tin[to] = 1;\n  \t\t\tans[to].pb(cur);\n  \t\t\t//cout << to << \" \" << cur << endl;\n  \t\t\t//cout << to << endl;\n  \t\t\tDFS(to,false);\n  \t\t}\n  \t}\n  \telse{\n  \t\t\n\t\tfor(int i=0;i<graph[cur].size();i++){\n  \t\t\tif(match[graph[cur][i]] != cur) continue;\n  \t\t\tint to = graph[cur][i];\n  \t\t\tif(in[to+200001]) continue;\n  \t\t\tin[to+200001] = 1;\n  \t\t\tDFS(to,true);\n  \t\t}\n  \t}\n  }\n};\n\nint n;\nvector<int>vec[200005];\n\nint par[200005],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tHopcroftKarp bm(n-1,n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\trep(j,a){\n\t\t\tint x; scanf(\"%d\",&x); x--;\n\t\t\tvec[i].pb(x);\n\t\t\tbm.add_edge(i,x);\n\t\t}\n\t}\n\tint v = bm.bipartite_matching(); \n\tbm.put_ans();\n\tif(beg != -1) bm.DFS(beg,true);\n\tinit();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ans[i].size() != 2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tint x = ans[i][0], y = ans[i][1];\n\t\tif(same(x,y)){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tunite(x,y);\n\t}\n//\tputs(\"YES\");\n\trep(i,n-1) cout << ans[i][0]+1 << \" \" << ans[i][1]+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<set>\n#include<algorithm>\nusing namespace std;\nconst int N=500010;\nint n,m,i,j,k,ans[N][2],d[N],head,tail,cnt,x;\nvector<int> a[N];\nset<int> b[N],c,e[N];\nbool ok[N];\nvoid doit(int x){ans[++cnt][0]=x;ok[x]=true;set<int>::iterator it=b[x].begin();c.erase(x);\n\tfor (int i=0;i<a[*it].size();i++) if (a[*it][i]!=x&&!e[x].count(a[*it][i])){ans[cnt][1]=a[*it][i];break;}int xx=*it;\n\tfor (int i=0;i<a[xx].size();i++){b[a[xx][i]].erase(xx);\n\tif (b[a[xx][i]].size()==1&&!ok[a[xx][i]]) d[++tail]=a[xx][i],\n\tc.erase(a[xx][i]);}e[ans[cnt][0]].insert(ans[cnt][1]);e[ans[cnt][1]].insert(ans[cnt][0]);\n}\nint main(){\n\tscanf(\"%d\",&n);for (i=1;i<=n-1;i++){scanf(\"%d\",&m);for (j=1;j<=m;j++) scanf(\"%d\",&x),a[i].push_back(x),b[x].insert(i);}\n\tfor (i=1;i<=n;i++) c.insert(i);\n\thead=1;tail=0;for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) d[++tail]=i,c.erase(i);\n\t//for (i=1;i<=n;i++) if (b[i].size()==0){printf(\"-1\\n\");return 0;} else if (b[i].size()==1) doit(i);\n\twhile (cnt!=n-1){\n\t\twhile (head<=tail&&cnt!=n-1){\n\t\t\tx=d[head];if (b[x].size()==0){printf(\"-1\\n\");return 0;} else doit(x);head++;\n\t\t}\n\t\tif (cnt!=n-1) doit(*c.begin());\n\t}for (i=1;i<=n-1;i++) printf(\"%d %d\\n\",ans[i][0],ans[i][1]);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 100000;\n\nnamespace FlowGraph{\n\tconst int MAXV = 2*MAXN;\n\tconst int MAXE = 10*MAXN;\n\tconst int INF = (1 << 30);\n\t\n\tstruct edge{\n\t\tint to, flow, cap;\n\t\tedge *nxt, *rev;\n\t}edges[MAXE + 5], *adj[MAXV + 5], *cur[MAXV + 5], *ecnt = edges;\n\tvoid addedge(int u, int v, int c) {\n\t\tedge *p = (++ecnt), *q = (++ecnt);\n\t\tp->to = v, p->cap = c, p->flow = 0;\n\t\tp->nxt = adj[u], adj[u] = p;\n\t\tq->to = u, q->cap = 0, q->flow = 0;\n\t\tq->nxt = adj[v], adj[v] = q;\n\t\tp->rev = q, q->rev = p;\n\t}\n\tint s, t;\n\tint fa[MAXV + 5], dis[MAXV + 5];\n\tint que[MAXV + 5], hd, tl;\n\tbool relabel() {\n\t\tfor(int i=s;i<=t;i++)\n\t\t\tdis[i] = t + 5, cur[i] = adj[i];\n\t\tdis[que[hd = tl = 1] = t] = 0;\n\t\twhile( hd <= tl ) {\n\t\t\tint x = que[hd++];\n\t\t\tfor(edge *p=adj[x];p;p=p->nxt) {\n\t\t\t\tif( dis[p->to] > dis[x] + 1 && p->rev->cap > p->rev->flow )\n\t\t\t\t\tdis[p->to] = dis[x] + 1, fa[p->to] = x, que[++tl] = p->to;\n\t\t\t}\n\t\t}\n\t\treturn !(dis[s] == t + 5);\n\t}\n\tint aug(int x, int tot) {\n\t\tif( x == t ) return tot;\n\t\tint sum = 0;\n\t\tfor(edge *&p=cur[x];p;p=p->nxt) {\n\t\t\tif( p->cap > p->flow && dis[p->to] + 1 == dis[x] ) {\n\t\t\t\tint del = aug(p->to, min(tot - sum, p->cap - p->flow));\n\t\t\t\tp->flow += del, p->rev->flow -= del, sum += del;\n\t\t\t\tif( sum == tot ) break;\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n\tint max_flow(int _s, int _t) {\n\t\tint flow = 0; s = _s, t = _t;\n\t\twhile( relabel() )\n\t\t\tflow += aug(s, INF);\n\t\treturn flow;\n\t}\n}\n\nint a[MAXN + 5], b[MAXN + 5];\nint main() {\n\tint N; scanf(\"%d\", &N);\n\tfor(int i=1;i<N;i++) {\n\t\tint c; scanf(\"%d\", &c);\n\t\tfor(int j=1;j<=c;j++) {\n\t\t\tint w; scanf(\"%d\", &w);\n\t\t\tFlowGraph::addedge(N + i, w, 1);\n\t\t}\n\t}\n\tint s = 0, t = N + N - 1 + 1;\n\tfor(int i=1;i<N;i++) FlowGraph::addedge(s, N + i, 1);\n\tfor(int i=1;i<=N;i++) FlowGraph::addedge(i, t, 1);\n\tint f = FlowGraph::max_flow(s, t);\n\tif( f == N - 1 ) {\n\t\tFlowGraph::relabel();\n\t\tfor(int i=1;i<t;i++)\n\t\t\tif( FlowGraph::dis[i] == t + 5 ) {\n\t\t\t\tputs(\"-1\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\tfor(int i=1;i<N;i++) a[i] = FlowGraph::fa[N + i];\n\t\tfor(int i=1;i<=N;i++) b[FlowGraph::fa[i] - N] = i;\n\t\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\", a[i], b[i]);\n\t}\n\telse puts(\"-1\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n     \ntemplate <typename Weight, int MAX_N, Weight INF> class MaxFlow{\npublic:\n\tstruct E{\n\t\tint to, rev;\n\t\tWeight lim;\n\t\tE(int x, Weight y, int z){\n\t\t\tto = x;\n\t\t\tlim = y;\n\t\t\trev = z;\n\t\t}\n\t};\n     \n\tvector<E> edge[MAX_N];\n\tint lev[MAX_N];\n\tint iter[MAX_N];\n     \n     \n\tWeight dfs(int s, int g, Weight f){\n\t\tif(s == g)return f;\n\t\tfor(int &i = iter[s];i < edge[s].size();i++){\n\t\t\tE &e = edge[s][i];\n\t\t\tif(lev[e.to] <= lev[s] || e.lim <= 0)continue;\n\t\t\tWeight tmp = dfs(e.to, g, min(f, e.lim));\n\t\t\tif(tmp<1e-9)continue;\n\t\t\te.lim -= tmp;\n\t\t\tedge[e.to][e.rev].lim += tmp;\n\t\t\treturn tmp;\n\t\t}\n\t\treturn 0;\n\t}\n     \n\tvoid bfs(int x){\n\t\tqueue<int> q;\n\t\tq.push(x);\n\t\tint p = 0;\n\t\twhile(!q.empty()){\n\t\t\tfor(int i = q.size();i--;){\n\t\t\t\tint tmp = q.front();q.pop();\n\t\t\t\tif(lev[tmp] != MAX_N)continue;\n\t\t\t\tlev[tmp] = p;\n\t\t\t\tfor(int j = 0;j < edge[tmp].size();j++){\n\t\t\t\t\tif(edge[tmp][j].lim > 0 && lev[edge[tmp][j].to] == MAX_N)q.push(edge[tmp][j].to);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp++;\n\t\t}\n\t}\n     \n\tvoid make_edge(int a, int b, Weight l){\n\t\tedge[a].push_back(E(b, l, edge[b].size()));\n\t\tedge[b].push_back(E(a, 0, edge[a].size() - 1));\n\t}\n     \n\tWeight max_flow(int s, int g){\n\t\tWeight res = 0;\n\t\tbool fin = false;\n\t\twhile(!fin){\n\t\t\tfill(lev, lev + MAX_N, MAX_N);\n\t\t\tfill(iter, iter + MAX_N, 0);\n\t\t\tbfs(s);\n\t\t\tfin = true;\n\t\t\twhile(true){\n\t\t\t\tWeight p = dfs(s, g, INF);\n\t\t\t\tif(p < 1e-9)break;\n\t\t\t\tfin = false;\n\t\t\t\tres += p;\n\t\t\t}\n\t\t}\t\n\t\treturn res;\n\t}\n};\n     \nMaxFlow<int, 216000, (1<<26)> mf;\nbool come[216000];\nint n,c, u;\nvector<int> ans[216000];\nvoid ng(){\n\tcout << -1 << endl;\n\texit(0);\n}\n\nvoid dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < mf.edge[x].size();i++){\n\t\tif(mf.edge[x][i].lim == 0)continue;\n\t\tint to = mf.edge[x][i].to;\n\t\tif(come[to])continue;\n\t\tdfs(to, x);\n\t\tif(x != 0 && x < n){\n\t\t\tans[x].push_back(to - n);\n\t\t\tans[x].push_back(last - n);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin >> n;\n\tint T = 215000, S = 0;\n\tfor(int i = 1;i <= n;i++)mf.make_edge(S, n + i, 1);\n\tfor(int i = 1;i < n;i++){\n\t\tcin >> c;\n\t\tmf.make_edge(i, T, 1);\n\t\tfor(int j = 0;j < c;j++){\n\t\t\tcin >> u;\n\t\t\tmf.make_edge(n + u, i, 1);\n\t\t}\t\n\t}\n\tif(mf.max_flow(S, T) != n-1)ng();\n\tdfs(S);\n\tfor(int i = 1;i < n;i++)\n\t\tif(ans[i].size() != 2)ng();\n\t\t\n\tfor(int i = 1;i < n;i++)\n\t\tcout << ans[i][0] << \" \" << ans[i][1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nconst int maxn = 1<<10, mod = 1e9 + 7;\nvector<array<int, 2>> ans, rans;\nset<pair<int, int>> q;\nmap<int, vector<int>> occ;\nvector<int> used, curval;\nset<int> lp[1<<17];\nstruct dsu {\n\tint n;\n\tvector<int> r, p;\n\tdsu(int n) : n(n), r(n+1, 1), p(n+1) {iota(all(p), 0);}\n\tint par(int v) {\n\t\treturn v == p[v] ? v : p[v] = par(p[v]);\n\t}\n\tbool unite(int i, int j) {\n\t\tarray<int, 2> orig {i, j};\n\t\ti = par(i), j = par(j);\n\t\tif(i == j) return false;\n\t\tans.pb(orig);\n\t\tif(r[i] < r[j]) swap(i, j);\n\t\tr[i] += r[j];\n\t\tp[j] = i;\n\t\tfor(auto t : occ[orig[1]]) if(!used[t] && lp[t].count(orig[0])) {\n\t\t\tq.erase({curval[t], t});\n\t\t\tcurval[t]--;\n\t\t\tq.insert({curval[t], t});\n\t\t}\n\t\treturn true;\n\t}\n};\nint n;\nvector<pair<vector<int>, int>> a;\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n;\n\tfor(int t, i = 0; i < n-1; i++) {\n\t\tcin >> t;\n\t\tvector<int> x(t);\n\t\tfor(auto &j : x) cin >> j, occ[j].pb(i), lp[i].insert(j);\n\t\ta.pb({x, i});\n\t\tcurval.pb(x.size());\n\t\tq.insert({x.size(), i});\n\t}\n\trans.resize(n-1);\n\tused = vector<int>(n-1);\n\tdsu d(n);\n\twhile(!q.empty()) {\n\t\tauto idx = q.begin()->second;\n\t\tauto i = a[idx].first;\n\t\tused[idx] = 1;\n\t\tq.erase(q.begin());\n\t\tint p = 1;\n\t\twhile(p < i.size() && !d.unite(i[0], i[p])) p++;\n\t\tif(p == i.size()) return cout << -1, 0;\n\t\trans[idx] = ans.back();\n\t}\n\tfor(auto i : rans) cout << i[0] << \" \" << i[1] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=100005;\nint n,bl[Maxn],vis[Maxn];\nvector<int>a[Maxn];\npair<int,int>ans[Maxn];\nnamespace dinic{\n\tconst int Maxn=233,Maxm=666;\n\tint S,T,cnt,h[Maxn],dis[Maxn];\n\tstruct node{\n\t\tint to,next,v,pair;\n\t}e[2*Maxm];\n\tvoid AddEdge(int x,int y,int v,int pair){\n\t\te[cnt]=(node){y,h[x],v,pair};h[x]=cnt;\n\t}\n\tvoid AddEdge(int x,int y,int v){\n\t\tAddEdge(x,y,v,++cnt+1);\n\t\tAddEdge(y,x,0,++cnt-1);\n\t}\n\tbool bfs(){\n\t\tmemset(dis,0x3f,sizeof(dis));\n\t\tdis[S]=0;\n\t\tqueue<int>Q;Q.push(S);\n\t\twhile(Q.size()){\n\t\t\tint x=Q.front();Q.pop();\n\t\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\t\tint y=e[p].to;\n\t\t\t\tif(dis[y]<=dis[x]+1||!e[p].v)continue;\n\t\t\t\tQ.push(y);dis[y]=dis[x]+1;\n\t\t\t}\n\t\t}\n\t\treturn dis[T]!=0x3f3f3f3f;\n\t}\n\tint dfs(int x,int Maxflow){\n\t\tif(x==T)return Maxflow;\n\t\tint flow=0;\n\t\tfor(int p=h[x];p;p=e[p].next){\n\t\t\tint y=e[p].to;\n\t\t\tif(dis[y]!=dis[x]+1)continue;\n\t\t\tint ret=dfs(y,min(e[p].v,Maxflow));\n\t\t\tMaxflow-=ret;flow+=ret;\n\t\t\te[p].v-=ret;e[e[p].pair].v+=ret;\n\t\t}\n\t\treturn flow;\n\t}\n\tint Maxflow(int s,int t){\n\t\tS=s,T=t;\n\t\tint ans=0;\n\t\twhile(bfs())ans+=dfs(S,INT_MAX);\n\t\treturn ans;\n\t}\n\tvoid solve(){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(int p=h[i];p;p=e[p].next)\n\t\t\t\tif(e[p].to>=n&&!e[p].v)\n\t\t\t\t\tbl[i]=e[p].to;\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint S=0,T=2*n;\n\tfor(int i=1;i<n;i++)dinic::AddEdge(S,i,1);\n\tfor(int i=1;i<=n;i++)dinic::AddEdge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint sz;scanf(\"%d\",&sz);\n\t\twhile(sz--){\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\ta[x].push_back(i);\n\t\t\tdinic::AddEdge(i,x+n-1,1);\n\t\t}\n\t}\n\tif(dinic::Maxflow(S,T)!=n-1){\n\t\tcout<<\"-1\\n\";\n\t\treturn 0;\n\t}\n\tdinic::solve();\n\tfor(int i=1;i<n;i++)bl[i]-=n-1;\n\tset<int>o;\n\tqueue<int>Q;\n\tint rt=1,cnt=0;\n\tfor(int i=1;i<n;i++)o.insert(bl[i]);\n\twhile(o.count(rt))rt++;\n\tauto add=[&](int x){\n\t\tfor(int f:a[x])\n\t\t\tif(!vis[f]){\n\t\t\t\tQ.push(f);\n\t\t\t\tvis[f]=x;\n\t\t\t}\n\t};\n\tadd(rt);\n\twhile(Q.size()){\n\t\tint f=Q.front();Q.pop();\n\t\tans[f]=make_pair(bl[f],vis[f]);\n\t\tcnt++;\n\t\tadd(bl[f]);\n\t}\n\tif(cnt==n-1){\n\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<ans[i].first<<\" \"<<ans[i].second<<\"\\n\";\n\t}else{\n\t\tcout<<\"-1\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define pdi pair<db,int>\n#define mp make_pair\n#define pb push_back\n#define enter putchar('\\n')\n#define space putchar(' ')\n#define eps 1e-8\n#define mo 974711\n#define MAXN 200005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;char c = getchar();T f = 1;\n    while(c < '0' || c > '9') {\n    if(c == '-') f = -1;\n    c = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    res = res * 10 + c - '0';\n    c = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    out(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next,cap;\n}E[MAXN * 10];\nint N,head[MAXN * 2],sumE = 1,S,T,tot,lev[MAXN * 2],cur[MAXN * 2],ch[MAXN],fa[MAXN];\nvector<int> v[MAXN];\nbool vis[MAXN];\nvoid add(int u,int v,int c) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    E[sumE].cap = c;\n    head[u] = sumE;\n}\nvoid addtwo(int u,int v,int c) {\n    add(u,v,c);add(v,u,0);\n}\nbool BFS() {\n    static int que[MAXN * 2],ql,qr;\n    que[ql = qr = 1] = S;\n    for(int i = 1 ; i <= T ; ++i) lev[i] = -1,cur[i] = head[i];\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(int i = head[u] ; i ; i = E[i].next) {\n\t    int v = E[i].to;\n\t    if(E[i].cap > 0 && lev[v] == -1) {\n\t\tlev[v] = lev[u] + 1;\n\t\tif(v == T) return true;\n\t\tque[++qr] = v;\n\t    }\n\t}\n    }\n    return false;\n}\nint dfs(int u,int aug) {\n    if(u == T) return aug;\n    int flow = 0;\n    for(int &i = cur[u] ; i ; i = E[i].next) {\n\tint v = E[i].to;\n\tif(E[i].cap > 0 && lev[v] > lev[u]) {\n\t    int t = dfs(v,min(E[i].cap,aug - flow));\n\t    flow += t;E[i].cap -= t;E[i ^ 1].cap += t;\n\t    if(flow == aug) break;\n\t}\n    }\n    if(flow != aug) lev[u] = -1;\n    return flow;\n}\nint Dinic() {\n    int res = 0;\n    while(BFS()) {\n\tres += dfs(1,0x7fffffff);\n    }\n    return res;\n}\nvoid Init() {\n    read(N);\n    S = 1;\n    for(int i = 1 ; i < N ; ++i) {\n\taddtwo(S,i + N,1);\n\tint c,w;\n\tread(c);\n\tfor(int j = 1 ; j <= c ; ++j) {\n\t    read(w);\n\t    if(w != 1) addtwo(i + N,w,1);\n\t    v[w].pb(i);\n\t}\n    }\n    T = 2 * N;\n    for(int i = 2 ; i <= N ; ++i) addtwo(i,T,1);\n}\nvoid construct() {\n    static int que[MAXN],ql,qr;\n    que[ql = qr = 1] = 1;\n    while(ql <= qr) {\n\tint u = que[ql++];\n\tfor(auto t : v[u]) {\n\t    if(!vis[t]) {\n\t\tvis[t] = 1;\n\t\tfa[ch[t]] = u;\n\t\tque[++qr] = ch[t];\n\t    }\n\t}\n    }\n}\nvoid Solve() {\n    if(Dinic() != N - 1) {puts(\"-1\");return;}\n    for(int i = 1 ; i <= N - 1 ; ++i) {\n\tint u = i + N;\n\tfor(int j = head[u] ; j ; j = E[j].next) {\n\t    int v = E[j].to;\n\t    if(E[j].cap == 0) {ch[i] = v;break;}\n\t}\n    }\n    construct();\n    for(int i = 1 ; i < N ; ++i) {\n\tif(!vis[i]) {puts(\"-1\");return;}\n    }\n    for(int i = 1 ; i < N ; ++i) {\n\tout(fa[ch[i]]);space;out(ch[i]);enter;\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Init();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst int N=2000002;\nint n,i,j,k,cnt[N],m,a,x[N],y[N],in[N];\nint h[N],t[N],v[N],vis[N],Mc[N],q[N],s,e;\nvoid add(int a,int b){\n\tt[++k]=h[a];\n\th[a]=k;\n\tv[k]=b;\n}\nvoid init(){\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d\",cnt+i);\n\t\tfor(j=1;j<=cnt[i];j++){\n\t\t\tscanf(\"%d\",&a);\n\t\t\tadd(a,i+n);\n\t\t}\n\t}\n}\nbool dfs(int i){\n\tfor(int j=h[i];j;j=t[j])\n\t\tif(vis[v[j]]!=k){\n\t\t\tvis[v[j]]=k;\n\t\t\tif(!Mc[v[j]]||dfs(Mc[v[j]])){\n\t\t\t\tMc[v[j]]=i;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\nvoid work(){\n\tfor(k=n;k>1;k--)\n\t\tif(!dfs(k)){\n\t\t\tprintf(\"-1\");\n\t\t\treturn;\n\t\t}\n\tq[s=e=0]=1;\n\tin[1]=1;\n\twhile(s<=e){\n\t\ti=q[s++];\n\t\tfor(j=h[i];j;j=t[j]){\n\t\t\ta=Mc[v[j]];\n\t\t\tif(!in[a]){\n\t\t\t\tin[a]=1;\n\t\t\t\tq[++e]=a;\n\t\t\t\tm++;\n\t\t\t\tx[m]=i;y[m]=a;\n\t\t\t}\n\t\t}\n\t}\n\tif(m!=n-1)\n\t\tprintf(\"-1\");\n\telse\n\t\tfor(i=1;i<=m;i++)\n\t\t\tprintf(\"%d %d\\n\",x[i],y[i]);\n}\nint main(){\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAXN=200100,MAXM=1000100,INF=0x3f3f3f3f;\nstruct Edge\n{\n\tint to,val,nxt;\n\tinline Edge() {}\n\tinline Edge(register int to,register int val,register int nxt):to(to),val(val),nxt(nxt) {}\n};\nEdge e[MAXM];\nint head[MAXN],S,T,cnt=-1;\nint d[MAXN],cur[MAXN];\nint vis1[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];\nint N;\nqueue<int> q,q_;\nvector<int> bel[MAXN];\ninline void Addedge(register int x,register int y,register int z)\n{\n\te[++cnt]=Edge(y,z,head[x]),head[x]=cnt;\n\te[++cnt]=Edge(x,0,head[y]),head[y]=cnt;\n\treturn;\n}\ninline bool bfs()\n{\n\twhile(!q.empty()) q.pop();\n\tmemset(d,-1,sizeof(d));\n\td[S]=0,cur[S]=head[S],q.push(S);\n\twhile(!q.empty())\n\t{\n\t\tregister int now=q.front(); q.pop();\n\t\tfor(register int i=head[now];~i;i=e[i].nxt)\n\t\t\tif(e[i].val&&(!(~d[e[i].to])))\n\t\t\t{\n\t\t\t\tregister int to=e[i].to;\n\t\t\t\td[to]=d[now]+1,cur[to]=head[to];\n\t\t\t\tif(to==T) return 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t}\n\treturn 0;\n}\ninline int dfs(register int now,register int num)\n{\n\tif(now==T||!num) return num;\n\tregister int ans=0;\n\tfor(register int &i=cur[now];~i;i=e[i].nxt)\n\t\tif(e[i].val&&d[e[i].to]==d[now]+1)\n\t\t{\n\t\t\tregister int to=e[i].to;\n\t\t\tregister int f=dfs(to,min(num,e[i].val));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\te[i].val-=f,e[i^1].val+=f;\n\t\t\t\tans+=f,num-=f;\n\t\t\t\tif(!num) break;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\ninline int maxflow()\n{\n\tregister int ans=0;\n\twhile(bfs()) ans+=dfs(S,INF);\n\treturn ans;\n}\ninline bool solve(register int n)\n{\n\tfor(register int i=1;i<n;i++)\n\t\tfor(register int j=head[n+i];~j;j=e[j].nxt)\n\t\t\tif(e[j].to&&!e[j].val) id[i]=e[j].to,vis1[e[j].to]=1;\n\tfor(register int i=1;i<=n;i++)\n\t\tif(!vis1[i]) q_.push(i);\n\tregister int cnt_=0;\n\twhile(!q_.empty())\n\t{\n\t\tregister int now=q_.front(); q_.pop();\n\t\tcnt_++;\n\t\tfor(register int i=0;i<(int)bel[now].size();i++)\n\t\t\tif(!vis2[bel[now][i]])\n\t\t\t{\n\t\t\t\tregister int to=bel[now][i];\n\t\t\t\tvis2[to]=1,nxt[to]=now,q_.push(id[to]);\n\t\t\t}\n\t}\n\treturn cnt_==n;\n}\nint main()\n{\n\tios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tmemset(head,-1,sizeof(head));\n\tcin>>N;\n\tS=0,T=N<<1;\n\tfor(register int i=1,x,y;i<N;i++)\n\t{\n\t\tcin>>x;\n\t\tAddedge(S,N+i,1);\n\t\tfor(register int j=1;j<=x;j++) cin>>y,Addedge(N+i,y,1),bel[y].push_back(i);\n\t}\n\tfor(register int i=1;i<=N;i++) Addedge(i,T,1);\n\tif(maxflow()<N-1) return puts(\"-1\"),0;\n\tif(!solve(N)) return puts(\"-1\"),0;\n\tfor(register int i=1;i<N;i++) cout<<id[i]<<\" \"<<nxt[i]<<\"\\n\";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=400010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N*2];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N],ans[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tq.push(1);int tot=0;\n\t\twhile(!q.empty()){\n\t\t\ttot++;\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans[link[v]]=u;\n\t\t\t}\n\t\t}\n\t\tif(tot!=n)puts(\"-1\");else\n\t\t\tref(i,1,n-1)cout<<ans[link[i]]<<\" \"<<link[i]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define rep(i,a) for(int i=lst[a];i;i=nxt[i])\nusing namespace std;\n\nint read() {\n\tchar ch;\n\tfor(ch=getchar();ch<'0'||ch>'9';ch=getchar());\n\tint x=ch-'0';\n\tfor(ch=getchar();ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\nconst int N=2e5+5,M=N<<3;\n\nint t[M],f[M],nxt[M],lst[N],l;\n\nvoid add(int x,int y,int z) {\n\tt[++l]=y;f[l]=z;nxt[l]=lst[x];lst[x]=l;\n\tt[++l]=x;f[l]=0;nxt[l]=lst[y];lst[y]=l;\n}\n\nint n,S,T,q[N],dis[N],p[N],fa[N];\nvector<int> to[N];\n\nbool bfs() {\n\tfo(i,S,T) dis[i]=0;dis[S]=1;\n\tint i=0,j=1;q[1]=S;\n\twhile (i<j) \n\t\trep(k,q[++i]) \n\t\t\tif (f[k]&&!dis[t[k]]) {\n\t\t\t\tdis[t[k]]=dis[q[i]]+1;\n\t\t\t\tq[++j]=t[k];\n\t\t\t}\n\treturn dis[T];\n}\n\nint dinic(int x,int y) {\n\tif (x==T) return y;\n\tint now=0;\n\trep(i,x)\n\t\tif (f[i]&&dis[t[i]]==dis[x]+1) {\n\t\t\tint k=dinic(t[i],min(y,f[i]));\n\t\t\tf[i]-=k;f[i^1]+=k;\n\t\t\ty-=k;now+=k;\n\t\t\tif (!y) break;\n\t\t}\n\tif (!now) dis[x]=-1;\n\treturn now;\n}\n\nbool vis[N];\n\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(int y:to[x])\n\t\tif (!vis[p[y]]) {\n\t\t\tfa[y]=x;\n\t\t\tdfs(p[y]);\n\t\t}\n}\n\nint main() {\n\tn=read();S=0;T=n<<1;l=1;\n\tfo(i,1,n-1) {\n\t\tadd(S,i,1);\n\t\tint c=read();\n\t\tfo(j,1,c) {\n\t\t\tint x=read();\n\t\t\tif (x>1) add(i,x+n-1,1);\n\t\t\tto[x].push_back(i);\n\t\t}\n\t}\n\tfo(i,1,n) add(i+n-1,T,1);\n\tint ret=0;\n\twhile (bfs()) ret+=dinic(S,1);\n\tif (ret<n-1) {puts(\"-1\");return 0;}\n\t/*fo(i,1,n-1) rep(j,i) if (!f[j]&&t[j]) p[i]=t[j]-n+1;\n\tdfs(1);\n\tfo(i,1,n-1) if (!fa[i]) {puts(\"-1\");return 0;}\n\tfo(i,1,n-1) printf(\"%d %d\\n\",p[i],fa[i]);*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include<bits/stdc++.h>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int maxn=200111;\nconst int maxm=400111;\n\nstruct edge{int to,cap;};\nnamespace flow\n{\n\tint head[maxn],nxt[maxm<<1],iter[maxn],tot;\n\tedge e[maxm<<1];\n\tvoid clear()\n\t{\n\t\tmemset(head,0,sizeof(head));\n\t\ttot=1;\n\t}\n\tvoid addedge(int u,int v,int cap)\n\t{\n\t\tnxt[++tot]=head[u];\n\t\thead[u]=tot;\n\t\te[tot]=edge{v,cap};\n\t\tnxt[++tot]=head[v];\n\t\thead[v]=tot;\n\t\te[tot]=edge{u,0};\n\t}\n\t \n\tint lvl[maxn],q[maxn];\n\tbool bfs(int s,int t)\n\t{\n\t\tmemset(lvl,-1,sizeof(lvl));\n\t\tlvl[s]=0;int rr=0;q[rr++]=s;\n\t\tfor(int fr=0;fr<rr;fr++)\n\t\t{\n\t\t\tint x=q[fr];if(x==t)return true;\n\t\t\tfor(int i=head[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==-1)\n\t\t\t{\n\t\t\t\tlvl[e[i].to]=lvl[x]+1;\n\t\t\t\tq[rr++]=e[i].to;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int x,int t,int f)\n\t{\n\t\tif(x==t||f==0)return f;\n\t\tint ret=0;\n\t\tfor(int&i=iter[x];i;i=nxt[i])if(e[i].cap&&lvl[e[i].to]==lvl[x]+1)\n\t\t{\n\t\t\tint d=dfs(e[i].to,t,min(f,e[i].cap));\n\t\t\te[i].cap-=d;e[i^1].cap+=d;\n\t\t\tf-=d;ret+=d;\n\t\t\tif(!f)break;\n\t\t}\n\t\treturn ret;\n\t}\n\tint maxflow(int s,int t)\n\t{\n\t\tint flow=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemcpy(iter,head,sizeof(head));\n\t\t\tflow+=dfs(s,t,inf);\n\t\t}\n\t\treturn flow;\n\t}\n};\n\nvector<int> e[maxn],g[maxn];\nint n,piv[maxn],fa[maxn];\n\nbool use[maxn];\nvoid dfs(int x)\n{\n\tuse[x]=1;\n\tfor(auto&v:g[x])if(!use[v])\n\t{\n\t\tfa[v]=x;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tget1(n);\n\tint S=1,T=n+n;\n\tflow::clear();\n\tfor(int i=2;i<=n;i++)flow::addedge(S,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint cnt,x;get1(cnt);\n\t\tflow::addedge(i+n,T,1);\n\t\twhile(cnt--)\n\t\t{\n\t\t\tget1(x);\n\t\t\te[i].pb(x);\n\t\t\tif(x>1)flow::addedge(x,i+n,1);\n\t\t}\n\t}\n\tif(flow::maxflow(S,T)<n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tfor(int i=2;i<=n;i++)for(int j=flow::head[i];j;j=flow::nxt[j])if(flow::e[j].to!=S&&!flow::e[j].cap)\n\t\tpiv[flow::e[j].to-n]=i;\n\t\n\tfor(int i=1;i<n;i++)for(int j=0;j<(int)e[i].size();j++)if(e[i][j]!=piv[i])g[e[i][j]].pb(piv[i]);\n\t\n\tdfs(1);\n\tfor(int i=2;i<=n;i++)if(!fa[i])\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",piv[i],fa[piv[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n\ntypedef std::pair <int, int> pr;\nconst int N = 100054;\n\nnamespace F {\n\t#define ad(x) ((x - 1 ^ 1) + 1)\n\n\tconst int N = ::N * 2, M = ::N * 8;\n\n\tstruct edge {\n\t\tint u, v, f;\n\t\tedge (int u0 = 0, int v0 = 0, int f0 = 0) : u(u0), v(v0), f(f0) {}\n\t} e[M];\n\n\tint V = 2, E = 0, si = 1, ti = 2, flow;\n\tint first[N], next[M];\n\tint dep[N], cur[N], que[N];\n\n\tinline void addedge(int u, int v, int f) {\n\t\te[++E] = edge(u, v, f), next[E] = first[u], first[u] = E;\n\t\te[++E] = edge(v, u), next[E] = first[v], first[v] = E;\n\t}\n\n\tbool bfs() {\n\t\tint h, t = 1, i, x, y;\n\t\tmemset(dep, -1, sizeof dep);\n\t\tque[0] = si, dep[si] = 0;\n\t\tfor (h = 0; h < t; h++) {\n\t\t\tif ((x = que[h]) == ti) return true;\n\t\t\tfor (i = first[x]; i; i = next[i])\n\t\t\t\tif (dep[y = e[i].v] == -1 && e[i].f)\n\t\t\t\t\tque[t++] = y, dep[y] = dep[x] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\n\tint dfs(int x, int lim) {\n\t\tint a, c, f = 0;\n\t\tif (x == ti || !lim) return lim;\n\t\tfor (int &i = cur[x]; i; i = next[i])\n\t\t\tif (dep[e[i].v] == dep[x] + 1 && e[i].f) {\n\t\t\t\ta = std::min(lim - f, e[i].f);\n\t\t\t\tc = dfs(e[i].v, a);\n\t\t\t\te[i].f -= c; e[ad(i)].f += c;\n\t\t\t\tif ((f += c) == lim) return f;\n\t\t\t}\n\t\treturn f;\n\t}\n\n\tint Dinic() {\n\t\tfor (flow = 0; bfs(); flow += dfs(si, INT_MAX))\n\t\t\tmemcpy(cur, first, sizeof cur);\n\t\treturn flow;\n\t}\n\n\tint get(int x) {\n\t\tfor (int i = first[x]; i; i = next[i]) if (i & 1 && !e[i].f) return e[i].v;\n\t\treturn -1;\n\t}\n}\n\nint n;\nint que[N], match[N], matup[N];\nstd::vector <int> nb[N];\n\nint main() {\n\tint i, v, m, h, t = 1;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i < n; ++i) {\n\t\tF::addedge(i + n + 1, 2, 1), scanf(\"%d\", &m);\n\t\tfor (; m; --m) scanf(\"%d\", &v), nb[v].EB(i), F::addedge(v + 1, i + n + 1, 1);\n\t}\n\tfor (i = 2; i <= n; ++i) F::addedge(1, i + 1, 1);\n\tif (F::Dinic() != n - 1) return puts(\"-1\"), 0;\n\tfor (i = 2; i <= n; ++i) match[ F::get(i + 1) - n - 1 ] = i;\n\tfor (*que = 1, h = 0; h < t; ++h)\n\t\tfor (int s : nb[v = que[h]]) if (!matup[s])\n\t\t\tmatup[s] = v, que[t++] = match[s];\n\tif (t != n) return puts(\"-1\"), 0;\n\tfor (i = 1; i < n; ++i) printf(matup[i] < match[i] ? \"%d %d\\n\" : \"%2$d %1$d\\n\", matup[i], match[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 210000;\nconst int INF = 1000000000;\n \nstruct edge {\n    int a, b, cap, flow;\n};\n \nint nv, s, t, d[MAXN], ptr[MAXN], q[MAXN];\nvector<edge> e;\nvector<int> g[MAXN];\n \nvoid addEdge (int a, int b, int cap) {\n    edge e1 = { a, b, cap, 0 };\n    edge e2 = { b, a, 0, 0 };\n    g[a].push_back ((int) e.size());\n    e.push_back (e1);\n    g[b].push_back ((int) e.size());\n    e.push_back (e2);\n}\n \nbool bfs() {\n    int qh=0, qt=0;\n    q[qt++] = s;\n    memset (d, -1, nv * sizeof d[0]);\n    d[s] = 0;\n    while (qh < qt && d[t] == -1) {\n        int v = q[qh++];\n        for (size_t i=0; i<g[v].size(); ++i) {\n            int id = g[v][i],\n                to = e[id].b;\n            if (d[to] == -1 && e[id].flow < e[id].cap) {\n                q[qt++] = to;\n                d[to] = d[v] + 1;\n            }\n        }\n    }\n    return d[t] != -1;\n}\n \nint dfs (int v, int flow) {\n    if (!flow)  return 0;\n    if (v == t)  return flow;\n    for (; ptr[v]<(int)g[v].size(); ++ptr[v]) {\n        int id = g[v][ptr[v]],\n            to = e[id].b;\n        if (d[to] != d[v] + 1)  continue;\n        int pushed = dfs (to, min (flow, e[id].cap - e[id].flow));\n        if (pushed) {\n            e[id].flow += pushed;\n            e[id^1].flow -= pushed;\n            return pushed;\n        }\n    }\n    return 0;\n}\n\nvector<bool> visited;\nvector<int> via;\n\nvoid dfs2(int v) {\n  visited[v] = true;\n  for (int i = 0; i < (int)g[v].size(); ++i) {\n    int id = g[v][i];\n    int to = e[id].b;\n    if (!visited[to] && e[id].flow < e[id].cap) {\n      via[to] = v;\n      dfs2(to);\n    }\n  }\n}\n \nint dinic() {\n    int flow = 0;\n    for (;;) {\n        if (!bfs())  break;\n        memset (ptr, 0, nv * sizeof ptr[0]);\n        while (int pushed = dfs (s, INF))\n            flow += pushed;\n    }\n    return flow;\n}\n\nint main() {\n        int n; scanf(\"%d\", &n);\n        nv = 2 * n + 1;\n        s = nv - 2;\n        t = nv - 1;\n        vector<int> left(n);\n        for (int i = 0; i < n; ++i) {\n            left[i] = i;\n            addEdge(s, left[i], 1);\n        }\n        for (int i = 0; i < n - 1; ++i) {\n            int cur = n + i;\n            int count; scanf(\"%d\", &count);\n            addEdge(cur, t, 1);\n            for (int j = 0; j < count; ++j) {\n                int a; scanf(\"%d\", &a);\n                addEdge(left[a - 1], cur, 1);\n            }\n        }\n        int flow = dinic();\n        if (flow != n - 1) {\n            \n                printf(\"-1\\n\");\n                return 0;\n        }\n        visited = vector<bool>(nv);\n        via = vector<int>(nv);\n        dfs2(s);\n        for (int v : left) {\n            if (!visited[v]) {\n                printf(\"-1\\n\");\n                return 0;\n            }\n        }\n        vector<int> first(n - 1);\n        vector<int> second(n - 1);\n        for (int v : left) {\n            if (via[v] == s) continue;\n            int u = via[via[v]];\n            first[via[v] - n] = v + 1;\n            second[via[v] - n] = u + 1;\n        }\n        for (int i = 0; i < n - 1; ++i)           {\n            printf(\"%d %d\\n\", first[i], second[i]);\n        }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[100000];\nint p[100000];\nbool used[100000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N - 1, N);\n  vector< int > rev[100000];\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n      rev[x].emplace_back(i);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n \ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\nstruct Dinic {\n  struct Edge {\n    int v, c, inv;\n  };\n  \npublic:\n  Dinic() {\n    n = -1;\n  }  \n  \n  void AddEdge(int a, int b, int cap, int bi_dir) {\n    if (n < max(a, b)) {\n      n = max(n, max(a, b));\n      ResizeVectors();\n    }\n    e_orig[a].PB(Edge{b, cap, SZ(e_orig[b])});\n    e_orig[b].PB(Edge{a, bi_dir * cap, SZ(e_orig[a]) - 1});\n  }\n  \n  int MaxFlow(int s, int t) {\n    if (t > n || s > n) {\n      n = max(s, t);\n      ResizeVectors();\n    }\n    e = e_orig;\n    int result = 0;\n    while (Bfs(s, t)) {\n      for (int i = 0; i <= n; i++) {\n        beg[i] = 0;\n      }\n      result += Dfs(s, t, kInf);\n    }\n    return result;\n  }\n \n  vector<bool> MinCut(int s, int t) {\n    assert(!Bfs(s, t));\n    vector<bool> res(n + 1);\n    for (int i = 0; i <= n; i++) { res[i] = (dis[i] <= n); }\n    return res;\n  }\n  \n  vector<PII> EdgeCut(int s, int t) {\n    vector<bool> left_part = MinCut(s, t);\n    vector<PII> cut;\n    for (int v = 0; v <= n; v++) {\n      for (auto edge : e_orig[v]) {\n        if (edge.c != 0 && left_part[v] && !left_part[edge.v]) {\n          cut.PB({v, edge.v});\n        }\n      }\n    }\n    return cut;\n  }\n  \n#ifdef int\n  static const int kInf = 1e18;\n#else\n  static const int kInf = 1e9;\n#endif\n  \n  int n;\n  vector<vector<Edge>> e_orig, e;\n  VI dis, beg;\n  \n  bool Bfs(int s, int t) {\n    for (int i = 0; i <= n; i++) {\n      dis[i] = n + 1;\n    }\n    dis[s] = 0;\n    VI que;\n    que.push_back(s);\n    for (int i = 0; i < SZ(que); i++) {\n      int v = que[i];\n      for (auto edge : e[v]) {\n        int nei = edge.v;\n        if (edge.c && dis[nei] > dis[v] + 1) {\n          dis[nei] = dis[v] + 1;\n          que.push_back(nei);\n          if (nei == t) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  \n  int Dfs(int v, int t, int min_cap) {\n    int result = 0;\n    if (v == t || min_cap == 0) {\n      return min_cap;\n    }\n    for (int& i = beg[v]; i < SZ(e[v]); i++) {\n      int nei = e[v][i].v;\n      int c = e[v][i].c;\n      if (dis[nei] == dis[v] + 1 && c > 0) {\n        int flow_here = Dfs(nei, t, min(min_cap, c));\n        result += flow_here;\n        min_cap -= flow_here;\n        e[v][i].c -= flow_here;\n        e[nei][e[v][i].inv].c += flow_here;\n      }\n      if (min_cap == 0) {\n        break;\n      }\n    }\n    return result;\n  }\n  \n  void ResizeVectors() {\n    e_orig.resize(n + 2);\n    beg.resize(n + 2);\n    dis.resize(n + 2);\n  }\n  \n};\n \n \nint32_t main() {\n \n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n;\n  cin>>n;\n  Dinic gr;\n  int source = 0;\n  int sink = 2 * n + 1;\n  RE (i, n - 1) {\n    int k;\n    cin>>k;\n    RE (j, k) {\n      int a;\n      cin>>a;\n      gr.AddEdge(i, n + a, Dinic::kInf, 0);\n    }\n    gr.AddEdge(source, i, n, 0);\n  }\n  RE (i, n) {\n    gr.AddEdge(i + n, sink, n - 1, 0);\n  }\n  int flow = gr.MaxFlow(source, sink);\n  if (flow != n * (n - 1)) {\n    cout<<\"-1\\n\";\n    return 0;\n  }\n  RE (i, n - 1) {\n    vector<PII> halko;\n    for (auto edge : gr.e[i]) {\n      if (edge.v > i && edge.c != Dinic::kInf) {\n        halko.PB({-edge.c, edge.v - n,  });\n      }\n    }\n    //assert(SZ(halko) == 2);\n    sort(ALL(halko));\n    REP (tr, 2) {\n      cout<<halko[tr].nd<<\" \";\n    }\n//     for (auto x : halko) {\n//       cout<<x<<\" \";\n//     }\n    cout<<\"\\n\";\n  }\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MN 201000\n#define MM 801000\n\nint h[MN], nxt[MM], to[MM], cap[MM], K = 1;\nint iter[MN], d[MN], q[MN], hh = 0, tt = 0;\nstd::vector<int> B[MN];\nint x[MN], y[MN], o = 0;\nbool used[MN]; int mat[MN];\n\nvoid ins(int u, int v, int c) {nxt[++K] = h[u]; h[u] = K; to[K] = v; cap[K] = c;}\nvoid insw(int u, int v, int c) {ins(u, v, c); ins(v, u, 0);}\n\nbool bfs(int S, int T)\n{\n\tmemset(d, 0, sizeof(d));\n\thh = tt = 0; d[S] = 1; q[tt++] = S;\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t\tif(cap[i] && !d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\tif(to[i] == T) return 1;\n\t\t\t\tq[tt++] = to[i];\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int T, int f)\n{\n\tif(u == T) return f;\n\tint used = 0;\n\tfor(int &i = iter[u]; i; i = nxt[i])\n\t\tif(cap[i] && d[to[i]] == d[u] + 1)\n\t\t{\n\t\t\tint w = dfs(to[i], T, std::min(f - used, cap[i]));\n\t\t\tif(w)\n\t\t\t{\n\t\t\t\tcap[i] -= w; cap[i ^ 1] += w; used += w; \n\t\t\t\tif(used == f) return f;\n\t\t\t}\n\t\t}\n\treturn used;\n}\n\nint dinic(int S, int T)\n{\n\tint flow = 0;\n\twhile(bfs(S, T))\n\t{\n\t\tmemcpy(iter, h, sizeof(h));\n\t\tint f;\n\t\twhile(f = dfs(S, T, 1e9)) flow += f;\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint S = 2 * n, T = S + 1; \n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint o; scanf(\"%d\", &o);\n\t\tfor(int j = 1; j <= o; j++) \n\t\t{\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\tB[k].push_back(i);\n\t\t\tinsw(i, n - 1 + k, 1); \n\t\t}\n\t\tinsw(S, i, 1);\n\t}\n\tfor(int i = n; i < 2 * n; i++) insw(i, T, 1);\n\tif(dinic(S, T) != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = h[i]; j; j = nxt[j])\n\t\t\tif(!cap[j] && n <= to[j] && to[j] < 2 * n) mat[i] = to[j] - n + 1;\n\tfor(int i = 1; i < n; i++) used[mat[i]] = 1;\n\thh = tt = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) q[tt++] = i;\n\tmemset(used, 0, sizeof(used));\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = 0; i < B[u].size(); i++)\n\t\t{\n\t\t\tif(!used[B[u][i]]) \n\t\t\t{\n\t\t\t\tused[B[u][i]] = 1;\n\t\t\t\t++o; x[o] = mat[B[u][i]]; y[o] = u;\n\t\t\t\tq[tt++] = mat[B[u][i]];\n\t\t\t}\n\t\t}\n\t}\n\tif(o != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i <= o; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(Lim,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 10];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = true;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    /*\n                    if (!pp[jh]) {\n                        cout << jh << endl;\n                    }\n                    */\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        // freopen(\"a.in\", \"r\", stdin);\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            // assert(ee[i + n - 1].first), assert(ee[i + n - 1].second), assert(ee[i + n - 1].first != ee[i + n - 1].second);\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1500010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[200010], ans[200010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue < int > q;\n    q.push(n);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ld long double\n#define db double\n#define pint pair<int,int>\n#define mk(x,y) make_pair(x,y)\n#define fir first\n#define sec second\n#define Rep(x,y,z) for(int x=y;x<=z;x++)\n#define Red(x,y,z) for(int x=y;x>=z;x--)\nusing namespace std;\nconst int MAXN=2e5+5,MAXM=1e6+5;\nchar buf[1<<12],*pp1=buf,*pp2=buf,nc;int ny;\ninline char gc() {return pp1==pp2&&(pp2=(pp1=buf)+fread(buf,1,1<<12,stdin),pp1==pp2)?EOF:*pp1++;}\n//inline char gc(){return getchar();}\ninline int read(){\n\tint x=0;for(ny=1;nc=gc(),(nc<48||nc>57)&&nc!=EOF;)if(nc==45)ny=-1;if(nc<0)return nc;\n\tfor(x=nc-48;nc=gc(),47<nc&&nc<58&&nc!=EOF;x=(x<<3)+(x<<1)+(nc^48));return x*ny;\n}int n;\nstruct Edge{int to,next,w;}edges[MAXM];\nint head[MAXN],cur[MAXN],cnt=1,d[MAXN],S,T;\ninline void add(int x,int y,int w){\n\tedges[++cnt]=(Edge){y,head[x],w},head[x]=cnt;\n\tedges[++cnt]=(Edge){x,head[y],0},head[y]=cnt;\n}inline bool bfs(){\n\tqueue<int>q;q.push(S);memset(d,0,sizeof(d)),memcpy(cur,head,sizeof(head));\n\tfor(int x;!q.empty();q.pop())\n\t\tfor(int i=head[x=q.front()],y;i;i=edges[i].next)\n\t\t\tif(edges[i].w&&!d[y=edges[i].to])d[y]=d[x]+1,q.push(y);\n\treturn d[T];\n}int dfs(int x,int dist){\n\tif(x==T||!dist)return dist;int z=0;\n\tfor(int&i=cur[x],y,k;i;i=edges[i].next)if(edges[i].w&&d[y=edges[i].to]==d[x]+1){\n\t\tk=dfs(y,min(dist,edges[i].w)),z+=k,dist-=k,edges[i].w-=k,edges[i^1].w+=k;\n\t\tif(!dist)break;\n\t}return z;\n}inline int Dinic(){int ans=0;while(bfs())ans+=dfs(S,1e9);return ans;}\nint vis[MAXN],vis2[MAXN],id[MAXN],nxt[MAXN];vector<int>bel[MAXN];\ninline bool Solve(){\n\tqueue<int>q;\n\tfor(int i=1;i<n;i++)for(int j=head[n+i];j;j=edges[j].next)if(edges[j].to&&!edges[j].w)id[i]=edges[j].to,vis[edges[j].to]=1;\n\tRep(i,1,n)if(!vis[i])q.push(i);\n\tint cnt=0;\n\tfor(int x;!q.empty();q.pop()){\n\t\tx=q.front(),cnt++;\n\t\tfor(int i=0,len=bel[x].size(),y;i<len;i++)\n\t\t\tif(!vis2[y=bel[x][i]])vis2[y]=1,nxt[y]=x,q.push(id[y]);\n\t}return cnt==n;\n}\nint main(){\n//\tfreopen(\"std.in\",\"r\",stdin);\n//\tfreopen(\"std.out\",\"w\",stdout);\n\tn=read(),S=0,T=2*n;\n\tRep(i,1,n-1){\n\t\tadd(S,i+n,1);\n\t\tfor(int t=read(),x;t--;)x=read(),add(i+n,x,1),bel[x].push_back(i);\n\t}Rep(i,1,n)add(i,T,1);\n\tif(Dinic()!=n-1){puts(\"-1\");return 0;}\n\tif(!Solve()){puts(\"-1\");return 0;}\n\tRep(i,1,n-1)cout<<id[i]<<' '<<nxt[i]<<'\\n';\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 200100;\n\nvector<int> g[N];\n\nbool mark[N];\nint match[N];\nint n;\n\nbool dfs(int v) {\n  if (mark[v]) {\n    return false;\n  }\n  mark[v] = true;\n  for (int to : g[v]) {\n    if (match[to] == -1 || dfs(match[to])) {\n      match[to] = v;\n      match[n + v] = to;\n      return true;\n    }\n  }\n  return false;\n}\n\nint matching() {\n  memset(match, -1, sizeof match);\n  while (true) {\n    memset(mark, false, sizeof mark);\n    bool done = true;\n    for (int i = 0; i < n - 1; i++) {\n      if (match[n + i] == -1) {\n        done &= !dfs(i);\n      }\n    }\n    if (done) {\n      break;\n    }\n  }\n  int res = 0;\n  for (int i = 0; i < n - 1; i++) {\n    res += (match[n + i] != -1);\n  }\n  return res;\n}\n\nvector<pair<int, int>> ed;\n\nint make(int v) {\n  int res = 1;\n  for (int to : g[n + v]) {\n    if (!mark[to]) {\n      mark[to] = 1;\n      assert(match[n + to] != -1);\n      ed[to] = {v, match[n + to]};\n      res += make(match[n + to]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cin >> n;\n  for (int i = 0; i < n - 1; i++) {\n    int c;\n    cin >> c;\n    while (c--) {\n      int x;\n      cin >> x;\n      --x;\n      g[i].push_back(x);\n      g[n + x].push_back(i);\n    }\n  }\n  if (matching() != n - 1) {\n    cout << -1 << '\\n';\n    return 0;\n  }\n  int root = -1;\n  for (int i = 0; i < n; i++) {\n    if (match[i] == -1) {\n      root = i;\n      break;\n    }\n  }\n  memset(mark, 0, sizeof mark);\n  ed.resize(n - 1);\n  if (make(root) != n) {\n    cout << -1 << '\\n';\n  } else {\n    for (auto e : ed) {\n      cout << e.first + 1 << \" \" << e.second + 1 << '\\n';\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = lis[i - 1], v = pre[u];\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[v-n]=u;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(cho[v]),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#define MN 200010\n#define MM 800010\n#define inf 999999999\nusing namespace std;\nint fr[MN],dy[MN],ne[MM],v[MM],w[MM],bs=0;\nvoid add(int a,int b,int c)\n{\n\tv[bs]=b;\n\tw[bs]=c;\n\tne[bs]=fr[a];\n\tfr[a]=bs++;\n}\nvoid addb(int a,int b,int c)\n{\n\tadd(a,b,c);\n\tadd(b,a,0);\n}\nint dl[100010],jl[100010],N,S,T;bool bk[100010];\nbool bfs()\n{\n\tfor(int i=1;i<=N;i++)\n\t{\n\t\tbk[i]=false;\n\t\tjl[i]=inf;\n\t}\n\tbk[S]=true;jl[S]=0;\n\tint he=0,ta=1;dl[0]=S;\n\twhile(he<ta)\n\t{\n\t\tint u=dl[he++];\n\t\tfor(int i=fr[u];i!=-1;i=ne[i])\n\t\t{\n\t\t\tif(w[i]>0&&!bk[v[i]])\n\t\t\t{\n\t\t\t\tbk[v[i]]=true;\n\t\t\t\tjl[v[i]]=jl[u]+1;\n\t\t\t\tdl[ta++]=v[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn jl[T]<inf;\n}\nint dfs(int u,int z)\n{\n\tif(u==T)\n\t\treturn z;\n\tfor(int &i=dy[u];i!=-1;i=ne[i])\n\t{\n\t\tif(w[i]>0&&jl[v[i]]==jl[u]+1)\n\t\t{\n\t\t\tint t=dfs(v[i],z<w[i]?z:w[i]);\n\t\t\tif(t!=-1)\n\t\t\t{\n\t\t\t\tw[i]-=t;\n\t\t\t\tw[i^1]+=t;\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t}\n\treturn -1;\n}\nint dinic()\n{\n\tint jg=0;\n\twhile(bfs())\n\t{\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tdy[i]=fr[i];\n\t\twhile(1)\n\t\t{\n\t\t\tint t=dfs(S,inf);\n\t\t\tif(t==-1)\n\t\t\t\tbreak;\n\t\t\tjg+=t;\n\t\t}\n\t}\n\treturn jg;\n}\nvector<int> ve[100010],to[100010];\nint pp[100010],fa[100010];\nvoid dfs2(int u,int f)\n{\n\tif(bk[u])return;\n\tfa[u]=f;bk[u]=true;\n\tfor(int i=0;i<to[u].size();i++)\n\t\tdfs2(to[u][i],u);\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tint s,a;\n\t\tscanf(\"%d\",&s);\n\t\tfor(int j=0;j<s;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&a);\n\t\t\tve[i].push_back(a);\n\t\t}\n\t}\n\tN=n*2+1;S=N-1;T=N;\n\tfor(int i=1;i<=N;i++)\n\t\tfr[i]=-1;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\taddb(S,i,1);\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t\taddb(i,ve[i][j]+n-1,1);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\taddb(i+n-1,T,1);\n\tif(dinic()!=n-1)\n\t{\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tbk[i]=false;\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tfor(int j=fr[i];j!=-1;j=ne[j])\n\t\t{\n\t\t\tint t=v[j];\n\t\t\tif(t>n-1&&w[j]==0)\n\t\t\t{\n\t\t\t\tpp[i]=t-(n-1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<ve[i].size();j++)\n\t\t{\n\t\t\tif(ve[i][j]!=pp[i])\n\t\t\t\tto[ve[i][j]].push_back(pp[i]);\n\t\t}\n\t\tbk[pp[i]]=true;\n\t}\n\tint ro=-1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!bk[i])\n\t\t{\n\t\t\tro=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)bk[i]=false;\n\tdfs2(ro,0);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(i!=ro&&fa[i]==0)\n\t\t{\n\t\t\tprintf(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i=1;i<=n-1;i++)\n\t\tprintf(\"%d %d\\n\",pp[i],fa[pp[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\ntemplate<typename T>\nstruct Maxflow\n{\n    struct edge { int to; T cap; int rev; };\n    std::vector<std::vector<edge> > edges;\n    std::vector<int> level;\n    std::vector<int> iter;\n    std::vector<int> used;\n\n    void bfs(int s)\n    {\n        level = std::vector<int>(edges.size(), -1);\n        std::queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while (!q.empty())\n        {\n            int v = q.front();\n            q.pop();\n            for (edge &e : edges[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    T dfs_d(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        for (int &i = iter[v]; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                T d = dfs_d(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    T dfs_ff(int v, int goal, T f)\n    {\n        if (v == goal) return f;\n        used[v] = true;\n        for (int i = 0; i < (int)edges[v].size(); i++)\n        {\n            edge &e = edges[v][i];\n            if (e.cap > 0 && !used[e.to])\n            {\n                T d = dfs_ff(e.to, goal, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    edges[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Maxflow(int N) { edges.resize(N); }\n    void add_edge(int from, int to, T capacity)\n    {\n        edges[from].push_back(edge{to, capacity, (int)edges[to].size()});\n        edges[to].push_back(edge{from, (T)0, (int)edges[from].size() - 1});\n    }\n\n    T Dinic(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            iter = std::vector<int>(edges.size(), 0);\n            T f;\n            while ((f = dfs_d(s, t, INF)) > 0) flow += f;\n        }\n    }\n\n    T FF(int s, int t)\n    {\n        constexpr T INF = std::numeric_limits<T>::max();\n        T flow = 0;\n        while (true)\n        {\n            used = std::vector<int>(edges.size(), 0);\n            T f = dfs_ff(s, t, INF);\n            if (f == 0) return flow;\n            flow += f;\n        }\n    }\n\n    void back_flow(int s, int t, int s_e, int t_e, T capacity_reduce)\n    {\n        int i;\n        for (i=0; edges[s_e][i].to != t_e; ) i++;\n        edge &e = edges[s_e][i];\n\n        if (capacity_reduce <= e.cap)\n        {\n            e.cap -= capacity_reduce;\n        }\n        else\n        {\n            T flow = capacity_reduce - e.cap;\n            e.cap = 0;\n            edges[e.to][e.rev].cap -= flow;\n\n            T f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(t, t_e, flow - f_sum);\n            }\n            f_sum = 0;\n            while (f_sum != flow)\n            {\n                used = std::vector<int>(edges.size(), 0);\n                f_sum += dfs_ff(s_e, s, flow - f_sum);\n            }\n        }\n    }\n};\n\n\nstruct UnionFind // UnionFind Tree (0-indexed)\n{\n    vector<int> par, rank;\n    UnionFind(int N) : par(N), rank(N) { REP(i, N) par[i] = i; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (rank[x] < rank[y]) par[x] = y; else par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n};\n\n\nint N;\n\nint main()\n{\n    cin >> N;\n    Maxflow<lint> a(2 * N + 2);\n    vector<int> wm(N);\n\n    FOR(i, 1, N)\n    {\n        int c;\n        vector<int> w;\n        cin >> c;\n        w.resize(c);\n        cin >> w;\n        sort(w.begin(), w.end());\n\n        a.add_edge(0, i, 1);\n        REP(j, c - 1) a.add_edge(i, N + w[j + 1], 1);\n        wm[i] = w[0];\n    }\n    REP(i, N - 1) a.add_edge(2 * N - i, 2 * N + 1, 1);\n\n    int mf = a.Dinic(0, 2 * N + 1);\n    dbg(mf);\n    vector<pint> ans;\n    if (mf != N - 1) puts(\"-1\");\n    else\n    {\n        FOR(from, 1, N)\n        {\n            for (auto ed : a.edges[from]) if (ed.to <= N * 2 && ed.to > N && ed.cap == 0) ans.push_back(pint(wm[from], ed.to - N));\n        }\n        if(ans.size() != N - 1) exit(1);\n        UnionFind uf(N + 1);\n        for (auto pa : ans) uf.unite(pa.first, pa.second);\n        REP(i, N) if (!uf.same(1, i + 1)) exit(1);\n\n        for (auto pa : ans) printf(\"%d %d\\n\", pa.first, pa.second);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MX = 200005;\nconst int ME = 800005;\nconst int oo = 123123123;\n\ntemplate<typename T> void cmax(T &x, const T &y)\n{\n\tif(y > x) x = y;\n}\n\ntemplate<typename T> void read(T &x)\n{\n\tx = 0;\n\tchar c = getchar();\n\tbool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct EDGE\n{\n\tint v, c;\n\n\tEDGE (const int &v0 = 0, const int &c0 = 0) : v(v0), c(c0) {}\n};\n\nstruct GRAPH\t//\n{\n\tEDGE e[ME];\n\tint fst[MX], nxt[ME], lnum;\n\tint dep[MX],q[MX];          //bfs \n\n\tvoid addeg(int nu, int nv, int nc)\n\t{\n\t\tnxt[++lnum] = fst[nu];\n\t\tfst[nu] = lnum;\n\t\te[lnum] = EDGE(nv, nc);\n\t}\n\n\tvoid init()\n\t{\n\t\tmemset(fst, 0xff, sizeof(fst));\n\t\tlnum = -1;\n\t}\n\n\tint bfs(int frm,int to)     //\n\t{\n\t\tint h=0,t=1,x,y;\n\t\tmemset(dep,0xff,sizeof(dep));\n\t\tq[++h]=frm;\n\t\tdep[frm]=0;\n\t\twhile(h>=t)\n\t\t{\n\t\t\tx=q[t++];\n\t\t\tfor(int i=fst[x];i!=-1;i=nxt[i])\n\t\t\t{\n\t\t\t\ty=e[i].v;\n\t\t\t\tif(dep[y]==-1&&e[i].c)\n\t\t\t\t{\n\t\t\t\t\tdep[y]=dep[x]+1;\n\t\t\t\t\tq[++h]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (dep[to]>=0);    //\n\t}\n\n\tint cur[MX];                //\n\tint dinic(int x,int mn,int tar)\n\t{\n\t\tif(x==tar)return mn;\n\t\tint y,a,now=0;\n\t\tfor(int &i=cur[x];i!=-1;i=nxt[i])   //\"int &i=\"\n\t\t{\n\t\t\ty=e[i].v;\n\t\t\tif(e[i].c&&dep[y]==dep[x]+1)\n\t\t\t{\n\t\t\t\ta=dinic(y,min(mn-now,e[i].c),tar);\n\t\t\t\tnow+=a;                     //\n\t\t\t\te[i].c-=a,e[i^1].c+=a;      // dinic \n\t\t\t\tif(mn==now)return now;\n\t\t\t}\n\t\t}\n\t\treturn now;\n\t}\n\n\tint mxflow(int s, int t)\n\t{\n\t\tint tot=0;\n\t\twhile(bfs(s,t))\n\t\t{\n\t\t\tmemmove(cur,fst,sizeof(fst));\n\t\t\ttot+=dinic(s,+oo,t);\n\t\t}\n\t\treturn tot;\n\t}\n} G;\n\nint n;\nint global_s, global_t;\n\nvoid input()\n{\n\tG.init();\n\tread(n);\n\tglobal_s = n*2, global_t = n*2+1;\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint c, x;\n\t\tread(c);\n\t\tfor(int j=1; j<=c; j++)\n\t\t{\n\t\t\tread(x);\n\t\t\tG.addeg(x, n+i, 1);\n\t\t\tG.addeg(n+i, x, 0);\n\t\t}\n\t}\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tG.addeg(global_s, i, 1);\n\t\tG.addeg(i, global_s, 0);\n\t}\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tG.addeg(n+i, global_t, 1);\n\t\tG.addeg(global_t, n+i, 0);\n\t}\n}\n\nint frm[MX];\npair<int, int> ans[MX];\n\nvoid dfs(int x, int f)\n{\n\tfrm[x] = f;\n\tfor(int i=G.fst[x]; ~i; i=G.nxt[i])\n\t\tif(G.e[i].c && !frm[G.e[i].v])\n\t\t\tdfs(G.e[i].v, x);\n}\n\nvoid work()\n{\n\tif(G.mxflow(global_s, global_t) != n-1) puts(\"-1\");\n\telse\n\t{\n\t\tint root = 0;\n\t\tfor(int i=G.fst[global_s]; ~i; i=G.nxt[i])\n\t\t\tif(G.e[i].c)\n\t\t\t\troot = G.e[i].v;\n\t\tdfs(root, -1);\n\t\tbool fucked = 0;\n\t\tfor(int i=1; i<=n; i++)\n\t\t\tif(!frm[i])\n\t\t\t\tfucked = 1;\n\t\tif(fucked) puts(\"-1\");\n\t\telse\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++)\n\t\t\t\tif(i != root)\n\t\t\t\t\tans[frm[i]-n] = make_pair(i, frm[frm[i]]);\n\t\t\tfor(int i=1; i<n; i++)\n\t\t\t\tprintf(\"%d %d\\n\", ans[i].first, ans[i].second);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#define pb push_back\n#define jizz ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n#define F first\n#define S second\n#define MP make_pair\n#define ET cout << \"\\n\"\n#define MEM(i,j) memset(i,j,sizeof i)\n#define ALL(v) v.begin(),v.end()\n#define DB(a,s,e) {for(int i=s;i<e;++i) cout << a[i] << \" \";ET;}\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nconst int MAXN=2e5+50,INF=1e9;\nstruct Maxflow{\n\tstruct edge{\n\t\tint to,cap,flow,rev;\n\t};\n\tvector<edge> G[MAXN];\n\tint dis[MAXN],cur[MAXN],s,t;\n\tint dfs(int u,int cap){\n\t\tif(u==t||!cap) return cap;\n\t\tfor(int &i=cur[u];i<G[u].size();++i){\n\t\t\tauto &e=G[u][i];\n\t\t\tif(dis[e.to]==dis[u]+1&&e.flow!=e.cap){\n\t\t\t\tint df=dfs(e.to,min(cap,e.cap-e.flow));\n\t\t\t\tif(df){\n\t\t\t\t\te.flow+=df,G[e.to][e.rev].flow-=df;\n\t\t\t\t\treturn df;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdis[u]=-1;\n\t\treturn 0;\n\t}\n\tbool bfs(){\n\t\tMEM(dis,-1);\n\t\tqueue<int> q;\n\t\tq.push(s),dis[s]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto e:G[u])\n\t\t\t\tif(!~dis[e.to]&&e.flow!=e.cap)\n\t\t\t\t\tq.push(e.to),dis[e.to]=dis[u]+1;\n\t\t}\n\t\treturn dis[t]!=-1;\n\t}\n\tint maxflow(int _s,int _t){\n\t\ts=_s,t=_t;\n\t\tint flow=0,df;\n\t\twhile(bfs()){\n\t\t\tMEM(cur,0);\n\t\t\twhile(df=dfs(s,INF)) flow+=df;\n\t\t}\n\t\treturn flow;\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;++i) G[i].clear();\n\t}\n\tvoid add_edge(int a,int b,int cap){\n\t\tG[a].pb(edge{b,cap,0,G[b].size()});\n\t\tG[b].pb(edge{a,0,0,G[a].size()-1});\n\t}\n}Dinic;\n\nint match[200005],n;\npii ans[100005];\nvector<int> G[100005],one;\nbitset<100005> vis;\n\nvoid dfs(int u,int f)\n{\n\tvis[u]=1;\n\tif(u!=1)\n\t\tans[match[u]-n]=MP(u,f);\n\tfor(int i:G[u])\n\t\tif(!vis[i])\n\t\t\tdfs(i,u);\n}\n\nint main()\n{jizz\n\tint t,x;\n\tcin >> n,Dinic.init(2*n-2);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tcin >> t;\n\t\twhile(t--)\n\t\t\tif(cin >> x,x==1)\n\t\t\t\tone.pb(i+n);\n\t\t\telse\n\t\t\t\tDinic.add_edge(x,i+n,1);\n\t}\n\tfor(int i=2;i<=n;++i)\n\t\tDinic.add_edge(0,i,1);\n\tfor(int i=1;i<n;++i)\n\t\tDinic.add_edge(i+n,1,1);\n\tif(Dinic.maxflow(0,1)!=n-1)\n\t\treturn cout << \"-1\\n\",0;\n\tfor(int i=2;i<=n;++i)\n\t\tfor(auto e:Dinic.G[i])\n\t\t\tif(e.cap==e.flow&&e.to>n)\n\t\t\t{\n\t\t\t\tmatch[i]=e.to,match[e.to]=i;\n\t\t\t\tbreak;\n\t\t\t}\n\tfor(int i:one)\n\t\tG[1].pb(match[i]),G[match[i]].pb(1);\n\tfor(int i=2;i<=n;++i)\n\t\tfor(auto e:Dinic.G[i])\n\t\t\tif(e.cap!=e.flow&&e.to>n)\n\t\t\t\tG[i].pb(match[e.to]),G[match[e.to]].pb(i);\n\tdfs(1,-1);\n\tfor(int i=1;i<n;++i)\n\t\tcout << ans[i].F << \" \" << ans[i].S << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\treturn 0;\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define WATCHR(a, b) TRACE(for (auto it=a; it!=b;) cout << *(it++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define all(x) (x).begin(), (x).end()\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate<typename F> struct dinic {\n    static constexpr F inf = numeric_limits<F>::has_infinity ?\n        numeric_limits<F>::infinity() : numeric_limits<F>::max();\n\n    int V;\n    vvi adj;\n    vi dest;\n    vector<F> cap;\n\n    dinic (int V = 0) : V(V) {\n        adj.resize(V);\n    }\n\n    void __arc(int u, int v, F c) {\n        adj[u].push_back(dest.size());\n        dest.push_back(v);\n        cap.push_back(c);\n    }\n\n    // Inserts a directed edge u --> v with capacity c.\n    void arc(int u, int v, F c) {\n        __arc(u, v, c);\n        __arc(v, u, F(0));\n    }\n\n    bool bfs(int s, int t, vi& level, vector<F>& flow) const {\n        level = vi(V, -1);\n        level[s] = 0;\n        for (queue<int> q({s}); !q.empty(); q.pop()) {\n            int u = q.front();\n            for (int e : adj[u]) {\n                if (level[dest[e]] == -1 && flow[e] < cap[e]) {\n                    level[dest[e]] = level[u] + 1;\n                    q.push(dest[e]);\n                }\n            }\n        }\n        return level[t] != -1;\n    }\n\n    F augment(int s, int t, vi& level, vector<F>& flow, vi& inx, F cur) const {\n        if (s == t) return cur;\n        for (int e; inx[s] < adj[s].size(); inx[s]++) {\n            e = adj[s][inx[s]];\n            if (level[dest[e]] != level[s] + 1) continue;\n            if (flow[e] == cap[e]) continue;\n            F incr = augment(dest[e], t, level, flow, inx, min(cur, cap[e] - flow[e]));\n            if (incr > F(0)) {\n                flow[e] += incr;\n                flow[e^1] -= incr;\n                return incr;\n            }\n        }\n        return F(0);\n    }\n\n    /*\n     * Computes a maximum flow from node s to node t.\n     *\n     * Runs in O(V^2 * E) in the general case.\n     * Runs in O(min{ V^(2/3), E^(1/2) } * E) if all edges have unit capacity.\n     * Runs in O(V^(1/2) * E) for bipartite matching.\n     */\n    tuple<F, vector<F>> max_flow(int s, int t) const {\n        assert(s != t);\n        F res(0);\n        vector<F> flow(cap.size());\n        for (vi level; bfs(s, t, level, flow); ) {\n            for (vi inx(V, 0); F incr = augment(s, t, level, flow, inx, inf); )\n                res += incr;\n        }\n        return { res, flow };\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    int N;\n    cin >> N;\n\n    int src = 0, snk = 2 * N;\n    dinic<int> g(2 * N + 1);\n\n    for (int i = 1; i <= N; i++) {\n        g.arc(src, i, 1);\n    }\n\n    for (int i = 1; i <= N - 1; i++) {\n        g.arc(N + i, snk, 1);\n\n        int sz, w;\n        cin >> sz;\n        for (int j = 0; j < sz; j++) {\n            cin >> w;\n            g.arc(w, N + i, 1);\n        }\n    }\n\n    auto [F, flow] = g.max_flow(src, snk);\n    if (F != N - 1) {\n        cout << -1 << endl;\n        return 0;\n    }\n\n    int root;\n    for (int e : g.adj[src]) {\n        if (flow[e] == 0) {\n            root = g.dest[e];\n            break;\n        }\n    }\n\n    vi vis(g.V);\n    vis[src] = -1;\n    vis[snk] = -1;\n    vis[root] = root;\n\n    queue<int> bfs({ root });\n    while (!bfs.empty()) {\n        int loc = bfs.front();\n        bfs.pop();\n        for (int e : g.adj[loc]) {\n            if (!vis[g.dest[e]] && (loc > N && flow[e] == -1 || loc <= N && flow[e] == 0)) {\n                vis[g.dest[e]] = loc;\n                bfs.push(g.dest[e]);\n            }\n        }\n    }\n\n    vector<pair<int, int>> res(N - 1);\n    for (int i = 1; i <= N; i++) {\n        if (i == root) continue;\n        if (!vis[i]) { cout << -1 << endl; return 0; }\n        res[vis[i] - N - 1] = { i, vis[vis[i]] };\n    }\n\n    for (auto [u, v] : res) {\n        cout << u << \" \" << v << \"\\n\";\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*4,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[S]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!~dis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\toutarr(dis,1,n);\n\t\treturn dis[T]!=-1;\n\t}\n\tint dfs(int x,int Lim){\n\t\tif (x==T||!Lim)\n\t\t\treturn Lim;\n\t\tint now=Lim;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tint d=dfs(y,min(now,e[i].cap));\n\t\t\t\te[i].cap-=d,e[i^1].cap+=d;\n\t\t\t\tnow-=d;\n\t\t\t\tif (!now)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn Lim-now;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tflow+=dfs(S,INF);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define M 400010\n#define inf 1e9\nusing namespace std;\nint n,num,cnt,s,t,h[M],head[M],son[M],vis[M];\nvector<int>S[M],P[M];\nqueue<int>Que;\nstruct node{int x,y,id;}f[M];\nstruct edge{int next,to,dis;}e[M<<1];\nbool cmp(node a,node b) {return a.id<b.id;}\nvoid add(int from,int to,int dis) {\n\te[num]=(edge){head[from],to,dis};\n\thead[from]=num++;\n}\nbool bfs() {\n\tqueue<int>Q;Q.push(s);\n\tmemset(h,0,sizeof(h)),h[s]=1;\n\twhile(!Q.empty()) {\n\t\tint x=Q.front();Q.pop();\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis>0&&!h[e[i].to])\n\t\t\t\tQ.push(e[i].to),h[e[i].to]=h[x]+1;\n\t}\n\treturn h[t];\n}\nint dfs(int x,int dis) {\n\tif(x==t) return dis;int sum=0;\n\tfor(int i=head[x];i;i=e[i].next) {\n\t\tint to=e[i].to;\n\t\tif(e[i].dis&&h[to]==h[x]+1) {\n\t\t\tint diss=dfs(to,min(e[i].dis,dis));\n\t\t\tdis-=diss;sum+=diss;\n\t\t\te[i].dis-=diss;e[i^1].dis+=diss;\n\t\t\tif(!dis) break;\n\t\t}\n\t}\n\tif(!sum) h[x]=-1;\n\treturn sum;\n}\nint dinic() {\n\tint tot=0;\n\twhile(bfs()) \n\t\ttot+=dfs(s,inf);\n\treturn tot;\n}\nint main() {\n\tscanf(\"%d\",&n);s=0,t=2*n;\n\tfor(int i=1;i<n;i++) {\n\t\tint sum;scanf(\"%d\",&sum);\n\t\tfor(int j=1;j<=sum;j++) {\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tS[i+n].push_back(x);\n\t\t\tadd(i+n,x,0),add(x,i+n,1);\n\t\t\tP[x].push_back(i+n);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++) add(i,s,0),add(s,i,1);\n\tfor(int i=n+1;i<n+n;i++) add(t,i,0),add(i,t,1);\n\tint ans=dinic();\n\tif(ans!=n-1) {puts(\"-1\");return 0;}\n\tfor(int x=n+1;x<n+n;x++)\n\t\tfor(int i=head[x];i;i=e[i].next)\n\t\t\tif(e[i].dis&&e[i].to!=t)\n\t\t\t\tson[x]=e[i].to;\n\tQue.push(1);\n\twhile(!Que.empty()) {\n\t\tint x=Que.front();Que.pop();\n\t\tfor(int i=0;i<P[x].size();i++) {\n\t\t\tint to=P[x][i];\n\t\t\tif(!vis[to]) {\n\t\t\t\tvis[to]=true;\n\t\t\t\tQue.push(son[to]);\n\t\t\t\tf[++cnt]=(node){x,son[to],to};\n\t\t\t}\n\t\t}\n\t}\n\tsort(f+1,f+1+cnt,cmp);\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define RI register int\n#define CI const int&\nusing namespace std;\nconst int N=100005;\nstruct edge\n{\n\tint to,nxt;\n}e[N<<1]; int n,x,y,cnt,head[N],frm[N],tim[N],pre[N],q[N];\ninline void addedge(CI x,CI y)\n{\n\te[++cnt]=(edge){y,head[x]}; head[x]=cnt;\n}\n#define to e[i].to\ninline bool find(CI now,CI t)\n{\n\tfor (RI i=head[now];i;i=e[i].nxt) if (tim[to]!=t)\n\tif (tim[to]=t,!frm[to]||find(frm[to],t)) return frm[to]=now,1; return 0;\n}\nint main()\n{\n\tRI i,j; for (scanf(\"%d\",&n),i=1;i<n;++i)\n\tfor (scanf(\"%d\",&x),j=1;j<=x;++j) scanf(\"%d\",&y),addedge(y,i);\n\tfor (i=2;i<=n;++i) if (!find(i,i)) return puts(\"-1\"),0;\n\tRI H=0,T=1; q[1]=1; while (H<T)\n\t{\n\t\tint now=q[++H]; for (i=head[now];i;i=e[i].nxt)\n\t\tif (!pre[to]) pre[to]=now,q[++T]=frm[to];\n\t}\n\tif (T!=n) return puts(\"-1\"),0;\n\tfor (i=1;i<n;++i) printf(\"%d %d\\n\",pre[i],frm[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define M 100010\nusing namespace std;\nstruct edge{int x,y;}f[M];\nint n,cnt,p[M],vis[M];\nint main() {\n\tscanf(\"%d\",&n);\n\tfor(int T=1;T<n;T++) {\n\t\tint m;scanf(\"%d\",&m);\n\t\tfor(int i=1;i<=m;i++) scanf(\"%d\",&p[i]);\n\t\tif(T==1) {\n\t\t\tvis[p[1]]=vis[p[2]]=true;\n\t\t\tf[++cnt]=(edge){p[1],p[2]};\n\t\t}\n\t\telse{\n\t\t\tint a1=0,a2=0;\n\t\t\tfor(int i=1;i<=m;i++) {\n\t\t\t\tif(!a1&&vis[p[i]]) a1=p[i];\n\t\t\t\telse if(!a2&&!vis[p[i]]) a2=p[i];\n\t\t\t}\n\t\t\tif(!a1||!a2) {puts(\"-1\");return 0;}\n\t\t\tf[++cnt]=(edge){a1,a2};vis[a1]=vis[a2]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=cnt;i++) printf(\"%d %d\\n\",f[i].x,f[i].y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500015;\nconst int INF = (int) 1e9;\nint e_num = 1, S, T;\nint hed[maxn], dep[maxn];\nstruct Edge {\n  int from, to, nxt, c;\n} edge[maxn * 4];\nvoid addedge(int from, int to, int c) {\n  edge[++e_num] = (Edge){from, to, hed[from], c};\n  hed[from] = e_num;\n}\nvoid adde(int from, int to, int c) {\n  addedge(from, to, c);\n  addedge(to, from, 0);\n}\nint que[maxn + 5], head = 0, tail = 0;\nbool bfs() {\n  head = tail = 0;\n  que[tail++] = S;\n  for (int i = S; i <= T; i++) dep[i] = 0;\n  dep[S] = 1;\n  while (head != tail) {\n    int cur = que[head++]; head %= maxn;\n    for (int i = hed[cur]; i; i = edge[i].nxt) {\n      int to = edge[i].to;\n      if (!dep[to] && edge[i].c) {\n        dep[to] = dep[cur] + 1;\n        que[tail++] = to; tail %= maxn;\n      }\n    }\n  }\n  return dep[T];\n}\nint dfs(int x, int flow) {\n  if (x == T) return flow;\n  int ret = 0;\n  for (int i = hed[x]; i; i = edge[i].nxt) {\n    int to = edge[i].to;\n    if (dep[to] == dep[x] + 1 && edge[i].c) {\n      int tmp = dfs(to, std::min(flow, edge[i].c));\n      edge[i].c -= tmp;\n      edge[i ^ 1].c += tmp;\n      flow -= tmp;\n      ret += tmp;\n      if (!flow) {\n        break;\n      }\n    }\n  }\n  if (!ret) dep[x] = 0;\n  return ret;\n}\nint dinic() {\n  int ret = 0;\n  while (bfs()) {\n    ret += dfs(S, INF);\n  }\n  return ret;\n}\n\nconst int N = 100233;\nint n, visit[N], son[N], fa[N];\nvector<int> e[N], g[N];\nint main() {\n  scanf(\"%d\", &n);\n  S = 0, T = n * 2 + 1;\n  for (int i = 1, t, x; i < n; i++) {\n    adde(S, i, 1);\n    scanf(\"%d\", &t);\n    while (t--) {\n      scanf(\"%d\", &x);\n      e[i].push_back(x);\n      g[x].push_back(i);\n      if (x > 1) adde(i, x + n, 1);\n    }\n  }\n  for (int i = 2; i <= n; i++) {\n    adde(i + n, T, 1);\n  }\n  int p = dinic();\n  if (p < n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    for (int e = hed[i]; e; e = edge[e].nxt) {\n      if (edge[e].to > n && !edge[e].c) {\n        son[i] = edge[e].to - n;\n      }\n    }\n  }\n  queue<int> q;\n  for (auto x : g[1]) {\n    q.push(x);\n    visit[x] = 1;\n    fa[x] = 1;\n  }\n  while (!q.empty()) {\n    int x = q.front();\n    q.pop();\n    for (auto y : g[son[x]]) {\n      if (!visit[y]) {\n        q.push(y);\n        visit[y] = 1;\n        fa[y] = son[x];\n      }\n    }\n  }\n  if (accumulate(visit + 1, visit + n, 0) != n - 1) return puts(\"-1\"), 0;\n  for (int i = 1; i < n; i++) {\n    printf(\"%d %d\\n\", fa[i], son[i]);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<climits>\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define LL long long\n//#define getchar() (p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, 1 << 21, stdin), p1 == p2) ? EOF : *p1++)\n//char buf[(1 << 21) + 1], *p1 = buf, *p2 = buf;\ninline int read() {\n\tbool f=0;int x=0;char c=getchar();\n\twhile(c<'0'||'9'<c){if(c==EOF)exit(0);if(c=='-')f=1;c=getchar();}\n\twhile('0'<=c&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();\n\treturn !f?x:-x;\n}\n#define MAXN 200000\n#define MAXM 500000\n#define INF 0x3f3f3f3f\nstruct Edge{\n\tint nxt,v,cap;\n}edge[2*MAXM+5];\nint ecnt,head[MAXN+5],cur[MAXN+5];\nvoid Init(){\n\tecnt=-1,memset(head,-1,sizeof(head));\n\treturn ;\n}\nvoid Addedge(int u,int v,int cap){\n\t//printf(\"%d %d %d\\n\",u,v,cap);\n\tedge[++ecnt]=(Edge){head[u],v,cap},head[u]=ecnt;\n\tedge[++ecnt]=(Edge){head[v],u,0},head[v]=ecnt;\n\treturn ;\n}\nint N,S,T;\nint dep[MAXN+5];\nbool BFS(){\n\tqueue<int> Q;\n\tfor(int i=0;i<=N;i++)\n\t\tdep[i]=INF;\n\tdep[S]=0,Q.push(S);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=head[u];~i;i=edge[i].nxt){\n\t\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\t\tif(dep[v]==INF&&cap)\n\t\t\t\tdep[v]=dep[u]+1,Q.push(v);\n\t\t}\n\t}\n\treturn dep[T]<INF;\n}\nint DFS(int u,int aug){\n\tif(u==T) return aug;\n\tint flow=0,f;\n\tfor(int &i=cur[u];~i;i=edge[i].nxt){\n\t\tint v=edge[i].v,cap=edge[i].cap;\n\t\tif(dep[v]==dep[u]+1&&cap&&(f=DFS(v,min(aug,cap)))){\n\t\t\taug-=f,flow+=f;\n\t\t\tedge[i].cap-=f,edge[i^1].cap+=f;\n\t\t\tif(!aug) break;\n\t\t}\n\t}\n\treturn flow;\n}\nint Dinic(){\n\tint Max_Flow=0;\n\twhile(BFS())\n\t\tmemcpy(cur,head,sizeof(head)),Max_Flow+=DFS(S,INF);\n\treturn Max_Flow;\n}\nqueue<int> Q;\nint ma[MAXN+5];\nbool vis[MAXN+5];\nvector<int> G[MAXN+5];\nint cho1[MAXN+5],cho2[MAXN+5];\nint main(){\n\tInit();\n\tint n=read();\n\tN=2*n+2,S=2*n+1,T=2*n+2;\n\tfor(int i=1;i<n;i++)\n\t\tAddedge(S,i,1);\n\tfor(int i=2;i<=n;i++)\t\n\t\tAddedge(i+n-1,T,1);\n\tfor(int i=1;i<n;i++){\n\t\tint c=read();\n\t\tfor(int j=1;j<=c;j++){\n\t\t\tint w=read();\n\t\t\tG[w].push_back(i);\n\t\t\tif(w!=1)\n\t\t\t\tAddedge(i,w+n-1,1);\n\t\t}\n\t}\n\tint ans=Dinic();\n\tif(ans!=n-1)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int s=1;s<n;s++)\n\t\tfor(int i=head[s];~i;i=edge[i].nxt)\n\t\t\tif(!edge[i].cap)\n\t\t\t\tma[s]=edge[i].v-(n-1);\n\tQ.push(1);\n\tint cnt=0;\n\twhile(!Q.empty()){\n\t\tcnt++;\n\t\tint u=Q.front();Q.pop();\n\t\tfor(int i=0;i<(int)G[u].size();i++){\n\t\t\tint s=G[u][i];\n\t\t\tif(vis[s]) continue;\n\t\t\tvis[s]=1,Q.push(ma[s]);\n\t\t\tcho1[s]=u,cho2[s]=ma[s];\n\t\t}\n\t}\n\tif(cnt!=n)\n\t\tputs(\"-1\"),exit(0);\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",cho1[i],cho2[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct Matching2 { // for bipartite graph\n    vector<int>matchM, matchW, use;\n    int ans;\n    bool dfs(const VI G[], int v) {\n\tif (use[v]) return false;\n\tuse[v] = true;\n\tfor (int i=0; i<(int)G[v].size(); i++) {\n\t    int u = G[v][i];\n\t    if (matchW[u] == -1 || dfs(G, matchW[u])) {\n\t\tmatchM[v] = u;\n\t\tmatchW[u] = v;\n\t\treturn true;\n\t    }\n\t}\n\treturn false;\n    }\n    Matching2(const VI G[], int sizeM, int sizeW): matchM(sizeM, -1), matchW(sizeW, -1), ans(0) {\n\tuse = vector<int>(sizeM, 0);\n\tfor (int i=0; i<sizeM; i++) {\n\t    fill(use.begin(), use.end(), 0);\n\t    if (dfs(G, i)) ans++;\n\t}\n    }\n};\n\nint N;\nVI E[100011];\nVI R[100011];\nVI G[100011];\nbool use[100011];\npair<int, int> ans[100011];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N-1) {\n\tint K;\n\tscanf(\"%d\", &K);\n\tE[i].resize(K);\n\tREP (j, K) scanf(\"%d\", &E[i][j]), E[i][j]--;\n    }\n\n    REP (i, N-1) {\n\tG[i] = E[i];\n\tG[i].erase(remove(G[i].begin(), G[i].end(), N-1), G[i].end());\n\tEACH (e, E[i]) R[*e].push_back(i);\n    }\n\n    Matching2 X(G, N-1, N-1);\n\n    if (X.ans == N-1) {\n\tVI ord; ord.reserve(N);\n\tord.push_back(N-1);\n\tuse[N-1] = true;\n\tfor (int i=0; i<(int)ord.size(); i++) {\n\t    int v = ord[i];\n\t    EACH (e, R[v]) if (!use[*e]) {\n\t\tint w = X.matchM[*e];\n\t\tans[*e] = make_pair(v, w);\n\t\tord.push_back(w);\n\t\tuse[*e] = true;\n\t    }\n\t}\n\n\tif ((int)ord.size() == N) {\n\t    REP (i, N-1) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t    return;\n\t}\n    }\n    puts(\"-1\");\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]++]==0)d[s]=t+3;\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n \n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n \nusing namespace std;\ntypedef long long ll;\nconst ll N=22e4,M=N<<1,K=M<<1;\n \ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n \nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\nint y[M];\n \nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n \ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n \ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n \ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n\tfo(i,1,T)y[i]=la[i];\n}\n \ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(;y[o];y[o]=ne[y[o]])\n\tif(dep[lb[y[o]]]==dep[o]+1&&c[y[o]])\n\tif(flow(lb[y[o]])){\n\t\tc[y[o]]=0;\n\t\tc[y[o]^1]=1;\n\t\treturn 1;\n\t}\n\tdep[o]=-1;\n\treturn 0;\n}\n \ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[re[lb[y]]][0]=o;\n\t\tbb[re[lb[y]]][1]=lb[y];\n\t\t++oo;\n\t\tdg(lb[y]);\n\t}\n}\n \nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse while(flow(S))++ans;\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst int S=0,T=1;\nstruct bian\n{\n\tint nxt,to,f;\n}bi[1000010];\nint n,head[200020],num=1,cur[200020],dep[200020],flow,match[200020],f[200020];\nvector<int>E[100010];\ninline void add(int from,int to,int f){bi[++num]=bian{head[from],to,f};head[from]=num;}\ninline void ADD(int from,int to,int f){add(from,to,f),add(to,from,0);}\nint q[200020],h,t;\nbool bfs()\n{\n\tmemset(dep,0,sizeof(dep));\n\tmemcpy(cur,head,sizeof(cur));\n\th=0,t=1;q[t]=S;dep[S]=1;\n\tint x,y;\n\twhile(h<t)\n\t{\n\t\tx=q[++h];\n\t\tfor(int i=head[x];i;i=bi[i].nxt)\n\t\t\tif(bi[i].f)\n\t\t\t{\n\t\t\t\ty=bi[i].to;\n\t\t\t\tif(!dep[y])dep[y]=dep[x]+1,q[++t]=y;\n\t\t\t}\n\t}\n\treturn dep[T]!=0;\n}\nint dfs(int v,int last)\n{\n//\tprintf(\"%d %d\\n\",v,last);\n\tif(v==T)\n\t{\n\t\tflow+=last;\n\t\treturn last;\n\t}\n\tint now=0;\n\tfor(int &i=cur[v],u;i;i=bi[i].nxt)\n\t\tif(bi[i].f)\n\t\t{\n\t\t\tu=bi[i].to;\n\t\t\tif(dep[u]!=dep[v]+1)continue;\n\t\t\tint dmin=dfs(u,min(last,bi[i].f));\n\t\t\tbi[i].f-=dmin,bi[i^1].f+=dmin;\n\t\t\tlast-=dmin,now+=dmin;\n\t\t\tif(!last)return now;\n\t\t}\n\treturn now;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=2;i<=n;++i)ADD(S,i,1);\n\tfor(int i=1;i<n;++i)ADD(i+n,T,1);\n\tint x;\n\tfor(int i=1;i<=n-1;++i)\n\t{\n\t\tint cnt;\n\t\tscanf(\"%d\",&cnt);\n\t\tfor(int j=1;j<=cnt;++j)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tE[x].push_back(i);\n\t\t\tif(x>1)ADD(x,i+n,1);\n\t\t}\n\t}\n//\tfor(int i=0;i<=2*n;++i)\n//\t\tfor(int j=head[i];j;j=bi[j].nxt)\n//\t\t\tprintf(\"%d %d %d\\n\",i,bi[j].to,bi[j].f);\n\twhile(bfs())\n\t\twhile(dfs(S,0x3f3f3f3f));\n//\tprintf(\"%d\\n\",flow);\n\tif(flow!=n-1){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=n-1;++i)\n\t\tfor(int j=head[i+n];j;j=bi[j].nxt)\n\t\t\tif(bi[j].to<=n&&bi[j].f){match[i]=bi[j].to;break;}\n//\tfor(int i=1;i<=n-1;++i)printf(\"%d \",match[i]);printf(\"\\n\");\n\tmemset(dep,0,sizeof(dep));\n\th=0,t=1;q[t]=1;\n\twhile(h<t)\n\t{\n\t\tx=q[++h];\n\t\tfor(auto y:E[x])\n\t\t\tif(!dep[y])\n\t\t\t{\n\t\t\t\tdep[y]=1;\n\t\t\t\tq[++t]=match[y];\n\t\t\t\tf[match[y]]=x;\n\t\t\t}\n\t}\n\tif(t!=n){printf(\"-1\");return 0;}\n\tfor(int i=1;i<=n-1;++i)printf(\"%d %d\\n\",match[i],f[match[i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nstruct Edge{int go; int c; int f;};\nvector<int> where, d, vert;\nvector<Edge> edges;\nvector<bool> used;\nvector<vector<int> > data;\nint number, m;\nqueue<int> q;\nint INF = 1e15;\nvoid construct_edge(int u, int v, int c){\n    Edge e1 = {v, c, 0};\n\tEdge e2 = {u, 0, 0};\n    edges.push_back(e1);\n\tedges.push_back(e2);\n\tdata[u].push_back(edges.size() - 2);\n\tdata[v].push_back(edges.size() - 1);\n}\nint dfs(int vertex, int flow, int maximum){\n    if (vertex == number - 1) return flow;\n    while (where[vertex] < data[vertex].size()){\n        int i = where[vertex];\n\t\tint edge_number = data[vertex][i];\n        int to = edges[edge_number].go;\n        int can = min(edges[edge_number].c - edges[edge_number].f, flow);\n        if (can < maximum || d[to] != d[vertex] + 1) {\n            where[vertex]++;\n            continue;\n        }\n        int fl = dfs(to, can, maximum);\n        if (fl >= maximum){\n            edges[edge_number].f += fl;\n            edges[edge_number^1].f -= fl;\n            return fl;\n        }\n        where[vertex]++;\n    }\n    return 0;\n}\nvoid bfs(int maximum){\n    while (!q.empty()){\n        int vertex = q.front();\n        q.pop();\n        for (int i=0; i < data[vertex].size(); i++){\n\t\t\tint edge_number = data[vertex][i];\n            int nv = edges[edge_number].go;\n            int can = edges[edge_number].c - edges[edge_number].f;\n            if (d[nv] == -1 && can >= maximum){\n                d[nv] = d[vertex] + 1;\n                q.push(nv);\n            }\n        }\n    }\n}\nvoid DFS(int vertex){\n    used[vertex] = true;\n    vert.push_back(vertex);\n    for (int i=0; i < data[vertex].size(); i++){\n        int e = data[vertex][i];\n        if (edges[e].f == edges[e].c) continue;\n        if (used[edges[e].go]) continue;\n        DFS(edges[e].go);\n    }\n}\nint dinic(){\n    int A = 1LL << 60;\n    while (A > 0){\n        while (true){\n            for (int i=0; i < number; i++){\n                where[i] = 0;\n                d[i] = -1;\n            }\n            d[0] = 0;\n            q.push(0);\n            bfs(A);\n            if (d[number-1] == -1) break;\n            while (true){\n                int flow = dfs(0, INF, A);\n                if (flow < A) break;\n            }\n        }\n        A /= 2;\n    }\n    int ans = 0;\n    for (int i=0; i < data[0].size(); i++){\n        ans += edges[data[0][i]].f;\n    }\n    return ans;\n}\nsigned main()\n{\n    int n;\n    cin >> n;\n    number = 2*n+1;\n    for (int i=0; i < number; i++){\n        where.push_back(0);\n        used.push_back(false);\n        d.push_back(0);\n        vector<int> help;\n        data.push_back(help);\n    }\n    for (int i=0; i < n-1; i++) construct_edge(0, i+1, 1);\n    for (int i=0; i < n; i++) construct_edge(n+i, number-1, 1);\n    vector<vector<int> > where(n), tot(n-1);\n    for (int i=0; i < n-1; i++){\n        int x;\n        cin >> x;\n        for (int j=0; j < x; j++){\n            int a;\n            cin >> a;\n            tot[i].push_back(a-1);\n            where[a-1].push_back(i);\n            construct_edge(i+1, n+a-1, 1);\n        }\n    }\n    int res = dinic();\n    if (res != n-1){\n        cout << -1;\n        return 0;\n    }\n    vector<int> nei;\n    for (int i=1; i < n; i++){\n        for (int j=0; j < data[i].size(); j++){\n            if (data[i][j] % 2 != 0) continue;\n            int num = data[i][j];\n            if (edges[num].f > 0){\n                nei.push_back(edges[num].go - n);\n            }\n        }\n    }\n    //for (int i=0; i < n-1; i++) cout << nei[i] << endl;\n    set<int> kek;\n    for (int i=0;i<n-1; i++) kek.insert(nei[i]);\n    for (int i=0; i < n; i++) if (!kek.count(i)) nei.push_back(i);\n    set<int> may;\n    set<int> used, e;\n    e.insert(nei.back());\n    for (int i=0; i < where[nei.back()].size(); i++){\n        may.insert(where[nei.back()][i]);\n    }\n    vector<pair<int, int> > ans(n-1);\n    for (int i=0; i < n-1; i++){\n        if (!may.size()){\n            cout <<-1;\n            return 0;\n        }\n        auto it = may.begin();\n        int num = *it;\n        may.erase(it);\n        int element = nei[num];\n        for (int j=0; j < tot[num].size(); j++){\n            int N = tot[num][j];\n            if (e.count(N)){\n                ans[num] = {N, element};\n                break;\n            }\n        }\n        used.insert(num);\n        e.insert(element);\n        for (int j=0; j < where[element].size(); j++){\n            int T = where[element][j];\n            if (!used.count(T)) may.insert(T);\n        }\n    }\n    for (int i=0;i<n-1;i++) cout << ans[i].first+1 << \" \" << ans[i].second+1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#include<cstring>\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\nconst int INF=1e9;\n\nint n;\nvector<int> rec[100010];\nstruct Edge{\n\tint to,nxt,val;\n}edge[800010];\nint cnt=1,last[200010],S=2e5+1,T=2e5+2,lastcur[200010];\ninline void addedge(int x,int y){\n//\tprintf(\"addedge %d->%d\\n\",x,y);\n\tedge[++cnt]=(Edge){y,last[x],1},last[x]=cnt;\n\tedge[++cnt]=(Edge){x,last[y],0},last[y]=cnt;\n}\nint dep[200010]; int que[200010],hd,tl;\nbool bfs(){\n\tmemset(dep+1,-1,T*sizeof(int)); hd=tl=0;\n\tdep[S]=1; que[++tl]=S;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (edge[i].val&&!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tif (v==T) return 1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int cur,int flw){\n//\tprintf(\"dfs %d %d\\n\",cur,flw);\n\tif (cur==T) return flw;\n\tint tmp,used=0;\n\tfor (int &i=lastcur[cur],v;i;i=edge[i].nxt)\n\t\tif (edge[i].val&&dep[cur]+1==dep[v=edge[i].to]){\n\t\t\ttmp=dfs(v,min(flw-used,edge[i].val));\n\t\t\tedge[i].val-=tmp; edge[i^1].val+=tmp;\n\t\t\tused+=tmp; if (used==flw) return used;\n\t\t}\n\tif (!used) dep[cur]=-1;\n\treturn used;\n}\nint maxflow(){\n\tint res=0;\n\twhile (bfs()){\n\t\tmemcpy(lastcur+1,last+1,T*sizeof(int));\n\t\tres+=dfs(S,INF);\n\t}\n\treturn res;\n}\nint chosen[100010];\ntypedef pair<int,int> P;\nvector<P> ans;\nbool vis[100010];\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\taddedge(S,i+1),addedge(i+n,T);\n\t\tfor (int c=read(),t;c--;){\n\t\t\tt=read(); rec[t].push_back(i);\n\t\t\taddedge(t,i+n);\n\t\t}\n\t}\n\tif (maxflow()^(n-1)) return puts(\"-1\"),0;\n\tfor (int i=2;i<=n;i++)\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt)\n\t\t\tif ((v=edge[j].to)>n&&(edge[j].val^1)){\n\t\t\t\tchosen[v-n]=i; break;\n\t\t\t}\n\thd=tl=0; que[++tl]=1; vis[1]=1;\n\tans.resize(n); int tot=0;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=0;i<rec[u].size();i++){\n\t\t\tv=chosen[rec[u][i]];\n\t\t\tif (!vis[v]) vis[v]=1,que[++tl]=v,ans[rec[u][i]]=(P){u,v},tot++;\n\t\t}\n\t}\n\tif (tot!=n-1) return puts(\"-1\"),0;\n\tfor (int i=1;i<n;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<climits>\n#include<queue>\n\ntypedef long long LL;\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\n\nint read()\n{\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)) { if(c == '-') f = 0; c = getchar(); }\n\twhile(isdigit(c)) { x = (x * 10) + (c ^ 48); c = getchar(); }\n\treturn f ? x : -x;\n}\n\nconst int maxn = 8e5 + 10, maxm = maxn;\nint to[maxm], nxt[maxm], head[maxn], cap[maxm], e, dep[maxn], flow[maxm], vis[maxn], s, t;\npair<int, int> p[maxn];\n\nvoid add(int x, int y, int z)\n{\n\tto[++e] = y; nxt[e] = head[x]; head[x] = e; cap[e] = z;\n\tto[++e] = x; nxt[e] = head[y]; head[y] = e; cap[e] = 0;\n}\n\nint bfs()\n{\n\tmemset(dep, 0, sizeof(dep));\n\tqueue<int> Q;\n\tdep[s] = 1; Q.push(s);\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif(!dep[v] && cap[i] > flow[i])\n\t\t\t{\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tif(dep[t]) return 1;\n\treturn 0;\n}\n\nint dfs(int x, int a)\n{\n\tif(x == t || a == 0) return a;\n\tint FLOW = 0, f;\n\tfor(int i = head[x]; i; i = nxt[i])\n\t{\n\t\tint v = to[i];\n\t\tif(dep[v] == dep[x] + 1 && (f = dfs(v, min(a, cap[i] - flow[i]))) > 0)\n\t\t{\n\t\t\tFLOW += f;\n\t\t\ta -= f;\n\t\t\tflow[i] += f; flow[i ^ 1] -= f;\n\t\t\tif(!a) return FLOW;\n\t\t}\n\t}\n\treturn FLOW;\n}\n\nint main()\n{\n\n\tint n = read();\n\te = 1; s = 0; t = n + n;\n\tfor(int i = 1; i < n; ++i)\n\t{\n\t\tint m = read();\n\t\tfor(int j = 1; j <= m; ++j)\n\t\t{\n\t\t\tint x = read();\n\t\t\tadd(x, i + n, 1);\n\t\t}\n\t}\n\n\tfor(int i = 2; i <= n; ++i) add(s, i, 1);\n\tfor(int i = n + 1; i <= n + n - 1; ++i) add(i, t, 1);\n\n\twhile(bfs()) dfs(s, 0x3f3f3f3f);\n\tfor(int u = 2; u <= n; ++u)\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(cap[i] == flow[i] && to[i] != s)\n\t\t{\n\t//\t\tcout << u << ' ' << to[i] << endl;\n\t\t\tp[to[i]].x = u;\n\t\t}\n\n\tqueue<int> Q; Q.push(1);\n\tint fg = n - 1;\n\twhile(!Q.empty())\n\t{\n\t\tint u = Q.front(); Q.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i]) if(to[i] != s && !vis[to[i]])\n\t\t\tp[to[i]].y = u, vis[to[i]] = 1, Q.push(p[to[i]].x), --fg;\n\t}\n\tif(fg) return puts(\"-1\"), 0;\n\n\tfor(int i = n + 1; i <= n + n - 1; ++i) printf(\"%d %d\\n\", p[i].x, p[i].y);\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\nconst ll N=12e4,M=N<<1,K=M<<1;\n\ninline int read()\n{\n\tint o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+(ch^48);\n\treturn o;\n}\n\nint ne[K],la[M],lb[K],c[K],bb[N][2];\nint dep[M];\n\nint fa[N],re[N];\nint gs[N];\nint ke[M];\nint be[N],en[N];\nint n,m,S,T,oo;\nint d[M];\n\ninline int get(int o)\n{return (fa[o]==o)?(o):(fa[o]=get(fa[o]));}\n\ninline void llb(int a,int b,int cc)\n{ne[++oo]=la[a]; la[a]=oo; lb[oo]=b; c[oo]=cc;}\n\ninline void bfs()\n{\n\tfo(i,1,T)dep[i]=-1;\n\tdep[S]=0;\n\tint l=0,r=1;\n\td[r]=S;\n\twhile(l<r){\n\t\tint o=d[++l];\n\t\tfor(int y=la[o];y;y=ne[y])\n\t\tif(c[y]==1&&dep[lb[y]]==-1){\n\t\t\tdep[lb[y]]=dep[o]+1;\n\t\t\td[++r]=lb[y];\n\t\t}\n\t}\n}\n\ninline int flow(int o)\n{\n\tif(o==T)return 1;\n\tfor(int y=la[o];y;y=ne[y])\n\tif(dep[lb[y]]==dep[o]+1&&c[y])\n\tif(flow(lb[y])){\n\t\tc[y]=0;\n\t\tc[y^1]=1;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\ninline void dg(int o)\n{\n\tfor(int y=la[o];y;y=ne[y])\n\tif(!fa[lb[y]]){\n\t\tfa[lb[y]]=o;\n\t\tbb[++oo][0]=o;\n\t\tbb[oo][1]=lb[y];\n\t\tdg(lb[y]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n-1){\n\t\tgs[i]=read();\n\t\tbe[i]=oo+1; \n\t\tfo(l,1,gs[i]){\n\t\t\tke[++oo]=read();\n\t\t\tif(l!=1)\n\t\t\tif(get(ke[oo-1])!=get(ke[oo]))fa[fa[ke[oo]]]=fa[ke[oo-1]];\n\t\t}\n\t\ten[i]=oo;\n\t}\n\tint kk=get(1);\n\tfo(i,2,n)if(get(i)!=kk){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tS=n*2,T=S^1,oo=1;\n\tfo(i,1,n)llb(S,i,1),llb(i,S,0);\n\tfo(i,1,n-1)fo(l,be[i],en[i])llb(ke[l],n+i,1),llb(n+i,ke[l],0);\n\tfo(i,1,n-1)llb(n+i,T,1),llb(T,n+i,0);\n\t\n\tint ans=0;\n\twhile(true){\n\t\tbfs();\n\t\tif(dep[T]==-1)break;\n\t\telse ans=ans+flow(S);\n\t}\n\t\n\tif(ans!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\t\n\tint root=0;\n\tfo(i,1,n)fa[i]=0;\n\tfo(i,1,n){\n\t\tint ok=0;\n\t\tfor(int y=la[i];y;y=ne[y])\n\t\tif(c[y]==0&&lb[y]!=S){\n\t\t\tre[i]=lb[y]-n;\n\t\t\tok=1; break;\n\t\t}\n\t\tif(!ok)root=i;\n\t}\n\t\n\too=0;\n\tfo(i,1,n)la[i]=fa[i]=0;\n\tfo(i,1,n)if(root!=i)\n\tfo(l,be[re[i]],en[re[i]])if(ke[l]!=i)llb(ke[l],i,0);\n\tfa[root]=-1;\n\too=0;\n\tdg(root);\n\tif(oo!=n-1)puts(\"-1\");\n\telse fo(i,1,n-1)printf(\"%d %d\\n\",bb[i][0],bb[i][1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    while (!q.empty()) {\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v, done);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//\n//10^5210^5\n//\nnamespace MF{\n\t#define MAXN 25252\n\t#define MAXM 364364//2\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//S\n\t//levS(AOJ2396verify)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//\nbool used[200100];//\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nstd::vector<int> set[maxn];\n\nint head[maxn << 1], nxt[maxn << 2], to[maxn << 2], cap[maxn << 2], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f = dinic(s, t);\n\t\twhile(f) {\n\t\t\tflow += f;\n\t\t\tf = dinic(s, t);\n\t\t}\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[ap] = u;\n\t\t\t\tansy[ap] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n#define N 500001\nusing namespace std;\nint total1,total2;\nint nexts[N],head[N],edge[N],nexts2[N],head2[N],edge2[N];\nint n;\nbool go[N];\nvector<int>s[N];\nvoid insert(int x,int y)\n{\n\ttotal1++;\n\tnexts[total1]=head[x];\n\thead[x]=total1;\n\tedge[total1]=y;\n}\nvoid insert2(int x,int y)\n{\n\ttotal2++;\n\tnexts2[total2]=head2[x];\n\thead2[x]=total2;\n\tedge2[total2]=y;\n}\nvoid dfs(int k,int fa)\n{\n\tgo[k]=true;\n\tinsert2(k,fa);\n\tinsert2(fa,k);\n\tfor (int i=head[k];i;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (go[y]) continue;\n\t\tdfs(y,k);\n\t\tif (k<n) break;\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<n;i++)\n\t{\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) scanf(\"%d\",&s[i][j]);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert(i,s[i][j]+n);\n\t\t\tinsert(s[i][j]+n,i);\t\n\t\t}\n\t}\n\tmemset(go,false,sizeof(go));\n\tdfs(1+n,0);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!go[i+n])\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tif (y>n)\n\t\t\t\tprintf(\"%d \",y-n);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 200005, inf = 0x3f3f3f3f;\n\nint n, s, t, head[N], tot = 1, f[N];\nstruct edge { int to, nxt, rem; } e[N << 2];\nint find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }\n\nvoid link(int x, int y) {\n\te[++tot] = (edge) { y, head[x], 1 }, head[x] = tot;\n\te[++tot] = (edge) { x, head[y], 0 }, head[y] = tot;\n\tif (x != s && y != t) f[find(x)] = find(y);\n}\n\nint dis[N];\nbool bfs() {\n\tstd::memset(dis, 0, sizeof dis), dis[s] = 1;\n\tstd::queue<int> q; q.push(s);\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].rem && !dis[e[i].to])\n\t\t\t\tdis[e[i].to] = dis[tmp] + 1, q.push(e[i].to);\n\t}\n\treturn dis[t] > 0;\n}\nint dinic(int x, int low) {\n\tif (x == t || !low) return low;\n\tint ans = 0, t;\n\tfor (int i = head[x]; i; i = e[i].nxt)\n\t\tif (e[i].rem && dis[e[i].to] > dis[x] && (t = dinic(e[i].to, std::min(low, e[i].rem)))) {\n\t\t\te[i].rem -= t, e[i ^ 1].rem += t, low -= t, ans += t;\n\t\t\tif (!low) break;\n\t\t}\n\treturn ans;\n}\n\nstd::pair<int, int> ans[N];\nint E[N];\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n, s = 0, t = 2 * n;\n\tfor (int i = 1; i < 2 * n; ++i) f[i] = i;\n\tfor (int i = 1, c, x; i < n; ++i) {\n\t\tstd::cin >> c, link(s, i + n);\n\t\twhile (c--) std::cin >> x, link(i + n, x);\n\t}\n\tfor (int i = 2; i <= n; ++i) link(i, t);\n\tfor (int i = 1; i < 2 * n; ++i) if (find(i) != find(1))\n\t\treturn std::cout << \"-1\\n\", 0;\n\tint sum = 0;\n\twhile (bfs()) sum += dinic(s, inf);\n\tif (sum < n - 1) return std::cout << \"-1\\n\", 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = head[i + n]; j; j = e[j].nxt)\n\t\t\tif (e[j].to != s && !e[j].rem) E[i] = e[j].to;\n\tstatic bool vis[N];\n\tstd::queue<int> q; q.push(1), vis[1] = 1;\n\twhile (q.size()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tfor (int i = head[tmp]; i; i = e[i].nxt)\n\t\t\tif (e[i].to != t && !vis[E[e[i].to - n]]) {\n\t\t\t\tvis[E[e[i].to - n]] = 1, q.push(E[e[i].to - n]);\n\t\t\t\tans[e[i].to - n] = std::make_pair(tmp, E[e[i].to - n]);\n\t\t\t}\n\t}\n\tfor (int i = 1; i < n; ++i)\n\t\tstd::cout << ans[i].first << ' ' << ans[i].second << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 2e5+5;\nint par[N] = {};\n\nvoid init(){\n\tfor (int i = 0; i < N; i++)\n\t\tpar[i] = i;\n}\n\nint root(int x) {\n\tif(x == par[x])\treturn x;\n\treturn root(par[x]);\n}\n\nvoid join(int x, int y) {\n\tpar[root(x)] = root(y);\n}\n\nvoid solve() {\n\tll p;\t\n\tcin >> p;\n\tp--;\n\tinit();\n\tvector<pair<int,int>> ans;\n\tbool possible = false;\n\twhile (p--) {\n\t\tll n;\n\t\tcin >> n;\n\t\tll start;\n\t\tcin >> start;\n\t\tn--;\n\t\tbool added =false;\n\t\twhile(n--) {\n\t\t\tll p;\n\t\t\tcin >> p;\n\t\t\tif ((!added) && (root(start) != root(p))) {\n\t\t\t\tjoin(start, p);\n\t\t\t\tadded = true;\n\t\t\t\tans.push_back({start, p});\n\t\t\t} \n\t\t}\n\t\tif (!added) {\n\t\t\tcout << -1 << endl;\treturn;\n\t\t}\n\t}\n\n\tfor (auto x: ans) {\n\t\tcout << x.first << ' ' << x.second << endl;\n\t}\n}\n\nint main() {\n\tll t = 1;\n\t//cin >> t;\n\twhile (t--) {\n\t\tsolve();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<queue>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define N 200500\nqueue<int> tp;\nint n,m,a,head[N],cnt=1,id[N],fa[N],cur[N],dis[N],is[N],ct1;\nvector<int> st2[N];\nstruct edge{int t,next,v;}ed[N*4];\nvoid adde(int f,int t,int v){ed[++cnt]=(edge){t,head[f],v};head[f]=cnt;ed[++cnt]=(edge){f,head[t],0};head[t]=cnt;}\nbool bfs(int s,int t)\n{\n\tmemset(dis,-1,sizeof(dis));\n\tmemcpy(cur,head,sizeof(cur));\n\tdis[s]=0;\n\tqueue<int> st;st.push(s);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tfor(int i=head[a];i;i=ed[i].next)\n\t\tif(ed[i].v&&dis[ed[i].t]==-1)\n\t\t{\n\t\t\tdis[ed[i].t]=dis[a]+1,st.push(ed[i].t);\n\t\t\tif(ed[i].t==t)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int u,int t,int f)\n{\n\tif(u==t||!f)return f;\n\tint as=0,tp;\n\tfor(int &i=cur[u];i;i=ed[i].next)\n\tif(ed[i].v&&dis[ed[i].t]==dis[u]+1&&(tp=dfs(ed[i].t,t,min(ed[i].v,f))))\n\t{\n\t\tas+=tp,f-=tp;ed[i].v-=tp;ed[i^1].v+=tp;\n\t\tif(!f)return as;\n\t}\n\treturn as;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++)scanf(\"%d\",&a),st2[a].push_back(i),adde(a,i+n,1);\n\t}\n\tfor(int i=1;i<n;i++)adde(2*n,i+1,1),adde(i+n,2*n+1,1);\n\tint as=0;while(bfs(n*2,n*2+1))\n\tas+=dfs(n*2,n*2+1,n);\n\tif(as<n-1){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tfor(int j=head[i+n];j;j=ed[j].next)if(ed[j].v)id[i]=ed[j].t;\n\tqueue<int> st;\n\tst.push(1);\n\twhile(!st.empty())\n\t{\n\t\tint a=st.front();st.pop();\n\t\tct1++;\n\t\tfor(int j=0;j<st2[a].size();j++)if(!fa[id[st2[a][j]]])fa[id[st2[a][j]]]=a,st.push(id[st2[a][j]]);\n\t}\n\tif(ct1<n){printf(\"-1\\n\");return 0;}\n\tfor(int i=1;i<n;i++)printf(\"%d %d\\n\",fa[id[i]],id[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][3];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z,int z1)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf,inf);\n\tinsert(S,T,0,inf);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i],inf);insert(i,SS,0,inf);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i],inf);insert(TT,i,0,inf);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j],down[j]);\n\t\t\tinsert(y,i,0,down[j]);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tfor (int i=2;i<=total2;i++)\n\t\t{\n\t\t\tif (v1[i]>=inf) continue;\n\t\t\tif (v1[i]+v[i^1]==1)\n\t\t\t{\n\t\t\t\tint u1=edge[i];\n\t\t\t\tint u2=edge[i^1];\n\t\t\t\tif (u1<u2)\n\t\t\t\t{\n\t\t\t\t\tint t=u1;u1=u2;u2=t;\n\t\t\t\t}\n\t\t\t\tu1=(u1+n-1)%n+1;\n\t\t\t\tu2=(u2+n-1)%n+1;\n\t\t\t\tans[u1][0]++;\n\t\t\t\tans[u1][ans[u1][0]]=u2;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<n;i++) \n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][2]);\n//\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 1e5+5;\nconst int M = 5e6+5;\nconst int INF = 1e9;\n\nint n;\nvector<int> pt[N];\n\nint st,ed;\nstruct edge{\n\tint x,f,nxt;\n}e[M];\nint h[N*2],tot;\n\nvoid addedge(int x,int y,int f){e[++tot].x=y;e[tot].f=f;e[tot].nxt=h[x];h[x]=tot;}\n\nvoid inse(int x,int y,int f){\n\taddedge(x,y,f);\n\taddedge(y,x,0);\n}\n\nint dis[N*2],que[N*2];\nint vt[N*2],tim;\n\nbool bfs(){\n\ttim++;\n\tint he=0,ta=1;\n\tdis[que[1]=st]=0;\n\tvt[st]=tim;\n\tfor(;he<ta;){\n\t\tint x=que[++he];\n\t\tfor(int p=h[x];p;p=e[p].nxt){\n\t\t\tint y=e[p].x;\n\t\t\tif (vt[y]<tim&&e[p].f){\n\t\t\t\tvt[y]=tim;\n\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\tque[++ta]=y;\t\n\t\t\t}\n\t\t}\n\t}\n\treturn vt[ed]==tim;\n}\n\nint aug(int x,int f){\n\tif (x==ed)return f;\n\tint ret=0;\n\tfor(int p=h[x];p;p=e[p].nxt)\n\tif (e[p].f&&vt[e[p].x]==tim&&dis[e[p].x]==dis[x]+1){\n\t\tint o=aug(e[p].x,min(f,e[p].f));\n\t\tf-=o,ret+=o;\n\t\te[p].f-=o,e[p^1].f+=o;\n\t\tif (!f)return ret;\n\t}\n\treturn ret;\n}\n\nint to[N];\npair<int,int>ans[N];\nint k;\nbool vis[N*2];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto u:pt[x])\n\tif (!vis[u]){\n\t\tvis[u]=1;\n\t\tk++;\n\t\tans[u-n]=make_pair(x,to[u]);\n\t\tdfs(to[u]);\n\t}\n}\n\nint main(){\n\tn=get();\n\ttot=1;\n\tst=n*2,ed=n*2+1;\n\tfo(i,1,n-1){\n\t\tint k=get();\n\t\tinse(st,n+i,1);\n\t\tfo(j,1,k){\n\t\t\tint x=get();\n\t\t\tif (x>1)inse(n+i,x,1);\n\t\t\tpt[x].push_back(n+i);\n\t\t}\n\t}\n\tfo(i,1,n)inse(i,ed,1);\n\tint ret=0;\n\twhile(bfs())\n\t\tret+=aug(st,INF);\n\tif (ret!=n-1)return printf(\"-1\\n\"),0;\n\tfo(i,n+1,n*2-1){\n\t\tfor(int p=h[i];p;p=e[p].nxt)\n\t\tif (!e[p].f&&e[p].x>1&&e[p].x<=n){\n\t\t\tto[i]=e[p].x;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs(1);\n\tif (k<n-1)return printf(\"-1\\n\"),0;\n\tfo(i,1,k)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=200010;\nstruct edge{\n\tint y,next,c;\n}s[N<<3];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[st]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t\tif(t==tot) break;\n\t}\n\tif(!tot) d[x]=0;\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(c[P[c[x]][i]]!=c[x] && !las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\\n\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],gap[N << 1],dis[N << 1],pos[N],vis[N];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline int isap(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int i = beg[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = isap(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]];\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tfor(gap[0] = T;dis[S] < T;) ans += isap(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[++tot] = mp(x,pos[cur]),Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <sstream>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <cstdlib>\n#include <cstdio>\n#include <iterator>\n#include <functional>\n#include <bitset>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\nclock_t __my_start_clock = clock();\n#else\n#define eprintf(...)\n#endif\n\n#define TIMESTAMP(x) eprintf(\"[\"#x\"] Time : %.3lf s.\\n\", (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n#define TIMESTAMPf(x,...) eprintf(\"[\" x \"] Time : %.3lf s.\\n\", __VA_ARGS__, (clock() - __my_start_clock)*1.0/CLOCKS_PER_SEC)\n\nusing namespace std;\n\n#ifdef LOCAL\nstatic struct __timestamper {\n  string what;\n  __timestamper(const char* what) : what(what){};\n  __timestamper(const string& what) : what(what){};\n  ~__timestamper(){\n    TIMESTAMPf(\"%s\", what.data());\n\t}\n} __TIMESTAMPER(\"end\");\n#else \nstruct __timestamper {};\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nclass MaxFlow {\n\n  typedef long long flow_type;\n  const flow_type FLOW_INF = 1LL << 60;\npublic:\n\n  struct Edge {\n    int to, next;\n    flow_type f, c;\n  };\n\n  vector<Edge> es;\n  int n;\n  vector<int> head;\n  vector<int> d;\n  vector<int> ptr;\n\n  flow_type dfs(int s, int t, flow_type have, flow_type min_edge) {\n    if (s == t) {\n      return have;\n    }\n    flow_type res = 0;\n    for (int &i = ptr[s]; i != -1; i = es[i].next) {\n      int to = es[i].to;\n      if (d[to] != d[s] + 1) continue;\n      if (es[i].c < min_edge) continue;\n      flow_type done = dfs(to, t, min(have, es[i].c), min_edge);\n      pushFlow(i, done);\n      have -= done;\n      res += done;\n      if (have == 0) break;\n    }\n    return res;\n  }\n\n  bool bfs(int s, int t, flow_type min_edge) {\n    queue<int> q;\n    d = vector<int>(n, -1);\n    d[s] = 0;\n    q.push(s);\n    while (!q.empty()) {\n      int v = q.front();\n      q.pop();\n      int e = head[v];\n      while (e != -1) {\n        if (es[e].c >= min_edge) {\n          int to = es[e].to;\n          if (d[to] == -1) {\n            d[to] = d[v] + 1;\n            q.push(to);\n          }\n        }\n        e = es[e].next;\n      }\n    }\n    return d[t] != -1;\n  }\n\n  explicit MaxFlow(int n) : n(n), head(n, -1) {}\n\n  int addVertex() {\n    int id = n++;\n    head.push_back(-1);\n    return id;\n  }\n\n  int addEdge(int from, int to, flow_type c, flow_type rc = 0) {\n    int id = (int) es.size();\n    es.push_back({to, head[from], 0, c});\n    head[from] = id;\n    es.push_back({from, head[to], 0, rc});\n    head[to] = id ^ 1;\n    return id;\n  }\n\n  void pushFlow(int eid, flow_type val) {\n    es[eid].f += val, es[eid].c -= val;\n    es[eid ^ 1].f -= val, es[eid ^ 1].c += val;\n  }\n\n  flow_type getFlow(int s, int t) {\n    flow_type res = 0;\n    for (flow_type i = FLOW_INF; i >= 1; i /= 2) {\n      while (bfs(s, t, i)) {\n        ptr = head;\n        res += dfs(s, t, FLOW_INF, i);\n      }\n    }\n    return res;\n  }\n};\n\n\nint main() {\n#ifdef LOCAL\n  freopen(\"f.in\", \"r\", stdin);\n  freopen(\"f.out\", \"w\", stdout);\n#endif\n\n  int n;\n  while (scanf(\"%d\", &n) == 1) {\n\n    MaxFlow flow(2 * n);\n    vector<vector<int>> in_set(n);\n    vector<vector<pair<int, int>>> id(n);\n\n    bool have0 = false;\n    \n    for (int i = 0; i < n - 1; i++) {\n      int c;\n      scanf(\"%d\", &c);\n      for (int j = 0; j < c; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        --x;\n        in_set[x].push_back(i);\n        if (x != 0) {\n          id[i].emplace_back(x, flow.addEdge(i, x + (n - 1) - 1, 1));\n        } else {\n          id[i].emplace_back(0, -1);\n          have0 = true;\n        }\n      }\n    }\n    for (int i = 0; i < n - 1; i++) {\n      flow.addEdge(2 * n - 2, i, 1);\n      flow.addEdge(i + (n - 1), 2 * n - 1, 1);\n    }\n    if (!have0 || flow.getFlow(2 * n - 2, 2 * n - 1) != n - 1) {\n      printf(\"-1\\n\");\n      continue;\n    }\n    vector<int> vin(n);\n    vin[0] = 1;\n    vector<int> active(n - 1);\n    queue<int> q;\n    for (int i : in_set[0]) {\n      active[i] = true;\n      q.push(i);\n    }\n    while (!q.empty()) {\n      int i = q.front();\n      q.pop();\n      int v = -1;\n      int done = -1;\n      for (auto x : id[i]) {\n        if (x.second != -1 && flow.es[x.second].f) {\n          v = x.first;\n        } else if (vin[x.first]) {\n          done = x.first;\n        }\n      }\n      assert(v != -1);\n      assert(done != -1);\n      vin[v] = true;\n      printf(\"%d %d\\n\", v, done);\n      for (int u : in_set[v]) {\n        if (!active[u]) {\n          q.push(u);\n          active[u] = true;\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[4*N],cnt=1,s,t,ma[N];\nint d[4*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[10*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1;\n\t\tson[x].push_back(ma[v[x][i]]);\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cctype>\n#include<vector>\n#include<cstring>\nusing namespace std;\n#define G getchar()\nint read()\n{\n\tint x=0; char ch=G;\n\tfor (;!isdigit(ch);ch=G);\n\tfor (;isdigit(ch);ch=G) x=(x<<3)+(x<<1)+(ch^48);\n\treturn x;\n}\n#undef G\nconst int INF=1e9;\n\nint n;\nvector<int> rec[100010];\nstruct Edge{\n\tint to,nxt,val;\n}edge[800010];\nint cnt=1,last[200010],S=2e5+1,T=2e5+2,lastcur[200010];\ninline void addedge(int x,int y){\n//\tprintf(\"addedge %d->%d\\n\",x,y);\n\tedge[++cnt]=(Edge){y,last[x],1},last[x]=cnt;\n\tedge[++cnt]=(Edge){x,last[y],0},last[y]=cnt;\n}\nint dep[200010]; int que[200010],hd,tl;\nbool bfs(){\n\tmemset(dep+1,-1,T*sizeof(int)); hd=tl=0;\n\tdep[S]=1; que[++tl]=S;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=last[u];i;i=edge[i].nxt)\n\t\t\tif (edge[i].val&&!~dep[v=edge[i].to]){\n\t\t\t\tdep[v]=dep[u]+1;\n\t\t\t\tif (v==T) return 1;\n\t\t\t\tque[++tl]=v;\n\t\t\t}\n\t}\n\treturn 0;\n}\nint dfs(int cur,int flw){\n//\tprintf(\"dfs %d %d\\n\",cur,flw);\n\tif (cur==T) return flw;\n\tint tmp,used=0;\n\tfor (int &i=lastcur[cur],v;i;i=edge[i].nxt)\n\t\tif (edge[i].val&&dep[cur]+1==dep[v=edge[i].to]){\n\t\t\ttmp=dfs(v,min(flw-used,edge[i].val));\n\t\t\tedge[i].val-=tmp; edge[i^1].val+=tmp;\n\t\t\tused+=tmp; if (used==flw) return used;\n\t\t}\n\tif (!used) dep[cur]=-1;\n\treturn used;\n}\nint maxflow(){\n\tint res=0;\n\twhile (bfs()){\n\t\tmemcpy(lastcur+1,last+1,T*sizeof(int));\n\t\tres+=dfs(S,INF);\n\t}\n\treturn res;\n}\nint chosen[100010];\ntypedef pair<int,int> P;\nvector<P> ans;\nbool vis[100010];\nint main()\n{\n\tn=read();\n\tfor (int i=1;i<n;i++){\n\t\taddedge(S,i+1),addedge(i+n,T);\n\t\tfor (int c=read(),t;c--;){\n\t\t\tt=read(); rec[t].push_back(i);\n\t\t\taddedge(t,i+n);\n\t\t}\n\t}\n\tif (maxflow()^(n-1)) return puts(\"-1\"),0;\n\tfor (int i=2;i<=n;i++)\n\t\tfor (int j=last[i],v;j;j=edge[j].nxt)\n\t\t\tif ((v=edge[j].to)>n&&(edge[j].val^1)){\n\t\t\t\tchosen[v-n]=i; break;\n\t\t\t}\n\thd=tl=0; que[++tl]=1; vis[1]=1;\n\twhile (hd<tl){\n\t\tint u=que[++hd],v;\n\t\tfor (int i=0;i<rec[u].size();i++){\n\t\t\tv=chosen[rec[u][i]];\n\t\t\tif (!vis[v]) vis[v]=1,que[++tl]=v,ans.push_back((P){u,v});\n\t\t}\n\t}\n\tif (ans.size()!=n-1) return puts(\"-1\"),0;\n\tfor (int i=0;i<n-1;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\n#define def(i,x,y)for(int i=x;i>=y;--i)\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define fi first\n#define se second\ntypedef long long LL;\ntypedef vector<int> vint;\nconst int N=200010;\nint n;\nnamespace eden{\n\tint op,ed,cnt,head[N],cur[N];\n\tstruct edge{\n\t\tint to,nxt,s;\n\t}e[N];\n\tvoid init(){\n\t\tcnt=1;\n\t\tmemset(e,0,sizeof e);\n\t\tmemset(head,0,sizeof head);\n\t}\n\tvoid add(int x,int y,int s){\n\t\t//cout<<x<<\" \"<<y<<endl;\n\t\te[++cnt]=(edge){y,head[x],s};head[x]=cnt;\n\t\te[++cnt]=(edge){x,head[y],0};head[y]=cnt;\n\t}\n\tqueue<int> q; int dis[N+1];\n\tbool bfs(){\n\t\tq.push(op);\n\t\tref(i,1,ed)dis[i]=1e9;dis[op]=0;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tfor(int i=head[u];i;i=e[i].nxt){\n\t\t\t\tint v=e[i].to;\n\t\t\t\tif(e[i].s&&dis[v]==(int)1e9)dis[v]=dis[u]+1,q.push(v);\n\t\t\t}\n\t\t}\n\t\treturn dis[ed]!=1e9;\n\t}\n\tint dinic(int x,int f){\n\t\tif(x==ed)return f;\n\t\tint res=0;\n\t\tfor(int&i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].to;\n\t\t\tif(dis[y]==dis[x]+1&&e[i].s){\n\t\t\t\tint s=dinic(y,min(f,e[i].s));\n\t\t\t\tf-=s;res+=s;e[i].s-=s;e[i^1].s+=s;\n\t\t\t}\n\t\t\tif(!f)return res;\n\t\t}\n\t\treturn res;\n\t}\n\tint flow(){\n\t\tint ans=0;while(bfs()){\n\t\t\tmemcpy(cur,head,sizeof head);\n\t\t\tans+=dinic(op,1e9);\n\t\t//cout<<ans<<endl;\n\t\t}return ans;\n\t}\n}\nusing namespace eden;\nvint E[N];\nint link[N]; bool vis[N];\nint main(){\n\tcin>>n;\n\top=n*2;ed=op+1;\n\tref(i,1,n-1){\n\t\tint k,x;cin>>k;\n\t\tref(j,1,k){cin>>x;E[x].pb(i);eden::add(x,i+n,1);}\n\t}\n\tref(i,2,n)eden::add(op,i,1);\n\tref(i,1,n-1)eden::add(i+n,ed,1);\n\tif(eden::flow()!=n-1)puts(\"-1\");else{\n\t\tref(i,2,n)for(int j=head[i];j;j=e[j].nxt)if(e[j].to!=op&&e[j].s==0)link[e[j].to-n]=i;\n\t\tqueue<int> q;\n\t\tvector<pair<int,int> >ans;\n\t\tq.push(1);\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tref(j,0,SZ(E[u])-1){\n\t\t\t\tint v=E[u][j];\n\t\t\t\tif(!vis[v])vis[v]=1,q.push(link[v]),ans.push_back(make_pair(u,link[v]));\n\t\t\t}\n\t\t}\n\t\tif(SZ(ans)!=n-1)puts(\"-1\");else\n\t\t\tref(i,0,SZ(ans)-1)cout<<ans[i].fi<<\" \"<<ans[i].se<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111],u[111111],v[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n&&pa)\n\t{\n\t\t::u[pa-n]=gp;\n\t\t::v[pa-n]=u;\n\t}\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=2;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=1;i<n;++i)if(!u[i])return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E(200050 * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0, t;i < In[u].size();++i)\n\t\tif (!done[t = In[u][i]])\n\t\t{\n\t\t\tdone[t] = true;\n\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), dfs(v);\n\t\t}\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 1;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tdfs(1); \n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nint lst[200005], to[2000005], pre[2000005], cap[2000005], tot;\nint dep[200005], que[200005], fst[200005];\ninline void add_edge(int u, int v, int _cap)\n{\n\t// printf(\"%d %d %d\\n\", u, v, _cap);\n\tauto add = [&] (int x, int y, int c)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = c;\n\t\tlst[x] = tot++;\n\t};\n\tadd(u, v, _cap);\n\tadd(v, u, 0);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tint he = 0, ta = 0;\n\tque[ta++] = s;\n\twhile (he < ta)\n\t{\n\t\tint u = que[he++];\n\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t{\n\t\t\tif (cap[i] && dep[to[i]] == -1)\n\t\t\t{\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t\tque[ta++] = to[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tint ans = 0;\n\tfor (int i = fst[u]; ~i; i = pre[i])\n\t{\n\t\tif (cap[i] && dep[to[i]] == dep[u] + 1)\n\t\t{\n\t\t\tint res = dfs(to[i], t, std::min(rem - ans, cap[i]));\n\t\t\tcap[i] -= res;\n\t\t\tcap[i ^ 1] += res;\n\t\t\tif (cap[i])\n\t\t\t\tfst[u] = i;\n\t\t\tans += res;\n\t\t\tif (ans == rem)\n\t\t\t\treturn ans;\n\t\t}\n\t}\n\tif (!ans)\n\t\tdep[u] = -1;\n\treturn ans;\n}\ninline int dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t))\n\t{\n\t\tmemcpy(fst, lst, sizeof(lst));\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nstd::vector<int> vec[200005], bel[200005];\nint fa[200005], rep[200005];\nbool vis[200005];\nint add(int u)\n{\n\tint res = 1;\n\tvis[u] = true;\n\tfor (int x : bel[u])\n\t{\n\t\tif (!vis[rep[x]])\n\t\t{\n\t\t\tfa[x] = u;\n\t\t\tres += add(rep[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC029-F.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint len;\n\t\tscanf(\"%d\", &len);\n\t\twhile (len--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tif (--u)\n\t\t\t\tadd_edge(i + 1, u + n - 1, 1);\n\t\t\tvec[i].pb(u);\n\t\t\tbel[u].pb(i);\n\t\t}\n\t\tadd_edge(0, i + 1, 1);\n\t\tadd_edge(i + n, n + n, 1);\n\t}\n\tif (dinic(0, n + n) != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = lst[i]; ~j; j = pre[j])\n\t\t{\n\t\t\tif (to[j] && !cap[j])\n\t\t\t\trep[i - 1] = to[j] - n + 1;\n\t\t}\n\t}\n\tif (add(0) != n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i + 1 < n; i++)\n\t\tprintf(\"%d %d\\n\", fa[i] + 1, rep[i] + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\n\nint n;\n\ninline void failed(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<int> G[N];\nbool vis[N];\nint match[N];\nint pref[N];\nstack<int> stk;\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<G[x].size();i++){\n\t\tint v=G[x][i];if(vis[v])continue;\n\t\tvis[v]=1;stk.push(v);\n\t\tif(!pref[v] || dfs(pref[v])){\n\t\t\tmatch[x] = v;\n\t\t\tpref[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint s[N];\ntypedef pair<int,int> pi;\nvector<pi> tr;\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<n;i++){\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int j=1,e;j<=c;j++){\n\t\t\tscanf(\"%d\",&e);\n\t\t\tG[e].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\t// cout << i << \":\";\n\t\tif(!dfs(i))failed();\n\t\twhile(stk.size()){\n\t\t\t// cout << stk.top();\n\t\t\tvis[stk.top()]=0;\n\t\t\tstk.pop();\n\t\t}\n\t\t// cout << \"?\" << endl;\n\t}\n\tqueue<int> q;\n\tfor(size_t i=0;i<G[1].size();i++){\n\t\ts[G[1][i]]=1;\n\t\tq.push(G[1][i]);\n\t}\n\ttr.resize(n);\n\tint ss=0;\n\twhile(q.size()){\n\t\t++ss;\n\t\tint u=q.front();q.pop();\n\t\tint v = pref[u];\n\t\t// cout << u << \":::\" << s[u] << \" \" << v << endl;\n\t\ttr[u] = pi(v,s[u]);\n\t\tfor(size_t i=0;i<G[v].size();i++){\n\t\t\tif(!s[G[v][i]])s[G[v][i]]=v,q.push(G[v][i]);\n\t\t}\n\t}\n\tif(ss<n-1){\n\t\tfailed();\n\t}\n\tfor(size_t i=1;i<tr.size();i++){\n\t\tprintf(\"%d %d\\n\",tr[i].first,tr[i].second);\n\t}\n\treturn 0;\n}\n/* \n10\n5 1 2 3 4 5\n5 2 3 4 5 6\n5 3 4 5 6 7\n5 4 5 6 7 8\n5 5 6 7 8 9\n5 6 7 8 9 10\n5 7 8 9 10 1\n5 8 9 10 1 2\n5 9 10 1 2 3\n */"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E(200050 * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N];\nvector<int> A[Max_N], In[Max_N];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0, t;i < In[u].size();++i)\n\t\tif (!done[t = In[u][i]])\n\t\t{\n\t\t\tdone[t] = true;\n\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), dfs(v);\n\t\t}\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 1;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tdfs(1); \n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst LL INF=1e16;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+2*NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tvoid AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tLL Aug(int u,LL flow) {\n\t\tif(u==t) return flow;\n\t\tLL sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min((LL)e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tLL Flow;\n\tLL ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c;i<n;i++) {\n\t\tscanf(\"%d\",&c);\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1,u;j<=c;j++) {\n\t\t\tscanf(\"%d\",&u);\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                     .:*+=%@@@@@@=-.\n                 .:=@#@@@#@@#######%==*.\n              .-=####@######%*-.....:%##%.\n            .*@###########%+:--........-%@-\n          .*@##############@+--.........-:%-\n        .+##################@==%%%%=+*:----+.\n      .-@####################%++%@@@@@=+**%@@*\n      .%###################@%%@@@###@%+:--%@@%.\n     -@###################@%%%%*::*%++:-----=@+.\n    -#####################@%=++++++*:-------.-=:\n   .+####################@%++*::-:::--::*:::***=:\n   .@#####################%=++*::::-:::++*=##@@#@-\n  ..#####################@%%=++**:::::**+%@#@%%##-..\n   .%####################@@%=+++*+****::*=@######@.\n  .=######################@%%==+==++**+=@%@##@###+:...\n  -#######################@@@%%%===++=@@@%=++===*::--...\n  -########################@@@@@@@%==%%=++==@@:::::*:--.\n..:#########################@@@@@@%%======++++::-..:-.--...\n%#############################@###@%%@@%==%=%*----.--.::---.\n#############################################*-:*:-:---*---- .\n#############################################*--*--:---*---:-.\n#############################################+--::--::-*::-::.\n###########################################+:*-.---.---.:---*-..\n###########################################**:-----------------.\n##########################################@::**:--::::::--:::::-\n###########################################:--:*:::::::::**::*+*\n###########################################=:::***::::::**:::*+*\n############################@@@@@@#########@+****::::********+++\n############################@%%%%%@@@@@@@###%+***::::::::***+==+\n############################@%%%%%%%%%%%@####=+:::-::::-::*+=%%+\n#############################@%%%%%%%%%%@#####=::--------:*=%@%+\n%###########################@%%%%==%%%%%%@##@#=:------..-:+%@@%=\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n--------------------------------------------\n----------------------------------------------\n\n         o###########oo\n      o##\"          \"\"##o\n    o#\"                \"##\n  o#\"                    \"#o\n #\"  ##              ##   \"##\n#\"                          ##\n#  ###################       #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#                            #\n#o                           #\n\"#o                         ##\n \"#o                       ##\n  \"#o                    o#\"\n   \"#o                  ##\n     \"#o              o#\"\n       \"#ooo      ooo#######oo\n        ###############   \"######o\n     o###\"\"        \"###o      # ###\n   o###o     oooo    ###    oo####\"\n o###**#     #**#   ############\"\n \"\"##\"\"\"\"\"\"\"\"\"\"###########    #\n    # oooooooo#\"#**     ##    #\n    # #       # # **    ##    #\n    #o#       #o#  *****###ooo#\n                        ##\n                        ##   o###o\n                        ## o##***##\n               o########## #***#**##o\n             o##\"   \"\"###  #***##***#\n o#######o  ###   oo####   ##**####*#\no##\"  \"\"#############\"\"     ##****###\n##\"         ##              ##*##*###\n##          ###              ##### ##\n##           ###              # ##  #\n##            ##                 #\n##             ##\n##             ###\n##              ###oo\n###              \"\"###\n ###\n  ###\n*/\n\n///YEAH IM THE BEST I'VE EVER WAS\n\n///SO HAPPY\n\n#include <bits/stdc++.h>\n\n#define popcnt(x) __builtin_popcount(x)\n\n#define fr first\n\n#define sc second\n\n#define m_p make_pair\n\n#define low_bo(a, x) lower_bound(a.begin(), a.end(), x) - a.begin()\n\n#define up_bo(a, x) upper_bound(a.begin(), a.end(), x) - a.begin()\n\n#define unique(a) a.resize(unique(a.begin(), a.end()) - a.begin())\n\n#define popcnt(x) __builtin_popcount(x)\n\n//#include <ext/pb_ds/assoc_container.hpp>\n\n//using namespace __gnu_pbds;\n\n//gp_hash_table<int, int> table;\n\n//#pragma GCC optimize(\"O3\")\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n//float __attribute__((aligned(32)))\n\n/*char memory[(int)1e8];\n\nchar memorypos;\n\ninline void * operator new(size_t n){\n    char * ret = memory + memorypos;\n    memorypos += n;\n    return (void *)ret;\n}\n\ninline void operator delete(void *){}\n*/\n\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ull;\n\ntypedef long double ld;\n\ntypedef unsigned int uint;\n\nll sqr(ll x){\n    return x * x;\n}\n\nint mysqrt(ll x){\n    int l = 0, r = 1e9 + 1;\n    while (r - l > 1){\n        int m = (l + r) / 2;\n        if (m * (ll)m <= x)\n            l = m;\n        else\n            r = m;\n    }\n    return l;\n}\n\nmt19937 rnd(1227);\n\nmt19937_64 rndll(12365);\n\nll AR = 19, BR = 13, CR = 23, XR = 228, YR = 322, MODR = 1e9 + 993;\n\nll myrand(){\n    ll ZR = (XR * AR + YR * BR + CR) % MODR;\n    XR = YR;\n    YR = ZR;\n    return ZR;\n}\n\nint gcd(int a, int b){\n    return a ? gcd(b % a, a) : b;\n}\n\nint gcdex(int a, int b, int &x, int &y){\n    if (a == 0){\n        x = 0;\n        y = 1;\n        return b;\n    }\n    int x1, y1;\n    int ret = gcdex(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return ret;\n}\n\nint Mod;\n\nint Bpow(int x, int y){\n    int ret = 1;\n    int w = x;\n    while (y){\n        if (y & 1)\n            ret = (ret * (ll)w) % Mod;\n        w = (w * (ll)w) % Mod;\n        y >>= 1;\n    }\n    return ret;\n}\n\nint Bdiv(int x){\n    int a, b;\n    gcdex(x, Mod, a, b);\n    if (a < 0)\n        a += Mod;\n    return a;\n}\n\nint Bdiv(int x, int y){\n    return (x * (ll)Bpow(y, Mod - 2)) % Mod;\n}\n\ninline int ad(int x, int y){\n    return x + y >= Mod ? x + y - Mod : x + y;\n}\n\ninline int dif(int x, int y){\n    return x - y < 0 ? x - y + Mod : x - y;\n}\n\ninline int mul(int x, int y){\n    return (x * (ll)y) % Mod;\n}\n\nint inv(int a){\n    int b = Mod, x = 0, y = 1;\n    while (a){\n        int t = b / a;\n        b -= a * t;\n        x -= t * y;\n        swap(a, b);\n        swap(x, y);\n    }\n    if (x < 0)\n        x += Mod;\n    return x;\n}\n\nvoid setmin(int &x, int y){\n    x = min(x, y);\n}\n\nvoid setmax(int &x, int y){\n    x = max(x, y);\n}\n\nvoid setmin(ll &x, ll y){\n    x = min(x, y);\n}\n\nvoid setmax(ll &x, ll y){\n    x = max(x, y);\n}\n\nconst ll llinf = 4e18 + 100;\n\nconst ld eps = 1e-9;\n\nconst int maxn = 1e5 + 100, maxw = 1e6 + 100, inf = 2e9 + 100, sq = 600, X = 43, mod = 1e9 + 7, LG = 17;\n\nset<int> q[maxn];\n\nint p[maxn], r[maxn];\n\nint get(int x) {\n    return x == p[x] ? x : p[x] = get(p[x]);\n}\n\nint d[maxn];\n\nset<pair<int, int> > g;\n\nvoid uni(int x, int y) {\n    x = get(x);\n    y = get(y);\n    if (x == y)\n        return;\n    if (r[x] < r[y])\n        swap(x, y);\n    p[y] = x;\n    if (q[x].size() < q[y].size())\n        swap(q[x], q[y]);\n    for (int i : q[y])\n        if (q[x].find(i) == q[x].end())\n            q[x].insert(i);\n        else {\n            g.erase({d[i], i});\n            d[i]--;\n            g.insert({d[i], i});\n        }\n    if (r[x] == r[y])\n        r[x]++;\n}\n\nint n;\n\nvector<int> a[maxn];\n\npair<int, int> ans[maxn];\n\nint main()\n{\n    #ifdef ONPC\n    //ifstream cin(\"a.in\");\n    //ofstream cout(\"a.out\");\n    freopen(\"a.in\", \"r\", stdin);\n    freopen(\"a.out\", \"w\", stdout);\n    #else\n    //ifstream cin(\"gymnasts.in\");\n    //ofstream cout(\"gymnasts.out\");\n    //freopen(\"nextpartition.in\", \"r\", stdin);\n    //freopen(\"nextpartition.out\", \"w\", stdout);\n    #endif // ONPC\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n;\n    for (int i = 0; i < n; i++)\n        p[i] = i;\n    for (int i = 0; i < n - 1; i++) {\n        int w;\n        cin >> w;\n        a[i].resize(w);\n        for (int j = 0; j < w; j++)\n            cin >> a[i][j], a[i][j]--, q[a[i][j]].insert(i);\n        d[i] = w;\n        g.insert({d[i], i});\n    }\n    for (int its = 0; its < n - 1; its++) {\n        int id = g.begin()->sc;\n        g.erase(g.begin());\n        int x = a[id][0], y = -1;\n        int tos = get(x);\n        q[tos].erase(id);\n        for (int i : a[id])\n        if (i != x){\n            int w = get(i);\n            if (w != tos)\n                y = i, q[w].erase(id);\n        }\n        if (y != -1) {\n            uni(x, y);\n            ans[id] = {x, y};\n        } else {\n            cout << -1;\n            return 0;\n        }\n    }\n    for (int i = 0; i < n - 1; i++)\n        cout << ans[i].fr + 1 << ' ' << ans[i].sc + 1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct vertex {\n\tint estart;\n\tint ecur;\n\tint dist;\n} v[300003];\nstruct edge {\n\tint enext,to;\n\tint cap;\n} e[1000003];int en;\nvoid addedge(int a,int b,int cap)\n{\n\te[en].enext = v[a].estart;e[en].to = b;e[en].cap = cap;v[a].estart = en++;\n\te[en].enext = v[b].estart;e[en].to = a;e[en].cap = 0;v[b].estart = en++;\n}\nint start, end;\nint dfs(int i,int cap)\n{\n\tif(i == end) return cap;\n\tint flow = 0;\n\tfor(int &j = v[i].ecur;j != -1;j = e[j].enext) {\n\t\tint to = e[j].to;\n\t\tif(e[j].cap == 0 || v[to].dist != v[i].dist + 1) continue;\n\t\tint val = dfs(to,std::min(cap,e[j].cap));\n\t\tflow += val;cap -= val;e[j].cap -= val;e[j^1].cap += val;\n\t\tif(cap == 0) break;\n\t}\n\treturn flow;\n}\nint n,m;\nstruct vertex2 {\n\tstd::vector<int> inset;\n\tbool vis;\n} v2[100003];\nstd::pair<int,int> ans[100003];\nint match[100003];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i = 0;i < 2*n+1;++i) {\n\t\tv[i].estart = -1;\n\t}\n\tstart = 2*n-1, end = 2*n;\n\t// root = 0\n\tfor(int i = 1;i < n;++i) {\n\t\taddedge(start,i,1);\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j = 0;j < c;++j) {\n\t\t\tint k;\n\t\t\tscanf(\"%d\",&k);--k;\n\t\t\tv2[k].inset.push_back(i);\n\t\t\tif(k != 0) addedge(k,n+i,1);\n\t\t}\n\t\taddedge(n+i,end,1);\n\t}\n\tint flow = 0;\n\tfor(;;) {\n\t\tfor(int i = 0;i < 2*n+1;++i) {\n\t\t\tv[i].dist = -1;\n\t\t\tv[i].ecur = v[i].estart;\n\t\t}\n\t\tv[start].dist = 0;\n\t\tstd::queue<int> q;\n\t\tq.push(start);\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = v[cur].estart;j != -1;j = e[j].enext) {\n\t\t\t\tif(e[j].cap == 0) continue;\n\t\t\t\tint to = e[j].to;\n\t\t\t\tif(v[to].dist == -1) {\n\t\t\t\t\tv[to].dist = v[cur].dist + 1;\n\t\t\t\t\tq.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(v[end].dist == -1) break;\n\t\tflow += dfs(start,999999);\n\t}\n\tif(flow != n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i = 0;i < n - 1;++i) {\n\t\tint x = n+i;\n\t\tmatch[i] = -1;\n\t\tfor(int j = v[x].estart;j != -1;j = e[j].enext) {\n\t\t\tif(e[j].to >= 1 && e[j].to < n && e[j].cap == 1) {\n\t\t\t\tmatch[i] = e[j].to;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(match[i] != -1);\n\t}\n\t\n\t{\n\t\tstd::queue<int> q;\n\t\tq.push(0);v2[0].vis = true;\n\t\tint cnt = 0;\n\t\twhile(!q.empty()) {\n\t\t\tint cur = q.front();q.pop();\n\t\t\tfor(int j = 0;j < v2[cur].inset.size();++j) {\n\t\t\t\tint to = v2[cur].inset[j];\n\t\t\t\tif(!v2[match[to]].vis) {\n\t\t\t\t\tans[to] = std::make_pair(cur,match[to]);\n\t\t\t\t\tv2[match[to]].vis = true;\n\t\t\t\t\tq.push(match[to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t++cnt;\n\t\t}\n\t\tif(cnt == n) {\n\t\t\tfor(int i = 0;i < n-1;++i) printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n\t\t} else {\n\t\t\tprintf(\"-1\\n\");\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num;\nconst int inf=0x3f3f3f3f;\nvector<int>v[N],son[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1;\n\t\tson[x].push_back(ma[v[x][i]]);\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&w[i].to!=s)ma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=0;j<(int)son[i].size();j++)\n\t\t\tprintf(\"%d %d\\n\",i,son[i][j]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nnamespace flw {\n\tconst int N = 1000000 + 7;\n\tstruct flow {\n\t\tint n, st, ed;\n\t\tint lay[N], gap[N], cur[N], pre[N];\n\t\tstruct edge {\n\t\t\tint to, nex, cap;\n\t\t} e[N];\n\t\tint fir[N], eid = 1;\n\n\t\tvoid addedge(int u, int v, int c);\n\t\tvoid addflow(int u, int v);\n\t\tint isap();\n\t};\n\n\tvoid flow::addedge(int u, int v, int c) {\n\t\te[++eid] = (edge){ v, fir[u], c }, fir[u] = eid;\n\t}\n\tvoid flow::addflow(int u, int v) {\n\t\taddedge(u, v, 1), addedge(v, u, 0);\n\t}\n\tint flow::isap() {\n\t\tstd::queue<int> q; q.push(ed);\n\t\tstd::fill(lay + 1, lay + n + 1, -1), lay[ed] = 0;\n\t\tfor (int s; q.size(); ) {\n\t\t\ts = q.front(), q.pop();\n\t\t\tfor (int i = fir[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[e[i].to] == -1 && e[i ^ 1].cap)\n\t\t\t\t\t++gap[lay[e[i].to] = lay[s] + 1], q.push(e[i].to);\n\t\t}\n\t\tstd::copy(fir + 1, fir + n + 1, cur + 1);\n\n\t\tint maxflow = 0, s = st;\n\t\twhile (lay[st] < n) {\n\t\t\tif (s == ed)\n\t\t\t\tfor (++maxflow; s != st; s = pre[s], --e[cur[s]].cap, ++e[cur[s] ^ 1].cap);\n\t\t\tfor (int &i = cur[s]; i; i = e[i].nex)\n\t\t\t\tif (lay[s] == lay[e[i].to] + 1 && e[i].cap)\n\t\t\t\t\t{ pre[e[i].to] = s; break; }\n\t\t\tif (cur[s]) { s = e[cur[s]].to; continue; }\n\t\t\tif (!--gap[lay[s]]) break;\n\t\t\t++gap[++lay[s]], cur[s] = fir[s];\n\t\t\tif (s != st) s = pre[s];\n\t\t}\n\t\treturn maxflow;\n\t}\n}\n\nconst int N = 400000 + 7;\n\nint n;\nflw::flow f;\nint u[N];\nstd::vector<int> v[N];\nint g[N], h[N], k;\n\nint fa[N];\nint getfa(int x) {\n\treturn fa[x] == x ? x : fa[x] = getfa(fa[x]);\n}\n\nint main() {\n//\tfreopen(\"code.in\", \"r\", stdin);\n//\tfreopen(\"code.out\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tf.st = n * 2, f.ed = f.n = f.st + 1;\n\tfor (int i = 1, x, y; i < n; ++i) {\n\t\tscanf(\"%d\", &y);\n\t\twhile (y--) scanf(\"%d\", &x), f.addflow(x, n + i), v[x].push_back(i);\n\t\tf.addflow(f.st, i), f.addflow(n + i, f.ed);\n\t}\n\tif (f.isap() < n - 1) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tfor (int j = f.fir[n + i]; j; j = f.e[j].nex)\n\t\t\tif (f.e[j].cap) u[i] = f.e[j].to;\n\tfor (int i = 1; i <= n; ++i) fa[i] = i;\n\tstd::queue<int> q; q.push(n);\n\tfor (int s; q.size(); ) {\n\t\ts = q.front(), q.pop();\n\t\tfor (auto i : v[s])\n\t\t\tif (u[i]) q.push(u[i]), fa[getfa(g[i] = s)] = getfa(h[i] = u[i]), u[i] = 0;\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (getfa(i) != getfa(1)) return printf(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", g[i], h[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\nsolution will be written here.\n#endif\n#include <cstdio>\n#include <vector>\n#include <queue>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef long long ll;\nstruct {\n\tinline operator int () { int x; return scanf(\"%d\", &x), x; }\n\tinline operator ll () { ll x; return scanf(\"%lld\", &x), x; }\n} read;\n\nconst int maxn = 100005;\nstd::vector<int> set[maxn];\n\nint head[maxn << 1], nxt[maxn << 2], to[maxn << 2], cap[maxn << 2], hp = 1;\nint cur[maxn << 1], level[maxn << 1];\n\ninline void add(int u, int v, int c) {\n\tnxt[++ hp] = head[u];\n\thead[u] = hp;\n\tto[hp] = v;\n\tcap[hp] = c;\n\tif(!(hp & 1)) add(v, u, 0);\n}\n\nbool bfs(int s, int t) {\n\tstd::queue<int> q;\n\tq.push(s);\n\tstd::fill(level, level + t + 1, 0);\n\tlevel[s] = 1;\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i] and !level[to[i]]) {\n\t\t\t\tlevel[to[i]] = level[u] + 1;\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn level[t];\n}\n\nint dinic(int u, int t) {\n\tif(u == t) return 1;\n\tfor(int &i = cur[u]; i; i = nxt[i])\n\t\tif(cap[i] and level[to[i]] == level[u] + 1) {\n\t\t\tint f = dinic(to[i], t);\n\t\t\tif(f) {\n\t\t\t\tcap[i] -= f;\n\t\t\t\tcap[i ^ 1] += f;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t}\n\treturn 0;\n}\n\nbool vis[maxn];\nint match[maxn];\nint ansx[maxn], ansy[maxn], ap;\n\nint main() {\n\tint n = read;\n\n\tint s = n * 2, t = n * 2 + 1;\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(s, i, 1);\n\tfor(int i = 1; i < n; i ++)\n\t\tadd(n + i, t, 1);\n\n\tfor(int i = 1; i < n; i ++) {\n\t\tint k = read;\n\t\twhile(k --)\n\t\t\tadd(read, n + i, 1);\n\t}\n\n\tint flow = 0;\n\twhile(bfs(s, t)) {\n\t\tstd::copy(head, head + t + 1, cur);\n\t\tint f = dinic(s, t);\n\t\twhile(f) {\n\t\t\tflow += f;\n\t\t\tf = dinic(s, t);\n\t\t}\n\t}\n\n\tif(flow != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int u = n + 1; u < n * 2; u ++)\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(cap[i])\n\t\t\t\tmatch[u - n] = to[i];\n\n\tstd::queue<int> q;\n\tq.push(n);\n\twhile(!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor(int i = head[u]; i; i = nxt[i])\n\t\t\tif(to[i] != s and !vis[to[i] - n]) {\n\t\t\t\tvis[to[i] - n] = 1;\n\t\t\t\tq.push(match[to[i] - n]);\n\t\t\t\t++ ap;\n\t\t\t\tansx[to[i] - n] = u;\n\t\t\t\tansy[to[i] - n] = match[to[i] - n];\n\t\t\t}\n\t}\n\n\tif(ap != n - 1) return puts(\"-1\"), 0;\n\n\tfor(int i = 1; i <= ap; i ++)\n\t\tprintf(\"%d %d\\n\", ansx[i], ansy[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nstruct Edge {\n\tint v, to;\n\tll cap, flow;\n\n\tEdge() : v(), to(), cap(), flow() {}\n\tEdge(int _v, int _to, ll _cap) : v(_v), to(_to), cap(_cap), flow(0LL) {}\n};\n\nconst ll INF = (ll)1e11;\nconst int N = (int)1e6 + 7;\nEdge ed[N];\nint edSz;\nvector<int> g[N];\nint n;\nint S, T;\nvector<int> ans[N];\nint dist[N];\nint q[N];\nint topQ;\nint idx[N];\n\nvoid addEdge(int v, int to, ll cap) {\n\ted[edSz] = Edge(v, to, cap);\n\tg[v].push_back(edSz++);\n\ted[edSz] = Edge(to, v, 0LL);\n\tg[to].push_back(edSz++);\n}\n\nbool BFS() {\n\tfor (int i = 0; i <= T; i++)\n\t\tdist[i] = N;\n\ttopQ = 0;\n\tq[topQ++] = S;\n\tdist[S] = 0;\n\tfor (int i = 0; i < topQ; i++) {\n\t\tint v = q[i];\n\t\tfor (int id : g[v]) {\n\t\t\tEdge e = ed[id];\n\t\t\tif (e.cap == e.flow) continue;\n\t\t\tint to = e.to;\n\t\t\tif (dist[to] <= dist[v] + 1) continue;\n\t\t\tdist[to] = dist[v] + 1;\n\t\t\tq[topQ++] = to;\n\t\t}\n\t}\n\treturn dist[T] < N;\n}\nll dfs(int v, ll flow) {\n\tif (flow == 0 || v == T) return flow;\n\tll res = 0;\n\tfor (int &i = idx[v]; i < (int)g[v].size(); i++) {\n\t\tint id = g[v][i];\n\t\tEdge e = ed[id];\n\t\tint to = e.to;\n\t\tif (dist[to] != dist[v] + 1) continue;\n\t\tll df = dfs(to, min(flow, e.cap - e.flow));\n\t\tres += df;\n\t\tflow -= df;\n\t\ted[id].flow += df;\n\t\ted[id ^ 1].flow -= df;\n\t\tif (flow == 0) return res;\n\t}\n\treturn res;\n}\n\nll Flow() {\n\tll res = 0;\n\twhile(BFS()) {\n\t\tfor (int i = 0; i <= T; i++)\n\t\t\tidx[i] = 0;\n\t\tres += dfs(S, INF);\n\t}\n\treturn res;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d\", &n);\n\tS = 2 * n;\n\tT = S + 1;\n\tfor (int i = 0; i < n; i++)\n\t\taddEdge(n + i, T, n - 1);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\taddEdge(S, i, n);\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\twhile(k--) {\n\t\t\tint v;\n\t\t\tscanf(\"%d\", &v);\n\t\t\tv--;\n\t\t\taddEdge(i, n + v, INF);\n\t\t}\n\t}\n\tif (Flow() != (ll)n * (n - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor (int i = 0; i < edSz; i++) {\n\t\tEdge e = ed[i];\n\t\tif (e.flow <= 0) continue;\n\t\tint v = e.v, u = e.to;\n\t\tif (v >= n || u < n || u >= 2 * n) continue;\n\t\tans[v].push_back(u - n);\n\t}\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif ((int)ans[i].size() != 2) throw;\n\t\tprintf(\"%d %d\\n\", ans[i][0] + 1, ans[i][1] + 1);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Bipartite_Matching {\n  vector< vector< int > > graph;\n  vector< int > dist, match, used;\n  vector< bool > vv;\n\n  Bipartite_Matching(int n, int m) {\n    graph.resize(n);\n    match.assign(m, -1);\n    used.assign(n, -1);\n  }\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(used[i] == -1) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        used[a] = b;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(used[i] == -1 && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n};\n\nvector< int > h[200000];\nint p[200000];\nbool used[200000];\n\nint dfs(int idx, int par) {\n  if(used[idx]) return 0;\n  used[idx] = true;\n  int times = 1;\n  p[idx] = par;\n  for(auto &to : h[idx]) times += dfs(to, idx);\n  return times;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  Bipartite_Matching flow(N, N);\n  for(int i = 0; i < N - 1; i++) {\n    int k;\n    cin >> k;\n    for(int j = 0; j < k; j++) {\n      int x;\n      cin >> x;\n      --x;\n      flow.add_edge(i, x);\n    }\n  }\n  if(flow.bipartite_matching() < N - 1) {\n    cout << -1 << endl;\n    return 0;\n  }\n  for(int i = 0; i < N; i++) {\n    if(flow.match[i] == -1) {\n      flow.match[i] = N - 1;\n      flow.used[N - 1] = i;\n    }\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    for(auto &to : flow.graph[i]) {\n      if(flow.match[to] != i) {\n        h[flow.match[to]].push_back(i);\n      }\n    }\n  }\n\n  if(dfs(N - 1, -1) < N) {\n    cout << -1 << endl;\n    return 0;\n  }\n\n  for(int i = 0; i < N - 1; i++) {\n    cout << flow.used[i] + 1 << \" \" << flow.used[p[i]] + 1 << endl;\n  }\n\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\ntemplate <class Z>\nstruct MaxFlow {\n  vector<vector<tuple<int, int, Z>>> g;\n\n  struct Ref {\n    const MaxFlow* p;\n    int u, id;\n\n    Ref() {}\n\n    Ref(const MaxFlow* p, int u, int id) : p(p), u(u), id(id) {}\n\n    Z get() const { return std::get<2>((p->g)[u][id]); }\n  };\n\n  MaxFlow() {}\n  MaxFlow(int n) : g(n) {}\n\n  Ref addEdge(int u, int v, const Z& w) {\n    if (u == v) return Ref();\n    int ru = g[u].size(), rv = g[v].size();\n    g[u].emplace_back(v, rv, w);\n    g[v].emplace_back(u, ru, 0);\n    return Ref(this, v, rv);\n  }\n\n  Z dinic(int s, int t) {\n    int n = g.size();\n    function<vector<int>()> getLevel = [&]() {\n      vector<int> level(n, -1);\n      queue<int> q;\n      level[s] = 0;\n      q.push(s);\n      while (!q.empty()) {\n        int u = q.front(); q.pop();\n        for (const auto& pr : g[u])\n          if (get<2>(pr) && level[get<0>(pr)] == -1) {\n            level[get<0>(pr)] = level[u] + 1;\n            q.push(get<0>(pr));\n          }\n      }\n      return level;\n    };\n    vector<int> r, level;\n    function<Z(int, Z)> cap = [&](int u, Z limit) {\n      if (u == t) return limit;\n      Z ret = 0;\n      while (r[u] && limit > ret) {\n        int v = get<0>(g[u][r[u] - 1]), rev = get<1>(g[u][r[u] - 1]);\n        Z& w = get<2>(g[u][r[u] - 1]);\n        if (level[v] == level[u] + 1) {\n          Z flow = cap(v, min(limit - ret, w));\n          ret += flow;\n          w -= flow;\n          get<2>(g[v][rev]) += flow;\n          if (limit == ret)\n            return ret;\n          --r[u];\n        } else\n          --r[u];\n      }\n      return ret;\n    };\n    Z ret = 0;\n    while (level = getLevel(), level[t] != -1) {\n      r = vector<int>(n);\n      for (int i = 0; i < n; ++i)\n        r[i] = g[i].size();\n      ret += cap(s, numeric_limits<Z>::max());\n    }\n    return ret;\n  }\n};\n\nint main() {\n#ifdef LBT\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n;\n  cin >> n;\n  vector<vector<int>> e(n - 1), fnd(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    cin >> c;\n    e[i].resize(c);\n    cin >> e[i];\n    for (int j = 0; j < c; ++j)\n      fnd[--e[i][j]].push_back(i);\n  }\n  MaxFlow<int> maxFlow(n * 2);\n  int s = 0, t = n * 2 - 1;\n  for (int i = 1; i < n; ++i)\n    maxFlow.addEdge(i, t, 1);\n  vector<vector<MaxFlow<int>::Ref>> eref(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    maxFlow.addEdge(s, n + i, 1);\n    eref[i].resize(e[i].size());\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0)\n        eref[i][j] = maxFlow.addEdge(n + i, e[i][j], 1);\n  }\n  if (maxFlow.dinic(s, t) != n - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n  vector<int> chosen(n - 1);\n  for (int i = 0; i < n - 1; ++i) {\n    for (size_t j = 0; j < e[i].size(); ++j)\n      if (e[i][j] != 0 && eref[i][j].get())\n        chosen[i] = e[i][j];\n  }\n  vector<bool> vis(n);\n  vector<pair<int, int>> ans(n - 1);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = true;\n    for (int id : fnd[u])\n      if (chosen[id] != -1) {\n        int v = chosen[id];\n        chosen[id] = -1;\n        ans[id] = make_pair(u + 1, v + 1);\n        dfs(v);\n      }\n  };\n  dfs(0);\n  if (count(chosen.begin(), chosen.end(), -1) != n - 1)\n    cout << \"-1\\n\";\n  else\n    for (const auto& pr : ans)\n      cout << pr.first << ' ' << pr.second << '\\n';\n\n#ifdef LBT\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\n#define LL long long\n#define fgx cerr<<\"--------------\"<<endl;\n#define dgx cerr<<\"==============\"<<endl;\n\ninline int read(){\n\tint x=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int MAXN = 600010;\nconst int INF = 2147483600;\n\nint N;\n\nint Node[MAXN<<1],Next[MAXN<<1],Root[MAXN+1],C[MAXN<<1],cnt; \ninline void addedge(int u,int v,int c){\n\tNode[cnt]=v; Next[cnt]=Root[u]; C[cnt]=c; Root[u]=cnt++;\n}\ninline void insert(int u,int v,int c){\n\taddedge(u,v,c); addedge(v,u,0);\n}\nint S,T; int dis[MAXN+1];\ninline bool BFS(){\n\tfor(int i=S;i<=T;i++) dis[i]=0;\n\tqueue<int> que; que.push(S); dis[S]=1;\n\twhile(!que.empty()){\n\t\tint k=que.front();\n\t\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\t\tint v=Node[x]; \n\t\t\tif(C[x]>0&&!dis[v]) dis[v]=dis[k]+1,que.push(v); \n\t\t} que.pop();\n\t} \n\treturn (dis[T]?1:0);\n}\ninline int DFS(int k,int t){\n\tif(k==T) {return t;} int ret=0;\n\tfor(int x=Root[k];x!=-1;x=Next[x]){\n\t\tint v=Node[x]; if(C[x]>0&&dis[v]==dis[k]+1){\n\t\t\tint d=DFS(v,min(t,C[x]));\n\t\t\tC[x]-=d; C[x^1]+=d; ret+=d; t-=d;\n\t\t\tif(!t) return ret;\n\t\t}\n\t} if(!ret) dis[k]=0;\n\treturn ret;\n}\nint nod;\nqueue<int> que; int vis[MAXN+1],chs[MAXN+1],root;\nvector<int> vec[MAXN+1]; int P[MAXN+1];\ninline void Add(int k){\n\t++nod; for(int i=0,sz=vec[k].size();i<sz;i++){\n\t\tint j=vec[k][i];\n\t\tif(!vis[j]&&chs[j]!=k) vis[j]=k,que.push(j); \n\t}\n}\n\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tN=read(); T=2*N,S=0;\n\tmemset(Root,-1,sizeof(Root));\n\tfor(int i=1;i<N;i++){\n\t\tP[i]=read();\n\t\tinsert(S,i,1);\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tint x=read();\n\t\t\tvec[x].push_back(i);\n\t\t\tinsert(i,x+N-1,1);\n\t\t}\n\t}\n\tfor(int i=1;i<=N;i++) insert(i+N-1,T,1);\n\tint sum=0; while(BFS()) sum+=DFS(S,INF);\n\tif(sum!=N-1){ puts(\"-1\"); return 0; }\n\tint id=1; int now=0;\n\tfor(int i=1;i<N;i++){\n\t\tnow+=2;\n\t\tfor(int j=1;j<=P[i];j++){\n\t\t\tif(!C[now]) chs[i]=Node[now]-(N-1);\n\t\t\tnow+=2;\n\t\t}\n\t}\n\twhile(now<cnt) {\n\t\tif(C[now]) {\n\t\t\troot=id; break;\n\t\t} now+=2; ++id;\n\t} \n\tAdd(root);\n\twhile(!que.empty()){ int k=que.front();  Add(chs[k]); que.pop(); }\n\tif(nod!=N){ puts(\"-1\"); return 0; }\n\tfor(int i=1;i<N;i++) printf(\"%d %d\\n\",chs[i],vis[i]);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200050\n#define maxm 400050\nusing namespace std;\ntypedef long long LL;\n\nint n;\nint vs,vt;\n\nvector<int> G[maxn];\n\nint tot;\nint cost[maxm<<1];\nint head[maxn],edge[maxm<<1],nxt[maxm<<1];\n\nvoid join(int u,int v)\n{\n    // cout<<\"edge:\"<<u<<\" \"<<v<<endl;\n    cost[tot]=1; edge[tot]=v; nxt[tot]=head[u]; head[u]=tot++;\n    cost[tot]=0; edge[tot]=u; nxt[tot]=head[v]; head[v]=tot++;\n}\n\nvoid init()\n{\n    tot=0;\n    memset(head,-1,sizeof(head));\n\n    scanf(\"%d\",&n);\n    vs=n+n,vt=n+n+1;\n    for (int k=1;k<n;++k)\n    {\n        int x,v;\n        scanf(\"%d\",&x);\n        while (x--)\n        {\n            scanf(\"%d\",&v);\n            G[v].push_back(k);\n            join(v,k+n);\n        }\n    }\n    for (int i=1;i<=n;++i)  join(vs,i);\n    for (int i=n+1;i<n+n;++i)   join(i,vt);\n}\n\nint d[maxn],gap[maxn];\nint cur[maxn],prt[maxn];\n\nint isap()\n{\n    for (int i=1;i<=vt;++i) cur[i]=head[i],++gap[d[i]=0];\n    int i=vs,ans=0;\n    while (d[vs]<vt)\n    {\n        if (i==vt)\n        {\n            for (++ans;i!=vs;i=edge[prt[i]^1])\n                // cout<<\"path:\"<<i<<endl,\n                --cost[prt[i]],++cost[prt[i]^1];\n            // cout<<\"path:\"<<vs<<endl<<endl;\n        }\n\n        bool flag=0;\n        for (int k=cur[i];~k;k=nxt[k])\n        {\n            int j=edge[k];\n            if (cost[k]&&d[i]==d[j]+1)\n            {\n                flag=1;\n                cur[i]=prt[j]=k;\n                i=j;\n                break;\n            }\n        }\n\n        if (flag)   continue;\n\n        if (--gap[d[i]]==0) break;\n        d[i]=vt;\n        for (int k=head[i];~k;k=nxt[k])\n            if (cost[k])\n                d[i]=min(d[i],d[edge[k]]+1);\n        ++gap[d[i]];\n        cur[i]=head[i];\n        if (i!=vs)\n            i=edge[prt[i]^1];\n    }\n    // cout<<\"isap:\"<<ans<<endl;\n    return ans;\n}\n\nint mp[maxn];\n\npair<int,int> ans[maxn];\n\nbool vis[maxn];\n\nvoid dfs(int i)\n{\n    vis[i]=1;\n    for (auto j:G[i])\n    {\n        if (vis[mp[j]]) continue;\n        ans[j]=make_pair(i,mp[j]);\n        dfs(mp[j]);\n    }\n}\n\nint solve()\n{\n    if (isap()!=n-1)    return puts(\"-1\");\n\n    LL rt=1LL*n*(n+1)/2;\n    for (int k=0;k<tot;k+=2)\n    {\n        int u=edge[k^1],v=edge[k];\n        if (u==vs||v==vt||cost[k])   continue;\n        rt-=u;\n        mp[v-n]=u;\n    }\n\n    // cout<<rt<<endl;\n    // for (int i=1;i<n;++i)\n    //     cout<<i<<\" \"<<mp[i]<<endl;\n\n    dfs(rt);\n    for (int i=1;i<=n;++i)\n        if (!vis[i])\n            return puts(\"-1\");\n    for (int i=1;i<n;++i)\n        printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n}\n\nint main()\n{\n    init();\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//pantyhose(black) + glasses = infinity\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << '\\n';\n#define BP() cerr << \"OK!\\n\";\n#define PR(A, n) {cerr << #A << \" = \"; for (int _=1; _<=n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define PR0(A, n) {cerr << #A << \" = \"; for (int _=0; _<n; ++_) cerr << A[_] << ' '; cerr << '\\n';}\n#define FILE_NAME \"data\"\n\nconst int MAX_N = 200002;\nconst int INF = 1e9;\n\nint n, nTime, nEdge, c[5*MAX_N], visited[MAX_N], rev[5*MAX_N];\nint source, target, d[MAX_N], f[5*MAX_N], match[MAX_N], par[MAX_N];\nvector<int> e[MAX_N], p[MAX_N];\nvector<pair<int, int> > g[MAX_N];\nqueue<int> qu;\n\nvoid readInput() {\n    cin >> n;\n    for (int i=1; i<n; ++i) {\n        int sz;\n        cin >> sz;\n        while (sz--) {\n            int v;\n            cin >> v;\n            e[i].push_back(v);\n            p[v].push_back(i);\n        }\n    }\n}\n\nvoid addEdge(int u, int v, int capacity) {\n    g[u].push_back(make_pair(v, ++nEdge));\n    c[nEdge] = 1;\n    g[v].push_back(make_pair(u, ++nEdge));\n    rev[nEdge-1] = nEdge;\n    rev[nEdge] = nEdge-1;\n}\n\nvoid buildGraph() {\n    source = 0;\n    target = 2*n;\n    for (int i=1; i<n; ++i) {\n        for (auto v : e[i]) {\n            if (v>1)\n                addEdge(v, i+n, 1);\n        }\n    }\n    for (int i=2; i<=n; ++i)\n        addEdge(source, i, 1);\n    for (int i=n+1; i<2*n; ++i)\n        addEdge(i, target, 1);\n}\n\nbool bfs() {\n    while (qu.size())\n        qu.pop();\n    memset(d, -1, sizeof(d));\n    d[source] = 0;\n    qu.push(source);\n    while (qu.size()) {\n        int u = qu.front();\n        qu.pop();\n        if (u==target)\n            return true;\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (c[id]>f[id] && d[v]==-1) {\n                d[v] = d[u] + 1;\n                qu.push(v);\n            }\n        }\n    }\n    return false;\n}\n\nint incFlow(int u, int delta) {\n    if (u==target)\n        return delta;\n    if (visited[u]==nTime)\n        return 0;\n    visited[u] = nTime;\n    for (int i=0; i<g[u].size(); ++i) {\n        int v = g[u][i].first, id = g[u][i].second;\n        if (c[id]>f[id] && d[v]==d[u]+1) {\n            int x = incFlow(v, min(delta, c[id]-f[id]));\n            if (x) {\n                f[id] += x;\n                f[rev[id]] -= x;\n                return x;\n            }\n        }\n    }\n    return 0;\n}\n\nint maxFlow() {\n    int res = 0;\n    while (bfs()) {\n        while (true) {\n            ++nTime;\n            int x = incFlow(source, INF);\n            if (!x)\n                break;\n            res += x;\n        }\n    }\n    return res;\n}\n\nvoid findResult(int u) {\n    visited[u] = true;\n    for (auto v : p[u]) {\n        if (!visited[match[v]]) {\n            par[v] = u;\n            findResult(match[v]);\n        }\n    }\n}\n\nvoid solve() {\n    if (maxFlow()<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int u=2; u<=n; ++u) {\n        for (int i=0; i<g[u].size(); ++i) {\n            int v = g[u][i].first, id = g[u][i].second;\n            if (f[id])\n                match[v-n] = u;\n        }\n    }\n    memset(visited, false, sizeof(visited));\n    findResult(1);\n    if (accumulate(visited+1, visited+n+1, 0)<n-1) {\n        cout << -1;\n        return;\n    }\n    for (int i=1; i<n; ++i)\n        cout << match[i] << ' ' << par[i] << '\\n';\n}\n\nint main() {\n\t#ifdef GLASSES_GIRL\n\t\tfreopen(FILE_NAME\".inp\", \"r\", stdin);\n\t\tfreopen(FILE_NAME\".out\", \"w\", stdout);\n\t#endif\n\tios::sync_with_stdio(0); cin.tie(0);\n    readInput();\n    buildGraph();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 1000000 + 10;\nconst int N = maxn << 1;\nconst int maxE = 3000000;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn], lis[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int u = 2;u <= n;u ++) {\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(v != T && e[i].w) lis[v - n - 1] = u;\n\t\t}\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint v = lis[id];\n\t\t\tpre[v] = u;\n\t\t\tq[++ tail] = v;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tif(!pre[i]) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = lis[i - 1], v = pre[u];\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nusing namespace std;\nint head[262144],now[262144],last[1048576],to[1048576],c[1048576],cnt=1;\nvoid add(int u,int v,int cc)\n{\n\tcnt++;\n\tlast[cnt]=head[u];\n\thead[u]=cnt;\n\tto[cnt]=v;\n\tc[cnt]=cc;\n}\nint n;\nqueue<int> q;\nint d[262144],pre[262144];\nvoid bfs()\n{\n\tfor(int i=1;i<=(n<<1)+1;i++)\n\t{\n\t\tnow[i]=head[i];\n\t\td[i]=-1;\n\t}\n\td[(n<<1)]=0;\n\tq.push(n<<1);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[u];i;i=last[i])\n\t\t{\n\t\t\tif(c[i]==0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint v=to[i];\n\t\t\tif(d[v]<0)\n\t\t\t{\n\t\t\t\td[v]=d[u]+1;\n\t\t\t\tpre[v]=u;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint dfs(int u,int a)\n{\n\tif(u==(n<<1)+1||a==0)\n\t{\n\t\treturn a;\n\t}\n\tint flow=0;\n\tfor(int& i=now[u];i;i=last[i])\n\t{\n\t\tint v=to[i];\n\t\tif(d[v]<=d[u])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint flow2;\n\t\tif(c[i]<a)\n\t\t{\n\t\t\tflow2=dfs(v,c[i]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tflow2=dfs(v,a);\n\t\t}\n\t\tc[i]-=flow2;\n\t\tc[i^1]+=flow2;\n\t\ta-=flow2;\n\t\tflow+=flow2;\n\t\tif(a==0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flow;\n}\nint dinic()\n{\n\tint ans=0;\n\twhile(1)\n\t{\n\t\tbfs();\n\t\tif(d[(n<<1)+1]<0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tans+=dfs(n<<1,1000000000);\n\t}\n\treturn ans;\n}\nint s[131072],t[131072];\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tadd((n<<1),i,1);\n\t\tadd(i,(n<<1),0);\n\t}\n\tfor(int i=n+1;i<(n<<1);i++)\n\t{\n\t\tadd(i,(n<<1)+1,1);\n\t\tadd((n<<1)+1,i,0);\n\t\tint num;\n\t\tscanf(\"%d\",&num);\n\t\twhile(num--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\",&u);\n\t\t\tadd(u,i,1);\n\t\t\tadd(i,u,0);\n\t\t}\n\t}\n\tif(dinic()<n-1)\n\t{\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(d[i]<0)\n\t\t{\n\t\t\tprintf(\"-1\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(d[i]==1)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\ts[pre[i]-n]=i;\n\t\tt[pre[i]-n]=pre[pre[i]];\n\t}\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tprintf(\"%d %d\\n\",s[i],t[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn * 10];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long LL;\nconst int INF=0x3f3f3f3f;\nconst int N=100005;\nconst int M=200005;\nconst int NN=2*N;\nint n;\nstruct Network {\n\tstruct Edge {\n\t\tint v,w;\n\t\tEdge *nxt,*opp;\n\t}edge[2*M+NN];\n\tEdge *ecnt,*head[NN];\n\tint pcnt,s,t;\n\tNetwork() {ecnt=&edge[0];}\n\tvoid Init(int _s,int _t) {\n\t\ts=_s; t=_t;\n\t}\n\tinline void AddEdge2(int u,int v,int w) {\n\t\tecnt->v=v; ecnt->w=w;\n\t\tecnt->nxt=head[u];\n\t\tecnt->opp=ecnt+1;\n\t\thead[u]=ecnt++;\n\t\t\n\t\tecnt->v=u; ecnt->w=0;\n\t\tecnt->nxt=head[v];\n\t\tecnt->opp=ecnt-1;\n\t\thead[v]=ecnt++;\n\t}\n\tbool vis[NN];\n\tint d[NN],vd[NN];\n\tvoid Bfs() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(d,0x3f,sizeof(d));\n\t\tmemset(vd,0,sizeof(vd));\n\t\tqueue<int>Q;\n\t\tQ.push(t),vis[t]=true;\n\t\td[t]=0,vd[d[t]]++;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\t\tif(!vis[e->v]) {\n\t\t\t\t\tvis[e->v]=true;\n\t\t\t\t\tQ.push(e->v);\n\t\t\t\t\td[e->v]=d[u]+1;\n\t\t\t\t\tvd[d[e->v]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int Aug(int u,int flow) {\n\t\tif(u==t) return flow;\n\t\tint sum=0,delta;int mind=pcnt-1;\n\t\tfor(Edge *e=head[u];e;e=e->nxt) {\n\t\t\tif(e->w) {\n\t\t\t\tif(d[e->v]+1==d[u]) {\n\t\t\t\t\tdelta=min(e->w,flow-sum);\n\t\t\t\t\tdelta=Aug(e->v,delta);\n\t\t\t\t\tsum+=delta;\n\t\t\t\t\te->w-=delta;\n\t\t\t\t\te->opp->w+=delta;\n\t\t\t\t\tif(d[s]>=pcnt) return sum;\n\t\t\t\t\tif(sum==flow) break;\n\t\t\t\t}\n\t\t\t\tmind=min(mind,d[e->v]);\n\t\t\t}\n\t\t}\n\t\tif(sum==0) {\n\t\t\tvd[d[u]]--;\n\t\t\tif(vd[d[u]]==0)\n\t\t\t\td[s]=pcnt;\n\t\t\td[u]=mind+1;\n\t\t\tvd[d[u]]++;\n\t\t}\n\t\treturn sum;\n\t}\n\tint Flow;\n\tint ISAP() {\n\t\tBfs();\n\t\tFlow=0;\n\t\twhile(d[s]<pcnt)\n\t\t\tFlow+=Aug(s,INF);\n\t\treturn Flow;\n\t}\n\tint flag[NN],nxt[NN];\n\tvector<int>bel[N];\n\tvoid Solve() {\n\t\tmemset(vis,0,sizeof(vis));\n\t\tfor(int i=1;i<n;i++)\n\t\t\tfor(Edge *e=head[i+n];e;e=e->nxt)\n\t\t\t\tif(!e->w)\n\t\t\t\t\tflag[i]=e->v,vis[e->v]=true;\n\t\tqueue<int>Q;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i]) {\n\t\t\t\tQ.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint ncnt=0;\n\t\twhile(!Q.empty()) {\n\t\t\tint u=Q.front(); Q.pop();\n\t\t\tncnt++;\n\t\t\tfor(int i=0;i<bel[u].size();i++) {\n\t\t\t\tint v=bel[u][i];\n\t\t\t\tif(!vis[v]) {\n\t\t\t\t\tvis[v]=true;\n\t\t\t\t\tnxt[v]=u;\n\t\t\t\t\tQ.push(flag[v]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ncnt!=n)\n\t\t\tprintf(\"-1\\n\");\n\t\telse for(int i=1;i<n;i++)\n\t\t\tprintf(\"%d %d\\n\",nxt[i],flag[i]);\n\t}\n}NF;\n\nint main() {\n\tscanf(\"%d\",&n);\n\tNF.Init(0,2*n); NF.pcnt=2*n+1;\n\tfor(int i=1,c;i<n;i++) {\n\t\tscanf(\"%d\",&c);\n\t\tNF.AddEdge2(NF.s,n+i,1);\n\t\tfor(int j=1,u;j<=c;j++) {\n\t\t\tscanf(\"%d\",&u);\n\t\t\tNF.AddEdge2(n+i,u,1);\n\t\t\tNF.bel[u].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tNF.AddEdge2(i,NF.t,1);\n\tif(NF.ISAP()<n-1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tNF.Solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],ans[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=S; dis[S]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[T]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]+1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(u+n,i,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i+n+1,1); dinic::Add(i,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; ans[j]=i; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,n-1) printf(\"%d %d\\n\",id[i],ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define lg long long\n#define db double\n#define lb(x) ((x)&-(x))\n#define ft first\n#define sd second\n\n#define HII cerr<<\"HI\"<<endl\n#define LLLINE cerr<<\"@@@@@@@@@@@@@@@@@@@@\"<<endl\n\ntemplate <class _T_>\nvoid read(_T_& d){\n\td=0;int f=1;char c=getchar();\n\tfor(;c<'0'||c>'9';c=getchar())if(c=='-')f*=-1;\n\tfor(;c>='0'&&c<='9';c=getchar())d=d*10+c-'0';\n\td*=f;\n}\n\n/************************************************/\n#define MN 2000005\n#define inf 0x3f3f3f3f\nint n;\nint nex[MN],vi[MN],wi[MN],fr[MN],tot=0;\nvoid _add(int x,int y,int z){\n\tnex[++tot]=fr[x];fr[x]=tot;vi[tot]=y;wi[tot]=z;\n}\nvoid add(int x,int y,int z){\n\t_add(x,y,z);_add(y,x,0);\n}\nint c[MN];\nint cur[MN],d[MN];\nint u[MN];\nint s,t;\nvector<int> z[MN/20+1];\n#define rev(i) (((i-1)^1)+1)\nint wow(int x,int f){\n\tif(x==t||f==0)return f;\n\tint fl=0,ff;\n\tfor(int& i=cur[x];i;i=nex[i]){\n\t\tif(d[vi[i]]==d[x]-1&&(ff=wow(vi[i],min(f,wi[i])))>0){\n\t\t\t\tfl+=ff;wi[i]-=ff;wi[rev(i)]+=ff;f-=ff;\n\t\t\t\tif(!f)break;\n\t\t}\n\t}\n\tif(!f)return fl;\n\tcur[x]=fr[x];\n\tif(--u[d[x]]==0)d[s]=t+3;else ++u[++d[x]];\n\treturn fl;\n}\nint resl[MN],resr[MN];\nint main(){\n\tread(n);\n\ts=n+n;t=s+1;\n\tfor(int i=1;i<=n;++i)add(i,t,1);\n\tfor(int i=1,x,t;i<n;++i){\n\t\tread(t);add(s,i+n,1);\n\t\twhile(t--)read(x),add(n+i,x,1),z[x].pb(i);\n\t}\n\tint res=0;u[0]=t;\n\tfor(int i=1;i<=t;++i)cur[i]=fr[i];\n\twhile(d[s]<t+2)res+=wow(s,inf);\n\tif(res<n-1)return puts(\"-1\"),0;\n\tint K=0;\n\tfor(int x=1;x<=n;++x){\n\t\tfor(int i=fr[x];i;i=nex[i]){\n\t\t\tif(wi[i]==1&&vi[i]>n&&vi[i]<n+n&&!c[vi[i]-n]){\n\t\t\t\tc[vi[i]-n]=x;goto Ass;\n\t\t\t}\n\t\t}K=x;Ass:;\n\t}res=0;\n\tqueue<pii> Q;\n\tfor(auto x:z[K])Q.push(mp(K,x));\n\tmemset(u,0,sizeof u);\n\twhile(!Q.empty()){\n\t\tint x=Q.front().ft,y=Q.front().sd;Q.pop();\n\t\tif(x==c[y]||u[y])continue;u[y]=x;y=c[y];++res;\n\t\tfor(auto b:z[y])Q.push(mp(y,b));\n\t}\n\tif(res!=n-1)return puts(\"-1\"),0;\n\tfor(int i=1;i<n;++i)printf(\"%d %d\\n\",u[i],c[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n  _|_|                              _|  _|    _|\n_|    _|  _|  _|_|  _|_|_|_|        _|  _|  _|\n_|    _|  _|_|          _|          _|  _|_|\n_|    _|  _|          _|      _|    _|  _|  _|\n  _|_|    _|        _|_|_|_|    _|_|    _|    _|\n\n*/\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<set>\n//#define ls (rt<<1)\n//#define rs (rt<<1|1)\n#define vi vector<int>\n#define pb push_back\n#define mk make_pair\n#define pii pair<int,int>\n#define rep(i,a,b) for(int i=(a),i##end=(b);i<=i##end;i++)\n#define fi first\n#define se second\ntypedef long long ll;\nconst int maxn=2e5+1000;\nconst int inf=1e9+100;\nusing namespace std;\nvi E[maxn],inset[maxn];\nint s=2e5+1,t=2e5+2,cnt=1,head[maxn];\nstruct gg{\n    int u,v,w,next;\n}side[maxn*4];\nvoid ins(int u,int v,int w) {\n    side[++cnt]=(gg){u,v,w,head[u]};head[u]=cnt;\n    side[++cnt]=(gg){v,u,0,head[v]};head[v]=cnt;\n}\nint rk[maxn],cur[maxn];\nqueue<int>q;\nbool bfs() {\n    memset(rk,0,sizeof(rk));rk[s]=1;\n    while(!q.empty())q.pop();q.push(s);\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=head[u];i;i=side[i].next) {\n            int v=side[i].v;if(rk[v]||!side[i].w)continue;\n            rk[v]=rk[u]+1;\n            q.push(v);\n        }\n    }\n    if(!rk[t])return 0;\n    return 1;\n}\nint dfs(int u,int flow) {\n    if(u==t||!flow)return flow;\n    int tot=0;\n    for(int &i=cur[u];i;i=side[i].next) {\n        int v=side[i].v;//cout<<v<<' '<<rk[v]<<endl;\n        if(rk[v]!=rk[u]+1||!side[i].w)continue;\n        int sent=dfs(v,min(flow,side[i].w));\n        side[i].w-=sent;side[i^1].w+=sent;\n        flow-=sent;tot+=sent;\n    }\n    return tot;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(cur,head,sizeof(cur));\n        maxflow+=dfs(s,inf);\n    }\n    return maxflow;\n}\nint match[maxn];//match[set_id]=match_point_id\nbool inq[maxn];\npii ans[maxn];\nint main(){\n    //ios::sync_with_stdio(0);\n    int n;scanf(\"%d\",&n);//cin>>n;\n    rep(i,1,n-1) {\n        int c;scanf(\"%d\",&c);//cin>>c;\n        rep(j,1,c) {\n            int u;scanf(\"%d\",&u);//cin>>u;\n            E[i].pb(u);inset[u].pb(i);\n            ins(u,n+i,1);\n        }\n    }\n    rep(i,2,n)ins(s,i,1);\n    rep(i,1,n-1)ins(n+i,t,1);\n    int flow=dinic();\n    if(flow!=n-1) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    rep(i,n+1,n+n-1) {\n        for(int j=head[i];j;j=side[j].next) {\n            int v=side[j].v;\n            if(v<=n&&side[j].w) {\n                match[i-n]=v;break;\n            }\n        }\n    }\n    while(!q.empty())q.pop();\n    int tot=1;q.push(1);inq[1]=1;\n    while(!q.empty()) {\n        int u=q.front();q.pop();\n        for(int i=0;i<inset[u].size();i++) {\n            int setid=inset[u][i],set_match=match[setid];\n            if(!inq[set_match]) {\n                inq[set_match]=1;ans[setid]=mk(u,set_match);\n                q.push(set_match);tot++;\n            }\n        }\n    }\n    if(tot!=n) {\n        printf(\"-1\\n\");//cout<<\"-1\";\n        return 0;\n    }\n    for(int i=1;i<n;i++) {\n        printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n        //cout<<ans[i].fi<<' '<<ans[i].se<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int inf=1000000000;\nint n,m,cnt,p[100001],P[100001],hd[200101],cur[200101],dis[200101],q[200101],l,r,K,x,ans;\nstruct node{int to,next,c;}e[1000001];\nvector<int> v[100001],t[100001];\nbool bo[200101];\n\nvoid addedge(int x,int y,int c) \n{\n\te[++cnt]=(node){y,hd[x],c},hd[x]=cnt;\n\te[++cnt]=(node){x,hd[y],0},hd[y]=cnt;\n}\n\nbool bfs()\n{\n\tfor (int i=1; i<=n+n+1; i++) dis[i]=inf;\n\tq[l=r=1]=1,dis[1]=0,memset(bo,0,sizeof(bo)),bo[1]=1;\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\tif (e[i].c&&!bo[e[i].to]) bo[e[i].to]=1,q[++r]=e[i].to,dis[e[i].to]=dis[x]+1;\n\t\tl++;\n\t}\n\treturn dis[n+n+1]<inf;\n}\n\nbool dinic(int x)\n{\n\tif (x==n+n+1) return 1;\n\tfor (int &i=cur[x]; i; i=e[i].next)\n\t\tif (e[i].c&&dis[e[i].to]==dis[x]+1&&dinic(e[i].to)) \n\t\t\treturn e[i].c--,e[i^1].c++,1;\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),cnt=1;\n\tmemset(hd,0,sizeof(hd));\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&K),v[i].clear();\n\t\tfor (int j=1; j<=K; j++) scanf(\"%d\",&x),v[i].push_back(x);\n\t}\n\tfor (int i=1; i<n; i++) addedge(1,i+1,1);\n\tfor (int i=1; i<=n; i++) addedge(i+n,n+n+1,1),t[i].clear();\n\tfor (int i=1; i<n; i++)\n\t\tfor (int siz=v[i].size(),j=0; j<siz; j++) \n\t\t\taddedge(i+1,v[i][j]+n,1);\n\tans=0;\n\twhile (bfs())\n\t{\n\t\tfor (int i=1; i<=n+n+1; i++) cur[i]=hd[i];\n\t\twhile (dinic(1)) ans++;\n\t}\n\tif (ans!=n-1) return puts(\"-1\"),0;\n\tmemset(bo,0,sizeof(bo));\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=hd[i+1]; j; j=e[j].next)\n\t\t\tif (!e[j].c) {bo[p[i]=e[j].to-n]=1; break;}\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=0,siz=v[i].size(); j<siz; j++)\n\t\t\tif (v[i][j]!=p[i]) t[v[i][j]].push_back(p[i]);\n\tfor (int i=1; i<=n; i++) if (!bo[i]) q[l=r=1]=i;\n\tmemset(P,0,sizeof(P));\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=0,siz=t[x].size(); i<siz; i++)\n\t\t\tif (!P[t[x][i]]) P[t[x][i]]=x,q[++r]=t[x][i];\n\t\tl++;\n\t}\n\tif (r<n) return puts(\"-1\"),0;\n\tfor (int i=1; i<n; i++) printf(\"%d %d\\n\",p[i],P[p[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//\n//10^5210^5\n//\nnamespace MF{\n\t#define MAXN 512810\n\t#define MAXM 512810//2\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//S\n\t//levS(AOJ2396verify)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//\nbool used[200100];//\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\tmemset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <queue>\n#include <vector>\nusing namespace std;\ninline int read()\n{\n\tint f = 1, x = 0;\n\tchar ch;\n\n\tdo{\n\t\tch = getchar();\n\t\tif (ch == '-')\n\t\t\tf = -1;\n\t}while(ch < '0' || ch > '9');\n\tdo{\n\t\tx = x * 10 + ch - '0';\n\t\tch = getchar();\n\t}while(ch >= '0' && ch <= '9');\n\treturn f * x;\n}\nconst int N = 2e5;\n\nint l, r, n, m, s, t;\nstruct Edge {\n\tint\tto, next, oppo;\n\tint\tdone, maxx;\n} edge[(N << 3) + 1];\nint tot, start[N + 1], cur[N + 1];\nqueue<int> q;\nint vis[N + 1], dep[N + 1];\nint to[N + 1], viss[N + 1];\nvector<int> in[N + 1];\nint ans;\nint ansa[N + 1], ansb[N + 1];\n\ninline void addedge(int u, int v, int flow)\n{\n\tedge[++tot] = Edge{ v, start[u], tot + 1, 0, flow };\n\tstart[u] = tot;\n\tedge[++tot] = Edge{ u, start[v], tot - 1, 0, 0 };\n\tstart[v] = tot;\n\treturn;\n}\ninline bool bfs()\n{\n\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\tvis[i] = dep[i] = 0;\n\tq.push(s);\n\tdep[s] = vis[s] = 1;\n\twhile (q.size()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = start[u]; i; i = edge[i].next) {\n\t\t\tint v = edge[i].to;\n\t\t\tif (!vis[v] && edge[i].done < edge[i].maxx) {\n\t\t\t\tdep[v] = dep[u] + 1;\n\t\t\t\tvis[v] = 1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dep[t];\n}\ninline int dfs(int u, int flow)\n{\n\tif (u == t || !flow)\n\t\treturn flow;\n\tint val = 0;\n\tfor (int &i = cur[u]; i; i = edge[i].next) {\n\t\tint v = edge[i].to;\n\t\tif (dep[v] == dep[u] + 1) {\n\t\t\tint w = dfs(v, min(flow, edge[i].maxx - edge[i].done));\n\t\t\tif (w > 0) {\n\t\t\t\tedge[i].done += w;\n\t\t\t\tedge[edge[i].oppo].done -= w;\n\t\t\t\tval += w;\n\t\t\t\tflow -= w;\n\t\t\t\tif (!flow)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn val;\n}\ninline void dinic()\n{\n\twhile (bfs()) {\n\t\tfor (int i = 0; i <= (n << 1) - 1; i++)\n\t\t\tcur[i] = start[i];\n\t\tans += dfs(s, 2147483647);\n\t}\n\treturn;\n}\ninline int solve()\n{\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (int j = start[i]; j; j = edge[j].next) {\n\t\t\tif (edge[j].to)\n\t\t\t\tif (edge[j].done)\n\t\t\t\t\tto[i] = edge[j].to - n + 1;\n\t\t}\n\t}\n\tq.push(n);\n\tint link = 0;\n\twhile (!q.empty()) {\n\t\tint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < in[u].size(); i++) {\n\t\t\tint v = in[u][i];\n\t\t\tif (viss[v])\n\t\t\t\tcontinue;\n\t\t\tlink++;\n\t\t\tansa[v] = u;\n\t\t\tansb[v] = to[v];\n\t\t\tq.push(to[v]);\n\t\t\tviss[v] = 1;\n\t\t}\n\t}\n\treturn link;\n}\nint main()\n{\n\tn = read();\n\ts = 0;\n\tt = (n << 1) - 1;\n\tfor (int i = 1; i < n; i++) {\n\t\tint k = read();\n\t\tfor (int j = 1; j <= k; j++) {\n\t\t\tint x = read();\n\t\t\tif (x != n)\n\t\t\t\taddedge(i, n + x - 1, 1e9);\n\t\t\tin[x].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\taddedge(0, i, 1);\n\tfor (int i = 1; i <= n; i++)\n\t\taddedge(i + n - 1, (n << 1) - 1, 1);\n\n\tdinic();\n\n\tif (ans < n - 1) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\tif (solve() < n - 1) {\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", ansa[i], ansb[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU \n// #pragma GCC optimize(\"O3\")  // CPU \n// #pragma GCC optimize(\"unroll-loops\")  // \n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double INF=1e+10;\nconst long double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\t// if(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// \n\nconst int D_MAX_V=200002;\nconst int D_v_size=200002;\nstruct D_wolf{\n\tint t,c,r;\n\tD_wolf(){t=c=r=0;}\n\tD_wolf(int t1,int c1,int r1){\n\t\tt=t1;c=c1;r=r1;\n\t}\n};\nvector<D_wolf>D_G[D_MAX_V];\nint D_level[D_MAX_V];\nint D_iter[D_MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n\tD_G[from].push_back(D_wolf(to,cap,D_G[to].size()));\n\tD_G[to].push_back(D_wolf(from,0,D_G[from].size()-1));\n}\nvoid D_bfs(int s){\n\tfor(int i=0;i<D_v_size;i++)D_level[i]=-1;\n\tqueue<int> Q;\n\tD_level[s]=0;\n\tQ.push(s);\n\twhile(Q.size()){\n\t\tint v=Q.front();\n\t\tQ.pop();\n\t\tfor(int i=0;i<D_G[v].size();i++){\n\t\t\tif(D_G[v][i].c>0&&D_level[D_G[v][i].t]<0){\n\t\t\t\tD_level[D_G[v][i].t]=D_level[v]+1;\n\t\t\t\tQ.push(D_G[v][i].t);\n\t\t\t}\n\t\t}\n\t}\n}\nint D_dfs(int v,int t,int f){\n\tif(v==t)return f;\n\tfor(;D_iter[v]<D_G[v].size();D_iter[v]++){\n\t\tint i=D_iter[v];\n\t\tif(D_G[v][i].c>0&&D_level[v]<D_level[D_G[v][i].t]){\n\t\t\tint d=D_dfs(D_G[v][i].t,t,min(f,D_G[v][i].c));\n\t\t\tif(d>0){\n\t\t\t\tD_G[v][i].c-=d;\n\t\t\t\tD_G[D_G[v][i].t][D_G[v][i].r].c+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\nint max_flow(int s,int t){\n\tint flow=0;\n\tfor(;;){\n\t\tD_bfs(s);\n\t\tif(D_level[t]<0)return flow;\n\t\tfor(int i=0;i<D_v_size;i++)D_iter[i]=0;\n\t\tint f;\n\t\twhile((f=D_dfs(s,t,99999999))>0){flow+=f;}\n\t}\n\treturn 0;\n}\nvector<int>v[110000];\nint ans[110000];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\n\tint S=a+a-1;\n\tint T=a+a;\n\tfor(int i=0;i<a-1;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tv[i].push_back(c);\n\t\t}\n\t\tstd::sort(v[i].begin(),v[i].end());\n\t\tfor(int j=1;j<b;j++){\n\t\t\tadd_edge(i,a-1+v[i][j],1);\n\t\t}\n\t\tadd_edge(S,i,1);\n\t}\n\n\tfor(int i=0;i<a;i++){\n\t\tadd_edge(i+a-1,T,1);\n\t}\n\tint ret=max_flow(S,T);\n\tif(ret!=a-1){\n\t\tprintf(\"-1\\n\");return 0;\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tfor(int j=0;j<D_G[i].size();j++){\n\t\t\tint to=D_G[i][j].t;\n\t\t\tif(to<a+a-1&&D_G[i][j].c==0){\n\t\t\t\tans[i]=to-(a-1);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a-1;i++){\n\t\tprintf(\"%d %d\\n\",v[i][0]+1,ans[i]+1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n// #include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\ntypedef long long LL;\ntypedef double db;\nconst int oo=2139063143;\nconst int N=1010000;\nconst int P=1000000007;\nconst db eps=1e-7;\n#define pritnf printf\n//char buf[1<<22],*p1=buf,*p2=buf,obuf[1<<22],*O=obuf;\n//#define getchar() (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++)\ntemplate <typename T>\ninline void sc (T &x)\n{\n    x=0; static int p; p=1; static char c; c=getchar();\n    while (!isdigit(c)) { if (c=='-') p=-1; c=getchar(); }\n    while ( isdigit(c)) { x=(x<<1)+(x<<3)+(c-48); c=getchar(); }\n    x*=p;\n}\ntemplate <typename T>\ninline void print (T x)\n{\n    if (x< 0) putchar('-'),x=-x;\n    if (x>=10) print(x/10);\n    putchar(x%10+'0');\n}\ntemplate <typename T>\ninline void pr (T x) { print(x),putchar('\\n'); }\ntemplate <typename T1,typename T2>\nvoid chkmax (T1 &A,T2 B) { A=A>=B?A:B; }\ntemplate <typename T1,typename T2>\nvoid chkmin (T1 &A,T2 B) { A=A<=B?A:B; }\nstruct EDGE { int v,w,nx; }lb[N<<3]; int tot=1,top[N],cur[N];\nvoid add (int u,int v,int w)\n{\n\tlb[++tot]=(EDGE){v,w,top[u]},top[u]=tot;\n\tlb[++tot]=(EDGE){u,0,top[v]},top[v]=tot;\n}\nint s,t,dep[N];\nbool bfs ()\n{\n\tmemcpy (cur,top,sizeof (int)*(t+1));\n\tmemset (dep,0,sizeof (int)*(t+1));\n\tqueue <int> q;\n\tdep[s]=1,q.push (s);\n\twhile (q.size ())\n\t{\n\t\tint u=q.front (); q.pop ();\n\t\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t\t{\n\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\tif (w&&!dep[v]) dep[v]=dep[u]+1,q.push (v);\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dinic (int u,int flow)\n{\n\tif (u==t) return flow;\n\tint rest=flow;\n\tfor (int &kb=cur[u]; kb; kb=lb[kb].nx)\n\t{\n\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\tif (w&&dep[v]==dep[u]+1)\n\t\t{\n\t\t\tint k=dinic (v,min (rest,w));\n\t\t\tif (!k) dep[v]=1;\n\t\t\trest-=k;\n\t\t\tlb[kb].w-=k,lb[kb^1].w+=k;\n\t\t\tif (!rest) break;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nint n,pos[N],x[N],y[N];\nbool vis[N];\nvoid dfs (int u)\n{\n\tint nx=0;\n\tfor (int kb=top[u]; kb; kb=lb[kb].nx)\n\t{\n\t\tint v=lb[kb].v;\n\t\tif (v< s&&!vis[v])\n\t\t{\n\t\t\tnx=v,vis[v]=1;\n\t\t\tx[nx-n]=u;\n\t\t\tfor (int kb=top[nx]; kb; kb=lb[kb].nx)\n\t\t\t{\n\t\t\t\tint v=lb[kb].v,w=lb[kb].w;\n\t\t\t\tif (w&&v<=n) { y[nx-n]=v; break; }\n\t\t\t}\n\t\t\tdfs (y[nx-n]);\n\t\t}\n\t}\n\t\n\n}\nint main ()\n{\n    // freopen (\".in\",\"r\",stdin);\n    // freopen (\".out\",\"w\",stdout);\n\tsc(n); s=n<<1,t=s+1;\n\tfor (int i=1; i< n; i++)\n\t{\n\t\tint m,x; sc(m); add (n+i,t,1);\n\t\tfor (int j=1; j<=m; j++)\n\t\t\tsc(x),add (x,n+i,1);\n\t}\n\tfor (int i=1; i<=n; i++)\n\t\tadd (s,i,1),pos[i]=tot;\n\tint ans=0,flow=0;\n\twhile (bfs ())\n\t\twhile ((flow=dinic (s,oo))) ans+=flow;\n\tif (ans!=n-1) return pr(-1),0;\n\tint rt=0;\n\tfor (int i=1; i<=n; i++)\n\t\tif (!lb[pos[i]].w) { rt=i; break; }\n\tdfs (rt);\n\tfor (int i=1; i< n; i++)\n\t\tif (!x[i]) return pr(-1),0;\n\tfor (int i=1; i< n; i++)\n\t\tprintf (\"%d %d\\n\",x[i],y[i]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = (a); i <= (b); i++)\n#define per(i, a, b) for(int i = (a); i >= (b); i--)\n#define pb push_back\nusing namespace std;\nconst int S = 1;\nconst int INF = 0x3f3f3f3f;\nconst int N = 300010;\nint n, s, t, tot;\nvector<int> hv[N];\nint cnt = 1, cur[N * 4], hed[N * 4], to[N * 4], nxt[N * 4], val[N * 4];\nint dep[N], bl[N];\nint ax[N], ay[N], la; bool vis[N];\n\ninline void add(int x, int y, int z) {\n\tto[++cnt] = y, nxt[cnt] = hed[x], hed[x] = cnt, val[cnt] = z;\n\tto[++cnt] = x, nxt[cnt] = hed[y], hed[y] = cnt, val[cnt] = 0;\n}\nbool bfs() {\n\tqueue<int> q; rep(i, s, t) dep[i] = 0; dep[s] = 1, q.push(s);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop();\n\t\tfor(int i = cur[u], ii = cur[u];;) {\n\t\t\tif(val[i] && !dep[to[i]]) dep[to[i]] = dep[u] + 1, q.push(to[i]);\n\t\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t\t}\n\t}\n\treturn dep[t];\n}\nint dfs(int u, int flow) {\n\tif(u == t) return flow;\n\tfor(int i = cur[u], ii = cur[u];;) {\n\t\tif(dep[to[i]] == dep[u] + 1 && val[i]) {\n\t\t\tint w = dfs(to[i], min(flow, val[i]));\n\t\t\tif(w) { cur[u] = i, val[i] -= w, val[i ^ 1] += w; return w; }\n\t\t}\n\t\ti = nxt[i]; if(!i) i = hed[u]; if(i == ii) break;\n\t}\n\tdep[u] = 0; return 0;\n}\nint Dinic() {\n\tint flow = 0; rep(i, s, t) cur[i] = hed[i];\n\tfor(; bfs();) for(int ad = dfs(s, INF); ad; flow += ad, ad = dfs(s, INF));\n\treturn flow;\n}\nint main() {\n\tscanf(\"%d\", &n), s = 0, t = n + n; rep(i, 2, n) add(n - 1 + i, t, 1);\n\trep(i, 1, n - 1) {\n\t\tadd(s, i, 1); int k; scanf(\"%d\", &k);\n\t\tfor(int x; k; --k) {\n\t\t\tscanf(\"%d\", &x), hv[x].pb(i); if(x != S) add(i, n - 1 + x, 1);\n\t\t}\n\t}\n\tint Flow = Dinic(); if(Flow != n - 1) { puts(\"-1\"); return 0; }\n\tqueue<int> q; q.push(S);\n\tfor(int i = 2; i <= cnt; i += 2) if(!val[i]) {\n\t\tint y = to[i], x = to[i ^ 1]; if(x == s || x >= n) continue;\n\t\tbl[x] = y - n + 1;\n\t}\n//\trep(i, 1, n - 1) printf(\">>> %d %d\\n\", i, bl[i]);\n\tfor(int u; !q.empty();) {\n\t\tu = q.front(), q.pop(), ++tot;\n\t\tfor(auto v : hv[u]) if(!vis[v]) {\n\t\t\tvis[v] = 1, q.push(bl[v]), ++la, ax[la] = u, ay[la] = bl[v];\n\t\t}\n\t}\n\tif(tot != n) { puts(\"-1\"); return 0; }\n\trep(i, 1, n - 1) printf(\"%d %d\\n\", ax[i], ay[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define PRINT(x...) TRACE(printf(x))\n#define WATCHR(a, b) TRACE(for (auto c=a; c!=b;) cout << *(c++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define FU(i, a, b) for (auto i = a; i < b; ++i)\n#define fu(i, b) FU(i, 0, b)\n#define FD(i, a, b) for (auto i = (b) - 1; i >= a; --i)\n#define fd(i, b) FD(i, 0, b)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nll mod(ll a, ll b) {\n  return ((a%b)+b)%b;\n}\n\nint cmp(double x, double y = 0, double tol = 1.e-7) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\nstruct graph {\n  vi dest;  // use sz(dest) as number of arcs\n  vvi adj;  // use sz(adj) as number of vertices\n  int inv(int a) { return a ^ 0x1; }\n  graph(int n = 0) {\n    adj.resize(n);\n  }\n  // Adds an arc to the graph. u is capacity, c is cost.\n  // u is only needed on flows, and c only on min-cost-flow\n  int arc(int i, int j, ll u = 1) {\n    dest.pb(j);\n    adj[i].pb(sz(dest)-1);\n    dest.pb(i);\n    adj[j].pb(sz(dest)-1);\n    cap.pb(u); // For both flows\n    cap.pb(0);\n    return sz(dest)-2;\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  // For both flows!!\n  //\n\n  vll cap, flow;\n\n  int orig(int a) { return dest[inv(a)]; }\n  ll capres(int a) { return cap[a] - flow[a]; }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Max Flow! - Dinic O(n^2 * m)\n  // don't call maxflow with ini == end\n  //\n\n  vi curAdj, d;\n\n  bool MFbfs(int s, int t) {\n    d.assign(sz(adj), INT_MAX/2);\n    curAdj = vi(sz(adj));\n    d[s] = 0;\n    queue<int> Q; Q.push(s);\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (auto i : adj[u]) {\n        int v = dest[i];\n        if (capres(i) > 0 && d[v] == INT_MAX/2) {\n          d[v] = d[u] + 1; Q.push(v);\n        }\n      }\n    }\n    return d[t] != INT_MAX/2;\n  }\n\n  ll MFdfs(int u, int t, ll f) {\n    if (u == t) return f;\n    for(int &i = curAdj[u]; i < adj[u].size(); ++i) {\n      int ar = adj[u][i], v = dest[ar];\n      if (d[v] != d[u]+1 || capres(ar) == 0) continue;\n      ll tmpF = MFdfs(v, t, min(f, capres(ar)));\n      if (tmpF) {\n        flow[ar] += tmpF;\n        flow[inv(ar)] -= tmpF;\n        return tmpF;\n      }\n    }\n    return 0;\n  }\n\n  ll maxflow(int ini, int end) {\n    flow.assign(sz(dest), 0);\n    while (MFbfs(ini, end))\n      while (MFdfs(ini, end, LLONG_MAX/2));\n    ll F = 0;\n    for (int a : adj[ini]) F += flow[a];\n    return F;\n  }\n};\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tgraph G(2 * N + 1);\n\tfu(i, N-1) G.arc(0, 1 + i, 1);\n\tfu(i, N) G.arc(N + i, 2 * N, 1);\n\n\tvvi inc(N);\n\tfu(i, N-1) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x); x--;\n\t\t\tG.arc(1 + i, N + x, 1);\n\t\t\tinc[x].push_back(i);\n\t\t}\n\t}\n\n\tif (G.maxflow(0, 2*N) != (N - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\t// find the match of each set\n\tvi match(N-1);\n\tll root = 0;\n\tfu(i, N) root += i;\n\n\tfu(i, N-1) {\n\t\tfor (int a : G.adj[1 + i])\n\t\t\tif (G.flow[a] == 1) {\n\t\t\t\tmatch[i] = G.dest[a] - N;\n\t\t\t\troot -= G.dest[a] - N;\n\t\t\t}\n\t}\n\n\tqueue<int> Q;\n\tQ.push(root);\n\tvb mark(N, false);\n\tmark[root] = true;\n\n\tvector<pair<int, int>> ans(N - 1);\n\tint tot = 0;\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\ttot++;\n\n\t\tfor (int s : inc[x]) {\n\t\t\tint y = match[s];\n\t\t\tif (mark[y]) continue;\n\t\t\tmark[y] = true;\n\t\t\tQ.push(y);\n\t\t\tans[s] = {x, y};\n\t\t}\n\t}\n\n\tif (tot != N) printf(\"-1\\n\");\n\telse for (auto p : ans) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <queue>\n#include <vector>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define N 200005\n#define M 800005\n#define inf 0x3f3f3f3f\nint tar[M], nex[M], cap[M], fir[N], cnt = 1;\nint n, m, d[N], dx[N], use[N][2];\nvector<int>A[N];\nset<int>S[N];\nqueue<int>Q;\nvoid add(int a, int b, int c)\n{\n\t++cnt;\n\ttar[cnt] = b;\n\tcap[cnt] = c;\n\tnex[cnt] = fir[a];\n\tfir[a] = cnt;\n}\nvoid Add(int a, int b)\n{\n\tadd(a, b, 1);\n\tadd(b, a, 0);\n}\nint aug(int s, int b, int e, int g, int augco)\n{\n\tif (s == e)\n\t\treturn augco;\n\tint augc = augco, mind = g - 1;\n\tfor (int i = fir[s]; i; i = nex[i])\n\t{\n\t\tint v = tar[i];\n\t\tif (cap[i])\n\t\t{\n\t\t\tif (d[s] == d[v] + 1)\n\t\t\t{\n\t\t\t\tint delta = aug(v, b, e, g, min(augc, cap[i]));\n\t\t\t\tcap[i] -= delta;\n\t\t\t\tcap[i ^ 1] += delta;\n\t\t\t\taugc -= delta;\n\t\t\t\tif (!augc || d[b] == g)\n\t\t\t\t\treturn augco - augc;\n\t\t\t}\n\t\t\tmind = min(mind, d[v]);\n\t\t}\n\t}\n\tif (augco == augc)\n\t{\n\t\tdx[d[s]]--;\n\t\tif (!dx[d[s]])\n\t\t\td[b] = g;\n\t\tdx[d[s] = mind + 1]++;\n\t}\n\treturn augco - augc;\n}\nint sap(int b, int e, int g)\n{\n\tint flow = 0;\n\tmemset(d, 0, sizeof(d));\n\tmemset(dx, 0, sizeof(dx));\n\tdx[0] = g;\n\twhile (d[b] < g)\n\t\tflow += aug(b, b, e, g, inf);\n\treturn flow;\n}\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tint t;\n\t\tscanf(\"%d\", &t);\n\t\tfor (int j = 1; j <= t; j++)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x);\n\t\t\tS[x].insert(i);\n\t\t\tA[i].push_back(x);\n\t\t\tif (x != 1)\n\t\t\t\tAdd(i, n + x);\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tAdd(2 * n + 1, i);\n\t\tAdd(n + i, 2 * n + 2);\n\t}\n\tint ans = sap(2 * n + 1, 2 * n + 2, 2 * n + 2);\n\tif (ans < n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = fir[i]; j; j = nex[j])\n\t\t{\n\t\t\tint v = tar[j];\n\t\t\tif (v > n && !cap[j])\n\t\t\t\tuse[i][0] = v - n;\n\t\t}\n\t}\n\tQ.push(1);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.front();\n\t\tm++;\n\t\tQ.pop();\n\t\tset<int>::iterator it = S[x].begin();\n\t\tfor (; it != S[x].end(); it++)\n\t\t{\n\t\t\tif (!use[*it][1])\n\t\t\t{\n\t\t\t\tuse[*it][1] = x;\n\t\t\t\tQ.push(use[*it][0]);\n\t\t\t}\n\t\t}\n\t}\n\tif (m < n)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", use[i][0], use[i][1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <tr1/unordered_map>\n#define ri register int\n#define ptf printf\nusing namespace std;\ntypedef double db;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector <int> poly;\ntypedef pair <int, int> pii;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\ntypedef pair <ll, ll> pll;\ntypedef unsigned long long ulll;\ntypedef unsigned int uii;\ntypedef string strr;\n#define fi first\n#define se second\n#define pb push_back\n#define ppp pop_back\n#define rez resize\nconst ll Inf = 2e18;\nconst int rlen = 1 << 20, inf = 0x3f3f3f3f;\nchar buf[rlen], *ib = buf, *ob = buf;\n#define gc() (((ib == ob) && (ob = (ib =  buf) + fread(buf, 1, rlen, stdin)), ib == ob) ? -1 : *ib++)\ninline int read() {\n  static int ans, f;\n  static char ch;\n  ans = 0, ch = gc(), f = 1;\n  while (!isdigit(ch)) f ^= ch == '-', ch = gc();\n  while (isdigit(ch)) ans = (ans << 3) + (ans << 1) + (ch ^ 48), ch = gc();\n  return f ? ans: -ans;\n}\ninline ll readl() {\n  static ll ans;\n  static char ch;\n  for (ans = 0, ch = gc(); !isdigit(ch); ch = gc());\n  while (isdigit(ch)) ans = ((ans << 2) + ans << 1) + (ch ^ 48), ch = gc();\n  return ans;\n}\ninline int Read(char *s) {\n  static int top;\n  static char ch;\n  top = 0, ch = gc();\n  while (!isalpha(ch) && !isdigit(ch)) ch = gc();\n  while (isalpha(ch) || isdigit(ch)) s[++top] = ch, ch = gc();\n  return top;\n}\nnamespace modular {\n  const int mod = 998244353;//= 1e9 + 7;\n  //int mod;\n  int ret;\n  inline int add(int a, int b) { return a + b < mod ? a + b : a + b - mod; }\n  inline int dec(int a, int b) { return a < b ? a - b + mod : a - b; }\n  inline int mul(int a, int b) { return (ll) a * b % mod; }\n  inline void Add(int &a, int b) { a = a + b < mod ? a + b : a + b - mod; }\n  inline void Dec(int &a, int b) { a = a < b? a - b + mod : a - b; }\n  inline void Mul(int &a, int b) { a = (ll) a * b % mod; }\n  inline int ksm(int a, int p) {\n    for (ret = 1; p; p >>= 1, Mul(a, a)) (p & 1) && (Mul(ret, a), 1);\n    return ret;\n  }\n  inline int Inv(int a) { return ksm(a, mod - 2); }\n  inline int sqr(int a) { return (ll) a * a % mod; }\n  inline int cub(int a) { return (ll) a * a % mod * a % mod; }\n} using namespace modular;\ntemplate <typename T> inline void ckmax(T &a, T b) { a < b ? a = b : 0; }\ntemplate <typename T> inline void ckmin(T &a, T b) { a > b ? a = b : 0; }\ntemplate <typename T> inline T Abs(T a) { return a < 0 ? -a : a; }\ntemplate <typename T> inline T gcd(T a, T b) {\n  T t;\n  while (b) t = a, a = b, b = t - t / a * a;\n  return a;\n}\ntemplate <typename T> inline void exgcd(T a, T b, T &x, T &y) {\n  if (!b) {\n    x = 1, y = 0;\n    return;\n  }\n  exgcd(b, a - a / b * b, y, x);\n  y -= a / b * x;\n}\nstruct E { int v, nxt, c; };\nconst int N = 2e5 + 5;\nint n, m;\nvector <int> g[N];\nnamespace Flow {\n  int d[N], cnt, fst[N], cur[N], s, t, ss, tt;\n  E e[2000005];\n  inline void init() {\n    cnt = -1, s = 0, t = n + m + 1;\n    for (ri i = s; i <= t; ++i) fst[i] = -1;\n  }\n  inline void addedge(int u, int v, int c) { e[++cnt] = (E) {v, fst[u], c}, fst[u] = cnt; }\n  inline void _add(int u, int v, int c) {\n    addedge(u, v, c);\n    addedge(v, u, 0);\n  }\n  inline bool bfs() {\n    queue <int> q;\n    for (ri i = 0; i <= n + m + 4; ++i) d[i] = -1;\n    q.push(s), d[s] = 0;\n    while (q.size()) {\n      int x = q.front();\n      q.pop(), cur[x] = fst[x];\n      for (ri i = fst[x], v; ~i; i = e[i].nxt) {\n        if (~d[v = e[i].v] || e[i].c <= 0) continue;\n        d[v] = d[x] + 1, q.push(v);\n      }\n    }\n    return ~d[t];\n  }\n  inline int dfs(int x, int f) {\n    if (x == t || !f) return f;\n    int fl = f;\n    for (ri &i = cur[x], v, tp; ~i; i = e[i].nxt) {\n      if (!fl) return f;\n      if (d[v = e[i].v] == d[x] + 1 && e[i].c > 0) {\n        tp = dfs(v, min(fl, e[i].c));\n        if (!tp) d[v] = -1;\n        e[i].c -= tp, e[i ^ 1].c += tp, fl -= tp;\n      }\n    }\n    return f - fl;\n  }\n  inline int solve() {\n    int res = 0, tp;\n    while (bfs()) while ((tp = dfs(s, inf)) > 0) res += tp;\n    return res;\n  }\n  bool vs[N];\n  pii ans[N];\n  inline void Solve() {\n    queue <int> q;\n    q.push(1);\n    int ct = 0;\n    while (q.size()) {\n      int x = q.front();\n      q.pop();\n      for (ri i = 0, v; i < g[x].size(); ++i) {\n        if (vs[v = g[x][i] + n]) continue;\n        vs[v] = 1;\n        for (ri j = fst[v]; ~j; j = e[j].nxt) if (e[j].c > 0) {\n          int _v = e[j].v;\n          ans[v] = pii(x, _v);\n          q.push(_v);\n          ++ct;\n        }\n      }\n    }\n    if (!ct) cout << -1, exit(0);\n    for (ri i = 1; i < n; ++i) cout << ans[i + n].fi << ' ' << ans[i + n].se << '\\n';\n  }\n}\nint main() {\n  #ifdef ldxcaicai\n  freopen(\"lx.in\", \"r\", stdin);\n  #endif\n  n = read(), m = n - 1;\n  Flow:: init();\n  for (ri i = 1; i <= n; ++i) Flow:: _add(Flow:: s, i, 1);\n  for (ri i = 1; i <= m; ++i) for (ri tt = read(); tt; --tt) {\n    int x = read();\n    g[x].pb(i);\n    if (x > 1) Flow:: _add(x, n + i, 1);\n  }\n  for (ri i = 1; i <= m; ++i) Flow:: _add(i + n, Flow:: t, 1);\n  if (Flow:: solve() != n - 1) return cout << -1, 0;\n  Flow:: Solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof x)\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define fi first\n#define se second\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outtag(x) cerr<<\"-----------------\"#x\"-----------------\\n\"\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n                    For(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef pair <int,int> pii;\nLL read(){\n    LL x=0,f=0;\n    char ch=getchar();\n    while (!isdigit(ch))\n        f=ch=='-',ch=getchar();\n    while (isdigit(ch))\n        x=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n    return f?-x:x;\n}\nconst int N=100005*2,INF=1e9;\nnamespace flows{\n\tconst int M=N*(2+2)*2;\n\tstruct Edge{\n\t\tint x,y,cap,nxt;\n\t\tEdge(){}\n\t\tEdge(int _x,int _y,int _cap,int _nxt){\n\t\t\tx=_x,y=_y,cap=_cap,nxt=_nxt;\n\t\t}\n\t}e[M];\n\tint cnt,n,S,T;\n\tint fst[N],vis[N],dis[N],cur[N];\n\tvoid clear(int _n,int _S,int _T){\n\t\tn=_n,S=_S,T=_T,cnt=1;\n\t\tclr(fst);\n\t}\n\tvoid Add(int x,int y,int cap){\n\t\te[++cnt]=Edge(x,y,cap,fst[x]),fst[x]=cnt;\n\t\te[++cnt]=Edge(y,x,0,fst[y]),fst[y]=cnt;\n\t}\n\tint bfs(){\n\t\tstatic int q[N];\n\t\tint head=0,tail=0;\n\t\tclr(vis);\n\t\tmemset(dis,-1,sizeof dis);\n\t\tdis[0]=0;\n\t\tq[++tail]=S;\n\t\twhile (head<tail){\n\t\t\tint x=q[++head];\n\t\t\tfor (int i=fst[x];i;i=e[i].nxt){\n\t\t\t\tint y=e[i].y;\n\t\t\t\tif (!vis[y]&&e[i].cap){\n\t\t\t\t\tdis[y]=dis[x]+1;\n\t\t\t\t\tq[++tail]=y;\n\t\t\t\t\tvis[y]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn vis[T];\n\t}\n\tint dfs(int x){\n\t\tif (x==T)\n\t\t\treturn 1;\n\t\tfor (int &i=cur[x];i;i=e[i].nxt){\n\t\t\tint y=e[i].y;\n\t\t\tif (e[i].cap&&dis[x]+1==dis[y]){\n\t\t\t\tif (dfs(y)){\n\t\t\t\t\te[i].cap^=1,e[i^1].cap^=1;\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Dinic(){\n\t\tint flow=0;\n\t\twhile (bfs()){\n\t\t\tFor(i,1,n)\n\t\t\t\tcur[i]=fst[i];\n\t\t\tclr(vis),flow+=dfs(S,INF);\n//\t\t\toutval(flow);\n\t\t}\n\t\treturn flow;\n\t}\n}\nint n;\nvector <int> s[N],e[N];\nint q[N],mat[N],fa[N],vis[N];\nint main(){\n\tn=read();\n\tint S=(n-1)*2+1,T=S+1;\n\tflows::clear(T,S,T);\n\tFor(i,1,n-1){\n\t\tflows::Add(S,i,1);\n\t\tflows::Add(i+n-1,T,1);\n\t\tint k=read();\n\t\twhile (k--){\n\t\t\tint j=read();\n\t\t\ts[i].pb(j);\n\t\t\te[j].pb(i);\n\t\t\tif (j!=n){\n\t\t\t\tflows::Add(j,i+n-1,1);\n\t\t\t}\n\t\t}\n\t}\n//\touttag(1);\n\tif (flows::Dinic()<n-1)\n\t\treturn puts(\"-1\"),0;\n//\touttag(2);\n\tFor(i,2,flows::cnt){\n\t\tint x=flows::e[i].x,y=flows::e[i].y;\n\t\tif (!flows::e[i].cap&&1<=x&&x<=n-1&&n<=y&&y<=n*2-2){\n\t\t\tmat[y-(n-1)]=x;\n//\t\t\tprintf(\"Mat[%d] = %d\\n\",y-(n-1),x);\n\t\t}\n\t}\n\tint head=0,tail=0;\n\tq[++tail]=n;\n\twhile (head<tail){\n\t\tint x=q[++head];\n\t\tfor (auto y : e[x]){\n\t\t\tif (vis[y])\n\t\t\t\tcontinue;\n\t\t\tvis[y]=1;\n\t\t\tfa[y]=x;\n\t\t\tq[++tail]=mat[y];\n\t\t}\n\t}\n//\touttag(3);\n\tif (tail<n)\n\t\treturn puts(\"-1\"),0;\n\tFor(i,1,n-1)\n\t\tprintf(\"%d %d\\n\",fa[i],mat[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\n#include<cassert>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\n//\n//10^5210^5\n//\nnamespace MF{\n\t#define MAXN 512810\n\t#define MAXM 512810//2\n\t#define wint int\n\tconst wint wEPS=0;\n\tconst wint wINF=1001001001;\n\tint n,m,ptr[MAXN],next[MAXM],zu[MAXM];\n\tint from[MAXM],to[MAXM];\n\twint capa[MAXM],tof;\n\tint lev[MAXN],see[MAXN],que[MAXN],*qb,*qe;\n\tvoid init(int _n){\n\t\tn=_n;m=0;memset(ptr,~0,n*4);\n\t}\n\tvoid ae(int u,int v,wint w0,wint w1=0){\n\t\tfrom[m]=u;to[m]=v;\n\t\tnext[m]=ptr[u];ptr[u]=m;zu[m]=v;capa[m]=w0;++m;\n\t\tfrom[m]=v;to[m]=u;\n\t\tnext[m]=ptr[v];ptr[v]=m;zu[m]=u;capa[m]=w1;++m;\n\t}\n\twint augment(int src,int ink,wint flo){\n\t\tif(src==ink) return flo;\n\t\twint f;\n\t\tfor(int &i=see[src];~i;i=next[i]) if(capa[i]>wEPS && lev[src]<lev[zu[i]]){\n\t\t\tif((f=augment(zu[i],ink,min(flo,capa[i])))>wEPS){\n\t\t\t\tcapa[i]-=f;capa[i^1]+=f;return f;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tbool solve(int src,int ink,wint flo=wINF){\n\t\twint f;\n\t\tint i,u,v;\n\t\tfor(tof=0;tof+wEPS<flo;){\n\t\t\tqb=qe=que;\n\t\t\tmemset(lev,~0,n*4);\n\t\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t\t\tif(v==ink) goto au;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\tau:\tfor(;(f=augment(src,ink,flo-tof))>wEPS;tof+=f);\n\t\t}\n\t\treturn 1;\n\t}\n\t//S\n\t//levS(AOJ2396verify)\n\tvoid cut(int src){\n\t\tint i,u,v;\n\t\tqb=qe=que;\n\t\tmemset(lev,~0,n*4);\n\t\tfor(lev[*qe++=src]=0,see[src]=ptr[src];qb!=qe;){\n\t\t\tfor(i=ptr[u=*qb++];~i;i=next[i]) if(capa[i]>wEPS && !~lev[v=zu[i]]){\n\t\t\t\tlev[*qe++=v]=lev[u]+1;see[v]=ptr[v];\n\t\t\t}\n\t\t}\n\t}\n}\nint p[200100];//\nbool used[200100];//\nvector<pint> gr[200100];\npint out[200100];\nvoid dfs(int v){\n\t//if(used[v]) return;\n\tused[v]=true;\n\trep(i,gr[v].size()){\n\t\tif(used[gr[v][i].fi]) continue;\n\t\tout[gr[v][i].se]=mp(v,gr[v][i].fi);\n\t\tdfs(gr[v][i].fi);\n\t}\n}\nvector<int> v[200100];\nint main()\n{\n\tint n,a,b;\n\tcin>>n;\n\trep(i,n-1){\n\t\tcin>>a;\n\t\trep(j,a){\n\t\t\tcin>>b;b--;v[i].pb(b);\n\t\t}\n\t}\n\tint S=2*n-1,T=S+1,V=T+1;\n\tMF::init(V);\n\trep(i,n-1){\n\t\tMF::ae(S,i,1);\n\t\trep(j,v[i].size()) MF::ae(i,n-1+v[i][j],1);\n\t\tMF::ae(n-1+i,T,1);\n\t}\n\tMF::solve(S,T);\n\t//cout<<MF::tof<<endl;\n\tif(MF::tof<n-1){\n\t\tcout<<-1<<endl;\n\t\treturn 0;\n\t}\n\t/*memset(p,-1,sizeof(p));\n\trep(i,MF::m){\n\t\tif(MF::from[i]<n-1 && MF::to[i]>=n-1 && MF::to[i]<S && MF::capa[i]<1) p[MF::from[i]]=MF::to[i]-n+1;\n\t}\n\t//rep(i,n-1) cout<<p[i]<<endl;\n\tmemset(used,false,sizeof(used));\n\trep(i,n-1) used[p[i]]=true;\n\tint root=-1;\n\trep(i,n){\n\t\tif(!used[i]) root=i;\n\t}\n\trep(i,n-1) rep(j,v[i].size()){\n\t\tif(v[i][j]==p[i]) continue;\n\t\tgr[v[i][j]].pb(mp(p[i],i));\n\t}\n\tmemset(used,false,sizeof(used));\n\tdfs(root);\n\trep(i,n){\n\t\tif(!used[i]){\n\t\t\tcout<<-1<<endl;return 0;\n\t\t}\n\t}\n\trep(i,n-1){\n\t\tcout<<out[i].fi+1<<' '<<out[i].se+1<<endl;\n\t}*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nconst int maxn = 100000 + 10;\nconst int N = maxn << 1;\nconst int maxE = maxn << 1;\nconst int INF = 0x3f3f3f3f;\n\nint n, h[N], ecnt, tot, S, T;\nstruct enode{\n\tint v, n, w, op;\n\tenode() {}\n\tenode(int _v, int _n, int _w, int _op):v(_v), n(_n), w(_w), op(_op) {}\n}e[maxE << 1];\n\ninline void addedge(int u, int v, int w) {\n\tecnt ++; e[ecnt] = enode(v,h[u],w,ecnt + 1); h[u] = ecnt;\n\tecnt ++; e[ecnt] = enode(u,h[v],0,ecnt - 1); h[v] = ecnt;\n}\n\nint level[N], q[N << 1], cur[N];\ninline bool bfs() {\n\tmemset(level,0,sizeof(level));\n\tint head = 1, tail = 0;\n\tlevel[S] = 1; q[++ tail] = S;\n\tfor(int i = S;i <= tot;i ++) cur[i] = h[i];\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = h[u];~ i;i = e[i].n) {\n\t\t\tint v = e[i].v;\n\t\t\tif(!level[v] && e[i].w > 0) {\n\t\t\t\tlevel[v] = level[u] + 1;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tif(v == T) return 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int c) {\n\tif(u == T || c == 0) return c;\n\tint tmp = 0;\n\tfor(int &i = cur[u];~ i;i = e[i].n) {\n\t\tint v = e[i].v;\n\t\tif(level[v] == level[u] + 1) {\n\t\t\tint x = dfs(v,min(c,e[i].w));\n\t\t\tif(x) {\n\t\t\t\te[i].w -= x; e[e[i].op].w += x;\n\t\t\t\ttmp += x; c -= x;\n\t\t\t\tif(!c) break;\n\t\t\t}\n\t\t}\n\t}\n\tif(!tmp) level[u] = -1;\n\treturn tmp;\n}\n\nint pre[maxn], used[maxn];\nvector<int> g[maxn], from[maxn];\n\nint main() {\n\tscanf(\"%d\", &n); tot = n;\n\tS = 0; T = ++ tot; ecnt = 0;\n\tmemset(h,-1,sizeof(h));\n\tfor(int i = 2;i <= n;i ++) addedge(i,T,1);\n\tfor(int i = 1;i < n;i ++) {\n\t\tint p = ++ tot;\n\t\taddedge(S,p,1);\n\t\tint k; scanf(\"%d\", &k);\n\t\tfor(int j = 1;j <= k;j ++) {\n\t\t\tint x; scanf(\"%d\", &x);\n\t\t\tg[i].push_back(x);\n\t\t\tfrom[x].push_back(i);\n\t\t\taddedge(p,x,INF);\n\t\t}\n\t}\n\tint flow = 0;\n\twhile(bfs())\n\t\tflow += dfs(S,INF);\n\tif(flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tint head = 1, tail = 0;\n\tq[++ tail] = 1; pre[1] = -1;\n\twhile(head <= tail) {\n\t\tint u = q[head]; head ++;\n\t\tfor(int i = 0, Sz = from[u].size();i < Sz;i ++) {\n\t\t\tint id = from[u][i];\n\t\t\tif(used[id]) continue;\n\t\t\tused[id] = 1;\n\t\t\tint flag = 0;\n\t\t\tfor(int j = 0, Sz = g[id].size();j < Sz;j ++) {\n\t\t\t\tint v = g[id][j];\n\t\t\t\tif(pre[v] != 0) continue;\n\t\t\t\tpre[v] = u;\n\t\t\t\tq[++ tail] = v;\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t}\n\t}\n\tfor(int i = 2;i <= n;i ++) {\n\t\tint u = pre[i], v = i;\n\t\tprintf(\"%d %d\\n\", u, v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing ii = pair<int, int>;\nusing vi = vector<int>;\n#define all(v) begin(v), end(v)\n#define rep(i,a,b) for(int i = a; i < b; ++i)\n#define sz(v) (int)(v).size()\n\nbool dfs(int a, int L, vector<vi>& g, vi& btoa, vi& A, vi& B) {\n  if (A[a] != L) return 0;\n  A[a] = -1;\n  for (int b : g[a]) if (B[b] == L + 1) {\n    B[b] = 0;\n    if (btoa[b] == -1 || dfs(btoa[b], L + 1, g, btoa, A, B))\n      return btoa[b] = a, 1;\n  }\n  return 0;\n}\n\nint hopcroftKarp(vector<vi>& g, vi& btoa) {\n  int res = 0;\n  vi A(g.size()), B(btoa.size()), cur, next;\n  for (;;) {\n    fill(all(A), 0);\n    fill(all(B), 0);\n    /// Find the starting nodes for BFS (i.e. layer 0).\n    cur.clear();\n    for (int a : btoa) if(a != -1) A[a] = -1;\n    rep(a,0,sz(g)) if(A[a] == 0) cur.push_back(a);\n    /// Find all layers using bfs.\n    for (int lay = 1;; lay++) {\n      bool islast = 0;\n      next.clear();\n      for (int a : cur) for (int b : g[a]) {\n        if (btoa[b] == -1) {\n          B[b] = lay;\n          islast = 1;\n        }\n        else if (btoa[b] != a && !B[b]) {\n          B[b] = lay;\n          next.push_back(btoa[b]);\n        }\n      }\n      if (islast) break;\n      if (next.empty()) return res;\n      for (int a : next) A[a] = lay;\n      cur.swap(next);\n    }\n    /// Use DFS to scan for augmenting paths.\n    rep(a,0,sz(g))\n      res += dfs(a, 0, g, btoa, A, B);\n  }\n}\n\nint main(int argc, char const *argv[])\n{\n#ifdef LOCAL\n  freopen(\"in\", \"r\", stdin);\n#endif\n  int n; scanf(\"%d\", &n);\n  vector<vi> li(n-1), g(n);\n  for(int i = 0; i < n-1; ++i) {\n    int k; scanf(\"%d\", &k);\n    li[i] = vi(k);\n    for(int& x : li[i]) {\n      scanf(\"%d\", &x);\n      x--;\n      g[x].push_back(i);\n    }\n  }\n  vi vis(2*n-1);\n  function<void(int)> dfs0 = [&](int u) {\n    vis[u] = 1;\n    if(u >= n) {\n      for(int& v : li[u-n]) {\n        if(!vis[v]) dfs0(v);\n      }\n    } else {\n      for(int& v : g[u]) {\n        if(!vis[v+n]) dfs0(v+n);\n      }\n    }\n  };\n  dfs0(0);\n  if(count(all(vis), 1) != 2*n-1) {\n    return puts(\"-1\"), 0;\n  }\n  vi g0 = g[0], btoa(n-1, -1);\n  g[0].clear();\n  hopcroftKarp(g, btoa);\n  g[0] = g0;\n  if(count(all(btoa), -1)) {\n    return puts(\"-1\"), 0;\n  }\n  vi atob(n, -1);\n  vector<ii> ans(n-1);\n  for(int i = 0; i < n-1; ++i) {\n    if(~btoa[i]) atob[btoa[i]] = i;\n  }\n  vis.assign(n, 0);\n  function<void(int)> dfs = [&](int u) {\n    vis[u] = 1;\n    for(int& m : g[u]) if(m != atob[u]) {\n      int v = btoa[m];\n      if(!vis[v]) {\n        ans[m] = {u, v};\n        dfs(v);\n      }\n    }\n  };\n  dfs(0);\n  for(int i = 0; i < n-1; ++i) {\n    printf(\"%d %d\\n\", ans[i].first+1, ans[i].second+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 300001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint next[N],head[N],edge[N],v[N],next2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z)\n{\n\ttotal2++;\n\tnext[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnext2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=next[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=next[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf);\n\tinsert(S,T,0);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i]);insert(i,SS,0);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i]);insert(TT,i,0);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=next2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j]);\n\t\t\tinsert(y,i,0);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+3*n,i,0,1);\n\t\t\tinsert2(i+n,s[i][j]+2*n,0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t\tprintf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst int MaxN = 1e5 + 100;\n\nvector<int> adj[MaxN];\nint N;\nbool visited[MaxN];\nint match_left[MaxN], match_right[MaxN];\nVI rev_adj[MaxN];\n\nbool DfsMatch(int v) {\n  if (visited[v]) { return false; }\n  visited[v] = true;\n  for (int s : adj[v]) {\n    if (match_right[s] == -1 || DfsMatch(match_right[s])) {\n      match_right[s] = v;\n      match_left[v] = s;\n      return true;\n    }\n  }\n  return false;\n}\n\nint Matching() {\n  fill_n(match_left, N, -1);\n  fill_n(match_right, N, -1);\n  int size = 0;\n  bool has_incr;\n  do {\n    has_incr = false;\n    fill_n(visited, N, false);\n    for (int i = 0; i < N; ++i)\n      if (match_left[i] == -1 && !visited[i] && DfsMatch(i)) {\n        ++size;\n        has_incr = true;\n      }\n  } while (has_incr);\n  return size;\n}\n\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n\n  cin >> N;\n  for (int i = 1; i <= N - 1; ++i) {\n    int sz;\n    cin >> sz;\n    for (int j = 0; j < sz; ++j) {\n      int v; cin >> v;\n      --v;\n      adj[i].PB(v);\n      rev_adj[v].PB(i);\n    }\n    adj[0].PB(i - 1);\n  }\n\n  if (Matching() != N) {\n    cout << \"-1\\n\";\n  }\n\n  for (int i = 0; i < N; ++i)\n    debug(i, match_left[i]);\n\n  vector<PII> edges(N - 1);\n  int num_edges = 0;\n  queue<int> Q;\n  vector<bool> vis_set(N);\n  vector<bool> vis_vert(N);\n\n  Q.push(match_left[0]);\n  vis_set[0] = true;\n  vis_vert[match_left[0]] = true;\n\n  while (!Q.empty()) {\n    const int v = Q.front();\n    Q.pop();\n\n    for (int set_id : rev_adj[v]) {\n      if (vis_set[set_id]) { continue; }\n      vis_set[set_id] = true;\n      const int s = match_left[set_id];\n      assert(!vis_vert[s]);\n      vis_vert[s] = true;\n      debug(set_id, v, s);\n      edges[set_id - 1] = make_pair(v, s);\n      ++num_edges;\n      Q.push(s);\n    }\n  }\n\n  if (num_edges != N - 1) {\n    cout << \"-1\\n\";\n    return 0;\n  }\n\n  for (auto &edge : edges)\n    cout << edge.st + 1 << \" \" << edge.nd + 1 << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e5+5;\nconst int inf=0x3f3f3f3f;\ninline int read(){\n\tchar c=getchar();int t=0,f=1;\n\twhile((!isdigit(c))&&(c!=EOF)){if(c=='-')f=-1;c=getchar();}\n\twhile((isdigit(c))&&(c!=EOF)){t=(t<<3)+(t<<1)+(c^48);c=getchar();}\n\treturn t*f;\n}\nint n,s,t;\nstruct edge{\n\tint v,p,w;\n}e[maxn<<1];\nint h[maxn],cnt=1;\ninline void add(int a,int b,int c){\n\te[++cnt].p=h[a];\n\te[cnt].v=b;\n\te[cnt].w=c;\n\th[a]=cnt;\n}\nint dis[maxn];\nbool bfs(){\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(s);\n\tmemset(dis,0,sizeof(dis));\n\tdis[s]=1;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(e[i].w&&!dis[v]){\n\t\t\t\tdis[v]=dis[u]+1;\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn dis[t];\n}\nint ht[maxn];\nint dfs(int u,int rest){\n\tif((u==t)||rest==0)return rest;\n\tint tot=0;\n\tfor(int &i=ht[u];i;i=e[i].p){\n\t\tint v=e[i].v;\n\t\tif(e[i].w&&dis[v]==dis[u]+1){\n\t\t\tint di=dfs(v,min(rest,e[i].w));\n\t\t\te[i].w-=di;e[i^1].w+=di;\n\t\t\trest-=di;tot+=di;\n\t\t\tif(rest==0)break;\n\t\t}\n\t}\n\treturn tot;\n}\nint dinic(){\n\tint ans=0;\n\twhile(bfs()){\n\t\tint di=0;\n\t\tfor(int i=s;i<=t;i++)ht[i]=h[i];\n\t\twhile(di=dfs(s,inf))ans+=di;\n\t}\n\treturn ans;\n}\nint cho[maxn];\nvector<int> g[maxn];\ntypedef pair<int,int> pii;\npii res[maxn];\nbool get(){\n\tfor(int u=1;u<n;u++){\n\t\tfor(int i=h[u];i;i=e[i].p){\n\t\t\tint v=e[i].v;\n\t\t\tif(v!=s&&(e[i].w==0)){cho[v-n]=u;}\n\t\t}\n\t}\n\tqueue<int> q;\n\twhile(!q.empty())q.pop();\n\tq.push(n);int sum=0;\n\twhile(!q.empty()){\n\t\tint u=q.front();q.pop();sum++;\n\t\tfor(int i=0;i<g[u].size();i++){\n\t\t\tint v=g[u][i];\n\t\t\tif(cho[v])res[v]=pii(u,cho[v]),q.push(cho[v]),cho[v]=0;\n\t\t}\n\t}\n\treturn sum==n;\n}\nsigned main(){\n\tn=read();s=0,t=n+n;\n\tfor(int i=1;i<n;i++){\n\t\tint k=read();\n\t\tfor(int j=1;j<=k;j++){\n\t\t\tint x=read();\n\t\t\tif(x!=n){\n\t\t\tadd(x,i+n,1);\n\t\t\tadd(i+n,x,0);\n\t\t\t}\n\t\t\tg[x].push_back(i);\n\t\t}\n\t\tadd(s,i,1);\n\t\tadd(i,s,0);\n\t\tadd(i+n,t,1);\n\t\tadd(t,i+n,0);\n\t}\n\tif(dinic()<n-1){puts(\"-1\");return 0;}\n\tif(!get()){puts(\"-1\");return 0;}\n\tfor(int i=1;i<n;i++)\n\tprintf(\"%d %d\\n\",res[i].first,res[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 0x3f3f3f3f\n\nusing namespace std;\n\nstruct Edge {\n  int t,f,next;\n  Edge() {}\n  Edge(int a,int b,int c):t(a),f(b),next(c) {}\n};\n\nEdge e[1000000];\nint head[200005],vs,vt,tot=-1;\n\ninline void addEdge(int x,int y,int z) {\n  e[++tot]=Edge(y,z,head[x]);\n  head[x]=tot;\n  e[++tot]=Edge(x,0,head[y]);\n  head[y]=tot;\n}\n\nnamespace Flow {\n\t\nint d[200005],cur[200005];\nqueue <int> q;\n\nbool bfs() {\n  while (!q.empty()) q.pop();\n  memset(d,255,sizeof(d));\n  d[vs]=0;cur[vs]=head[vs];\n  q.push(vs);\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tfor(int i=head[x];i!=-1;i=e[i].next)\n  \t  if (e[i].f&&d[e[i].t]==-1) {\n  \t  \t  int u=e[i].t;\n  \t  \t  d[u]=d[x]+1;\n  \t  \t  cur[u]=head[u];\n  \t  \t  if (u==vt) return 1;\n  \t  \t  q.push(u);\n\t\t}\n  }\n  return 0;\n}\n\nint dfs(int x,int a) {\n  if (x==vt||!a) return a;\n  int ans=0;\n  for(int &i=cur[x];i!=-1;i=e[i].next)\n    if (e[i].f&&d[e[i].t]==d[x]+1) {\n    \tint u=e[i].t;\n    \tint f=dfs(u,min(a,e[i].f));\n    \tif (f) {\n    \t\te[i].f-=f;\n    \t\te[i^1].f+=f;\n    \t\tans+=f;\n    \t\ta-=f;\n    \t\tif (!a) break;\n\t\t}\n\t}\n  return ans;\n} \n\nint maxflow() {\n  int ans=0;\n  while (bfs())\n    ans+=dfs(vs,inf);\n  return ans;\n}\n\t\n}\n\nvector <int> bel[100005];\nbool vis1[100005],vis2[100005];\nint id[100005],nxt[100005];\n\nqueue <int> q;\n\nbool solve(int n) {\n  for(int i=1;i<n;i++)\n    for(int j=head[n+i];j!=-1;j=e[j].next)\n      if (e[j].t&&!e[j].f) {\n      \tint u=e[j].t;\n      \tid[i]=u;\n      \tvis1[u]=1;\n\t  }\n  for(int i=1;i<=n;i++)\n    if (!vis1[i]) q.push(i);\n  int cnt=0;\n  while (!q.empty()) {\n  \tint x=q.front();q.pop();\n  \tcnt++;\n  \tfor(int i=0;i<bel[x].size();i++)\n  \t  if (!vis2[bel[x][i]]) {\n  \t  \t  int u=bel[x][i];\n  \t  \t  vis2[u]=1;\n  \t  \t  nxt[u]=x;\n  \t  \t  q.push(id[u]);\n\t\t}\n  }\n  return cnt==n;\n}\n\nint main() {\n  memset(head,255,sizeof(head));\n  int n;\n  scanf(\"%d\",&n);\n  vs=0;vt=2*n;\n  for(int i=1;i<n;i++) {\n  \tint x;\n  \tscanf(\"%d\",&x);\n  \taddEdge(vs,n+i,1);\n  \tfor(int j=1;j<=x;j++) {\n  \t\tint y;\n  \t\tscanf(\"%d\",&y);\n  \t\taddEdge(n+i,y,1);\n  \t\tbel[y].push_back(i);\n\t  }\n  }\n  for(int i=1;i<=n;i++) addEdge(i,vt,1);\n  if (Flow::maxflow()<n-1) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  if (!solve(n)) {\n  \tputs(\"-1\");\n  \treturn 0;\n  }\n  for(int i=1;i<n;i++) printf(\"%d %d\\n\",id[i],nxt[i]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define range(i, m, n) for(int i = m; i < n; i++)\n#define husk(i, m, n) for(int i = m; i > n; i--)\n\nclass matching {\n  public:\n  vector< vector<int> > g;\n  vector<int> pa;\n  vector<int> pb;\n  vector<int> was;\n  int n, m;\n  int res;\n  int iter;\n\n  matching(int _n, int _m) : n(_n), m(_m) {\n    assert(0 <= n && 0 <= m);\n    pa = vector<int>(n, -1);\n    pb = vector<int>(m, -1);\n    was = vector<int>(n, 0);\n    g.resize(n);\n    res = 0;\n    iter = 0;\n  }\n\n  void add(int from, int to) {\n    assert(0 <= from && from < n && 0 <= to && to < m);\n    g[from].push_back(to);\n  }\n\n  bool dfs(int v) {\n    was[v] = iter;\n    for (int u : g[v]) {\n      if (pb[u] == -1) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    for (int u : g[v]) {\n      if (was[pb[u]] != iter && dfs(pb[u])) {\n        pa[v] = u;\n        pb[u] = v;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int solve() {\n    while (true) {\n      iter++;\n      int add = 0;\n      for (int i = 0; i < n; i++) {\n        if (pa[i] == -1 && dfs(i)) {\n          add++;\n        }\n      }\n      if (add == 0) {\n        break;\n      }\n      res += add;\n    }\n    return res;\n  }\n\n  int run_one(int v) {\n    if (pa[v] != -1) {\n      return 0;\n    }\n    iter++;\n    return (int) dfs(v);\n  }\n};\n\nint n;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  matching st(n - 1, n);\n  vector<vector<int>> e(n - 1);\n  range(i, 0, n - 1) {\n    int sz;\n    cin >> sz;\n    range(j, 0, sz) {\n      int a;\n      cin >> a;\n      a--;\n      e[i].push_back(a);\n      st.add(i, a);\n    }\n  }\n  if(st.solve() != n - 1) {\n    cout << -1;\n    return 0;\n  }\n  vector<int> pb = st.pb;\n  vector<int> pa = st.pa;\n  pa.resize(n);\n  range(i, 0, n) if(pb[i] == -1) {\n    pb[i] = n - 1;\n    pa[n - 1] = i;\n  }\n  vector<vector<int>> g(n);\n  range(i, 0, n - 1) {\n    for(int u : e[i]) {\n      g[pb[u]].push_back(i);\n    }\n  }\n  vector<int> was(n);\n  vector<int> par(n, -1);\n  function<void(int, int)> dfs = [&](int v, int p) {\n    was[v] = 1;\n    par[v] = p;\n    for(int u : g[v]) {\n      if(was[u]) continue;\n      dfs(u, v);\n    }\n  };\n  dfs(n - 1, -1);\n  if(count(was.begin(), was.end(), 0) > 1) {\n    cout << -1;\n    return 0;\n  }\n  range(i, 0, n - 1) {\n    cout << pa[i] + 1 << \" \" << pa[par[i]] + 1 << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,l,r) for(int i = (l),i##end = (r);i <= i##end;i++)\n#define Fordown(i,r,l) for(int i = (r),i##end = (l);i >= i##end;i--)\n#define debug(x) cout << #x << \" = \" << x << endl\n#define mp make_pair\n#define fir first\n#define sec second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\ntemplate <typename T> inline bool chkmin(T &x,T y) { return y < x ? x = y,1 : 0; }\ntemplate <typename T> inline bool chkmax(T &x,T y) { return x < y ? x = y,1 : 0; }\n\nconst int INF = 0x3f3f3f3f;\nconst int N = 1e5 + 10,E = 8e5 + 10;\n\nvector <int> Node[N],Pos[N];\nqueue <int> Q;\npii id[E],Ans[N];\nint to[E],nex[E],beg[N << 1],flow[E],pos[N],vis[N],dis[N << 1],cur[N << 1],gap[N << 1];\nint e = 1,S,T,n;\n\ninline int read() {\n\tint x = 0,flag = 1;\n\tchar ch = getchar();\n\twhile(!isdigit(ch) && ch != '-') ch = getchar();\n\tif(ch == '-') flag = -1,ch = getchar();\n\twhile(isdigit(ch)) x = (x << 3) + (x << 1) + (ch - '0'),ch = getchar();\n\treturn x * flag;\n}\n\ninline void Add(int x,int y,int z) {\n\tto[++e] = y,nex[e] = beg[x],beg[x] = e,flow[e] = z;\n\tif(x != S && y != T) id[e] = mp(x,y - n + 2);\n\tto[++e] = x,nex[e] = beg[y],beg[y] = e,flow[e] = 0;\n}\n\ninline bool bfs() {\n\tqueue <int> q;\n\tmemset(dis,0,sizeof(dis));\n\tq.push(T),gap[dis[T] = 0]++;\n\twhile(!q.empty()) {\n\t\tint x = q.front();q.pop();\n\t\tif(x == S) return true;\n\t\tfor(int i = beg[x];i;i = nex[i])\n\t\t\tif(!dis[to[i]] && flow[i ^ 1]) {\n\t\t\t\t++gap[dis[to[i]] = dis[x] + 1];\n\t\t\t\tq.push(to[i]);\n\t\t\t}\n\t}\n\treturn false;\n}\n\ninline int dfs(int x,int f) {\n\tif(x == T || !f) return f;\n\tint res = f;\n\tfor(int &i = cur[x];i;i = nex[i])\n\t\tif(flow[i] && dis[x] == dis[to[i]] + 1) {\n\t\t\tint val = dfs(to[i],min(res,flow[i]));\n\t\t\tflow[i] -= val,flow[i ^ 1] += val;\n\t\t\tres -= val;\n\t\t\tif(!res) return f;\n\t\t}\n\tif(!(--gap[dis[x]])) dis[S] = T;\n\t++gap[++dis[x]],cur[x] = beg[x];\n\treturn f - res;\n}\n\nint main() {\n\n\tn = read(),S = n * 2 - 1,T = n * 2;\n\tFor(i,1,n - 1) {\n\t\tint sz = read();\n\t\tAdd(S,i,1);\n\t\tFor(j,1,sz) {\n\t\t\tint val = read();\n\t\t\tNode[i].push_back(val);\n\t\t\tPos[val].push_back(i);\n\t\t\tif(val > 1) Add(i,val + n - 2,1);\n\t\t}\n\t}\n\tFor(i,2,n) Add(i + n - 2,T,1);\n\n\tint ans = 0,tot = 0;\n\tbfs(),memcpy(cur,beg,sizeof(cur));\n\twhile(dis[S] < T) ans += dfs(S,INF);\n\tif(ans < n - 1) return puts(\"-1\"),0;\n\n\tFor(i,1,e) if(!flow[i] && id[i].fir) pos[id[i].fir] = id[i].sec;\n\tQ.push(1);\n\twhile(!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\t\tFor(i,0,Pos[x].size() - 1) {\n\t\t\tint cur = Pos[x][i];\n\t\t\tif(!vis[pos[cur]]) vis[pos[cur]] = true,Ans[cur] = mp(x,pos[cur]),tot++,Q.push(pos[cur]);\n\t\t}\n\t}\n\tif(tot == n - 1) {\n\t\tFor(i,1,tot) printf(\"%d %d\\n\",Ans[i].fir,Ans[i].sec);\n\t} else puts(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100005, M = 200005, inf = 0x3f3f3f3f;\nint n, p[N], fa[N];\nvector<int> E[N], F[N];\n\nnamespace flow {\n\tconst int V = 2 * N, E = 2 * (M + 2 * N);\n\tint ans, S, T, tot = 1, nxt[E], fst[V], to[E], f[E], cur[V], d[V];\n\tvoid addedge(int u, int v, int w) {\n\t\tnxt[++tot] = fst[u]; fst[u] = tot; to[tot] = v; f[tot] = w;\n\t\tnxt[++tot] = fst[v]; fst[v] = tot; to[tot] = u; f[tot] = 0;\n\t}\n\tbool bfs() {\n\t\tstatic int q[E];\n\t\tint st = 0, ed = 0;\n\t\tq[ed++] = S;\n\t\tfor (int i = 1; i <= T; i++) d[i] = -1, cur[i] = fst[i];\n\t\td[S] = 0;\n\t\twhile (st < ed) {\n\t\t\tint u = q[st++];\n\t\t\tfor (int i = fst[u]; i; i = nxt[i])\n\t\t\t\tif (f[i] && d[to[i]] == -1) {\n\t\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\t\tif (to[i] == T) return true;\n\t\t\t\t\tq[ed++] = to[i];\n\t\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint aug(int u, int flow) {\n\t\tif (u == T || !flow) return flow;\n\t\tint used = 0;\n\t\tfor (int &i = cur[u], w; i; i = nxt[i])\n\t\t\tif (d[to[i]] == d[u] + 1 && (w = aug(to[i], min(f[i], flow - used)))) {\n\t\t\t\tf[i] -= w, f[i ^ 1] += w;\n\t\t\t\tif ((used += w) == flow) break;\n\t\t\t}\n\t\tif (!used) d[u] = -1;\n\t\treturn used;\n\t}\n\tint dinic() {\n\t\twhile (bfs()) ans += aug(S, inf);\n\t\treturn ans;\n\t}\n}\n\nvoid dfs(int u) {\n\tfor (int v : F[u])\n\t\tif (!fa[p[v]]) {\n\t\t\tfa[p[v]] = u;\n\t\t\tdfs(p[v]);\n\t\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tflow::S = 2 * (n - 1) + 1, flow::T = 2 * (n - 1) + 2;\n\tfor (int i = 1, k; i < n; ++i) {\n\t\tscanf(\"%d\", &k);\n\t\tE[i].resize(k);\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tscanf(\"%d\", &E[i][j]);\n\t\t\tif (E[i][j] != n)\n\t\t\t\tflow::addedge(E[i][j], n - 1 + i, 1);\n\t\t\tF[E[i][j]].push_back(i);\n\t\t}\n\t\tflow::addedge(flow::S, i, 1);\n\t\tflow::addedge(n - 1 + i, flow::T, 1);\n\t}\n\tint x = flow::dinic();\n\tif (x != n - 1) return !puts(\"-1\");\n\tfor (int i = 2; i <= flow::tot; i += 2)\n\t\tif (!flow::f[i] && flow::to[i] != flow::T && flow::to[i ^ 1] != flow::S)\n\t\t\tp[flow::to[i] - n + 1] = flow::to[i ^ 1];\n\tfa[n] = -1, dfs(n);\n\tfor (int i = 1; i < n; ++i)\n\t\tif (!fa[i]) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i)\n\t\tprintf(\"%d %d\\n\", fa[i], i);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n\nconst int N=5e5+5,M=3e6+5,INF=0x3f3f3f3f;\nint n;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint h[N],le=1;\nint hh[N];\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\nvoid add_bidir_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,v);}\n#define FORe(i,u,v,w)     for(int  i= h[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,u,v,w) for(int &i=hh[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint dep[N];\nqueue<int> q;\n\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    dep[s]=1, q.push(s);\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w) if(!dep[v]&&w)dep[v]=dep[u]+1, q.push(v);\n    }\n    return dep[t]!=0;\n}\nint dfs(int u,int flow){\n    if(u==t||!flow)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(rest,w));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int x;(x=dfs(s,INF));)maxflow+=x;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],Gap[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=cur[x]=k;\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[x]==dis[a[i]]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\tif(!--Gap[dis[x]])dis[S]=n;else ++Gap[++dis[x]],cur[x]=F[x];\n\treturn used;\n}\nint q[200010],h,t;bool vis[200010];\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(dis[S]<n)ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1000010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        if (a == 0)\n            d[e[i].v] = 0;\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], vis[100010], to[100010], ans[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue <int> q;\n    q.push(n);\n    vis[n] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (e[i].c == 0 && !::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i, x, y) for(int i = x, B = y; i <= B; i ++)\n#define ff(i, x, y) for(int i = x, B = y; i <  B; i ++)\n#define fd(i, x, y) for(int i = x, B = y; i >= B; i --)\n#define ll long long\n#define pp printf\n#define hh pp(\"\\n\")\nusing namespace std;\n\nconst int N = 1e5 + 5;\n\nint n;\nvector<int> e[N]; int e0[N];\n\nconst int M = 1e6 + 5;\nint fi[M], nt[M], to[M], r[M], tot = 1;\n\nvoid link(int x, int y, int z) {\n\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = 0, fi[y] = tot;\n}\n\nint d[M], co[M], cur[M], S, T;\nint q[M], q0;\n\nint bfs() {\n\tfo(i, 1, T) d[i] = 0, cur[i] = fi[i];\n\tq[q0 = 1] = S;\n\tfor(int i = 1; i <= q0; i ++) {\n\t\tint x = q[i];\n\t\tfor(int j = fi[x]; j; j = nt[j]) if(r[j])\n\t\t\tif(!d[to[j]]) d[to[j]] = d[x] + 1, q[++ q0] = to[j];\n\t} \n\treturn d[T] > 0;\n}\nint dg(int x, int flow) {\n\tif(x == T) return flow;\n\tint use = 0;\n\tfor(int i = cur[x]; i; i = nt[i], cur[x] = i)\n\t\tif(d[x] + 1 == d[to[i]] && r[i]) {\n\t\t\tint t = dg(to[i], min(flow - use, r[i]));\n\t\t\tr[i] -= t, r[i ^ 1] += t, use += t;\n\t\t\tif(use == flow) return use;\n\t\t}\n\treturn use;\n}\n\nint cho[N];\n\nint ans[N][2], cnt, bz[N];\n\nstruct edge {\n\tint fi[M], nt[M], to[M], r[M], tot;\n\tvoid link(int x, int y, int z) {\n\t\tnt[++ tot] = fi[x], to[tot] = y, r[tot] = z, fi[x] = tot;\n\t\tnt[++ tot] = fi[y], to[tot] = x, r[tot] = z, fi[y] = tot;\n\t}\n\tvoid dg(int x) {\n\t\tbz[x] = 1; cnt ++;\n\t\tfor(int i = fi[x]; i; i = nt[i])\n\t\t\tif(!bz[to[i]] && !ans[r[i]][0]) {\n\t\t\t\tans[r[i]][0] = x, ans[r[i]][1] = to[i];\n\t\t\t\tdg(to[i]);\n\t\t\t}\n\t}\n} g;\n\nint main() {\n\tscanf(\"%d\", &n);\n\tS = 2 * n + 1, T = S + 1;\n\tfo(i, 1, n - 1) {\n\t\tscanf(\"%d\", &e0[i]);\n\t\te[i].resize(e0[i]);\n\t\tff(j, 0, e0[i]) {\n\t\t\tscanf(\"%d\", &e[i][j]);\n\t\t\tif(e[i][j] != 1) link(e[i][j], i + n, 1);\n\t\t}\n\t}\n\tfo(i, 2, n) link(S, i, 1);\n\tfo(i, 1, n - 1) link(i + n, T, 1);\n\tint sum = 0;\n\tco[0] = T; while(bfs()) sum += dg(S, 1 << 30);\n\tif(sum != n - 1) {\n\t\tpp(\"-1\\n\"); return 0;\n\t}\n\tfor(int i = 2; i <= tot; i += 2)\n\t\tif(to[i] != S && to[i ^ 1] != S && to[i] != T && to[i ^ 1] != T && r[i] == 0)\n\t\t\tcho[to[i] - n] = to[i ^ 1];\n\tfo(i, 1, n - 1) {\n\t\tff(j, 0, e0[i]) if(e[i][j] != cho[i])\n\t\t\tg.link(cho[i], e[i][j], i);\n\t}\n\tg.dg(1);\n\tif(cnt == n) {\n\t\tfo(i, 1, n - 1) pp(\"%d %d\\n\", ans[i][0], ans[i][1]);\n\t} else pp(\"-1\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nclass Flow {\npublic:\n    static constexpr int INF = 1E9;\n    int n;\n    vector<pair<int, int>> e;\n    vector<vector<int>> g;\n    vector<int> cur, h;\n    bool bfs(int s, int t) {\n        h.assign(n, -1);\n        queue<int> que;\n        h[s] = 0;\n        que.push(s);\n        while (!que.empty()) {\n            int u = que.front();\n            que.pop();\n            for (int i : g[u]) {\n                int v, c;\n                tie(v, c) = e[i];\n                if (c > 0 && h[v] == -1) {\n                    h[v] = h[u] + 1;\n                    if (v == t)\n                        return true;\n                    que.push(v);\n                }\n            }\n        }\n        return false;\n    }\n    int dfs(int u, int t, int f) {\n        if (u == t)\n            return f;\n        int r = f;\n        for (int &i = cur[u]; i < g[u].size(); ++i) {\n            int j = g[u][i];\n            int v, c;\n            tie(v, c) = e[j];\n            if (c > 0 && h[v] == h[u] + 1) {\n                int a = dfs(v, t, min(r, c));\n                e[j].second -= a;\n                e[j ^ 1].second += a;\n                r -= a;\n                if (r == 0)\n                    return f;\n            }\n        }\n        return f - r;\n    }\n    Flow(int n) : n(n) {g.resize(n);}\n    void addEdge(int u, int v, int c) {\n        g[u].push_back(e.size());\n        e.emplace_back(v, c);\n        g[v].push_back(e.size());\n        e.emplace_back(u, 0);\n    }\n    int maxFlow(int s, int t) {\n        int ans = 0;\n        while (bfs(s, t)) {\n            cur.assign(n, 0);\n            ans += dfs(s, t, INF);\n        }\n        return ans;\n    }\n};\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    int n;\n    cin >> n;\n    vector<vector<int>> e(n - 1);\n    Flow f(2 * n);\n    int s = 0, t = 2 * n - 1;\n    for (int i = 0; i < n - 1; ++i) {\n        f.addEdge(s, i + 1, 1);\n        f.addEdge(i + n, t, 1);\n    }\n    for (int i = 0; i < n - 1; ++i) {\n        int c;\n        cin >> c;\n        e[i].resize(c);\n        for (int &j : e[i]) {\n            cin >> j;\n            --j;\n            if (j != 0)\n                f.addEdge(j, i + n, 1);\n        }\n    }\n    if (f.maxFlow(s, t) != n - 1) {\n        cout << -1 << \"\\n\";\n        return 0;\n    }\n    vector<int> match(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : f.g[i]) {\n            int v, c;\n            tie(v, c) = f.e[j];\n            if (v >= n && c == 0) {\n                match[i] = v - n;\n                break;\n            }\n        }\n    }\n    vector<int> u(n - 1), v(n - 1, -1);\n    vector<vector<int>> g(n);\n    for (int i = 1; i < n; ++i) {\n        for (int j : e[match[i]])\n            if (i != j)\n                g[j].push_back(i);\n        u[match[i]] = i;\n    }\n    function<void(int)> dfs = [&](int u) {\n        for (int _v : g[u]) {\n            if (v[match[_v]] == -1) {\n                v[match[_v]] = u;\n                dfs(_v);\n            }\n        }\n    };\n    dfs(0);\n    for (int i = 0; i < n - 1; ++i)\n        cout << u[i] + 1 << \" \" << v[i] + 1 << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(3)\n#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nbool bfs(){\n\tmemset(dep,-1,sizeof(dep));\n\tqueue<int>q;\n\tq.push(S);\n\tdep[S]=0;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]==-1){\n\t\t\tdep[to[i]]=dep[k1]+1;\n\t\t\tq.push(to[i]);\n\t\t}\n\t}\n\treturn dep[T]!=-1;\n}\nint dfs(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]==dep[k1]+1){\n\t\tint f=dfs(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tcur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\trd(n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\trd(m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\trd(k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tint res=0;\n\twhile(bfs()){\n\t\tmemcpy(cur,lnk,sizeof(cur));\n\t\tres+=dfs(S,INF);\n\t}\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing ld = long double;\nusing ii = pair<ll, ll>;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing vii = vector<ii>;\nusing vvii = vector<vii>;\nusing vd = vector<ld>;\n\ntemplate<class T>\nusing min_heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class TIn, class TOut = null_type>\nusing order_tree = tree<TIn, TOut, less<TIn>, rb_tree_tag,\n\ttree_order_statistics_node_update>;\n// .find_by_order(int r) and .order_of_key(TIn v)\n\nconstexpr int INF = 2000000010;\nconstexpr ll LLINF = 9000000000000000010LL;\nconstexpr ld PI = acos(-1);\n\nauto now(){ return chrono::high_resolution_clock::now(); }\nusing TP = decltype(now());\t// time point\nauto duration(TP t1, TP t2){\n\treturn chrono::duration_cast<chrono::microseconds>(t2-t1).count();\n}\n\n\n// Need a much better hash function for gp_hash_table\nstruct custom_hash {\n\tstatic uint64_t splitmix64(uint64_t x) {\n        x += 0x9e3779b97f4a7c15;\n        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;\n        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;\n        return x ^ (x >> 31); }\n\tsize_t operator()(uint64_t x) const {\n        static const uint64_t FIXED_RANDOM\n\t\t\t= chrono::steady_clock::now().time_since_epoch().count();\n        return splitmix64(x + FIXED_RANDOM); } };\n\ntemplate<class TOut>\n//using table = gp_hash_table<TIn, TOut>;\nusing table = gp_hash_table<uint64_t, TOut, custom_hash>;\n\nstruct UnionFind {\n\tvi par, rank, size; int c;\n\tUnionFind(int n) : par(n), rank(n,0), size(n,1), c(n) {\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint find(int i) { return (par[i] == i ? i : (par[i] = find(par[i]))); }\n\tbool same(int i, int j) { return find(i) == find(j); }\n\tint get_size(int i) { return size[find(i)]; }\n\tint count() { return c; }\n\tint merge(int i, int j) {\n\t\tif ((i = find(i)) == (j = find(j))) return -1; else --c;\n\t\tif (rank[i] > rank[j]) swap(i, j);\n\t\tpar[i] = j; size[j] += size[i];\n\t\tif (rank[i] == rank[j]) rank[j]++;\n\t\treturn j;\n\t}\n};\n\nvoid solve() {\n\tauto start = now();\n\tint N;\n\tcin >> N;\n\tvvi E(N-1);\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tint c;\n\t\tcin >> c;\n\t\tE[i].resize(c);\n\t\tfor (ll &id : E[i]) cin >> id, --id;\n\t}\n\tvi inds(N-1);\n\tiota(inds.begin(), inds.end(), 0);\n\tshuffle(inds.begin(), inds.end(), mt19937(0x94949));\n\tsort(inds.begin(), inds.end(), [&E](int l, int r) { return E[l].size() < E[r].size(); });\n\n\twhile (duration(start, now()) < 1800000) {\n\t\tbool ok = true;\n\t\tvii edges(N-1);\n\t\tUnionFind uf(N);\n\t\tfor (size_t l = 0, r = 0; ok && l < inds.size(); l = r) {\n\t\t\twhile (r < inds.size() && E[inds[l]].size() == E[inds[r]].size()) ++r;\n\t//\t\tshuffle(inds.begin()+l, inds.begin()+r, mt19937(0x94949));\n\n\t\t\tfor (size_t i = l; i < r; ++i) {\n\t\t\t\tint x = inds[i];\n\t\t\t\ttable<null_type> sn;\n//\t\t\t\tunordered_set<int> sn;\n\t\t\t\tvi vec;\n//\t\t\t\tcerr << \"Trying E[\" << x << \"] = {\";\n\t\t\t\tfor (int v : E[x]) {\n\t\t\t\t\tint id = uf.find(v);\n//\t\t\t\t\tcerr << \"(\"<<v<<\", \"<<id<<\") \";\n\t\t\t\t\tif (sn.find(id) != sn.end()) continue;\n\t\t\t\t\tsn.insert(id);\n\t\t\t\t\tvec.push_back(v);\n\t\t\t\t}\n//\t\t\t\tcerr << \"}\" << endl;\n\t\t\t\tif (sn.size() == 1) {\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n//\t\t\t\tcerr << \"Final vec:\"; for (int k : vec) cerr << ' ' << k; cerr << endl;\n\t\t\t\tint a = rand() % vec.size(), b;\n\t\t\t\tdo { b = rand() % vec.size(); } while (a == b);\n\t\t\t\ta = vec[a], b = vec[b];\n\t\t\t\tif (a > b) swap(a, b);\n\t\t\t\tuf.merge(a, b);\n\t\t\t\tedges[x] = {a, b};\n\t\t\t}\n\t\t}\n\t\tif (!ok) continue;\n\t\tfor (int i = 0; i < N-1; ++i)\n\t\t\tcout << 1+edges[i].first << ' ' << 1+edges[i].second << '\\n';\n\t\treturn;\n\t}\n\n\tcout << -1 << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(NULL);\n\tcout << fixed << setprecision(12);\n\t\n\tsolve();\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e5 + 5;\nint n;\nvector<int> g[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    vector<int> vs(k);\n    for (int j = 0; j < k; j++) {\n      scanf(\"%d\", &vs[j]);\n      vs[j]--;\n    }\n    g[i] = vs;\n  }\n  return true;\n}\n\nint p[maxn];\nint q[maxn];\nint used[maxn];\n\nbool dfs(int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (p[u] == -1) {\n      p[u] = v;\n      q[v] = u;\n      return true;\n    }\n  }\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (!used[p[u]] && dfs(p[u])) {\n      p[u] = v;\n      q[v] = u;\n      return true;\n    }\n  }\n  return false;\n}\n\nint match() {\n  for (int i = 0; i < n; i++) {\n    p[i] = -1;\n    q[i] = -1;\n  }\n  int res = 0;\n  while (true) {\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n      used[i] = false;\n    }\n    for (int i = 0; i < n - 1; i++) {\n      if (q[i] == -1 && dfs(i)) {\n        found = true;\n        res++;\n      }\n    }\n    if (!found) {\n      break;\n    }\n  }\n  return res;\n}\n\nvector<int> ng[maxn];\nvector<int> vs;\npair<int, int> ans[maxn];\n\nvoid dfs1(int v) {\n  used[v] = true;\n  for (int i = 0; i < sz(g[v]); i++) {\n    int u = g[v][i];\n    if (used[u]) {\n      continue;\n    }\n    int id = p[u];\n    ans[id] = make_pair(v, u);\n    dfs1(u);\n  }\n}\n\nvoid solve() {\n  if (match() < n - 1) {\n    printf(\"-1\\n\");\n    return;\n  }\n  for (int i = 0; i < n; i++) {\n    ng[i].clear();\n  }\n  for (int i = 0; i < n - 1; i++) {\n    int v = q[i];\n    for (int j = 0; j < sz(g[i]); j++) {\n      int u = g[i][j];\n      if (u != v) {\n        ng[u].push_back(v);\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    g[i] = ng[i];\n    used[i] = false;\n  }\n  int root = -1;\n  for (int i = 0; i < n; i++) {\n    if (p[i] == -1) {\n      root = i;\n      break;\n    }\n  }\n  dfs1(root);\n  for (int i = 0; i < n; i++) {\n    if (!used[i]) {\n      printf(\"-1\\n\");\n      return;\n    }\n  }\n  for (int i = 0; i < n - 1; i++) {\n    printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[(N<<1)+3];\nvector<pair<int,pii> > ans;\nint mch[(N<<1)+3];\nbool vis[(N<<1)+3];\nint que[N+3];\nint n;\n\nbool bfs()\n{\n\tint hd = 1,tl = 1; que[1] = 1; vis[1] = true;\n\twhile(hd<=tl)\n\t{\n\t\tint u = que[hd]; hd++;\n\t\tfor(int o=0; o<adj[u].size(); o++)\n\t\t{\n\t\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\t\tif(vis[mch[v]]) continue;\n\t\t\tque[++tl] = mch[v]; vis[v] = vis[mch[v]] = true;\n\t\t\tans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\t}\n\t}\n\tif(tl<n) {return false;}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tif(!bfs()) {puts(\"-1\"); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<vector>\n#define N 100005\nusing namespace std;\nint n,head[2*N],cnt=1,s,t,ma[N];\nint d[2*N],maxflow,rt,num,ans[N];\nconst int inf=0x3f3f3f3f;\nvector<int>v[N];\nbool vis[N];\nstruct edge\n{\n\tint to,nxt,siz;\n}w[8*N];\nvoid add(int x,int y,int siz)\n{\n\tw[++cnt]=(edge){y,head[x],siz};\n\thead[x]=cnt;\n\tw[++cnt]=(edge){x,head[y],0};\n\thead[y]=cnt;\n}\nbool bfs()\n{\n\tqueue<int>q;\n\tmemset(d,0,sizeof(d));\n\tq.push(s);\n\td[s]=1;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t{\n\t\t\tint y=w[i].to;\n\t\t\tif(d[y]||!w[i].siz)continue;\n\t\t\td[y]=d[x]+1;\n\t\t\tif(y==t)return 1;\n\t\t\tq.push(y);\n\t\t}\n\t}\n\treturn 0;\n}\nint Dinic(int x,int flow)\n{\n\tif(x==t)return flow;\n\tint rest=flow;\n\tfor(int i=head[x];i&&rest;i=w[i].nxt)\n\t{\n\t\tint y=w[i].to;\n\t\tif(d[y]!=d[x]+1||!w[i].siz)continue;\n\t\tint k=Dinic(y,min(w[i].siz,rest));\n\t\tif(!k)d[y]=0;\n\t\tw[i].siz-=k;\n\t\tw[i^1].siz+=k;\n\t\trest-=k;\n\t}\n\treturn flow-rest;\n}\nvoid dfs(int x)\n{\n\tnum++;\n\tfor(int i=0;i<(int)v[x].size();i++)\n\t{\n\t\tif(vis[v[x][i]])continue;\n\t\tvis[v[x][i]]=1,ans[v[x][i]]=x;\n\t\tdfs(ma[v[x][i]]);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n+1,t=s+1;\n\tfor(int i=1;i<=n;i++)add(s,i,1);\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tadd(n+i,t,1);\n\t\tfor(int j=1,x;j<=k;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tv[x].push_back(i);\n\t\t\tadd(x,n+i,1);\n\t\t}\n\t}\n\twhile(bfs())maxflow+=Dinic(s,inf);\n\tif(maxflow!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int x=1;x<=n;x++)\n\t{\n\t\tbool flag=0;\n\t\tfor(int i=head[x];i;i=w[i].nxt)\n\t\t\tif(!w[i].siz&&n+1<=w[i].to&&w[i].to<=n+n-1)\n\t\t\t\tma[w[i].to-n]=x,flag=1;\n\t\tif(!flag)rt=x;\n\t}\n\tdfs(rt);\n\tif(num!=n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d %d\\n\",ans[i],ma[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n\nvector<int>ans[200005];\nint beg = -1;\nbool in[400005];\n\n//O(E sqrt V)\n\nstruct HopcroftKarp {\n  vector< vector< int > > graph, rev;\n  vector< int > dist, match, revmatch;\n  vector< bool > used, vv;\n\n  HopcroftKarp(int n, int m) : graph(n), rev(m), match(m, -1), revmatch(n,-1), used(n) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    rev[v].push_back(u);\n  }\n\n  void bfs() {\n    dist.assign(graph.size(), -1);\n    queue< int > que;\n    for(int i = 0; i < graph.size(); i++) {\n      if(!used[i]) {\n        que.emplace(i);\n        dist[i] = 0;\n      }\n    }\n\n    while(!que.empty()) {\n      int a = que.front();\n      que.pop();\n      for(auto &b : graph[a]) {\n        int c = match[b];\n        if(c >= 0 && dist[c] == -1) {\n          dist[c] = dist[a] + 1;\n          que.emplace(c);\n        }\n      }\n    }\n  }\n\n  bool dfs(int a) {\n    vv[a] = true;\n    for(auto &b : graph[a]) {\n      int c = match[b];\n      if(c < 0 || (!vv[c] && dist[c] == dist[a] + 1 && dfs(c))) {\n        match[b] = a;\n        revmatch[a] = b;\n        used[a] = true;\n        return (true);\n      }\n    }\n    return (false);\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    while(true) {\n      bfs();\n      vv.assign(graph.size(), false);\n      int flow = 0;\n      for(int i = 0; i < graph.size(); i++) {\n        if(!used[i] && dfs(i)) ++flow;\n      }\n      if(flow == 0) return (ret);\n      ret += flow;\n    }\n  }\n\n  void output() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        cout << match[i] << \"-\" << i << endl;\n      }\n    }\n  }\n  \n  void put_ans() {\n    for(int i = 0; i < match.size(); i++) {\n      if(~match[i]) {\n        ans[match[i]].pb(i);\n      }\n      else{\n      \tbeg = i;\n      }\n    }\n  }\n  \n  void DFS(int cur,bool right){\n      //cout << cur << \" \" << right << endl;\n  \tif(right){\n  \t\t\n  \t\tfor(int i=0;i<rev[cur].size();i++){\n  \t\t\tif(match[cur] == rev[cur][i]) continue;\n  \t\t\tint to = rev[cur][i];\n  \t\t\t//cout << to << endl;\n  \t\t\tif(in[to]) continue;\n  \t\t\tin[to] = 1;\n  \t\t\tans[to].pb(cur);\n  \t\t\t//cout << to << \" \" << cur << endl;\n  \t\t\t//cout << to << endl;\n  \t\t\tDFS(to,false);\n  \t\t}\n  \t}\n  \telse{\n  \t\t\n\t\tfor(int i=0;i<graph[cur].size();i++){\n  \t\t\tif(match[graph[cur][i]] != cur) continue;\n  \t\t\tint to = graph[cur][i];\n  \t\t\tif(in[to+200001]) continue;\n  \t\t\tin[to+200001] = 1;\n  \t\t\tDFS(to,true);\n  \t\t}\n  \t}\n  }\n};\n\nint n;\nvector<int>vec[200005];\n\nint par[200005],ran[200005];\nvoid init(){ for(int i=0;i<200005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\n\n\nint main(){\n\tscanf(\"%d\",&n);\n\tHopcroftKarp bm(n-1,n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a; scanf(\"%d\",&a);\n\t\trep(j,a){\n\t\t\tint x; scanf(\"%d\",&x); x--;\n\t\t\tvec[i].pb(x);\n\t\t\tbm.add_edge(i,x);\n\t\t}\n\t}\n\tint v = bm.bipartite_matching(); \n\tbm.put_ans();\n\tif(beg != -1) bm.DFS(beg,true);\n\tinit();\n\tfor(int i=0;i<n-1;i++){\n\t\tif(ans[i].size() != 2){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tint x = ans[i][0], y = ans[i][1];\n\t\tif(same(x,y)){\n\t\t\tputs(\"-1\"); return 0;\n\t\t}\n\t\tunite(x,y);\n\t}\n//\tputs(\"YES\");\n\trep(i,n-1) cout << ans[i][0]+1 << \" \" << ans[i][1]+1 << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 100007;\n\nvoid failure(){cout<<-1<<lf;exit(0);}\n\nvector<int> e[_];\nint n,ed[_]={0},via[_]={0};\n\nint dfs(int x,int who)\n{\n\tif(ed[x]==who)return 0;\n\ted[x]=who;\n\tfor(auto b:e[x])if(!via[b] || dfs(via[b],who)){via[b]=x;return 1;}\n\treturn 0;\n}\n\nint es[_]={0};\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<n;i++)for(int j=ty();j>=1;j--)e[ty()].emplace_back(i);\n\tfor(int i=2;i<=n;i++)if(!dfs(i,i))failure();\n\n\tqueue<int> q;\n\tq.emplace(1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(q.empty())failure();\n\t\tint a=q.front();q.pop();\n\t\tfor(auto b:e[a])if(!es[b])es[b]=a,q.emplace(via[b]);\n\t}\n\tfor(int i=1;i<n;i++)cout<<es[i]<<' '<<via[i]<<lf;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i])dis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=F[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 300010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nnamespace MF { //init before you use it. when you use double, be careful.\n\tstruct edge { int to, cap, rev; };\n\n\tvector<edge> G[MAX_N];\n\tint level[MAX_N];\n\tint iter[MAX_N];\n\n\tvoid init(int n) {\n\t\trep(i, 0, n) G[i].clear();\n\t}\n\n\tvoid add_edge(int from, int to, int cap) {\n\t\tG[from].push_back((edge){to, cap, (int)G[to].size()});\n\t\tG[to].push_back((edge){from, 0, (int)G[from].size() - 1});\n\t}\n\n\tvoid bfs(int s) {\n\t\tmemset(level, -1, sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor(int i = 0; i < (int)G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && level[e.to] == -1) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v, int t, int f) {\n\t\tif(v == t) return f;\n\t\tfor(int &i = iter[v]; i < (int)G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif(e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif(d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\tll get(int s, int t) {\n\t\tll flow = 0;\n\t\twhile(true) {\n\t\t\tbfs(s);\n\t\t\tif(level[t] == -1) return flow;\n\t\t\tmemset(iter, 0, sizeof(iter));\n\t\t\tint f;\n\t\t\twhile((f = dfs(s, t, inf)) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint N;\nint used[MAX_N];\n\nvoid loop(int v, int p) {\n\t// debug(v, p);\n\tif(v < N - 1) used[v] = p - (N - 1);\n\telse used[v] = 0;\n\trep(i, 0, sz(MF::G[v])) {\n\t\tauto& e = MF::G[v][i];\n\t\tif(e.cap == 0 && used[e.to] == -1 && e.to < 2 * N - 1) loop(e.to, v);\n\t}\n}\n\nvoid solve() {\n\tcin >> N;\n\tint S = 2 * N - 1, T = 2 * N;\n\tMF::init(2 * N + 1);\n\trep(i, 0, N - 1) {\n\t\tint a; cin >> a;\n\t\twhile(a--) {\n\t\t\tint b; cin >> b; b--;\n\t\t\tMF::add_edge(i, b + N - 1, 1);\n\t\t}\n\t}\n\trep(i, 0, N - 1) MF::add_edge(S, i, 1);\n\trep(i, 0, N) MF::add_edge(i + N - 1, T, 1);\n\tif(MF::get(S, T) != N - 1) {\n\t\tcout << -1 << \"\\n\"; return;\n\t}\n\trep(i, 0, N - 1) {\n\t\trep(j, 0, sz(MF::G[i])) {\n\t\t\tauto& e = MF::G[i][j];\n\t\t\tif(e.cap == 0) {\n\t\t\t\tused[e.to] = 1;\n\t\t\t\t// debug(i, e.to);\n\t\t\t}\n\t\t}\n\t}\n\tint root = -1;\n\trep(i, 0, N) {\n\t\tif(!used[i + N - 1]) {\n\t\t\troot = i + N - 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmemset(used, -1, sizeof(used));\n\tloop(root, -1);\n\trep(i, 0, N - 1) {\n\t\tif(used[i] == -1) {\n\t\t\tcout << -1 << \"\\n\"; return;\n\t\t}\n\t}\n\trep(i, 0, N - 1) {\n\t\trep(j, 0, sz(MF::G[i])) {\n\t\t\tauto& e = MF::G[i][j];\n\t\t\tif(e.cap == 0) {\n\t\t\t\tcout << e.to - (N - 1) + 1 << \" \" << used[i] + 1 << \"\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                                                                                                `\n                                                                         `!!!;'                                                                 `\n                                                           '%$@########################&&%:.                                                    `\n                                                       .%###################################%.                                                  `\n                                                    .`|######################################%                                                  `\n                                                 .!@###############################################$'                                           `\n                                              .!@#########################@@@#########################&;.                                       `\n                                             :@##################@@@&&@@@$!!%&@@@@@@@###################&'                                      `\n                                          :&################@@@&$%%||||!!:'':;!!||%|!%&@@#################%`                                    `\n                                         |###############@@&&$%|!;;::::':'''':::;;!!|%%%$&&@###############$`                                   `\n                                      :&#############@&$%||||!;'````````````'''```'':::'':!|$@@###############;                                 `\n                                    :@#############@$$%|!;;;;:'``````...```...`...`'':::''';|%$$$&############&'                                `\n                                   |##############&$$$%||!!;:'`````..````....`...```''::::;!!||$&&@@###########&'                               `\n                                 !##############@$%|!!!;::'''`````...``.....`````````'''::::;;::!|%$&############|                              `\n                                :@##########@&%!:'`::;;:'``....```.......  .``....````````````'':;!|%$@############;                            `\n                               ;##########@%;```...`'''`...  .....    ................   .`.    `:!!!!%%%&#########|                            `\n                              ;##########&|:.`'`. ..`...   .......   .....  ..  .....   ...   .'':!!:.`''!@#########|.                          `\n                              !##########|'`.;!`       .  ......          ..    .      ....  .::'`. .. .`'|@########@:                          `\n                              ;##########%'`'%!    ..       .  .                ..    .```.   ';:`..``.`':|@########@:                          `\n                              !##########$:;$&;                     . `|%;.  `;||;::`.``';;.  .;!: `;:`';|$#########@!.                         `\n                              !##########@$&@|. ...... .`':!|;` !$|%%'!##$' `|####$:`:;:!&$:. '$&!';!!||%&############;                         `\n                             `$#############&:  `!!'`:;;;||%@&!'!&&$;.|##%`.|#####%`'$@$&##%` .:||;;;;%@##############!                         `\n                             :@#############|. .!&@|;%@@@@@&@@#@&@#@&@############@@#####@:   .`'%@%!!&###############!                         `\n                             :@############@;   :&@!;$###@|%|!$@@######################@%`    .;|!;!|%@###############!                         `\n                             :@############@:   `$#$%#@@##&@################@$$$&$%|!'       `%#@|;':|&###############!                         `\n                              !##########@$%:    |####@&######$;.                          ..`'`      ;@##############!                         `\n                              !##########!       ;#########|.                             `;`         ;###############!                         `\n                              ;##########;       `%######;                           '$###&:          `%@############&'                         `\n                               !########@:       .'.       .:;`                   .|%:                   !##########&'                          `\n                               !########@:                                                               ;#########@:                           `\n                                !######%.     !##&;.        .                  `%&!`             '&###&' !#########!                            `\n                                |#######;.%###!                 `!&###@|;;%@###%.    ';;|&$:;;`     |#%. .%###%$###!                            `\n                               !#######|  `%#&'    |##&$####&:     !##########;    `%#####%.!#|.   .%@:   ;###;`%##!                            `\n                                !#$!$##!   :@#!        .|###$'.    ;##|.  :&#@;    .``::`          ;@|.   :@#@: `$#|                            `\n                                :&&|&##;   :&#!                   :&##;    .%##!                   !&'    ;@##!  |#!                            `\n                                 |@@##@;  .`%#!                  '$##;      ;##$`                 :@!    .|##@; :&!                             `\n                                 !&|&##%:'.  :&!                :@#%.        .%##;               |&!.   `|@!   `$!                              `\n                                 '$%%###&;.   '&&'            `%##&'           |##@&:    ...;&&&@;     .;&#|':;$&:                              `\n                                 .|######&;        '$@@@@@@@@#|                                        :&######%`                               `\n                                   !#####&:                                                           '$#####@:                                 `\n                                   '$#####@:                                                          ;#####$`                                  `\n                                     '&####%.                 ``                                     '$#####;                                   `\n                                      !#####$'                |@:  .:%|;;;;!$#####@#|               '&###$:                                     `\n                                       :&####&:               ;####################@:    ':`       `%###@:                                      `\n                                         ;#####@%:.                                         `'';|@######$`                                      `\n                                         `$######@|`                                        !#&||@#####$`                                       `\n                                          :&######@%'.                        .`''''` .';!|%@#@$$@####&:                                        `\n                                           |######@|'.   ;##$!!%@##########################@:   '$####;                                         `\n                                           :&#####$;''.`%#########&'             `|@$:         .%###@;                                          `\n                                            :@####@;          |#@##&$;         `|%'           .|####!                                           `\n                                              !####@;                                .        |####!                                            `\n                                               :@###@|`         .                 `|!.       |####%.                                            `\n                                                .|####!          `;$@%|!!!!!%&&@#$;.        !#####|                                             `\n                                                .%####&:              '%&@@@|`             '&#####|                                             `\n                                                .%#####|.                                 :&######%`                                            `\n                                       :|||;`    !#######;                              .%#####@@#####@$;.                                      `\n                                   `$#############&%!%#####|.                         :@####%:..'!&######@;                                     `\n                                  `$#############|`..'%#######!                      ;####&;.    .'%#######!                                    `\n                                .|##############@!`    .'%#########%'.          '%#####%`           :@#######@%;:.                              `\n                          ;%|;. !############%::;'        `!&############@&&@#######@%'               !###########&'                            `\n                         !################$'   .:'         '|&######################$:.               :@#############@@@@@@;                    `\n                      ';$##&;:&###########$`                  :|$@################%:.                 !#####################@;                  `\n                   '%####@$!:.  `%#########!                    .:!%&@#######@%!;'.                   |##############%!$@####!                  `\n                .|#######&;'. .    |#######%.                      .':;!!!!!!;`...                   .|############|. :$@@####%.                `\n                !####&$&@#@!:'.       ;#####%`                  .`';;'... ..''``.                    !##########%`    ''':$######$`             `\n                ;#####@$$;`%&:.         `%####;                   .:;;:'':;||!:`                    !#########!          :&#@@####!             `\n          '%######@######!   !!            :$@$`                    ...`.'::`..                   '$######@!`         '|$$&!!@#######@!.        `\n     '$#########@&$$@######@:    ;: . `'    ....                      ...``.                    `$######&'           '!;`'!@######&&########$'  `\n  ;############@#@@@@@$|%@###$`  `!!.;' .     :!.                                             .%#####!.            .;::&####|`..`  ..;@########!'\n  |########&|;'``..`:'    ..!##%:.    ;;      `.                                            .|###|`             `'|###@&$|`  ..   .`|&&@#######%:\n  |###@#@@#&|:`.`';;:;!!!;:;''!$##&;'.  .'%; .;&###&|$!                                     '$; .|$:;|`   ...;&###$'    ....      :||%&########%:\n  |#######@$;!%%:```           .!@###&|`   :|'!########@#!                                ;@! :@####%'. `|@###&:         ..`:::%$$&$$$&@##@@@##|:\n  |########$;::'`         .`.     `%#####%!: .. !#####%` !#%.                        !; '%; !#############&:          `::`.```. .':.  :$@&&&###|:\n  !####@%:::;;:::::` .........            '.  !#######%;;';; `%#&'             ;&: `;``$@!%########&&##&|::::'.             ':.     `!%@@######|:\n  !#####%;;::.       ...... ....`..  ..  '::!|&########$';%`.'` .;%:        !#$';$%|&$!&##########$'        `';;;;!&##&%||||||%;`   .:|&###@###|:\n  |#######|`...      `|$&&$$!`....           ;$:  :&#@:     `'''``.   .%########&'  .%#@&$%$#####$`     ....`:%&@@@@@@&&@@!`.      .`'%@#######|'\n  |######@@$:       .`..`!@&$&&&&:                ;@#######@@#$%@######&$;    '%@##%!@###@&&@####%.     `!&@@@@@$:..`..``.``...     `|&####@@##!'\n  ;###&|;::!&#&%%%%:         .'::::;|$&&$%|'..;%%&#######%;$########@&#####%`   '|@###;    '%####$;::::::`            '!|%%%%%%%%%&#$:'::.'%###|'\n  `%###@|;|%$%$@#&|;::::`          '|%%%%%$%|%|;';$##@|'.   |######&'     .:|$%: :&@|'.     !####%.              `::;:!$@######&%%%%%!'  ':;&##|:\n  '$##%:.    :&##@####@$;.  ..                    `$|     :; !#####|      '|%:  ``    ...   !####!          .  ..:&#@@@@##@&||$;         :&####|'\n  !####&@@&;        ...`.'%@##@@#@@&!`            :&&!.       !###&'  :||:.`   !%'     ``:$######@@@&&@@@&@##$;``....             |@@@@########!'\n  !#######@$||!:          ';!;;;!&###&|||||||||||%&##@!`.     !###&||%!!!:   .:;`        `;;%####$;:;;;;;;;;;;;::.         '||||||&#####%!;;$##!`\n  `%#&:.`:!||||||%@#@%;::;;;'                     ;@@:    .. .%###|.   `:::'  .:!;'`':'`   `$####!             ':;;;;!%@@&%%%|;`        `;%&###|:\n  .%##|..       '$##@@@@@@#&:...`..              `$#$'        !##%`   ..`.`:%@@! '%@$:''. .`|####|... .........`:%###@#@@@|`        ....`%#####|:\n  !###@&!       .`.```':!&##@&&&&$:              '&#%.        !#&'     ````.    .```:%&&&&&@#####@!':|$&&$&&&&&&&&&@##|`````.       !@@@#######!'\n  :&#########@$||||:            `::::;;;;;!!;;;:;$###$'  .'`  |#@|.  .:;;:.                `%####%:''':::::`               `!||&##$;;;:::.  ;##|:\n  .%#@$%$%%%%%$@###$::::::'.           ...`;|!::!&##@$%|||!' .%##&%%$%'        `'.         :&####!                  .':::'::%@&$%%!` .!!':;$###%:\n  :&#############@|.              .  '$##################&;..!@###@#######%'.             .!#####!          .              `$#####@|``;&|!&####|:\n  |####&%'   .''''':|@###@$$$$$$%;.             |####%`      .|#@;.         .;$$$%$&$$$$$$&######$:..:|%$$$$$$$&&&&@######&;'''.    ;$&########|:\n  |#######@%;;`    '!|!||$#######&|!!!;;;!!!;`.!#####@: .;|!!|&#$'   `:'':;;$######################################%!|!!!!!;.  .`;|&######@####%:\n  |############$!''''..';$&&&&@########################$;'!;`:@#&:``'|$@######@@@@&&&&&&&@#######@&&&&&&&&&&&@@&&&&$|:.    .`''$########@&@####%:\n  |###&%$&#################@%;'  ..      `|@############$: `%@###########$`  `%%:.     . :@######|         !#####################@$%&##########%:\n  |#######################################@&&@######################@@&@#######################################################################%:\n*/\n\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <map>\n#include <set>\n#include <stack>\n#include <ctime>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <bitset>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ninline char gc() {\n    static const int L = 233333;\n    static char sxd[L], *sss = sxd, *ttt = sxd;\n    if (sss == ttt) {\n        ttt = (sss = sxd) + fread(sxd, 1, L, stdin);\n        if (sss == ttt) {\n            return EOF;\n        }\n    }\n    return *sss++;\n}\n\n#ifndef _AT_HOME\n#define dd c = gc()\n#else\n#define dd c = getchar()\n#endif\ninline char readalpha() {\n    char dd;\n    for (; !isalpha(c); dd);\n    return c;\n}\n\ninline char readchar() {\n    char dd;\n    for (; c == ' '; dd);\n    return c;\n}\n\ntemplate <class T>\ninline bool read(T& x) {\n    bool flg = false;\n    char dd;\n    x = 0;\n    for (; !isdigit(c); dd) {\n        if (c == '-') {\n            flg = true;\n        } else if(c == EOF) {\n            return false;\n        }\n    }\n    for (; isdigit(c); dd) {\n        x = (x * 10) + (c ^ 48);\n    }\n    if (flg) {\n        x = -x;\n    }\n    return true;\n}\n#undef dd\n\ntemplate <class T>\ninline void write(T x) {\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    if (x < 10) {\n        putchar(x | 48);\n        return;\n    }\n    write(x / 10);\n    putchar((x % 10) | 48);\n}\n\ntemplate <class T>\ninline void writesp(T x) {\n    write(x);\n    putchar(' ');\n}\n\ntemplate <class T>\ninline void writeln(T x) {\n    write(x);\n    puts(\"\");\n}\n\n#define lowbit(x) (x & -x)\n\nnamespace dfcmd {\n    const int maxn = 200005;\n    const int inf = 0x3f3f3f3f;\n\n    struct Edge {\n        int to, nxt, flow;\n    } e[maxn];\n\n    int first[maxn];\n    int first_bak[maxn];\n\n    inline void add_edge(int from, int to) {\n        // cout << \"edge    \" << from << ' ' << to << endl;\n        static int cnt = -1;\n        e[++cnt].nxt = first[from];\n        first[from] = cnt;\n        e[cnt].to = to;\n        e[cnt].flow = 1;\n        // cout << \"edggg \" << cnt << ' ' << from << ' ' << first[from] << ' ' << e[cnt].flow << endl;\n        e[++cnt].nxt = first[to];\n        first[to] = cnt;\n        e[cnt].to = from;\n        e[cnt].flow = 0;\n    }\n\n    int n, nn, S, T;\n    vector<int> dian[maxn];\n    vector<int> too[maxn];\n\n    int dep[maxn];\n\n    inline bool bfs() {\n        for (int i = 1; i <= n << 1; ++i) {\n            first[i] = first_bak[i];\n        }\n        queue<int> q;\n        memset(dep, 0, sizeof(dep));\n        dep[S] = 1;\n        q.push(S);\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << ' ' << first[now] << endl;\n            q.pop();\n            for (int i = first[now]; ~i; i = e[i].nxt) {\n                int to = e[i].to;\n                // cout << i << ' ' << e[i].to << ' ' << e[i].flow << endl;\n                if (!dep[to] && e[i].flow) {\n                    dep[to] = dep[now] + 1;\n                    q.push(to);\n                }\n            }\n        }\n        return dep[T];\n    }\n\n    inline int dfs(int now, int all) {\n        if (now == T) {\n            return all;\n        }\n        int flow = 0;\n        for (int i = first[now]; ~i; i = e[i].nxt) {\n            first[now] = i;\n            int to = e[i].to, f;\n            if (e[i].flow && dep[to] == dep[now] + 1 && (f = dfs(to, min(e[i].flow, all)))) {\n                all -= f;\n                flow += f;\n                e[i].flow -= f;\n                e[i ^ 1].flow += f;\n            }\n        }\n        return flow;\n    }\n\n    inline int Dinic() {\n        int ans = 0;\n        while (bfs()) {\n            ans += dfs(S, inf);\n        }\n        return ans;\n    }\n\n    int pp[maxn];\n    bool viss[maxn];\n    pair<int, int> ee[maxn];\n\n    inline int getans() {\n        for (int now = 1; now < n; ++now) {\n            for (int i = first[now]; i; i = e[i].nxt) {\n                int to = e[i].to;\n                if (!e[i].flow) {\n                    pp[now] = to;\n                    pp[to] = now;\n                    break;\n                }\n            }\n        }\n        queue<int> q;\n        while (!q.empty()) {\n            q.pop();\n        }\n        q.push(n);\n        memset(viss, 0, sizeof(viss));\n        viss[n] = 1;\n        int ans = 0;\n        while (!q.empty()) {\n            int now = q.front();\n            // cout << \"now = \" << now << endl;\n            q.pop();\n            for (auto jh : too[now]) {\n                if (!viss[pp[jh]]) {\n                    viss[pp[jh]] = true;\n                    ee[jh] = make_pair(now, pp[jh]);\n                    ans++;\n                    q.push(pp[jh]);\n                }\n            }\n        }\n        return ans;\n    }\n\n    int Main() {\n        read(n);\n        memset(first, 0xff, sizeof(first));\n        for (int i = 1, cnt, xx; i < n; ++i) {\n            read(cnt);\n            while (cnt--) {\n                read(xx);\n                dian[i + n - 1].push_back(xx);\n                too[xx].push_back(i + n - 1);\n                if (xx != n) {\n                    add_edge(xx, i + n - 1);\n                }\n            }\n        }\n        nn = (n - 1) << 1;\n        S = ++nn, T = ++nn;\n        for (int i = 1; i < n; ++i) {\n            add_edge(S, i);\n        }\n        for (int i = 1; i < n; ++i) {\n            add_edge(i + n - 1, T);\n        }\n        for (int i = 1; i <= n << 1; ++i) {\n            first_bak[i] = first[i];\n        }\n        int ff = Dinic();\n        if (ff != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        // cout << ff << endl;\n        if (getans() != n - 1) {\n            puts(\"-1\");\n            return 0;\n        }\n        for (int i = 1; i < n; ++i) {\n            writesp(ee[i + n - 1].first), writeln(ee[i + n - 1].second);\n        }\n        return 0;\n    }\n}\n\nint main() {\n    return dfcmd::Main();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<set<ll>>& cap){\n\n    if (v == g) return maxflow;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[v].count(nex) == 0)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            cap[v].insert(nex);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n    vector<ll> level(N,inf);\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        rep(i,0,N) level[i] = inf;\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<set<ll>> cap(N); \n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "//~ while (clock()<=69*CLOCKS_PER_SEC)\n//~ #pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"O3\")\n//~ #pragma GCC optimize(\"Ofast\")\n//~ #pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//~ #pragma GCC optimize(\"unroll-loops\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\ntemplate <typename T>\nusing ordered_set =\n    tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\n#define shandom_ruffle random_shuffle\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing vi=vector<int>;\nusing vll=vector<ll>;\nconst int nax=200*1007;\n\nusing T = int;\nclass Flow {\n  struct E {\n    int dest;\n    T orig, *lim, *rev;\n  };\n  int zr, uj, n = 0;\n  vector<unique_ptr<T>> ts;\n  vector<vector<E>> graf;\n  vector<int> ptr, odl;\n\n  void vert(int v) {\n    n = max(n, v + 1);\n    graf.resize(n);\n    ptr.resize(n);\n    odl.resize(n);\n  }\n\n  bool iszero(T v) {\n    return !v; // Zmieni dla doubli.\n  }\n\n  void bfs() {\n    fill(odl.begin(), odl.end(), 0);\n    vector<int> kol = {zr};\n    odl[zr] = 1;\n    for (int i = 0; i < (int) kol.size(); i++) {\n      for (E& e : graf[kol[i]]) {\n        if (!odl[e.dest] and !iszero(*e.lim)) {\n          odl[e.dest] = odl[kol[i]] + 1;\n          kol.push_back(e.dest);\n        }\n      }\n    }\n  }\n\n  T dfs(int v, T lim) {\n    if (v == uj) return lim;\n    T ret = 0, wez;\n    for (int& i = ptr[v]; i < (int) graf[v].size(); i++) {\n      E& e = graf[v][i];\n      if (odl[e.dest] == odl[v] + 1 and !iszero(*e.lim) and\n          !iszero(wez = dfs(e.dest, min(*e.lim, lim)))) {\n        ret += wez;\n        *e.lim -= wez;\n        *e.rev += wez;\n        lim -= wez;\n        if (iszero(lim)) break;\n      }\n    }\n    return ret;\n  }\n\n public:\n  void add_edge(int u, int v, T lim, bool bi = false /* bidirectional? */) {\n    vert(max(u, v));\n    T *a = new T(lim), *b = new T(lim * bi);\n    ts.emplace_back(a);\n    ts.emplace_back(b);\n    graf[u].push_back(E{v, lim,      a, b});\n    graf[v].push_back(E{u, lim * bi, b, a});\n  }\n\n  T dinic(int zr_, int uj_) {\n    zr = zr_; uj = uj_;\n    vert(max(zr, uj));\n    T ret = 0;\n    while (true) {\n      bfs();\n      fill(ptr.begin(), ptr.end(), 0);\n      const T sta = dfs(zr, numeric_limits<T>::max());  // Dla doubli mona da\n      if (iszero(sta)) break;                           // infinity() zamiast\n      ret += sta;                                       // max().\n    }\n    return ret;\n  }\n\n  vector<int> cut() {\n    vector<int> ret;\n    bfs();\n    for (int i = 0; i < n; i++)\n      if (odl[i])\n        ret.push_back(i);\n    return ret;\n  }\n\n  map<pair<int, int>, T> get_flowing() {  // Tam gdzie plynie 0 moe nie by\n    map<pair<int, int>, T> ret;           // krawdzi.\n    for (int i = 0; i < n; i++)\n      for (E& e : graf[i])\n        if (*e.lim < e.orig)\n          ret[make_pair(i, e.dest)] += e.orig - *e.lim;\n    for (auto& i : ret) {\n      const pair<int, int> rev{i.first.second, i.first.first};\n      const T x = min(i.second, ret[rev]);\n      i.second -= x;\n      ret[rev] -= x;\n    }\n    return ret;\n  }\n};\n\n\nint n;\nvi wek[nax];\n\nFlow janusz;\n\nvi nalezy[nax];\n\nint sko[nax];\nint prze[nax];\n\nint oj[nax];\n\nint ile[nax];\n\nvoid nope()\n{\n\tprintf(\"-1\\n\");\n\texit(0);\n}\n\nint fin(int v)\n{\n\tif (oj[v]!=v)\n\t\toj[v]=fin(oj[v]);\n\treturn oj[v];\n}\n\npii kra[nax];\n\nvoid uni(int a, int b, int kt)\n{\n\tif (fin(a)==fin(b))\n\t\tnope();\n\tkra[kt]={a, b};\n\toj[fin(a)]=fin(b);\n}\n\nint bylo[nax];\n\nvoid dfs(int v)\n{\n\tif (bylo[v])\n\t\treturn;\n\tbylo[v]=1;\n\tdebug() << imie(v);\n\tfor (int i : nalezy[v])\n\t{\n\t\tif (kra[i].first)\n\t\t\tcontinue;\n\t\tuni(v, prze[i], i);\n\t\tdfs(prze[i]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\toj[i]=i;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tint x, y;\n\t\tscanf(\"%d\", &x);\n\t\twhile(x--)\n\t\t{\n\t\t\tscanf(\"%d\", &y);\n\t\t\twek[i].push_back(y);\n\t\t\tnalezy[y].push_back(i);\n\t\t}\n\t\tile[i]=wek[i].size();\n\t\t//~ debug() << wek[i];\n\t}\n\tfor (int i=1; i<n; i++)\n\t\tjanusz.add_edge(0, i, 1);\n\tfor (int i=1; i<=n; i++)\n\t\tjanusz.add_edge(n+i, n, 1);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int j : wek[i])\n\t\t\tjanusz.add_edge(i, n+j, 1);\n\tjanusz.dinic(0, n);\n\tauto wez=janusz.get_flowing();\n\tdebug() << wez;\n\tfor (auto i : wez)\n\t\tif (i.first.first>0 && i.first.first<n && i.first.second>n && i.second)\n\t\t\tsko[i.first.second-n]=i.first.first;\n\tfor (int i=1; i<=n; i++)\n\t\tprze[sko[i]]=i;\n\tint v=0;\n\tdebug() << range(prze+1, prze+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tif (!sko[i])\n\t\t\tv=i;\n\tdebug() << imie(v);\n\tdfs(v);\n\tfor (int i=1; i<n; i++)\n\t\tif (!kra[i].first)\n\t\t\tnope();\n\tfor (int i=1; i<n; i++)\n\t\tprintf(\"%d %d\\n\", kra[i].first, kra[i].second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nnamespace io\n{\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\tinline void flush (){fwrite (obuf, 1, oS - obuf, stdout);oS = obuf;}\n\tinline void putc (char x){*oS ++ = x;if (oS == oT) flush ();}\n\ttemplate <class I>\n\tinline void gi (I &x) {for (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;}\n\ttemplate <class I>\n\tinline void print (I x){\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;while(x) qu[++ qr] = x % 10 + '0',  x /= 10;while (qr) putc (qu[qr--]);}\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io::gi;\nusing io::putc;\nusing io::print;\n\nconst int Max_N(100050);\n\nnamespace G\n{\n\tconst int Max_V(200050);\n\tconst int Max_E((100050 + 200050 + 100050) * 2);\n\tint V, S, T;\n\tint Head[Max_V], Total, To[Max_E], Next[Max_E], Cap[Max_E];\n\tinline void Add_Edge(int tot, int s, int t, int c)\n\t{\n\t\tTo[tot] = t, Next[tot] = Head[s], Head[s] = tot, Cap[tot] = c;\n\t}\n\tinline void Add_Link(int s, int t, int c)\n\t{\n\t\tTotal += 2, Add_Edge(Total, s, t, c), Add_Edge(Total ^ 1, t, s, 0);\n\t}\n\tint Cur[Max_V], Dist[Max_V], Q[Max_V];\n\tbool BFS()\n\t{\n\t\tmemset(Dist, 0, sizeof(Dist)), Dist[Q[Q[0] = 1] = S] = 1;\n\t\tfor (int ft = 1, u;ft <= Q[0];)\n\t\t{\n\t\t\tif ((u = Q[ft++]) == T)\n\t\t\t\treturn true;\n\t\t\tfor (int i = Head[u], v;i;i = Next[i])\n\t\t\t\tif (!Dist[v = To[i]] && Cap[i])\n\t\t\t\t\tDist[Q[++Q[0]] = v] = Dist[u] + 1;\n\t\t}\n\t\treturn false;\n\t}\n\tint DFS(int u, int a)\n\t{\n\t\tif (u == T || a == 0)\n\t\t\treturn a;\n\t\tint Ans(0);\n\t\tfor (int &i = Cur[u], v, f;i;i = Next[i])\n\t\t\tif (Dist[v = To[i]] == Dist[u] + 1 && (f = DFS(v, min(a, Cap[i]))) > 0)\n\t\t\t{\n\t\t\t\tAns += f, Cap[i] -= f, Cap[i ^ 1] += f;\n\t\t\t\tif ((a -= f) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\treturn Ans;\n\t}\n\tint Dinic()\n\t{\n\t\tint Ans(0);\n\t\twhile (BFS())\n\t\t{\n\t\t\tfor (int i = 1;i <= V;++i)\n\t\t\t\tCur[i] = Head[i];\n\t\t\tAns += DFS(S, 0X3F3F3F3F);\n\t\t}\n\t\treturn Ans;\n\t}\n}\n\nint N, Father[Max_N * 2], P[Max_N * 2];\nvector<int> A[Max_N * 2], In[Max_N * 2];\nbool done[Max_N * 2];\n\nint Get_Father(int x)\n{\n\treturn Father[x] == x ? x : Father[x] = Get_Father(Father[x]);\n}\n\nvoid dfs(int u)\n{\n\tfor (int i = 0, t;i < In[u].size();++i)\n\t\tif (!done[t = In[u][i]])\n\t\t{\n\t\t\tdone[t] = true;\n\t\t\tfor (int j = 0, v;j < A[t].size();++j)\n\t\t\t\tif (P[v = A[t][j]] == t)\n\t\t\t\t\tprint(u), putc(' '), print(v), putc('\\n'), dfs(v);\n\t\t}\n}\n\nint main()\n{\n\tgi(N);\n\tG::V = N + (N - 1) + 2, G::S = N + (N - 1) + 1, G::T = N + (N - 1) + 2;\n\tfor (int u = 2;u <= N;++u)\n\t\tFather[u] = u, G::Add_Link(G::S, u, 1);\n\tfor (int i = N + 1, c;i <= N + (N - 1);++i)\n\t{\n\t\tFather[i] = i, gi(c), G::Add_Link(i, G::T, 1);\n\t\tfor (int u;c--;)\n\t\t{\n\t\t\tgi(u), In[u].push_back(i), A[i].push_back(u);\n\t\t\tif (u != 1)\n\t\t\t\tFather[Get_Father(u)] = i, G::Add_Link(u, i, 1);\n\t\t}\n\t}\n\tfor (int i = 2;i <= N + (N - 1);++i)\n\t\tif (Get_Father(i) != Get_Father(2))\n\t\t{\n\t\t\tprint(-1);\n\t\t\treturn 0;\n\t\t}\n\tif (G::Dinic() == N - 1)\n\t{\n\t\tfor (int u = 2;u <= N;++u)\n\t\t\tfor (int i = G::Head[u];i;i = G::Next[i])\n\t\t\t\tif (N + 1 <= G::To[i] && G::To[i] <= N + (N - 1) && G::Cap[i] == 0)\n\t\t\t\t\tP[u] = G::To[i];\n\t\tdfs(1); \n\t}\n\telse\n\t\tprint(-1); \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define FILL(a, n, x) memset((a), (x), sizeof ((a)[0]) * (n))\n#define FILLA(a, x) memset((a), (x), sizeof (a))\n#define COPY(a, n, b) memcpy((b), (a), sizeof ((a)[0]) * (n))\n#define COPYA(a, b) memcpy((b), (a), sizeof (a))\n\ntypedef unsigned long long lu;\ntypedef long long li;\ntypedef pair<int, int> pii;\nconst int mod = 1e9 + 7;\n\ninline int Add(int x) { return x >= mod ? x - mod : x; }\ninline void Add(int &x, int y) { x += y; if (x >= mod) x -= mod; }\ninline int Sub(int x) { return x < 0 ? x + mod : x; }\ninline void Sub(int &x, int y) { x = Sub(x - y); }\ninline int Mul(int x, int y) { return (int)((lu)x * y % mod); }\ninline int Mul(int x, int y, int z) { return (int)((lu)x * y % mod * z % mod); }\n\nint Pow(int x, int y) {\n  int z = 1;\n  for (; y; y >>= 1) {\n    if (y & 1) z = Mul(z, x);\n    x = Mul(x, x);\n  }\n  return z;\n}\n\nint Inv(int x) { return Pow(x, mod - 2); }\ntemplate <class T> inline void Max(T &x, T y) { if (y > x) x = y; }\ntemplate <class T> inline void Min(T &x, T y) { if (y < x) x = y; }\n\n// ----------------------------------------\n\nnamespace dinic {\n  const int maxn = 1e6, maxm = 1e6;\n  typedef int FlowType;\n  const FlowType inf_f = ~0U >> 1;\n\n  void Init(int n);\n  void AddEdge(int u, int v, FlowType cap, li id);\n  FlowType Solve(int s, int t);\n  vector< pair<li, FlowType> > Result(void);\n}\n\nnamespace dinic {\n  struct Edge {\n    int v;\n    li id;\n    FlowType cap, cap0;\n  } edge[maxm << 1];\n\n  int n, m, s, t;\n  vector<int> g[maxn];\n\n  void Init(int _n) {\n    n = _n, m = 0;\n    for (int i = 0; i < n; ++i) g[i].clear();\n  }\n\n  void AddEdge(int u, int v, FlowType c, li id = -1) {\n    g[u].push_back(m);\n    edge[m++] = (Edge){v, id, c, c};\n    g[v].push_back(m);\n    edge[m++] = (Edge){u, id, 0, 0};\n  }\n\n  int iter[maxn], dist[maxn];\n\n  bool Bfs(void) {\n    queue<int> que;\n    que.push(s);\n    FILL(dist, n, -1);\n    dist[s] = 0;\n    while (!que.empty()) {\n      int u = que.front(); que.pop();\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap && dist[e.v] == -1) {\n          dist[e.v] = dist[u] + 1;\n          que.push(e.v);\n        }\n      }\n    }\n    return dist[t] >= 0;\n  }\n\n  FlowType Dfs(int u, FlowType f) {\n    if (u == t) return f;\n    FlowType sum = 0;\n    for (int &i = iter[u]; i < g[u].size(); ++i) {\n      Edge &e = edge[g[u][i]], &rev = edge[g[u][i] ^ 1];\n      if (e.cap && dist[e.v] == dist[u] + 1) {\n        FlowType res = Dfs(e.v, min(f - sum, e.cap));\n        e.cap -= res;\n        rev.cap += res;\n        if ((sum += res) == f) break;\n      }\n    }\n    return sum;\n  }\n\n  FlowType Solve(int _s, int _t) {\n    s = _s, t = _t;\n    FlowType ans = 0;\n    while (Bfs()) {\n      FILL(iter, n, 0);\n      ans += Dfs(s, inf_f);\n    }\n    return ans;\n  }\n\n  vector< pair<li, FlowType> > Result(void) {\n    vector< pair<li, FlowType> > ans;\n    for (int u = 0; u < n; ++u) {\n      for (int i = 0; i < g[u].size(); ++i) {\n        Edge &e = edge[g[u][i]];\n        if (e.cap < e.cap0 && e.id != -1) {\n          ans.push_back(make_pair(e.id, e.cap0 - e.cap));\n        }\n      }\n    }\n    return ans;\n  }\n}\n\n// ----------------------------------------\n\nconst int maxn = 1e5;\nint n;\nvector<int> E[maxn];\nvector<int> F[maxn];\n\nint match[maxn], par[maxn];\nint A[maxn], B[maxn];\n\nvoid NoSolution(void) {\n  puts(\"-1\");\n  exit(0);\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n - 1; ++i) {\n    int c;\n    scanf(\"%d\", &c);\n    while (c--) {\n      int x;\n      scanf(\"%d\", &x);\n      --x;\n      E[i].push_back(x);\n      F[x].push_back(i);\n    }\n  }\n\n  // root = 0\n  int L = 0, R = n, S = R + n - 1, T = S + 1, N = T + 1;\n  dinic::Init(N);\n  for (int i = 1; i < n; ++i) {\n    dinic::AddEdge(S, L + i, 1, -1);\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    dinic::AddEdge(R + i, T, 1, -1);\n  }\n  for (int i = 1; i < n; ++i) {\n    for (int j : F[i]) {\n      dinic::AddEdge(L + i, R + j, 1, (li)i * n + j);\n    }\n  }\n  int flow = dinic::Solve(S, T);\n  if (flow < n - 1) NoSolution();\n\n  vector< pair<li, int> > way = dinic::Result();\n  for (pair<li, int> p : way) {\n    int x = (int)(p.first / n), y = (int)(p.first % n);\n    match[y] = x;\n  }\n\n  queue<int> que;\n  que.push(0);\n  FILL(par, n, -1);\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (int j : F[u]) {\n      int i = match[j];\n      if (par[i] == -1) {\n        par[i] = u;\n        A[j] = i;\n        B[j] = u;\n        que.push(i);\n      }\n    }\n  }\n  for (int i = 1; i < n; ++i) {\n    if (par[i] == -1) NoSolution();\n  }\n  for (int i = 0; i < n - 1; ++i) {\n    printf(\"%d %d\\n\", A[i] + 1, B[i] + 1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\n#define fst first\n#define snd second\n#define pb(a) push_back(a)\n#define mp(a, b) std::make_pair(a, b)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n\nconst int oo = 0x3f3f3f3f;\n\nstring procStatus() {\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\n\ntemplate <typename T> T read(T& x) {\n    int f = 1; x = 0;\n    char ch = getchar();\n    for(;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for(; isdigit(ch); ch = getchar()) x = x * 10 + ch - 48;\n    return x *= f;\n}\n\nconst int N = 200000;\nconst int M = N << 4;\n\nint S, T;\n\nstruct edge {\n    int to, nxt, cap;\n};\n\nedge e[M + 5];\nint st[N + 5], ecnt = 1;\n\nvoid addedge(int u, int v, int c) {\n    e[++ ecnt] = (edge) { v, st[u], c }, st[u] = ecnt;\n    e[++ ecnt] = (edge) { u, st[v], 0 }, st[v] = ecnt;\n}\n\nint cur[N + 5], dis[N + 5];\n\nbool bfs() {\n    static int que[N + 5];\n    int head = 0, tail = 0;\n\n    memset(dis, 0xff, sizeof dis);\n    dis[que[tail ++] = S] = 0;\n\n    while(head < tail) {\n        int x = que[head ++];\n        for(int i = st[x]; i; i = e[i].nxt) if(e[i].cap) {\n            int y = e[i].to;\n            if(dis[y] == -1) {\n                dis[y] = dis[x] + 1;\n                que[tail ++] = y;\n            }\n        }\n    }\n    return ~dis[T];\n}\n\nint dfs(int x, int flow) {\n    if(x == T || !flow) {\n        return flow;\n    }\n\n    int res = 0;\n    for(int &i = cur[x]; i; i = e[i].nxt) {\n        int y = e[i].to, aug;\n        if(dis[y] == dis[x] + 1 && (aug = dfs(y, std::min(e[i].cap, flow)))) {\n            res += aug;\n            flow -= aug;\n            e[i].cap -= aug;\n            e[i ^ 1].cap += aug;\n            if(!flow) break;\n        }\n    }\n    return res;\n}\n\nint max_flow() {\n    int ans = 0;\n    while(bfs()) {\n        memcpy(cur, st, sizeof cur);\n        ans += dfs(S, oo);\n    }\n    return ans;\n}\n\nint n, cnt;\npii ans[N + 5];\nint mat[N + 5];\nbool vis[N + 5];\nvector<int> g[N + 5];\n\nvoid dfs(int u) {\n    for(auto v : g[u]) if(!vis[v]) {\n        ++ cnt;\n        vis[v] = true;\n        ans[v - n] = mp(u, mat[v]);\n        dfs(mat[v]);\n    }\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"in\", \"r\", stdin);\n    freopen(\"out\", \"w\", stdout);\n#endif\n\n    read(n);\n    S = n << 1, T = S + 1;\n    for(int i = 2; i <= n; ++i) {\n        addedge(S, i, 1);\n    }\n\n    for(int i = 1; i < n; ++i) {\n        static int c, x;\n\n        for(read(c); c--; ) {\n            read(x);\n            g[x].pb(i + n);\n            addedge(x, i + n, 1);\n        }\n        addedge(i + n, T, 1);\n    }\n\n    int mf = max_flow();\n\n    if(mf < n - 1) return !puts(\"-1\");\n\n    for(int i = 2; i <= n; ++i) {\n        for(int j = st[i]; j; j = e[j].nxt) {\n            int t = e[j].to;\n            if(!e[j].cap && t > n && t < 2*n) {\n                mat[t] = i;\n                break;\n            }\n        }\n    }\n\n    dfs(1);\n\n    if(cnt < n - 1) {\n        puts(\"-1\");\n    } else {\n        for(int i = 1; i < n; ++i) {\n            printf(\"%d %d\\n\", ans[i].fst, ans[i].snd);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int inf=1000000000;\nint n,m,cnt,id[100001],p[100001],P[100001],hd[200101],cur[200101],dis[200101],q[200101],l,r,K,x,fa[100001],ans,nw;\nstruct node{int to,next,c;}e[1000001];\nvector<int> v[100001];\nbool bo[200101];\n\nint ask(int x) {return fa[x]==x?x:fa[x]=ask(fa[x]);}\nbool cmp(int a,int b) {return v[a].size()<v[b].size();}\n\nvoid addedge(int x,int y,int c) \n{\n\te[++cnt]=(node){y,hd[x],c},hd[x]=cnt;\n\te[++cnt]=(node){x,hd[y],0},hd[y]=cnt;\n}\n\nbool bfs()\n{\n\tfor (int i=1; i<=n+n+1; i++) dis[i]=inf;\n\tq[l=r=1]=1,dis[1]=0,memset(bo,0,sizeof(bo)),bo[1]=0;\n\twhile (l<=r)\n\t{\n\t\tx=q[l];\n\t\tfor (int i=hd[x]; i; i=e[i].next)\n\t\t\tif (e[i].c&&!bo[e[i].to]) bo[e[i].to]=1,q[++r]=e[i].to,dis[e[i].to]=dis[x]+1;\n\t\tl++;\n\t}\n\treturn dis[n+n+1]<inf;\n}\n\nbool dinic(int x)\n{\n\tif (x==n+n+1) return 1;\n\tfor (int &i=cur[x]; i; i=e[i].next)\n\t\tif (e[i].c&&dis[e[i].to]==dis[x]+1&&dinic(e[i].to)) \n\t\t\treturn e[i].c--,e[i^1].c++,1;\n\treturn 0;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n),cnt=1;\n\tmemset(hd,0,sizeof(hd));\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tscanf(\"%d\",&K),v[i].clear(),id[i]=i;\n\t\tfor (int j=1; j<=K; j++) scanf(\"%d\",&x),v[i].push_back(x);\n\t}\n\tsort(id+1,id+n,cmp);\n\tfor (int i=1; i<n; i++) addedge(1,i+1,1);\n\tfor (int i=1; i<=n; i++) addedge(i+n,n+n+1,1);\n\tfor (int i=1; i<n; i++)\n\t\tfor (int siz=v[i].size(),j=0; j<siz; j++) \n\t\t\taddedge(i+1,v[i][j]+n,1);\n\tans=0;\n\twhile (bfs())\n\t{\n\t\tfor (int i=1; i<=n+n+1; i++) cur[i]=hd[i];\n\t\twhile (dinic(1)) ans++;\n\t}\n\tif (ans!=n-1) return puts(\"-1\"),0;\n\tfor (int i=1; i<n; i++) \n\t\tfor (int j=hd[i+1]; j; j=e[j].next)\n\t\t\tif (!e[j].c) {p[i]=e[j].to-n; break;}\n\tfor (int i=1; i<=n; i++) fa[i]=i;\n\tfor (int i=1; i<n; i++)\n\t{\n\t\tP[id[i]]=0;\n\t\tfor (int j=0,siz=v[id[i]].size(); j<siz; j++)\n\t\t\tif (ask(v[id[i]][j])!=ask(p[id[i]])) {P[id[i]]=v[id[i]][j]; break;}\n\t\tif (!P[id[i]]) return puts(\"-1\"),0;\n\t\tfa[ask(P[id[i]])]=ask(p[id[i]]);\n\t}\n\tfor (int i=1; i<n; i++) printf(\"%d %d\\n\",p[i],P[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=100000;\nconst int MAXESUM=200000;\n\nconst int MAXGN=2+MAXN+MAXN-1;\nconst int MAXGM=MAXN-1+MAXN-1+MAXESUM;\n\ntypedef struct MF {\n\tint n,m;\n\tint ghead[MAXGN],gnxt[2*MAXGM],gto[2*MAXGM]; ll gcap[2*MAXGM];\n\tvoid init(int _n) { n=_n,m=0; REP(i,n) ghead[i]=-1; }\n\tvoid addedge(int a,int b,ll c) { gnxt[2*m+0]=ghead[a],ghead[a]=2*m+0,gto[2*m+0]=b,gcap[2*m+0]=c; gnxt[2*m+1]=ghead[b],ghead[b]=2*m+1,gto[2*m+1]=a,gcap[2*m+1]=0; ++m; /*printf(\"%d->%d\\n\",a,b);*/ }\n\tint d[MAXGN];\n\tint q[MAXGN],qhead,qtail;\n\tint cur[MAXGN];\n\tll dinic(int s,int t) {\n\t\tll ret=0; int niter=0;\n\t\twhile(true) {\n\t\t\tREP(i,n) d[i]=INT_MAX; qhead=qtail=0; d[s]=0,q[qhead++]=s;\n\t\t\twhile(qtail<qhead&&d[t]==INT_MAX) { int at=q[qtail++];for(int x=ghead[at];x!=-1;x=gnxt[x]) { int to=gto[x]; if(gcap[x]==0||d[to]!=INT_MAX) continue; d[to]=d[at]+1; q[qhead++]=to; } }\n\t\t\tif(d[t]==INT_MAX) return ret;\n\t\t\tREP(i,n) cur[i]=ghead[i];\n\t\t\tret+=dfs(s,t,LLONG_MAX); ++niter;\n\t\t}\n\t}\n\tll dfs(int at,int t,ll rem) {\n\t\tll ret=0; if(at==t) return rem;\n\t\tif(d[at]>=d[t]) return 0;\n\t\tfor(;cur[at]!=-1;cur[at]=gnxt[cur[at]]) {\n\t\t\tint to=gto[cur[at]]; ll cap=gcap[cur[at]]; if(d[to]!=d[at]+1||cap==0) continue;\n\t\t\tll now=dfs(to,t,min(cap,rem));\n\t\t\trem-=now; ret+=now; if(gcap[cur[at]]!=LLONG_MAX) gcap[cur[at]]-=now; if(gcap[cur[at]^1]!=LLONG_MAX) gcap[cur[at]^1]+=now; if(rem==0) return ret;\n\t\t}\n\t\treturn ret;\n\t}\n} MF;\nMF g;\n\n\nint n;\nvector<int> e[MAXN-1];\npair<int,int> ans[MAXN-1];\n\nint sid,tid,lid[MAXN],rid[MAXN-1],nid;\nint match[MAXN],rmatch[MAXN-1];\nvector<int> who[MAXN];\nbool intree[MAXN];\nint q[MAXN],qhead,qtail;\n\nbool solve() {\n\tnid=0; sid=nid++,tid=nid++; FOR(i,1,n) lid[i]=nid++; REP(i,n-1) rid[i]=nid++;\n\tg.init(nid);\n\tFOR(i,1,n) g.addedge(sid,lid[i],1);\n\tREP(j,n-1) for(int i:e[j]) if(i!=0) g.addedge(lid[i],rid[j],1);\n\tREP(i,n-1) g.addedge(rid[i],tid,1);\n\tll flow=g.dinic(sid,tid);\n\t\n\tif(flow!=n-1) return false;\n\tREP(i,n) match[i]=-1; FOR(i,1,n) for(int x=g.ghead[lid[i]];x!=-1;x=g.gnxt[x]) if(g.gcap[x^1]==1&&g.gto[x]>=rid[0]) { assert(match[i]==-1); match[i]=g.gto[x]-rid[0]; } FOR(i,1,n) assert(match[i]!=-1);\n\tREP(i,n-1) rmatch[i]=-1; REP(i,n) if(match[i]!=-1) { assert(rmatch[match[i]]==-1); rmatch[match[i]]=i; } REP(i,n-1) assert(rmatch[i]!=-1);\n\t//FOR(i,1,n) { printf(\"%d:\",i+1); REPSZ(j,e[match[i]]) printf(\" %d\",e[match[i]][j]+1); puts(\"\"); }\n\n\tREP(i,n-1) REPSZ(j,e[i]) who[e[i][j]].PB(i);\n\tqhead=qtail=0; REP(i,n) intree[i]=false;\n\tintree[0]=true; q[qhead++]=0;\n\twhile(qtail<qhead) {\n\t\tint at=q[qtail++];\n\t\tREPSZ(i,who[at]) {\n\t\t\tint id=who[at][i],to=rmatch[id];\n\t\t\tif(!intree[to]) { ans[id]=MP(at,to); intree[to]=true; q[qhead++]=to; }\n\t\t}\n\t}\n\tREP(i,n) if(!intree[i]) return false;\n\treturn true;\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n-1) { int cnt; scanf(\"%d\",&cnt); REP(j,cnt) { int x; scanf(\"%d\",&x); --x; e[i].PB(x); } }\n\tif(!solve()) { printf(\"-1\\n\"); return; }\n\tREP(i,n-1) printf(\"%d %d\\n\",ans[i].first+1,ans[i].second+1);\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint head[200010];\nint cur[200010];\nstruct edge {\n    int v, c, next;\n    edge() {}\n    edge(int _v, int _c, int _next) : v(_v), c(_c), next(_next) {}\n} e[1000010];\nint n, s, t;\nint newedge(int v = 0, int c = 0, int next = 0) {\n    static int tot = 2;\n    return e[tot] = edge(v, c, next), tot++;\n}\nvoid addedge(int u, int v, int c) {\n    head[u] = newedge(v, c, head[u]);\n    head[v] = newedge(u, 0, head[v]);\n}\nint d[2010];\nint bfs() {\n    memset(d, -1, sizeof d);\n    queue < int > q;\n    q.push(0);\n    d[s] = 1;\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now]; i; i = e[i].next)\n            if (e[i].c > 0 && d[e[i].v] == -1)\n                d[e[i].v] = d[now] + 1, q.push(e[i].v);\n    }\n    memcpy(cur, head, sizeof cur);\n    return d[t] > 0;\n}\nint dfs(int now = 0, int limit = 0x7fffffff) {\n    if (now == t)\n        return limit;\n    int ans = 0;\n    for (int &i = cur[now]; i; i = e[i].next) {\n        if (d[e[i].v] != d[now] + 1 || e[i].c == 0)\n            continue;\n        int a = dfs(e[i].v, min(e[i].c, limit));\n        limit -= a;\n        ans += a;\n        e[i].c -= a;\n        e[i ^ 1].c += a;\n        if (limit == 0)\n            break;\n    }\n    return ans;\n}\nint tmp[200010], to[100010], ans[100010];\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i < n; i++) {\n        int cnt;\n        scanf(\"%d\", &cnt);\n        while (cnt--) {\n            int x;\n            scanf(\"%d\", &x);\n            addedge(i, n - 1 + x, 1);\n        }\n    }\n    s = 0, t = n + n;\n    memcpy(tmp, head, sizeof tmp);\n    for (int i = 1; i < n; i++) addedge(s, i, 1), addedge(i + n - 1, t, 1);\n    int ans = 0;\n    while (bfs())\n        ans += dfs();\n    memcpy(head, tmp, sizeof tmp);\n    if (ans != n - 1) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++)\n        for (int j = head[i]; j; j = e[j].next) if (e[j].c == 0) to[i] = e[j].v - n + 1;\n    queue < int > q;\n    q.push(n);\n    while (!q.empty()) {\n        int now = q.front();\n        q.pop();\n        for (int i = head[now + n - 1]; i; i = e[i].next) {\n            if (!::ans[to[e[i].v]]) {\n                q.push(to[e[i].v]);\n                ::ans[to[e[i].v]] = now;\n            }\n        }\n    }\n    for (int i = 1; i < n; i++) if (!::ans[i]) return puts(\"-1\"), 0;\n    for (int i = 1; i < n; i++) printf(\"%d %d\\n\", ::ans[to[i]], to[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[(N<<1)+3];\nvector<pair<int,pii> > ans;\nint mch[(N<<1)+3];\nbool vis[(N<<1)+3];\nint n;\n\nvoid dfs(int u)\n{\n\tfor(int o=0; o<adj[u].size(); o++)\n\t{\n\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\tif(vis[mch[v]]) continue;\n\t\tvis[v] = vis[mch[v]] = true; ans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\tdfs(mch[v]);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tvis[1] = true; dfs(1);\n\tif(ans.size()<n-1) {puts(\"-1\"); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#ifndef LOCAL\n#define cerr dolor_sit_amet\n#endif\n\n#define mp make_pair\n#define sz(x) ((int)((x).size()))\n#define X first\n#define Y second\n#define all(x) (x).begin(), (x).end()\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair < int , int > ipair;\ntypedef pair < ll , ll > lpair;\nconst int IINF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3fll;\nconst double DINF = numeric_limits<double>::infinity();\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\nconst int DX[] = { 1,  0, -1,  0,  1, -1,  1, -1};\nconst int DY[] = { 0,  1,  0, -1,  1, -1, -1,  1};\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll sqr(ll x) { return x*x; } ll sqr(int x) { return (ll)x*x; }\ndouble sqr(double x) { return x*x; } ld sqr(ld x) { return x*x; }\nmt19937 mmtw(960172);\nll rnd(ll x, ll y) { static uniform_int_distribution<ll> d; return d(mmtw) % (y - x + 1) + x; }\n\ntemplate<typename T> T& updMin(T& a, T const& b) { if (b < a) a = b; return a; }\ntemplate<typename T> T& updMax(T& a, T const& b) { if (a < b) a = b; return a; }\n\n// ========================================================================= //\n\nint main() {\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> sets(n - 1);\n    vector<vector<int>> v2s(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int s;\n        cin >> s;\n        sets[i].resize(s);\n        for (int j = 0; j < s; ++j) {\n            int x;\n            cin >> x;\n            --x;\n            sets[i][j] = x;\n            v2s[x].push_back(i);\n        }\n    }\n\n    vector<int> pv(n, 0), ps(n - 1, -1);\n    vector<char> visv(n, 0);\n\n    function<bool(int)> dfs1 = [&](int v) {\n        if (visv[v])\n            return 0;\n        visv[v] = 1;\n        for (int nv : v2s[v])\n            if (ps[nv] == -1 || dfs1(ps[nv])) {\n                ps[nv] = v;\n                return 1;\n            }\n        return 0;\n    };\n\n    while (true) {\n        bool was = false;\n        for (int i = 0; i < n; ++i)\n            if (!pv[i]) {\n                if (dfs1(i))\n                    was = 1;\n            }\n        memset(visv.data(), 0, sizeof(char) * n);\n        if (!was)\n            break;\n    }\n\n    int root = -1;\n    for (int i = 0; i < n; ++i)\n        if (pv[i] == 0)\n            root = i;\n\n    vector<ipair> es;\n    function<void(int)> dfs = [&](int v) {\n        visv[v] = true;\n        for (int s : v2s[v]) {\n            int nv = ps[s];\n            if (nv == -1 || visv[nv])\n                continue;\n            es.push_back({v, nv});\n            dfs(nv);\n        }\n    };\n    dfs(root);\n\n    if (sz(es) != n - 1) {\n        cout << \"-1\\n\";\n        return 0;\n    }\n    for (ipair a : es)\n        cout << min(a.X, a.Y) + 1 << \" \" << max(a.X, a.Y) + 1 << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nnamespace mxfl{\n  const int N=1e6, M=5e6;\n  typedef int str;\n  const str inf=1e9;\n  \n  struct E{\n    int to; str fl; int nex;\n  }e[M];\n  int n, hea[N], cne, cur[N], st, en, d[N];\n  void init(int n_=N-1){\n    n=n_; cne=1;\n    memset(hea,0,sizeof (int)*(n+1));\n  }\n  int adde(int u,int v,str w,str bw=0){\n    e[++cne]=(E){v,w,hea[u]}; hea[u]=cne;\n    e[++cne]=(E){u,bw,hea[v]}; hea[v]=cne;\n    return cne;\n  }\n  bool bfs(){\n    memset(d,33,sizeof d); d[st]=0;\n    queue<int>q; q.push(st);\n    for (int x,y,z;!q.empty();){\n      x=q.front(); q.pop(); if (x==en) return 1;\n      for (int i=hea[x];i;i=e[i].nex){\n        if (!e[i].fl) continue;\n        y=e[i].to; z=d[x]+1;\n        if (z<d[y]) d[y]=z, q.push(y);\n      }\n    }\n    return 0;\n  }\n  str dfs(int x,str F){\n    if (x==en||!F) return F;\n    str las=F;\n    for (int &i=cur[x];i;i=e[i].nex){\n      int y=e[i].to;\n      if (!e[i].fl||d[y]!=d[x]+1) continue;\n      str t=dfs(y,min(las,e[i].fl));\n      las-=t; e[i].fl-=t; e[i^1].fl+=t;\n      if (!las) break;\n    }\n    return F-las;\n  }\n  str realmain(int st_,int en_){\n    st=st_; en=en_;\n    str ans=0;\n    for (;bfs();){\n      memcpy(cur,hea,sizeof (int)*(n+1));\n      ans+=dfs(st,inf);\n    }\n    return ans;\n  }\n}\n\nint n, s, t, pre[101000], vis[101000];\nvector<tuple<int,int,int> >vec;\nvector<int>in[101000];\n\nvoid dfs(int x){\n    for (auto y:in[x])\n        if (!vis[y]){\n            vis[y]=x;\n            dfs(pre[y]);\n        }\n}\n\nint main(){\n    cin>>n; s=n*2+1; t=n*2+2;\n    mxfl::init(t);\n    for (int i=1;i<=n-1;++i){\n        int k, x; scanf(\"%d\",&k);\n        for (;k--;){\n            scanf(\"%d\",&x);\n            in[x].push_back(i);\n            vec.push_back({x,i,mxfl::adde(x,i+n,1)});\n        }\n    }\n    for (int i=1;i<=n-1;++i){\n        mxfl::adde(s,i,1);\n        mxfl::adde(i+n,t,1);\n    }\n    if (mxfl::realmain(s,t)!=n-1){\n        puts(\"-1\"); exit(0);\n    }\n    for (auto o:vec){\n        int u, v, id; tie(u,v,id)=o;\n        if (mxfl::e[id].fl){\n            pre[v]=u;\n        }\n    }\n    dfs(n);\n    if (*min_element(vis+1,vis+n)==0){\n        puts(\"-1\"); exit(0);\n    }\n    for (int i=1;i<=n-1;++i)\n        printf(\"%d %d\\n\",pre[i],vis[i]);\n}"
  },
  {
    "language": "C++",
    "code": "/****************************************************************\n*\tAuthor: huhao\n*\tEmail: 826538400@qq.com\n*\tCreate time: 2020-02-14 10:45:07\n****************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\n#include<vector>\nconst int N=400010;\nstd::vector<int> e[N];\nint n,q[N],l,r,id[N],vis[N],u[N],v[N],m;\nnamespace dinic\n{\n\tint e=1,begin[N],next[N],to[N],w[N],dis[N],n,S,T,q[N],l,r,cur[N];\n#define fo(i,a) for(int i=begin[a];i;i=next[i])\n#define Fo(i,a) for(int &i=cur[a];i;i=next[i])\n\tvoid add(int u,int v,int W){ e++; next[e]=begin[u]; begin[u]=e; to[e]=v; w[e]=W; }\n\tint bfs()\n\t{\n\t\tfr(i,1,n) dis[i]=n+1;\n\t\tfr(i,1,n) cur[i]=begin[i];\n\t\tq[l=r=1]=T; dis[T]=0;\n\t\twhile(l<=r)\n\t\t{\n\t\t\tint u=q[l++];\n\t\t\tfo(i,u) if(w[i^1]&&dis[u]+1<dis[to[i]])\n\t\t\t{\n\t\t\t\tdis[to[i]]=dis[u]+1; q[++r]=to[i];\n\t\t\t}\n\t\t}\n//\t\tfr(i,1,n) printf(\"%d%c\",dis[i],i==n?'\\n':' ');\n\t\treturn dis[S]<=n;\n\t}\n\tint dfs(int u,int F)\n\t{\n\t\tint ans=0;\n\t\tif(u==T) return F;\n\t\tFo(i,u) if(w[i]&&dis[u]-1==dis[to[i]])\n\t\t{\n\t\t\tint f=dfs(to[i],std::min(F,w[i]));\n\t\t\tif(f)\n\t\t\t{\n\t\t\t\tF-=f; w[i]-=f; ans+=f; w[i^1]+=f;\n\t\t\t\tif(!F) return ans;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid Add(int u,int v,int w){ add(u,v,w); add(v,u,0); }\n\tvoid solve()\n\t{\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n\t\twhile(bfs()) dfs(S,n);\n\t\tfr(i,1,::n-1) fo(j,i) if(to[j]>=::n+1&&w[j^1]) ::id[i]=to[j]-::n;\n//\t\tfr(i,1,n) fo(j,i) if(w[j]) printf(\"%d %d\\n\",i,to[j]);\n//\t\tfr(i,1,::n-1) printf(\"%d%c\",::id[i],i==end_i?'\\n':' ');\n\t}\n}\nint main()\n{\n\tn=read(); dinic::n=n*2; dinic::S=n; dinic::T=n+1;\n\tfr(i,1,n-1)\n\t{\n\t\tint c=read();\n\t\tfr(j,1,c)\n\t\t{\n\t\t\tint u=read();\n\t\t\te[u].push_back(i); if(u!=1) dinic::Add(i,u+n,1);\n\t\t}\n\t}\n\tfr(i,1,n-1){ dinic::Add(dinic::S,i,1); dinic::Add(i+n+1,dinic::T,1); }\n\tdinic::solve();\n\tfr(i,1,n-1) if(!id[i]){ printf(\"-1\\n\"); return 0; }\n\tq[l=r=1]=1; vis[1]=1;\n/*\tfr(i,1,n)\n\t{\n\t\tfor(auto j:e[i]) printf(\"%d \",j);\n\t\tputchar(10);\n\t}*/\n\twhile(l<=r)\n\t{\n\t\tint i=q[l++];\n\t\tfor(auto j:e[i]) if(!vis[id[j]]){ m++; u[m]=i; v[m]=id[j]; vis[id[j]]=1; q[++r]=id[j]; }\n\t}\n\tif(m<n-1) printf(\"-1\\n\");\n\telse fr(i,1,m) printf(\"%d %d\\n\",u[i],v[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#define N 200011\n#define INF 0x7f7f7f7f\nusing namespace std;\nstruct apple{\n\tint v,nxt,flw;\n}edge[N*11];\nint que[N],indexx[N],dist[N],cur[N],Mac[N][2],tot,S,T,vist[N],n;\nvector<int> V[N];\nvoid addedge(int x,int y,int flw){\n\tedge[++tot].v=y;\n\tedge[tot].flw=flw;\n\tedge[tot].nxt=indexx[x];\n\tindexx[x]=tot;\n}\nvoid add(int x,int y,int flw){\n\taddedge(x,y,flw);\n\taddedge(y,x,0);\n}\nint bfs(){\n\tmemset(dist,0,sizeof(dist));\n\tmemcpy(cur,indexx,sizeof(indexx));\n\tdist[S]=1;\n\tint head=0,tail=0;\n\tque[++tail]=S;\n\twhile(head<tail){\n\t\tint x=que[++head];\n\t\tint t=indexx[x],vv;\n\t\twhile(t){\n\t\t\tvv=edge[t].v;\n\t\t\tif(edge[t].flw && !dist[vv]){\n\t\t\t\tdist[vv]=dist[x]+1;\n\t\t\t\tque[++tail]=vv;\n\t\t\t}\n\t\t\tt=edge[t].nxt;\n\t\t}\n\t}\n\treturn dist[T];\n}\nint dfs(int u,int flw){\n\tif(u==T) return flw;\n\tint t=cur[u],vv,All=0;\n\twhile(t){\n\t\tvv=edge[t].v;\n\t\tcur[u]=t;\n\t\tif(edge[t].flw && dist[vv]==dist[u]+1){\n\t\t\tint temp=dfs(vv,min(flw,edge[t].flw));\n\t\t\tif(temp){\n\t\t\t\tAll+=temp;\n\t\t\t\tedge[t].flw-=temp;\n\t\t\t\tedge[((t-1)^1)+1].flw+=temp;\n\t\t\t\tflw-=temp;\n\t\t\t\tif(!flw) return All;\n\t\t\t}\n\t\t}\n\t\tt=edge[t].nxt;\n\t}\n\treturn All;\n}\nint Dinic(){\n\tint ret=0;\n\twhile(bfs()){\n\t\tret+=dfs(S,INF);\n\t}\n\treturn ret;\n}\nint solve(){\n\tint head=0,tail=0;\n\tque[++tail]=n;\n\twhile(head<tail){\n\t\tint x=que[++head];\n\t\tint len=V[x].size();\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint y=V[x][i];\n\t\t\tif(vist[y]) continue;\n\t\t\tvist[y]=1;\n\t\t\tMac[y][0]=x;\n\t\t\tint t=indexx[y+n],vv;\n\t\t\twhile(t){\n\t\t\t\tvv=edge[t].v;\n\t\t\t\tif(!edge[t].flw){\n\t\t\t\t\tMac[y][1]=vv;\n\t\t\t\t\tque[++tail]=vv;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt=edge[t].nxt;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(!vist[i]) return -1;\n\t}\n\treturn 1;\n}\nint main(){\n\tint m,x;\n\tscanf(\"%d\",&n);S=n*2,T=n*2+1;\n\tfor(int i=1;i<n;i++){\n\t\tadd(S,i+n,1);\n\t\tscanf(\"%d\",&m);\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tV[x].push_back(i);\n\t\t\tadd(i+n,x,1);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++) add(i,T,1);\n\tint t=Dinic();\n\tif(t!=n-1){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tt=solve();\n\tif(t==-1){\n\t\tprintf(\"-1\");\n\t\treturn 0;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tif(Mac[i][0]>Mac[i][1]) swap(Mac[i][0],Mac[i][1]);\n\t\tprintf(\"%d %d\\n\",Mac[i][0],Mac[i][1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=100010;\nstruct edge{\n\tint y,next,c;\n}s[N<<3];\nstruct op{\n\tint x,y;\n}we[N];\nint first[N<<1],len=0,n,m,bg,nd,c[N<<1],d[N<<1],las[N];\nint lis[N<<1],st,ed;\nvector<int> P[N];\n\nvoid ins(int x,int y){\n\ts[len++]=(edge){y,first[x],1};first[x]=len-1;\n\ts[len++]=(edge){x,first[y],0};first[y]=len-1;\n}\n\nbool bfs(){\n\tlis[st=1]=bg;ed=2;\n\tmemset(d,0,sizeof(d));d[0]=1;\n\twhile(st!=ed){\n\t\tint x=lis[st];st++;\n\t\tfor(int i=first[x];i!=-1;i=s[i].next) if(!d[s[i].y] && s[i].c) \n\t\t\td[s[i].y]=d[x]+1,lis[ed++]=s[i].y;\n\t}\n\treturn d[nd];\n}\n\nint dfs(int x,int t){\n\tif(x==nd) return t;\n\tint tot=0,my;\n\tfor(int i=first[x];i!=-1;i=s[i].next) if(d[s[i].y]==d[x]+1 && s[i].c){\n\t\tmy=dfs(s[i].y,min(t-tot,s[i].c));tot+=my;\n\t\tif(my && x>=1 && x<=n-1 && s[i].y) c[x]=s[i].y-n+2;\n\t\ts[i].c-=my;s[i^1].c+=my;\n\t\tif(t==tot) break;\n\t}\n\tif(!tot) d[x]=0;\n\treturn tot;\n}\n\nint Dinic(){\n\tint dx,ans=0;\n\twhile(bfs()){\n\t\tdx=dfs(bg,1e9);\n\t\twhile(dx) ans+=dx,dx=dfs(bg,1e9);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);bg=0,nd=2*n-1;\n\tint x;\n\tmemset(first,-1,sizeof(first));\n\tfor(int i=1;i<n;i++){\n\t\tins(bg,i);\n\t\tins(i+n-1,nd);\n\t\tscanf(\"%d\",&m);\n\t\twhile(m--){\n\t\t\tscanf(\"%d\",&x);\n\t\t\tP[x].push_back(i);\n\t\t\tif(x-1) ins(i,n-1+x-1);\n\t\t}\n\t}\n\tif(Dinic()==n-1){\n\t\tst=ed=1;\n\t\tfor(int i=0;i<P[1].size();i++) lis[ed++]=P[1][i],las[P[1][i]]=1;\n\t\twhile(st!=ed){\n\t\t\tint x=lis[st];st++;\n\t\t\twe[x]=(op){las[x],c[x]};\n\t\t\tfor(int i=0;i<P[c[x]].size();i++) if(!las[P[c[x]][i]]) lis[ed++]=P[c[x]][i],las[P[c[x]][i]]=c[x];\n\t\t}\n\t\tif(ed==n) for(int i=1;i<n;i++) printf(\"%d %d\\n\",we[i].x,we[i].y);\n\t\telse printf(\"-1\\n\");\n\t}\n\telse printf(\"-1\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\n\nconst int N=1e6+5,M=3e6+5,INF=0x3f3f3f3f;\nint n;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint h[N],le=1;\nint hh[N];\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\nvoid add_bidir_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,v);}\n#define FORe(i,u,v,w)     for(int  i= h[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,u,v,w) for(int &i=hh[u],v,w;v=e[i].t,w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint dep[N];\nqueue<int> q;\n\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    dep[s]=1, q.push(s);\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w) if(!dep[v]&&w)dep[v]=dep[u]+1, q.push(v);\n    }\n    return dep[t]!=0;\n}\nint dfs(int u,int flow){\n    if(u==t||!flow)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(rest,w));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int x;(x=dfs(s,INF));)maxflow+=x;\n    }\n    return maxflow;\n}\n\nvector<int> c[N],g[N];\nvector<pii> ans;\nint p[N],vis[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v:g[u])if(!vis[v]){\n        ans.pb({u,v});\n        dfs(v);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb(p[i]);//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(ans.size()!=n-1)return puts(\"-1\"),0;\n    for(pii x:ans)printf(\"%d %d\\n\",x.fi,x.se);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nusing namespace std;\nconst int N=200005,M=2000005,INF=0X3F3F3F3F;\ntemplate<typename T>void rd(T&x){int f=0,c;while(!isdigit(c=getchar()))f^=!(c^45);x=(c&15);while(isdigit(c=getchar()))x=x*10+(c&15);if(f)x=-x;}\ntemplate<typename T>void pt(T x,int c=-1){if(x<0)putchar('-'),x=-x;if(x>9)pt(x/10);putchar(x%10+48);if(c!=-1)putchar(c);}\nint n,S,T;\nint fa[N],match[N],ans[N][2];\nint dep[N],gap[N];\nint pp=1,lnk[N],cur[N],nxt[M],to[M],we[M];\nvoid ae(int k1,int k2,int k3){\n\tto[++pp]=k2,we[pp]=k3,nxt[pp]=lnk[k1],lnk[k1]=pp;\n\tto[++pp]=k1,we[pp]=0, nxt[pp]=lnk[k2],lnk[k2]=pp;\n}\nvoid bfs(){\n\tmemset(dep,-1,sizeof(dep));\n\tqueue<int>q;\n\tq.push(T);\n\tdep[T]=0;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\t++gap[dep[k1]];\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i])if(dep[to[i]]==-1){\n\t\t\tdep[to[i]]=dep[k1]+1;\n\t\t\tq.push(to[i]);\n\t\t}\n\t}\n}\nint sap(int k1,int k2){\n\tif(k1==T)return k2;\n\tint k3=k2;\n\tfor(int&i=cur[k1];i;i=nxt[i])if(we[i]&&dep[to[i]]+1==dep[k1]){\n\t\tint f=sap(to[i],min(we[i],k2));\n\t\tk3-=f,we[i]-=f,we[i^1]+=f;\n\t\tif(!k3)return k2;\n\t}\n\tif(!--gap[dep[k1]++])dep[S]=T+1;\n\t++gap[dep[k1]],cur[k1]=lnk[k1];\n\treturn k2-k3;\n}\nint main(){\n\trd(n);\n\tS=n+n,T=n+n+1;\n\trep(i,2,n)ae(S,i,1);\n\trep(i,1,n-1){\n\t\tint m;\n\t\trd(m);\n\t\trep(j,1,m){\n\t\t\tint k1;\n\t\t\trd(k1);\n\t\t\tae(k1,i+n,1);\n\t\t}\n\t}\n\trep(i,1,n-1)ae(i+n,T,1);\n\tmemcpy(cur,lnk,sizeof(cur));\n\tbfs();\n\tint res=0;\n\twhile(dep[S]<=T)res+=sap(S,INF);\n\tif(res!=n-1){\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\trep(i,1,n-1){\n\t\tfor(int j=lnk[i+n];j;j=nxt[j])if(to[j]!=T&&we[j]==1){\n\t\t\tmatch[i]=to[j];\n\t\t}\n\t\tassert(match[i]);\n\t}\n\tqueue<int>q;\n\tq.push(1),fa[1]=1;\n\twhile(!q.empty()){\n\t\tint k1=q.front();\n\t\tq.pop();\n\t\tfor(int i=lnk[k1];i;i=nxt[i]){\n\t\t\tint k2=match[to[i]-n];\n\t\t\tif(!fa[k2]){\n\t\t\t\tans[to[i]-n][0]=k1,ans[to[i]-n][1]=k2;\n\t\t\t\tfa[k2]=k1;\n\t\t\t\tq.push(k2);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,1,n-1){\n\t\tprintf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5+5;\n\nint n;\n\ninline void failed(){\n\tputs(\"-1\");\n\texit(0);\n}\n\nvector<int> G[N];\nbool vis[N];\nint match[N];\nint pref[N];\nstack<int> stk;\n\ninline bool dfs(int x){\n\tfor(size_t i=0;i<G[x].size();i++){\n\t\tint v=G[x][i];if(vis[v])continue;\n\t\tvis[v]=1;stk.push(v);\n\t\tif(!pref[v] || dfs(pref[v])){\n\t\t\tmatch[x] = v;\n\t\t\tpref[v] = x;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint s[N];\ntypedef pair<int,int> pi;\nvector<pi> tr;\nint main()\n{\n\tcin >> n;\n\tfor(int i=1;i<n;i++){\n\t\tint c;scanf(\"%d\",&c);\n\t\tfor(int j=1,e;j<=c;j++){\n\t\t\tscanf(\"%d\",&e);\n\t\t\tG[e].push_back(i);\n\t\t}\n\t}\n\tfor(int i=2;i<=n;i++){\n\t\t// cout << i << \":\";\n\t\tif(!dfs(i))failed();\n\t\twhile(stk.size()){\n\t\t\t// cout << stk.top();\n\t\t\tvis[stk.top()]=0;\n\t\t\tstk.pop();\n\t\t}\n\t\t// cout << \"?\" << endl;\n\t}\n\tqueue<int> q;\n\tfor(size_t i=0;i<G[1].size();i++){\n\t\ts[G[1][i]]=1;\n\t\tq.push(G[1][i]);\n\t}\n\twhile(q.size()){\n\t\tint u=q.front();q.pop();\n\t\tint v = pref[u];\n\t\t// cout << u << \":::\" << s[u] << \" \" << v << endl;\n\t\ttr.push_back(pi(v,s[u]));\n\t\tfor(size_t i=0;i<G[v].size();i++){\n\t\t\tif(!s[G[v][i]])s[G[v][i]]=v,q.push(G[v][i]);\n\t\t}\n\t}\n\tif((int)tr.size()<n-1){\n\t\tfailed();\n\t}\n\tfor(size_t i=0;i<tr.size();i++){\n\t\tprintf(\"%d %d\\n\",tr[i].first,tr[i].second);\n\t}\n\treturn 0;\n}\n/* \n10\n5 1 2 3 4 5\n5 2 3 4 5 6\n5 3 4 5 6 7\n5 4 5 6 7 8\n5 5 6 7 8 9\n5 6 7 8 9 10\n5 7 8 9 10 1\n5 8 9 10 1 2\n5 9 10 1 2 3\n */"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+5,M=2e6+5,INF=0x3f3f3f3f;\n\nstruct qxx{int nex,t,v;};\nqxx e[M];\nint hh[M],h[M],le=1;\nvoid add_path(int f,int t,int v){e[++le]=(qxx){h[f],t,v},h[f]=le;}\nvoid add_flow(int f,int t,int v){add_path(f,t,v),add_path(t,f,0);}\n#define FORe(i,_u,_v,_w)     for(int  i= h[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n#define FORflowe(i,_u,_v,_w) for(int &i=hh[_u],_v,_w;_v=e[i].t,_w=e[i].v,i;i=e[i].nex)\n\nint s,t;\nint n;\nint dep[N];\nqueue<int> q;\nbool bfs(){\n    memset(dep,0,sizeof(dep));\n    q.push(s),dep[s]=1;\n    while(!q.empty()){\n        int u=q.front();q.pop();\n        FORe(i,u,v,w)if(w&&!dep[v])dep[v]=dep[u]+1,q.push(v);\n    }\n    return !!dep[t];\n}\nint dfs(int u,int flow){\n    if(u==t)return flow;\n    int rest=flow;\n    FORflowe(i,u,v,w){\n        if(!w||dep[v]!=dep[u]+1)continue;\n        int k=dfs(v,min(w,rest));\n        e[i].v-=k,e[i^1].v+=k,rest-=k;\n        if(!rest)break;\n    }\n    return flow-rest;\n}\nint dinic(){\n    int maxflow=0;\n    while(bfs()){\n        memcpy(hh,h,sizeof(h));\n        for(int i;(i=dfs(s,INF));)maxflow+=i;\n    }\n    return maxflow;\n}\n\nvector<int> c[N];\nvector<pii> g[N];\npii ans[N];\nint p[N],vis[N],use[N],la;\nvoid dfs(int u){\n    vis[u]=1;\n    for(pii v:g[u])if(!vis[v.fi]&&!use[v.se]){\n        use[v.se]=1;\n        ans[v.se]={u,v.fi};\n        ++la;\n        dfs(v.fi);\n    }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    s=0,t=n*2;\n    FOR(i,1,n-1){\n        int k,x;\n        scanf(\"%d\",&k);\n        FOR(j,1,k){\n            scanf(\"%d\",&x);\n            c[i].pb(x);\n            if(x!=1)add_flow(x,i+n,1);//1\n        }\n    }\n    FOR(i,2,n)add_flow(s,i,1);\n    FOR(i,1,n-1)add_flow(i+n,t,1);\n    int tot=dinic();\n    if(tot<n-1)return puts(\"-1\"),0;\n    assert(tot==n-1);\n    FOR(i,2,n){\n        FORe(j,i,v,w)if((j&1)==0&&!w)p[v-n]=i;\n    }\n    //FOR(i,1,n-1)printf(\"p[%d]=%d\\n\",i,p[i]);\n    FOR(i,1,n-1){\n        for(int x:c[i]){\n            if(x!=p[i])g[x].pb({p[i],i});//,g[p[i]].pb(x);\n        }\n    }\n    dfs(1);\n    if(la!=n-1)return puts(\"-1\"),0;\n    FOR(i,1,n-1)printf(\"%d %d\\n\",ans[i].fi,ans[i].se);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 100111, inf = 1000111222;\n\nint n, p[max_n], nxt[max_n], used[max_n], ans[max_n];\nvector<int> g[max_n], g2[max_n];\n\nbool dfs(int v) {\n    if (used[v]) {\n        return false;\n    }\n    used[v] = 1;\n    for (int to : g[v]) {\n        if (p[to] == -1 || dfs(p[to])) {\n            p[to] = v;\n            nxt[v] = to;\n            return true;\n        }\n    }\n    return false;\n}\n\nvoid dfs2(int v) {\n    used[v] = 1;\n    for (int to : g2[v]) {\n        if (used[to] == 0) {\n            dfs2(to);\n            ans[to] = nxt[v];\n        }\n    }\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    scanf(\"%d\", &n);\n    for (int i = 0; i + 1 < n; ++i) {\n        int k;\n        scanf(\"%d\", &k);\n        g[i].resize(k);\n        for (int &x : g[i]) {\n            scanf(\"%d\", &x);\n            --x;\n        }\n    }\n    memset(nxt, -1, sizeof(nxt));\n    memset(p, -1, sizeof(p));\n    for (int run = 1; run; ) {\n        run = 0;\n        memset(used, 0, sizeof(used));\n        for (int i = 0; i + 1 < n; ++i) {\n            if (nxt[i] == -1 && dfs(i)) {\n                run = 1;\n            }\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        if (nxt[i] == -1) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    int root;\n    for (int i = 0; i < n; ++i) {\n        if (p[i] == -1) {\n            root = i;\n            break;\n        }\n    }\n    p[root] = n - 1;\n    nxt[n - 1] = root;\n    for (int i = 0; i + 1 < n; ++i) {\n        for (int to : g[i]) {\n            if (to != nxt[i]) {\n                g2[p[to]].push_back(i);\n            }\n        }\n    }\n    memset(used, 0, sizeof(used));\n    dfs2(n - 1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            puts(\"-1\");\n            return 0;\n        }\n    }\n    for (int i = 0; i + 1 < n; ++i) {\n        printf(\"%d %d\\n\", nxt[i] + 1, ans[i] + 1);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b)for(int i=a,_e=b;i<=_e;++i)\nusing namespace std;\nconst int N=1e5+5;\nint n,T,c,a,ans,u[N],v[N];\nint la[N*2],st[N*2],ne[N*8],to[N*8],l[N*8],h[N*2],d[N*2],js;\nbool bz[N*2];\nvector<int>e[N*2];\nvoid link(int x,int y){\n\tne[++js]=la[x];la[x]=js;to[js]=y;l[js]=1;\n\tne[++js]=la[y];la[y]=js;to[js]=x;\n}\nbool get(){\n\tfo(i,0,T)st[i]=la[i],h[i]=-1;\n\th[0]=0;d[1]=0;\n\tfor(int s=0,t=1,x;x=d[++s],s<=t;)\n\t\tfor(int i=la[x];i;i=ne[i])if(l[i]&&h[to[i]]==-1)\n\t\t\th[to[i]]=h[x]+1,d[++t]=to[i];\n\treturn h[T]>-1;\n}\nint dinic(int x,int su){\n\tif(x==T)return su;int us=0;\n\tfor(int i=st[x];i;i=ne[i])\n\t\tif(l[i]&&h[to[i]]==h[x]+1){\n\t\t\tint tt=dinic(to[i],min(su-us,l[i]));\n\t\t\tif(tt){\n\t\t\t\tl[i]-=tt;l[i^1]+=tt;us+=tt;\n\t\t\t\tif(us==su)return us;\n\t\t\t}\n\t\t\tst[x]=i;\n\t\t}\n\th[x]=-1;\n\treturn us;\n}\nvoid dfs(int x){\n\tbz[x]=1;\n\tif(x<=n){\n\t\tfor(int i:e[x])if(!bz[i])u[i-n]=x,dfs(i);\n\t}else{\n\t\tif(!bz[v[x-n]])dfs(v[x-n]);\n\t}\n}\nbool ck(){\n\tfo(i,1,n*2-1)if(!bz[i])return 0;\n\treturn 1;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin>>n;js=1;\n\tT=n+n+1;\n\tfo(i,1,n-1){\n\t\tcin>>c;\n\t\tlink(0,i);\n\t\tfo(j,1,c){\n\t\t\tcin>>a;\n\t\t\tif(a!=1)link(i,n+a);\n\t\t\te[a].push_back(n+i);\n\t\t\te[n+i].push_back(a);\n\t\t}\n\t}\n\tfo(i,2,n)link(n+i,T);\n\tfor(;get();)ans+=dinic(0,n);\n\tif(ans==n-1){\n\t\tfo(i,1,n-1)for(int j=la[i];j;j=ne[j])if(!l[j])v[i]=to[j]-n;\n\t\tdfs(1);\n\t\tif(ck()){\n\t\t\tfo(i,1,n-1)printf(\"%d %d\\n\",u[i],v[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<-1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; (i) < (int) (n); (i) ++)\nusing namespace std;\n\nint V;\nvector<int> g[101010];\nint match[101010];\nbool used[101010];\nvoid add_edge(int v, int u) {\n        g[v].push_back(u);\n        g[u].push_back(v);\n}\nbool dfs(int v) {\n        used[v] = true;\n        for (auto u : g[v]) {\n                int w = match[u];\n                if (w < 0 || (!used[w] && dfs(w))) {\n                        match[v] = u;\n                        match[u] = v;\n                        return true;\n                }\n        }\n        return false;\n}\nint BipartiteMatching() {\n        int res = 0;\n        memset(match, -1, sizeof match);\n        for (int v = 0; v < V; v ++) {\n                if (match[v] < 0) {\n                        memset(used, 0, sizeof used);\n                        if (dfs(v)) {\n                                res ++;\n                        }\n                }\n        }\n        return res;\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> es(n - 1), unko(n);\n        V = n * 2;\n        rep(i, n - 1) {\n                int c;\n                scanf(\"%d\", &c);\n                rep(j, c) {\n                        int u;\n                        scanf(\"%d\", &u);\n                        u --;\n                        es[i].push_back(u);\n                        unko[u].push_back(i);\n                        if (u) add_edge(i, u + n);\n                }\n        }\n        int cnt = BipartiteMatching();\n        if (cnt != n - 1) {\n                printf(\"-1\\n\");\n                return 0;\n        }\n        queue<int> que;\n        que.push(0);\n        vector<pair<int, int>> ans(n - 1);\n        while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                for (auto en : unko[u]) if (!used[en]) {\n                        used[en] = true;\n                        ans[en] = make_pair(match[en] - n, u);\n                        que.push(match[en] - n);\n                }\n        }\n        rep(i, n - 1) {\n                printf(\"%d %d\\n\", ans[i].first + 1, ans[i].second + 1);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iostream>\n#include <limits>\n#include <numeric>\n#include <type_traits>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i,n,m) for(ll (i)=(n);(i)<(m);(i)++)\n#define rrep(i,n,m) for(ll (i)=(n);(i)>(m);(i)--)\nusing ll = int;\nconst ll mod = 998244353;\n\n\n#include <list>\nconst ll inf = INT_MAX; //changeable \nll Dinic_DFS(ll v,ll g,ll maxflow,vector<set<ll>>& lines, vector<map<ll,ll>>& cost,vector<ll>& level,vector<ll>& cap){\n\n    if (v == g) return maxflow;\n    cap[v] = 0;\n\n    ll realflow = 0;\n    vector<ll> tmp(0);\n    for ( ll tmpv : lines[v] ) tmp.push_back(tmpv);\n\n    for ( ll nex : tmp ){\n        if (level[nex] > level[v] && (cap[nex] == 1)){\n            ll plusflow = Dinic_DFS(nex,g,min(maxflow,cost[v][nex]),lines,cost,level,cap);\n            cost[v][nex] -= plusflow;\n            if (cost[v][nex] == 0) lines[v].erase(nex);\n            if (cost[nex][v] == 0) lines[nex].insert(v);\n            cost[nex][v] += plusflow;\n\n            realflow += plusflow;\n            maxflow -= plusflow;\n\n            if (maxflow <= 0) return realflow;\n        }\n    }\n\n    return realflow;\n}\n\nll Dinic(ll s,ll g,vector<set<ll>>& lines, vector<map<ll,ll>>& cost){\n\n    ll N = cost.size();\n    ll ans = 0;\n    vector<ll> level(N,inf);\n\n    while (true){\n\n        //bfs\n        list<ll> q;\n        q.push_back(s);\n        rep(i,0,N) level[i] = inf;\n        level[s] = 0;\n        while (!q.empty()){\n            ll now = q.front();\n            q.pop_front();\n            for ( ll nex : lines[now] ){\n                if (level[nex] > level[now] + 1){\n                    level[nex] = level[now] + 1;\n                    q.push_back(nex);\n                }\n            }\n        }\n\n        if (level[g] == inf){\n            return ans;\n        }\n\n        //dfs\n        vector<ll> cap(N,1);\n        ll delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        while (delta_flow > 0){\n            ans += delta_flow;\n            delta_flow = Dinic_DFS(s,g,inf,lines,cost,level,cap);\n        }\n\n    }\n}\n\nint main(){\n\n    ll N;\n    scanf (\"%d\" , &N);\n    vector<vector<ll>> w(N-1,vector<ll> (0));\n    vector<vector<ll>> vtoc(N,vector<ll> (0));\n\n    rep(loop,0,N-1){\n        ll c,wtmp;\n        scanf (\"%d\" , &c);\n        rep(i,0,c){\n            scanf (\"%d\" , &wtmp);\n            wtmp--;\n            w[loop].push_back(wtmp);\n            vtoc[wtmp].push_back(loop);\n        }\n    }\n\n    vector<set<ll>> lines(2*N);\n    vector<map<ll,ll>> cost(2*N);\n\n    rep(i,1,N){\n        lines[0].insert(i);\n        cost[0][i] = 1;\n    }\n    rep(i,N+1,2*N){\n        lines[i].insert(N);\n        cost[i][N] = 1;\n    }\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0){\n                lines[i+1].insert(N+j);\n                cost[i+1][N+j] = 1;\n            }\n        }\n    }\n\n    ll flow = Dinic(0,N,lines,cost);\n    if (flow != N-1){\n        cout << -1 << endl;\n        return 0;\n    }\n\n    vector<ll> newv(N-1,-1);\n    rep(i,0,N-1){\n        for(ll j : w[i]){\n            if (j != 0 && cost[i+1][N+j] == 0){\n                newv[i] = j;\n                break;\n            }\n        }\n    }\n\n    vector<ll> end(N,0);\n    list<ll> q;\n    q.push_back(0);\n    vector<vector<ll>> ans(N-1,vector<ll> (2,-1));\n\n    while (!q.empty()){\n\n        ll nv = q.front();\n        q.pop_front();\n\n        for (ll c : vtoc[nv]){\n            if (end[newv[c]] == 0){\n                ans[c] = {nv+1,newv[c]+1};\n                end[newv[c]] = 1;\n                q.push_back(newv[c]);\n            }\n        }\n    }\n\n    ll ttf = 1;\n    rep(i,0,N-1){\n        if (ans[i][0] < 0) ttf = 0;\n    }\n\n    if (ttf){\n        rep(i,0,N-1){\n            printf (\"%d %d\\n\",ans[i][0],ans[i][1]);\n        }\n    }else{\n        cout << -1 << endl;\n    }\n\n    /* verify\n    ll V,E;\n    cin >> V >> E;\n\n    vector<set<ll>> lines (V);\n    vector<map<ll,ll>> cost (V);\n\n    rep (i,0,E){\n        ll u,v,c;\n        cin >> u >> v >> c;\n        if (c != 0){\n            lines[u].insert(v);\n            cost[u][v] += c;\n        }\n    }\n\n    cout << Dinic(0,V-1,lines,cost) << endl;\n    */\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ui unsigned int\n#define ll long long\n#define db double\n#define ld long double\n#define ull unsigned long long\n#define ft first\n#define sd second\n#define pb(a) push_back(a)\n#define PII std::pair<int,int>\n#define PLL std::pair<ll,ll>\n#define mp(a,b) std::make_pair(a,b)\n#define ITR(a,b) for(auto a:b)\n#define REP(a,b,c) for(register int a=(b),a##end=(c);a<=a##end;++a)\n#define DEP(a,b,c) for(register int a=(b),a##end=(c);a>=a##end;--a)\nconst int MAXN=200000+10,inf=0x3f3f3f3f;\nint n,e=1,beg[MAXN<<1],cur[MAXN<<1],s,t,nex[MAXN<<2],to[MAXN<<2],out[MAXN<<2],cap[MAXN<<2],vis[MAXN<<1],level[MAXN<<1],mh[MAXN],clk;\nPII side[MAXN];\nstd::queue<int> q;\nstd::vector<int> V[MAXN];\ntemplate<typename T> inline void read(T &x)\n{\n\tT data=0,w=1;\n\tchar ch=0;\n\twhile(ch!='-'&&(ch<'0'||ch>'9'))ch=getchar();\n\tif(ch=='-')w=-1,ch=getchar();\n\twhile(ch>='0'&&ch<='9')data=((T)data<<3)+((T)data<<1)+(ch^'0'),ch=getchar();\n\tx=data*w;\n}\ntemplate<typename T> inline void write(T x,char ch='\\0')\n{\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);\n\tputchar(x%10+'0');\n\tif(ch!='\\0')putchar(ch);\n}\ntemplate<typename T> inline bool chkmin(T &x,T y){return y<x?(x=y,true):false;}\ntemplate<typename T> inline bool chkmax(T &x,T y){return y>x?(x=y,true):false;}\ntemplate<typename T> inline T min(T x,T y){return x<y?x:y;}\ntemplate<typename T> inline T max(T x,T y){return x>y?x:y;}\ninline void insert(int x,int y,int z)\n{\n\tto[++e]=y;\n\tnex[e]=beg[x];\n\tbeg[x]=e;\n\tout[e]=x;\n\tcap[e]=z;\n\tto[++e]=x;\n\tnex[e]=beg[y];\n\tbeg[y]=e;\n\tout[e]=y;\n\tcap[e]=0;\n}\ninline bool bfs()\n{\n\tmemset(level,0,sizeof(level));\n\tlevel[s]=1;\n\tq.push(s);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();\n\t\tfor(register int i=beg[x];i;i=nex[i])\n\t\t\tif(cap[i]&&!level[to[i]])level[to[i]]=level[x]+1,q.push(to[i]);\n\t}\n\treturn level[t];\n}\ninline int dfs(int x,int maxflow)\n{\n\tif(x==t||!maxflow)return maxflow;\n\tint res=0;\n\tvis[x]=clk;\n\tfor(register int i=beg[x];i;i=nex[i])\n\t\tif((vis[x]^vis[to[i]])&&cap[i]&&level[to[i]]==level[x]+1)\n\t\t{\n\t\t\tint f=dfs(to[i],min(cap[i],maxflow));\n\t\t\tres+=f;\n\t\t\tcap[i]-=f;\n\t\t\tcap[i^1]+=f;\n\t\t\tmaxflow-=f;\n\t\t\tif(!maxflow)break;\n\t\t}\n\treturn res;\n}\ninline int Dinic()\n{\n\tint res=0;\n\twhile(bfs())clk++,memcpy(cur,beg,sizeof(cur)),res+=dfs(s,inf);\n\treturn res;\n}\ninline bool solve()\n{\n\tint cnt=0;\n\tq.push(1);\n\tREP(i,1,n-1)vis[i]=0;\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();\n\t\tq.pop();cnt++;\n\t\tITR(v,V[x])if(!vis[v])\n\t\t\tside[v]=mp(mh[v],x),vis[v]=1,q.push(mh[v]);\n\t}\n\treturn cnt==n;\n}\nint main()\n{\n\tread(n);s=n+n;t=s+1;\n\tREP(i,2,n)insert(s,i,1);\n\tREP(i,1,n-1)\n\t{\n\t\tint k,x;read(k);\n\t\tREP(j,1,k)\n\t\t{\n\t\t\tread(x);\n\t\t\tV[x].pb(i);\n\t\t\tif(x!=1)insert(x,i+n,1);\n\t\t}\n\t\tinsert(i+n,t,1);\n\t}\n\tif(Dinic()!=n-1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,2,e)\n\t{\n\t\tif(out[i]>to[i]||cap[i]||out[i]==s||to[i]==t||out[i]==t||to[i]==s)continue;\n\t\tmh[to[i]-n]=out[i];\n\t}\n\tif(!solve())\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tREP(i,1,n-1)printf(\"%d %d\\n\",side[i].ft,side[i].sd);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..: :::::::-`        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--) \n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) { \n\tscanf(\"%c\", &x); \n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tT floor_mod(T a, T b) {\n\t\tif (a % b == 0) return 0;\n\t\tif (a >= 0 && b >= 0) return a % b;\n\t\tif (a <= 0 && b <= 0) return a % b;\n\t\treturn abs(b) - (abs(a) % abs(b));\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\n\nint n;\nvector<vector<int>> g;\nvector<int> rez;\nvector<int> sc;\nvector<bool> used;\n\nbool ktun(int v) {\n\tused[v] = true;\n\tfor (int sub : g[v]) {\n\t\tif (rez[sub] == -1) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\tfor (int sub : g[v]) {\n\t\tif (used[rez[sub]]) continue;\n\t\tif (ktun(rez[sub])) {\n\t\t\trez[sub] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\t\n\tg.resize(n);\n\trez.resize(n - 1, -1);\n\tsc.resize(n - 1, -1);\n\tf(i, n - 1) {\n\t\tint k;\n\t\tscan k;\n\t\tf(j, k) {\n\t\t\tint x;\n\t\t\tscan x;\n\t\t\tx--;\n\t\t\tg[x].pb(i);\n\t\t}\n\t}\n\tused = vector<bool>(n, false);\n\tf(i, n) {\n\t\tif (ktun(i)) {\n\t\t\tused = vector<bool>(n, false);\n\t\t}\n\t}\n\tset<int> all;\n\tf(i, n) {\n\t\tall.insert(i);\n\t}\n\tvector<int> id(n);\n\tfor (int i = 0; i < n - 1; i++) {\n\t\tif (rez[i] == -1) {\n\t\t\tprint -1;\n\t\t\treturn 0;\n\t\t}\n\t\tid[rez[i]] = i;\n\t\tall.erase(rez[i]);\n\t}\n\tused = vector<bool>(n, false);\n\tdeque<int> deq{*all.begin()};\n\tused[deq[0]] = true;\n\twhile (!deq.empty()) {\n\t\tint v = deq[0];\n\t\tdeq.pop_front();\n\t\tfor (int sub : g[v]) {\n\t\t\tif (used[rez[sub]]) continue;\n\t\t\tused[rez[sub]] = true;\n\t\t\tsc[sub] = v;\n\t\t\tdeq.pb(rez[sub]);\n\t\t}\n\t}\n\tif (used != vector<bool>(n, true)) {\n\t\tprint -1;\n\t\treturn 0;\n\t}\n\tf(i, n - 1) {\n\t\tprint rez[i] + 1, sc[i] + 1;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define llong long long\n#define mkpr make_pair\n#define riterator reverse_iterator\n#define pii pair<int,int>\nusing namespace std;\n\ninline int read()\n{\n\tint x = 0,f = 1; char ch = getchar();\n\tfor(;!isdigit(ch);ch=getchar()) {if(ch=='-') f = -1;}\n\tfor(; isdigit(ch);ch=getchar()) {x = x*10+ch-48;}\n\treturn x*f;\n}\n\nconst int INF = 1e7;\n\nnamespace NetFlow\n{\n\tconst int N = 2e5+2;\n\tconst int M = 4e5;\n\tstruct Edge\n\t{\n\t\tint v,w,nxt,rev;\n\t} e[(M<<1)+3];\n\tint fe[N+3];\n\tint te[N+3];\n\tint dep[N+3];\n\tint que[N+3];\n\tint n,en,s,t;\n\tvoid addedge(int u,int v,int w)\n\t{\n\t\ten++; e[en].v = v; e[en].w = w;\n\t\te[en].nxt = fe[u]; fe[u] = en; e[en].rev = en+1;\n\t\ten++; e[en].v = u; e[en].w = 0;\n\t\te[en].nxt = fe[v]; fe[v] = en; e[en].rev = en-1;\n\t}\n\tbool bfs()\n\t{\n\t\tfor(int i=1; i<=n; i++) dep[i] = 0;\n\t\tint head = 1,tail = 1; que[1] = s; dep[s] = 1;\n\t\twhile(head<=tail)\n\t\t{\n\t\t\tint u = que[head]; head++;\n\t\t\tfor(int i=fe[u]; i; i=e[i].nxt)\n\t\t\t{\n\t\t\t\tint v = e[i].v;\n\t\t\t\tif(e[i].w>0 && dep[v]==0)\n\t\t\t\t{\n\t\t\t\t\tdep[v] = dep[u]+1;\n\t\t\t\t\tif(v==t) return true;\n\t\t\t\t\ttail++; que[tail] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint dfs(int u,int cur)\n\t{\n\t\tif(u==t||cur==0) {return cur;}\n\t\tint rst = cur;\n\t\tfor(int &i=te[u]; i; i=e[i].nxt)\n\t\t{\n\t\t\tint v = e[i].v;\n\t\t\tif(e[i].w>0 && rst>0 && dep[v]==dep[u]+1)\n\t\t\t{\n\t\t\t\tint flow = dfs(v,min(rst,e[i].w));\n\t\t\t\tif(flow>0)\n\t\t\t\t{\n\t\t\t\t\te[i].w -= flow;\t\n\t\t\t\t\trst -= flow;\n\t\t\t\t\te[e[i].rev].w += flow;\n\t\t\t\t\tif(rst==0) {return cur;}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(rst==cur) {dep[u] = -2;}\n\t\treturn cur-rst;\n\t}\n\tint dinic(int _n,int _s,int _t)\n\t{\n\t\tn = _n,s = _s,t = _t;\n\t\tint ret = 0;\n\t\twhile(bfs())\n\t\t{\n\t\t\tfor(int i=1; i<=n; i++) te[i] = fe[i];\n\t\t\tmemcpy(te,fe,sizeof(int)*(n+1));\n\t\t\tret += dfs(s,INF);\n\t\t}\n\t\treturn ret;\n\t}\n}\nusing NetFlow::addedge;\nusing NetFlow::dinic;\n\nconst int N = 1e5;\nvector<int> adj[(N<<1)+3];\nvector<pair<int,pii> > ans;\nint mch[(N<<1)+3];\nbool vis[(N<<1)+3];\nint que[N+3];\nint n;\n\nbool bfs()\n{\n\tint hd = 1,tl = 1; que[1] = 1; vis[1] = true;\n\twhile(hd<=tl)\n\t{\n\t\tint u = que[hd]; hd++;\n\t\tfor(int o=0; o<adj[u].size(); o++)\n\t\t{\n\t\t\tint v = adj[u][o]; if(vis[v]) continue;\n\t\t\tif(vis[mch[v]]) continue;\n\t\t\tque[++tl] = mch[v]; vis[v] = vis[mch[v]] = true;\n\t\t\tans.push_back(mkpr(v,mkpr(u,mch[v])));\n\t\t}\n\t}\n\tif(tl<n) {return false;}\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++) addedge(1,i+2,1);\n\tfor(int i=n+1; i<n+n; i++) addedge(i+2,2,1);\n\tfor(int i=1; i<n; i++)\n\t{\n\t\tint sz; scanf(\"%d\",&sz);\n\t\twhile(sz--)\n\t\t{\n\t\t\tint x; scanf(\"%d\",&x); adj[i+n].push_back(x); adj[x].push_back(i+n);\n\t\t\tif(x!=1) {addedge(x+2,i+n+2,1);}\n\t\t}\n\t}\n\tif(dinic(n+n+1,1,2)<n-1) {puts(\"-1\"); return 0;}\n\tfor(int u=3; u<=n+2; u++)\n\t{\n\t\tfor(int i=NetFlow::fe[u]; i; i=NetFlow::e[i].nxt)\n\t\t{\n\t\t\tint v = NetFlow::e[i].v; if(v<=n+2) continue;\n\t\t\tif(NetFlow::e[i].w==0)\n\t\t\t{\n\t\t\t\tmch[u-2] = v-2,mch[v-2] = u-2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n//\tprintf(\"match: \"); for(int i=1; i<=n+n-1; i++) printf(\"%d \",mch[i]); puts(\"\");\n\tif(!bfs()) {puts(\"-1\"); assert(0); return 0;}\n\tsort(ans.begin(),ans.end());\n\tfor(int i=0; i<ans.size(); i++) printf(\"%d %d\\n\",ans[i].second.first,ans[i].second.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<functional>\n#include<algorithm>\n#include<iterator>\n#include<cstring>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nstruct R{int v,z,c;}e[1111111];\nint K[222222],cur[222222],ce=1;\nvoid ins(int a,int b,int c)\n{\n\te[++ce]=(R){b,K[a],c};\n\tK[a]=ce;\n}\nvoid AE(int a,int b)\n{\n\tins(a,b,1);\n\tins(b,a,0);\n}\nint s,t,d[222222];\nbool BFS()\n{\n\tstatic int q[222222],du,my;\n\tmemset(d,0,sizeof(d));\n\tmemcpy(cur,K,sizeof(cur));\n\tfor(d[q[du=my=1]=s]=1;du<=my;)\n\t{\n\t\tint u=q[du++];\n\t\tfor(int i=K[u];i;i=e[i].z)if(e[i].c&&!d[e[i].v])\n\t\t{\n\t\t\td[e[i].v]=d[u]+1;\n\t\t\tq[++my]=e[i].v;\n\t\t}\n\t}\n\treturn d[t];\n}\nint DFS(int u,int r)\n{\n\tif(u==t)return r;\n\tint tmp=r;\n\tfor(int&i=cur[u];i;i=e[i].z)if(e[i].c&&d[e[i].v]==d[u]+1)\n\t{\n\t\tint qwq=DFS(e[i].v,min(r,e[i].c));\n\t\tif(qwq)\n\t\t{\n\t\t\tr-=qwq;\n\t\t\te[i].c-=qwq;\n\t\t\te[i^1].c+=qwq;\n\t\t\tif(!r)return tmp;\n\t\t}\n\t}\n\treturn tmp-r;\n}\nint Dinic()\n{\n\tint r=0;\n\tfor(;BFS();)r+=DFS(s,2333333);\n\treturn r;\n}\nbool viz[222222];\nint n,p[111111];\nvoid dfs(int u,int pa,int gp)\n{\n\tviz[u]=1;\n\tif(u<=n)p[u]=gp;\n\tfor(int i=K[u];i;i=e[i].z)if(!viz[e[i].v]&&e[i].c)\n\t\tdfs(e[i].v,u,pa);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\ts=2*n;\n\tt=2*n+1;\n\tfor(int i=2;i<=n;++i)AE(s,i);\n\tfor(int i=1;i<n;++i)\n\t{\n\t\tint c;\n\t\tfor(scanf(\"%d\",&c);c--;)\n\t\t{\n\t\t\tint v;\n\t\t\tscanf(\"%d\",&v);\n\t\t\tAE(v,i+n);\n\t\t}\n\t\tAE(i+n,t);\n\t}\n\tviz[s]=viz[t]=1;\n\tif(Dinic()!=n-1)return puts(\"-1\"),0;\n\tdfs(1,0,0);\n\tfor(int i=2;i<=n;++i)if(!p[i])return puts(\"-1\"),0;\n\tfor(int i=2;i<=n;++i)printf(\"%d %d\\n\",p[i],i);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#define MN 101000\n#define MM 801000\n\nint h[MN], nxt[MM], to[MM], cap[MM], K = 1;\nint iter[MN], d[MN], q[MN], hh = 0, tt = 0;\nstd::vector<int> B[MN];\nint x[MN], y[MN], o = 0;\nbool used[MN]; int mat[MN];\n\nvoid ins(int u, int v, int c) {nxt[++K] = h[u]; h[u] = K; to[K] = v; cap[K] = c;}\nvoid insw(int u, int v, int c) {ins(u, v, c); ins(v, u, 0);}\n\nbool bfs(int S, int T)\n{\n\tmemset(d, 0, sizeof(d));\n\thh = tt = 0; d[S] = 1; q[tt++] = S;\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = h[u]; i; i = nxt[i])\n\t\t\tif(cap[i] && !d[to[i]])\n\t\t\t{\n\t\t\t\td[to[i]] = d[u] + 1;\n\t\t\t\tif(to[i] == T) return 1;\n\t\t\t\tq[tt++] = to[i];\n\t\t\t}\n\t}\n\treturn 0;\n}\n\nint dfs(int u, int T, int f)\n{\n\tif(u == T) return f;\n\tint used = 0;\n\tfor(int &i = iter[u]; i; i = nxt[i])\n\t\tif(cap[i] && d[to[i]] == d[u] + 1)\n\t\t{\n\t\t\tint w = dfs(to[i], T, std::min(f - used, cap[i]));\n\t\t\tif(w)\n\t\t\t{\n\t\t\t\tcap[i] -= w; cap[i ^ 1] += w; used += w; \n\t\t\t\tif(used == f) return f;\n\t\t\t}\n\t\t}\n\treturn used;\n}\n\nint dinic(int S, int T)\n{\n\tint flow = 0;\n\twhile(bfs(S, T))\n\t{\n\t\tmemcpy(iter, h, sizeof(h));\n\t\tint f;\n\t\twhile(f = dfs(S, T, 1e9)) flow += f;\n\t}\n\treturn flow;\n}\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\tint S = 2 * n, T = S + 1; \n\tfor(int i = 1; i < n; i++)\n\t{\n\t\tint o; scanf(\"%d\", &o);\n\t\tfor(int j = 1; j <= o; j++) \n\t\t{\n\t\t\tint k; scanf(\"%d\", &k);\n\t\t\tB[k].push_back(i);\n\t\t\tinsw(i, n - 1 + k, 1); \n\t\t}\n\t\tinsw(S, i, 1);\n\t}\n\tfor(int i = n; i < 2 * n; i++) insw(i, T, 1);\n\tif(dinic(S, T) != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = h[i]; j; j = nxt[j])\n\t\t\tif(!cap[j] && n <= to[j] && to[j] < 2 * n) mat[i] = to[j] - n + 1;\n\tfor(int i = 1; i < n; i++) used[mat[i]] = 1;\n\thh = tt = 0;\n\tfor(int i = 1; i <= n; i++) if(!used[i]) q[tt++] = i;\n\tmemset(used, 0, sizeof(used));\n\twhile(hh < tt)\n\t{\n\t\tint u = q[hh++];\n\t\tfor(int i = 0; i < B[u].size(); i++)\n\t\t{\n\t\t\tif(!used[B[u][i]]) \n\t\t\t{\n\t\t\t\tused[B[u][i]] = 1;\n\t\t\t\t++o; x[o] = mat[B[u][i]]; y[o] = u;\n\t\t\t\tq[tt++] = mat[B[u][i]];\n\t\t\t}\n\t\t}\n\t}\n\tif(o != n - 1) return 0 * puts(\"-1\");\n\tfor(int i = 1; i <= o; i++) printf(\"%d %d\\n\", x[i], y[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define N_ 201000\n#define M_ 2010000\n#define INF 99999999\nusing namespace std;\nstruct Edge {\n\tint b, e, f;\n};\nclass MaxFlow {\npublic:\n\tEdge E[M_ * 2];\n\tvector<int>G[N_];\n\tint Level[N_], Q[N_], PV[N_], source, sink, n, EC;\n\tlong long flow;\n\tvoid init(int N, int S, int T) {\n\t\tn = N, flow = EC = 0;\n\t\tfor (int i = 0; i <= n; i++)G[i].clear();\n\t\tsource = S, sink = T;\n\t}\n\tvoid Add_Edge(int a, int b, int f) {\n\t\tG[a].push_back(EC);\n\t\tG[b].push_back(EC + 1);\n\t\tE[EC++] = { a,b,f };\n\t\tE[EC++] = { b,a,0 };\n\t}\n\tbool GetLevel() {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++)Level[i] = -1;\n\t\tint head = 0, tail = 0;\n\t\tQ[++tail] = source, Level[source] = 0;\n\t\twhile (head < tail) {\n\t\t\tint x = Q[++head];\n\t\t\tfor (auto &y : G[x]) {\n\t\t\t\tif (E[y].f && Level[E[y].e] == -1) {\n\t\t\t\t\tQ[++tail] = E[y].e;\n\t\t\t\t\tLevel[E[y].e] = Level[x] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn Level[sink] != -1;\n\t}\n\tint BlockFlow(int a, int f) {\n\t\tif (a == sink)return f;\n\t\tfor (int &i = PV[a]; i >= 0; i--) {\n\t\t\tint x = G[a][i];\n\t\t\tif (E[x].f && Level[E[x].e] == Level[a] + 1) {\n\t\t\t\tint t = BlockFlow(E[x].e, min(f, E[x].f));\n\t\t\t\tif (t) {\n\t\t\t\t\tE[x].f -= t;\n\t\t\t\t\tE[x ^ 1].f += t;\n\t\t\t\t\treturn t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tvoid Dinic() {\n\t\tint t;\n\t\twhile (GetLevel()) {\n\t\t\tfor (int i = 1; i <= n; i++)PV[i] = G[i].size() - 1;\n\t\t\twhile (t = BlockFlow(source, INF)) flow += t;\n\t\t}\n\t}\n}G1;\nint n, Deg[N_], vis[N_], UF[N_], vv[N_], Res[N_][2];\nint Find(int a) {\n\tif (a == UF[a])return a;\n\treturn UF[a] = Find(UF[a]);\n}\nvector<int>A[N_], B[N_];\nstruct point {\n\tint d, num;\n\tbool operator < (const point &p)const {\n\t\treturn d < p.d;\n\t}\n}w[N_];\nvoid Merge(int a, int b) {\n\ta = Find(a), b = Find(b);\n\tUF[a] = b;\n}\nint main() {\n\tint i, j, c, a;\n\tscanf(\"%d\", &n);\n\tG1.init(n + n + 1, n + n, n + n + 1);\n\tfor (i = 1; i < n; i++) {\n\t\tG1.Add_Edge(G1.source, i, n);\n\t\tscanf(\"%d\", &c);\n\t\tfor (j = 1; j <= c; j++) {\n\t\t\tscanf(\"%d\", &a);\n\t\t\tG1.Add_Edge(i, n - 1 + a, INF);\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)G1.Add_Edge(n - 1 + i, G1.sink, n - 1);\n\tG1.Dinic();\n\tif (G1.flow != 1ll * n*(n - 1)) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (i = 1; i < n; i++) {\n\t\tfor (auto &t : G1.G[i]) {\n\t\t\tEdge tp = G1.E[t^1];\n\t\t\tif (tp.b >= n && tp.b < n + n && tp.f) {\n\t\t\t\tA[i].push_back(tp.b - (n - 1));\n\t\t\t\tDeg[i]++;\n\t\t\t\tB[tp.b - (n - 1)].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 1; i <= n; i++)UF[i] = i;\n\tfor (i = 1; i < n; i++) {\n\t\tw[i] = { Deg[i],i };\n\t}\n\tsort(w + 1, w + n);\n\tint s = 0;\n\tfor (i = 1; i < n; i++) {\n\t\tint a = w[i].num, c = 0, u[4];\n\t\tif (vis[a])continue;\n\t\tfor (auto &t : A[a]) {\n\t\t\tif (!vv[Find(t)]) {\n\t\t\t\tvv[Find(t)] = 1;\n\t\t\t\tu[c++] = t;\n\t\t\t\tif (c >= 2)break;\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < c; j++)vv[Find(u[j])] = 0;\n\t\ts++;\n\t\tvis[a] = 1;\n\t\tRes[a][0] = u[0], Res[a][1] = u[1];\n\t\tMerge(u[0], u[1]);\n\t}\n\tfor (i = 1; i < n; i++)printf(\"%d %d\\n\", Res[i][0], Res[i][1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <stdlib.h>\n#include <time.h>\nusing namespace std;\n\nvector<int> G[100100];\nint N,P[100100],C[100100],R[100100],X[100100],Y[100100];\nint W[100100];\n\nint find(int x)\n{\n\tint &a = P[x];\n\tif (a != x) a = find(a);\n\treturn a;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tif (N == 2){\n\t\tputs(\"1 2\");\n\t\treturn 0;\n\t}\n\n\tvector<pair<int, int> > v;\n\tfor (int i=0;i<N-1;i++){\n\t\tint s; scanf (\"%d\",&s);\n\t\twhile (s--){\n\t\t\tint x; scanf (\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t\tW[x]++;\n\t\t}\n\t\tv.push_back({G[i].size(),i});\n\t}\n\tsort(v.begin(),v.end());\n\n\tfor (int i=1;i<=N;i++){\n\t\tif (W[i] == 0){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor (int i=0;i<N-1;i++){\n\t\tint c = 0;\n\t\tfor (int x : G[i]) if (W[x] == 1) c++;\n\t\tif (c >= 2){\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsrand(time(NULL));\n\tfor (int t=0;t<1000;t++){\n\t\tbool g = 1;\n\t\tfor (int i=1;i<=N;i++) C[i] = -1, P[i] = i;\n\t\tfor (auto &p : v){\n\t\t\tint i = p.second, c = 0;\n\t\t\tfor (auto x : G[i]){\n\t\t\t\tint u = find(x);\n\t\t\t\tif (C[u] == i) continue;\n\t\t\t\tR[c++] = x;\n\t\t\t\tC[u] = i;\n\t\t\t}\n\t\t\tif (c >= 2){\n\t\t\t\tint a = rand() % c;\n\t\t\t\tint b = rand() % (c-1);\n\t\t\t\tif (b >= a) b++;\n\t\t\t\tX[i] = R[a];\n\t\t\t\tY[i] = R[b];\n\t\t\t\tP[find(R[a])] = find(R[b]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (g){\n\t\t\tfor (int i=0;i<N-1;i++) printf (\"%d %d\\n\",X[i],Y[i]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"-1\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 100005, Inf = 1 << 30;\n\ninline int gi()\n{\n\tchar c = getchar();\n\twhile (c < '0' || c > '9') c = getchar();\n\tint sum = 0;\n\twhile ('0' <= c && c <= '9') sum = sum * 10 + c - 48, c = getchar();\n\treturn sum;\n}\n\nint n;\nqueue<int> q;\nvector<int> vec[maxn];\nint eu[maxn], ev[maxn], vis[maxn];\n\nstruct edge\n{\n\tint to, next, cap;\n} e[maxn << 3];\nint s, t, h[maxn << 1], cur[maxn << 1], dis[maxn << 1], mat[maxn << 1], tot = 1;\n\ninline void add(int u, int v, int w)\n{\n\te[++tot] = (edge) {v, h[u], w}; h[u] = tot;\n\te[++tot] = (edge) {u, h[v], 0}; h[v] = tot;\n}\n\nbool bfs()\n{\n\tstatic int l, r, q[maxn << 1];\n\tmemset(dis + 1, 0, sizeof(int) * t);\n\tl = 0; q[r = 1] = s; dis[s] = 1;\n\twhile (l < r) {\n\t\tint u = q[++l];\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!dis[v] && e[i].cap) dis[v] = dis[u] + 1, q[++r] = v;\n\t}\n\treturn dis[t];\n}\n\nint dfs(int u, int a)\n{\n\tif (u == t || !a) return a;\n\tint f, flow = 0;\n\tfor (int &i = cur[u], v; v = e[i].to, i; i = e[i].next)\n\t\tif (dis[v] == dis[u] + 1 && (f = dfs(v, min(a, e[i].cap)))) {\n\t\t\tflow += f; a -= f;\n\t\t\te[i].cap -= f; e[i ^ 1].cap += f;\n\t\t\tif (!a) break;\n\t\t}\n\treturn flow;\n}\n\nint max_flow()\n{\n\tint res = 0;\n\twhile (bfs()) {\n\t\tmemcpy(cur + 1, h + 1, sizeof(int) * t);\n\t\tres += dfs(s, Inf);\n\t}\n\tfor (int u = 1; u < n; ++u)\n\t\tfor (int i = h[u], v; v = e[i].to, i; i = e[i].next)\n\t\t\tif (!e[i].cap && v != s) {mat[u] = v; mat[v] = u; break;}\n\treturn res;\n}\n\nint main()\n{\n\tn = gi();\n\tfor (int c, w, i = 1; i < n; ++i) {\n\t\tc = gi();\n\t\twhile (c--) {\n\t\t\tw = gi(); vec[w].push_back(i);\n\t\t\tif (w != n) add(w, i + n - 1, 1);\n\t\t}\n\t}\n\ts = n * 2 - 1; t = s + 1;\n\tfor (int i = 1; i < n; ++i) add(s, i, 1), add(i + n - 1, t, 1);\n\t\n\tif (max_flow() != n - 1) return puts(\"-1\"), 0;\n\tint cnt = 0; q.push(n);\n\twhile (!q.empty()) {\n\t\tint u = q.front(); q.pop(); ++cnt;\n\t\tfor (int e : vec[u])\n\t\t\tif (!vis[e]) vis[e] = 1, q.push(mat[e + n - 1]), eu[e] = u, ev[e] = mat[e + n - 1];\n\t}\n\tif (cnt != n) return puts(\"-1\"), 0;\n\tfor (int i = 1; i < n; ++i) printf(\"%d %d\\n\", eu[i], ev[i]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\n// O(V^2 E)\nstruct Dinic {\n    using F = ll;\n    static constexpr F INF = numeric_limits<F>::max();\n\n    struct Edge {\n        int to, rev;\n        F cap;\n        Edge(int to, F cap, int rev) : to(to), cap(cap), rev(rev){};\n    };\n\n    using E = Edge;\n\n    VV<E> g;\n    V<int> level, iter;\n\n    Dinic() {}\n    Dinic(int n) : g(n), level(n), iter(n) {}\n\n    void add_edge(int from, int to, F cap) {\n        g[from].emplace_back(to, cap, (int)g[to].size());\n        g[to].emplace_back(from, 0, (int)g[from].size() - 1);\n    }\n\n    void bfs(int s) {\n        fill(ALL(level), -1);\n        queue<int> que;\n        level[s] = 0;\n        que.push(s);\n\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (auto& e : g[v]) {\n                if (e.cap > 0 && level[e.to] < 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n\n    F dfs(int v, int t, F f) {\n        if (v == t) return f;\n        for (int& i = iter[v]; i < g[v].size(); i++) {\n            auto& e = g[v][i];\n            if (e.cap > 0 && level[v] < level[e.to]) {\n                F d = dfs(e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    F max_flow(int s, int t) {\n        F flow = 0;\n        while (true) {\n            bfs(s);\n            if (level[t] < 0) return flow;\n            fill(ALL(iter), 0);\n            F f;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n    }\n};\n\nVV<pii> gg;\nV<bool> vis;\nV<pii> ans;\n\nvoid dfs(int v) {\n    vis[v] = 1;\n    for (auto e : gg[v]) {\n        if (!vis[e.fi]) {\n            ans[e.se] = mp(v, e.fi);\n            dfs(e.fi);\n        }\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    VV<int> E(N);\n    rep(i, N - 1) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int x;\n            cin >> x;\n            --x;\n            E[i].pb(x);\n        }\n    }\n\n    int r = 0;  // special\n    Dinic flow(N + N + 2);\n    int s = N * 2, t = s + 1;\n    rep(i, N - 1) {\n        flow.add_edge(i + N, t, 1);\n        for (int x : E[i])\n            if (x != r) {\n                flow.add_edge(x, i + N, 1);\n            }\n    }\n    rep(i, N) { flow.add_edge(s, i, 1); }\n    int f = flow.max_flow(s, t);\n\n    if (f != N - 1) {\n        puts(\"-1\");\n        return 0;\n    }\n\n    V<int> rmt(N);\n    for (int i = 1; i < N; ++i) {\n        for (auto e : flow.g[i]) {\n            if (e.to >= N && e.to < N + N - 1 && e.cap == 0) {\n                rmt[e.to - N] = i;\n            }\n        }\n    }\n    debug(rmt);\n\n    gg.resize(N);\n    vis.resize(N);\n\n    rep(i, N - 1) {\n        for (int v : E[i]) {\n            gg[v].eb(rmt[i], i);\n        }\n    }\n\n    ans.resize(N - 1, mp(-1, -1));\n    dfs(0);\n    bool ok = 1;\n    rep(i, N - 1) if (ans[i] == mp(-1, -1)) {\n        puts(\"-1\");\n        return 0;\n    }\n    rep(i, N - 1) { cout << ans[i].fi + 1 << \" \" << ans[i].se + 1 << endl; }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 200005 , S = 0 , T = 200000;\nstruct node{int to,next,val;}e[N<<4];\nint head[N],cnt,dep[N],q[N],c[N],n;\nvoid add(int x,int y,int z){e[cnt]=(node){y,head[x],z};head[x]=cnt++;}\nvoid insert(int x,int y,int z){add(x,y,z),add(y,x,0);}\nint bfs()\n{\n\tint l=0,r=0;q[r++] = S;memset(dep,-1,sizeof(dep));dep[S] = 1;\n\twhile(l<r)\n\t{\n\t\tint x = q[l++];\n\t\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t\t{\n\t\t\tint to1=e[i].to;\n\t\t\tif(dep[to1]==-1&&e[i].val)dep[to1] = dep[x]+1 , q[r++] = to1;\n\t\t}\n\t}return dep[T] != -1;\n}\nint dfs(int x,int maxf)\n{\n\tif(x==T)return maxf;int tflow = maxf , nowf;\n\tfor(int i=head[x];i!=-1;i=e[i].next)\n\t{\n\t\tint to1=e[i].to;\n\t\tif(dep[to1]==dep[x]+1&&e[i].val)\n\t\t{\n\t\t\tnowf = dfs(to1 , min(tflow , e[i].val) );\n\t\t\tif(nowf && x>=1 && x<=n-1 && to1) c[x]=to1-n+2;\n\t\t\te[i].val-=nowf , tflow -= nowf , e[i^1].val += nowf;\n\t\t\tif(!tflow)break;\n\t\t}\n\t}if(tflow)dep[x] = -1;return maxf-tflow;\n}\nvector<int >v[N];\nint Dinic()\n{\n\tint sum = 0;\n\twhile(bfs())sum += dfs(S,1<<30);\n\treturn sum;\n}\nint vis[N];pair<int ,int > ans[N];\nint main()\n{\n\tscanf(\"%d\",&n);memset(head,-1,sizeof(head));\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tint siz; scanf(\"%d\",&siz); insert(S,i,1); insert(n+i-1,T,1);\n\t\tfor(int j=1,x;j<=siz;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&x),v[x].push_back(i);\n\t\t\tif(x!=1)insert(i,n+x-2,1);\n\t\t}\n\t}\n\t// puts(\"B\");\n\tif(Dinic()==n-1)\n\t{\n\t\t// puts(\"a\");\n\t\tint l = 0 , r = 0;\n\t\tfor(int i=0;i<v[1].size();i++)\n\t\t\tq[r++] = v[1][i] , vis[v[1][i]] = 1;\n\t\twhile(l<r)\n\t\t{\n\t\t\tint x = q[l++]; ans[l] = make_pair(vis[x] , c[x]); x = c[x];\n\t\t\tfor(int i=0;i<v[x].size();i++)\n\t\t\t\tif(!vis[v[x][i]]) q[r++] = v[x][i] , vis[v[x][i]] = x;\n\t\t}\n\t\tif(r==n-1)for(int i=1;i<n;i++)printf(\"%d %d\\n\",ans[i].first,ans[i].second);\n\t\telse puts(\"-1\");\n\t}else puts(\"-1\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<ctime>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define M 800050\n#define file(x)freopen(x\".in\",\"r\",stdin);freopen(x\".out\",\"w\",stdout)\n#define rt register int\n#define l putchar('\\n')\n#define ll long long\n#define r read()\nusing namespace std;\ninline ll read(){\n    ll x=0;char zf=1;char ch=getchar();\n    while(ch!='-'&&!isdigit(ch))ch=getchar();\n    if(ch=='-')zf=-1,ch=getchar();\n    while(isdigit(ch))x=x*10+ch-'0',ch=getchar();return x*zf;\n}\nvoid write(ll y){if(y<0)putchar('-'),y=-y;if(y>9)write(y/10);putchar(y%10+48);}\nvoid writeln(const ll y){write(y);putchar('\\n');}\nint k,m,n,x,y,z,cnt,S,T;\nint sum[M];\nvector<int>s[100010];//i \nint F[M],N[M],a[M],c[M],dis[M],pre[M],num[M],fa[M],cur[M];\nvoid add(int x,int y,int z){\n\ta[++k]=y;c[k]=z;\n\tN[k]=F[x];F[x]=k;\n}\nint q[200010],h,t;bool vis[200010];\nbool bfs(){\n\tmemset(dis,0,n*4+8);h=t=0;q[++t]=S;dis[S]=1;\n\tfor(rt i=1;i<=n;i++)cur[i]=F[i];\n\twhile(h<t){\n\t\tconst int x=q[++h];\n\t\tfor(rt i=F[x];i;i=N[i])if(!dis[a[i]]&&c[i]){\n\t\t\tdis[a[i]]=dis[x]+1,q[++t]=a[i];\n\t\t\tif(a[i]==T)return 1;\n\t\t}\n\t}\n\treturn dis[T];\n}\nint dfs(int x,int flow){\n\tif(x==T)return flow;int used=0;\n\tfor(rt i=cur[x];i;i=cur[x]=N[i])if(c[i]&&dis[a[i]]==dis[x]+1){\n\t\tconst int v=dfs(a[i],1);\n\t\tif(v)used++,c[i]--,c[i^1]++,pre[a[i]]=x; \n\t\tif(flow==used||dis[S]>=n)return used;\n\t}\n\treturn used;\n}\n\nvoid print(int x,int y){\n\twrite(x),putchar(' ');writeln(y);\n}\nint main(){\n\tn=r;k=1;\n\tfor(rt i=1;i<n;i++){\n\t\tsum[i]=r;\n\t\tfor(rt j=1;j<=sum[i];j++){\n\t\t\tx=r;s[x].push_back(i);\n\t\t\tif(x>1)add(i,n-1+x-1,1),add(n-1+x-1,i,0);\n\t\t}\n\t}\n\tS=n*2-1,T=n*2;\n\tfor(rt i=1;i<n;i++)add(S,i,1),add(i,S,0);\n\tfor(rt i=n;i<=n*2-2;i++)add(i,T,1),add(T,i,0);\n\tn<<=1;int ans=0;\n\twhile(bfs())ans+=dfs(S,1000000000);\n\tif(ans+1<n/2)return puts(\"-1\"),0;\n\tn>>=1;h=t=0;\n\tfor(rt i=n;i<=n*2-2;i++)num[pre[i]]=i-n+2;q[t=1]=1;\n\twhile(h<t){\n\t\tx=q[++h];\n\t\tfor(auto i:s[x])if(!vis[num[i]])vis[num[i]]=1,fa[num[i]]=x,q[++t]=num[i];\n\t}\n\tfor(rt i=1;i<n;i++)if(!fa[num[i]])return puts(\"-1\"),0;\n\tfor(rt i=1;i<n;i++)print(fa[num[i]],num[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define MIN_INT -2147483648\n#define MAX_INT 2147483647\n#define MIN_LONG -9223372036854775808L\n#define MAX_LONG 9223372036854775807L\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::set;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\nusing std::cerr;\n\n// @author: pashka\n\nvector<vector<int>> g;\nvector<int> r;\nvector<int> z;\n\nint ccc = 0;\n\nbool dfs(int x) {\n//    cout << x << \"\\n\";\n    if (z[x] == ccc) return false;\n    z[x] = ccc;\n    for (int y : g[x]) {\n        if (r[y] == -1 || dfs(r[y])) {\n            r[y] = x;\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\nint main() {\n    std::ios::sync_with_stdio(false);\n    int n;\n    cin >> n;\n    g.resize(n);\n    r.assign(n, -1);\n    z.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int c;\n        cin >> c;\n        for (int j = 0; j < c; j++) {\n            int x;\n            cin >> x;\n            x--;\n            g[x].push_back(i);\n        }\n    }\n\n    int ff = -1;\n    for (int i = 0; i < n; i++) {\n        ccc++;\n        if (!dfs(i)) {\n            if (ff == -1) {\n                ff = i;\n            } else {\n                cout << -1 << \"\\n\";\n                return 0;\n            }\n        }\n    }\n\n//    for (int i = 0; i < n - 1; i++) {\n//        cout << r[i] << \"\\n\";\n//    }\n\n    vector<int> q;\n    vector<bool> zz(n);\n    q.push_back(ff);\n    vector<pair<int, int>> res(n - 1);\n    for (int i = 0; i < q.size(); i++) {\n        int x = q[i];\n        for (int c : g[x]) {\n            if (!zz[c]) {\n                zz[c] = true;\n                q.push_back(r[c]);\n                res[c] = {r[c], x};\n            }\n        }\n    }\n\n    if (q.size() < n) {\n        cout << \"-1\\n\";\n    } else {\n        for (int i = 0; i < n - 1; i++) {\n            cout << res[i].first + 1 << \" \" << res[i].second + 1 << \"\\n\";\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 1e5 + 5;\n\nint s[Nmax];\nint n;\nbool unlocked[Nmax];\nvector<int> v[Nmax], w[Nmax];\nvector< pair<int,int> > edges;\n\nclass Graph\n{\n    vector<int> v[Nmax];\n    bool used[Nmax];\n    int L[Nmax], R[Nmax];\n\n    bool cupleaza(int node)\n    {\n        if(used[node]) return 0;\n        used[node] = 1;\n\n        for(auto it : v[node])\n            if(!R[it])\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n\n        for(auto it : v[node])\n            if(cupleaza(R[it]))\n            {\n                L[node] = it;\n                R[it] = node;\n                return 1;\n            }\n        return 0;\n    }\n\npublic:\n    void add_edge(int x, int y)\n    {\n        v[x].push_back(y);\n    }\n\n    bool cuplaj()\n    {\n        bool done = 1; int i;\n        while(done)\n        {\n            done = 0;\n            for(i=1; i<=n; ++i) used[i] = 0;\n\n            for(i=1; i<=n; ++i)\n                if(!L[i]) done |= cupleaza(i);\n        }\n\n        for(i=1; i<n; ++i)\n        {\n            s[i] = R[i];\n            if(!s[i]) return 0;\n        }\n        return 1;\n    }\n\n} graph;\n\nvoid build_sol()\n{\n    queue<int> q;\n    q.push(n);\n\n    int node;\n    while(q.size())\n    {\n        node = q.front();\n        q.pop();\n\n        for(auto it : w[node])\n            if(!unlocked[s[it]])\n            {\n                q.push(s[it]);\n                unlocked[s[it]] = 1;\n                edges.push_back({node, s[it]});\n            }\n    }\n\n    if(edges.size() != n-1)\n    {\n        cout << \"-1\\n\";\n        return;\n    }\n\n    for(auto e : edges) cout << e.first << ' ' << e.second << '\\n';\n}\n\nint main()\n{\n  ///  freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    int i, nr, x;\n    cin >> n;\n    for(i=1; i<n; ++i)\n    {\n        cin >> nr;\n        while(nr--)\n        {\n            cin >> x;\n            v[i].push_back(x);\n            w[x].push_back(i);\n            if(x < n) graph.add_edge(x, i);\n        }\n    }\n\n    if(!graph.cuplaj())\n    {\n        cout << \"-1\\n\";\n        return 0;\n    }\n\n    build_sol();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef bool boolean;\n\nconst int inf = (signed) (~0u >> 1);\n\ntypedef class Edge {\n\tpublic:\n\t\tint ed, nx, r;\n\n\t\tEdge() {\t}\n\t\tEdge(int ed, int nx, int r) : ed(ed), nx(nx), r(r) {\t}\n} Edge;\n\ntypedef class MapManager {\n\tpublic:\n\t\tint *h;\n\t\tvector<Edge> E;\n\n\t\tMapManager() {\t}\n\t\tMapManager(int n) {\n\t\t\th = new int[(n + 1)];\n\t\t\tmemset(h, -1, sizeof(int) * (n + 1));\n\t\t}\n\t\t~MapManager() {\n\t\t\tdelete[] h;\n\t\t\tE.clear();\n\t\t}\n\n\t\tvoid add_edge(int u, int v, int r) {\n\t\t\tE.emplace_back(v, h[u], r);\n\t\t\th[u] = (signed) E.size() - 1;\n\t\t}\n\t\tvoid add_arc(int u, int v, int r) {\n\t\t\tadd_edge(u, v, r);\n\t\t\tadd_edge(v, u, 0);\n\t\t}\n\t\tEdge& operator [] (int p) {\n\t\t\treturn E[p];\n\t\t}\n} MapManager;\n\ntypedef class Network {\n\tpublic:\n\t\tint S, T;\n\t\tMapManager g;\n\n\t\tint *d, *h;\n\n\t\tNetwork(int S, int T) : S(S), T(T), g(T) {\n\t\t\td = new int[(T + 1)];\n\t\t\th = new int[(T + 1)];\n\t\t}\n\t\t~Network() {\n\t\t\tdelete[] d;\n\t\t\tdelete[] h;\n\t\t}\n\n\t\tboolean bfs() {\n\t\t\tqueue<int> Q;\n\t\t\tmemset(d, -1, sizeof(int) * (T + 1));\n\t\t\td[S] = 0;\n\t\t\tQ.push(S);\n\t\t\twhile (!Q.empty()) {\n\t\t\t\tint e = Q.front();\n\t\t\t\tQ.pop();\n\t\t\t\tfor (int i = g.h[e], eu; ~i; i = g[i].nx) {\n\t\t\t\t\teu = g[i].ed;\n\t\t\t\t\tif (!g[i].r || ~d[eu])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\td[eu] = d[e] + 1;\n\t\t\t\t\tQ.push(eu);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn d[T] != -1;\n\t\t}\n\t\t\n\t\tint dfs(int p, int mf) {\n\t\t\tif (p == T || !mf)\n\t\t\t\treturn mf;\n\t\t\tint flow = 0, f;\n\t\t\tfor (int& i = h[p], j, e; ~i; (i != -1) && (i = g[i].nx)) {\n\t\t\t\te = g[i].ed, j = i;\n\t\t\t\tif (g[i].r && d[e] == d[p] + 1 && (f = dfs(e, min(mf, g[i].r))) > 0) {\n\t\t\t\t\tg[j].r -= f;\n\t\t\t\t\tg[j ^ 1].r += f;\n\t\t\t\t\tflow += f;\n\t\t\t\t\tmf -= f;\n\t\t\t\t\tif (!mf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn flow;\n\t\t}\n\n\t\tint dinic() {\n\t\t\tint rt = 0;\n\t\t\twhile (bfs()) {\n\t\t\t\tfor (int i = 0; i <= T; i++)\n\t\t\t\t\th[i] = g.h[i];\n\t\t\t\trt += dfs(S, inf);\n\t\t\t}\n\t\t\treturn rt;\n\t\t}\n\n\t\tvoid add_edge(int u, int v, int r) {\n\t\t\tg.add_arc(u, v, r);\n\t\t}\n\n\t\tint find_in_match(int p) {\n\t\t\tfor (int i = g.h[p]; ~i; i = g[i].nx) {\n\t\t\t\tif (!g[i].r) {\n\t\t\t\t\treturn g[i].ed;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n} Network;\n\nconst int N = 1e5 + 5;\n\nint n, T;\nint A[N], B[N];\nboolean vis[N];\nvector<int> S[N], G[N];\n\nint main() {\n\tscanf(\"%d\", &n);\n\tNetwork network (0, T = 2 * n - 1);\n\tfor (int i = 1; i < n; i++)\n\t\tnetwork.add_edge(0, i, 1);\n\tfor (int i = 1; i < n; i++)\n\t\tnetwork.add_edge(n - 1 + i, T, 1);\n\tfor (int i = 1, k; i < n; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tS[i].resize(k);\n\t\tfor (auto& x : S[i]) {\n\t\t\tscanf(\"%d\", &x);\n\t\t\tif (x > 1) {\n\t\t\t\tnetwork.add_edge(i, n - 2 + x, 1);\n\t\t\t}\n\t\t}\n\t}\n\tint flow = network.dinic();\n\tif (flow < n - 1) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tA[i] = network.find_in_match(i);\n\t\tassert(A[i] >= n);\n\t\tA[i] -= n - 2;\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tfor (auto e : S[i]) {\n\t\t\tif (e ^ A[i]) {\n\t\t\t\tG[e].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int> Q;\n\tQ.push(1);\n\twhile (!Q.empty()) {\n\t\tint p = Q.front();\n\t\tQ.pop();\n\t\tfor (auto e : G[p]) {\n\t\t\tif (!B[e]) {\n\t\t\t\tB[e] = p;\n\t\t\t\tQ.push(A[e]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tif (!B[i]) {\n\t\t\tputs(\"-1\");\n\t\t}\n\t}\n\tfor (int i = 1; i < n; i++) {\n\t\tprintf(\"%d %d\\n\", A[i], B[i]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n\n// constructor(n, inf?) // be careful !\n// addEdge(from, to, capacity, isDirected? = false) returns edgeID\n// === build(s, t) - returns max flow (or inf) ===\n// === restoreMinCut(s) ===\n// .isCut[edgeID]\n// === --- ===\n// inf * 2 < LL_MAX\n/// --- Max Flow with Dinic Library {{{ ///\n\nstruct Dinic {\n  struct Edge {\n    int from, to;\n    ll cap, rev;\n    int To(int i) const { return from == i ? to : from; }\n    ll& Cap(int i) { return from == i ? cap : rev; }\n    ll& Rev(int i) { return from == i ? rev : cap; }\n  };\n\n  int n;\n  vector< Edge > edges;\n  vector< vector< int > > g;\n  ll inf;\n  Dinic(int n, ll inf = 1e18) : n(n), g(n), inf(inf) {}\n  int addEdge(int a, int b, ll cap, bool undirected = false) {\n    edges.emplace_back((Edge){a, b, cap, undirected ? cap : 0});\n    g[a].emplace_back(edges.size() - 1);\n    g[b].emplace_back(edges.size() - 1);\n    return edges.size() - 1;\n  }\n  ll build(int s, int t) {\n    vector< int > level(n);\n    vector< int > colors(n);\n    int color = 1;\n    ll flow = 0;\n    while(++color, bfs(s, level, colors, color), colors[t] == color) {\n      ll newflow = dfs(s, t, inf, level);\n      if(newflow == 0) break;\n      flow += newflow;\n      if(flow >= inf) return inf;\n    }\n    return flow;\n  }\n  vector< int > isCut;\n  void restoreMinCut(int s) {\n    isCut = vector< int >(edges.size());\n    // bfs\n    vector< int > used(n);\n    queue< int > q;\n    q.emplace(s);\n    used[s] = 1;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge& edge = edges[idx];\n        if(!used[edge.To(i)] && edge.Cap(i) > 0) {\n          q.emplace(edge.To(i));\n          used[edge.To(i)] = 1;\n        }\n      }\n    }\n    for(size_t i = 0; i < edges.size(); i++) {\n      if(used[edges[i].from] != used[edges[i].to]) isCut[i] = 1;\n    }\n  }\n\nprivate:\n  void bfs(int s, vector< int >& level, vector<int> & colors, int color) {\n    // fill(begin(level), end(level), -1);\n    queue< int > q;\n    q.emplace(s);\n    level[s] = 0;\n    colors[s] = color;\n    while(q.size()) {\n      int i = q.front();\n      q.pop();\n      for(int idx : g[i]) {\n        Edge edge = edges[idx];\n        if(colors[edge.To(i)] != color && edge.Cap(i) > 0) {\n          colors[edge.To(i)] = color;\n          level[edge.To(i)] = level[i] + 1;\n          q.emplace(edge.To(i));\n        }\n      }\n    }\n  }\n\n  ll dfs(int i, int t, ll flow, vector< int > const& level) {\n    if(i == t) return flow;\n    for(int idx : g[i]) {\n      Edge& edge = edges[idx];\n      if(edge.Cap(i) > 0 && level[edge.To(i)] > level[i]) {\n        ll newflow = dfs(edge.To(i), t, min(flow, edge.Cap(i)), level);\n        if(newflow == 0) continue;\n        edge.Cap(i) -= newflow;\n        edge.Rev(i) += newflow;\n        return newflow;\n      }\n    }\n    return 0;\n  }\n};\n\n/// }}}--- ///\n\nconst ll inf = 1e18;\n\nint n;\n\nvoid imp() {\n  cout << -1 << endl;\n  exit(0);\n}\n\nint ans[112345][2];\n\nvector<int> inc[112345]; // [x] := x\n\nvector<int> usedGroup(112345);\n\nvoid dfs(int i) {\n  for(int gid : inc[i]) if(!usedGroup[gid]) {\n    usedGroup[gid] = 1;\n    dfs(ans[gid][0]);\n    ans[gid][1] = i;\n  }\n}\n\n// \n// kk\n//  (k+1) \n//  k \n// n-1\n\n//  E_i has i \n// E_0 + E_1 + E_2 + ... + E_k = {0, 1, ..., k} \n// N\n// N\n\n// DFS\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  Dinic eca(n + n - 1 + 2, inf);\n  int s = n + n - 1 + 0, t = s + 1;\n  vector<tuple<int, int, int>> v;\n  for(int i = 0; i < n - 1; i++) {\n    int c; cin >> c;\n    for(int j = 0; j < c; j++) {\n      int x;\n      cin >> x;\n      x--;\n      inc[x].emplace_back(i);\n      int id = eca.addEdge(i, n - 1 + x, 1);\n      v.emplace_back(id, i, x);\n    }\n    eca.addEdge(s, i, 1);\n    eca.addEdge(n - 1 + i, t, 1);\n  }\n  eca.addEdge(n - 1 + n - 1, t, 1);\n\n  int sz = eca.build(s, t);\n  if(sz != n - 1) imp();\n\n  vector<int> found(n);\n  for(auto p : v) {\n    int id, from, to;\n    tie(id, from, to) = p;\n    if(eca.edges[id].cap == 0) {\n      ans[from][0] = to;\n      found[to] = 1;\n    }\n  }\n\n  int root;\n  for(int i = 0; i < n; i++) if(!found[i]) root = i;\n\n  dfs(root);\n\n  for(int i = 0; i < n - 1; i++) if(!usedGroup[i]) imp();\n\n  for(int i = 0; i < n - 1; i++) {\n    cout << ans[i][0] + 1 << \" \" << ans[i][1] + 1 << \"\\n\";\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#define inf 1e9\n#define N 4000001\nusing namespace std;\nint total1,total2,SS,TT,S,T;\nint nexts[N],head[N],edge[N],v1[N],v[N],nexts2[N],head2[N],edge2[N],down[N],up[N];\nint du[N],h[N],d[N],out[N],in[N],ans[N][15];\nint n;\nvector<int>s[N];\nint max(int x,int y)\n{\n\tif (x<y) return y;\n\telse\treturn x;\n}\nint min(int x,int y)\n{\n\tif (x>y) return y;\n\telse\treturn x;\n}\nvoid insert(int x,int y,int z,int z1)\n{\n\ttotal2++;\n\tnexts[total2]=head[x];\n\thead[x]=total2;\n\tedge[total2]=y;\n\tv[total2]=z;\n\tv1[total2]=z1;\n}\nvoid insert2(int x,int y,int l,int r)\n{\n//\tprintf(\"%d %d %d %d\\n\",x,y,l,r);\n\ttotal1++;\n\tnexts2[total1]=head2[x];\n\thead2[x]=total1;\n\tedge2[total1]=y;\n\tdown[total1]=l;\n\tup[total1]=r;\n\tout[x]+=l;in[y]+=l;\n}\nbool bfs()\n{\n\tmemset(d,0,sizeof(d));\n\tint l=1,r=1;\n\th[1]=SS;\n\td[SS]=1;\n\twhile (l<=r)\n\t{\n\t\tint u=h[l];\n\t\tfor (int i=head[u];i;i=nexts[i])\n\t\t{\n\t\t\tint y=edge[i];\n\t\t\tif (v[i]&&!d[y])\n\t\t\t{\n\t\t\t\tr++;\n\t\t\t\th[r]=y;\n\t\t\t\td[y]=d[u]+1;\n\t\t\t\tif (y==TT) return true;\n\t\t\t}\n\t\t}\n\t\tl++;\n\t}\n\treturn false;\n}\nint dinic(int k,int flow)\n{\n\tif (k==TT) return flow;\n\tint rest=flow;\n\tfor (int i=head[k];i && rest;i=nexts[i])\n\t{\n\t\tint y=edge[i];\n\t\tif (v[i]&&d[y]==d[k]+1)\n\t\t{\n\t\t\tint cost;\n\t\t\tif (rest>v[i]) cost=v[i];\n\t\t\telse\tcost=rest;\n\t\t\tint pay=dinic(y,cost);\n\t\t\tif (pay==0) d[y]=0;\n\t\t\trest-=pay;\n\t\t\tv[i]-=pay;\n\t\t\tv[i^1]+=pay;\n\t\t}\n\t}\n\treturn flow-rest;\n}\nvoid restructure()\n{\n\tSS=T+1;\n\tTT=SS+1;\n\tfor (int i=S;i<=T;i++)\n\t\tdu[i]=in[i]-out[i];\n\ttotal2=1;\n\tinsert(T,S,inf,inf);\n\tinsert(S,T,0,inf);\n\tfor (int i=S;i<=T;i++)\n\t\tif (du[i]>0) \n\t\t{\n\t\t\tinsert(SS,i,du[i],inf);insert(i,SS,0,inf);\n\t\t}\n\t\telse\t\n\t\t{\n\t\t\tinsert(i,TT,-du[i],inf);insert(TT,i,0,inf);\n\t\t}\n\tfor (int i=S;i<=T;i++)\n\t\tfor (int j=head2[i];j;j=nexts2[j])\n\t\t{\n\t\t\tint y=edge2[j];\n\t\t\tinsert(i,y,up[j]-down[j],down[j]);\n\t\t\tinsert(y,i,0,down[j]);\n\t\t}\n}\nint re_dinic()\n{\n\tint maxflow=0;\n\tint flow;\n\twhile (bfs())\n\t\twhile ((flow=dinic(SS,inf))) maxflow+=flow;\n\treturn maxflow;\n}\nint main()\n{\n\tS=0;\n\tscanf(\"%d\",&n);\n\tT=n*4+1;\n\ttotal1=1;\n\tmemset(out,0,sizeof(out));\n\tmemset(in,0,sizeof(in));\n\tinsert2(S,1,0,1e9);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tinsert2(i,i+n,1,1e9);\n\t//\tinsert2(i+n,i,1,1e9);\t\n\t\tinsert2(i+n,T,0,1e9);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tinsert2(i+2*n,i+3*n,1,1);\n\t//\tinsert2(i+3*n,i+2*n,1,1);\n\t}\n\tfor (int i=1;i<n;i++)\n\t{\n\t//\tint p;\n\t\ts[i].resize(1);\n\t\tscanf(\"%d\",&s[i][0]);\n\t\ts[i].resize(s[i][0]+1);\n\t\tfor (int j=1;j<=s[i][0];j++) \tscanf(\"%d\",&s[i][j]);\n\t\tfor (int j=1;j<=s[i][0];j++)\n\t\t{\n\t\t\tinsert2(s[i][j]+n,i+2*n,0,1);\n\t\t\tinsert2(i+3*n,s[i][j],0,1);\n\t\t}\n\t}\n\trestructure();\n\tint sum=0;\n\tfor (int i=S;i<=T;i++)\tif (du[i]>=0) sum+=du[i];\n\tint maxflow=re_dinic();\n\tif (maxflow==sum)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tfor (int i=2;i<=total2;i++)\n\t\t{\n\t\t\tif (v1[i]>=inf) continue;\n\t\t\tint u1=edge[i];\n\t\t\tint u2=edge[i^1];\n\t\t\tif (v1[i]!=0) continue;\n\t\t\tif (u1==S||u2==S) continue;\n\t\t\tif (u1==T||u2==T) continue;\n\t\t\tif (u1<u2)\n\t\t\t{\n\t\t\t\tint t=u1;u1=u2;u2=t;\n\t\t\t}\n\t\t\tif (i==62)\n\t\t\t{\n\t\t\t\tn++;n--;\n\t\t\t}\n\t\t\tif (i%2==0&&v1[i]+v[i^1]==1)\n\t\t\t{\n\t\t\t\tprintf(\"%d %d\\n\",u1,u2);\n\t\t\t\tu1=(u1+n-1)%n+1;\n\t\t\t\tu2=(u2+n-1)%n+1;\n\t\t\t\tans[u1][0]++;\n\t\t\t\tans[u1][ans[u1][0]]=u2;\n\t\t\t}\n\t\t}\n\t\tfor (int i=1;i<n;i++) \n\t\t\tprintf(\"%d %d\\n\",ans[i][1],ans[i][2]);\n//\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t{\n\t\tprintf(\"-1\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <cstdio>\n#include <vector>\n#define pb push_back\nint lst[200005], to[2000005], pre[2000005], cap[2000005], tot;\nint dep[200005], que[200005], fst[200005];\ninline void add_edge(int u, int v, int _cap)\n{\n\t// printf(\"%d %d %d\\n\", u, v, _cap);\n\tauto add = [&] (int x, int y, int c)\n\t{\n\t\tto[tot] = y;\n\t\tpre[tot] = lst[x];\n\t\tcap[tot] = c;\n\t\tlst[x] = tot++;\n\t};\n\tadd(u, v, _cap);\n\tadd(v, u, 0);\n}\nbool bfs(int s, int t)\n{\n\tmemset(dep, -1, sizeof(dep));\n\tdep[s] = 0;\n\tint he = 0, ta = 0;\n\tque[ta++] = s;\n\twhile (he < ta)\n\t{\n\t\tint u = que[he++];\n\t\tfor (int i = lst[u]; ~i; i = pre[i])\n\t\t{\n\t\t\tif (cap[i] && dep[to[i]] == -1)\n\t\t\t{\n\t\t\t\tdep[to[i]] = dep[u] + 1;\n\t\t\t\tque[ta++] = to[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn ~dep[t];\n}\nint dfs(int u, int t, int rem)\n{\n\tif (u == t)\n\t\treturn rem;\n\tint ans = 0;\n\tfor (int i = fst[u]; ~i; i = pre[i])\n\t{\n\t\tif (cap[i] && dep[to[i]] == dep[u] + 1)\n\t\t{\n\t\t\tint res = dfs(to[i], t, std::min(rem - ans, cap[i]));\n\t\t\tcap[i] -= res;\n\t\t\tcap[i ^ 1] += res;\n\t\t\tif (cap[i])\n\t\t\t\tfst[u] = i;\n\t\t\tans += res;\n\t\t\tif (ans == rem)\n\t\t\t\treturn ans;\n\t\t}\n\t}\n\tif (!ans)\n\t\tdep[u] = -1;\n\treturn ans;\n}\ninline int dinic(int s, int t)\n{\n\tint ans = 0;\n\twhile (bfs(s, t))\n\t{\n\t\tmemcpy(fst, lst, sizeof(lst));\n\t\tans += dfs(s, t, 1e9);\n\t}\n\treturn ans;\n}\nstd::vector<int> vec[200005], bel[200005];\nint fa[200005], rep[200005];\nbool vis[200005];\nint add(int u)\n{\n\tint res = 1;\n\tvis[u] = true;\n\tfor (int x : bel[u])\n\t{\n\t\tif (!vis[rep[x]])\n\t\t{\n\t\t\tfa[rep[x]] = u;\n\t\t\tres += add(rep[x]);\n\t\t}\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"AGC029-F.in\", \"r\", stdin);\n\tmemset(lst, -1, sizeof(lst));\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i + 1 < n; i++)\n\t{\n\t\tint len;\n\t\tscanf(\"%d\", &len);\n\t\twhile (len--)\n\t\t{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tif (--u)\n\t\t\t\tadd_edge(i + 1, u + n - 1, 1);\n\t\t\tvec[i].pb(u);\n\t\t\tbel[u].pb(i);\n\t\t}\n\t\tadd_edge(0, i + 1, 1);\n\t\tadd_edge(i + n, n + n, 1);\n\t}\n\tif (dinic(0, n + n) != n - 1)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tfor (int j = lst[i]; ~j; j = pre[j])\n\t\t{\n\t\t\tif (to[j] && !cap[j])\n\t\t\t\trep[i - 1] = to[j] - n + 1;\n\t\t}\n\t}\n\tif (add(0) != n)\n\t{\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i < n; i++)\n\t\tprintf(\"%d %d\\n\", fa[i] + 1, i + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define all(x) (x).begin(), (x).end()\n\n#define TRACE(x) x\n#define WATCH(x) TRACE(cout << #x\" = \" << x << endl)\n#define PRINT(x...) TRACE(printf(x))\n#define WATCHR(a, b) TRACE(for (auto c=a; c!=b;) cout << *(c++) << \" \"; cout << endl)\n#define WATCHC(V) TRACE({cout << #V\" = \"; WATCHR(V.begin(), V.end());})\n\n#define FU(i, a, b) for (auto i = a; i < b; ++i)\n#define fu(i, b) FU(i, 0, b)\n#define FD(i, a, b) for (auto i = (b) - 1; i >= a; --i)\n#define fd(i, b) FD(i, 0, b)\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vd = vector<double>;\nusing vb = vector<bool>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nll mod(ll a, ll b) {\n  return ((a%b)+b)%b;\n}\n\nint cmp(double x, double y = 0, double tol = 1.e-7) {\n\treturn (x <= y + tol) ? (x + tol < y) ? -1 : 0 : 1;\n}\n#define pb push_back\n#define sz(x) ((int)(x).size())\n\nstruct graph {\n  vi dest;  // use sz(dest) as number of arcs\n  vvi adj;  // use sz(adj) as number of vertices\n  int inv(int a) { return a ^ 0x1; }\n  graph(int n = 0) {\n    adj.resize(n);\n  }\n  // Adds an arc to the graph. u is capacity, c is cost.\n  // u is only needed on flows, and c only on min-cost-flow\n  int arc(int i, int j, ll u = 1) {\n    dest.pb(j);\n    adj[i].pb(sz(dest)-1);\n    dest.pb(i);\n    adj[j].pb(sz(dest)-1);\n    cap.pb(u); // For both flows\n    cap.pb(0);\n    return sz(dest)-2;\n  }\n  //////////////////////////////////////////////////////////////////////////////\n  // For both flows!!\n  //\n\n  vll cap, flow;\n\n  int orig(int a) { return dest[inv(a)]; }\n  ll capres(int a) { return cap[a] - flow[a]; }\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Max Flow! - Dinic O(n^2 * m)\n  // don't call maxflow with ini == end\n  //\n\n  vi curAdj, d;\n\n  bool MFbfs(int s, int t) {\n    d.assign(sz(adj), INT_MAX/2);\n    curAdj = vi(sz(adj));\n    d[s] = 0;\n    queue<int> Q; Q.push(s);\n    while (!Q.empty()) {\n      int u = Q.front(); Q.pop();\n      for (auto i : adj[u]) {\n        int v = dest[i];\n        if (capres(i) > 0 && d[v] == INT_MAX/2) {\n          d[v] = d[u] + 1; Q.push(v);\n        }\n      }\n    }\n    return d[t] != INT_MAX/2;\n  }\n\n  ll MFdfs(int u, int t, ll f) {\n    if (u == t) return f;\n    for(int &i = curAdj[u]; i < adj[u].size(); ++i) {\n      int ar = adj[u][i], v = dest[ar];\n      if (d[v] != d[u]+1 || capres(ar) == 0) continue;\n      ll tmpF = MFdfs(v, t, min(f, capres(ar)));\n      if (tmpF) {\n        flow[ar] += tmpF;\n        flow[inv(ar)] -= tmpF;\n        return tmpF;\n      }\n    }\n    return 0;\n  }\n\n  ll maxflow(int ini, int end) {\n    flow.assign(sz(dest), 0);\n    while (MFbfs(ini, end))\n      while (MFdfs(ini, end, LLONG_MAX/2));\n    ll F = 0;\n    for (int a : adj[ini]) F += flow[a];\n    return F;\n  }\n};\n\nint main() {\n\tint N;\n\tscanf(\"%d\", &N);\n\n\tgraph G(2 * N + 1);\n\tfu(i, N-1) G.arc(0, 1 + i, 1);\n\tfu(i, N) G.arc(N + i, 2 * N, 1);\n\n\tvvi inc(N);\n\tfu(i, N-1) {\n\t\tint c;\n\t\tscanf(\"%d\", &c);\n\t\twhile (c--) {\n\t\t\tint x;\n\t\t\tscanf(\"%d\", &x); x--;\n\t\t\tG.arc(1 + i, N + x, 1);\n\t\t\tinc[x].push_back(i);\n\t\t}\n\t}\n\n\tif (G.maxflow(0, 2*N) != (N - 1)) {\n\t\tprintf(\"-1\\n\");\n\t\treturn 0;\n\t}\n\n\t// find the match of each set\n\tvi match(N-1);\n\tll root = 0;\n\tfu(i, N) root += i;\n\n\tfu(i, N-1) {\n\t\tfor (int a : G.adj[1 + i])\n\t\t\tif (G.flow[a] == 1) {\n\t\t\t\tmatch[i] = G.dest[a] - N;\n\t\t\t\troot -= G.dest[a] - N;\n\t\t\t}\n\t}\n\n\tqueue<int> Q;\n\tQ.push(root);\n\tvb mark(N, false);\n\tmark[root] = true;\n\n\tvector<pair<int, int>> ans;\n\twhile (!Q.empty()) {\n\t\tint x = Q.front(); Q.pop();\n\n\t\tfor (int s : inc[x]) {\n\t\t\tint y = match[s];\n\t\t\tif (mark[y]) continue;\n\t\t\tmark[y] = true;\n\t\t\tQ.push(y);\n\t\t\tans.emplace_back(x, y);\n\t\t}\n\t}\n\n\tif (ans.size() != N - 1) printf(\"-1\\n\");\n\telse for (auto p : ans) printf(\"%d %d\\n\", p.first + 1, p.second + 1);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Text",
    "code": ""
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDfs(s, t);\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int nextEdge = 0;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDinic(s, t, all.size());\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        boolean bfs(TaskF.Vertex s, TaskF.Vertex t, TaskF.Vertex[] q, int curGen) {\n            int qh = 0, qt = 0;\n            q[qt++] = s;\n            s.generation = curGen;\n            s.dist = 0;\n            while (t.generation < curGen && qh < qt) {\n                TaskF.Vertex v = q[qh++];\n                for (TaskF.Edge e : v.outgo) {\n                    if (e.dest.generation < curGen && e.flow < e.cap) {\n                        e.dest.generation = curGen;\n                        q[qt++] = e.dest;\n                        e.dest.dist = v.dist + 1;\n                    }\n                }\n            }\n            return t.generation == curGen;\n        }\n\n        int maxFlowDinic(TaskF.Vertex s, TaskF.Vertex t, int nv) {\n            int flow = 0;\n            int curGen = 0;\n            TaskF.Vertex[] q = new TaskF.Vertex[nv];\n            for (; ; ) {\n                ++curGen;\n                if (!bfs(s, t, q, curGen)) break;\n                ++curGen;\n                t.markDinic(curGen - 1, curGen);\n                while (true) {\n                    int pushed = s.dfsDinic(t, curGen, INF);\n                    if (pushed == 0) break;\n                    flow += pushed;\n                }\n            }\n            return flow;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int interestingGeneration = 0;\n            int nextEdge = 0;\n            int dist;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            int dfsDinic(TaskF.Vertex t, int curGen, int got) {\n                if (got == 0) return 0;\n                if (this == t) return got;\n                if (interestingGeneration != curGen) return 0;\n                if (generation < curGen) {\n                    generation = curGen;\n                    nextEdge = 0;\n                }\n                for (; nextEdge < outgo.size(); ++nextEdge) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.dest.dist != dist + 1) continue;\n                    int pushed = e.dest.dfs(t, curGen, Math.min(got, e.cap - e.flow));\n                    if (pushed > 0) {\n                        e.flow += pushed;\n                        e.rev.flow -= pushed;\n                        return pushed;\n                    }\n                }\n                return 0;\n            }\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n            public void markDinic(int bfsGen, int curGen) {\n                interestingGeneration = curGen;\n                for (TaskF.Edge e : outgo)\n                    if (e.dest.interestingGeneration < curGen && e.dest.generation == bfsGen && e.dest.dist == dist - 1 && e.rev.flow < e.rev.cap) {\n                        e.dest.markDinic(bfsGen, curGen);\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDinic(s, t, all.size());\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        boolean bfs(TaskF.Vertex s, TaskF.Vertex t, TaskF.Vertex[] q, int curGen) {\n            int qh = 0, qt = 0;\n            q[qt++] = s;\n            s.generation = curGen;\n            s.dist = 0;\n            while (t.generation < curGen && qh < qt) {\n                TaskF.Vertex v = q[qh++];\n                for (TaskF.Edge e : v.outgo) {\n                    if (e.dest.generation < curGen && e.flow < e.cap) {\n                        e.dest.generation = curGen;\n                        q[qt++] = e.dest;\n                        e.dest.dist = v.dist + 1;\n                    }\n                }\n            }\n            return t.generation == curGen;\n        }\n\n        int maxFlowDinic(TaskF.Vertex s, TaskF.Vertex t, int nv) {\n            int flow = 0;\n            int curGen = 0;\n            TaskF.Vertex[] q = new TaskF.Vertex[nv];\n            for (; ; ) {\n                ++curGen;\n                if (!bfs(s, t, q, curGen)) break;\n                ++curGen;\n                t.markDinic(curGen - 1, curGen);\n                while (true) {\n                    int pushed = s.dfsDinic(t, curGen, INF);\n                    if (pushed == 0) break;\n                    flow += pushed;\n                }\n            }\n            return flow;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int interestingGeneration = 0;\n            int nextEdge = 0;\n            int dist;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            int dfsDinic(TaskF.Vertex t, int curGen, int got) {\n                if (got == 0) return 0;\n                if (this == t) return got;\n                if (interestingGeneration != curGen) return 0;\n                if (generation < curGen) {\n                    generation = curGen;\n                    nextEdge = 0;\n                }\n                for (; nextEdge < outgo.size(); ++nextEdge) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.dest.dist != dist + 1) continue;\n                    int pushed = e.dest.dfs(t, curGen, Math.min(got, e.cap - e.flow));\n                    if (pushed > 0) {\n                        e.flow += pushed;\n                        e.rev.flow -= pushed;\n                        return pushed;\n                    }\n                }\n                return 0;\n            }\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n            public void markDinic(int bfsGen, int curGen) {\n                interestingGeneration = curGen;\n                for (TaskF.Edge e : outgo)\n                    if (e.dest.interestingGeneration < curGen && e.dest.generation == bfsGen && e.dest.dist == dist - 1 && e.rev.flow < e.rev.cap) {\n                        e.dest.markDinic(bfsGen, curGen);\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\t\n\tList<Integer>[] where;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint[][] a = new int[n - 1][];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint k = nextInt();\n\t\t\ta[i] = new int[k];\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\ta[i][j] = nextInt() - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\twhere = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhere[i] = new ArrayList<>();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\twhere[v].add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tFlowGraph g = new FlowGraph(2 * n + 1, 2 * n - 1, 2 * n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.addDirectedEdge(g.S, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tg.addDirectedEdge(i + n, g.T, 1);\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\tg.addDirectedEdge(v, i + n, 1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (g.maxFlow() != n - 1) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tmatch = new int[n - 1];\n\t\t\n\t\tArrays.fill(match, -1);\n\t\tint src = -1;\n\t\touter: for (int i = 0; i < n; i++) {\n\t\t\tfor (FlowEdge e : g.g[i]) {\n\t\t\t\tif (e.flow == 1) {\n\t\t\t\t\tmatch[e.to - n] = i;\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsrc = i;\n\t\t}\n\t\t\n\t\tvis1 = new boolean[n];\n\t\tvis2 = new boolean[n];\n\t\tdfs(src);\n\t\t\n\t\tif (ans.size() == 2 * n - 2) {\n\t\t\tfor (int i = 0; i < ans.size(); i += 2) {\n\t\t\t\tout.println((ans.get(i) + 1) + \" \" + (ans.get(i + 1) + 1));\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tout.println(-1);\n\t}\n\t\n\tboolean[] vis1, vis2;\n\tint[] match;\n\t\n\tList<Integer> ans = new ArrayList<>();\n\t\n\tvoid dfs(int v) {\n\t\tvis1[v] = true;\n\t\tfor (int u : where[v]) {\n\t\t\tif (vis2[u]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis2[u] = true;\n\t\t\tif (vis1[match[u]]) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tans.add(v);\n\t\t\tans.add(match[u]);\n\t\t\tdfs(match[u]);\n\t\t}\n\t}\n\t\n\tstatic class FlowGraph {\n\t\tint N, S, T;\n\t\tstatic final int INF = Integer.MAX_VALUE / 3;\n\n\t\tList<FlowEdge>[] g;\n\n\t\tprivate int[] dist;\n\t\tprivate Deque<Integer> q;\n\t\tprivate int[] ptr;\n\n\t\tpublic FlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tdist = new int[N];\n\t\t\tq = new ArrayDeque<>();\n\t\t\tptr = new int[N];\n\t\t}\n\n\t\tpublic void addDirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, 0);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tpublic void addUndirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, cap);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tprivate boolean bfs() {\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[S] = 0;\n\t\t\tq.clear();\n\t\t\tq.add(S);\n\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint v = q.poll();\n\t\t\t\tList<FlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow < e.cap && dist[e.to] > dist[v] + 1) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\t\tq.add(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist[T] != INF;\n\t\t}\n\n\t\tprivate int dfs(int v, int curFlow) {\n\t\t\tif (v == T)\n\t\t\t\treturn curFlow;\n\t\t\tList<FlowEdge> adj = g[v];\n\t\t\tfor (; ptr[v] < adj.size(); ptr[v]++) {\n\t\t\t\tFlowEdge e = adj.get(ptr[v]);\n\t\t\t\tif (dist[e.to] == dist[v] + 1 && e.flow != e.cap) {\n\t\t\t\t\tint go = dfs(e.to, Math.min(curFlow, e.cap - e.flow));\n\t\t\t\t\tif (go != 0) {\n\t\t\t\t\t\te.flow += go;\n\t\t\t\t\t\te.rev.flow -= go;\n\t\t\t\t\t\treturn go;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic int maxFlow() {\n\t\t\tint flow = 0;\n\n\t\t\twhile (bfs()) {\n\t\t\t\tArrays.fill(ptr, 0);\n\t\t\t\tint addFlow;\n\t\t\t\tdo {\n\t\t\t\t\taddFlow = dfs(S, INF);\n\t\t\t\t\tflow += addFlow;\n\t\t\t\t} while (addFlow > 0);\n\t\t\t}\n\n\t\t\treturn flow;\n\t\t}\n\n\t}\n\n\tstatic class FlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tFlowEdge rev;\n\n\t\tpublic FlowEdge(int to, int cap) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t}\n\t}\n\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n\n\tList<Integer>[] where;\n\n\tvoid submit() {\n\t\tint n = nextInt();\n\t\tint[][] a = new int[n - 1][];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tint k = nextInt();\n\t\t\ta[i] = new int[k];\n\t\t\tfor (int j = 0; j < k; j++) {\n\t\t\t\ta[i][j] = nextInt() - 1;\n\t\t\t}\n\t\t}\n\n\t\twhere = new List[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhere[i] = new ArrayList<>();\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\twhere[v].add(i);\n\t\t\t}\n\t\t}\n\n\t\tFlowGraph g = new FlowGraph(2 * n + 1, 2 * n - 1, 2 * n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg.addDirectedEdge(g.S, i, 1);\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tg.addDirectedEdge(i + n, g.T, 1);\n\t\t}\n\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tfor (int v : a[i]) {\n\t\t\t\tg.addDirectedEdge(v, i + n, 1);\n\t\t\t}\n\t\t}\n\n\t\tif (g.maxFlow() != n - 1) {\n\t\t\tout.println(-1);\n\t\t\treturn;\n\t\t}\n\n\t\tmatch = new int[n - 1];\n\n\t\tArrays.fill(match, -1);\n\t\tint src = -1;\n\t\touter: for (int i = 0; i < n; i++) {\n\t\t\tfor (FlowEdge e : g.g[i]) {\n\t\t\t\tif (e.flow == 1) {\n\t\t\t\t\tmatch[e.to - n] = i;\n\t\t\t\t\tcontinue outer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsrc = i;\n\t\t}\n\n\t\tvis1 = new boolean[n];\n\t\tvis2 = new boolean[n];\n\n\t\tans = new int[2 * n - 2];\n\t\tArrays.fill(ans, -1);\n\n\t\tdfs(src);\n\n\t\tif (Arrays.stream(ans).anyMatch(x -> x == -1)) {\n\t\t\tout.println(-1);\n\t\t} else {\n\t\t\tfor (int i = 0; i < ans.length; i += 2) {\n\t\t\t\tout.println((ans[i] + 1) + \" \" + (ans[i + 1] + 1));\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean[] vis1, vis2;\n\tint[] match;\n\n\tint[] ans;\n\n\tvoid dfs(int v) {\n\t\tvis1[v] = true;\n\t\tfor (int u : where[v]) {\n\t\t\tif (vis2[u]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis2[u] = true;\n\t\t\tif (vis1[match[u]]) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tans[2 * u] = v;\n\t\t\tans[2 * u + 1] = match[u];\n\t\t\tdfs(match[u]);\n\t\t}\n\t}\n\n\tstatic class FlowGraph {\n\t\tint N, S, T;\n\t\tstatic final int INF = Integer.MAX_VALUE / 3;\n\n\t\tList<FlowEdge>[] g;\n\n\t\tprivate int[] dist;\n\t\tprivate Deque<Integer> q;\n\t\tprivate int[] ptr;\n\n\t\tpublic FlowGraph(int n, int s, int t) {\n\t\t\tN = n;\n\t\t\tS = s;\n\t\t\tT = t;\n\t\t\tg = new List[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\t}\n\t\t\tdist = new int[N];\n\t\t\tq = new ArrayDeque<>();\n\t\t\tptr = new int[N];\n\t\t}\n\n\t\tpublic void addDirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, 0);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tpublic void addUndirectedEdge(int v1, int v2, int cap) {\n\t\t\tFlowEdge e1 = new FlowEdge(v2, cap);\n\t\t\tFlowEdge e2 = new FlowEdge(v1, cap);\n\t\t\te1.rev = e2;\n\t\t\te2.rev = e1;\n\t\t\tg[v1].add(e1);\n\t\t\tg[v2].add(e2);\n\t\t}\n\n\t\tprivate boolean bfs() {\n\t\t\tArrays.fill(dist, INF);\n\t\t\tdist[S] = 0;\n\t\t\tq.clear();\n\t\t\tq.add(S);\n\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tint v = q.poll();\n\t\t\t\tList<FlowEdge> adj = g[v];\n\t\t\t\tfor (int i = 0; i < adj.size(); i++) {\n\t\t\t\t\tFlowEdge e = adj.get(i);\n\t\t\t\t\tif (e.flow < e.cap && dist[e.to] > dist[v] + 1) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t\t\t\tq.add(e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn dist[T] != INF;\n\t\t}\n\n\t\tprivate int dfs(int v, int curFlow) {\n\t\t\tif (v == T)\n\t\t\t\treturn curFlow;\n\t\t\tList<FlowEdge> adj = g[v];\n\t\t\tfor (; ptr[v] < adj.size(); ptr[v]++) {\n\t\t\t\tFlowEdge e = adj.get(ptr[v]);\n\t\t\t\tif (dist[e.to] == dist[v] + 1 && e.flow != e.cap) {\n\t\t\t\t\tint go = dfs(e.to, Math.min(curFlow, e.cap - e.flow));\n\t\t\t\t\tif (go != 0) {\n\t\t\t\t\t\te.flow += go;\n\t\t\t\t\t\te.rev.flow -= go;\n\t\t\t\t\t\treturn go;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic int maxFlow() {\n\t\t\tint flow = 0;\n\n\t\t\twhile (bfs()) {\n\t\t\t\tArrays.fill(ptr, 0);\n\t\t\t\tint addFlow;\n\t\t\t\tdo {\n\t\t\t\t\taddFlow = dfs(S, INF);\n\t\t\t\t\tflow += addFlow;\n\t\t\t\t} while (addFlow > 0);\n\t\t\t}\n\n\t\t\treturn flow;\n\t\t}\n\n\t}\n\n\tstatic class FlowEdge {\n\t\tint to;\n\t\tint flow, cap;\n\n\t\tFlowEdge rev;\n\n\t\tpublic FlowEdge(int to, int cap) {\n\t\t\tthis.to = to;\n\t\t\tthis.cap = cap;\n\t\t}\n\t}\n\n\tvoid test() {\n\n\t}\n\n\tvoid stress() {\n\t\tfor (int tst = 0;; tst++) {\n\t\t\tif (false) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tSystem.err.println(tst);\n\t\t}\n\t}\n\n\tMain() throws IOException {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tsubmit();\n\t\t// stress();\n\t\t// test();\n\t\tout.close();\n\t}\n\n\tstatic final Random rng = new Random();\n\tstatic final int C = 5;\n\n\tstatic int rand(int l, int r) {\n\t\treturn l + rng.nextInt(r - l + 1);\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main();\n\t}\n\n\tprivate InputStream is;\n\tPrintWriter out;\n\n\tprivate byte[] buf = new byte[1 << 14];\n\tprivate int bufSz = 0, bufPtr = 0;\n\n\tprivate int readByte() {\n\t\tif (bufSz == -1)\n\t\t\tthrow new RuntimeException(\"Reading past EOF\");\n\t\tif (bufPtr >= bufSz) {\n\t\t\tbufPtr = 0;\n\t\t\ttry {\n\t\t\t\tbufSz = is.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t\tif (bufSz <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[bufPtr++];\n\t}\n\n\tprivate boolean isTrash(int c) {\n\t\treturn c < 33 || c > 126;\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isTrash(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tString nextToken() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tString nextString() {\n\t\tint b = readByte();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!isTrash(b) || b == ' ') {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() {\n\t\treturn (char) skip();\n\t}\n\n\tint nextInt() {\n\t\tint ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tlong nextLong() {\n\t\tlong ret = 0;\n\t\tint b = skip();\n\t\tif (b != '-' && (b < '0' || b > '9')) {\n\t\t\tthrow new InputMismatchException();\n\t\t}\n\t\tboolean neg = false;\n\t\tif (b == '-') {\n\t\t\tneg = true;\n\t\t\tb = readByte();\n\t\t}\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tret = ret * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\tif (b != -1 && !isTrash(b)) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\treturn neg ? -ret : ret;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final int INF = (int) 1e9;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, int cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            int flow = maxFlowDfs(s, t);\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private int maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            int res = 0;\n            while (true) {\n                ++curGen;\n                int by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            int cap = 0;\n            int flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int nextEdge = 0;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            public int dfs(TaskF.Vertex t, int curGen, int max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        int nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FConstructionOfATree solver = new FConstructionOfATree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FConstructionOfATree {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[][] w = new int[n - 1][];\n            for (int i = 0; i < n - 1; i++) {\n                w[i] = in.readIntArray(in.readInt());\n            }\n            MiscUtils.decreaseByOne(w);\n            Graph graph = new Graph(2 * n);\n            int source = n - 1;\n            int sink = n;\n            for (int i = 0; i < n - 1; i++) {\n                graph.addFlowEdge(source, i, 1);\n                for (int j : w[i]) {\n                    if (j != 0) {\n                        graph.addFlowEdge(i, n + j, 1);\n                    }\n                }\n                graph.addFlowEdge(n + 1 + i, sink, 1);\n            }\n            long flow = MaxFlow.dinic(graph, source, sink);\n            if (flow != n - 1) {\n                out.printLine(-1);\n                return;\n            }\n            int[] vertex = new int[n - 1];\n            for (int i = 0; i < graph.edgeCount(); i++) {\n                if (graph.flow(i) == 1 && graph.source(i) < n - 1 && graph.destination(i) > n) {\n                    vertex[graph.source(i)] = graph.destination(i) - n;\n                }\n            }\n            int[][] answer = new int[n - 1][2];\n            IntList[] connected = new IntList[n];\n            for (int i = 0; i < n; i++) {\n                connected[i] = new IntArrayList(1);\n            }\n            for (int i = 0; i < n - 1; i++) {\n                for (int j : w[i]) {\n                    connected[j].add(i);\n                }\n            }\n            int[] queue = new int[n];\n            boolean[] done = new boolean[n - 1];\n            int size = 1;\n            for (int i = 0; i < size; i++) {\n                int current = queue[i];\n                for (int j : connected[current]) {\n                    if (!done[j]) {\n                        done[j] = true;\n                        queue[size++] = vertex[j];\n                        answer[j][0] = current + 1;\n                        answer[j][1] = vertex[j] + 1;\n                    }\n                }\n            }\n            if (size < n) {\n                out.printLine(-1);\n                return;\n            }\n            for (int[] row : answer) {\n                out.printLine(row);\n            }\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public boolean isEmpty() {\n            return size() == 0;\n        }\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class MiscUtils {\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static interface IntQueue extends IntCollection {\n        public int poll();\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static class IntArrayQueue implements IntQueue {\n        private int[] data;\n        private int from;\n        private int to;\n\n        public IntArrayQueue(int capacity) {\n            data = new int[Integer.highestOneBit(capacity) << 1];\n        }\n\n        public IntArrayQueue() {\n            this(3);\n        }\n\n        public IntArrayQueue(int[] array) {\n            this(array.length);\n            to = array.length;\n            System.arraycopy(array, 0, data, 0, to);\n        }\n\n        public IntArrayQueue(IntStream s) {\n            addAll(s);\n        }\n\n        public IntArrayQueue(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public int size() {\n            return (to - from) & (data.length - 1);\n        }\n\n        public void add(int v) {\n            ensureCapacity(size() + 1);\n            data[to++] = v;\n            to &= data.length - 1;\n        }\n\n        public int poll() {\n            if (from == to) {\n                throw new NoSuchElementException();\n            }\n            int result = data[from++];\n            from &= data.length - 1;\n            return result;\n        }\n\n        public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at = from;\n\n                public int value() {\n                    if (at == to) {\n                        throw new NoSuchElementException();\n                    }\n                    return data[at];\n                }\n\n                public boolean advance() {\n                    if (!isValid()) {\n                        throw new NoSuchElementException();\n                    }\n                    at++;\n                    at &= data.length - 1;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return at != to;\n                }\n\n                public void remove() {\n                    throw new UnsupportedOperationException();\n                }\n            };\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length <= capacity) {\n                int[] newData = new int[Integer.highestOneBit(capacity) << 1];\n                if (from <= to) {\n                    System.arraycopy(data, from, newData, 0, size());\n                } else {\n                    System.arraycopy(data, from, newData, 0, data.length - from);\n                    System.arraycopy(data, 0, newData, data.length - from, to);\n                }\n                to = size();\n                from = 0;\n                data = newData;\n            }\n        }\n\n    }\n\n    static interface Edge {\n    }\n\n    static class Graph {\n        public static final int REMOVED_BIT = 0;\n        protected int vertexCount;\n        protected int edgeCount;\n        private int[] firstOutbound;\n        private int[] firstInbound;\n        private Edge[] edges;\n        private int[] nextInbound;\n        private int[] nextOutbound;\n        private int[] from;\n        private int[] to;\n        private long[] weight;\n        public long[] capacity;\n        private int[] reverseEdge;\n        private int[] flags;\n\n        public Graph(int vertexCount) {\n            this(vertexCount, vertexCount);\n        }\n\n        public Graph(int vertexCount, int edgeCapacity) {\n            this.vertexCount = vertexCount;\n            firstOutbound = new int[vertexCount];\n            Arrays.fill(firstOutbound, -1);\n\n            from = new int[edgeCapacity];\n            to = new int[edgeCapacity];\n            nextOutbound = new int[edgeCapacity];\n            flags = new int[edgeCapacity];\n        }\n\n        public int addEdge(int fromID, int toID, long weight, long capacity, int reverseEdge) {\n            ensureEdgeCapacity(edgeCount + 1);\n            if (firstOutbound[fromID] != -1) {\n                nextOutbound[edgeCount] = firstOutbound[fromID];\n            } else {\n                nextOutbound[edgeCount] = -1;\n            }\n            firstOutbound[fromID] = edgeCount;\n            if (firstInbound != null) {\n                if (firstInbound[toID] != -1) {\n                    nextInbound[edgeCount] = firstInbound[toID];\n                } else {\n                    nextInbound[edgeCount] = -1;\n                }\n                firstInbound[toID] = edgeCount;\n            }\n            this.from[edgeCount] = fromID;\n            this.to[edgeCount] = toID;\n            if (capacity != 0) {\n                if (this.capacity == null) {\n                    this.capacity = new long[from.length];\n                }\n                this.capacity[edgeCount] = capacity;\n            }\n            if (weight != 0) {\n                if (this.weight == null) {\n                    this.weight = new long[from.length];\n                }\n                this.weight[edgeCount] = weight;\n            }\n            if (reverseEdge != -1) {\n                if (this.reverseEdge == null) {\n                    this.reverseEdge = new int[from.length];\n                    Arrays.fill(this.reverseEdge, 0, edgeCount, -1);\n                }\n                this.reverseEdge[edgeCount] = reverseEdge;\n            }\n            if (edges != null) {\n                edges[edgeCount] = createEdge(edgeCount);\n            }\n            return edgeCount++;\n        }\n\n        protected final GraphEdge createEdge(int id) {\n            return new GraphEdge(id);\n        }\n\n        public final int addFlowWeightedEdge(int from, int to, long weight, long capacity) {\n            if (capacity == 0) {\n                return addEdge(from, to, weight, 0, -1);\n            } else {\n                int lastEdgeCount = edgeCount;\n                addEdge(to, from, -weight, 0, lastEdgeCount + entriesPerEdge());\n                return addEdge(from, to, weight, capacity, lastEdgeCount);\n            }\n        }\n\n        protected int entriesPerEdge() {\n            return 1;\n        }\n\n        public final int addFlowEdge(int from, int to, long capacity) {\n            return addFlowWeightedEdge(from, to, 0, capacity);\n        }\n\n        public final int vertexCount() {\n            return vertexCount;\n        }\n\n        public final int edgeCount() {\n            return edgeCount;\n        }\n\n        public final int firstOutbound(int vertex) {\n            int id = firstOutbound[vertex];\n            while (id != -1 && isRemoved(id)) {\n                id = nextOutbound[id];\n            }\n            return id;\n        }\n\n        public final int nextOutbound(int id) {\n            id = nextOutbound[id];\n            while (id != -1 && isRemoved(id)) {\n                id = nextOutbound[id];\n            }\n            return id;\n        }\n\n        public final int source(int id) {\n            return from[id];\n        }\n\n        public final int destination(int id) {\n            return to[id];\n        }\n\n        public final long capacity(int id) {\n            if (capacity == null) {\n                return 0;\n            }\n            return capacity[id];\n        }\n\n        public final long flow(int id) {\n            if (reverseEdge == null) {\n                return 0;\n            }\n            return capacity[reverseEdge[id]];\n        }\n\n        public final void pushFlow(int id, long flow) {\n            if (flow == 0) {\n                return;\n            }\n            if (flow > 0) {\n                if (capacity(id) < flow) {\n                    throw new IllegalArgumentException(\"Not enough capacity\");\n                }\n            } else {\n                if (flow(id) < -flow) {\n                    throw new IllegalArgumentException(\"Not enough capacity\");\n                }\n            }\n            capacity[id] -= flow;\n            capacity[reverseEdge[id]] += flow;\n        }\n\n        public final boolean flag(int id, int bit) {\n            return (flags[id] >> bit & 1) != 0;\n        }\n\n        public final boolean isRemoved(int id) {\n            return flag(id, REMOVED_BIT);\n        }\n\n        protected void ensureEdgeCapacity(int size) {\n            if (from.length < size) {\n                int newSize = Math.max(size, 2 * from.length);\n                if (edges != null) {\n                    edges = resize(edges, newSize);\n                }\n                from = resize(from, newSize);\n                to = resize(to, newSize);\n                nextOutbound = resize(nextOutbound, newSize);\n                if (nextInbound != null) {\n                    nextInbound = resize(nextInbound, newSize);\n                }\n                if (weight != null) {\n                    weight = resize(weight, newSize);\n                }\n                if (capacity != null) {\n                    capacity = resize(capacity, newSize);\n                }\n                if (reverseEdge != null) {\n                    reverseEdge = resize(reverseEdge, newSize);\n                }\n                flags = resize(flags, newSize);\n            }\n        }\n\n        protected final int[] resize(int[] array, int size) {\n            int[] newArray = new int[size];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            return newArray;\n        }\n\n        private long[] resize(long[] array, int size) {\n            long[] newArray = new long[size];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            return newArray;\n        }\n\n        private Edge[] resize(Edge[] array, int size) {\n            Edge[] newArray = new Edge[size];\n            System.arraycopy(array, 0, newArray, 0, array.length);\n            return newArray;\n        }\n\n        protected class GraphEdge implements Edge {\n            protected int id;\n\n            protected GraphEdge(int id) {\n                this.id = id;\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n    }\n\n    static class MaxFlow {\n        private final Graph graph;\n        private int source;\n        private int destination;\n        private IntQueue queue;\n        private int[] distance;\n        private int[] nextEdge;\n\n        public MaxFlow(Graph graph, int source, int destination) {\n            this.graph = graph;\n            this.source = source;\n            this.destination = destination;\n            int vertexCount = graph.vertexCount();\n            queue = new IntArrayQueue(vertexCount);\n            distance = new int[vertexCount];\n            nextEdge = new int[vertexCount];\n        }\n\n        public static long dinic(Graph graph, int source, int destination) {\n            return new MaxFlow(graph, source, destination).dinic();\n        }\n\n        public long dinic() {\n            long totalFlow = 0;\n            while (true) {\n                edgeDistances();\n                if (distance[destination] == -1) {\n                    break;\n                }\n                Arrays.fill(nextEdge, -2);\n                totalFlow += dinicImpl(source, Long.MAX_VALUE);\n            }\n            return totalFlow;\n        }\n\n        private void edgeDistances() {\n            Arrays.fill(distance, -1);\n            distance[source] = 0;\n            queue.add(source);\n            while (!queue.isEmpty()) {\n                int current = queue.poll();\n                int id = graph.firstOutbound(current);\n                while (id != -1) {\n                    if (graph.capacity(id) != 0) {\n                        int next = graph.destination(id);\n                        if (distance[next] == -1) {\n                            distance[next] = distance[current] + 1;\n                            queue.add(next);\n                        }\n                    }\n                    id = graph.nextOutbound(id);\n                }\n            }\n        }\n\n        private long dinicImpl(int source, long flow) {\n            if (source == destination) {\n                return flow;\n            }\n            if (flow == 0 || distance[source] == distance[destination]) {\n                return 0;\n            }\n            int id = nextEdge[source];\n            if (id == -2) {\n                nextEdge[source] = id = graph.firstOutbound(source);\n            }\n            long totalPushed = 0;\n            while (id != -1) {\n                int nextDestinationID = graph.destination(id);\n                if (graph.capacity(id) != 0 && distance[nextDestinationID] == distance[source] + 1) {\n                    long pushed = dinicImpl(nextDestinationID, Math.min(flow, graph.capacity(id)));\n                    if (pushed != 0) {\n                        graph.pushFlow(id, pushed);\n                        flow -= pushed;\n                        totalPushed += pushed;\n                        if (flow == 0) {\n                            return totalPushed;\n                        }\n                    }\n                }\n                nextEdge[source] = id = graph.nextOutbound(id);\n            }\n            return totalPushed;\n        }\n\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskF {\n        static final long INF = (long) 1e18;\n\n        void addEdge(TaskF.Vertex a, TaskF.Vertex b, long cap) {\n            TaskF.Edge ab = new TaskF.Edge();\n            TaskF.Edge ba = new TaskF.Edge();\n            ab.rev = ba;\n            ab.dest = b;\n            ab.cap = cap;\n            ba.dest = a;\n            ba.rev = ab;\n            a.outgo.add(ab);\n            b.outgo.add(ba);\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<TaskF.Vertex> all = new ArrayList<>();\n            TaskF.Vertex s = new TaskF.Vertex();\n            TaskF.Vertex t = new TaskF.Vertex();\n            all.add(s);\n            all.add(t);\n            TaskF.Vertex[] left = new TaskF.Vertex[n];\n            for (int i = 0; i < n; ++i) {\n                left[i] = new TaskF.Vertex();\n                left[i].tag = i + 1;\n                all.add(left[i]);\n                addEdge(s, left[i], 1);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                TaskF.Vertex cur = new TaskF.Vertex();\n                all.add(cur);\n                cur.tag = i;\n                int count = in.nextInt();\n                addEdge(cur, t, 1);\n                for (int j = 0; j < count; ++j) {\n                    addEdge(left[in.nextInt() - 1], cur, 1);\n                }\n            }\n            long flow = maxFlowDinic(s, t, all.size());\n            if (flow != n - 1) {\n                out.println(-1);\n                return;\n            }\n            for (TaskF.Vertex v : all) {\n                v.generation = 0;\n                v.nextEdge = 0;\n            }\n            flow = maxFlowDfs(s, t);\n            if (flow != 0) {\n                throw new RuntimeException();\n            }\n            for (TaskF.Vertex v : left) {\n                if (v.generation != 1) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            String[] res = new String[n - 1];\n            for (TaskF.Vertex v : left) {\n                if (v.prevInDfs == s) continue;\n                TaskF.Vertex u = v.prevInDfs.prevInDfs;\n                res[v.prevInDfs.tag] = v.tag + \" \" + u.tag;\n            }\n            for (String x : res) {\n                out.println(x);\n            }\n        }\n\n        private long maxFlowDfs(TaskF.Vertex s, TaskF.Vertex t) {\n            int curGen = 0;\n            long res = 0;\n            while (true) {\n                ++curGen;\n                long by = s.dfs(t, curGen, INF);\n                if (by == 0) break;\n                res += by;\n            }\n            return res;\n        }\n\n        boolean bfs(TaskF.Vertex s, TaskF.Vertex t, TaskF.Vertex[] q, int curGen) {\n            int qh = 0, qt = 0;\n            q[qt++] = s;\n            s.generation = curGen;\n            s.dist = 0;\n            while (t.generation < curGen && qh < qt) {\n                TaskF.Vertex v = q[qh++];\n                for (TaskF.Edge e : v.outgo) {\n                    if (e.dest.generation < curGen && e.flow < e.cap) {\n                        e.dest.generation = curGen;\n                        q[qt++] = e.dest;\n                        e.dest.dist = v.dist + 1;\n                    }\n                }\n            }\n            return t.generation == curGen;\n        }\n\n        long maxFlowDinic(TaskF.Vertex s, TaskF.Vertex t, int nv) {\n            long flow = 0;\n            int curGen = 0;\n            TaskF.Vertex[] q = new TaskF.Vertex[nv];\n            for (; ; ) {\n                ++curGen;\n                if (!bfs(s, t, q, curGen)) break;\n                ++curGen;\n                t.markDinic(curGen - 1, curGen);\n                while (true) {\n                    long pushed = s.dfsDinic(t, curGen, INF);\n                    if (pushed == 0) break;\n                    flow += pushed;\n                }\n            }\n            return flow;\n        }\n\n        static class Edge {\n            TaskF.Vertex dest;\n            TaskF.Edge rev;\n            long cap = 0;\n            long flow = 0;\n\n        }\n\n        static class Vertex {\n            int tag = -1;\n            int generation = 0;\n            int interestingGeneration = 0;\n            int nextEdge = 0;\n            int dist;\n            TaskF.Vertex prevInDfs;\n            List<TaskF.Edge> outgo = new ArrayList<>();\n\n            long dfsDinic(TaskF.Vertex t, int curGen, long got) {\n                if (got == 0) return 0;\n                if (this == t) return got;\n                if (interestingGeneration != curGen) return 0;\n                if (generation < curGen) {\n                    generation = curGen;\n                    nextEdge = 0;\n                }\n                for (; nextEdge < outgo.size(); ++nextEdge) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.dest.dist != dist + 1) continue;\n                    long pushed = e.dest.dfs(t, curGen, Math.min(got, e.cap - e.flow));\n                    if (pushed > 0) {\n                        e.flow += pushed;\n                        e.rev.flow -= pushed;\n                        return pushed;\n                    }\n                }\n                return 0;\n            }\n\n            public long dfs(TaskF.Vertex t, int curGen, long max) {\n                if (this == t) return max;\n                generation = curGen;\n                for (int i = 0; i < outgo.size(); ++i) {\n                    TaskF.Edge e = outgo.get(nextEdge);\n                    if (e.flow < e.cap && e.dest.generation < curGen) {\n                        long nmax = Math.min(max, e.cap - e.flow);\n                        if (nmax > 0) {\n                            e.dest.prevInDfs = this;\n                            nmax = e.dest.dfs(t, curGen, nmax);\n                            if (nmax > 0) {\n                                e.flow += nmax;\n                                e.rev.flow -= nmax;\n                                return nmax;\n                            }\n                        }\n                    }\n                    ++nextEdge;\n                    if (nextEdge == outgo.size()) nextEdge = 0;\n                }\n                return 0;\n            }\n\n            public void markDinic(int bfsGen, int curGen) {\n                interestingGeneration = curGen;\n                for (TaskF.Edge e : outgo)\n                    if (e.dest.interestingGeneration < curGen && e.dest.generation == bfsGen && e.dest.dist == dist - 1 && e.rev.flow < e.rev.cap) {\n                        e.dest.markDinic(bfsGen, curGen);\n                    }\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Awk",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fi first\n#define se second\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=5e5+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w;}e[N<<1];int head[N],tot=1;\ninline void add(R int u,R int v,R int w){\n\te[++tot]={v,head[u],w},head[u]=tot;\n\te[++tot]={u,head[v],0},head[v]=tot;\n}\ntypedef pair<int,int> pi;\nvector<int>es[N];int sz[N],chs[N];vector<pi>to[N];\nint cur[N],dep[N],q[N],S,T,n;\ninline int min(R int x,R int y){return x<y?x:y;}\nbool bfs(){\n\tmemset(dep,-1,(T-S+1)<<2);\n\tmemcpy(cur,head,(T-S+1)<<2);\n\tR int h,t,u;q[h=t=1]=S,dep[S]=0;\n\twhile(h<=t){\n\t\tu=q[h++];\n\t\tgo(u)if(e[i].w&&dep[v]==-1)dep[v]=dep[u]+1,q[++t]=v;\n\t}\n\treturn ~dep[T];\n}\nint dfs(int u,int lim){\n\tif(u==T||!lim)return lim;\n\tint flow=0,fl;\n\tgg(u)if(dep[v]==dep[u]+1&&(fl=dfs(v,min(lim,e[i].w)))){\n\t\tflow+=fl,lim-=fl,e[i].w-=fl,e[i^1].w+=fl;\n\t\tif(!lim)break;\n\t}\n\tif(!flow)dep[u]=-1;\n\treturn flow;\n}\nint dinic(){R int res=0;while(bfs())res+=dfs(S,inf);return res;}\nint vis[N],ans[N][2],ret;\nvoid dfs(int u){\n\tvis[u]=1,++ret;\n\tfor(auto v:to[u])if(!vis[v.fi]&&!ans[v.se][0])\n\t\tans[v.se][0]=u,ans[v.se][1]=v.fi,dfs(v.fi);\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d\",&n),S=0,T=n<<1;\n\tfp(i,1,n-1){\n\t\tscanf(\"%d\",&sz[i]),es[i].resize(sz[i]);\n\t\tfp(j,0,sz[i]-1){\n\t\t\tscanf(\"%d\",&es[i][j]);\n\t\t\tif(es[i][j]!=1)add(es[i][j],i+n,1);\n\t\t}\n\t}\n\tR int tc=tot;\n\tfp(i,2,n)add(S,i,1);\n\tfp(i,n+1,T-1)add(i,T,1);\n\tif(dinic()!=n-1)return puts(\"-1\"),0;\n\tfor(R int i=2;i<=tc;i+=2)if(!e[i].w)chs[e[i].v-n]=e[i^1].v;\n\tfp(i,1,n-1)fp(j,0,sz[i]-1)if(es[i][j]!=chs[i])\n\t\tto[es[i][j]].pb(pi(chs[i],i)),to[chs[i]].pb(pi(es[i][j],i));\n\tdfs(1);\n\tif(ret!=n)return puts(\"-1\"),0;\n\tfp(i,1,n-1)printf(\"%d %d\\n\",ans[i][0],ans[i][1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "Ruby",
    "code": "$debug = false\ndef d(*s)\n  pp *s if $debug == true\nend\n\nN = readline.to_i\n\nES = (N-1).times.map do |i|\n  readline.split(' ')[1..-1].map(&:to_i)\nend\n\nd ES\n\n\ndef search(nodes, sets)\n  d \"nodes: #{nodes}, sets: #{sets}\"\n  raise unless nodes.size-1 == sets.size\n  if nodes.size == 2\n    s = ES[sets[0]]\n    if s.include?(nodes[0]) and s.include?(nodes[1])\n      return [ nodes ]\n    else\n      return nil\n    end\n  elsif nodes.size > 2\n    node_to_sets = construct_node_to_sets(nodes,sets)\n    d \"node_to_sets: #{node_to_sets.inspect}\"\n    node_to_sets.each do |node,ss|\n      d \"node: #{node}\"\n      ss.each do |s|\n        next if node == s\n        raise unless sets.include?(s)\n        s2 = sets - [s]\n        d \"s: #{s}, s2: #{s2}\"\n        found = search( nodes-[node], s2 )\n        d \"found : #{found.inspect}\"\n        if found\n          other = ES[s].find {|x| x != node and nodes.include?(x)}\n          found.push([node,other])\n          return found\n        else\n          return nil\n        end\n      end\n    end\n  else\n    raise \"must not happen\"\n  end\nend\n\ndef construct_node_to_sets(nodes, sets)\n  h = Hash.new { [] }\n  sets.each do |i|\n    ES[i].each do |n|\n      h[n] += [i] if nodes.include?(n)\n    end\n  end\n  h.sort_by {|k,v| v.size}\nend\n\n#pp node_eis\nnodes = (1..N).to_a\nsets = (0...ES.size).to_a\n\nd nodes, sets\ntree = search(nodes, sets)\nif tree\n  puts tree.map {|x| x.join(' ')}\nelse\n  puts -1\nend\n"
  },
  {
    "language": "Ruby",
    "code": "$debug = false\ndef d(*s)\n  pp *s if $debug == true\nend\n\nN = readline.to_i\n\nES = (N-1).times.map do |i|\n  readline.split(' ')[1..-1].map(&:to_i)\nend\n\n$memo = {}\n\ndef memo_key(nodes,sets)\n  nodes.join('-') + ',' + sets.join('-')\nend\n\ndef search(nodes, sets)\n  mem_key = memo_key(nodes,sets)\n  if $memo[mem_key]\n    return $memo[mem_key]\n  end\n\n  raise unless nodes.size-1 == sets.size\n  if nodes.size == 2\n    s = ES[sets[0]]\n    if s.include?(nodes[0]) and s.include?(nodes[1])\n      $memo[mem_key] = [nodes]\n      return [ nodes ]\n    else\n      $memo[mem_key] = nil\n      return nil\n    end\n  elsif nodes.size > 2\n    node_to_sets = construct_node_to_sets(nodes,sets)\n    node_to_sets.each do |node,ss|\n      ss.each do |s|\n        next if node == s\n        raise unless sets.include?(s)\n        s2 = sets - [s]\n        found = search( nodes-[node], s2 )\n        if found\n          other = ES[s].find {|x| x != node and nodes.include?(x)}\n          found.push([node,other])\n          $memo[mem_key] = found\n          return found\n        end\n      end\n      $memo[mem_key] = nil\n      return nil\n    end\n  else\n    raise \"must not happen\"\n  end\nend\n\ndef construct_node_to_sets(nodes, sets)\n  h = Hash.new { [] }\n  sets.each do |i|\n    ES[i].each do |n|\n      h[n] += [i] if nodes.include?(n)\n    end\n  end\n  h.sort_by {|k,v| v.size}\nend\n\n#pp node_eis\nnodes = (1..N).to_a\nsets = (0...ES.size).to_a\n\ntree = search(nodes, sets)\nif tree\n  puts tree.map {|x| x.join(' ')}\nelse\n  puts -1\nend\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n:1\n11 & \n & \n\n\n\n\n22\n\n\n1\n\n\n\n\n\n\"\"\"\n\n#RMQ()\n#query,(+1)\n#0OK\n#,0 , (len()+1)//2 \n\ndef make_ST(n,first): #firstn2\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #index(0-origin)pointnum/tree\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query,,,,,\n\n    if r <= a or b <= l: #inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n            \n"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nfrom sys import stdin\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n            \n\n\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#N-1N-1\n#0,N\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n:1\n11 & \n & \n\n\n\n\n22\n\n\n1\n\n\n\n\n\n\n\n==========\n\n1 1&\n\n\ndinic\n\n\"\"\"\n\nfrom sys import stdin\n\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level,cap):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v] and (nex not in cap[v]):\n\n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level,cap)\n            if plusflow == 0:\n                cap[v].add(nex)\n                continue\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n\n            return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        cap = [set() for i in range(N)]\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level,cap)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level,cap)\n            \n\n\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#N-1N-1\n#0,N\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\n\n\"\"\"\n#RMQ()\n#query,(+1)\n#0OK\n#,0 , (len()+1)//2 \n\ndef make_ST(n,first): #firstn2\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #index(0-origin)pointnum/tree\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query,,,,,\n\n    if r <= a or b <= l: #inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n\n#ans\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\"\"\"\n            \n"
  },
  {
    "language": "Python",
    "code": "\nfrom collections import defaultdict\nfrom collections import deque\nimport sys\nfrom sys import stdin\nsys.setrecursionlimit(200000)\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n            \n\n\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#N-1N-1\n#0,N\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n:1\n11 & \n & \n\n\n\n\n22\n\n\n1\n\n\n\n\n\n\n\n==========\n\n1 1&\n\n\ndinic\n\n\"\"\"\n\nfrom collections import defaultdict\nfrom collections import deque\n\ndef Ford_Fulkerson_Func(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n    queue = deque([ [s,float(\"inf\")] ])\n\n    ed = [True] * N\n    ed[s] = False\n\n    route = [0] * N\n    route[s] = -1\n\n    while queue:\n\n        now,flow = queue.pop()\n        for nex in lines[now]:\n\n            if ed[nex]: \n                flow = min(cost[now][nex],flow)\n                route[nex] = now\n                queue.append([nex,flow])\n                ed[nex] = False\n\n                if nex == g:\n                    ans += flow\n                    break\n            \n        else:\n            continue\n        break\n\n    else:\n        return False,ans\n\n\n    t = g\n    s = route[t]\n\n    while s != -1:\n        cost[s][t] -= flow\n        if cost[s][t] == 0:\n            lines[s].remove(t)\n\n        if cost[t][s] == 0:\n            lines[t].add(s)\n        cost[t][s] += flow\n        t = s\n        s = route[t]\n\n    return True,ans\n\ndef Ford_Fulkerson(s,g,lines,cost):\n\n    ans = 0\n\n    while True:\n        fl,nans = Ford_Fulkerson_Func(s,g,lines,cost)\n\n        if fl:\n            ans += nans\n            continue\n        else:\n            break\n    \n    return ans\n\nimport sys\nfrom sys import stdin\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#N-1N-1\n#0,N\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Ford_Fulkerson(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\n\n\"\"\"\n#RMQ()\n#query,(+1)\n#0OK\n#,0 , (len()+1)//2 \n\ndef make_ST(n,first): #firstn2\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #index(0-origin)pointnum/tree\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query,,,,,\n\n    if r <= a or b <= l: #inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n\n#ans\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\"\"\"\n            \n\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n:1\n11 & \n & \n\n\n\n\n22\n\n\n1\n\n\n\n\n\n\"\"\"\n\n#RMQ()\n#query,(+1)\n#0OK\n#,0 , (len()+1)//2 \n\ndef make_ST(n,first): #firstn2\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #index(0-origin)pointnum/tree\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query,,,,,\n\n    if r <= a or b <= l: #inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = []\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans.append((nv+1,newv[c]+1))\n            end[newv[c]] = True\n            q.append(newv[c])\nif len(ans) == N-1:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n            \n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\n\nhttps://atcoder.jp/contests/agc029/tasks/agc029_f\n\n:1\n11 & \n & \n\n\n\n\n22\n\n\n1\n\n\n\n\n\n\n\n==========\n\n1 1&\n\n\ndinic\n\n\"\"\"\n\nfrom collections import defaultdict\nfrom collections import deque\n\ndef Dinic_DFS(v,g,maxflow,lines,cost,level):\n    if v == g:\n        return maxflow\n\n    realflow = 0\n    tmp = [i for i in lines[v]]\n    for nex in tmp:\n        if level[nex] > level[v]:\n            \n            plusflow = Dinic_DFS(nex,g,min(maxflow , cost[v][nex]),lines,cost,level)\n            cost[v][nex] -= plusflow\n            if cost[v][nex] == 0:\n                lines[v].remove(nex)\n            if cost[nex][v] == 0:\n                lines[nex].add(v)\n            cost[nex][v] += plusflow\n            \n            realflow += plusflow\n            maxflow -= plusflow\n\n            if maxflow <= 0:\n                return realflow\n\n    return realflow\n\ndef Dinic(s,g,lines,cost):\n\n    N = len(cost)\n    ans = 0\n\n    while True:\n\n        #bfs\n        q = deque([s])\n        level = [float(\"inf\")] * N\n        level[s] = 0\n        while q:\n            now = q.popleft()\n            #print (now)\n            for nex in lines[now]:\n\n                if level[nex] > level[now] + 1:\n                    level[nex] = level[now] + 1\n                    q.append(nex)\n\n        if level[g] == float(\"inf\"):\n            return ans\n\n        #dfs\n        delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n        while delta_flow > 0:\n            ans += delta_flow\n            delta_flow = Dinic_DFS(s,g,float(\"inf\"),lines,cost,level)\n            \n\nimport sys\nfrom sys import stdin\n\nN = int(stdin.readline())\nw = []\nvtoc = [ [] for i in range(N)]  #\n\nfor loop in range(N-1):\n    \n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\n#N-1N-1\n#0,N\n\nlines = defaultdict(set)\ncost = [ defaultdict(int) for i in range(2*N) ]\nfor i in range(1,N):\n    lines[0].add(i)\n    cost[0][i] = 1\nfor i in range(N+1,2*N):\n    lines[i].add(N)\n    cost[i][N] = 1\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0:\n            lines[i+1].add(N + j)\n            cost[i+1][N + j] =  1\nflow = Dinic(0,N,lines,cost)\nif flow != N-1:\n    print (-1)\n    sys.exit()\n\nnewv = [None] * (N-1)\nfor i in range(N-1):\n    for j in w[i]:\n        if j != 0 and cost[i+1][N + j] == 0:\n            newv[i] = j\n            break\n\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\n\n\"\"\"\n#RMQ()\n#query,(+1)\n#0OK\n#,0 , (len()+1)//2 \n\ndef make_ST(n,first): #firstn2\n\n    i = 0\n    ret = []\n    while 2 ** (i-1) < n:\n\n        for j in range(2 ** i):\n            ret.append(first)\n\n        i += 1\n\n    return ret\n\ndef RMQ_update_point(num,point,tree): #index(0-origin)pointnum/tree\n\n    i = (len(tree) - 1) // 2 + point\n    tree[i] = num\n    while i > 0:\n        i = (i - 1) // 2\n        tree[i] = min(tree[i * 2 + 2] , tree[i * 2 + 1])\n\n    return\n\ndef RMQ_query(a,b,k,l,r,tree): #query,,,,,\n\n    if r <= a or b <= l: #inf\n        return ( float(\"inf\") , float(\"inf\") )\n    \n    if a <= l and r <= b: #\n        return tree[k]\n\n    c1 = RMQ_query(a,b,2*k+1,l,(l+r)//2,tree)\n    c2 = RMQ_query(a,b,2*k+2,(l+r)//2,r,tree)   \n\n    return min(c1,c2)\n\nimport sys\nfrom collections import deque\nN = int(input())\n\nw = []\napp = [0] * N\nvtoc = [ [] for i in range(N)]\n\nfor loop in range(N-1):\n\n    cw = list(map(int,input().split())) \n\n    for i in range(1,cw[0]+1):\n        cw[i] -= 1\n        app[cw[i]] += 1\n        vtoc[cw[i]].append(loop)\n\n    w.append(cw[1:])\n\nnewv = [None] * (N-1)\ntree = make_ST(N,(float(\"inf\"),float(\"inf\")))\n\nfor i in range(1,N):\n    RMQ_update_point((app[i],i),i,tree)\nfor i in range(N-1):\n    nmin,minind = RMQ_query(0,N,0,0,(len(tree)+1)//2,tree)\n    for c in vtoc[minind]:\n        if newv[c] == None:\n            newv[c] = minind\n            for tmpv in w[c]:\n                if tmpv != 0:\n                    tmpmin,minind2 = tree[(len(tree) - 1) // 2 + tmpv]\n                    RMQ_update_point((tmpmin-1,minind2),minind2,tree)\n            RMQ_update_point((float(\"inf\"),minind),minind,tree)\n            break\n    else:\n        #print (newv)\n        print (-1)\n        sys.exit()\n\n\n#ans\n#print (newv)\nend = [False] * N\nq = deque([0])\nans = [None] * (N-1)\n\nwhile len(q) > 0:\n    nv = q.popleft()\n    for c in vtoc[nv]:\n        if not end[newv[c]]:\n            ans[c] = (nv+1,newv[c]+1)\n            end[newv[c]] = True\n            q.append(newv[c])\nif None not in ans:\n    for i in ans:\n        print (*i)\nelse:\n    print (-1)\n\n\"\"\"\n            \n\n"
  }
]