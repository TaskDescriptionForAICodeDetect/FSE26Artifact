[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct Mobile {\n    int width;\n    int weight;\n} Mobile;\n\nMobile* createMobile(int width, int weight) {\n    Mobile* m = (Mobile*)malloc(sizeof(Mobile));\n    m->width = width;\n    m->weight = weight;\n    return m;\n}\n\nMobile* combine(Mobile* left, Mobile* right) {\n    int totalWeight = left->weight + right->weight;\n    int leftWidth = left->width;\n    int rightWidth = right->width;\n    int newWidth = leftWidth + rightWidth;\n    int leftDistance = (right->weight * rightWidth) / totalWeight;\n    int rightDistance = (left->weight * leftWidth) / totalWeight;\n    if (leftDistance * totalWeight != right->weight * rightWidth || \n        rightDistance * totalWeight != left->weight * leftWidth) {\n        return NULL;\n    }\n    return createMobile(newWidth, totalWeight);\n}\n\nMobile* findWidestMobile(int* stones, int n, int roomWidth, int index, Mobile* current) {\n    if (index == n) {\n        if (current->width < roomWidth) {\n            return current;\n        } else {\n            return NULL;\n        }\n    }\n\n    Mobile* without = findWidestMobile(stones, n, roomWidth, index + 1, current);\n    Mobile* newMobile = createMobile(1, stones[index]);\n    Mobile* combined = combine(current, newMobile);\n    Mobile* with = NULL;\n    if (combined != NULL) {\n        with = findWidestMobile(stones, n, roomWidth, index + 1, combined);\n        free(combined);\n    }\n    free(newMobile);\n\n    Mobile* best = NULL;\n    if (with != NULL && (without == NULL || with->width > without->width)) {\n        best = with;\n    } else if (without != NULL) {\n        best = without;\n    }\n\n    return best;\n}\n\nint widestMobile(int* stones, int n, int roomWidth) {\n    if (n == 0) return -1;\n    Mobile* initial = createMobile(1, stones[0]);\n    Mobile* result = findWidestMobile(stones, n, roomWidth, 1, initial);\n    int width = -1;\n    if (result != NULL) {\n        width = result->width;\n        free(result);\n    }\n    free(initial);\n    return width;\n}\n\nint main() {\n    int n, roomWidth;\n    scanf(\"%d %d\", &n, &roomWidth);\n    int* stones = (int*)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &stones[i]);\n    }\n    int result = widestMobile(stones, n, roomWidth);\n    printf(\"%d\\n\", result);\n    free(stones);\n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public static int widestMobile(int[] weights, int roomWidth) {\n        int n = weights.length;\n        \n        // Helper function to recursively find mobile width\n        class MobileInfo {\n            int width;\n            int totalWeight;\n            \n            MobileInfo(int width, int totalWeight) {\n                this.width = width;\n                this.totalWeight = totalWeight;\n            }\n        }\n        \n        // Memoization to store intermediate results\n        Map<String, MobileInfo> memo = new HashMap<>();\n        \n        MobileInfo buildMobile(int[] subWeights) {\n            // Base case: single stone\n            if (subWeights.length == 1) {\n                return new MobileInfo(0, subWeights[0]);\n            }\n            \n            // Check memoized results\n            String key = Arrays.toString(subWeights);\n            if (memo.containsKey(key)) {\n                return memo.get(key);\n            }\n            \n            int bestWidth = -1;\n            int bestTotalWeight = -1;\n            \n            // Try all possible splits\n            for (int leftLen = 1; leftLen < subWeights.length; leftLen++) {\n                int[] leftWeights = Arrays.copyOfRange(subWeights, 0, leftLen);\n                int[] rightWeights = Arrays.copyOfRange(subWeights, leftLen, subWeights.length);\n                \n                MobileInfo leftMobile = buildMobile(leftWeights);\n                MobileInfo rightMobile = buildMobile(rightWeights);\n                \n                // Check equilibrium condition\n                if (leftMobile.totalWeight * leftMobile.width == \n                    rightMobile.totalWeight * rightMobile.width) {\n                    \n                    int currentWidth = leftMobile.width + rightMobile.width + 1;\n                    int totalWeight = leftMobile.totalWeight + rightMobile.totalWeight;\n                    \n                    if (currentWidth > bestWidth) {\n                        bestWidth = currentWidth;\n                        bestTotalWeight = totalWeight;\n                    }\n                }\n            }\n            \n            // Store and return result\n            MobileInfo result = new MobileInfo(bestWidth, bestTotalWeight);\n            memo.put(key, result);\n            return result;\n        }\n        \n        // Check if mobile can be created\n        MobileInfo result = buildMobile(weights);\n        \n        return result.width <= roomWidth ? result.width : -1;\n    }\n}",
    "timestamp": "2025-08-05 19:18:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Mobile {\n    int width;\n    int weight;\n};\n\nMobile makeMobile(int w, int wt) {\n    Mobile m;\n    m.width = w;\n    m.weight = wt;\n    return m;\n}\n\nMobile solve(vector<int>& stones, int roomWidth, int left, int right) {\n    if (left == right) {\n        return makeMobile(1, stones[left]);\n    }\n    \n    vector<Mobile> candidates;\n    for (int i = left; i < right; ++i) {\n        Mobile leftMobile = solve(stones, roomWidth, left, i);\n        Mobile rightMobile = solve(stones, roomWidth, i + 1, right);\n        \n        int totalWeight = leftMobile.weight + rightMobile.weight;\n        int leftWidth = leftMobile.width;\n        int rightWidth = rightMobile.width;\n        \n        int leftArm = (rightMobile.weight * rightWidth) / totalWeight;\n        int rightArm = (leftMobile.weight * leftWidth) / totalWeight;\n        \n        int totalWidth = leftArm + rightArm;\n        if (totalWidth < roomWidth) {\n            candidates.push_back(makeMobile(totalWidth, totalWeight));\n        }\n    }\n    \n    if (candidates.empty()) {\n        return makeMobile(-1, -1);\n    }\n    \n    auto maxWidthMobile = *max_element(candidates.begin(), candidates.end(),\n        [](const Mobile& a, const Mobile& b) {\n            return a.width < b.width;\n        });\n    \n    return maxWidthMobile;\n}\n\nint main() {\n    int N, W;\n    cin >> N >> W;\n    vector<int> stones(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> stones[i];\n    }\n    \n    Mobile result = solve(stones, W, 0, N - 1);\n    cout << (result.width == -1 ? -1 : result.width) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:19:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\ntypedef struct Mobile {\n    int weight;\n    int width;\n    struct Mobile* left;\n    struct Mobile* right;\n} Mobile;\n\nMobile* createMobile(int weight) {\n    Mobile* mobile = malloc(sizeof(Mobile));\n    mobile->weight = weight;\n    mobile->width = 0;\n    mobile->left = NULL;\n    mobile->right = NULL;\n    return mobile;\n}\n\nbool canCreateMobile(int* stones, int n, int roomWidth) {\n    return n > 0;\n}\n\nMobile* buildMobile(int* stones, int n, int roomWidth, int* totalWidth) {\n    if (n == 0) return NULL;\n    if (n == 1) {\n        Mobile* mobile = createMobile(stones[0]);\n        *totalWidth = 0;\n        return mobile;\n    }\n\n    for (int leftCount = 1; leftCount < n; leftCount++) {\n        int rightCount = n - leftCount;\n        int totalWeight = 0;\n        for (int i = 0; i < n; i++) totalWeight += stones[i];\n\n        Mobile* mobile = createMobile(totalWeight);\n        int leftWidth = 0, rightWidth = 0;\n        int* leftStones = malloc(leftCount * sizeof(int));\n        int* rightStones = malloc(rightCount * sizeof(int));\n\n        for (int i = 0; i < leftCount; i++) leftStones[i] = stones[i];\n        for (int i = 0; i < rightCount; i++) rightStones[i] = stones[leftCount + i];\n\n        mobile->left = buildMobile(leftStones, leftCount, roomWidth, &leftWidth);\n        mobile->right = buildMobile(rightStones, rightCount, roomWidth, &rightWidth);\n\n        int leftWeight = mobile->left ? mobile->left->weight : 0;\n        int rightWeight = mobile->right ? mobile->right->weight : 0;\n\n        int width = leftWidth + rightWidth + 1;\n        if (leftWeight * (leftWidth + 1) == rightWeight * (rightWidth + 1) && width <= roomWidth) {\n            mobile->width = width;\n            *totalWidth = width;\n            free(leftStones);\n            free(rightStones);\n            return mobile;\n        }\n\n        free(leftStones);\n        free(rightStones);\n    }\n\n    return NULL;\n}\n\nint findWidestMobile(int* stones, int n, int roomWidth) {\n    if (!canCreateMobile(stones, n, roomWidth)) return -1;\n\n    int totalWidth = 0;\n    Mobile* mobile = buildMobile(stones, n, roomWidth, &totalWidth);\n\n    return mobile ? totalWidth : -1;\n}",
    "timestamp": "2025-08-05 19:19:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\n\nclass Solution {\npublic:\n    int widestMobile(std::vector<int>& stones, int roomWidth) {\n        int n = stones.size();\n        if (n == 0) return -1;\n        if (n == 1) return 0;\n\n        return buildMobile(stones, 0, n - 1, roomWidth).first;\n    }\n\nprivate:\n    std::pair<int, int> buildMobile(std::vector<int>& stones, int left, int right, int maxWidth) {\n        if (left == right) return {0, stones[left]};\n\n        int maxPossibleWidth = -1;\n        int totalWeight = 0;\n\n        for (int i = left; i < right; i++) {\n            auto leftResult = buildMobile(stones, left, i, maxWidth);\n            auto rightResult = buildMobile(stones, i + 1, right, maxWidth);\n\n            int leftWidth = leftResult.first;\n            int rightWidth = rightResult.first;\n            int leftWeight = leftResult.second;\n            int rightWeight = rightResult.second;\n\n            int currentWidth = leftWidth + rightWidth + 1;\n            if (currentWidth > maxWidth) continue;\n\n            if (leftWeight * (leftWidth + 1) == rightWeight * (rightWidth + 1)) {\n                maxPossibleWidth = std::max(maxPossibleWidth, currentWidth);\n                totalWeight = leftWeight + rightWeight;\n            }\n        }\n\n        return {maxPossibleWidth, totalWeight};\n    }\n};",
    "timestamp": "2025-08-05 19:19:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MobileDesign {\n    public static int widestMobile(int[] stones, int roomWidth) {\n        int n = stones.length;\n        if (n == 1) {\n            return stones[0] < roomWidth ? stones[0] : -1;\n        }\n        Arrays.sort(stones);\n        List<Integer> list = new ArrayList<>();\n        for (int stone : stones) {\n            list.add(stone);\n        }\n        return dfs(list, roomWidth);\n    }\n\n    private static int dfs(List<Integer> stones, int maxWidth) {\n        if (stones.size() == 1) {\n            return stones.get(0) < maxWidth ? stones.get(0) : -1;\n        }\n        int max = -1;\n        for (int i = 1; i < stones.size(); i++) {\n            List<Integer> leftStones = new ArrayList<>(stones.subList(0, i));\n            List<Integer> rightStones = new ArrayList<>(stones.subList(i, stones.size()));\n            int leftWeight = sum(leftStones);\n            int rightWeight = sum(rightStones);\n            int gcd = gcd(leftWeight, rightWeight);\n            int leftWidth = rightWeight / gcd;\n            int rightWidth = leftWeight / gcd;\n            int leftMaxWidth = (maxWidth - 1) * leftWidth / (leftWidth + rightWidth);\n            int rightMaxWidth = (maxWidth - 1) * rightWidth / (leftWidth + rightWidth);\n            int leftResult = dfs(leftStones, leftMaxWidth);\n            int rightResult = dfs(rightStones, rightMaxWidth);\n            if (leftResult != -1 && rightResult != -1) {\n                int totalWidth = leftResult + rightResult + 1;\n                if (totalWidth < maxWidth && totalWidth > max) {\n                    max = totalWidth;\n                }\n            }\n        }\n        return max;\n    }\n\n    private static int sum(List<Integer> stones) {\n        int sum = 0;\n        for (int stone : stones) {\n            sum += stone;\n        }\n        return sum;\n    }\n\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    public static void main(String[] args) {\n        int[] stones = {1, 2, 3};\n        int roomWidth = 10;\n        System.out.println(widestMobile(stones, roomWidth));\n    }\n}",
    "timestamp": "2025-08-05 19:19:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_balance(dp, left_mass, right_mass, left_part, right_part):\n    if left_mass == 0 and right_mass == 0:\n        return True\n    if left_mass * right_part != right_mass * left_part:\n        return False\n    return True\n\ndef mobile_balance(weights, room_width):\n    n = len(weights)\n    dp = [[-1 for _ in range(room_width + 1)] for _ in range(1<<n)]\n\n    def find_max_width(mask):\n        if dp[mask][0] != -1:\n            return dp[mask][0]\n\n        by_weight = [(weights[i], i) for i in range(n) if (mask & (1 << i)) != 0]\n        total_weight = sum(w for w, _ in by_weight)\n\n        if len(by_weight) == 1:\n            dp[mask][0], dp[mask][1] = 0, total_weight\n            return dp[mask]\n\n        max_width = 0\n\n        for submask in range(mask):\n            if submask & mask == submask:\n                left_mass, left_width = find_max_width(submask)\n                right_mass, right_width = find_max_width(mask ^ submask)\n\n                if is_balance(dp, left_mass, right_mass, left_width, right_width):\n                    mobile_width = left_width + right_width + total_weight\n                \n                    if mobile_width <= room_width:\n                        max_width = max(max_width, mobile_width)\n\n        dp[mask][0], dp[mask][1] = max_width, total_weight\n        return dp[mask]\n\n    result, _ = find_max_width((1 << n) - 1)\n    return result if result > 0 else -1\n\n# Example usage:\nweights = [2, 3, 7, 1]\nroom_width = 15\nprint(mobile_balance(weights, room_width))",
    "timestamp": "2025-08-13 03:28:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\n\npublic class MobileMaker {\n    public int widestMobile(int[] stones, int maxWidth) {\n        int n = stones.length;\n        return widestMobileRecursive(stones, 0, n - 1, maxWidth);\n    }\n\n    private int widestMobileRecursive(int[] stones, int start, int end, int maxWidth) {\n        if (end - start + 1 == 1) {\n            return 0; // Single stone, no width\n        }\n        int maxMobileWidth = -1; // Initialize max width as -1 for no valid mobile\n        for (int pivot = start; pivot < end; pivot++) {\n            int leftWeight = Arrays.stream(stones, start, pivot + 1).sum();\n            int rightWeight = Arrays.stream(stones, pivot + 1, end + 1).sum();\n            if (leftWeight == rightWeight) { // Check for equilibrium\n                int leftWidth = widestMobileRecursive(stones, start, pivot, maxWidth);\n                int rightWidth = widestMobileRecursive(stones, pivot + 1, end, maxWidth);\n                int totalWidth = leftWidth + rightWidth + 1; // Rod width is 1\n                if (totalWidth <= maxWidth) {\n                    maxMobileWidth = Math.max(maxMobileWidth, totalWidth);\n                }\n            }\n        }\n        return maxMobileWidth;\n    }\n\n    public static void main(String[] args) {\n        MobileMaker mobileMaker = new MobileMaker();\n        int[] stones = {1, 2, 1, 2};\n        int maxWidth = 3;\n        System.out.println(mobileMaker.widestMobile(stones, maxWidth)); // Output depends on input test case\n    }\n}",
    "timestamp": "2025-08-13 03:28:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\nint maxWidth = -1;\nint roomWidth;\n\nvoid findWidestMobile(int *weights, int size, int *visited, int depth, int *leftWeights, int *rightWeights, int leftSum, int rightSum, int currentWidth) {\n    if (depth == size) {\n        if (leftSum == rightSum && currentWidth < roomWidth && currentWidth > maxWidth) {\n            maxWidth = currentWidth;\n        }\n        return;\n    }\n\n    for (int i = 0; i < size; i++) {\n        if (!visited[i]) {\n            visited[i] = 1;\n\n            // Try adding the stone to left\n            int newLeftSum = leftSum + weights[i];\n            leftWeights[depth] = weights[i];\n            findWidestMobile(weights, size, visited, depth + 1, leftWeights, rightWeights, newLeftSum, rightSum, currentWidth + 1);\n\n            // Try adding the stone to right\n            leftWeights[depth] = 0; // Remove from left\n            rightWeights[depth] = weights[i]; // Add to right\n            int newRightSum = rightSum + weights[i];\n            findWidestMobile(weights, size, visited, depth + 1, leftWeights, rightWeights, leftSum, newRightSum, currentWidth + 1);\n\n            rightWeights[depth] = 0; // Remove from right\n\n            visited[i] = 0;\n        }\n    }\n}\n\nint main() {\n    int weights[] = {1, 2, 3, 4};\n    int n = sizeof(weights) / sizeof(weights[0]);\n    roomWidth = 10; // Example room width\n\n    int *visited = (int *)calloc(n, sizeof(int));\n    int *leftWeights = (int *)calloc(n, sizeof(int));\n    int *rightWeights = (int *)calloc(n, sizeof(int));\n\n    findWidestMobile(weights, n, visited, 0, leftWeights, rightWeights, 0, 0, 0);\n\n    if (maxWidth == -1) {\n        printf(\"-1\\n\");\n    } else {\n        printf(\"Widest Mobile Width: %d\\n\", maxWidth);\n    }\n\n    free(visited);\n    free(leftWeights);\n    free(rightWeights);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:28:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def create_mobile(stones, room_width):\n    def is_balanced(left_weight, left_dist, right_weight, right_dist):\n        return left_weight * left_dist == right_weight * right_dist\n\n    def find_mobile(remaining_stones):\n        if len(remaining_stones) == 1:\n            return remaining_stones[0], 0\n\n        best_width = -1\n        for i in range(1, len(remaining_stones)):\n            for left_combo in generate_combinations(remaining_stones[:i]):\n                for right_combo in generate_combinations(remaining_stones[i:]):\n                    left_weight, left_stones = left_combo\n                    right_weight, right_stones = right_combo\n                    \n                    for left_dist in range(1, room_width):\n                        for right_dist in range(1, room_width):\n                            total_width = left_dist + right_dist\n                            if total_width >= room_width:\n                                break\n                            \n                            if is_balanced(left_weight, left_dist, right_weight, right_dist):\n                                best_width = max(best_width, total_width)\n\n        return best_width\n\n    def generate_combinations(stones):\n        def backtrack(start, current_weight, current_stones):\n            if start == len(stones):\n                if current_stones:\n                    results.append((current_weight, current_stones))\n                return\n\n            # Include current stone\n            backtrack(start + 1, current_weight + stones[start], \n                      current_stones + [stones[start]])\n            \n            # Skip current stone\n            backtrack(start + 1, current_weight, current_stones)\n\n        results = []\n        backtrack(0, 0, [])\n        return results\n\n    stones.sort(reverse=True)\n    result = find_mobile(stones)\n    return result if result > 0 else -1",
    "timestamp": "2025-08-13 03:29:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(stones, room_width):\n    stones.sort()\n    n = len(stones)\n    dp = {}\n\n    def dfs(left, right):\n        if left == right:\n            return (stones[left], 1)\n        if (left, right) in dp:\n            return dp[(left, right)]\n        max_width = -1\n        total_weight = sum(stones[left:right+1])\n        for i in range(left, right):\n            left_weight, left_width = dfs(left, i)\n            right_weight, right_width = dfs(i+1, right)\n            if left_weight == right_weight:\n                current_width = left_width + right_width\n                if current_width < room_width and current_width > max_width:\n                    max_width = current_width\n        dp[(left, right)] = (total_weight, max_width)\n        return dp[(left, right)]\n\n    _, result = dfs(0, n-1)\n    return result if result != -1 else -1",
    "timestamp": "2025-08-13 03:29:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int widestPossibleMobile(vector<int>& stones, int roomWidth) {\n        int n = stones.size();\n        vector<vector<int>> dp(n, vector<int>(roomWidth + 1, -1));\n        return dfs(stones, roomWidth, 0, roomWidth, dp);\n    }\n    \n    int dfs(vector<int>& stones, int roomWidth, int usedMask, int remainingWidth, vector<vector<int>>& dp) {\n        if (usedMask == (1 << stones.size()) - 1) {\n            return 0;\n        }\n\n        int &res = dp[usedMask][remainingWidth];\n        if (res != -1) return res;\n\n        res = -1;\n        for (int i = 0; i < stones.size(); ++i) {\n            if (!(usedMask & (1 << i))) {\n                for (int j = 1; j < remainingWidth; ++j) {\n                    for (int k = 1; k <= j; ++k) {\n                        if (k != j - k) {\n                            int newMask = usedMask | (1 << i);\n                            int leftWeight = stones[i];\n                            int rightWeight = accumulate(stones.begin(), stones.end(), 0) - leftWeight;\n                            int leftMoment = leftWeight * k;\n                            int rightMoment = rightWeight * (j - k);\n                            if (leftMoment == rightMoment) {\n                                int subRes = dfs(stones, roomWidth, newMask, roomWidth - j, dp);\n                                if (subRes != -1) {\n                                    res = max(res, j + subRes);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    Solution sol;\n    vector<int> stones = {1, 2, 1};\n    int roomWidth = 5;\n    cout << sol.widestPossibleMobile(stones, roomWidth) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:12:30"
  }
]