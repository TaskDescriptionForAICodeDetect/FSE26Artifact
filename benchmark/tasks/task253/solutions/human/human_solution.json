[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)  REP(i,0,n)\nint gcd(int w,int m){\n  return m == 0?w:gcd(m,w%m);\n}\ndouble cost[N][N];\ndouble lcost[N][N];\ndouble rcost[N][N];\nint weight[N][N];\n\ndouble mcm(int n,int *inp,double lim){\n  rep(i,n)rep(j,n)weight[i][j]=0;\n  rep(i,n){\n    rcost[i][i]=lcost[i][i]=cost[i][i]=0;\n    weight[i][i]=inp[i];\n  }\n  \n  for(int l=2;l<n+1;l++){\n    for(int i=0;i<n-l+1;i++){\n      int j = i+l-1;//matrix i to j separated by k\n      cost[i][j]=-1;\n      for(int k=i;k<j;k++){\n\tif ( cost[i][k] == -1 || cost[k+1][j] == -1)continue;\n\tdouble tw=weight[i][k]+weight[k+1][j];\n\tdouble g = gcd(max(weight[i][k],weight[k+1][j]),min(weight[i][k],weight[k+1][j]));\n\tdouble tmpr = max(weight[i][k]/(tw)+rcost[k+1][j],rcost[i][k]-weight[k+1][j]/(tw) );\n\tdouble tmpl = max(weight[k+1][j]/(tw)+lcost[i][k],lcost[k+1][j]-weight[i][k]/(tw) );\n\t\n\n\n\tdouble tmp = tmpr+tmpl;\n\t\n\tif ( tmp <lim-eps && tmp >cost[i][j]){\n\t  cost[i][j]=tmp;\n\t  lcost[i][j]=tmpl;\n\t  rcost[i][j]=tmpr;\n\t  weight[i][j]=weight[k+1][j]+weight[i][k];\n\t}\n\t\n      }\n    }\n  }\n  \n  /*  \n rep(i,n){\n   rep(j,n){\n     cout <<cost[i][j] << \" \";\n   }\n   cout << endl;\n }\n cout << endl;\n cout << \"lcost \" << endl;\n rep(i,n){\n   rep(j,n)printf(\"%.3lf %.3lf : \",lcost[i][j],rcost[i][j]);\n   cout << endl;\n }\n  */\n \n return cost[0][n-1];\n}\n\n//critical case 1\nvoid solve(int n,double w,int *inp){\n sort(inp,inp+n);\n double ans = -1;\n do{\n   //   rep(i,n)cout << inp[i];\n   //cout << endl;\n   double tmp =mcm(n,inp,w);\n   if ( tmp != 0)ans = max(ans,tmp);\n }while( next_permutation(inp,inp+n));\n\n if ( ans == -1)puts(\"-1\");\n else printf(\"%.8lf\\n\",ans);\n\n}\n\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n   solve(n,r,inp);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\nvoid prB(int S){\n  for(int i=0;i<6;i++){\n    int x=(S>>i);\n    cout<<(x&1)<<\" \";\n  }\n  cout<<endl;\n}\ndouble width;\nint n;\nint t[6];\n\nint mem[(1<<7)];\nint calc(int S){\n  if(mem[S]!=-1)return mem[S];\n  int x=S&-S;\n  return mem[S]=calc(S-x)+calc(x);\n}\n\nvector<double> dp[(1<<7)];\nvector<double> dp2[(1<<7)];\nbool vd[(1<<7)];\nvoid rec(int S){\n  if(vd[S])return;\n  vd[S]=true;\n  int sub=S;\n  do{\n    if(sub!=S&&sub!=0){\n      int lS=sub,rS=S-sub;\n      rec(lS);rec(rS);\n      double lsum=calc(lS),rsum=calc(rS);\n    \n      double ld=rsum/(lsum+rsum);\n      double rd=lsum/(lsum+rsum);\n      for(int i=0;i<(int)dp[lS].size();i++){\n\tfor(int j=0;j<(int)dp[rS].size();j++){\n\t  double nl=min(dp[lS][i]-ld,dp[rS][j]+rd);\n\t  double nr=max(dp2[lS][i]-ld,dp2[rS][j]+rd);\n\t  dp[S].push_back(nl);\n\t  dp2[S].push_back(nr);\n\t}\n      }\n    }\n    sub=(sub-1)&S;\n  }while(sub!=S);\n}\n\nvoid solve(){\n  for(int i=0;i<n;i++){\n    vd[(1<<i)]=true;\n    dp[(1<<i)].push_back(0);\n    dp2[(1<<i)].push_back(0);\n  }\n  int U=(1<<n)-1;\n  rec(U);\n  double ans=-1.0;\n  for(int i=0;i<(int)dp[U].size();i++){\n    double d=dp2[U][i]-dp[U][i];\n    if( d < width + 0.00001  )ans=max(ans,d);\n  }\n  if(ans==-1.0)cout<<\"-1\"<<endl;\n  else printf(\"%.10f\\n\",ans);\n}\n\nvoid init(){\n  for(int i=0;i<(1<<7);i++){\n    vd[i]=0;\n    mem[i]=-1;\n    dp[i].clear();\n    dp2[i].clear();\n  }\n  mem[0]=0;\n  for(int i=0;i<n;i++)mem[(1<<i)]=t[i];\n}\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  for(int tc=1;tc<=Tc;tc++){\n    cin>>width>>n;\n    for(int i=0;i<n;i++)cin>>t[i];\n    init();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ndouble R;\nint n, a[100];\n\nstruct ST {\n    double w, a, h;\n    ST() {}\n    ST(double w, double a, double h) : w(w), a(a), h(h) {}\n};\n\nST combine(const ST& p, const ST& q) {\n    const double a = p.h / (p.h+q.h);\n    double l = min(-a-p.a, (1-a)-q.a);\n    double r = max((1-a)+(q.w-q.a), -a+(p.w-p.a));\n    return ST(r-l, -l, p.h+q.h);\n}\n\nvector<ST> calc(int u) {\n    if ((u&(u-1)) == 0) {\n        int ix = -1;\n        rep (i, n) if (u&(1<<i)) ix = i;\n        return vector<ST>(1, ST(0, 0, a[ix]));\n    }\n    vector<ST> ans;\n    rep (b, 1<<n) if ((u&b) == b && b != u && b != 0) {\n        vector<ST> x = calc(b);\n        vector<ST> y = calc(u-b);\n        rep (i, x.size()) rep (j, y.size()) {\n            ans.push_back(combine(x[i], y[j]));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%lf%d\", &R, &n);\n        rep (i, n) scanf(\"%d\", a+i);\n        vector<ST> ws = calc((1<<n)-1);\n        double ans = -1;\n        rep (i, ws.size()) if (ws[i].w < R) ans = max(ans, ws[i].w);\n        if (ans < 0) printf(\"%d\\n\", -1);\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= S; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\nconst int N = 7, M = 1 << N;\nint tr[M];          //-1: root, 0: no use, else:left value\nint value[M];\nint sumvalue[M];\ndouble _left[M], _right[M], cur[M];   //具体的位置\nbool st[N];\ndouble r, ans;   int s;\ndouble _r;\nint q[N];\nvector<double> que;\n\nvoid dfs_value(int u){      //dfs求得左右子树的value\n    if(tr[u] != -1){\n        value[u] = tr[u];\n        return;\n    }\n    dfs_value(u * 2);\n    dfs_value(u * 2 + 1);\n    value[u] = value[u * 2] + value[u * 2 + 1];\n}\n\n\nvoid update(){              //dfs进行更新ans\n    int cnt = 1;\n    int mark = 1;\n\n\n\n    memcpy(value, tr, sizeof value);\n    dfs_value(1);\n\n    int u;\n    double res = 0.0, t = 0.0;\n\n    // 一路向左 加 一路向右\n    double l = 0, r = 0;\n    cur[1] = 0;\n    for(int i = 1; i <= M; i++){\n        if(tr[i] == -1){\n            int x = 2 * i, y = 2 * i + 1;\n            _left[i] = double(value[y]) / (value[x] + value[y]);\n            _right[i] = double(value[x]) / (value[x] + value[y]);\n            cur[x] = cur[i] - _left[i];\n            cur[y] = cur[i] + _right[i];\n            l = min(cur[x], l);\n            r = max(cur[y], r);\n        }\n    }\n\n\n    res = (r - l);\n    if(res <= _r + 0.00000001){\n        ans = max(ans, res);\n    }\n\n    cnt = 1;\n    mark = 1;\n\n    //cout<<\"RES : \"<<res<<endl;\n    //que.push_back(res);\n    /*printf(\"T  : %0.16f\\n\", r - l);\n    printf(\"RES: %0.16f\\n\", res);\n    cout<<\"*************************\\n\";\n    for(int i = 1; i < (2 << s); i++){\n        printf(\"%d \", tr[i]);\n        if(mark == i){\n            cnt *= 2;\n            mark += cnt;\n            cout<<endl;\n        }\n    }\n    cout<<\"*************************\\n\";\n    cnt = 1;\n    mark = 1;\n    cout<<\"*************************\\n\";\n    for(int i = 1; i < (2 << s); i++){\n        printf(\"%d \", value[i]);\n        if(mark == i){\n            cnt *= 2;\n            mark += cnt;\n            cout<<endl;\n        }\n    }\n    cout<<\"*************************\\n\";*/\n\n}\n\n// 二叉树的线性便利\nvoid dfs(int u, int surp, int need){    //need: 是现在需要的， surp 是剩余的\n    if(need < surp) return;\n    //if(u >= (2 << s))   return;\n    //printf(\"U:%d, SURP:%d, NEED:%d\\n\", u, surp, need);\n    if(need == 0){      //递归结束，填坑完毕\n        //调用更新函数\n        update();\n        //cout<<\"*************UPDATE*************\"<<endl;\n        return;\n    }\n\n    if(tr[u / 2] != -1){    //这个点不可以，下一个\n        dfs(u + 1, surp, need);\n        return;\n    }\n\n\n    if(surp < need){    //可以加一个杠\n        int tmp = tr[u];\n        tr[u] = -1;\n        dfs(u + 1, surp + 1, need);\n        tr[u] = tmp;\n    }\n\n    if(surp == 1 && need > 1)   return;     //一定要注意这一个，只剩一下一个位置，不可以放东西了,只允许加杠\n\n    //不加杠\n    for(int i = 1; i <= s; i++){\n        if(st[i])   continue;\n        st[i] = true;\n        int tmp = tr[u];\n        tr[u] = q[i];\n        dfs(u + 1, surp - 1, need - 1);\n        st[i] = false;\n        tr[u] = tmp;\n    }\n    return;\n}\n\nint main()\n{\n    int T;  cin>>T;\n\n    while(T--){\n        cin>>r>>s;\n        _r = r;\n        for(int i = 1; i <= s; i++) scanf(\"%d\", &q[i]);\n        if(s == 1){\n            if(0.0 <= r + 0.0000001){\n                printf(\"%0.16f\\n\", 0.0);\n            }else{\n                cout<<-1<<endl;\n            }\n            continue;\n        }\n\n        memset(tr, 0, sizeof tr);   memset(st, false, sizeof st);\n        ans = -1;\n        tr[1] = -1;\n        dfs(2, 2, s);\n\n        /*for(int i = 0; i < que.size(); i++){\n            printf(\"%0.6f\\n\", que[i]);\n        }*/\n        //printf(\"Ans: %0.6lf\\n\", ans);\n\n\n        if(ans >= -0.001){\n            printf(\"%0.16f\\n\", ans);\n        }else{\n            cout<<-1<<endl;\n        }\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        return true;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,NEXT;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tNEXT.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tNEXT.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,NEXT);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = NEXT.top();\n\t\tNEXT.pop();\n\t\tright = NEXT.top();\n\t\tNEXT.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);\n\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tprintf(\"0.00000000\\n\");\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 105;\nconst double eps = 1e-5;\nint s,w[maxn],t[maxn];\ndouble r;\nbool vis[maxn];\ndouble ans;\ndouble li[maxn],ri[maxn],val[maxn];\nvoid init() {\n\tmemset(vis,false,sizeof(vis));\n\tmemset(w,0,sizeof(w));\n\tmemset(t,0,sizeof(t));\n}\nvoid cal(int num) {\n\tmemset(li,0,sizeof(li));\n\tmemset(ri,0,sizeof(ri));\n\tmemset(val,0,sizeof(val));\n\tfor(int i = num - 1;i >= 1;i--) {\n\t\tif(t[i] == -1) {\n\t\t\tval[i] = val[2*i] + val[2*i+1];\n\t\t\tdouble L = val[2*i+1]/val[i],R = val[2*i]/val[i];\n\t\t\tli[i] = min(li[2*i]-L,li[2*i+1]+R);\n\t\t\tri[i] = max(ri[2*i+1]+R,ri[2*i]-L);\n\t\t}\n\t\telse if(t[i]) val[i] = w[t[i]];\n\t}\n\tdouble temp = ri[1] - li[1];\n\tif(temp - r < eps && temp > ans) ans = temp;\n}\nvoid dfs(int cur,int cnt,int now) {\n\tif(cnt == s) {\n\t\tcal(cur);\n\t\treturn;\t\n\t}\n\tif(t[cur/2] != -1) dfs(cur+1,cnt,now);\n\telse {\n\t\tif(s - cnt > now) {\n\t\t\tt[cur] = -1;\n\t\t\tdfs(cur+1,cnt,now+1);\n\t\t\tt[cur] = 0;\n\t\t}\n\t\tif(now == 1 && s - cnt > now) return; \n\t\tfor(int i = 1;i <= s;i++) {\n\t\t\tif(!vis[i]) {\n\t\t\t\tvis[i] = true;\n\t\t\t\tt[cur] = i;\n\t\t\t\tdfs(cur+1,cnt+1,now-1);\n\t\t\t\tvis[i] = false;\n\t\t\t\tt[cur] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint T;\n\tscanf(\"%d\",&T);\n\twhile(T--) {\n\t\tscanf(\"%lf %d\",&r,&s);\n\t\tinit();\n\t\tfor(int i = 1;i <= s;i++) scanf(\"%d\",&w[i]);\n\t\tif(s == 1) {printf(\"0.00\\n\");continue;}\n\t\tans = -1;\n\t\tt[1] = -1;\n\t\tdfs(2,0,2);\n\t\tif(ans == -1) printf(\"-1\\n\");\n\t\telse printf(\"%.10lf\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <memory>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nstruct node_t {\n\tshared_ptr<node_t> left_child, right_child;\n\n\tinline bool is_leaf() const {\n\t\treturn left_child == nullptr;\n\t}\n\n\tnode_t(const shared_ptr<node_t> &l = nullptr, const shared_ptr<node_t> &r = nullptr):\n\t\tleft_child(l), right_child(r) {}\n};\n\nconstexpr int MAX_S = 6;\n\ntypedef array<vector<shared_ptr<node_t>>, MAX_S + 1> T_array;\ntypedef tuple<int, double, double> result;\nenum { WEIGHT, LEFT, RIGHT };\n\nT_array init_trees() {\n\tT_array trees;\n\n\ttrees[1].emplace_back(new node_t());\n\n\tfor(int s = 2; s <= 6; ++s) {\n\t\tfor(int l = 1; l < s; ++l) {\n\t\t\tconst int r = s - l;\n\n\t\t\tfor(const auto &p1 : trees[l]) {\n\t\t\t\tfor(const auto &p2 : trees[r]) {\n\t\t\t\t\ttrees[s].emplace_back(new node_t(p1, p2));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn trees;\n}\n\nresult dfs(const shared_ptr<node_t> &node, vector<int>::const_iterator &it) {\n\tif(node->is_leaf()) {\n\t\tconst result res(*it, 0.0, 0.0);\n\t\t++it;\n\t\treturn res;\n\t}\n\n\tconst auto l_result = dfs(node->left_child, it);\n\tconst auto r_result = dfs(node->right_child, it);\n\n\tconst int weight = get<WEIGHT>(l_result) + get<WEIGHT>(r_result);\n\n\tconst double left_pos = -static_cast<double>(get<WEIGHT>(r_result)) / weight;\n\tconst double right_pos = static_cast<double>(get<WEIGHT>(l_result)) / weight;\n\n\tconst double left = min(get<LEFT>(l_result) + left_pos, get<LEFT>(r_result) + right_pos);\n\tconst double right = max(get<RIGHT>(l_result) + left_pos, get<RIGHT>(r_result) + right_pos);\n\n\treturn result(weight, left, right);\n}\n\nvoid solve(const T_array &trees) {\n\tdouble r;\n\tint s;\n\tcin >> r >> s;\n\n\tvector<int> w(s);\n\tfor(auto &e : w) cin >> e;\n\n\tsort(w.begin(), w.end());\n\n\tdouble ans = -1;\n\tdo {\n\t\tfor(const auto &root : trees[s]) {\n\t\t\tauto it = w.cbegin();\n\t\t\tconst auto tmp = dfs(root, it);\n\t\t\tconst double width = get<RIGHT>(tmp) - get<LEFT>(tmp);\n\t\t\tif(width < r) chmax(ans, width);\n\t\t}\n\n\t} while(next_permutation(w.begin(), w.end()));\n\n\n\tif(ans < 0) {\n\t\tcout << \"-1\" << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tconst auto trees = init_trees();\n\n\tint T;\n\tcin >> T;\n\n\twhile(T--) solve(trees);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cmath>\n#include<complex>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<string>\n#include<vector>\n\n#define repi(i,a,b) for(int i = int(a); i < int(b); i++)\n#define rep(i,a) repi(i,0,a)\n#define repd(i,a,b) for(int i = int(a); i >= int(b); i--)\n#define repit(i,a) for(__typeof((a).begin()) i = (a).begin(); i != (a).end(); i++)\n#define all(u) (u).begin(),(u).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define UNIQUE(u) (u).erase(unique(all(u)),(u).end())\n#define pb push_back\n#define mp make_pair\nconst double pi = acos(-1.0);\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int N = 6;\n\nint n;\ndouble room, a[6], sum[1 << N];\n\nvoid input()\n{\n    cin >> room >> n;\n    rep(i, n) cin >> a[i];\n\n    sum[0] = 0.0;\n    rep(i, n) sum[1 << i] = a[i];\n    rep(i, 1 << n) if (__builtin_popcount(i) >= 2)\n        sum[i] = sum[i & -i] + sum[i & i - 1];\n}\n\ntypedef pair<double, double> P;\n\nvector<set<P> > dp;\n\nvoid solve()\n{\n    dp.assign(1 << n, set<P>());\n\n    rep(i, n) dp[1 << i].insert(P(0.0, 0.0));\n    rep(s, 1 << n) if (__builtin_popcount(s) >= 2) {\n        for (int t = s; t = t - 1 & s; ) {\n            double r = sum[t] / sum[s], l = 1.0 - r;\n            repit(ii, dp[t]) repit(jj, dp[s ^ t]) {\n                dp[s].insert(P(max(l + ii->first, jj->second - r),\n                               max(r + jj->first, ii->second - l)));\n                dp[s].insert(P(max(l + ii->first, jj->first - r),\n                               max(r + jj->second, ii->second - l)));\n                dp[s].insert(P(max(l + ii->second, jj->second - r),\n                               max(r + jj->first, ii->first - l)));\n                dp[s].insert(P(max(l + ii->second, jj->first - r),\n                               max(r + jj->second, ii->first - l)));\n            }\n        }\n    }\n\n    double ans = -1.0;\n    repit(it, dp[(1 << n) - 1])\n        if (it->first + it->second <= room)\n            ans = max(ans, it->first + it->second);\n\n    if (ans >= 0.0)\n        printf(\"%.16f\\n\", ans);\n    else\n        puts(\"-1\");\n}\n\nsigned main()\n{\n    int T; cin >> T;\n    while (T--) {\n        input();\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble r,w[6],ans,cal,LL,RR;\nint n,t[300],cnt;\n\ndouble s[300];\n\nvoid dfs(int p,double c){\n\n  if(s[p*2+1])dfs(p*2+2,c+s[p*2+1]/s[p]);\n  if(s[p*2+2])dfs(p*2+1,c-s[p*2+2]/s[p]);\n\n  RR=max(c,RR);\n  LL=min(c,LL);\n  \n}\n\ndouble dfs2(int p){\n\n  double rm,lm;\n\n  if(t[p*2+1])lm=dfs2(p*2+1);\n  else s[p*2+1]=lm=w[cnt++];\n  \n  if(t[p*2+2])rm=dfs2(p*2+2);\n  else s[p*2+2]=rm=w[cnt++];\n\n  return s[p]=lm+rm;\n}\n\nvoid check(){\n\n  sort(w,w+n);\n\n  do{\n\n    cnt=0;\n    LL=0,RR=0;\n    memset(s,0,sizeof(s));\n    dfs2(0);\n    dfs(0,0);\n    cal=RR-LL;\n    if(cal<=r)ans=max(ans,cal);\n    \n  }while(next_permutation(w,w+n));\n\n}\n\nvoid dfs1(int p,int c){\n  if(t[p])return;\n  if(c==n){check();return;}\n  t[p]=1;\n\n  for(int i=0;i<16;i++){\n    if(t[i]){\n      dfs1(2*p+1,c+1);\n      dfs1(2*p+2,c+1);\n    }\n  }\n  \n  t[p]=0;\n}\n\n\nint main(){\n\n\n  int T;\n  cin>>T;\n  while(T--){\n    ans=-1;\n    cin>>r>>n;\n    \n    for(int i=0;i<n;i++)cin>>w[i];\n    \n    memset(t,0,sizeof(t));\n    if(2<=n)dfs1(0,1);\n    \n    if(ans==-1)cout<<-1<<endl;\n    else printf(\"%.16f\\n\",ans);\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=(int)b;i<(int)n;i++)\n#define rep(i,n)  REP(i,0,n)\nint gcd(int w,int m){\n  return m == 0?w:gcd(m,w%m);\n}\n\n/*\ndouble tw=weight[i][k]+weight[k+1][j];\ndouble tmpr = max(weight[i][k]/tw+rcost[k+1][j],rcost[i][k]-weight[k+1][j]/tw);\ndouble tmpl = max(weight[k+1][j]/tw+lcost[i][k],lcost[k+1][j]-weight[i][k]/tw );\ndouble tmp = tmpr+tmpl;\nif ( tmp <lim+eps && tmp >cost[i][j]){\n*/\n\ndouble ans = -1;\n\n\nvoid solve(int n,int now,bool *used,double *rc,double *lc,double lim,double c,int *weight){\n  if ( n-1 == now){\n    ans = max(ans,c);\n    return;\n  }\n  \n  //left i , right j\n  rep(i,n){\n    if ( used[i] == true)continue;\n    rep(j,n){\n      if (i == j)continue;\n      if ( used[j] == true)continue;\n      double w = weight[i]+weight[j];\n      double tmpr=max(weight[i]/w+rc[j],-weight[j]/w+rc[i]);\n      double tmpl=max(weight[j]/w+lc[i],-weight[i]/w+lc[j]);\n\n      if ( tmpr+tmpl >lim+eps){continue;}\n      double tr=rc[i],tl=lc[i];int tw=weight[i];\n      used[j]=true;\n      rc[i]=tmpr;\n      lc[i]=tmpl;\n      weight[i]=weight[i]+weight[j];\n      solve(n,now+1,used,rc,lc,lim,tmpr+tmpl,weight);\n      rc[i]=tr;\n      lc[i]=tl;\n      weight[i]=tw;\n      used[j]=false;\n    }\n  }\n  \n}\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n\n   double rc[n],lc[n];\n   bool used[n];\n   rep(i,n)rc[i]=lc[i]=0,used[i]=false;\n   ans=-1;\n\n   solve(n,0,used,rc,lc,r,0,inp);\n   if ( ans == -1)puts(\"-1\");\n   else printf(\"%.9lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\n\n#define lowbit(x) ((x)&(-x))\n\nusing namespace std;\n\nconst double eps=1e-5;\n\nint w[6], n, tw[1<<6], d[1<<6];\ndouble ans, R;\n\nbool dfs(int s, double l, double r, double c)\n{\n    if (r-l>R+eps) return 0;\n    //cout<<\"s=\"<<s<<endl;\n    if (!(s&(s-1)))\n    {\n        ans=max(ans, r-l);\n        return 1;\n    }\n    bool ret=0;\n    for (int t=(s&(s-1)); t; t=s&(t-1))\n    {\n        double kl=1.0*tw[s^t]/tw[s], kr=1.0-kl;\n        //cout<<\"kl=\"<<kl<<\" kr=\"<<kr<<endl;\n        //cout<<\"mid=\"<<mid<<endl;\n        if (dfs(t, min(l,c-kl), max(r,c+kr), c-kl)\n        &&  dfs(s^t, min(l,c-kl), max(r,c+kr), c+kr)) ret=1;\n    }\n    return ret;\n}\n\nint main()\n{\n    for (int i=0; i<6; ++i) d[1<<i]=i;\n    int cas;\n    scanf(\"%d\", &cas);\n    while (cas--)\n    {\n        scanf(\"%lf%d\", &R, &n);\n        for (int i=0; i<n; ++i) scanf(\"%d\", w+i);\n        int lim=1<<n;\n        for (int i=1; i<lim; ++i)\n            tw[i]=tw[i^lowbit(i)]+w[d[lowbit(i)]];\n        ans=0;\n        if (!dfs(lim-1, 0, 0, 0)) puts(\"-1\");\n        else printf(\"%.16f\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        printf(\"%.18lf\\n\", ans);\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\n#define MAX 10\n#define EPS 1e-6\n\nint w[MAX];\nlong double rcost[MAX], lcost[MAX];\nbool used[MAX];\n\nlong double r;\nint n;\nlong double ans;\n\nvoid dfs(int now, long double cost){\n  if(n-1 == now){\n    ans = max(ans, cost);\n    return;\n  }\n  \n  for(int i = 0 ; i < n ; i++){\n    if(used[i]) continue;\n    for(int j = 0 ; j < n ; j++){\n      if(i == j || used[j]) continue;\n      long double weight = w[i] + w[j];\n      long double tmpr = max( (w[i] / weight) + rcost[j], (-w[j] / weight) + rcost[i]);\n      long double tmpl = max( (w[j] / weight) + lcost[i], (-w[i] / weight) + lcost[j]);\n      \n      if(tmpr + tmpl > r+EPS) continue;\n      \n      long double tr = rcost[i], tl = lcost[i], tw = w[i];      \n      rcost[i] = tmpr;\n      lcost[i] = tmpl;\n      w[i] += w[j];\n      used[j] = true;\n      \n      dfs(now+1, tmpr+tmpl);\n      // back track\n      rcost[i] = tr;\n      lcost[i] = tl;\n      w[i] = tw;\n      used[j] = false;\n    }\n  }\n}\n\nvoid init(){\n  ans = -1.0;\n  for(int i = 0 ; i < MAX ; i++) w[i] = rcost[i] = lcost[i] = used[i] = 0;\n}\n\nint main(){\n  int tc;\n  cin >> tc;\n  while(tc--){\n    init();\n    cin >> r >> n;\n    for(int i = 0 ; i < n ; i++) cin >> w[i];\n    dfs(0, 0);\n    cout << setprecision(16);\n    if(ans == -1.0) cout << -1 << endl;\n    else cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<ll,ll> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(ll i=0;i<(int)(n);++i)\n#define REP(i,m,n) for(ll i=m; i<=(int)(n); ++i)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\nll dx[]={0,1,0,-1,1,1,-1,-1};\nll dy[]={1,0,-1,0,-1,1,1,-1};\n\nint w[10];\ntypedef pair<double,double> PD;\ntypedef vector<PD> mo;\nvector<pair<double, double> > memo[1<<6];\nbool vis[1<<6];\ndouble r;\nint s;\nmo rec(int have){\n  if(vis[have]) return memo[have];\n  //cout << have << endl;\n  vis[have] = true;\n  if(__builtin_popcount(have)==1){\n    mo &ret=memo[have];\n    ret.clear();\n    ret.pb(PD(0,0));\n    return ret;\n  }\n\n  mo &ret=memo[have];\n  ret.clear();\n  int sub=(have-1)&have;\n  while(sub){\n    mo a = rec(sub);\n    mo b = rec(have^sub);\n    int wa=0,wb=0;\n    rep(i,s){\n      if((sub>>i)&1) wa += w[i];\n      if((have>>i)&1) wb += w[i];\n    }\n    wb -= wa;\n    double la = wb*1./(wa+wb);\n    double lb = wa*1./(wa+wb);\n    FOR(ita,a)FOR(itb,b){\n      ret.pb(mp(max(lb+itb->F,ita->S-la),\n                max(la+ita->F,itb->S-lb)));\n      ret.pb(mp(max(lb+itb->S,ita->S-la),\n                max(la+ita->F,itb->F-lb)));\n      ret.pb(mp(max(lb+itb->F,ita->F-la),\n                max(la+ita->S,itb->S-lb)));\n      ret.pb(mp(max(lb+itb->S,ita->F-la),\n                max(la+ita->S,itb->F-lb)));\n    }\n    sub=(sub-1)&have;\n  }\n  \n  FOR(it,ret) if(it->F < it->S) swap(it->F,it->S);\n  sort(ALL(ret));\n  ret.erase(unique(ALL(ret)),ret.end());\n  return ret;\n}\n\nvoid solve(){\n  cin >> r >> s;\n  rep(i,s) cin >> w[i];\n  memset(vis,0,sizeof(vis));\n\n  vector<pair<double,double> > ans = rec((1<<s)-1);\n  //cout << SZ(ans) << endl;\n  double out = -1;\n  FOR(it,ans)\n    if(it->F+it->S<r)\n      out = max(out,it->F+it->S);\n\n  printf(\"%.9f\\n\",out);\n}\n\nint main(){\n  int t;\n  cin >> t;\n  rep(i,t) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef pair<double, double> P;\n\nvector<P> rec(vector<double> w){\n    if(w.size() == 0) return vector<P>(); \n    if(w.size() == 1) return vector<P>(1, P(0, 0));\n    int n = w.size();\n    vector<P> res;\n    for(int s = 0; s < (1 << n); s++){\n        vector<double> w1, w2;\n        double s1 = 0, s2 = 0;\n        for(int i = 0; i < n; i++){\n            if(s >> i & 1){\n                s1 += w[i];\n                w1.push_back(w[i]);\n            }else{\n                s2 += w[i];\n                w2.push_back(w[i]);\n            }\n        }\n        if(s1 == 0 || s2 == 0) continue;\n        vector<P> pv1 = rec(w1);\n        vector<P> pv2 = rec(w2);\n        double lx = -s2 / (s1 + s2);\n        double rx = s1 / (s1 + s2);\n        for(int i = 0; i < pv1.size(); i++)\n        for(int j = 0; j < pv2.size(); j++){\n            res.push_back( make_pair( min(pv1[i].first + lx, pv2[j].first + rx), max(pv1[i].second + lx, pv2[j].second + rx) ));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int T;\n    cin >> T;\n    while(T--){\n        double r;\n        cin >> r;\n        int n;\n        cin >> n;\n        vector<double> w(n);\n        REP(i, n) cin >> w[i];\n        vector<P> pv = rec(w);\n        vector<double> cand;\n        for(int i = 0; i < pv.size(); i++){\n            cand.push_back(pv[i].second - pv[i].first);\n        }\n        sort(cand.begin(), cand.end());\n\n        int k = upper_bound(cand.begin(), cand.end(), r) - cand.begin();\n        if(k == 0 || cand.empty()){\n            cout << -1 << endl;\n        }else{\n            printf(\"%.16f\\n\", cand[k - 1]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7];\ndouble room_width;\nchar equation[100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[eq_index++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < num_stone){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\tInfo left_info[12],right_info[12];\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tfor(int i = 0; i < info_index; i++){\n\t\t\tleft_info[i] = tmp_info[i];\n\t\t\tright_info[i] = tmp_info[i];\n\t\t}\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = left_info[left].weight;\n\t\tright_weight = left_info[right].weight;\n\n\t\tleft_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tleft_info[info_index].right = 1.0-left_info[info_index].left;\n\t\tleft_info[info_index].type = Mobile;\n\t\tleft_info[info_index].index_left = left;\n\t\tleft_info[info_index].index_right = right;\n\t\tleft_info[info_index].weight = left_weight+right_weight;\n\t\tleft_info[info_index].most_left_loc = max(left_info[info_index].left+left_info[left].most_left_loc,left_info[right].most_left_loc-left_info[info_index].right);\n\t\tleft_info[info_index].most_right_loc = max(left_info[info_index].right+left_info[right].most_right_loc,left_info[left].most_right_loc-left_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,left_info,info_index+1,S_1);\n\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = right_info[left].weight;\n\t\tright_weight = right_info[right].weight;\n\n\t\tright_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tright_info[info_index].right = 1.0-right_info[info_index].left;\n\t\tright_info[info_index].type = Mobile;\n\t\tright_info[info_index].index_left = left;\n\t\tright_info[info_index].index_right = right;\n\t\tright_info[info_index].weight = left_weight+right_weight;\n\t\tright_info[info_index].most_left_loc = max(right_info[info_index].left+right_info[left].most_left_loc,right_info[right].most_left_loc-right_info[info_index].right);\n\t\tright_info[info_index].most_right_loc = max(right_info[info_index].right+right_info[right].most_right_loc,right_info[left].most_right_loc-right_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,right_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = 0;\n\n\tchar first_buf[12];\n\n\tfor(int i = 0; i < table_index[num_stone]; i++){\n\t\tmakeEquation(table[num_stone][i],0,first_buf,0,0,num_stone-1);\n\t}\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cassert>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\nusing namespace std;\nstruct mobile_t {\n    int w; // weight\n    double l; // left\n    double r; // right\n};\nconst double eps = 0.0001;\ndouble evaluate(vector<int> const & p, double r) {\n    stack<mobile_t> stk;\n    for (int w : p) {\n        if (w == 0) {\n            if (stk.size() < 2) return -1;\n            mobile_t x = stk.top(); stk.pop();\n            mobile_t y = stk.top(); stk.pop();\n            mobile_t z;\n            z.w = x.w + y.w;\n            double dx = y.w /(double) (x.w + y.w);\n            double dy = x.w /(double) (x.w + y.w);\n            z.l = max(x.l + dx, y.l - dy);\n            z.r = max(x.r - dx, y.r + dy);\n            if (r + eps < z.r + z.l) return -1;\n            stk.push(z);\n        } else {\n            stk.push((mobile_t){ w, 0.0, 0.0 });\n        }\n    }\n    if (stk.size() != 1) return -1;\n    return stk.top().l + stk.top().r;\n}\nint main() {\n    int datasets; cin >> datasets;\n    repeat (dataset, datasets) {\n        double r; cin >> r;\n        int s; cin >> s;\n        vector<int> w(s); repeat (i,s) cin >> w[i];\n        double result = -1;\n        vector<int> p;\n        repeat (i,s)   p.push_back(w[i]);\n        repeat (i,s-1) p.push_back(0);\n        sort(p.begin(), p.end());\n        do {\n            result = max(result, evaluate(p, r));\n        } while (next_permutation(p.begin(), p.end()));\n        if (result == -1) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.16lf\\n\", result);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s,sum[10];\ndouble memo[10];\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  if(memo[v]>=0)return memo[v];\n  double res=0;\n  double tmp1=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r+EPS)res=max(res,tmp1);\n  if(tmp2<r+EPS)res=max(res,tmp2);\n  return memo[10]=res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      fill(memo,memo+10,-1);\n      double res=rec(0,1);\n      //printf(\"%.16f\\n\",res);\n      if(res<r+EPS)ans=max(ans,res);\n      res=rec(1,1);\n      if(res<r+EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#define INF (1<<29)\nusing namespace std;\n\nconst double EPS=1e-10;\n\nstruct rod{\n  double l,r,w;\n  rod(double l=0,double r=0,double w=INF):l(l),r(r),w(w){}\n  bool operator < (const rod& a)const{\n    if(!(abs(w-a.w)<EPS))return w<a.w;\n    if(!(abs(l-a.l)<EPS))return l<a.l;\n    return r<a.r;\n  }\n};\n\nrod Merge(rod a,rod b){\n  rod res;\n  res.w=a.w+b.w;\n  double mid=b.w/(a.w+b.w);\n  res.l=min(-b.w/(a.w+b.w)+a.l,b.l+(1-mid));\n  res.r=max(a.w/(a.w+b.w)+b.r,a.r+(1-mid));\n}\n\ndouble r;\n\ndouble rec(vector<rod>v){\n  int vl=v.size();\n  for(int i=0;i<vl;i++){\n    for(int j=i+1;j<vl;j++){\n      vector<rod>nx;\n      for(int k=0;k<vl;k++){\n        if(k==i || k==j)continue;\n        nx.push_back(v[k]);\n      }\n      nx.push_back(Merge(v[i],v[j]));\n      rec(nx);\n    }\n  }\n\n}\n\nint main(void){\n\n  int T;\n  cin >> T;\n  while(T--){\n    int s;\n    cin >> r >> s;\n    vector<rod>v(s);\n    for(int i=0;i<s;i++)cin >> v[i].w;\n    printf(\"%.16f\\n\",rec(v));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s,sum[10];\ndouble memo[10];\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  if(memo[v]>=0)return memo[v];\n  double res=0;\n  double tmp1=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r+EPS)res=max(res,tmp1);\n  if(tmp2<r+EPS)res=max(res,tmp2);\n  return memo[10]=res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      fill(memo,memo+10,-1);\n      double res=rec(0,1);\n      if(res<r+EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=-1;\n  double tmp1=rec(v+1,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+1,L+w[v+1]/(w[v]+w[v+1]));\n  double tmp3=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp4=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  if(tmp3<r-EPS)res=max(res,tmp3);\n  if(tmp4<r-EPS)res=max(res,tmp4);\n\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n    if(s==1){\n      printf(\"0.0000000000\\n\");\n      continue;\n     }\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(1,1.0);\n      if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= S; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        printf(\"%.18lf\\n\", ans);\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (pat[0] <= 0) continue;\n            if (pat[0] >= (S + 1) / 2) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\tInfo left_info[12],right_info[12];\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tfor(int i = 0; i < info_index; i++){\n\t\t\tleft_info[i] = tmp_info[i];\n\t\t\tright_info[i] = tmp_info[i];\n\t\t}\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = left_info[left].weight;\n\t\tright_weight = left_info[right].weight;\n\n\t\tleft_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tleft_info[info_index].right = 1.0-left_info[info_index].left;\n\t\tleft_info[info_index].type = Mobile;\n\t\tleft_info[info_index].index_left = left;\n\t\tleft_info[info_index].index_right = right;\n\t\tleft_info[info_index].weight = left_weight+right_weight;\n\t\tleft_info[info_index].most_left_loc = max(left_info[info_index].left+left_info[left].most_left_loc,left_info[right].most_left_loc-left_info[info_index].right);\n\t\tleft_info[info_index].most_right_loc = max(left_info[info_index].right+left_info[right].most_right_loc,left_info[left].most_right_loc-left_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,left_info,info_index+1,S_1);\n\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = right_info[left].weight;\n\t\tright_weight = right_info[right].weight;\n\n\t\tright_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tright_info[info_index].right = 1.0-right_info[info_index].left;\n\t\tright_info[info_index].type = Mobile;\n\t\tright_info[info_index].index_left = left;\n\t\tright_info[info_index].index_right = right;\n\t\tright_info[info_index].weight = left_weight+right_weight;\n\t\tright_info[info_index].most_left_loc = max(right_info[info_index].left+right_info[left].most_left_loc,right_info[right].most_left_loc-right_info[info_index].right);\n\t\tright_info[info_index].most_right_loc = max(right_info[info_index].right+right_info[right].most_right_loc,right_info[left].most_right_loc-right_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,right_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\tInfo left_info[12],right_info[12];\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tfor(int i = 0; i < info_index; i++){\n\t\t\tleft_info[i] = tmp_info[i];\n\t\t\tright_info[i] = tmp_info[i];\n\t\t}\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = left_info[left].weight;\n\t\tright_weight = left_info[right].weight;\n\n\t\tleft_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tleft_info[info_index].right = 1.0-left_info[info_index].left;\n\t\tleft_info[info_index].type = Mobile;\n\t\tleft_info[info_index].index_left = left;\n\t\tleft_info[info_index].index_right = right;\n\t\tleft_info[info_index].weight = left_weight+right_weight;\n\t\tleft_info[info_index].most_left_loc = max(left_info[info_index].left+left_info[left].most_left_loc,left_info[right].most_left_loc-left_info[info_index].right);\n\t\tleft_info[info_index].most_right_loc = max(left_info[info_index].right+left_info[right].most_right_loc,left_info[left].most_right_loc-left_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,left_info,info_index+1,S_1);\n\n\t\tif(left_info[left].type == Stone && left_info[right].type == Stone)return;\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = right_info[left].weight;\n\t\tright_weight = right_info[right].weight;\n\n\t\tright_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tright_info[info_index].right = 1.0-right_info[info_index].left;\n\t\tright_info[info_index].type = Mobile;\n\t\tright_info[info_index].index_left = left;\n\t\tright_info[info_index].index_right = right;\n\t\tright_info[info_index].weight = left_weight+right_weight;\n\t\tright_info[info_index].most_left_loc = max(right_info[info_index].left+right_info[left].most_left_loc,right_info[right].most_left_loc-right_info[info_index].right);\n\t\tright_info[info_index].most_right_loc = max(right_info[info_index].right+right_info[right].most_right_loc,right_info[left].most_right_loc-right_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,right_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n \nconst double EPS = 1e-9;\n \nstruct data{\n  double lm, rm, m;//l-min, r-max\n  int bit; \n  data(double l=0, double r=0, double m=0, int b=0):lm(l),rm(r),m(m),bit(b){}\n};\n \nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n \nint n;\ndouble r;\nvector<double> v;\n \nvoid solve(){\n  if(n == 1){\n    cout << 0.0 << endl;\n    return;\n  }\n \n  vector<data> res[7];\n  double ans = -1.0;\n  for(int i=0;i<n;i++) res[1].push_back(data(0,0,v[i],(1<<i)));\n  for(int i=2;i<=n;i++){\n    for(int j=1;j<i;j++){\n      int x1 = j, x2 = i - j;\n      for(int k=0;k<res[x1].size();k++){\n        for(int l=0;l<res[x2].size();l++){\n          if((res[x1][k].bit & res[x2][l].bit) != 0) continue;\n          data pos;\n          double a = res[x2][l].m / (res[x1][k].m + res[x2][l].m);\n          double b = 1.0 - a;\n          pos.lm = min(-a + res[x1][k].lm, b + res[x2][l].lm);\n          pos.rm = max(b + res[x2][l].rm, -a + res[x1][k].rm);\n          pos.m = res[x1][k].m + res[x2][l].m;\n          pos.bit = res[x1][k].bit | res[x2][l].bit;\n          if(pos.rm - pos.lm > r || equal(pos.rm-pos.lm,r)) continue;\n          else if(i == n) ans = max(ans, pos.rm - pos.lm);\n          else res[i].push_back(pos);\n        }\n      }\n    }\n  }\n  if(ans < 0) cout << -1 << endl;\n  else printf(\"%.9f\\n\",ans);\n}\n \nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n    cin >> r >> n;\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=-1;\n  double tmp1=rec(v+1,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+1,L+w[v+1]/(w[v]+w[v+1]));\n  double tmp3=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp4=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  if(tmp3<r-EPS)res=max(res,tmp3);\n  if(tmp4<r-EPS)res=max(res,tmp4);\n\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(1,1.0);\n      if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\ndouble r;\nint s;\nint w[101];\n\nvector<P> dfs(vector<int> stones){\n    if(stones.size()==1){\n        vector<P> res;\n        res.push_back(P(0,0));\n        return res;\n    }\n    vector<int> v,v2;\n    vector<P> ret;\n    for(int s=0;s<(1<<stones.size());s++){\n        v.clear();\n        v2.clear();\n        int sum1=0;\n        int sum2=0;\n        for(int i = 0; i < stones.size(); i++){\n            if((s>>i)&1){\n                sum1+=w[stones[i]];\n                v.push_back(stones[i]);\n            }\n            else{\n                sum2+=w[stones[i]];\n                v2.push_back(stones[i]);\n            }\n        }\n        if(v.size()==0||v2.size()==0)continue;\n        double b=(double)sum1/(sum1+sum2);\n        double a=(double)sum2/(sum1+sum2);\n        vector<P> res1=dfs(v);\n        vector<P> res2=dfs(v2);\n        //if(stones.size()==3){\n        //    cout<<endl;\n        //}\n        for(int i = 0; i < res1.size(); i++){\n            for(int j = 0; j < res2.size(); j++){\n                double left=res1[i].first-a;\n                double right=res1[i].second-a;\n                double left2=res2[j].first+b;\n                double right2=res2[j].second+b;\n                double minn=min(left,min(left2,min(right,right2)));\n                double maxn=max(left,max(left2,max(right,right2)));\n                if(EQ(maxn,0.5)&&EQ(minn,0)){\n                  //  cout<<endl;\n                }\n                ret.push_back(P(minn,maxn));\n            }\n        }\n    }\n    return ret;\n}\n\nconst double INF=1000000000;\nint main(){\n\n    int t;\n    cin>>t;\n    while(t--){\n        cin>>r>>s;\n        vector<int> ss;\n        for(int i = 0; i < s; i++){\n            cin>>w[i];\n            ss.push_back(i);\n        }\n        vector<P> res=dfs(ss);\n        double maxl=-1;\n        for(int i = 0; i < res.size(); i++){\n            double len=abs(res[i].first-res[i].second);\n            if(!EQ(len,r)&&len<r){\n                maxl=max(maxl,len);\n            }\n        }\n        if(!EQ(maxl,-1)){\n            printf(\"%.7f\\n\",maxl);\n        }\n        else\n            cout<<-1<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<iomanip>\n\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nstruct Node\n{\n  ld left,right,lweight,rweight;\n  bool leaf;\n  Node(ld left=0,ld right=0,ld lweight=inf,ld rweight=inf):left(left),right(right),lweight(lweight),rweight(rweight)\n  {\n    leaf = true; \n  }\n};\n\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nvoid dfs(vector<Node> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(len >= 0);\n      if(!check(len))return;\n      ans = max(ans,len);\n      return;\n    }\n  /*\n  cout << \"vec ---- \" << endl;\n  rep(i,vec.size())cout << \"(\" << vec[i].left << \",\" << vec[i].right << \",\" << vec[i].lweight << \",\" << vec[i].rweight << \")\\n\";\n  cout << \"^^^^^^^^^^^^^\" << endl;\n  */\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\n\t  vector<Node> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  \n\t  if(vec[i].leaf && vec[j].leaf)\n\t    {\n\t      assert(vec[i].lweight == vec[i].rweight);\n\t      assert(vec[j].lweight == vec[j].rweight);\n\t      Node node = Node(0,1,vec[i].lweight,vec[j].rweight);\n\t      node.leaf = false;\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\n\t      //ループ回してるから両方やらなくて良いだろ女子高生\n\t      /*\n\t      node.lweight = vec[j].lweight;\n\t      node.rweight = vec[i].rweight;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\t      */\n\t    }\n\t  else if(!vec[i].leaf && !vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\n\t      ld lenA = A.right - A.left;\n\t      ld lenB = B.right - B.left;\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio - 1;\n\t      ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld lp = x - lenB * ratio;\n\t      ratio = B.lweight/(B.rweight+B.lweight);\n\t      ld rp = x + lenB * ratio;\n\n\t      Node C = Node(min(lp,A.left),max(rp,A.right),B.rweight+B.lweight,A.rweight+A.lweight);\n\t      C.leaf = false;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[i].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenB = B.right - B.left;\n\t      ld ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld x = lenB * ratio - 1;\n\n\t      assert(A.rweight == A.lweight);\n\t      Node C = Node(min(x,B.left),B.right,A.rweight,B.rweight+B.lweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenA = A.right - A.left;\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio + 1;\n\n\t      assert(B.rweight == B.lweight);\n\t      Node C = Node(A.left,max(A.right,x),A.rweight+A.lweight,B.rweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }  \n\t    }\n\t  else assert(false);\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<Node> vec(s);\n\n\t  rep(i,s)cin >> vec[i].lweight,vec[i].rweight = vec[i].lweight;\n\n\t  dfs(vec);\t  \n\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<iomanip>\n\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nstruct Node\n{\n  ld left,right,lweight,rweight,middle;\n  bool leaf;\n  Node(ld left=0,ld right=0,ld lweight=inf,ld rweight=inf):left(left),right(right),lweight(lweight),rweight(rweight)\n  {\n    middle = inf;\n    leaf = true; \n  }\n};\n\ntypedef pair<Node,Node> NN;\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nvoid dfs(vector<Node> vec,vector<NN> path)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      /*\n      cout << \"path--------- ANS : \" << len << endl;\n      rep(i,path.size())\n\t{\n\t  cout << \"merge (\" << path[i].first.left << \",\" << path[i].first.right << \",\" << path[i].first.lweight << \",\" << path[i].first.rweight << \") (\" << path[i].second.left << \",\" << path[i].second.right << \",\" << path[i].second.lweight << \",\" << path[i].second.rweight << \")\" << endl;\n\t}\n      cout << \"last (\" << vec[0].left << \",\" << vec[0].right << \",\" << vec[0].lweight << \",\" << vec[0].rweight << \")\" << endl;\n      cout << \"^^^^^^^^^^^^\" << endl << endl;\n      */\n      assert(len >= 0);\n      if(!check(len))return;\n      ans = max(ans,len);\n      return;\n    }\n  /*\n  cout << \"vec ---- \" << endl;\n  rep(i,vec.size())cout << \"(\" << vec[i].left << \",\" << vec[i].right << \",\" << vec[i].lweight << \",\" << vec[i].rweight << \")\\n\";\n  cout << \"^^^^^^^^^^^^^\" << endl;\n  */\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\n\t  vector<Node> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  \n\t  if(vec[i].leaf && vec[j].leaf)\n\t    {\n\t      assert(vec[i].lweight == vec[i].rweight);\n\t      assert(vec[j].lweight == vec[j].rweight);\n\t      Node node = Node(0,1,vec[i].lweight,vec[j].rweight);\n\t      node.leaf = false;\n\t      node.middle = vec[i].rweight/(vec[i].rweight+vec[j].rweight);\n\t      {\n\t\tvector<NN> p2 = path;//:::::\n\t\tp2.push_back(NN(vec[i],vec[j]));\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2,p2);\n\t      }\n\n\t      //ループ回してるから両方やらなくて良いだろ女子高生\n\t      /*\n\t      node.lweight = vec[j].lweight;\n\t      node.rweight = vec[i].rweight;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\t      */\n\t    }\n\t  else if(!vec[i].leaf && !vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\n\t      ld lenA = A.right - A.left;\n\t      ld lenB = B.right - B.left;\n\t      assert(equals(lenA,0) || lenA > 0);\n\t      assert(equals(lenB,0) || lenB > 0);\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = -A.left + A.middle - 1;\n\t      ld lp = x - B.middle;\n\t      ld rp = x + B.middle;\n\n\t      Node C = Node(min(lp,A.left),max(rp,A.right),B.rweight+B.lweight,A.rweight+A.lweight);\n\t      C.leaf = false;\n\t      ratio = C.rweight / (C.rweight+C.lweight);\n\t      C.middle = ratio * (C.right - C.left) + B.middle;\n\t      vector<NN> p2 = path;//::::\n\t      {\n\t\tp2.push_back(NN(A,B));\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2,p2);\n\t      }\n\n\t    }\n\t  else if(vec[i].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenB = B.right - B.left;\n\t      assert(equals(lenB,0) || lenB > 0);\n\t      ld x = -B.left + B.middle - 1;\n\n\t      assert(A.rweight == A.lweight);\n\t      Node C = Node(min(x,B.left),B.right,A.rweight,B.rweight+B.lweight);\n\t      C.leaf = false;\n\t      ld ratio = (B.rweight+B.lweight)/(A.rweight+(B.rweight+B.lweight));\n\t      C.middle = B.left + B.middle - ratio * (C.right-C.left);\n\t      vector<NN> p2 = path;//:::::::\n\t      p2.push_back(NN(A,B));\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2,p2);\n\t      }\n\n\t    }\n\t  else if(vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenA = A.right - A.left;\n\t      assert(equals(lenA,0) || lenA > 0);\n\t      ld x = -A.left + A.middle + 1;\n\n\t      assert(B.rweight == B.lweight);\n\t      Node C = Node(A.left,max(A.right,x),A.rweight+A.lweight,B.rweight);\n\t      C.leaf = false;\n\t      ld ratio = B.rweight/((A.rweight+A.lweight)+B.rweight);\n\t      C.middle = A.left + A.middle + ratio * (C.right-C.left);\n\t      vector<NN> p2 = path;//::::\n\t      {\n\t\tp2.push_back(NN(A,B));\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2,p2);\n\t      }  \n\t    }\n\t  else assert(false);\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<Node> vec(s);\n\n\t  rep(i,s)cin >> vec[i].lweight,vec[i].rweight = vec[i].lweight;\n\n\t  if(s == 1)\n\t    {\n\t      cout << 0 << endl;\n\t      continue;\n\t    }\n\t  vector<NN> path;\n\t  dfs(vec,path);\t  \n\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<iomanip>\n\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nstruct Node\n{\n  ld left,right,lweight,rweight;\n  bool leaf;\n  Node(ld left=0,ld right=0,ld lweight=inf,ld rweight=inf):left(left),right(right),lweight(lweight),rweight(rweight)\n  {\n    leaf = true; \n  }\n};\n\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nvoid dfs(vector<Node> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(len >= 0);\n      if(!check(len))return;\n      ans = max(ans,len);\n      return;\n    }\n  /*\n  cout << \"vec ---- \" << endl;\n  rep(i,vec.size())cout << \"(\" << vec[i].left << \",\" << vec[i].right << \",\" << vec[i].lweight << \",\" << vec[i].rweight << \")\\n\";\n  cout << \"^^^^^^^^^^^^^\" << endl;\n  */\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\n\t  vector<Node> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  \n\t  if(vec[i].leaf && vec[j].leaf)\n\t    {\n\t      assert(vec[i].lweight == vec[i].rweight);\n\t      assert(vec[j].lweight == vec[j].rweight);\n\t      Node node = Node(0,1,vec[i].lweight,vec[j].rweight);\n\t      node.leaf = false;\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\n\t      //ループ回してるから両方やらなくて良いだろ女子高生\n\t      /*\n\t      node.lweight = vec[j].lweight;\n\t      node.rweight = vec[i].rweight;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\t      */\n\t    }\n\t  else if(!vec[i].leaf && !vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\n\t      ld lenA = A.right - A.left;\n\t      ld lenB = B.right - B.left;\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio - 1;\n\t      ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld lp = x - lenB * ratio;\n\t      ratio = B.lweight/(B.rweight+B.lweight);\n\t      ld rp = x + lenB * ratio;\n\n\t      Node C = Node(min(lp,A.left),max(rp,A.right),B.rweight+B.lweight,A.rweight+A.lweight);\n\t      C.leaf = false;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[i].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenB = B.right - B.left;\n\t      ld ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld x = lenB * ratio - 1;\n\n\t      assert(A.rweight == A.lweight);\n\t      Node C = Node(min(x,B.left),B.right,A.rweight,B.rweight+B.lweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenA = A.right - A.left;\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio + 1;\n\n\t      assert(B.rweight == B.lweight);\n\t      Node C = Node(A.left,max(A.right,x),A.rweight+A.lweight,B.rweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }  \n\t    }\n\t  else assert(false);\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<Node> vec(s);\n\t  assert(s != 1);\n\t  rep(i,s)cin >> vec[i].lweight,vec[i].rweight = vec[i].lweight;\n\n\t  dfs(vec);\t  \n\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint L[15], R[15];\nint weight[15];\n\ndouble W;\n\nint N, w[6];\nint TS;\n\nint make_tree(int x, vector<int> A, vector<int> B){\n  \n  if( (int)B.size() == 1 ) return weight[x] = w[B[0]];\n  \n  int idx = 0, maxA = -1;\n  \n  for(int i=0;i<(int)A.size();i++){\n    \n    if( maxA < A[i] ){\n      \n      maxA = A[i];\n      \n      idx = i;\n      \n    }\n    \n  }\n  \n  assert( (int)A.size() + 1 == (int)B.size() );\n  \n  int sum = 0;\n  \n  vector<int> xLA, xLB;\n  \n  for(int i=0;i<idx;i++) xLA.push_back(A[i]);\n  \n  for(int i=0;i<=idx;i++) xLB.push_back(B[i]);\n  \n  TS++;\n  \n  L[x] = TS;\n  \n  sum += make_tree( TS, xLA, xLB );\n  \n  vector<int> xRA, xRB;\n  \n  for(int i=idx+1;i<(int)A.size();i++) xRA.push_back(A[i]);\n  \n  for(int i=idx+1;i<(int)B.size();i++) xRB.push_back(B[i]);\n  \n  TS++;\n  \n  R[x] = TS;\n  \n  sum += make_tree( TS, xRA, xRB );\n  \n  return weight[x] = sum;\n}\n\ndouble lmin, rmax;\n\nvoid dfs(int x, double mid){\n  \n  lmin = min( lmin, mid );\n  rmax = max( rmax, mid );\n  \n  if( L[x] == -1 && R[x] == -1 ) return;\n  \n  double l = weight[L[x]], r = weight[R[x]];\n  \n  double a = r / ( l + r ), b = l / ( l + r );\n  \n  dfs( L[x], mid - a );\n  \n  dfs( R[x], mid + b );\n  \n}\n\nsigned main(){\n  \n  int cnt;\n  cin>>cnt;\n  \n  while(cnt--){\n    \n    cin>>W>>N;\n    \n    for(int i=0;i<N;i++) cin>>w[i];\n    \n    if( N == 1 ){\n      cout<<0<<endl;\n      continue;\n    }\n    \n    double ans = -1;\n    \n    vector<int> A;\n    \n    for(int i=0;i<N-1;i++) A.push_back(i);\n    \n    do{\n      \n      vector<int> B;\n      \n      for(int i=0;i<N;i++) B.push_back(i);\n      \n      do{\n\t\n\tmemset( L, -1, sizeof(L) );\n\tmemset( R, -1, sizeof(R) );\n\t\n\tTS = 0;\n\t\n\tmake_tree( TS, A, B );\n\t\n\tlmin = 1e9, rmax = -1e9;\n\t\n\tdfs( 0, 0.0 );\n\t\n\tif( rmax - lmin < W ) ans = max( ans, rmax - lmin );\n\t\n      }\n      while( next_permutation( B.begin(), B.end() ) );\n      \n    }\n    while( next_permutation( A.begin(), A.end() ) );\n        \n    printf(\"%.8f\\n\", ans );\n    \n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\n \nusing namespace std;\ntypedef long double ld;\n \nstruct P\n{\n  ld left,right,weight;\n  P(ld left=0,ld right=0,ld weight=inf):left(left),right(right),weight(weight){}\n  bool operator < (const P& a)const\n  {\n    if(!equals(weight,a.weight))return weight < a.weight;\n    if(!equals(left,a.left))return left < a.left;\n    return right < a.right;\n  }\n};\n \nld r,ans;\nint s;\n \nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n \nP unit(P a,P b)\n{\n  P node;\n  node.weight = a.weight + b.weight;\n  ld middle = b.weight/(a.weight+b.weight);\n  node.left = min(-b.weight/(a.weight+b.weight) + a.left,b.left + (1-middle));\n  node.right = max(a.weight/(a.weight+b.weight) + b.right,a.right - middle);\n  return node;\n}\n \nvoid dfs(vector<P> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(equals(len,0) || len > 0);\n      if(check(len))ans = max(ans,len);\n      return;\n    }\n  \n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\t  vector<P> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  P p = unit(vec[i],vec[j]);\n\t  nvec.push_back(p);\n\t  dfs(nvec);\n\t}\n    }\n}\n \n \nint main()\n{\n  /*\n  rep(i,100000)\n    {\n    P a,b;\n      cout << \"type node a\\n\";\n      cin >> a.left >> a.right >> a.weight;\n      cout << \"type node b\\n\";\n      cin >> b.left >> b.right >> b.weight;\n      P c = unit(a,b);\n      cout << \"unit c (\" << c.left << \",\" << c.right << \",\" << c.weight << \")\" << endl;\n    }\n  */\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<P> ps(s);\n\t  rep(i,s)cin >> ps[i].weight;\n\t  \n\t  ans = -inf;\n\t  \n\t  dfs(ps);\n\t  \n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(9) << ans << endl;\n\t  \n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nstruct mobile_t {\n    int w; // weight\n    double l; // left\n    double r; // right\n};\nconst double eps = 0.0001;\ndouble evaluate(vector<int> const & p, double r) {\n    stack<mobile_t> stk;\n    for (int w : p) {\n        if (w == 0) {\n            if (stk.size() < 2) return -1;\n            mobile_t x = stk.top(); stk.pop();\n            mobile_t y = stk.top(); stk.pop();\n            mobile_t z;\n            z.w = x.w + y.w;\n            double dx = y.w /(double) (x.w + y.w);\n            double dy = x.w /(double) (x.w + y.w);\n            z.l = max(x.l + dx, y.l - dy);\n            z.r = max(x.r - dx, y.r + dy);\n            if (r + eps < z.r + z.l) return -1;\n            stk.push(z);\n        } else {\n            stk.push((mobile_t){ w, 0.0, 0.0 });\n        }\n    }\n    if (stk.size() != 1) return -1;\n    return stk.top().l + stk.top().r;\n}\nint main() {\n    int datasets; cin >> datasets;\n    repeat (dataset, datasets) {\n        double r; cin >> r;\n        int s; cin >> s;\n        vector<int> w(s); repeat (i,s) cin >> w[i];\n        double result = -1;\n        vector<int> p;\n        repeat (i,s)   p.push_back(w[i]);\n        repeat (i,s-1) p.push_back(0);\n        sort(p.begin(), p.end());\n        do {\n            result = max(result, evaluate(p, r));\n        } while (next_permutation(p.begin(), p.end()));\n        if (result == -1) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%.16lf\\n\", result);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ndouble R;\nint n, a[100];\n\nstruct ST {\n    double w, a, h;\n    ST() {}\n    ST(double w, double a, double h) : w(w), a(a), h(h) {}\n};\n\nbool operator<(const ST& a, const ST& b) {\n    if (a.w != b.w) return a.w < b.w;\n    if (a.a != b.a) return a.a < b.a;\n    return a.h < b.h;\n}\n\nbool operator==(const ST& a, const ST& b) {\n    return !(a < b) && !(b < a);\n}\n\nST combine(const ST& p, const ST& q) {\n    const double a = p.h / (p.h+q.h);\n    double l = min(-a-p.a, (1-a)-q.a);\n    double r = max((1-a)+(q.w-q.a), -a+(p.w-p.a));\n    return ST(r-l, p.a+a, p.h+q.h);\n}\n\nmap<int, vector<ST> > memo;\n\nvector<ST> calc(int u) {\n    if ((u&(u-1)) == 0) {\n        int ix = -1;\n        rep (i, n) if (u&(1<<i)) ix = i;\n        return vector<ST>(1, ST(0, 0, a[ix]));\n    }\n    if (memo.count(u)) return memo[u];\n    vector<ST> ans;\n    rep (b, 1<<n) if ((u&b) == b && b != u && b != 0) {\n        vector<ST> x = calc(b);\n        vector<ST> y = calc(u-b);\n        rep (i, x.size()) rep (j, y.size()) {\n            ans.push_back(combine(x[i], y[j]));\n        }\n    }\n    sort(ans.begin(), ans.end());\n    ans.erase(unique(ans.begin(), ans.end()), ans.end());\n    return memo[u] = ans;\n}\n\nint main() {\n    while (scanf(\"%lf\", &R) != EOF) {\n        scanf(\"%d\", &n);\n        rep (i, n) scanf(\"%d\", a+i);\n        memo.clear();\n        vector<ST> ws = calc((1<<n)-1);\n        double ans = -1;\n        rep (i, ws.size()) if (ws[i].w <= R) ans = max(ans, ws[i].w);\n        if (ans < 0) printf(\"%d\\n\", -1);\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <iostream>\n#include <memory>\n#include <tuple>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\nstruct node_t {\n\tshared_ptr<node_t> left_child, right_child;\n\n\tinline bool is_leaf() const {\n\t\treturn left_child == nullptr;\n\t}\n\n\tnode_t():left_child(nullptr), right_child(nullptr) {}\n};\n\nconstexpr int MAX_S = 6;\n\ntypedef array<vector<shared_ptr<node_t>>, MAX_S + 1> T_array;\ntypedef tuple<int, double, double> result;\nenum { WEIGHT, LEFT, RIGHT };\n\nT_array init_trees() {\n\tT_array trees;\n\n\ttrees[1].emplace_back(shared_ptr<node_t>(new node_t));\n\n\tfor(int s = 2; s <= 6; ++s) {\n\t\tfor(int l = 1; l < s; ++l) {\n\t\t\tconst int r = s - l;\n\n\t\t\tfor(const auto &p1 : trees[l]) {\n\t\t\t\tfor(const auto &p2 : trees[r]) {\n\t\t\t\t\tshared_ptr<node_t> p(new node_t);\n\t\t\t\t\tp->left_child = p1;\n\t\t\t\t\tp->right_child = p2;\n\t\t\t\t\ttrees[s].emplace_back(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn trees;\n}\n\nresult dfs(const shared_ptr<node_t> &node, vector<int>::const_iterator &it) {\n\tif(node->is_leaf()) {\n\t\tconst result res(*it, 0.0, 0.0);\n\t\t++it;\n\t\treturn res;\n\t}\n\n\tconst auto l_result = dfs(node->left_child, it);\n\tconst auto r_result = dfs(node->right_child, it);\n\n\tconst int weight = get<WEIGHT>(l_result) + get<WEIGHT>(r_result);\n\n\tconst double left_pos = -static_cast<double>(get<WEIGHT>(r_result)) / weight;\n\tconst double right_pos = static_cast<double>(get<WEIGHT>(l_result)) / weight;\n\n\tconst double left = min(get<LEFT>(l_result) + left_pos, get<LEFT>(r_result) + right_pos);\n\tconst double right = max(get<RIGHT>(l_result) + left_pos, get<RIGHT>(r_result) + right_pos);\n\n\treturn result(weight, left, right);\n}\n\nvoid solve(const T_array &trees) {\n\tdouble r;\n\tint s;\n\tcin >> r >> s;\n\n\tvector<int> w(s);\n\tfor(auto &e : w) cin >> e;\n\n\tsort(w.begin(), w.end());\n\n\tdouble ans = -1;\n\tdo {\n\t\tfor(const auto &root : trees[s]) {\n\t\t\tauto it = w.cbegin();\n\t\t\tconst auto tmp = dfs(root, it);\n\t\t\tconst double width = get<RIGHT>(tmp) - get<LEFT>(tmp);\n\t\t\tif(width < r) chmax(ans, width);\n\t\t}\n\n\t} while(next_permutation(w.begin(), w.end()));\n\n\n\tif(ans < 0) {\n\t\tcout << \"-1\" << endl;\n\t}\n\telse {\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tconst auto trees = init_trees();\n\n\tint T;\n\tcin >> T;\n\n\twhile(T--) solve(trees);\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef long double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        pat.clear();\n        for (int k = 0; k < S - 1; k++) pat.push_back(0);\n        for (int i = 1; i <= S; i++) pat.push_back(i);\n        ans = max(ans, solve());\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18Lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] == 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                nleft = 1.0 / w * b.w + a.left;\n                nright = 1.0 / w * a.w + b.right;\n                stack.push_back(State(a.w + b.w, nleft, nright));\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        if (S == 1) return 0;\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            //if (!check()) continue;\n            real c = parse();\n            assert(c <= S - 1);\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ndouble R;\nint n, a[100];\n\nstruct ST {\n    double w, a, h;\n    ST() {}\n    ST(double w, double a, double h) : w(w), a(a), h(h) {}\n};\n\nST combine(const ST& p, const ST& q) {\n    const double a = q.h / (p.h+q.h);\n    double l = min(-a-p.a, (1-a)-q.a);\n    double r = max((1-a)+(q.w-q.a), -a+(p.w-p.a));\n    return ST(r-l, -l, p.h+q.h);\n}\n\nvector<ST> calc(int u) {\n    if ((u&(u-1)) == 0) {\n        int ix = -1;\n        rep (i, n) if (u&(1<<i)) ix = i;\n        return vector<ST>(1, ST(0, 0, a[ix]));\n    }\n    vector<ST> ans;\n    rep (b, 1<<n) if ((u&b) == b && b != u && b != 0) {\n        vector<ST> x = calc(b);\n        vector<ST> y = calc(u-b);\n        rep (i, x.size()) rep (j, y.size()) {\n            ans.push_back(combine(x[i], y[j]));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%lf%d\", &R, &n);\n        rep (i, n) scanf(\"%d\", a+i);\n        vector<ST> ws = calc((1<<n)-1);\n        double ans = -1;\n        rep (i, ws.size()) if (ws[i].w < R) ans = max(ans, ws[i].w);\n        if (ans < 0) printf(\"%d\\n\", -1);\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\nvector<pair<double,double> > rec(vector<int> v){\n  if(v.size()==1)return {make_pair(0.,0.)};\n  vector<pair<double,double> > ret;\n  for(int i=0;i<1<<v.size();i++){\n    vector<int> nw[2];\n    int ws[2]={};\n    for(int j=0;j<v.size();j++){\n      nw[i>>j&1].push_back(v[j]);\n      ws[i>>j&1]+=v[j];\n    }\n    if(ws[0]==0||ws[1]==0)continue;\n    auto l=rec(nw[0]);\n    auto r=rec(nw[1]);\n    double x=ws[1]*1./(ws[0]+ws[1]);\n    for(auto e:l){\n      for(auto f:r){\n\tret.emplace_back(max(e.first+x,f.first-(1-x)),max(1-x+f.second,e.second-x));\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  int T;\n  cin>>T;\n  while(T--){\n    double r;\n    int s;\n    cin>>r>>s;\n    vector<int> w(s);\n    for(int i=0;i<s;i++){\n      cin>>w[i];\n    }\n    auto res=rec(w);\n    double a=-1;\n    for(auto e:res){\n      double l=e.first+e.second;\n      if(l<r){\n\ta=max(a,l);\n      }\n    }\n    cout.precision(9);\n    cout<<fixed<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MaxN = 100005;\n#define two(i) (1<<(i))\ndouble r;\nint w[10],n,sz[two(6)],cnt[two(6)],sum[two(6)];\ndouble x[two(6)][MaxN],y[two(6)][MaxN];\n\nint main() \n{\n\n\tfor(int i = 0; i < two(6); i++)\n\t{\n\t\tcnt[i] = 0;\n\t\tfor(int t = i; t; t-=t&(-t))cnt[i]++;\n\t}\n\tint T;scanf(\"%d\",&T);\n\twhile(T--)\n\t{\n\t\tscanf(\"%lf%d\",&r,&n);\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tscanf(\"%d\",&w[i]);\n\t\tfor(int i = 0; i < two(n); i++)\n\t\t{\n\t\t\tsum[i] = 0;\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tif(i&two(j))\n\t\t\t\t\tsum[i] += w[j];\n\t\t}\n\t\tfor(int i = 1; i < two(n); i++)\n\t\t{\n\t\t\tif(cnt[i]==1)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\t\tif((i>>j)&1)\n\t\t\t\t\t{\n\t\t\t\t\t\tx[i][0] = 0;\n\t\t\t\t\t\ty[i][0] = 0;\n\t\t\t\t\t\tsz[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint m = 0;\n\t\t\tfor(int j = (i-1)&i; j>0; j = (j-1)&i)\n\t\t\t{\n\t\t\t\tdouble L = 1.0*sum[j^i]/sum[i];\n\t\t\t\tdouble R = 1.0*sum[j]/sum[i];\n\t\t\t\tfor(int k = 0; k < sz[j]; k++)\n\t\t\t\t\tfor(int p = 0; p < sz[i^j]; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tx[i][m] = max(L+x[j][k],x[i^j][p]-R);\n\t\t\t\t\t\ty[i][m] = max(R+y[i^j][p],y[j][k]-L);\n\t\t\t\t\t\tm++;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tsz[i] = m;\n\t\t}\n\t\tint ok = 0;\n\t\tdouble ret = -1;\n\t\tfor(int i = 0; i < sz[two(n)-1]; i++)\n\t\t{\n\t\t\t// printf(\"%lf %lf\\n\",x[two(n)-1][i],y[two(n)-1][i]);\n\t\t\tif(x[two(n)-1][i]+y[two(n)-1][i] < r)\n\t\t\t{\n\t\t\t\tok = 1;\n\t\t\t\tret = max(ret,x[two(n)-1][i]+y[two(n)-1][i]);\n\t\t\t}\n\t\t}\n\t\tif(!ok)puts(\"-1\");\n\t\telse printf(\"%.8f\\n\",ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - lw/(lw+rw);\n    double rx = x + rw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = 1e9;\n    for(P p:v) ans = min(ans,p.second - p.first);\n    if(ans > len)cout<<-1<<endl;\n    else printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble r,w[6],ans,cal,LL,RR,s[300];\nint n,t[300],cnt;\n\nvoid dfs(int p,double c){\n  if(s[p*2+1])dfs(p*2+2,c+s[p*2+1]/s[p]);\n  if(s[p*2+2])dfs(p*2+1,c-s[p*2+2]/s[p]);\n  RR=max(c,RR);\n  LL=min(c,LL);\n}\n\ndouble dfs2(int p){\n  double rm,lm;\n  if(t[p*2+1])lm=dfs2(p*2+1);\n  else s[p*2+1]=lm=w[cnt++];\n  if(t[p*2+2])rm=dfs2(p*2+2);\n  else s[p*2+2]=rm=w[cnt++];\n  return s[p]=lm+rm;\n}\n\nvoid check(){\n  sort(w,w+n);\n  do{\n    cnt=0;\n    LL=0,RR=0;\n    memset(s,0,sizeof(s));\n    dfs2(0);\n    dfs(0,0);\n    cal=RR-LL;\n    if(cal<=r)ans=max(ans,cal);\n  }while(next_permutation(w,w+n));\n}\n\nvoid dfs1(int p,int c){\n  if(t[p])return;\n  if(c==n){check();return;}\n  t[p]=1;\n  for(int i=0;i<16;i++){\n    if(t[i]){\n      dfs1(2*p+1,c+1);\n      dfs1(2*p+2,c+1);\n    }\n  }\n  t[p]=0;\n}\n\n\nint main(){\n\n\n  int T;\n  cin>>T;\n  while(T--){\n    ans=-1;\n    cin>>r>>n;\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(t,0,sizeof(t));\n    if(2<=n)dfs1(0,1);\n    printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)  REP(i,0,n)\n\ndouble cost[N][N];\ndouble lcost[N][N];\ndouble rcost[N][N];\nint weight[N][N];\n\ndouble mcm(int n,int *inp,double lim){\n  rep(i,n)rep(j,n)weight[i][j]=0;\n  rep(i,n){\n    rcost[i][i]=lcost[i][i]=cost[i][i]=0;\n    weight[i][i]=inp[i];\n  }\n  \n  for(int l=2;l<n+1;l++){\n    for(int i=0;i<n-l+1;i++){\n      int j = i+l-1;//matrix i to j separated by k\n      cost[i][j]=-1;\n      for(int k=i;k<j;k++){\n\tif ( cost[i][k] == -1 || cost[k+1][j] == -1)continue;\n\tdouble tw=weight[i][k]+weight[k+1][j];\n\t\n\t//double tmpr =rcost[k+1][j]+(weight[i][k])/tw,tmpl=lcost[i][k]+(weight[k+1][j])/tw;\n\t//double tmp=1+rcost[k+1][j]+lcost[i][k];\n\tdouble tmpr = max(weight[i][k]/tw+rcost[k+1][j],rcost[i][k]-weight[k+1][j]/tw);\n\tdouble tmpl = max(weight[k+1][j]/tw+lcost[i][k],lcost[k+1][j]-weight[i][k]/tw);\n\t\n\n\n\tdouble tmp = tmpr+tmpl;\n\t\n\tif ( tmp <lim+eps && tmp >cost[i][j]){\n\t  cost[i][j]=tmp;\n\t  lcost[i][j]=tmpl;\n\t  rcost[i][j]=tmpr;\n\t  weight[i][j]=weight[k+1][j]+weight[i][k];\n\t}\n\t\n      }\n    }\n  }\n  \n  /*  \n rep(i,n){\n   rep(j,n){\n     cout <<cost[i][j] << \" \";\n   }\n   cout << endl;\n }\n cout << endl;\n cout << \"lcost \" << endl;\n rep(i,n){\n   rep(j,n)printf(\"%.3lf %.3lf : \",lcost[i][j],rcost[i][j]);\n   cout << endl;\n }\n  */\n \n return cost[0][n-1];\n}\n\n//critical case 1\nvoid solve(int n,double w,int *inp){\n sort(inp,inp+n);\n double ans = -1;\n do{\n   //   rep(i,n)cout << inp[i];\n   //cout << endl;\n   double tmp =mcm(n,inp,w);\n   if ( tmp != 0)ans = max(ans,tmp);\n }while( next_permutation(inp,inp+n));\n\n if ( ans == -1)puts(\"-1\");\n else printf(\"%.8lf\\n\",ans);\n\n}\n\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n   solve(n,r,inp);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX 6\n#define NON -1\n#define ROOT 0\n#define TO_LEAF 0\n#define TO_NODE 1\n\nstruct Node{\n    int left, right;\n    double weight;\n};\n\nclass Tree{\n    public:\n    Node nodes[MAX*2];\n    int size;\n    vector<int> leaves, internals;\n\n    Tree(){\n\tfor ( int i = 0; i < MAX*2; i++ ){\n\t    nodes[i].left = nodes[i].right = NON;\n\t    nodes[i].weight = 0.0;\n\t}\n    }\n\n    double getWidth(){\n\tdouble maxx, minx;\n\tmaxx = minx = 0.0;\n\tparse(0, 0.0, maxx, minx);\n\treturn maxx - minx;\n    }\n\n    void parse(int u, double x, double &maxx, double &minx){\n\tmaxx = max( maxx, x );\n\tminx = min( minx, x );\n\tdouble n, m;\n\tint left = nodes[u].left;\n\tint right = nodes[u].right;\n\tif ( left == NON ) return;\n\tn = nodes[left].weight;\n\tm = nodes[right].weight;\n\tparse(left, x - m/(n+m), maxx, minx);\n\tparse(right, x + n/(n+m), maxx, minx);\n    }\n\n    double getWeight(int u){\n\tif ( nodes[u].left == NON ) return nodes[u].weight;\n\tnodes[u].weight = getWeight(nodes[u].left) + getWeight(nodes[u].right);\n\treturn nodes[u].weight;\n    }\n};\n\ndouble R;\nint stones[MAX];\nint nstone;\n\ndouble maxv;\n\nvoid check(Tree u){\n    sort( stones, stones + nstone );\n    do {\n\tfor ( int i = 0; i < nstone; i++ ){\n\t    u.nodes[u.leaves[i]].weight = stones[i];\n\t}\n\tu.getWeight(ROOT);\n\tdouble width = u.getWidth();\n\tif ( width < R ) maxv = max( maxv, width );\n    } while ( next_permutation( stones, stones + nstone )) ;\n}\n\nvoid makeTree(Tree u){\n    if ( u.leaves.size() == nstone && u.internals.size() == 0 ) check(u);\n    if ( u.leaves.size() + u.internals.size()*2 > nstone ) return;\n\n    Tree v;\n\n    for ( int i = 0; i < u.internals.size(); i++ ){\n\tint parent = u.internals[i];\n\tfor ( int a = 0; a < 2; a++ ){\n\t    for ( int b = 0; b < 2; b++ ){\n\t\tv = u;\n\t\tv.nodes[parent].left = v.size++;\n\t\tv.nodes[parent].right = v.size++;\n\t\tif ( a == TO_LEAF ) v.leaves.push_back(v.size-2);\n\t\telse v.internals.push_back(v.size-2);\n\t\tif ( b == TO_LEAF ) v.leaves.push_back(v.size-1);\n\t\telse v.internals.push_back(v.size-1);\n\t\tv.internals.erase( v.internals.begin() + i );\n\t\tmakeTree(v);\n\t    }\n\t}\n    }\n}\n\nvoid compute(){\n    if ( nstone == 1 ) {\n\tprintf(\"%.9lf\\n\", 0.0); return;\n    }\n    Tree root = Tree();\n    root.internals.push_back(ROOT);\n    root.size = 1;\n    maxv = -1;\n    makeTree(root);\n    if ( maxv < 0.0 ) cout << \"-1\" << endl;\n    else printf(\"%.9lf\\n\", maxv);\n}\n\nvoid input(){\n    cin >> R >> nstone;\n    for ( int i = 0; i < nstone; i++ ) cin >> stones[i];\n}\n\nmain(){\n    int tcase; cin >> tcase;\n    for ( int i = 0; i < tcase; i++ ){\n\tinput();\n\tcompute();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\n\nusing namespace std;\ntypedef long double ld;\n\nstruct P\n{\n  ld left,right,weight;\n  P(ld left=0,ld right=0,ld weight=inf):left(left),right(right),weight(weight){}\n};\n\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nP unit(P a,P b)\n{\n  P node;\n  node.weight = a.weight + b.weight;\n  node.left = min(-b.weight/(a.weight+b.weight) + a.left,b.left + 1);\n  node.right = max(a.weight/(a.weight+b.weight) + b.right,a.right);\n  return node;\n}\n\nvoid dfs(vector<P> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(equals(len,0) || len > 0);\n      if(check(len))ans = max(ans,len);\n      return;\n    }\n\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\t  vector<P> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  P p = unit(vec[i],vec[j]);\n\t  nvec.push_back(p);\n\t  dfs(nvec);\n\t}\n    }\n}\n\n\nint main()\n{\n  /*\n  rep(i,100000)\n    {\n      P a,b;\n      cout << \"type node a\\n\";\n      cin >> a.left >> a.right >> a.weight;\n      cout << \"type node b\\n\";\n      cin >> b.left >> b.right >> b.weight;\n      P c = unit(a,b);\n      cout << \"unit c (\" << c.left << \",\" << c.right << \",\" << c.weight << \")\" << endl;\n    }\n  */\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<P> ps(s);\n\t  rep(i,s)cin >> ps[i].weight;\n\n\t  ans = -inf;\n\n\t  dfs(ps);\n\t  \n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(15) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ndouble R;\nint n, a[100];\n\nstruct ST {\n    double w, a, h;\n    ST() {}\n    ST(double w, double a, double h) : w(w), a(a), h(h) {}\n};\n\nbool operator<(const ST& a, const ST& b) {\n    if (a.w != b.w) return a.w < b.w;\n    if (a.a != b.a) return a.a < b.a;\n    return a.h < b.h;\n}\n\nbool operator==(const ST& a, const ST& b) {\n    return !(a < b) && !(b < a);\n}\n\nST combine(const ST& p, const ST& q) {\n    const double a = p.h / (p.h+q.h);\n    double l = min(-a-p.a, (1-a)-q.a);\n    double r = max((1-a)+(q.w-q.a), -a+(p.w-p.a));\n    return ST(r-l, p.a+a, p.h+q.h);\n}\n\nmap<int, vector<ST> > memo;\n\nvector<ST> calc(int u) {\n    if ((u&(u-1)) == 0) {\n        int ix = -1;\n        rep (i, n) if (u&(1<<i)) ix = i;\n        return vector<ST>(1, ST(0, 0, a[ix]));\n    }\n    if (memo.count(u)) return memo[u];\n    vector<ST> ans;\n    rep (b, 1<<n) if ((u&b) == b && b != u && b != 0) {\n        vector<ST> x = calc(b);\n        vector<ST> y = calc(u-b);\n        rep (i, x.size()) rep (j, y.size()) {\n            ans.push_back(combine(x[i], y[j]));\n        }\n    }\n    sort(ans.begin(), ans.end());\n    ans.erase(unique(ans.begin(), ans.end()), ans.end());\n    return memo[u] = ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (scanf(\"%lf\", &R) != EOF) {\n        scanf(\"%d\", &n);\n        rep (i, n) scanf(\"%d\", a+i);\n        memo.clear();\n        vector<ST> ws = calc((1<<n)-1);\n        double ans = -1;\n        rep (i, ws.size()) if (ws[i].w <= R) ans = max(ans, ws[i].w);\n        if (ans < 0) printf(\"%d\\n\", -1);\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= S - 1; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        if (S == 1) {\n            return 0;\n        }\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cassert>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\nusing namespace std;\nstruct mobile_t {\n    int w; // weight\n    double l; // left\n    double r; // right\n};\nconst double eps = 0.0001;\ndouble evaluate(string const & pat, double r, vector<int> const & w) {\n    stack<mobile_t> stk;\n    for (char c : pat) {\n        if (c == 'L' or c == 'R') {\n            if (stk.size() < 2) return -1;\n            mobile_t x = stk.top(); stk.pop();\n            mobile_t y = stk.top(); stk.pop();\n            mobile_t z;\n            z.w = x.w + y.w;\n            double xofs = y.w /(double) (x.w + y.w);\n            double yofs = x.w /(double) (x.w + y.w);\n            z.l = max(x.l + xofs, y.l - yofs);\n            z.r = max(x.r - xofs, y.r + yofs);\n            if (c == 'R') {\n                z = { z.w, z.r, z.l };\n            }\n            if (r + eps < z.r + z.l) return -1;\n            stk.push(z);\n        } else {\n            int i = c - '0';\n            stk.push((mobile_t){ w[i], 0.0, 0.0 });\n        }\n    }\n    if (stk.size() != 1) return -1;\n    return stk.top().l + stk.top().r;\n}\nint main() {\n    int datasets; cin >> datasets;\n    repeat (dataset, datasets) {\n        double r; cin >> r;\n        int s; cin >> s;\n        vector<int> w(s); repeat (i,s) cin >> w[i];\n        double result = -1;\n        repeat (ln, s-1+1) {\n            int rn = s-1 - ln;\n            string pat;\n            repeat (i,s)  pat += i + '0';\n            repeat (i,ln) pat += 'L';\n            repeat (i,rn) pat += 'R';\n            sort(pat.begin(), pat.end());\n            do {\n                result = max(result, evaluate(pat, r, w));\n            } while (next_permutation(pat.begin(), pat.end()));\n        }\n        if (result == -1) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.16lf\\n\", result);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct data{\n  double lm, rm, m;//l-min, r-max\n  int bit; \n  data(double l=0, double r=0, double m=0, int b=0):lm(l),rm(r),m(m),bit(b){}\n};\n\nint n;\ndouble r;\nvector<double> v;\n\nvoid solve(){\n  vector<data> res[7];\n  double ans = -1.0;\n  for(int i=0;i<n;i++) res[1].push_back(data(0,0,v[i],(1<<i)));\n  for(int i=2;i<=n;i++){\n    for(int j=1;j<i;j++){\n      int x1 = j, x2 = i - j;\n      for(int k=0;k<res[x1].size();k++){\n        for(int l=0;l<res[x2].size();l++){\n          if((res[x1][k].bit & res[x2][l].bit) != 0) continue;\n          data pos;\n          double a = res[x2][l].m / (res[x1][k].m + res[x2][l].m);\n          double b = 1.0 - a;\n          pos.lm = min(-a + res[x1][k].lm, b + res[x2][l].lm);\n          pos.rm = max(b + res[x2][l].rm, -a + res[x1][k].rm);\n          pos.m = res[x1][k].m + res[x2][l].m;\n          pos.bit = res[x1][k].bit | res[x2][l].bit;\n          if(pos.rm - pos.lm > r) continue;\n          else if(i == n) ans = max(ans, pos.rm - pos.lm);\n          else res[i].push_back(pos);\n        }\n      }\n    }\n  }\n  printf(\"%.9f\\n\",ans);\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n    cin >> r >> n;\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s,sum[10];\ndouble memo[10];\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  if(memo[v]>=0)return memo[v];\n  double res=0;\n  double tmp1=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r+EPS)res=max(res,tmp1);\n  if(tmp2<r+EPS)res=max(res,tmp2);\n  return memo[10]=res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      fill(memo,memo+10,-1);\n      double res=rec(0,1);\n      if(res<r+EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_S = 6;\nconst int INF = 1<<24;\nconst double EPS = 1e-5;\ndouble r;\nint s;\nint w[MAX_S];\n\nbool equals(double a, double b) {\n  return fabs(a-b) <= EPS;\n}\n\ndouble calc() {\n  double res = -1.0;\n  double pos[MAX_S];\n  int g[MAX_S];\n  int t[MAX_S];\n  for(int i = 1; i <= s-1; ++i) t[i-1] = i;\n\n  do {\n    fill(pos, pos+s, 0.0);\n    fill(g, g+s, 0);\n    int cnt = 1;\n    for(int k = 0; k < s-1; ++k) {\n      int a, b;\n      for(a = t[k]-1; a >= 0 && g[a] == g[t[k]-1]; --a) ; ++a;\n      for(b = t[k]; b < s && g[b] == g[t[k]]; ++b);\n\n      int sumA = accumulate(&w[a], &w[t[k]], 0);\n      int sumB = accumulate(&w[t[k]], &w[b], 0);\n      double d;\n\n      d = (double)sumB/(sumA+sumB);\n      for(int i = a; i < t[k]; ++i) {\n\tpos[i] -= d;\n\tg[i] = cnt;\n      }\n      ++cnt;\n\n      d = (double)sumA/(sumA+sumB);\n      for(int i = t[k]; i < b; ++i) {\n\tpos[i] += d;\n\tg[i] = cnt;\n      }\n      ++cnt;\n    }\n\n    sort(pos, pos+s);\n    double newV = pos[s-1] - pos[0];\n    if(!equals(newV, r) && newV < r) res = max(res, newV);\n\n  } while(next_permutation(t, t+s-1));\n  return res;\n}\n\ndouble solve() {\n  sort(w, w+s);\n  double res = -1.0;\n  do {\n    res = max(res, calc());\n  } while(next_permutation(w, w+s));\n  return res;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  for(int tc = 1; tc <= T; ++tc) {\n    cin >> r;\n    cin >> s;\n    for(int i = 0; i < s; ++i) {\n      cin >> w[i];\n    }\n    double ans = solve();\n    if(ans == -1) printf(\"%d\\n\", -1);\n    else printf(\"%.16f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct mobile{ double w,l,r; };\n\nvector<mobile> dfs(const vector<int> a){\n\tint n=a.size();\n\tif(n==1) return vector<mobile>(1,(mobile){a[0],0,0});\n\n\tvector<mobile> res;\n\trep(S,1<<n) if(0<S && S<(1<<n)-1) {\n\t\tvector<int> al,ar;\n\t\tdouble wl=0,wr=0;\n\t\trep(i,n){\n\t\t\tif(S&1<<i) al.push_back(a[i]), wl+=a[i];\n\t\t\telse       ar.push_back(a[i]), wr+=a[i];\n\t\t}\n\n\t\tvector<mobile> L=dfs(al),R=dfs(ar);\n\t\trep(i,L.size()) rep(j,R.size()) {\n\t\t\tdouble l2=min(-wr/(wl+wr)+L[i].l,wl/(wl+wr)+R[j].l);\n\t\t\tdouble r2=max(-wr/(wl+wr)+L[i].r,wl/(wl+wr)+R[j].r);\n\t\t\tres.push_back((mobile){wl+wr,l2,r2});\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tdouble W;\n\t\tint n; scanf(\"%lf%d\",&W,&n);\n\t\tvector<int> a(n);\n\t\trep(i,n) scanf(\"%d\",&a[i]);\n\n\t\tvector<mobile> res=dfs(a);\n\n\t\tdouble ans=-1;\n\t\trep(i,res.size()) if(res[i].r-res[i].l<W) ans=max(ans,res[i].r-res[i].l);\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      //double res=rec(1,1.0);\n      //if(res<r-EPS)ans=max(ans,res);\n      int sum[10];\n      fill(sum,sum+10,0);\n      for(int i=s-1;i>=0;i--)sum[i]+=sum[i+1]+w[i];\n      double res=1;\n      for(int i=1;i<s-3;i++)res+=w[i]/(w[i]+sum[i+1]);\n\n      if(res+w[s-2]/(w[s-2]+w[s-1])<r-EPS)\n        ans=max(ans,res+w[s-2]/(w[s-2]+w[s-1]));\n\n      if(res+w[s-1]/(w[s-2]+w[s-1])<r-EPS)\n        ans=max(ans,res+w[s-1]/(w[s-2]+w[s-1]));\n\n      for(int i=s-3;i<s-2;i++)res+=w[i]/(w[i]+sum[i+1]);\n\n      if(res+w[s-2]/(w[s-2]+w[s-1])<r-EPS)\n        ans=max(ans,res+w[s-2]/(w[s-2]+w[s-1]));\n\n      if(res+w[s-1]/(w[s-2]+w[s-1])<r-EPS)\n        ans=max(ans,res+w[s-1]/(w[s-2]+w[s-1]));\n\n\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - rw/(lw+rw);\n    double rx = x + lw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = -1;\n    for(P p:v)\n      if(p.second-p.first<len)ans = max(ans,p.second - p.first);\n    \n    if(ans<0) printf(\"-1\\n\");\n    else printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\tInfo left_info[12],right_info[12];\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tfor(int i = 0; i < info_index; i++){\n\t\t\tleft_info[i] = tmp_info[i];\n\t\t\tright_info[i] = tmp_info[i];\n\t\t}\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = left_info[left].weight;\n\t\tright_weight = left_info[right].weight;\n\n\t\tleft_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tleft_info[info_index].right = 1.0-left_info[info_index].left;\n\t\tleft_info[info_index].type = Mobile;\n\t\tleft_info[info_index].index_left = left;\n\t\tleft_info[info_index].index_right = right;\n\t\tleft_info[info_index].weight = left_weight+right_weight;\n\t\tleft_info[info_index].most_left_loc = max(left_info[info_index].left+left_info[left].most_left_loc,left_info[right].most_left_loc-left_info[info_index].right);\n\t\tleft_info[info_index].most_right_loc = max(left_info[info_index].right+left_info[right].most_right_loc,left_info[left].most_right_loc-left_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,left_info,info_index+1,S_1);\n\n\t\tif(left_info[left].type == Stone && left_info[right].type == Stone)return;\n\n\t\tfor(int i = 0; i < info_index; i++){\n\n\t\t\t\t\tright_info[i] = tmp_info[i];\n\t\t\t\t}\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = right_info[left].weight;\n\t\tright_weight = right_info[right].weight;\n\n\t\tright_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tright_info[info_index].right = 1.0-right_info[info_index].left;\n\t\tright_info[info_index].type = Mobile;\n\t\tright_info[info_index].index_left = left;\n\t\tright_info[info_index].index_right = right;\n\t\tright_info[info_index].weight = left_weight+right_weight;\n\t\tright_info[info_index].most_left_loc = max(right_info[info_index].left+right_info[left].most_left_loc,right_info[right].most_left_loc-right_info[info_index].right);\n\t\tright_info[info_index].most_right_loc = max(right_info[info_index].right+right_info[right].most_right_loc,right_info[left].most_right_loc-right_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,right_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<iomanip>\n\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nstruct Node\n{\n  ld left,right,lweight,rweight;\n  bool leaf;\n  Node(ld left=0,ld right=0,ld lweight=inf,ld rweight=inf):left(left),right(right),lweight(lweight),rweight(rweight)\n  {\n    leaf = true; \n  }\n};\n\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nvoid dfs(vector<Node> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(len >= 0);\n      if(!check(len))return;\n      ans = max(ans,len);\n      return;\n    }\n  /*\n  cout << \"vec ---- \" << endl;\n  rep(i,vec.size())cout << \"(\" << vec[i].left << \",\" << vec[i].right << \",\" << vec[i].lweight << \",\" << vec[i].rweight << \")\\n\";\n  cout << \"^^^^^^^^^^^^^\" << endl;\n  */\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\n\t  vector<Node> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  \n\t  if(vec[i].leaf && vec[j].leaf)\n\t    {\n\t      assert(vec[i].lweight == vec[i].rweight);\n\t      assert(vec[j].lweight == vec[j].rweight);\n\t      Node node = Node(0,1,vec[i].lweight,vec[j].rweight);\n\t      node.leaf = false;\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\n\t      //ループ回してるから両方やらなくて良いだろ女子高生\n\t      /*\n\t      node.lweight = vec[j].lweight;\n\t      node.rweight = vec[i].rweight;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\t      */\n\t    }\n\t  else if(!vec[i].leaf && !vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\n\t      ld lenA = A.right - A.left;\n\t      ld lenB = B.right - B.left;\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio - 1;\n\t      ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld lp = x - lenB * ratio;\n\t      ratio = B.lweight/(B.rweight+B.lweight);\n\t      ld rp = x + lenB * ratio;\n\n\t      Node C = Node(min(lp,A.left),max(rp,A.right),B.rweight+B.lweight,A.rweight+A.lweight);\n\t      C.leaf = false;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[i].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenB = B.right - B.left;\n\t      ld ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld x = lenB * ratio - 1;\n\n\t      assert(A.rweight == A.lweight);\n\t      Node C = Node(min(x,B.left),B.right,A.rweight,B.rweight+B.lweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenA = A.right - A.left;\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio + 1;\n\n\t      assert(B.rweight == B.lweight);\n\t      Node C = Node(A.left,max(A.right,x),A.rweight+A.lweight,B.rweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }  \n\t    }\n\t  else assert(false);\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<Node> vec(s);\n\n\t  rep(i,s)cin >> vec[i].lweight,vec[i].rweight = vec[i].lweight;\n\n\t  if(s == 1)\n\t    {\n\t      cout << 0 << endl;\n\t      continue;\n\t    }\n\n\t  dfs(vec);\t  \n\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)  REP(i,0,n)\nint gcd(int w,int m){\n  return m == 0?w:gcd(m,w%m);\n}\ndouble cost[N][N];\ndouble lcost[N][N];\ndouble rcost[N][N];\nint weight[N][N];\n\ndouble mcm(int n,int *inp,double lim){\n  rep(i,n)rep(j,n)weight[i][j]=0;\n  rep(i,n){\n    rcost[i][i]=lcost[i][i]=cost[i][i]=0;\n    weight[i][i]=inp[i];\n  }\n  \n  for(int l=2;l<n+1;l++){\n    for(int i=0;i<n-l+1;i++){\n      int j = i+l-1;//matrix i to j separated by k\n      cost[i][j]=-1;\n      for(int k=i;k<j;k++){\n\tif ( cost[i][k] == -1 || cost[k+1][j] == -1)continue;\n\tdouble tw=weight[i][k]+weight[k+1][j];\n\tdouble tmpr = max(weight[i][k]/(tw)+rcost[k+1][j],rcost[i][k]-weight[k+1][j]/(tw));\n\tdouble tmpl = max(weight[k+1][j]/(tw)+lcost[i][k],lcost[k+1][j]-weight[i][k]/(tw) );\n\t\n\n\n\tdouble tmp = tmpr+tmpl;\n\t\n\tif ( tmp <lim-eps && tmp >cost[i][j]){\n\t  cost[i][j]=tmp;\n\t  lcost[i][j]=tmpl;\n\t  rcost[i][j]=tmpr;\n\t  weight[i][j]=weight[k+1][j]+weight[i][k];\n\t}\n\t\n      }\n    }\n  }\n  \n  /*  \n rep(i,n){\n   rep(j,n){\n     cout <<cost[i][j] << \" \";\n   }\n   cout << endl;\n }\n cout << endl;\n cout << \"lcost \" << endl;\n rep(i,n){\n   rep(j,n)printf(\"%.3lf %.3lf : \",lcost[i][j],rcost[i][j]);\n   cout << endl;\n }\n  */\n \n return cost[0][n-1];\n}\n\n//critical case 1\nvoid solve(int n,double w,int *inp){\n  if ( n == 1){printf(\"%.8lf\\n\",0.);return;}\n sort(inp,inp+n);\n double ans = -1;\n do{\n   //   rep(i,n)cout << inp[i];\n   //cout << endl;\n   double tmp =mcm(n,inp,w);\n   if ( tmp != 0)ans = max(ans,tmp);\n }while( next_permutation(inp,inp+n));\n\n if ( ans == -1)puts(\"-1\");\n else printf(\"%.8lf\\n\",ans);\n\n}\n\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n   solve(n,r,inp);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-8;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=-1;\n  double tmp1=rec(v+1,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+1,L+w[v+1]/(w[v]+w[v+1]));\n  double tmp3=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp4=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  if(tmp3<r-EPS)res=max(res,tmp3);\n  if(tmp4<r-EPS)res=max(res,tmp4);\n\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(1,1.0);\n      if(res<r-EPS)ans=max(ans,res);\n      //res=rec(1,1.0);\n      //if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-8;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=0;\n  double tmp1=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(0,1);\n      //printf(\"%.16f\\n\",res);\n      if(res<r-EPS)ans=max(ans,res);\n      res=rec(1,1);\n      if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstruct node {\n  node *left, *right;\n  double w;\n  node() { left = right = NULL; }\n  node(node *left, node *right) : left(left), right(right) {}\n};\n\nstruct P {\n  double w;\n  double l, r;\n  P(double l, double r, double w) : l(l),r(r),w(w) {}\n};\nint s;\n\nmap<vector<double>, vector<P> > memo;\n\nvector<P> solve(vector<double> w) {\n  if (memo.count(w)) return memo[w];\n  int m = w.size();\n  if (m == 1) {\n    return vector<P>(1,P(0,0,w[0]));\n  }\n  vector<P> res;\n  for (int S=1; S<(1<<m)-1; ++S) {\n    vector<double> lw, rw;\n    REP(i, m) {\n      if (S>>i & 1) lw.push_back(w[i]);\n      else rw.push_back(w[i]);\n    }\n    vector<P> lp = solve(lw);\n    vector<P> rp = solve(rw);\n    // cout << \"lp = \";\n    // FOR(it, lw)\n    //   cout << *it << \" \";\n    // cout << endl;\n    // cout << \"rp = \";\n    // FOR(it, rw)\n    //   cout << *it << \" \";\n    // cout << endl;\n    FOR(lit, lp) {\n      FOR(rit, rp) {\n        //printf(\"((%f, %f), (%f,%f))\\n\", lit->l,lit->r,rit->l,rit->r);\n        double a = rit->w/(lit->w+rit->w);\n        double b = 1-a;\n        res.push_back(P(min(-a+lit->l, b+rit->l), max(-a+lit->r, b+rit->r), lit->w+rit->w));\n      }\n    }\n  }\n  return memo[w] = res;\n}\n\nint main() {\n  int N;\n  cin >> N;\n  while(N--) {\n    double r ;\n    cin >> r;\n    cin >> s;\n    vector<double > w(s);\n    REP(i, s)\n      cin >> w[i];\n    memo.clear();\n    vector<P> res = solve(w);\n    double ans = -1;\n    FOR(it, res) {\n      //cout << it->r - it->l << endl;;\n      if (it->r - it->l < r)\n        ans = max(ans, it->r - it->l);\n    }\n    if (ans == -1)\n      cout << -1 << endl;\n    else\n      printf(\"%.16f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        printf(\"%.18lf\\n\", ans);\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (pat[0] != 1) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<iomanip>\n\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nstruct Node\n{\n  ld left,right,lweight,rweight,middle;\n  bool leaf;\n  Node(ld left=0,ld right=0,ld lweight=inf,ld rweight=inf):left(left),right(right),lweight(lweight),rweight(rweight)\n  {\n    middle = inf;\n    leaf = true; \n  }\n};\n\ntypedef pair<Node,Node> NN;\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nvoid dfs(vector<Node> vec,vector<NN> path)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      /*\n      cout << \"path--------- ANS : \" << len << endl;\n      rep(i,path.size())\n\t{\n\t  cout << \"merge (\" << path[i].first.left << \",\" << path[i].first.right << \",\" << path[i].first.lweight << \",\" << path[i].first.rweight << \") (\" << path[i].second.left << \",\" << path[i].second.right << \",\" << path[i].second.lweight << \",\" << path[i].second.rweight << \")\" << endl;\n\t}\n      cout << \"last (\" << vec[0].left << \",\" << vec[0].right << \",\" << vec[0].lweight << \",\" << vec[0].rweight << \")\" << endl;\n      cout << \"^^^^^^^^^^^^\" << endl << endl;\n      */\n      assert(len >= 0);\n      if(!check(len))return;\n      ans = max(ans,len);\n      return;\n    }\n  /*\n  cout << \"vec ---- \" << endl;\n  rep(i,vec.size())cout << \"(\" << vec[i].left << \",\" << vec[i].right << \",\" << vec[i].lweight << \",\" << vec[i].rweight << \")\\n\";\n  cout << \"^^^^^^^^^^^^^\" << endl;\n  */\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\n\t  vector<Node> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  \n\t  if(vec[i].leaf && vec[j].leaf)\n\t    {\n\t      assert(vec[i].lweight == vec[i].rweight);\n\t      assert(vec[j].lweight == vec[j].rweight);\n\t      Node node = Node(0,1,vec[i].lweight,vec[j].rweight);\n\t      node.leaf = false;\n\t      node.middle = vec[i].rweight/(vec[i].rweight+vec[j].rweight);\n\t      {\n\t\tvector<NN> p2 = path;//:::::\n\t\tp2.push_back(NN(vec[i],vec[j]));\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2,p2);\n\t      }\n\n\t      //ループ回してるから両方やらなくて良いだろ女子高生\n\t      /*\n\t      node.lweight = vec[j].lweight;\n\t      node.rweight = vec[i].rweight;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\t      */\n\t    }\n\t  else if(!vec[i].leaf && !vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\n\t      ld lenA = A.right - A.left;\n\t      ld lenB = B.right - B.left;\n\t      assert(equals(lenA,0) || lenA > 0);\n\t      assert(equals(lenB,0) || lenB > 0);\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = A.left + A.middle + 1;\n\t      ld lp = x - B.middle;\n\t      ld rp = x + (lenB-B.middle);\n\n\t      Node C = Node(min(lp,A.left),max(rp,A.right),B.rweight+B.lweight,A.rweight+A.lweight);\n\t      C.leaf = false;\n\t      ratio = C.rweight / (C.rweight+C.lweight);\n\t      C.middle = ratio * (C.right - C.left) + A.left + A.middle;\n\t      vector<NN> p2 = path;//::::\n\t      {\n\t\tp2.push_back(NN(A,B));\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2,p2);\n\t      }\n\n\t    }\n\t  else if(vec[i].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenB = B.right - B.left;\n\t      assert(equals(lenB,0) || lenB > 0);\n\t      ld x = -B.left + B.middle - 1;\n\n\t      assert(A.rweight == A.lweight);\n\t      Node C = Node(min(x,B.left),B.right,A.rweight,B.rweight+B.lweight);\n\t      C.leaf = false;\n\t      ld ratio = (B.rweight+B.lweight)/(A.rweight+(B.rweight+B.lweight));\n\t      C.middle = B.left + B.middle - ratio * (C.right-C.left);\n\t      vector<NN> p2 = path;//:::::::\n\t      p2.push_back(NN(A,B));\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2,p2);\n\t      }\n\n\t    }\n\t  else if(vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenA = A.right - A.left;\n\t      assert(equals(lenA,0) || lenA > 0);\n\t      ld x = -A.left + A.middle + 1;\n\n\t      assert(B.rweight == B.lweight);\n\t      Node C = Node(A.left,max(A.right,x),A.rweight+A.lweight,B.rweight);\n\t      C.leaf = false;\n\t      ld ratio = B.rweight/((A.rweight+A.lweight)+B.rweight);\n\t      C.middle = A.left + A.middle + ratio * (C.right-C.left);\n\t      vector<NN> p2 = path;//::::\n\t      {\n\t\tp2.push_back(NN(A,B));\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2,p2);\n\t      }  \n\t    }\n\t  else assert(false);\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<Node> vec(s);\n\n\t  rep(i,s)cin >> vec[i].lweight,vec[i].rweight = vec[i].lweight;\n\n\t  if(s == 1)\n\t    {\n\t      cout << 0 << endl;\n\t      continue;\n\t    }\n\t  vector<NN> path;\n\t  dfs(vec,path);\t  \n\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,NEXT;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tNEXT.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tNEXT.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,NEXT);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = NEXT.top();\n\t\tNEXT.pop();\n\t\tright = NEXT.top();\n\t\tNEXT.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);\n\n\t\t/*if(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tNEXT.pop();\n\t\tswap(left,right);\n\n\t\tswap(tmp_info[info_index].left,tmp_info[info_index].right);\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);*/\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tprintf(\"0.00000000\\n\");\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n \nconst double EPS = 1e-9;\n \nstruct data{\n  double lm, rm, m;//l-min, r-max\n  int bit; \n  data(double l=0, double r=0, double m=0, int b=0):lm(l),rm(r),m(m),bit(b){}\n};\n \nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n \nint n;\ndouble r;\nvector<double> v;\n \nvoid solve(){\n  if(n == 1){\n    cout << 0.0 << endl;\n    return;\n  }\n \n  vector<data> res[7];\n  double ans = -1.0;\n  for(int i=0;i<n;i++) res[1].push_back(data(0,0,v[i],(1<<i)));\n  for(int i=2;i<=n;i++){\n    for(int j=1;j<i;j++){\n      int x1 = j, x2 = i - j;\n      for(int k=0;k<res[x1].size();k++){\n        for(int l=0;l<res[x2].size();l++){\n          if((res[x1][k].bit & res[x2][l].bit) != 0) continue;\n          data pos;\n          double a = res[x2][l].m / (res[x1][k].m + res[x2][l].m);\n          double b = 1.0 - a;\n          pos.lm = min(-a + res[x1][k].lm, b + res[x2][l].lm);\n          pos.rm = max(b + res[x2][l].rm, -a + res[x1][k].rm);\n          pos.m = res[x1][k].m + res[x2][l].m;\n          pos.bit = res[x1][k].bit | res[x2][l].bit;\n          if(pos.rm - pos.lm > r || equal(pos.rm-pos.lm,r)) continue;\n          else if(i == n) ans = max(ans, pos.rm - pos.lm);\n          else res[i].push_back(pos);\n        }\n      }\n    }\n  }\n  if(ans < 0) cout << -1 << endl;\n  else printf(\"%.9f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - lw/(lw+rw);\n    double rx = x + rw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = -1;\n    for(P p:v)\n      if(p.second-p.first<=len)ans = max(ans,p.second - p.first);\n    if(ans<0)cout<<-1<<endl;\n    else printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;};\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;};\n\nsigned main(){\n  Int T;\n  cin>>T;\n\n  cout<<fixed<<setprecision(12);\n  while(T--){\n    double width;\n    Int n;\n    cin>>width>>n;\n    vector<double> w(n);\n    for(Int i=0;i<n;i++) cin>>w[i];\n\n    using P = pair<double, double>;\n    Int s=1<<n;\n    vector<double> sum(s,0);\n    for(Int b=0;b<s;b++)\n      for(Int i=0;i<n;i++)\n\tif((b>>i)&1) sum[b]+=w[i];\n\n    function<vector<P>(Int, double)> dfs=[&](Int b,double pos){\n      vector<P> res;      \n      if(__builtin_popcount(b)==1){\n\tres.emplace_back(pos,pos);\n\treturn res;\n      }\n      for(Int nb=b;nb;nb=(nb-1)&b){\n\tif(nb==b) continue;\n\tassert(nb&&(nb^b));\n\tdouble x=sum[nb],y=sum[nb^b];\n\tdouble aa=1.0/(1.0+x/y);\n\tdouble bb=1.0-aa;\n\tauto l=dfs(nb,pos-aa);\n\tauto r=dfs(nb^b,pos+bb);\n\tfor(auto p:l) \n\t  for(auto q:r)\n\t    res.emplace_back(min({p.first,q.first,p.second,q.second}),\n\t\t\t     max({p.first,q.first,p.second,q.second}));\n      }\n      return res;\n    };\n    \n    double ans=-1; \n    auto v=dfs(s-1,0);\n    for(auto p:v) if(p.second-p.first<width) chmax(ans,p.second-p.first);\n    \n    if(ans<0) cout<<\"-1\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)  REP(i,0,n)\n\ndouble cost[N][N];\ndouble lcost[N][N];\ndouble rcost[N][N];\nint weight[N][N];\n\ndouble mcm(int n,int *inp,double lim){\n  rep(i,n)rep(j,n)weight[i][j]=0;\n  rep(i,n){\n    rcost[i][i]=lcost[i][i]=cost[i][i]=0;\n    weight[i][i]=inp[i];\n  }\n  \n  for(int l=2;l<n+1;l++){\n    for(int i=0;i<n-l+1;i++){\n      int j = i+l-1;//matrix i to j separated by k\n      cost[i][j]=-1;\n      for(int k=i;k<j;k++){\n\tif ( cost[i][k] == -1 || cost[k+1][j] == -1)continue;\n\tdouble tw=weight[i][k]+weight[k+1][j];\n\t\n\t//double tmpr =rcost[k+1][j]+(weight[i][k])/tw,tmpl=lcost[i][k]+(weight[k+1][j])/tw;\n\t//double tmp=1+rcost[k+1][j]+lcost[i][k];\n\tdouble tmpr = max(weight[i][k]/tw+rcost[k+1][j],rcost[i][k]-weight[k+1][j]/tw);\n\tdouble tmpl = max(weight[k+1][j]/tw+lcost[i][k],lcost[k+1][j]-weight[i][k]/tw);\n\t\n\n\n\tdouble tmp = tmpr+tmpl;\n\t\n\tif ( tmp <lim+eps && tmp >cost[i][j]){\n\t  cost[i][j]=tmp;\n\t  lcost[i][j]=tmpl;\n\t  rcost[i][j]=tmpr;\n\t  weight[i][j]=weight[k+1][j]+weight[i][k];\n\t}\n\t\n      }\n    }\n  }\n  \n  /*  \n rep(i,n){\n   rep(j,n){\n     cout <<cost[i][j] << \" \";\n   }\n   cout << endl;\n }\n cout << endl;\n cout << \"lcost \" << endl;\n rep(i,n){\n   rep(j,n)printf(\"%.3lf %.3lf : \",lcost[i][j],rcost[i][j]);\n   cout << endl;\n }\n  */\n \n return cost[0][n-1];\n}\n\n//critical case 1\nvoid solve(int n,double w,int *inp){\n sort(inp,inp+n);\n double ans = -1;\n do{\n   //   rep(i,n)cout << inp[i];\n   //cout << endl;\n   double tmp =mcm(n,inp,w);\n   if ( tmp != 0)ans = max(ans,tmp);\n }while( next_permutation(inp,inp+n));\n\n if ( ans == -1)puts(\"-1\");\n else printf(\"%.9lf\\n\",ans);\n\n}\n\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n   solve(n,r,inp);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=0;\n  double tmp1=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(0,1);\n      //printf(\"%.16f\\n\",res);\n      if(res<r-EPS)ans=max(ans,res);\n      res=rec(1,1);\n      if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct data{\n  double lm, rm, m;//l-min, r-max\n  int bit; \n  data(double l=0, double r=0, double m=0, int b=0):lm(l),rm(r),m(m),bit(b){}\n};\n\nint n;\ndouble r;\nvector<double> v;\n\nvoid solve(){\n  vector<data> res[7];\n  double ans = -1.0;\n  for(int i=0;i<n;i++) res[1].push_back(data(0,0,v[i],(1<<i)));\n  for(int i=2;i<=n;i++){\n    for(int j=1;j<i;j++){\n      int x1 = j, x2 = i - j;\n      for(int k=0;k<res[x1].size();k++){\n        for(int l=0;l<res[x2].size();l++){\n          if((res[x1][k].bit & res[x2][l].bit) != 0) continue;\n          data pos;\n          double a = res[x2][l].m / (res[x1][k].m + res[x2][l].m);\n          double b = 1.0 - a;\n          pos.lm = min(-a + res[x1][k].lm, b + res[x2][l].lm);\n          pos.rm = max(b + res[x2][l].rm, -a + res[x1][k].rm);\n          pos.m = res[x1][k].m + res[x2][l].m;\n          pos.bit = res[x1][k].bit | res[x2][l].bit;\n          if(pos.rm - pos.lm > r) continue;\n          else if(i == n) ans = max(ans, pos.rm - pos.lm);\n          else res[i].push_back(pos);\n        }\n      }\n    }\n  }\n  printf(\"%.9f\\n\",ans);\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n    cin >> r >> n;\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#define INF (1<<29)\nusing namespace std;\n \nconst double EPS=1e-10;\n \nstruct rod{\n  double l,r,w;\n  rod(double l=0,double r=0,double w=INF):l(l),r(r),w(w){}\n};\n \nrod Merge(rod a,rod b){\n  rod res;\n  res.w=a.w+b.w;\n  double mid=b.w/(a.w+b.w);\n  res.l=min(-b.w/(a.w+b.w)+a.l,b.l+(1-mid));\n  res.r=max(a.w/(a.w+b.w)+b.r,a.r-mid);\n  return res;\n}\n\ndouble r,ans;\n \nvoid rec(vector<rod>v){\n  int vl=v.size();\n  if(vl<=1){\n    double res=v[0].r-v[0].l;\n    if(res<r-EPS)ans=max(ans,res);\n    return;\n  }\n  for(int i=0;i<vl;i++){\n    for(int j=0;j<vl;j++){\n      if(i==j)continue;\n      vector<rod>nx;\n      for(int k=0;k<vl;k++){\n        if(k==i || k==j)continue;\n        nx.push_back(v[k]);\n      }\n      nx.push_back(Merge(v[i],v[j]));\n      rec(nx);\n    }\n  }\n \n}\n \nint main(void){\n \n  int T;\n  cin >> T;\n  while(T--){\n    int s;\n    cin >> r >> s;\n    vector<rod>v(s);\n    for(int i=0;i<s;i++)cin >> v[i].w;\n    ans=-INF;\n    rec(v);\n    if(ans<0)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[11];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][11];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[11],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[11];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[11];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[11],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_1);\n\n\t\tif(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tswap(tmp_info[info_index].left,tmp_info[info_index].right);\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[11];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 11; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[11];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - lw/(lw+rw);\n    double rx = x + rw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = -1;\n    for(P p:v)\n      if(p.second-p.first<=len)ans = max(ans,p.second - p.first);\n    printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble r,w[6],ans,cal,LL,RR,s[300];\nint n,t[300],cnt;\n\nvoid dfs(int p,double c){\n  if(s[p*2+1])dfs(p*2+2,c+s[p*2+1]/s[p]);\n  if(s[p*2+2])dfs(p*2+1,c-s[p*2+2]/s[p]);\n  RR=max(c,RR);\n  LL=min(c,LL);\n}\n\ndouble dfs2(int p){\n  double rm,lm;\n  if(t[p*2+1])lm=dfs2(p*2+1);\n  else s[p*2+1]=lm=w[cnt++];\n  if(t[p*2+2])rm=dfs2(p*2+2);\n  else s[p*2+2]=rm=w[cnt++];\n  return s[p]=lm+rm;\n}\n\nvoid check(){\n  sort(w,w+n);\n  do{\n    cnt=0;\n    LL=0,RR=0;\n    memset(s,0,sizeof(s));\n    dfs2(0);\n    dfs(0,0);\n    cal=RR-LL;\n    if(cal<=r)ans=max(ans,cal);\n  }while(next_permutation(w,w+n));\n}\n\nvoid dfs1(int p,int c){\n  if(t[p])return;\n  if(c==n){check();return;}\n  t[p]=1;\n  for(int i=0;i<16;i++){\n    if(t[i]){\n      dfs1(2*p+1,c+1);\n      dfs1(2*p+2,c+1);\n    }\n  }\n  t[p]=0;\n}\n\n\nint main(){\n\n\n  int T;\n  cin>>T;\n  while(T--){\n    ans=-1;\n    cin>>r>>n;\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(t,0,sizeof(t));\n    if(n>=2)dfs1(0,1);\n    else ans=0;\n    printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - lw/(lw+rw);\n    double rx = x + rw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = -1;\n    for(P p:v)\n      if(p.second-p.first<len)ans = max(ans,p.second - p.first);\n    \n    if(ans<0) printf(\"-1\\n\");\n    else printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<quadmath.h>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\n\n__float128 rec(int v,__float128 L){\n  if(v>=s)return L;\n  __float128 res=-1;\n  __float128 tmp1=rec(v+1,L+w[v]/(w[v]+w[v+1]));\n  __float128 tmp2=rec(v+1,L+w[v+1]/(w[v]+w[v+1]));\n  __float128 tmp3=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  __float128 tmp4=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  if(tmp3<r-EPS)res=max(res,tmp3);\n  if(tmp4<r-EPS)res=max(res,tmp4);\n\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    __float128 ans=-1;\n    sort(all(w));\n    do{\n      __float128 res=rec(1,1.0);\n      if(res<r-EPS)ans=max(ans,res);\n      /*\n      int sum[10];\n      fill(sum,sum+10,0);\n      for(int i=s-1;i>=0;i--)sum[i]+=sum[i+1]+w[i];\n      double res=1;\n      for(int i=1;i<s-2;i++)res+=w[i]/(w[i]+sum[i+1]);\n\n      if(res+w[s-2]/(w[s-2]+w[s-1])<r-EPS)\n        ans=max(ans,res+w[s-2]/(w[s-2]+w[s-1]));\n      if(res+w[s-1]/(w[s-2]+w[s-1])<r-EPS)\n        ans=max(ans,res+w[s-1]/(w[s-2]+w[s-1]));\n      */\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16Qf\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ndouble R;\nint n, a[100];\n\nstruct ST {\n    double w, a, h;\n    ST() {}\n    ST(double w, double a, double h) : w(w), a(a), h(h) {}\n};\n\nbool operator<(const ST& a, const ST& b) {\n    if (a.w != b.w) return a.w < b.w;\n    if (a.a != b.a) return a.a < b.a;\n    return a.h < b.h;\n}\n\nbool operator==(const ST& a, const ST& b) {\n    return !(a < b) && !(b < a);\n}\n\nST combine(const ST& p, const ST& q) {\n    const double a = p.h / (p.h+q.h);\n    double l = min(-a-p.a, (1-a)-q.a);\n    double r = max((1-a)+(q.w-q.a), -a+(p.w-p.a));\n    return ST(r-l, p.a+a, p.h+q.h);\n}\n\nmap<int, vector<ST> > memo;\n\nvector<ST> calc(int u) {\n    if ((u&(u-1)) == 0) {\n        int ix = -1;\n        rep (i, n) if (u&(1<<i)) ix = i;\n        return vector<ST>(1, ST(0, 0, a[ix]));\n    }\n    if (memo.count(u)) return memo[u];\n    vector<ST> ans;\n    rep (b, 1<<n) if ((u&b) == b && b != u && b != 0) {\n        vector<ST> x = calc(b);\n        vector<ST> y = calc(u-b);\n        rep (i, x.size()) rep (j, y.size()) {\n            ans.push_back(combine(x[i], y[j]));\n        }\n    }\n//    sort(ans.begin(), ans.end());\n//    ans.erase(unique(ans.begin(), ans.end()), ans.end());\n    return memo[u] = ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%lf%d\", &R, &n);\n        rep (i, n) scanf(\"%d\", a+i);\n        memo.clear();\n        vector<ST> ws = calc((1<<n)-1);\n        double ans = -1;\n        rep (i, ws.size()) if (ws[i].w <= R) ans = max(ans, ws[i].w);\n        if (ans < 0) printf(\"%d\\n\", -1);\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst double eps = 1e-8;\n\nstruct state{\n  double left,right,weight;\n};\n\ndouble r;\nint n;\nint w[6];\n\nstate merge(state a,state b){\n  double sum=a.weight+b.weight;\n  double aleft=a.left - b.weight/sum;\n  double bleft=b.left + a.weight/sum;\n  double left=min(aleft,bleft);\n  double aright=a.right - b.weight/sum;\n  double bright=b.right + a.weight/sum;\n  double right=max(aright,bright);\n  return (state){left,right,sum};\n}\n\ndouble calc(vector<state> u){\n  vector<state> tmp=u;\n  \n  int t[6]={0,1,2,3,4,5};\n  int a[6];\n  double res=-1;\n  \n  do{\n    u=tmp;\n    \n    for(int i=0;i<n-1;i++)a[i]=t[i];\n    \n    for(int i=0;i<n-1;i++){\n      int c=0;\n      for(int j=i+1;j<n-1;j++){\n        if(a[i]<a[j])c++;\n      }\n      a[i]=c;\n    }\n\n    for(int i=0;i<n-1;i++){\n      int id=a[i];\n      u[id]=merge(u[id],u[id+1]);\n      u.erase( u.begin() + id + 1);\n    }\n    double value=u[0].right-u[0].left;\n    if( value < r + eps )      res=max(res,value);\n    \n  }while( next_permutation(t,t+n-1) );\n  \n  return res;\n}\n\ndouble solve(){\n  int t[6]={0,1,2,3,4,5};\n  double res=-1;\n  \n  do{\n    vector< state > u(n);\n    \n    for(int i=0;i<n;i++){\n      u[i]=(state){ 0.0, 0.0, (double)w[ t[i] ]};\n    }\n\n\n    res=max(res,calc(u));\n    \n  }while( next_permutation(t,t+n) );\n\n  if(res < r + eps )return res;\n  else return -1;\n}\n\nint main(){\n  int Tc;\n  cin>>Tc;\n  while(Tc--){\n    cin>>r;\n    cin>>n;\n    for(int i=0;i<n;i++)cin>>w[i];\n    double ans=solve();\n    if(ans<0){\n      cout<<\"-1\"<<endl;\n    }else{\n      printf(\"%.10f\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef long double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= S - 1; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18Lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        if (S == 1) {\n            return 0;\n        }\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,NEXT;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tNEXT.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tNEXT.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,NEXT);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = NEXT.top();\n\t\tNEXT.pop();\n\t\tright = NEXT.top();\n\t\tNEXT.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);\n\n\t\tif(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tNEXT.pop();\n\t\tswap(left,right);\n\n\t\tswap(tmp_info[info_index].left,tmp_info[info_index].right);\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tprintf(\"0.00000000\\n\");\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef long double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        pat.clear();\n        for (int k = 0; k < S - 1; k++) pat.push_back(0);\n        for (int i = 1; i <= S; i++) pat.push_back(i);\n        ans = max(ans, solve());\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18Lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] == 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                nleft = 1.0 / w * b.w + a.left;\n                nright = 1.0 / w * a.w + b.right;\n                stack.push_back(State(a.w + b.w, nleft, nright));\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        if (S == 1) return 0;\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            assert(c <= S - 1);\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        pat.clear();\n        for (int k = 0; k < S - 1; k++) pat.push_back(0);\n        for (int i = 1; i <= S; i++) pat.push_back(i);\n        ans = max(ans, solve());\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] == 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                nleft = 1.0 / w * b.w + a.left;\n                nright = 1.0 / w * a.w + b.right;\n                stack.push_back(State(a.w + b.w, nleft, nright));\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        if (S == 1) return 0;\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            assert(c <= S - 1);\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        printf(\"%.18lf\\n\", ans);\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (pat[0] <= 0 || pat[1] <= 0) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<cassert>\n#include<map>\n#include<set>\n#include<iomanip>\n\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nstruct Node\n{\n  ld left,right,lweight,rweight;\n  bool leaf;\n  Node(ld left=0,ld right=0,ld lweight=inf,ld rweight=inf):left(left),right(right),lweight(lweight),rweight(rweight)\n  {\n    leaf = true; \n  }\n};\n\nld r,ans;\nint s;\n\nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n\nvoid dfs(vector<Node> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(len >= 0);\n      if(!check(len))return;\n      ans = max(ans,len);\n      return;\n    }\n  /*\n  cout << \"vec ---- \" << endl;\n  rep(i,vec.size())cout << \"(\" << vec[i].left << \",\" << vec[i].right << \",\" << vec[i].lweight << \",\" << vec[i].rweight << \")\\n\";\n  cout << \"^^^^^^^^^^^^^\" << endl;\n  */\n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\n\t  vector<Node> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  \n\t  if(vec[i].leaf && vec[j].leaf)\n\t    {\n\t      assert(vec[i].lweight == vec[i].rweight);\n\t      assert(vec[j].lweight == vec[j].rweight);\n\t      Node node = Node(0,1,vec[i].lweight,vec[j].rweight);\n\t      node.leaf = false;\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\n\t      //ループ回してるから両方やらなくて良いだろ女子高生\n\t      /*\n\t      node.lweight = vec[j].lweight;\n\t      node.rweight = vec[i].rweight;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(node);\n\t\tdfs(nvec2);\n\t      }\n\t      */\n\t    }\n\t  else if(!vec[i].leaf && !vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\n\t      ld lenA = A.right - A.left;\n\t      ld lenB = B.right - B.left;\n\t      assert(equals(lenA,0) || lenA > 0);\n\t      assert(equals(lenB,0) || lenB > 0);\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio - 1;\n\t      ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld lp = x - lenB * ratio;\n\t      ratio = B.lweight/(B.rweight+B.lweight);\n\t      ld rp = x + lenB * ratio;\n\n\t      Node C = Node(min(lp,A.left),max(rp,A.right),B.rweight+B.lweight,A.rweight+A.lweight);\n\t      C.leaf = false;\n\n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[i].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenB = B.right - B.left;\n\t      assert(equals(lenB,0) || lenB > 0);\n\t      ld ratio = B.rweight/(B.rweight+B.lweight);\n\t      ld x = lenB * ratio - 1;\n\n\t      assert(A.rweight == A.lweight);\n\t      Node C = Node(min(x,B.left),B.right,A.rweight,B.rweight+B.lweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }\n\n\t    }\n\t  else if(vec[j].leaf)\n\t    {\n\t      Node A = vec[i];\n\t      Node B = vec[j];\t      \n\t      ld lenA = A.right - A.left;\n\t      assert(equals(lenA,0) || lenA > 0);\n\t      ld ratio = A.rweight/(A.rweight+A.lweight);\n\t      ld x = lenA * ratio + 1;\n\n\t      assert(B.rweight == B.lweight);\n\t      Node C = Node(A.left,max(A.right,x),A.rweight+A.lweight,B.rweight);\n\t      C.leaf = false;\n\t      \n\t      {\n\t\tvector<Node> nvec2 = nvec;\n\t\tnvec2.push_back(C);\n\t\tdfs(nvec2);\n\t      }  \n\t    }\n\t  else assert(false);\n\t}\n    }\n\n}\n\nint main()\n{\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<Node> vec(s);\n\n\t  rep(i,s)cin >> vec[i].lweight,vec[i].rweight = vec[i].lweight;\n\n\t  if(s == 1)\n\t    {\n\t      cout << 0 << endl;\n\t      continue;\n\t    }\n\n\t  dfs(vec);\t  \n\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(10) << ans << endl;\n\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\nconst int MAX_N = 6;\nconst int INF = 1<<24;\nconst double EPS = 1e-6;\n\nbool equals(double a, double b) {\n  return fabs(a-b) < EPS;\n}\n\ndouble r;\nint s;\nint w[MAX_N];\n\n\nint sum(int a, int b) {\n  int res = 0;\n  for(int i = a; i < b; ++i) {\n    res += w[i];\n  }\n  return res;\n}\n/*\npair<double, double> rec(double x, int a, int b) {\n  if(b-a == 1) {\n    return make_pair(x, x);\n  }\n  pair<double, double> res, p;\n  res = make_pair(-INF, INF);\n  for(int i = a+1; i < b; ++i) {\n    int su = sum(a, b);\n    int u = sum(a, i);\n    int v = sum(i, b);\n    p = rec(x-(double)v/su, a, i);\n    res.first = max(res.first, p.first);\n    p = rec(x+(double)u/su, i, b);\n    res.second = min(res.second, p.second);\n  }\n  return res;\n}\n*/\ndouble calc() {\n  int t[MAX_N];\n  for(int i = 1; i <= s-1; ++i) {\n    t[i-1] = i;\n  }\n\n  double pos[MAX_N];\n  int g[MAX_N];\n  double res = -INF;\n\n  do {\n    fill(pos, pos+s, 0.0);\n    fill(g, g+s, 0);\n    for(int k = 0; k < s-1; ++k) {\n      int a, b;\n      int sa, sb;\n      for(a = t[k]-1; a >= 0 && g[a] == g[t[k]-1]; --a); ++a;\n      for(b = t[k]; b < s && g[b] == g[t[k]]; ++b);\n      sa = sum(a, t[k]);\n      sb = sum(t[k], b);\n      for(int i = a; i < t[k]; ++i) {\n\tpos[i] -= (double)sb/(sa+sb);\n\tg[i] += 1;\n      }\n      for(int i = t[k]; i < b; ++i) {\n\tpos[i] += (double)sa/(sa+sb);\n\tg[i] += 2;\n      }\n    }\n    double minv, maxv;\n    minv = INF;\n    maxv = -INF;\n    for(int i = 0; i < s; ++i) {\n      minv = min(minv, pos[i]);\n      maxv = max(maxv, pos[i]);\n    }\n    double newv = maxv - minv;\n    if(!equals(newv, r) && newv <= r) res = max(res, newv);\n\n  } while(next_permutation(t, t+s-1));\n\n  return res;\n}\n\ndouble solve() {\n  sort(w, w+s);\n  double res = -INF;\n  do {\n    //    pair<double, double> p = rec(0.0, 0, s);\n    //    double newV = p.second - p.first;\n    double newV = calc();\n    res = max(res, newV);\n  } while(next_permutation(w, w+s));\n  return res == -INF ? -1 : res;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  for(int tc = 1; tc <= T; ++tc) {\n    cin >> r;\n    cin >> s;\n    for(int i = 0; i < s; ++i) {\n      cin >> w[i];\n    }\n    double res = solve();\n    if(res == -1) printf(\"%d\\n\", -1);\n    else printf(\"%.16f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= S; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(parse(), ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n \nusing namespace std;\nconst int N = 10;\nconst int M = 105;\nconst double INF = 0x3f3f3f3f;\n \nint n, v[N], t[M];\ndouble R, w[N], ans, l[M], r[M], val[M];\n \nvoid init () {\n\tmemset(t, 0, sizeof(t));\n\tmemset(v, 0, sizeof(v));\n\tt[1] = -1; ans = -1;\n \n\tscanf(\"%lf%d\", &R, &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &w[i]);\n}\n \nvoid judge(int u) {\n\tmemset(l, 0, sizeof(l));\n\tmemset(r, 0, sizeof(r));\n\tmemset(val, 0, sizeof(val));\n \n\tfor (int i = u; i; i--) {\n\t\tif (t[i] == -1) {\n\t\t\tint x = i*2, y = i*2+1;\n\t\t\tval[i] = val[x] + val[y];\n\t\t\tdouble Li = val[y] / val[i];\n\t\t\tdouble Ri = val[x] / val[i];\n \n\t\t\tl[i] = min(-Li+l[x], Ri+l[y]);\n\t\t\tr[i] = max(-Li+r[x], Ri+r[y]);\n\t\t} else if (t[i]) {\n\t\t\tval[i] = w[t[i]];\n\t\t}\n\t}\n \n\tdouble tmp = r[1] - l[1];\n\tif (tmp - R < 1e-5 && tmp > ans) ans = tmp;\n}\n \nvoid dfs(int u, int m, int use) {\n \n\tif (use == 0) {\n\t\tjudge(u-1);\n\t\treturn;\n\t}\n \n\tif (t[u/2] != -1)  {\n\t\tdfs(u+1, m, use);\n\t} else {\n \n\t\tif (use > m) {\n\t\t\tt[u] = -1;\n\t\t\tdfs(u+1, m+1, use);\n\t\t\tt[u] = 0;\n\t\t}\n \n\t\tif (m == 1 && use > 1) return;\n \n\t\tfor (int i = 1; i <= n; i++) if (!v[i]) {\n\t\t\tv[i] = 1; t[u] = i;\n\t\t\tdfs(u+1, m-1, use-1);\n\t\t\tv[i] = 0; t[u] = 0;\n\t\t}\n\t}\n}\n \nint main () {\n\tint cas;\n\tscanf(\"%d\", &cas);\n\twhile (cas--) {\n\t\tinit();\n\t\tif (n == 1) printf(\"%.10lf\\n\", 0.0);\t\n\t\telse {\n\t\t\tdfs(2, 2, n);\n\t\t\tif (ans == -1) printf(\"-1\\n\");\n\t\t\telse printf(\"%.10lf\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <complex>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,double> P;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n\ndouble r;\nint n;\ndouble w[10];\n\nvector<P> solve(vector<int> rem,double x){\n  vector<P> res;\n  int n = rem.size();\n\n  if(n == 1){\n    res.push_back(P(x,x));\n    return res;\n  }\n\n  sort(rem.begin(),rem.end());\n\n  do{\n    for(int i=1;i<n;i++){\n      vector<int> left_rem(rem.begin(),rem.begin()+i);\n      vector<int> right_rem(rem.begin()+i,rem.end());\n      double lw = 0;\n      double rw = 0;\n      rep(j,i) lw += w[left_rem[j]];\n      rep(j,n-i) rw += w[right_rem[j]];\n\n      double lx = x - rw / (lw + rw);\n      double rx = x + 1 - rw / (lw + rw);\n\n      vector<P> lv = solve(left_rem,lx);\n      vector<P> rv = solve(right_rem,rx);\n\n      rep(i,lv.size()){\n        rep(j,rv.size()){\n          res.push_back(P(min(lv[i].first,rv[j].first),\n                          max(lv[i].second,rv[j].second)));\n        }\n      }\n    }\n  }while(next_permutation(rem.begin(),rem.end()));\n\n  return res;\n}\n\nint main(){\n  int T;\n  cin>>T;\n\n  while(T--){\n    cin>>r>>n;\n    rep(i,n){\n      cin>>w[i];\n    }\n\n    vector<int> rem;\n    rep(i,n) rem.push_back(i);\n\n    double ans = -1;\n    vector<P> v = solve(rem,0);\n    rep(i,v.size()){\n      if(v[i].second - v[i].first < r){\n        ans = max(ans, v[i].second - v[i].first);\n      }\n    }\n    if(ans == -1)\n      printf(\"-1\\n\");\n    else\n      printf(\"%.16f\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nstruct mobile_t {\n    int w; // weight\n    double l; // left\n    double r; // right\n};\nconst double eps = 0.0001;\ndouble evaluate(vector<int> const & p) {\n    stack<mobile_t> stk;\n    for (int w : p) {\n        if (w == 0) {\n            if (stk.size() < 2) return -1;\n            mobile_t x = stk.top(); stk.pop();\n            mobile_t y = stk.top(); stk.pop();\n            mobile_t z;\n            z.w = x.w + y.w;\n            double dx = y.w /(double) (x.w + y.w);\n            double dy = x.w /(double) (x.w + y.w);\n            z.l = max(x.l + dx, y.l - dy);\n            z.r = max(x.r - dx, y.r + dy);\n            stk.push(z);\n        } else {\n            stk.push((mobile_t){ w, 0.0, 0.0 });\n        }\n    }\n    if (stk.size() != 1) return -1;\n    return stk.top().l + stk.top().r;\n}\nint main() {\n    int datasets; cin >> datasets;\n    repeat (dataset, datasets) {\n        double r; cin >> r;\n        int s; cin >> s;\n        vector<int> w(s); repeat (i,s) cin >> w[i];\n        double result = -1;\n        vector<int> p;\n        repeat (i,s)   p.push_back(w[i]);\n        repeat (i,s-1) p.push_back(0);\n        sort(p.begin(), p.end());\n        do {\n            double it = evaluate(p);\n            if (r + eps < it) continue;\n            result = max(result, it);\n        } while (next_permutation(p.begin(), p.end()));\n        if (result == -1) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%.16lf\\n\", result);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n \n};\n \n#define Line pair<point,point>\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n \ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n \nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1 + (a2 - a1) * (cross(b2 - b1,b1 - a1) / cross(b2 - b1,a2 - a1));\n}\n\npoint symmetry(point p1, point p2, point Q){\n  double xa,ya,xb,yb,t1,t2;\n  point R;\n \n  xa=Q.x-p1.x,ya=Q.y-p1.y;\n  xb=p2.x-p1.x,yb=p2.y-p1.y;\n \n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n \n  R.x=2*(p1.x+xb*t1/t2)-Q.x;\n  R.y=2*(p1.y+yb*t1/t2)-Q.y;\n  return R;\n}\n\n Line parallel_line(point a,point b,double h){\n    double t = atan((a.y-b.y)/(a.x-b.x));\n \n    point a_(a.x + h*cos(t+PI/2), a.y + h*sin(t+PI/2));\n    point b_(b.x + h*cos(t+PI/2), b.y + h*sin(t+PI/2));\n \n    if(ccw(a,b,a_)==-1)a_=symmetry(a,b,a_),b_=symmetry(a,b,b_);\n \n    return make_pair(a_,b_);\n}\n\nvector<point> convex_cut(vector<point>pol,point a,point b){\n  vector<point>q;\n  for (int i=0; i<pol.size();i++) {\n    point A=curr(pol,i),B=next(pol, i);\n    if (ccw(a,b,A)!=-1)q.push_back(A);\n    if (ccw(a,b,A)*ccw(a,b,B)<0)\n      q.push_back(intersection_l(A,B,a,b));\n  }\n  return q;\n}\n\nbool C(vector<point>pol,double d){\n  vector<Line>L;\n  for(int i=0;i<pol.size();i++){\n    L.push_back(Line(curr(pol,i),next(pol,i)));\n  }\n  \n  for(int i=0;i<L.size();i++){\n    Line tmp=parallel_line(L[i].first,L[i].second,d);\n    pol=convex_cut(pol,tmp.first,tmp.second);\n  }\n  return pol.size()>0;\n}\n\ndouble Binary_search(vector<point>pol){\n  double l=0,r=10000,tc=50;\n  while(tc--){\n    double d=(l+r)/2;\n    if(C(pol,d))l=d;\n    else r=d;\n  }\n  return l;\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>pol(n);\n    for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n    printf(\"%.6f\",Binary_search(pol));\n    cout << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_1);\n\n\t\tif(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <ctime>\n#include <cstdio>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <set>\n#include <stack>\n#include <queue>\n#include <string>\n#include <vector>\n#include <map>\n#define maxn 560000\n#define maxl 1000000000\n#define mod 1000000007\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nconst double eps=1e-12;\ndouble r,best;\n\nstruct Stone{\n\tdouble l,r;\n\tint w;\n\tStone(double ll=0,double rr=0,int ww=0){\n\t\tl=ll;r=rr;w=ww;\n\t}\n\tvoid print()const{\n\t\tcout<<l<<\" \"<<r<<\" \"<<w<<endl;\n\t}\n}a[maxn];\n\nStone make_stone(int w1,int w2,double l1,double r1,double l2,double r2){\n\tdouble l,r,midl,midr;\n\tmidl=(double)w1/(w1+w2);\n\tmidr=1-midl;\n\tl=max(l1+midl,l2-midr);\n\tr=max(r2+midr,r1-midl);\n\treturn Stone(l,r,w1+w2);\n}\n\nvector<Stone> add(const Stone &s1,const Stone &s2){\n\tvector<Stone> vv;\n\tvv.clear();\n\tvv.push_back(make_stone(s1.w,s2.w,s1.l,s1.r,s2.l,s2.r));\n\tif(fabs(s1.r-s1.l)>eps)vv.push_back(make_stone(s1.w,s2.w,s1.r,s1.l,s2.l,s2.r));\n\tif(fabs(s2.r-s2.l)>eps)vv.push_back(make_stone(s1.w,s2.w,s1.l,s1.r,s2.r,s2.l));\n\tif(fabs(s1.r-s1.l)>eps && fabs(s2.r-s2.l)>eps)vv.push_back(make_stone(s1.w,s2.w,s1.r,s1.l,s2.r,s2.l));\n\treturn vv;\n}\n\nvoid dfs(const vector<Stone> &v){\n\tif(v.size()==1){\n\t\t//v[0].print();\n\t\tif(v[0].l+v[0].r<r)best=max(v[0].l+v[0].r,best);\n\t\treturn;\n\t}\n\tint i,j,k;\n\tfor(i=0;i<v.size();++i)\n\t\tfor(j=0;j<v.size();++j)if(i!=j){\n\t\t\tvector<Stone> vv,mid=add(v[i],v[j]);\n\t\t\t//cout<<mid.size()<<endl;\n\t\t\tvv.clear();\n\t\t\tfor(k=0;k<v.size();++k)if(k!=i && k!=j)vv.push_back(v[k]);\n\t\t\tfor(k=0;k<mid.size();++k){\n\t\t\t//\tmid[k].print();\n\t\t\t//\tv[i].print();\n\t\t\t//\tv[j].print();\n\t\t\t//\tmid[k].print();\n\t\t\t//\tcout<<\"-------------------\"<<endl;\n\t\t\t\tif(mid[k].l+mid[k].r<r){\n\t\t\t\t\tvv.push_back(mid[k]);\n\t\t\t\t\tdfs(vv);\n\t\t\t\t\tvv.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n}\n\t\t\t\nvoid solve(){\n\tint n,i,x;\n\tscanf(\"%lf%d\",&r,&n);\n\tvector<Stone> v;\n\tv.clear();\n\tfor(i=1;i<=n;++i){\n\t\tscanf(\"%d\",&x);\n\t\tv.push_back(Stone(0,0,x));\n\t}\n\tbest=-1;\n\tdfs(v);\n\tif(best<0)printf(\"-1\\n\");else printf(\"%.12f\\n\",best);\n}\n\t\t\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t-->0)solve();\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\tInfo left_info[12],right_info[12];\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tfor(int i = 0; i < info_index; i++){\n\t\t\tleft_info[i] = tmp_info[i];\n\t\t\tright_info[i] = tmp_info[i];\n\t\t}\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = left_info[left].weight;\n\t\tright_weight = left_info[right].weight;\n\n\t\tleft_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tleft_info[info_index].right = 1.0-left_info[info_index].left;\n\t\tleft_info[info_index].type = Mobile;\n\t\tleft_info[info_index].index_left = left;\n\t\tleft_info[info_index].index_right = right;\n\t\tleft_info[info_index].weight = left_weight+right_weight;\n\t\tleft_info[info_index].most_left_loc = max(left_info[info_index].left+left_info[left].most_left_loc,left_info[right].most_left_loc-left_info[info_index].right);\n\t\tleft_info[info_index].most_right_loc = max(left_info[info_index].right+left_info[right].most_right_loc,left_info[left].most_right_loc-left_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,left_info,info_index+1,S_1);\n\n\n\t\t/*right = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = right_info[left].weight;\n\t\tright_weight = right_info[right].weight;\n\n\t\tright_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\tright_info[info_index].right = 1.0-right_info[info_index].left;\n\t\tright_info[info_index].type = Mobile;\n\t\tright_info[info_index].index_left = left;\n\t\tright_info[info_index].index_right = right;\n\t\tright_info[info_index].weight = left_weight+right_weight;\n\t\tright_info[info_index].most_left_loc = max(right_info[info_index].left+right_info[left].most_left_loc,right_info[right].most_left_loc-right_info[info_index].right);\n\t\tright_info[info_index].most_right_loc = max(right_info[info_index].right+right_info[right].most_right_loc,right_info[left].most_right_loc-right_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,right_info,info_index+1,S_2);*/\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<cassert>\n#include<iomanip>\n#include<set>\n#include<map>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define all(n) (n).begin(),(n).end()\n\nusing namespace std;\ntypedef long double ld;\n\nld r,ans;\nint s;\nvector<ld> w;\n\nvoid dfs(vector<ld> www,ld cost,ld frac,ld denom)\n{\n  int sz = www.size();\n  //cout << \"cost = \" << frac << \"/\" << denom << \" = \" << frac/denom << endl;\n  ld ncost = frac/denom;\n  if(equals(ncost,r) || ncost > r)return;\n  if(sz <= 2)\n    {\n      ld ncost = frac/denom;\n      if(equals(ncost,r) || ncost > r)return;\n      ans = max(ans,ncost);\n      return;\n    }\n\n  rep(i,sz)\n    {\n      rep(j,sz)\n\t{\n\t  if(i == j)continue;\n\t  vector<ld> www2;\n\t  ld a = www[i],b = www[j];\n\t  rep(k,sz)\n\t    {\n\t      if(k == i || k == j)continue;\n\t      else www2.push_back(www[k]);\n\t    }\n\t  www2.push_back(www[i]+www[j]);\n\t  ld nfrac = a;\n\t  ld ndenom = a+b;\n\t  dfs(www2,cost+(a/(a+b)),ndenom*frac+denom*nfrac,ndenom*denom);\n\t  nfrac = b;\n\t  dfs(www2,cost+(b/(a+b)),ndenom*frac+denom*nfrac,ndenom*denom);\n\t}\n    }\n\n}\n\nint main()\n{\n  //__float128 a;\n  //__float80 a;\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  ans = -inf;\n\t  cin >> r;\n\t  cin >> s;\n\t  w.clear();\n\t  w.resize(s);\n\t  rep(i,s)cin >> w[i];\n\n\t  //cout << \"w = \";\n\t  //rep(i,w.size())cout << w[i] << \" \";\n\t  //cout << endl;\n\t  if(s == 1)\n\t    {\n\t      cout << 0 << endl;\n\t      continue;\n\t    }\n\t  dfs(w,(ld)1,(ld)1,(ld)1);\n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(16) << ans << endl;\n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - lw/(lw+rw);\n    double rx = x + rw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = -1;\n    for(P p:v)\n      if(p.second-p.first<len)ans = max(ans,p.second - p.first);\n    printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ndouble r,w[6],ans,cal,LL,RR,s[300];\nint n,t[300],cnt;\n\nvoid dfs(int p,double c){\n  if(s[p*2+1])dfs(p*2+2,c+s[p*2+1]/s[p]);\n  if(s[p*2+2])dfs(p*2+1,c-s[p*2+2]/s[p]);\n  RR=max(c,RR);\n  LL=min(c,LL);\n}\n\ndouble dfs2(int p){\n  double rm,lm;\n  if(t[p*2+1])lm=dfs2(p*2+1);\n  else s[p*2+1]=lm=w[cnt++];\n  if(t[p*2+2])rm=dfs2(p*2+2);\n  else s[p*2+2]=rm=w[cnt++];\n  return s[p]=lm+rm;\n}\n\nvoid check(){\n  sort(w,w+n);\n  do{\n    cnt=0;\n    LL=0,RR=0;\n    memset(s,0,sizeof(s));\n    dfs2(0);\n    dfs(0,0);\n    cal=RR-LL;\n    if(cal<=r)ans=max(ans,cal);\n  }while(next_permutation(w,w+n));\n}\n\nvoid dfs1(int p,int c){\n  if(t[p])return;\n  if(c==n){check();return;}\n  t[p]=1;\n  for(int i=0;i<16;i++){\n    if(t[i]){\n      dfs1(2*p+1,c+1);\n      dfs1(2*p+2,c+1);\n    }\n  }\n  t[p]=0;\n}\n\n\nint main(){\n\n\n  int T;\n  cin>>T;\n  while(T--){\n    ans=-1;\n    cin>>r>>n;\n    for(int i=0;i<n;i++)cin>>w[i];\n    memset(t,0,sizeof(t));\n    if(n<=2)dfs1(0,1);\n    else ans=0;\n    printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef long double real;\n\n    real EPS = 1e-6;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        pat.clear();\n        for (int k = 0; k < S - 1; k++) pat.push_back(0);\n        for (int i = 1; i <= S; i++) pat.push_back(i);\n        ans = max(ans, solve());\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18Lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] == 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                nleft = 1.0 / w * b.w + a.left;\n                nright = 1.0 / w * a.w + b.right;\n                stack.push_back(State(a.w + b.w, nleft, nright));\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    real solve() {\n        if (S == 1) return 0;\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            real c = parse();\n            assert(c <= S - 1);\n            if (c > R - EPS) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=(int)b;i<(int)n;i++)\n#define rep(i,n)  REP(i,0,n)\n\ndouble ans = -1;\n\n\nvoid solve(int n,int now,bool *used,double *rc,double *lc,double lim,double c,int *weight){\n  if ( n-1 == now){\n    ans = max(ans,c);\n    return;\n  }\n  \n  //left i , right j\n  rep(i,n){\n    if ( used[i] == true)continue;\n    rep(j,n){\n      if (i == j)continue;\n      if ( used[j] == true)continue;\n      double w = weight[i]+weight[j];\n      double tmpr=max(weight[i]/w+rc[j],-weight[j]/w+rc[i]);\n      double tmpl=max(weight[j]/w+lc[i],-weight[i]/w+lc[j]);\n\n      if ( tmpr+tmpl >lim+eps){continue;}\n      double tr=rc[i],tl=lc[i];int tw=weight[i];\n      used[j]=true;\n      rc[i]=tmpr;\n      lc[i]=tmpl;\n      weight[i]=weight[i]+weight[j];\n      solve(n,now+1,used,rc,lc,lim,tmpr+tmpl,weight);\n      rc[i]=tr;\n      lc[i]=tl;\n      weight[i]=tw;\n      used[j]=false;\n    }\n  }\n  \n}\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n\n   double rc[n],lc[n];\n   bool used[n];\n   rep(i,n)rc[i]=lc[i]=0,used[i]=false;\n   ans=-1;\n\n   solve(n,0,used,rc,lc,r,0,inp);\n   if ( ans == -1)puts(\"-1\");\n   else printf(\"%.9lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<double,double> P;\ntypedef vector<P> PV;\n\ndouble room, w[10], wts[1 << 10];\nint s;\n\nbool onlyOne(int bit){\n  int cnt = 0;\n  for(int i = 0; i < s; i++){\n    if(bit & (1 << i)){\n      cnt++;\n    }\n  }\n  return cnt == 1;\n}\n\nPV solve(double x, int rem){\n  PV res;\n\n  if(onlyOne(rem)){\n    res.push_back(P(x, x));\n    return res;\n  }\n\n  for(int l = 1; l <= rem; l++){\n    if((rem | l) != rem) continue;\n\n    double wl = wts[l];\n\n    for(int r = 1; r <= rem; r++){\n      if(l & r) continue;\n      if((l | r) != rem) continue;\n\n      double wr = wts[r];\n      double a = wr / (wl + wr);\n\n      PV pvl = solve(x - a, l);\n      PV pvr = solve(x + (1.0 - a), r);\n\n      for(int i = 0; i < pvl.size(); i++){\n\tfor(int j = 0; j < pvr.size(); j++){\n\t  double L = min(pvl[i].first, pvr[j].first);\n\t  double R = max(pvl[i].second, pvr[j].second);\n\t  if(R - L > room) continue;\n\t  res.push_back(P(L, R));\n\t}\n      }\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  int T;\n  cin >> T;\n\n  while(T--){\n    cin >> room >> s;\n    for(int i = 0; i < s; i++){\n      cin >> w[i];\n    }\n\n    for(int i = 0; i < (1 << s); i++){\n      wts[i] = 0;\n\n      for(int j = 0; j < s; j++){\n\tif(i & (1 << j)){\n\t  wts[i] += w[j];\n\t}\n      }\n    }\n\n    PV pv = solve(0, (1 << s) - 1);\n\n    double ans = -1;\n\n    for(int i = 0; i < pv.size(); i++){\n      ans = max(ans, pv[i].second - pv[i].first);\n    }\n\n    if(ans == -1){\n      cout << -1 << endl;\n    }\n    else{\n      cout << fixed << setprecision(10) << ans << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\nvoid prB(int S){\n  for(int i=0;i<6;i++){\n    int x=(S>>i);\n    cout<<(x&1)<<\" \";\n  }\n  cout<<endl;\n}\ndouble width;\nint n;\nint t[6];\n \nint mem[(1<<7)];\nint calc(int S){\n  if(mem[S]!=-1)return mem[S];\n  int x=S&-S;\n  return mem[S]=calc(S-x)+calc(x);\n}\n \nvector<double> dp[(1<<7)];\nvector<double> dp2[(1<<7)];\nbool vd[(1<<7)];\nvoid rec(int S){\n  if(vd[S])return;\n  vd[S]=true;\n  int sub=S;\n  do{\n    if(sub!=S&&sub!=0){\n      int lS=sub,rS=S-sub;\n      rec(lS);rec(rS);\n      double lsum=calc(lS),rsum=calc(rS);\n     \n      double ld=rsum/(lsum+rsum);\n      double rd=lsum/(lsum+rsum);\n      for(int i=0;i<(int)dp[lS].size();i++){\n    for(int j=0;j<(int)dp[rS].size();j++){\n      double nl=min(dp[lS][i]-ld,dp[rS][j]+rd);\n      double nr=max(dp2[lS][i]-ld,dp2[rS][j]+rd);\n      dp[S].push_back(nl);\n      dp2[S].push_back(nr);\n    }\n      }\n    }\n    sub=(sub-1)&S;\n  }while(sub!=S);\n}\n \nvoid solve(){\n  for(int i=0;i<n;i++){\n    vd[(1<<i)]=true;\n    dp[(1<<i)].push_back(0);\n    dp2[(1<<i)].push_back(0);\n  }\n  int U=(1<<n)-1;\n  rec(U);\n  double ans=-1.0;\n  for(int i=0;i<(int)dp[U].size();i++){\n    double d=dp2[U][i]-dp[U][i];\n    if( d < width + 0.00001  )ans=max(ans,d);\n  }\n  if(ans==-1.0)cout<<\"-1\"<<endl;\n  else printf(\"%.10f\\n\",ans);\n}\n \nvoid init(){\n  for(int i=0;i<(1<<7);i++){\n    vd[i]=0;\n    mem[i]=-1;\n    dp[i].clear();\n    dp2[i].clear();\n  }\n  mem[0]=0;\n  for(int i=0;i<n;i++)mem[(1<<i)]=t[i];\n}\n \nint main(){\n  int Tc;\n  cin>>Tc;\n  for(int tc=1;tc<=Tc;tc++){\n    cin>>width>>n;\n    for(int i=0;i<n;i++)cin>>t[i];\n    init();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\ndouble R;\nint n, a[100];\n\nstruct ST {\n    double w, a, h;\n    ST() {}\n    ST(double w, double a, double h) : w(w), a(a), h(h) {}\n};\n\nbool operator<(const ST& a, const ST& b) {\n    if (a.w != b.w) return a.w < b.w;\n    if (a.a != b.a) return a.a < b.a;\n    return a.h < b.h;\n}\n\nbool operator==(const ST& a, const ST& b) {\n    return !(a < b) && !(b < a);\n}\n\nST combine(const ST& p, const ST& q) {\n    const double a = p.h / (p.h+q.h);\n    double l = min(-a-p.a, (1-a)-q.a);\n    double r = max((1-a)+(q.w-q.a), -a+(p.w-p.a));\n    return ST(r-l, -l, p.h+q.h);\n}\n\nmap<int, vector<ST> > memo;\n\nvector<ST> calc(int u) {\n    if ((u&(u-1)) == 0) {\n        int ix = -1;\n        rep (i, n) if (u&(1<<i)) ix = i;\n        return vector<ST>(1, ST(0, 0, a[ix]));\n    }\n    if (memo.count(u)) return memo[u];\n    vector<ST> ans;\n    rep (b, 1<<n) if ((u&b) == b && b != u && b != 0) {\n        vector<ST> x = calc(b);\n        vector<ST> y = calc(u-b);\n        rep (i, x.size()) rep (j, y.size()) {\n            ans.push_back(combine(x[i], y[j]));\n        }\n    }\n//    sort(ans.begin(), ans.end());\n//    ans.erase(unique(ans.begin(), ans.end()), ans.end());\n    return memo[u] = ans;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%lf%d\", &R, &n);\n        rep (i, n) scanf(\"%d\", a+i);\n        memo.clear();\n        vector<ST> ws = calc((1<<n)-1);\n        double ans = -1;\n        rep (i, ws.size()) if (ws[i].w <= R) ans = max(ans, ws[i].w);\n        if (ans < 0) printf(\"%d\\n\", -1);\n        else printf(\"%.12f\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;};\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;};\n\nsigned main(){\n  Int T;\n  cin>>T;\n\n  cout<<fixed<<setprecision(12);\n  while(T--){\n    double width;\n    Int n;\n    cin>>width>>n;\n    vector<double> w(n);\n    for(Int i=0;i<n;i++) cin>>w[i];\n\n    using P = pair<double, double>;\n    Int s=1<<n;\n    vector<double> sum(s,0);\n    for(Int b=0;b<s;b++)\n      for(Int i=0;i<n;i++)\n\tif((b>>i)&1) sum[b]+=w[i];\n\n    function<vector<P>(Int, double)> dfs=[&](Int b,double pos){\n      vector<P> res;      \n      if(__builtin_popcount(b)==1){\n\tres.emplace_back(pos,pos);\n\treturn res;\n      }\n      for(Int nb=b;nb;nb=(nb-1)&b){\n\tif(nb==b) continue;\n\tassert(nb&&(nb^b));\n\tdouble x=sum[nb],y=sum[nb^b];\n\tdouble aa=1.0/(1.0+x/y);\n\tdouble bb=1.0-aa;\n\tauto l=dfs(nb,pos-aa);\n\tauto r=dfs(nb^b,pos+bb);\n\tfor(auto p:l) \n\t  for(auto q:r)\n\t    res.emplace_back(min({p.first,q.first,p.second,q.second}),\n\t\t\t     max({p.first,q.first,p.second,q.second}));\n      }\n      return res;\n    };\n    \n    double ans=-1; \n    auto v=dfs(s-1,0);\n    for(auto p:v) if(p.second-p.first<width) chmax(ans,p.second-p.first);\n    \n    if(ans<0) cout<<\"-1\"<<endl;\n    else cout<<ans<<endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef long double real;\n\n    real EPS = 1e-9;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        pat.clear();\n        for (int k = 0; k < S - 1; k++) pat.push_back(0);\n        for (int i = 0; i < S; i++) pat.push_back(W[i]);\n        ans = max(ans, solve());\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18Lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] == 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                int w = a.w + b.w;\n                real L = 1.0 / w * b.w, R = 1.0 / w * a.w;\n                real nleft = max(L + a.left, b.left - R);\n                real nright = max(R + b.right, a.right - L);\n                stack.push_back(State(a.w + b.w, nleft, nright));\n                ans = max(ans, nleft + nright);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(pat[i], 0, 0));\n            }\n        }\n        assert(stack.size() == 1);\n        return ans;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            real c = parse();\n            //printf(\"c: %.18Lf  \", c); cout << pat << endl;\n            if (c > R + EPS) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= S; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        printf(\"%.18lf\\n\", ans);\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (pat[0] != 1) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_1);\n\n\t\tif(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n\n    if(s<=2){\n      printf(\"1.0000000000\\n\");\n      continue;\n    }\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      int sum[10];\n      fill(sum,sum+10,0);\n      for(int i=s-1;i>=0;i--)sum[i]+=sum[i+1]+w[i];\n      double res=1;\n      for(int i=1;i<s-3;i++)res+=w[i]/(w[i]+sum[i+1]);\n\n      double tmp1=w[s-2]/(w[s-2]+w[s-1]);\n      if(res+tmp1<r-EPS)\n        ans=max(ans,res+tmp1);\n\n      double tmp2=w[s-1]/(w[s-2]+w[s-1]);\n      if(res+tmp2<r-EPS)\n        ans=max(ans,res+tmp2);\n\n      for(int i=s-3;i<s-2;i++)res+=w[i]/(w[i]+sum[i+1]);\n\n      tmp1=w[s-2]/(w[s-2]+w[s-1]);\n      if(res+tmp1<r-EPS)\n        ans=max(ans,res+tmp1);\n\n      tmp2=w[s-1]/(w[s-2]+w[s-1]);\n      if(res+tmp2<r-EPS)\n        ans=max(ans,res+tmp2);\n\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        printf(\"%.18lf\\n\", ans);\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    inline bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                c--;\n                if (c <= 0) return false;\n            } else {\n                c++;\n            }\n        }\n        return c == 1;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<double,double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\ndouble r;\nint s;\nint w[101];\n\nvector<P> dfs(vector<int> stones){\n    if(stones.size()==1){\n        vector<P> res;\n        res.push_back(P(0,0));\n        return res;\n    }\n    vector<int> v,v2;\n    vector<P> ret;\n    for(int s=0;s<(1<<stones.size());s++){\n        v.clear();\n        v2.clear();\n        int sum1=0;\n        int sum2=0;\n        for(int i = 0; i < stones.size(); i++){\n            if((s>>i)&1){\n                sum1+=w[stones[i]];\n                v.push_back(stones[i]);\n            }\n            else{\n                sum2+=w[stones[i]];\n                v2.push_back(stones[i]);\n            }\n        }\n        if(v.size()==0||v2.size()==0)continue;\n        double b=(double)sum1/(sum1+sum2);\n        double a=(double)sum2/(sum1+sum2);\n        vector<P> res1=dfs(v);\n        vector<P> res2=dfs(v2);\n        //if(stones.size()==3){\n        //    cout<<endl;\n        //}\n        for(int i = 0; i < res1.size(); i++){\n            for(int j = 0; j < res2.size(); j++){\n                double left=res1[i].first-a;\n                double right=res1[i].second-a;\n                double left2=res2[j].first+b;\n                double right2=res2[j].second+b;\n                double minn=min(left,min(left2,min(right,right2)));\n                double maxn=max(left,max(left2,max(right,right2)));\n                if(EQ(maxn,0.5)&&EQ(minn,0)){\n                  //  cout<<endl;\n                }\n                ret.push_back(P(minn,maxn));\n            }\n        }\n    }\n    return ret;\n}\n\nconst double INF=1000000000;\nint main(){\n\n    int t;\n    cin>>t;\n    while(t--){\n        cin>>r>>s;\n        vector<int> ss;\n        for(int i = 0; i < s; i++){\n            cin>>w[i];\n            ss.push_back(i);\n        }\n        vector<P> res=dfs(ss);\n        double maxl=-1;\n        for(int i = 0; i < res.size(); i++){\n            double len=abs(res[i].first-res[i].second);\n            if(!EQ(len,r)&&len<r){\n                maxl=max(maxl,len);\n            }\n        }\n        if(!EQ(maxl,-1)){\n            printf(\"%.7f\\n\",maxl);\n        }\n        else\n            cout<<-1<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\ntypedef pair<double,double> P;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b))<EPS)\n\ndouble r;\nint s;\nint w[101];\n\nvector<P> dfs(vector<int> stones){\n    if(stones.size()==1){\n        vector<P> res;\n        res.push_back(P(0,0));\n        return res;\n    }\n    vector<int> v,v2;\n    vector<P> ret;\n    for(int s=0;s<(1<<stones.size());s++){\n        v.clear();\n        v2.clear();\n        int sum1=0;\n        int sum2=0;\n        for(int i = 0; i < stones.size(); i++){\n            if((s>>i)&1){\n                sum1+=w[stones[i]];\n                v.push_back(stones[i]);\n            }\n            else{\n                sum2+=w[stones[i]];\n                v2.push_back(stones[i]);\n            }\n        }\n        if(v.size()==0||v2.size()==0)continue;\n        double b=(double)sum1/(sum1+sum2);\n        double a=(double)sum2/(sum1+sum2);\n        vector<P> res1=dfs(v);\n        vector<P> res2=dfs(v2);\n        for(int i = 0; i < res1.size(); i++){\n            for(int j = 0; j < res2.size(); j++){\n                double left=res1[i].first-a;\n                double right=res1[i].second-a;\n                double left2=res2[j].first+b;\n                double right2=res2[j].second+b;\n                double minn=min(left,min(left2,min(right,right2)));\n                double maxn=max(left,max(left2,max(right,right2)));\n                ret.push_back(P(minn,maxn));\n            }\n        }\n    }\n    return ret;\n}\n\nconst double INF=1000000000;\nint main(){\n\n    int t;\n    cin>>t;\n    while(t--){\n        cin>>r>>s;\n        vector<int> ss;\n        for(int i = 0; i < s; i++){\n            cin>>w[i];\n            ss.push_back(i);\n        }\n        vector<P> res=dfs(ss);\n        double maxl=-1;\n        for(int i = 0; i < res.size(); i++){\n            double len=abs(res[i].first-res[i].second);\n            if(!EQ(len,r)&&len<r){\n                maxl=max(maxl,len);\n            }\n        }\n        if(!EQ(maxl,-1))\n            printf(\"%.10f\\n\",maxl);\n        else\n            cout<<-1<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\npair<double, double> solve(int a, int b, vector<int>& w, vector<int>& x)\n{\n    if(a == b)\n        return make_pair(0.0, 0.0);\n\n    int c = min_element(x.begin()+a, x.begin()+b) - x.begin();\n    int left = accumulate(w.begin()+a, w.begin()+c+1, 0);\n    int right = accumulate(w.begin()+c+1, w.begin()+b+1, 0);\n\n    pair<double, double> p = solve(a, c, w, x);\n    pair<double, double> q = solve(c+1, b, w, x);\n    p.first  -= right / (double)(left + right);\n    p.second -= right / (double)(left + right);\n    q.first  += left  / (double)(left + right);\n    q.second += left  / (double)(left + right);\n\n    return make_pair(min(p.first, q.first), max(p.second, q.second));\n}\n\nint main()\n{\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        double r;\n        int s;\n        cin >> r >> s;\n        vector<int> w(s);\n        for(int i=0; i<s; ++i)\n            cin >> w[i];\n\n        sort(w.begin(), w.end());\n        \n        double ret = -1.0;\n        do{\n            vector<int> x(s-1);\n            for(int i=0; i<s-1; ++i)\n                x[i] = i;\n\n            do{\n                pair<double, double> p = solve(0, s-1, w, x);\n                double len = p.second - p.first;\n                if(len < r)\n                    ret = max(ret, len);\n            }while(next_permutation(x.begin(), x.end()));\n        }while(next_permutation(w.begin(), w.end()));\n\n        if(ret < -0.5)\n            cout << -1 << endl;\n        else\n            printf(\"%.10f\\n\", ret);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\nconst int MAX_N = 6;\nconst int INF = 1<<24;\nconst double EPS = 1e-5;\n\nbool equals(double a, double b) {\n  return fabs(a-b) <= EPS;\n}\n\ndouble r;\nint s;\nint w[MAX_N];\n\n\nint sum(int a, int b) {\n  int res = 0;\n  for(int i = a; i < b; ++i) {\n    res += w[i];\n  }\n  return res;\n}\n/*\npair<double, double> rec(double x, int a, int b) {\n  if(b-a == 1) {\n    return make_pair(x, x);\n  }\n  pair<double, double> res, p;\n  res = make_pair(-INF, INF);\n  for(int i = a+1; i < b; ++i) {\n    int su = sum(a, b);\n    int u = sum(a, i);\n    int v = sum(i, b);\n    p = rec(x-(double)v/su, a, i);\n    res.first = max(res.first, p.first);\n    p = rec(x+(double)u/su, i, b);\n    res.second = min(res.second, p.second);\n  }\n  return res;\n}\n*/\ndouble calc() {\n  int t[MAX_N];\n  for(int i = 1; i <= s-1; ++i) {\n    t[i-1] = i;\n  }\n\n  double pos[MAX_N];\n  int g[MAX_N];\n  double res = -INF;\n\n  do {\n    int cnt = 1;\n    fill(pos, pos+s, 0.0);\n    fill(g, g+s, 0);\n    for(int k = 0; k < s-1; ++k) {\n      int a, b;\n      int sa, sb;\n      for(a = t[k]-1; a >= 0 && g[a] == g[t[k]-1]; --a); ++a;\n      for(b = t[k]; b < s && g[b] == g[t[k]]; ++b);\n      sa = sum(a, t[k]);\n      sb = sum(t[k], b);\n      for(int i = a; i < t[k]; ++i) {\n\tpos[i] -= (double)sb/(sa+sb);\n\tg[i] = cnt;\n      }\n      ++cnt;\n      for(int i = t[k]; i < b; ++i) {\n\tpos[i] += (double)sa/(sa+sb);\n\tg[i] = cnt;\n      }\n      ++cnt;\n    }\n    double minv, maxv;\n    minv = INF;\n    maxv = -INF;\n    for(int i = 0; i < s; ++i) {\n      minv = min(minv, pos[i]);\n      maxv = max(maxv, pos[i]);\n    }\n    double newv = maxv - minv;\n    if(!equals(newv, r) && newv < r) res = max(res, newv);\n\n  } while(next_permutation(t, t+s-1));\n\n  return res;\n}\n\ndouble solve() {\n  sort(w, w+s);\n  double res = -INF;\n  do {\n    //    pair<double, double> p = rec(0.0, 0, s);\n    //    double newV = p.second - p.first;\n    double newV = calc();\n    res = max(res, newV);\n  } while(next_permutation(w, w+s));\n  return res == -INF ? -1 : res;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  for(int tc = 1; tc <= T; ++tc) {\n    cin >> r;\n    cin >> s;\n    for(int i = 0; i < s; ++i) {\n      cin >> w[i];\n    }\n    double res = solve();\n    if(res == -1) printf(\"%d\\n\", -1);\n    else printf(\"%.16f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,S_1,S_2;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tS_1.push(WORK.top());\n\t\tS_2.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tS_1.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,S_1);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = S_1.top();\n\t\tS_1.pop();\n\t\tright = S_1.top();\n\t\tS_1.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_1.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_1);\n\n\t\tif(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tright = S_2.top();\n\t\tS_2.pop();\n\t\tleft = S_2.top();\n\t\tS_2.pop();\n\n\t\tswap(tmp_info[info_index].left,tmp_info[info_index].right);\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tS_2.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,S_2);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <cassert>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\n#define repeat_from_reverse(i,m,n) for (int i = (n)-1; (i) >= (m); --(i))\n#define repeat_reverse(i,n) repeat_from_reverse(i,0,n)\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl\nusing namespace std;\nstruct mobile_t {\n    int w; // weight\n    double l; // left\n    double r; // right\n};\nconst double eps = 0.0001;\ndouble evaluate(string const & pat, double r, vector<int> const & w) {\n    stack<mobile_t> stk;\n    for (char c : pat) {\n        if (c == 'L' or c == 'R') {\n            if (stk.size() < 2) return -1;\n            mobile_t x = stk.top(); stk.pop();\n            mobile_t y = stk.top(); stk.pop();\n            mobile_t z;\n            z.w = x.w + y.w;\n            double xofs = y.w /(double) (x.w + y.w);\n            double yofs = x.w /(double) (x.w + y.w);\n            z.l = max(x.l + xofs, y.l - yofs);\n            z.r = max(x.r - xofs, y.r + yofs);\n            if (c == 'R') {\n                z = { z.w, z.r, z.l };\n            }\n            if (r + eps < z.r + z.l) return -1;\n            stk.push(z);\n        } else {\n            int i = c - '0';\n            stk.push((mobile_t){ w[i], 0.0, 0.0 });\n        }\n    }\n    if (stk.size() != 1) return -1;\n    return stk.top().l + stk.top().r;\n}\nint main() {\n    int datasets; cin >> datasets;\n    repeat (dataset, datasets) {\n        double r; cin >> r;\n        int s; cin >> s;\n        vector<int> w(s); repeat (i,s) cin >> w[i];\n        double result = -1;\n        repeat (ln, s-1+1) {\n            int rn = s-1 - ln;\n            string pat;\n            repeat (i,s)  pat += i + '0';\n            repeat (i,ln) pat += 'L';\n            repeat (i,rn) pat += 'R';\n            sort(pat.begin(), pat.end());\n            do {\n                result = max(result, evaluate(pat, r, w));\n            } while (next_permutation(pat.begin(), pat.end()));\n        }\n        if (result == -1) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.16lf\\n\", result);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tStone,\n\tMobile,\n};\n\nstruct Info{\n\tType type;\n\tint index_left,index_right;\n\tdouble weight,left,right,most_left_loc,most_right_loc;\n};\n\nInfo info[12];\nint num_stone,eq_index;\nint table[7][720][6],table_index[7],eq_num[7];\ndouble room_width;\nchar equation[7][100000][12];\npriority_queue<double> Q;\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid makeEquation(int array[6],int array_index,char buf[12],int buf_index,int value,int rest_mult,int length){\n\n\tif(rest_mult == 0){\n\t\tbuf[buf_index] = '\\0';\n\t\tstrcpy(equation[length][eq_num[length]++],buf);\n\t\treturn;\n\t}\n\n\tif(array_index < length){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = array[array_index]+'0';\n\t\tmakeEquation(array,array_index+1,next_buf,buf_index+1,value+1,rest_mult,length);\n\t}\n\n\tif(value >= 2){\n\t\tchar next_buf[12];\n\t\tfor(int i = 0; i < buf_index; i++)next_buf[i] = buf[i];\n\t\tnext_buf[buf_index] = '*';\n\t\tmakeEquation(array,array_index,next_buf,buf_index+1,value-1,rest_mult-1,length);\n\t}\n}\n\nvoid calc_mobile(int tmp_index,int buf_index,Info tmp_info[12],int info_index,stack<int> S){\n\n\tif(equation[num_stone][tmp_index][buf_index] == '\\0'){\n\n\t\tQ.push(tmp_info[info_index-1].most_left_loc+tmp_info[info_index-1].most_right_loc);\n\n\t\treturn;\n\t}\n\n\tint left,right;\n\tdouble left_weight,right_weight;\n\tchar tmp_ch;\n\tstack<int> WORK,NEXT;\n\n\twhile(!S.empty()){\n\t\tWORK.push(S.top());\n\t\tS.pop();\n\t}\n\n\twhile(!WORK.empty()){\n\t\tNEXT.push(WORK.top());\n\t\tWORK.pop();\n\t}\n\n\ttmp_ch = equation[num_stone][tmp_index][buf_index];\n\n\tif(tmp_ch >= '0' && tmp_ch <= '5'){\n\n\t\tNEXT.push(tmp_ch-'0');\n\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index,NEXT);\n\n\t}else{ //tmp_ch == '*'\n\n\t\tleft = NEXT.top();\n\t\tNEXT.pop();\n\t\tright = NEXT.top();\n\t\tNEXT.pop();\n\n\t\tleft_weight = tmp_info[left].weight;\n\t\tright_weight = tmp_info[right].weight;\n\n\t\ttmp_info[info_index].left = (right_weight)/(left_weight+right_weight);\n\t\ttmp_info[info_index].right = 1.0-tmp_info[info_index].left;\n\t\ttmp_info[info_index].type = Mobile;\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].weight = left_weight+right_weight;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);\n\n\t\tif(tmp_info[left].type == Stone && tmp_info[right].type == Stone)return;\n\n\t\tNEXT.pop();\n\t\tswap(left,right);\n\n\t\tswap(tmp_info[info_index].left,tmp_info[info_index].right);\n\t\ttmp_info[info_index].index_left = left;\n\t\ttmp_info[info_index].index_right = right;\n\t\ttmp_info[info_index].most_left_loc = max(tmp_info[info_index].left+tmp_info[left].most_left_loc,tmp_info[right].most_left_loc-tmp_info[info_index].right);\n\t\ttmp_info[info_index].most_right_loc = max(tmp_info[info_index].right+tmp_info[right].most_right_loc,tmp_info[left].most_right_loc-tmp_info[info_index].left);\n\n\t\tNEXT.push(info_index);\n\t\tcalc_mobile(tmp_index,buf_index+1,tmp_info,info_index+1,NEXT);\n\t}\n}\n\nvoid calc(int tmp_index){\n\n\tInfo tmp_info[12];\n\tfor(int i = 0; i < num_stone; i++)tmp_info[i] = info[i];\n\tfor(int i = num_stone; i < 12; i++){\n\t\ttmp_info[i].index_left = -1;\n\t\ttmp_info[i].index_right = -1;\n\t\ttmp_info[i].most_left_loc = 0.0;\n\t\ttmp_info[i].most_right_loc = 0.0;\n\t}\n\n\tstack<int> S;\n\n\tcalc_mobile(tmp_index,0,tmp_info,num_stone,S);\n}\n\nvoid func(){\n\n\twhile(!Q.empty())Q.pop();\n\n\tscanf(\"%lf\",&room_width);\n\n\tscanf(\"%d\",&num_stone);\n\n\tfor(int i = 0; i < num_stone; i++){\n\t\tscanf(\"%lf\",&info[i].weight);\n\t\tinfo[i].type = Stone;\n\t\tinfo[i].index_left = -1;\n\t\tinfo[i].index_right = -1;\n\t}\n\n\tif(num_stone == 1){\n\t\tif(room_width < 1.0){\n\t\t\tprintf(\"-1\\n\");\n\t\t}else{\n\t\t\tprintf(\"1.00000000\\n\");\n\t\t}\n\t\treturn;\n\t}\n\n\teq_index = eq_num[num_stone];\n\n\tfor(int i = 0; i < eq_index; i++){\n\t\tcalc(i);\n\t}\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top() < room_width){\n\t\t\tprintf(\"%.16lf\\n\",Q.top());\n\t\t\treturn;\n\t\t}\n\t\tQ.pop();\n\t}\n\n\tprintf(\"-1\\n\");\n}\n\nvoid recursive(int array[6],int array_index,int length){\n\n\tif(array_index == length){\n\n\t\tfor(int i = 0; i < length; i++){\n\t\t\ttable[length][table_index[length]][i] = array[i];\n\t\t}\n\t\ttable_index[length]++;\n\t\treturn;\n\t}\n\n\tbool check[length];\n\tfor(int i = 0; i < length; i++)check[i] = false;\n\n\tfor(int i = 0; i < array_index; i++){\n\t\tcheck[array[i]] = true;\n\t}\n\n\tfor(int i = 0; i < length; i++){\n\t\tif(check[i] == false){\n\t\t\tint next_array[6];\n\n\t\t\tfor(int k = 0; k < array_index; k++)next_array[k] = array[k];\n\t\t\tnext_array[array_index] = i;\n\t\t\trecursive(next_array,array_index+1,length);\n\t\t}\n\t}\n}\n\nvoid makeTable(){\n\n\tfor(int length = 2; length <= 6; length++){\n\t\ttable_index[length] = 0;\n\n\t\tint first_array[6];\n\n\t\trecursive(first_array,0,length);\n\t}\n}\n\nint main(){\n\n\tmakeTable();\n\n\tfor(int length = 2; length <= 6; length++){\n\t\tchar first_buf[12];\n\t\teq_num[length] = 0;\n\n\t\tfor(int i = 0; i < table_index[length]; i++){\n\t\t\tmakeEquation(table[length][i],0,first_buf,0,0,length-1,length);\n\t\t}\n\t}\n\n\tint case_num;\n\tscanf(\"%d\",&case_num);\n\n\tfor(int i = 0; i < case_num; i++)func();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define double long double\n#define INF 10000\n#define N 10\ntypedef pair<double,double> P;\ntypedef vector<P> V;\nint n;\ndouble w[N];\n\nint getW(int bit){\n  int res = 0;\n  for(int i=0;i<n;i++) if(bit>>i&1) res += w[i];\n  return res;\n}\n\nP Merge(P a,P b){\n  double l = min(a.first,b.first);\n  double r = max(a.second,b.second);\n  return P(l,r);\n}\n\nV dfs(double x,int bit){\n\n  if(__builtin_popcount(bit)==1) return V(1,P(x,x));\n  if(__builtin_popcount(bit)==0) return V(1,P(-INF,INF));\n  \n  vector<P> res;\n  for(int i=0;i<(1<<n);i++){\n    if( (i | bit) != bit ) continue;\n    int lbit = i;\n    int rbit = bit ^ i;\n    double lw = getW(lbit);\n    double rw = getW(rbit);\n    if(lw == 0 || rw == 0) continue;\n    double lx = x - lw/(lw+rw);\n    double rx = x + rw/(lw+rw);\n    V L = dfs(lx,lbit);\n    V R = dfs(rx,rbit);\n\n    for(P l:L)\n      for(P r:R) res.push_back(Merge(l,r));\n  }\n  \n  return res;\n}\n\n\nsigned main(){\n  int q;\n  cin>>q;\n  while(q--){\n    double len;\n    cin>>len;\n    cin>>n;\n    for(int i=0;i<n;i++) cin>>w[i];\n\n    V v = dfs(0,(1<<n)-1);\n    double ans = -1;\n    for(P p:v)\n      if(p.second-p.first<len)ans = max(ans,p.second - p.first);\n    \n    if(ans<0)cout<<-1<<endl;\n    else printf(\"%.10Lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps)\n#define all(n) (n).begin(),(n).end()\n#define inf (1<<29)\n \nusing namespace std;\ntypedef long double ld;\n \nstruct P\n{\n  ld left,right,weight;\n  P(ld left=0,ld right=0,ld weight=inf):left(left),right(right),weight(weight){}\n  bool operator < (const P& a)const\n  {\n    if(!equals(weight,a.weight))return weight < a.weight;\n    if(!equals(left,a.left))return left < a.left;\n    return right < a.right;\n  }\n};\n \nld r,ans;\nint s;\n \nbool check(ld v)\n{\n  if(equals(v,r) || v > r)return false;\n  return true;\n}\n \nP unit(P a,P b)\n{\n  P node;\n  node.weight = a.weight + b.weight;\n  ld middle = b.weight/(a.weight+b.weight);\n  node.left = min(-b.weight/(a.weight+b.weight) + a.left,b.left + (1-middle));\n  node.right = max(a.weight/(a.weight+b.weight) + b.right,a.right - middle);\n  return node;\n}\n \nvoid dfs(vector<P> vec)\n{\n  int n = vec.size();\n  if(n <= 1)\n    {\n      ld len = vec[0].right - vec[0].left;\n      assert(equals(len,0) || len > 0);\n      if(check(len))ans = max(ans,len);\n      return;\n    }\n  \n  rep(i,n)\n    {\n      rep(j,n)\n\t{\n\t  if(i == j)continue;\n\t  vector<P> nvec;\n\t  rep(k,n)\n\t    if(k == i || k == j)continue;\n\t    else                nvec.push_back(vec[k]);\n\t  P p = unit(vec[i],vec[j]);\n\t  nvec.push_back(p);\n\t  dfs(nvec);\n\t}\n    }\n}\n \n \nint main()\n{\n  /*\n  rep(i,100000)\n    {\n    P a,b;\n      cout << \"type node a\\n\";\n      cin >> a.left >> a.right >> a.weight;\n      cout << \"type node b\\n\";\n      cin >> b.left >> b.right >> b.weight;\n      P c = unit(a,b);\n      cout << \"unit c (\" << c.left << \",\" << c.right << \",\" << c.weight << \")\" << endl;\n    }\n  */\n  int T;\n  while(cin >> T)\n    {\n      while(T--)\n\t{\n\t  cin >> r;\n\t  cin >> s;\n\t  vector<P> ps(s);\n\t  rep(i,s)cin >> ps[i].weight;\n\t  \n\t  ans = -inf;\n\t  \n\t  dfs(ps);\n\t  \n\t  if(equals(ans,-inf))cout << -1 << endl;\n\t  else                cout << setiosflags(ios::fixed) << setprecision(9) << ans << endl;\n\t  \n\t}\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <map>\nusing namespace std;\n\n\nconst int MAX_N = 6;\nconst int INF = 1<<24;\ndouble r;\nint s;\nint w[MAX_N];\n\n\nint sum(int a, int b) {\n  int res = 0;\n  for(int i = a; i < b; ++i) {\n    res += w[i];\n  }\n  return res;\n}\n/*\npair<double, double> rec(double x, int a, int b) {\n  if(b-a == 1) {\n    return make_pair(x, x);\n  }\n  pair<double, double> res, p;\n  res = make_pair(-INF, INF);\n  for(int i = a+1; i < b; ++i) {\n    int su = sum(a, b);\n    int u = sum(a, i);\n    int v = sum(i, b);\n    p = rec(x-(double)v/su, a, i);\n    res.first = max(res.first, p.first);\n    p = rec(x+(double)u/su, i, b);\n    res.second = min(res.second, p.second);\n  }\n  return res;\n}\n*/\ndouble calc() {\n  int t[MAX_N];\n  for(int i = 1; i <= s-1; ++i) {\n    t[i-1] = i;\n  }\n\n  double pos[MAX_N];\n  int g[MAX_N];\n  double res = -INF;\n\n  do {\n    fill(pos, pos+s, 0.0);\n    fill(g, g+s, 0);\n    for(int k = 0; k < s-1; ++k) {\n      int a, b;\n      int sa, sb;\n      for(a = t[k]-1; a >= 0 && g[a] == g[t[k]-1]; --a); ++a;\n      for(b = t[k]; b < s && g[b] == g[t[k]]; ++b);\n      sa = sum(a, t[k]);\n      sb = sum(t[k], b);\n      for(int i = a; i < t[k]; ++i) {\n\tpos[i] -= (double)sb/(sa+sb);\n\tg[i] += 1;\n      }\n      for(int i = t[k]; i < b; ++i) {\n\tpos[i] += (double)sa/(sa+sb);\n\tg[i] += 2;\n      }\n    }\n    double minv, maxv;\n    minv = INF;\n    maxv = -INF;\n    for(int i = 0; i < s; ++i) {\n      minv = min(minv, pos[i]);\n      maxv = max(maxv, pos[i]);\n    }\n    double newv = maxv - minv;\n    if(newv <= r) res = max(res, newv);\n\n  } while(next_permutation(t, t+s-1));\n\n  return res;\n}\n\ndouble solve() {\n  sort(w, w+s);\n  double res = -INF;\n  do {\n    //    pair<double, double> p = rec(0.0, 0, s);\n    //    double newV = p.second - p.first;\n    double newV = calc();\n    res = max(res, newV);\n  } while(next_permutation(w, w+s));\n  return res == -INF ? -1 : res;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  for(int tc = 1; tc <= T; ++tc) {\n    cin >> r;\n    cin >> s;\n    for(int i = 0; i < s; ++i) {\n      cin >> w[i];\n    }\n    double res = solve();\n    if(res == -1) printf(\"%d\\n\", -1);\n    else printf(\"%.16f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <queue>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\n#define whole(xs) (xs).begin(),(xs).end()\n\nnamespace {\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    typedef double real;\n\n    real R;\n    int S;\n    vector<int> W;\n    void input() {\n        cin >> R >> S;\n        W.clear(); W.resize(S);\n        for (int i = 0; i < S; i++) {\n            cin >> W[i];\n        }\n    }\n\n    real solve();\n\n    vector<int> pat;\n    void init() {\n        real ans = -1;\n        for (int j = 0; j <= (S + 1) / 2; j++) {\n            pat.clear();\n            for (int k = 0; k < j; k++) pat.push_back(0);\n            for (int k = j; k < S - 1; k++) pat.push_back(-1);\n            for (int i = 1; i <= S; i++) pat.push_back(i);\n            ans = max(ans, solve());\n        }\n        if (ans < 0) {\n            cout << -1 << endl;\n        } else {\n            printf(\"%.18lf\\n\", ans);\n        }\n    }\n\n    struct State {\n        int w;\n        real left, right;\n        State(int w, real left, real right) : w(w), left(left), right(right) {}\n    };\n\n    real parse() {\n        vector<State> stack;\n        real ans = -1.0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) { // 結合\n                if (stack.size() < 2) return -1.0;\n                assert(stack.size() >= 2);\n                State a = stack.back(); stack.pop_back();\n                State b = stack.back(); stack.pop_back();\n                real nleft, nright;\n                int w = (a.w + b.w);\n                if (pat[i] == 0) {\n                    nleft = 1.0 / w * b.w + a.left;\n                    nright = 1.0 / w * a.w + b.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                } else {\n                    assert(pat[i] == -1);\n                    nleft = 1.0 / w * a.w + b.left;\n                    nright = 1.0 / w * b.w + a.right;\n                    stack.push_back(State(a.w + b.w, nleft, nright));\n                }\n                if (nright + nleft > R) return -1;\n                ans = max(ans, nright + nleft);\n            } else {\n                assert(pat[i] >= 1); // 石\n                stack.push_back(State(W[pat[i] - 1], 0, 0));\n            }\n        }\n        return ans;\n    }\n\n    inline bool check() {\n        if (pat[0] <= 0 || pat[1] <= 0) return false;\n        int c = 0;\n        for (int i = 0; i < pat.size(); i++) {\n            if (pat[i] <= 0) {\n                if (c < 2) return false;\n                c--;\n            } else {\n                c++;\n            }\n        }\n        return true;\n    }\n\n    real solve() {\n        real ans = -1.0;\n        sort(whole(pat));\n        do {\n            if (!check()) continue;\n            real c = parse();\n            if (c > R) continue;\n            ans = max(c, ans);\n        } while (next_permutation(whole(pat)));\n        return ans;\n    }\n}\n\nint main() {\n    int T; cin >> T;\n    for (int i = 0; i < T; i++) {\n        input(); init();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=(int)b;i<(int)n;i++)\n#define rep(i,n)  REP(i,0,n)\n\ndouble ans = -1;\n\n\nvoid solve(int n,int now,bool *used,double *rc,double *lc,double lim,double c,int *weight){\n  if ( n-1 == now){\n    ans = max(ans,c);\n    return;\n  }\n  \n  //left i , right j\n  rep(i,n){\n    if ( used[i] == true)continue;\n    rep(j,n){\n      if (i == j)continue;\n      if ( used[j] == true)continue;\n      double w = weight[i]+weight[j];\n      double tmpr=max(weight[i]/w+rc[j],-weight[j]/w+rc[i]);\n      double tmpl=max(weight[j]/w+lc[i],-weight[i]/w+lc[j]);\n\n      if ( tmpr+tmpl >lim+eps){continue;}\n      double tr=rc[i],tl=lc[i];int tw=weight[i];\n      used[j]=true;\n      rc[i]=tmpr;\n      lc[i]=tmpl;\n      weight[i]=weight[i]+weight[j];\n      solve(n,now+1,used,rc,lc,lim,tmpr+tmpl,weight);\n      rc[i]=tr;\n      lc[i]=tl;\n      weight[i]=tw;\n      used[j]=false;\n    }\n  }\n  \n}\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n\n   double rc[n],lc[n];\n   bool used[n];\n   rep(i,n)rc[i]=lc[i]=0,used[i]=false;\n   ans=-1;\n\n   solve(n,0,used,rc,lc,r,0,inp);\n   if ( ans == -1)puts(\"-1\");\n   else printf(\"%.9lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nstruct mobile{ double w,l,r; };\n\ndouble W;\n\nvector<mobile> dfs(const vector<int> a){\n\tint n=a.size();\n\tif(n==1) return vector<mobile>(1,(mobile){a[0],0,0});\n\n\tvector<mobile> res;\n\trep(S,1<<n) if(0<S && S<(1<<n)-1) {\n\t\tvector<int> al,ar;\n\t\tdouble wl=0,wr=0;\n\t\trep(i,n){\n\t\t\tif(S&1<<i) al.push_back(a[i]), wl+=a[i];\n\t\t\telse       ar.push_back(a[i]), wr+=a[i];\n\t\t}\n\n\t\tvector<mobile> L=dfs(al),R=dfs(ar);\n\t\trep(i,L.size()) rep(j,R.size()) {\n\t\t\tdouble l2=min(-wr/(wl+wr)+L[i].l,wl/(wl+wr)+R[j].l);\n\t\t\tdouble r2=max(-wr/(wl+wr)+L[i].r,wl/(wl+wr)+R[j].r);\n\t\t\tif(r2-l2<W){\n\t\t\t\tres.push_back((mobile){wl+wr,l2,r2});\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint n; scanf(\"%lf%d\",&W,&n);\n\t\tvector<int> a(n);\n\t\trep(i,n) scanf(\"%d\",&a[i]);\n\n\t\tvector<mobile> res=dfs(a);\n\n\t\tdouble ans=-1;\n\t\trep(i,res.size()) if(res[i].r-res[i].l<W) ans=max(ans,res[i].r-res[i].l);\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<double,int> P;\n\nint dx[8]={1,-1,0,0,1,-1,1,-1};\nint dy[8]={0,0,1,-1,1,-1,-1,1};\n\ndouble EPS=1e-8;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=0;\n  double tmp1=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(10);\n    fill(all(w),0);\n    rep(i,s)cin >> w[i];\n\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(0,1.0);\n      //printf(\"%.16f\\n\",res);\n      if(res<r-EPS)ans=max(ans,res);\n      res=rec(1,1.0);\n      if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#define repeat_from(i,m,n) for (int i = (m); (i) < (n); ++(i))\n#define repeat(i,n) repeat_from(i,0,n)\nusing namespace std;\nstruct mobile_t {\n    int w; // weight\n    double l; // left\n    double r; // right\n};\nconst double eps = 0.0001;\ndouble evaluate(vector<int> const & p) {\n    stack<mobile_t> stk;\n    for (int w : p) {\n        if (w == 0) {\n            if (stk.size() < 2) return -1;\n            mobile_t x = stk.top(); stk.pop();\n            mobile_t y = stk.top(); stk.pop();\n            mobile_t z;\n            z.w = x.w + y.w;\n            double dx = y.w /(double) (x.w + y.w);\n            double dy = x.w /(double) (x.w + y.w);\n            z.l = max(x.l + dx, y.l - dy);\n            z.r = max(x.r - dx, y.r + dy);\n            stk.push(z);\n        } else {\n            stk.push((mobile_t){ w, 0.0, 0.0 });\n        }\n    }\n    if (stk.size() != 1) return -1;\n    return stk.top().l + stk.top().r;\n}\nint main() {\n    int datasets; cin >> datasets;\n    repeat (dataset, datasets) {\n        double r; cin >> r;\n        int s; cin >> s;\n        vector<int> w(s); repeat (i,s) cin >> w[i];\n        double result = -1;\n        vector<int> p;\n        repeat (i,s)   p.push_back(w[i]);\n        repeat (i,s-1) p.push_back(0);\n        sort(p.begin(), p.end());\n        do {\n            result = max(result, evaluate(p));\n            if (r + eps < result) continue;\n        } while (next_permutation(p.begin(), p.end()));\n        if (result == -1) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%.16lf\\n\", result);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct data{\n  double lm, rm, m;//l-min, r-max\n  int bit; \n  data(double l=0, double r=0, double m=0, int b=0):lm(l),rm(r),m(m),bit(b){}\n};\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\nint n;\ndouble r;\nvector<double> v;\n\nvoid solve(){\n  if(n == 1){\n    cout << 0.0 << endl;\n    return;\n  }\n\n  vector<data> res[7];\n  double ans = -1.0;\n  for(int i=0;i<n;i++) res[1].push_back(data(0,0,v[i],(1<<i)));\n  for(int i=2;i<=n;i++){\n    for(int j=1;j<i;j++){\n      int x1 = j, x2 = i - j;\n      for(int k=0;k<res[x1].size();k++){\n        for(int l=0;l<res[x2].size();l++){\n          if((res[x1][k].bit & res[x2][l].bit) != 0) continue;\n          data pos;\n          double a = res[x2][l].m / (res[x1][k].m + res[x2][l].m);\n          double b = 1.0 - a;\n          pos.lm = min(-a + res[x1][k].lm, b + res[x2][l].lm);\n          pos.rm = max(b + res[x2][l].rm, -a + res[x1][k].rm);\n          pos.m = res[x1][k].m + res[x2][l].m;\n          pos.bit = res[x1][k].bit | res[x2][l].bit;\n          if(pos.rm - pos.lm > r || equal(pos.rm-pos.lm,r)) continue;\n          else if(i == n) ans = max(ans, pos.rm - pos.lm);\n          else res[i].push_back(pos);\n        }\n      }\n    }\n  }\n  if(ans < 0) cout << -1 << endl;\n  else printf(\"%.9f\\n\",ans);\n}\n\nint main(){\n  int T;\n  cin >> T;\n  while(T--){\n    cin >> r >> n;\n    v.clear();\n    for(int i=0;i<n;i++){\n      int x;\n      cin >> x;\n      v.push_back(x);\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<cstdio>\n\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n \ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  point operator + (point p){return point(add(x,p.x), add(y,p.y));}\n  point operator - (point p){return point(add(x,-p.x), add(y,-p.y));}\n  point operator * (double d){return point(x*d,y*d);}\n};\n \n#define Line pair<point,point>\n\ndouble dot(point a, point b){return (a.x*b.x+a.y*b.y);}\ndouble cross(point a, point b){return (a.x*b.y-a.y*b.x);}\ndouble norm(point a){return sqrt(a.x*a.x+a.y*a.y);}\n \nint ccw(point a, point b, point c) {\n  b = b-a; c = c-a;\n  if (cross(b, c) > 0)   return +1;\n  if (cross(b, c) < 0)   return -1;\n  if (dot(b, c) < 0)     return +2;\n  if (norm(b) < norm(c)) return -2; \n  return 0;\n}\n\npoint intersection_l(point a1, point a2, point b1, point b2) {\n  return a1+(a2-a1)*(cross(b2-b1,b1-a1)/cross(b2-b1,a2-a1));\n}\n\npoint symmetry(point p1, point p2, point Q){\n  double xa,ya,xb,yb,t1,t2;\n  point R;\n \n  xa=Q.x-p1.x,ya=Q.y-p1.y;\n  xb=p2.x-p1.x,yb=p2.y-p1.y;\n \n  t1=xa*xb+ya*yb,t2=xb*xb+yb*yb;\n \n  R.x=2*(p1.x+xb*t1/t2)-Q.x;\n  R.y=2*(p1.y+yb*t1/t2)-Q.y;\n  return R;\n}\n\n Line parallel_line(point a,point b,double h){\n    double t = atan((a.y-b.y)/(a.x-b.x));\n \n    point a_(a.x + h*cos(t+PI/2), a.y + h*sin(t+PI/2));\n    point b_(b.x + h*cos(t+PI/2), b.y + h*sin(t+PI/2));\n \n    if(ccw(a,b,a_)==-1)a_=symmetry(a,b,a_),b_=symmetry(a,b,b_);\n    return make_pair(a_,b_);\n}\n\nvector<point> convex_cut(vector<point>pol,point a,point b){\n  vector<point>q;\n  for (int i=0; i<pol.size();i++) {\n    point A=curr(pol,i),B=next(pol, i);\n    if (ccw(a,b,A)!=-1)q.push_back(A);\n    if (ccw(a,b,A)*ccw(a,b,B)<0)\n      q.push_back(intersection_l(A,B,a,b));\n  }\n  return q;\n}\n\nbool C(vector<point>pol,double d){\n  vector<Line>L;\n  for(int i=0;i<pol.size();i++){\n    L.push_back(Line(curr(pol,i),next(pol,i)));\n  }\n  \n  for(int i=0;i<L.size();i++){\n    Line tmp=parallel_line(L[i].first,L[i].second,d);\n    pol=convex_cut(pol,tmp.first,tmp.second);\n  }\n  return pol.size()>0;\n}\n\ndouble Binary_search(vector<point>pol){\n  double l=0,r=10000,tc=50;\n  while(tc--){\n    double d=(l+r)/2;\n    if(C(pol,d))l=d;\n    else r=d;\n  }\n  return l;\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    vector<point>pol(n);\n    for(int i=0;i<n;i++)cin >> pol[i].x >> pol[i].y;\n    printf(\"%.6f\",Binary_search(pol));\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n\n#define all(c) (c).begin(),(c).end()\n#define D(x) cout << #x \" is \" << x << endl\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define F first\n#define S second\n#define INF (1<<29)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ndouble EPS=1e-10;\n\nvector<double>w;\ndouble r;\nint s;\n\ndouble rec(int v,double L){\n  if(v>=s)return L;\n  double res=-1;\n  double tmp1=rec(v+1,L+w[v]/(w[v]+w[v+1]));\n  double tmp2=rec(v+1,L+w[v+1]/(w[v]+w[v+1]));\n  double tmp3=rec(v+2,L+w[v]/(w[v]+w[v+1]));\n  double tmp4=rec(v+2,L+w[v+1]/(w[v]+w[v+1]));\n  if(tmp1<r-EPS)res=max(res,tmp1);\n  if(tmp2<r-EPS)res=max(res,tmp2);\n  if(tmp3<r-EPS)res=max(res,tmp3);\n  if(tmp4<r-EPS)res=max(res,tmp4);\n\n  return res;\n}\n\nint main(void){\n  int T;\n\n  cin >> T;\n\n  while(T--){\n    cin >> r >> s;\n    w.resize(s);\n    rep(i,s)cin >> w[i];\n    if(s<=2){\n      printf(\"1.0000000000\\n\");\n      continue;\n    }\n    double ans=-1;\n    sort(all(w));\n    do{\n      double res=rec(1,1.0);\n      if(res<r-EPS)ans=max(ans,res);\n    }while(next_permutation(all(w)));\n    if(ans<EPS)cout << -1 << endl;\n    else printf(\"%.16f\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n\nconst int MAX_N = 6;\nconst int INF = 1<<24;\nconst double EPS = 1e-5;\n\nbool equals(double a, double b) {\n  return fabs(a-b) <= EPS;\n}\n\ndouble r;\nint s;\nint w[MAX_N];\n\n\nint sum(int a, int b) {\n  int res = 0;\n  for(int i = a; i < b; ++i) {\n    res += w[i];\n  }\n  return res;\n}\n/*\npair<double, double> rec(double x, int a, int b) {\n  if(b-a == 1) {\n    return make_pair(x, x);\n  }\n  pair<double, double> res, p;\n  res = make_pair(-INF, INF);\n  for(int i = a+1; i < b; ++i) {\n    int su = sum(a, b);\n    int u = sum(a, i);\n    int v = sum(i, b);\n    p = rec(x-(double)v/su, a, i);\n    res.first = max(res.first, p.first);\n    p = rec(x+(double)u/su, i, b);\n    res.second = min(res.second, p.second);\n  }\n  return res;\n}\n*/\ndouble calc() {\n  int t[MAX_N];\n  for(int i = 1; i <= s-1; ++i) {\n    t[i-1] = i;\n  }\n\n  double pos[MAX_N];\n  int g[MAX_N];\n  double res = -INF;\n\n  do {\n    fill(pos, pos+s, 0.0);\n    fill(g, g+s, 0);\n    for(int k = 0; k < s-1; ++k) {\n      int a, b;\n      int sa, sb;\n      for(a = t[k]-1; a >= 0 && g[a] == g[t[k]-1]; --a); ++a;\n      for(b = t[k]; b < s && g[b] == g[t[k]]; ++b);\n      sa = sum(a, t[k]);\n      sb = sum(t[k], b);\n      for(int i = a; i < t[k]; ++i) {\n\tpos[i] -= (double)sb/(sa+sb);\n\tg[i] += 1;\n      }\n      for(int i = t[k]; i < b; ++i) {\n\tpos[i] += (double)sa/(sa+sb);\n\tg[i] += 2;\n      }\n    }\n    double minv, maxv;\n    minv = INF;\n    maxv = -INF;\n    for(int i = 0; i < s; ++i) {\n      minv = min(minv, pos[i]);\n      maxv = max(maxv, pos[i]);\n    }\n    double newv = maxv - minv;\n    if(!equals(newv, r) && newv < r) res = max(res, newv);\n\n  } while(next_permutation(t, t+s-1));\n\n  return res;\n}\n\ndouble solve() {\n  sort(w, w+s);\n  double res = -INF;\n  do {\n    //    pair<double, double> p = rec(0.0, 0, s);\n    //    double newV = p.second - p.first;\n    double newV = calc();\n    res = max(res, newV);\n  } while(next_permutation(w, w+s));\n  return res == -INF ? -1 : res;\n}\n\nint main() {\n  int T;\n  cin >> T;\n  for(int tc = 1; tc <= T; ++tc) {\n    cin >> r;\n    cin >> s;\n    for(int i = 0; i < s; ++i) {\n      cin >> w[i];\n    }\n    double res = solve();\n    if(res == -1) printf(\"%d\\n\", -1);\n    else printf(\"%.16f\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n#define MAX 10\n#define EPS 1e-6\n\nint w[MAX];\ndouble rcost[MAX], lcost[MAX];\nbool used[MAX];\n\ndouble r;\nint n;\ndouble ans;\n\nvoid dfs(int now, double cost){\n  if(n-1 == now){\n    ans = max(ans, cost);\n    return;\n  }\n  \n  for(int i = 0 ; i < n ; i++){\n    if(used[i]) continue;\n    for(int j = 0 ; j < n ; j++){\n      if(i == j || used[j]) continue;\n      double weight = w[i] + w[j];\n      double tmpr = max( (w[i] / weight) + rcost[j], (-w[j] / weight) + rcost[j]);\n      double tmpl = max( (w[j] / weight) + lcost[i], (-w[i] / weight) + lcost[j]);\n      \n      if(tmpr + tmpl > r+EPS) continue;\n      \n      double tr = rcost[i], tl = lcost[i], tw = w[i];      \n      rcost[i] = tmpr;\n      lcost[i] = tmpl;\n      w[i] += w[j];\n      used[j] = true;\n      \n      dfs(now+1, tmpr+tmpl);\n      // back track\n      rcost[i] = tr;\n      lcost[i] = tl;\n      w[i] = tw;\n      used[j] = false;\n    }\n  }\n}\n\nvoid init(){\n  ans = -1.0;\n  for(int i = 0 ; i < MAX ; i++) w[i] = rcost[i] = lcost[i] = used[i] = 0;\n}\n\nint main(){\n  int tc;\n  cin >> tc;\n  while(tc--){\n    init();\n    cin >> r >> n;\n    for(int i = 0 ; i < n ; i++) cin >> w[i];\n    dfs(0, 0);\n    if(ans == -1.0) cout << -1 << endl;\n    else printf(\"%.10f\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\n#define N 6\n#define eps 0.00001\n#define REP(i,b,n) for(int i=(int)b;i<(int)n;i++)\n#define rep(i,n)  REP(i,0,n)\n\ndouble ans = -1;\n\n\nvoid solve(int n,int now,bool *used,double *rc,double *lc,double lim,double c,int *weight){\n  if ( n-1 == now){\n    ans = max(ans,c);\n    return;\n  }\n  \n  //left i , right j\n  rep(i,n){\n    if ( used[i] == true)continue;\n    rep(j,n){\n      if (i == j)continue;\n      if ( used[j] == true)continue;\n      double w = weight[i]+weight[j];\n      double tmpr=max(weight[i]/w+rc[j],-weight[j]/w+rc[i]);\n      double tmpl=max(weight[j]/w+lc[i],-weight[i]/w+lc[j]);\n\n      if ( tmpr+tmpl >lim+eps){continue;}\n      double tr=rc[i],tl=lc[i];int tw=weight[i];\n      used[j]=true;\n      rc[i]=tmpr;\n      lc[i]=tmpl;\n      weight[i]=weight[i]+weight[j];\n      solve(n,now+1,used,rc,lc,lim,tmpr+tmpl,weight);\n      rc[i]=tr;\n      lc[i]=tl;\n      weight[i]=tw;\n      used[j]=false;\n    }\n  }\n  \n}\n\nmain(){\n int te;\n cin>>te;\n while(te--){\n   int n;\n   double r;\n   cin>>r>>n;\n   int inp[n];\n   rep(i,n)cin>>inp[i];\n\n   double rc[n],lc[n];\n   bool used[n];\n   rep(i,n)rc[i]=lc[i]=0,used[i]=false;\n   ans=-1;\n\n   solve(n,0,used,rc,lc,r,0,inp);\n   if ( ans == -1)puts(\"-1\");\n   else printf(\"%.9lf\\n\",ans);\n }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 200\n\nstruct tree\n{\n    int wei;\n    double l,r,m;\n    int is;\n\n}tr[MAX];\n\ndouble r;\nint s,w[7];\nint jie[8];\n\nint queen[MAX];\nint tail=0;\n\nvoid init()\n{\n    int i;\n    for(i=0;i<MAX;++i)\n    tr[i].wei=0;\n}\n\nint  calcw(int rt)\n{\n    int l=0,r=0;\n    if(tr[rt].wei!=0)\n    return tr[rt].wei;\n    else\n    {\n        if(tr[2*rt].is==1)\n        l=calcw(2*rt);\n        if(tr[2*rt+1].is==1)\n        r=calcw(2*rt+1);\n\n        tr[rt].wei=l+r;\n        return l+r;\n    }\n\n}\n\ndouble calclr()\n{\n    int i;\n    double min=9999999,max=-999999;\n\n    tr[1].m=0;\n\n    for(i=1;i<MAX;++i)\n    {\n\n        if(2*i+1<MAX&&tr[i*2].is==1)\n        {\n            double sum=tr[2*i].wei+tr[i*2+1].wei;\n\n            tr[i].l=tr[i].m-tr[i*2+1].wei/sum;\n            tr[i].r=tr[i].m+tr[i*2].wei/sum;\n            min=min>tr[i].l?tr[i].l:min;\n            max=max>tr[i].r?max:tr[i].r;\n\n            tr[i*2].m=tr[i].l;\n            tr[i*2+1].m=tr[i].r;\n\n        }\n    }\n\n    return max-min;\n}\n\nvoid in(int n)\n{\n    int i;\n    for(i=tail;i>n;--i)\n    {\n        queen[i]=queen[i-1];\n    }\n    queen[n]=queen[n+1]*2;\n    queen[n+1]+=queen[n+1]+1;\n    tr[queen[n]].is=1;\n    tr[queen[n+1]].is=1;\n\n    tail++;\n}\n\nint main()\n{\n\n\n    int i,t,j,l;\n    double max;\n    jie[0]=1;\n    for(i=1;i<8;++i)\n    jie[i]=jie[i-1]*i;\n\n\n    scanf(\"%d\",&t);\n    for(;t>0;--t)\n    {\n    max=0;\n    scanf(\"%lf%d\",&r,&s);\n    for(i=0;i<s;++i)\n    scanf(\"%d\",w+i);\n        if(s>1)\n        for(i=0;i<jie[s-1];++i)\n        {\n            int k=2;\n            int pos=i;\n\n\n            tail=0;\n            memset(tr,0,sizeof(tr));\n            queen[tail++]=1;\n            in(0);\n\n            tr[1].is=1;\n\n            for(;k<s;++k)\n            {\n                in(pos*jie[k]/jie[s-1]);\n                pos=pos%(jie[s-1]/jie[k]);\n\n\n            }\n\n\n\n            for(j=0;j<jie[tail];++j)\n            {\n                int k=tail-1;\n                int nhh;\n                int pos=j;\n                int sub;\n                double temp;\n\n                int pailie[7];\n                for(nhh=0;nhh<6;++nhh)\n                pailie[nhh]=0;\n\n                init();\n\n                for(l=0;l<tail;++l)\n                {\n                    int i;\n\n                    sub=pos/jie[k];\n                    for(i=0;sub!=0||pailie[i]==1;)\n                    {\n                        if(pailie[i]==1)\n                        ++i;\n                        else if(pailie[i]==0)\n                        {\n                            --sub;\n                            ++i;}\n\n                    }\n                    pailie[i]=1;\n                    pos=pos%jie[k];\n                    --k;\n                    tr[queen[l]].wei=w[i];\n                    //printf(\"%d\",w[i]);\n\n                }\n\n\n                calcw(1);\n                temp=calclr();\n                //printf(\" %d %d %lf\\n\",i,j,temp);\n                if(temp<r&&temp>max)\n                {\n                    max=temp;\n\n                }\n\n\n\n            }\n\n\n\n\n\n        }\n\n\n        else\n        {\n            max=-1;\n            printf(\"-1\\n\");\n        }\n        if(max>0)\n        printf(\"%.16lf\\n\",max);\n        else if(max==0)\n        printf(\"-1\\n\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX 200\n\nstruct tree\n{\n    int wei;\n    double l,r,m;\n    int is;\n\n}tr[MAX];\n\ndouble r;\nint s,w[7];\nint jie[8];\n\nint queen[MAX];\nint tail=0;\n\nint  calcw(int rt)\n{\n    int l=0,r=0;\n    if(tr[rt].wei!=0)\n    return tr[rt].wei;\n    else\n    {\n        if(tr[2*rt].is==1)\n        l=calcw(2*rt);\n        if(tr[2*rt+1].is==1)\n        r=calcw(2*rt+1);\n\n        tr[rt].wei=l+r;\n        return l+r;\n    }\n\n}\n\ndouble calclr()\n{\n    int i;\n    double min=9999999,max=-999999;\n\n    tr[1].m=0;\n\n    for(i=1;i<MAX;++i)\n    {\n\n        if(2*i+1<MAX&&tr[i*2].is==1)\n        {\n            double sum=tr[2*i].wei+tr[i*2+1].wei;\n\n            tr[i].l=tr[i].m-tr[i*2+1].wei/sum;\n            tr[i].r=tr[i].m+tr[i*2].wei/sum;\n            min=min>tr[i].l?tr[i].l:min;\n            max=max>tr[i].r?max:tr[i].r;\n\n            tr[i*2].m=tr[i].l;\n            tr[i*2+1].m=tr[i].r;\n\n        }\n    }\n\n    return max-min;\n}\n\nvoid in(int n)\n{\n    int i;\n    for(i=tail;i>n;--i)\n    {\n        queen[i]=queen[i-1];\n    }\n    queen[n]=queen[n+1]*2;\n    queen[n+1]+=queen[n+1]+1;\n    tr[queen[n]].is=1;\n    tr[queen[n+1]].is=1;\n\n    tail++;\n}\n\nint main()\n{\n\n\n    int i,t,j,l;\n    double max;\n    jie[0]=1;\n    for(i=1;i<8;++i)\n    jie[i]=jie[i-1]*i;\n\n\n    scanf(\"%d\",&t);\n    for(;t>0;--t)\n    {\n    max=0;\n    scanf(\"%lf%d\",&r,&s);\n    for(i=0;i<s;++i)\n    scanf(\"%d\",w+i);\n        if(s>1)\n        for(i=0;i<jie[s-1];++i)\n        {\n            int k=2;\n            int pos=i;\n\n\n            tail=0;\n            memset(tr,0,sizeof(tr));\n            queen[tail++]=1;\n            in(0);\n\n            tr[1].is=1;\n\n            for(;k<s;++k)\n            {\n                in(pos*jie[k]/jie[s-1]);\n                pos=pos%(jie[s-1]/jie[k]);\n\n\n            }\n\n\n\n            for(j=0;j<jie[tail];++j)\n            {\n                int k=tail-1;\n                int nhh;\n                int pos=j;\n                int sub;\n                double temp;\n\n                int pailie[7];\n                for(nhh=0;nhh<6;++nhh)\n                pailie[nhh]=0;\n\n                for(l=0;l<tail;++l)\n                {\n                    int i;\n\n                    sub=pos/jie[k];\n                    for(i=0;sub!=0||pailie[i]==1;)\n                    {\n                        if(pailie[i]==1)\n                        ++i;\n                        else if(pailie[i]==0)\n                        {\n                            --sub;\n                            ++i;}\n\n                    }\n                    pailie[i]=1;\n                    pos=pos%jie[k];\n                    --k;\n                    tr[queen[l]].wei=w[i];\n                }\n\n                calcw(1);\n                temp=calclr();\n                if(temp<r&&fabs(temp-r)>0.00001)\n                max=max>temp?max:temp;\n\n\n\n            }\n\n\n\n\n\n        }\n\n\n        else\n        {\n            max=-1;\n            printf(\"-1\\n\");\n        }\n        if(max>0)\n        printf(\"%.16lf\\n\",max);\n        else if(max==0)\n        printf(\"-1\\n\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1261: Mobile Computing\n// 2018.1.21 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { double l, r; } T;\nT tbl[128][20000];\nint sz[128];\n\ndouble R;\nint w[7], sum[128];\nchar mk[128];\n      \nvoid dfs(int n)\n{\n\tint i, j, f, l, r;\n\tdouble ll, rr, x;\n\tT t;\n\n\tif (mk[n]) return;\n\tmk[n] = 1;\n    \n\tf = 0;\n\tfor (l = (n-1) & n; l > 0; l = (l-1) & n) {\n\t\tf = 1;\n        r = l ^ n;\n        ll = (double)sum[r] / sum[n];\n\t\trr = (double)sum[l] / sum[n];\n         \n\t\tdfs(l), dfs(r);\n              \n\t\tfor (i = 0; i < sz[l]; i++) for (j = 0; j < sz[r]; j++) {\n\t\t\tx = tbl[l][i].l + ll;\n\t\t\tif (x < tbl[r][j].l - rr) x = tbl[r][j].l - rr;\n\t\t\tt.l = x;\n\n\t\t\tx = tbl[r][j].r + rr;\n\t\t\tif (x < tbl[l][i].r - ll) x = tbl[l][i].r - ll;\n\t\t\tt.r = x;\n\n\t\t\tif (t.l + t.r < R) tbl[n][sz[n]++] = t;\n\t\t}\n    }\n\tif (!f) tbl[n][sz[n]].l = tbl[n][sz[n]].r = 0, sz[n]++;\n}\n      \nint main()\n{\n\tint cno, n, i, j, lim;\n\tdouble ans, t;\n\n\tscanf(\"%d\", &cno);\n\twhile (cno--) {\n\t\tscanf(\"%lf%d\", &R, &n);\n\t\tfor (i = 0; i < n; i++) scanf(\"%d\", w+i);\n\t\tlim = (1 << n) - 1;\n\t\tmemset(sz, 0, sizeof(sz));\n\t\tmemset(mk, 0, sizeof(mk));\n\n\t\tfor (i = 0; i <= lim; i++) {\n\t\t\tsum[i] = 0;\n            for (j = 0; j < n; j++) if (i & (1<<j)) sum[i] += w[j];\n\t\t}\n\n\t\tans = -1;\n\t\tdfs(lim);\n\t\tfor (i = 0; i < sz[lim]; i++) {\n\t\t\tif (ans < (t = tbl[lim][i].l + tbl[lim][i].r)) ans = t;\n\t\t}\n\t\tif (ans < 0) puts(\"-1\");\n\t\telse printf(\"%.16lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX 200\n\nstruct tree\n{\n    int wei;\n    double l,r,m;\n    int is;\n\n}tr[MAX];\n\ndouble r;\nint s,w[7];\nint jie[8];\n\nint queen[MAX];\nint tail=0;\n\nint  calcw(int rt)\n{\n    int l=0,r=0;\n    if(tr[rt].wei!=0)\n    return tr[rt].wei;\n    else\n    {\n        if(tr[2*rt].is==1)\n        l=calcw(2*rt);\n        if(tr[2*rt+1].is==1)\n        r=calcw(2*rt+1);\n\n        tr[rt].wei=l+r;\n        return l+r;\n    }\n\n}\n\ndouble calclr()\n{\n    int i;\n    double min=9999999,max=-999999;\n\n    tr[1].m=0;\n\n    for(i=1;i<MAX;++i)\n    {\n\n        if(2*i+1<MAX&&tr[i*2].is==1)\n        {\n            double sum=tr[2*i].wei+tr[i*2+1].wei;\n\n            tr[i].l=tr[i].m-tr[i*2+1].wei/sum;\n            tr[i].r=tr[i].m+tr[i*2].wei/sum;\n            min=min>tr[i].l?tr[i].l:min;\n            max=max>tr[i].r?max:tr[i].r;\n\n            tr[i*2].m=tr[i].l;\n            tr[i*2+1].m=tr[i].r;\n\n        }\n    }\n\n    return max-min;\n}\n\nvoid in(int n)\n{\n    int i;\n    for(i=tail;i>n;--i)\n    {\n        queen[i]=queen[i-1];\n    }\n    queen[n]=queen[n+1]*2;\n    queen[n+1]+=queen[n+1]+1;\n    tr[queen[n]].is=1;\n    tr[queen[n+1]].is=1;\n\n    tail++;\n}\n\nint main()\n{\n\n\n    int i,t,j,l;\n    double max;\n    jie[0]=1;\n    for(i=1;i<8;++i)\n    jie[i]=jie[i-1]*i;\n\n\n    scanf(\"%d\",&t);\n    for(;t>0;--t)\n    {\n    max=0;\n    scanf(\"%lf%d\",&r,&s);\n    for(i=0;i<s;++i)\n    scanf(\"%d\",w+i);\n\n        for(i=0;i<jie[s];++i)\n        {\n            int k=2;\n            int pos=i;\n\n\n            tail=0;\n            memset(tr,0,sizeof(tr));\n            queen[tail++]=1;\n            in(0);\n\n            tr[1].is=1;\n\n            for(;k<s;++k)\n            {\n                in(pos*jie[k]/jie[s]);\n                pos=pos%(jie[s]/jie[k]);\n\n\n            }\n\n\n\n            for(j=0;j<jie[tail];++j)\n            {\n                int k=tail-1;\n                int nhh;\n                int pos=j;\n                int sub;\n                double temp;\n\n                int pailie[6];\n                for(nhh=0;nhh<5;++nhh)\n                pailie[nhh]=0;\n\n                for(l=0;l<tail;++l)\n                {\n                    int i;\n\n                    sub=pos/jie[k];\n                    for(i=0;sub!=0||pailie[i]==1;)\n                    {\n                        if(pailie[i]==1)\n                        ++i;\n                        else if(pailie[i]==0)\n                        {\n                            --sub;\n                            ++i;}\n\n                    }\n                    pailie[i]=1;\n                    pos=pos%jie[k];\n                    --k;\n                    tr[queen[l]].wei=w[i];\n                }\n\n                calcw(1);\n                temp=calclr();\n                if(temp<=r)\n                max=max>temp?max:temp;\n\n\n\n            }\n\n\n\n\n\n        }\n\n        if(max>0)\n        printf(\"%.16lf\\n\",max);\n        else\n        printf(\"-1\\n\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\npair<double, double> solve(int a, int b, vector<int>& w, vector<int>& x)\n{\n    if(a == b)\n        return make_pair(0.0, 0.0);\n\n    int c = min_element(x.begin()+a, x.begin()+b) - x.begin();\n    int left = accumulate(w.begin()+a, w.begin()+c+1, 0);\n    int right = accumulate(w.begin()+c+1, w.begin()+b+1, 0);\n\n    pair<double, double> p = solve(a, c, w, x);\n    pair<double, double> q = solve(c+1, b, w, x);\n    p.first  -= right / (double)(left + right);\n    p.second -= right / (double)(left + right);\n    q.first  += left  / (double)(left + right);\n    q.second += left  / (double)(left + right);\n\n    return make_pair(min(p.first, q.first), max(p.second, q.second));\n}\n\nint main()\n{\n    int d;\n    cin >> d;\n\n    while(--d >= 0){\n        double r;\n        int s;\n        cin >> r >> s;\n        vector<int> w(s);\n        for(int i=0; i<s; ++i)\n            cin >> w[i];\n\n        sort(w.begin(), w.end());\n        \n        double ret = -1.0;\n        do{\n            vector<int> x(s-1);\n            for(int i=0; i<s-1; ++i)\n                x[i] = i;\n\n            do{\n                pair<double, double> p = solve(0, s-1, w, x);\n                double len = p.second - p.first;\n                if(len < r)\n                    ret = max(ret, len);\n            }while(next_permutation(x.begin(), x.end()));\n        }while(next_permutation(w.begin(), w.end()));\n\n        if(ret < -0.5)\n            cout << -1 << endl;\n        else\n            printf(\"%.10f\\n\", ret);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1261: Mobile Computing\n// 2017.12.18 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-6\n\ntypedef struct { int w; double l, r; } ST;\nST st[20]; int top;\n\nint sz; double r;\ndouble ans;\nint w[12];\nchar f[12];\nint p[12];\n\ndouble calc()\n{\n\tint i;\n\tdouble x, y;\n\tST *a, *b, c;\n\n\ttop = 0;\n\tfor (i = 0; i < sz; i++) {\n\t\tif (w[p[i]] >= 0) st[top].w = w[p[i]], st[top].l = st[top].r = 0, top++;\n\t\telse {\n\t\t\tif (top < 2) return -1;\n\t\t\ta = &st[--top], b = &st[--top];\n\t\t\tc.w = a->w + b->w;\n\t\t\tx = b->w / (double)c.w, y = a->w / (double)c.w;\n\t\t\tc.l = a->l + x; if (c.l < b->l - y) c.l = b->l - y;\n\t\t\tc.r = a->r - x; if (c.r < b->r + y) c.r = b->r + y;\n\t\t\tst[top++] = c;\n\t\t}\n\t}\n\tif (top > 1) return -1;\n\treturn st[0].l + st[0].r;\n}\n\nvoid permutation(int i, int k)\n{\n\tint j;\n\tdouble w;\n\n\tp[i] = k;\n\tif (i == sz-1) {\n\t\tw = calc();\n\t\tif ((fabs(w-r) <= EPS || w <= r) && w > ans) ans = w;\n\t} else {\n\t\tf[k] = 0;\n\t\tfor (j = 0; j < sz; j++) if (f[j]) permutation(i+1, j);\n\t\tf[k] = 1;\n\t}\n}\n\nint main()\n{\n\tint cno, s, i;\n\n\tscanf(\"%d\", &cno);\n\twhile (cno--) {\n\t\tscanf(\"%lf%d\", &r, &s);\n\t\tsz = 0;\n\t\tfor (i = 0; i < s; i++) scanf(\"%d\", w + sz++);\n\t\tfor (i = 1; i < s; i++) w[sz++] = -1;\n\t\tif (r < 1.0 || s < 2) { puts(\"-1\"); continue; }\n\n\t\tans = -1;\n\t\tmemset(f, 1, sizeof(f));\n\t\tfor (i = 0; i < sz; i++) permutation(0, i);\n\t\tif (ans < 0) puts(\"-1\");\n\t\telse printf(\"%.16lf\\n\", ans);\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define MAX 200\n\nstruct tree\n{\n    int wei;\n    double l,r,m;\n    int is;\n\n}tr[MAX];\n\ndouble r;\nint s,w[7];\nint jie[8];\n\nint queen[MAX];\nint tail=0;\n\nint  calcw(int rt)\n{\n    int l=0,r=0;\n    if(tr[rt].wei!=0)\n    return tr[rt].wei;\n    else\n    {\n        if(tr[2*rt].is==1)\n        l=calcw(2*rt);\n        if(tr[2*rt+1].is==1)\n        r=calcw(2*rt+1);\n\n        tr[rt].wei=l+r;\n        return l+r;\n    }\n\n}\n\ndouble calclr()\n{\n    int i;\n    double min=9999999,max=-999999;\n\n    tr[1].m=0;\n\n    for(i=1;i<MAX;++i)\n    {\n\n        if(2*i+1<MAX&&tr[i*2].is==1)\n        {\n            double sum=tr[2*i].wei+tr[i*2+1].wei;\n\n            tr[i].l=tr[i].m-tr[i*2+1].wei/sum;\n            tr[i].r=tr[i].m+tr[i*2].wei/sum;\n            min=min>tr[i].l?tr[i].l:min;\n            max=max>tr[i].r?max:tr[i].r;\n\n            tr[i*2].m=tr[i].l;\n            tr[i*2+1].m=tr[i].r;\n\n        }\n    }\n\n    return max-min;\n}\n\nvoid in(int n)\n{\n    int i;\n    for(i=tail;i>n;--i)\n    {\n        queen[i]=queen[i-1];\n    }\n    queen[n]=queen[n+1]*2;\n    queen[n+1]+=queen[n+1]+1;\n    tr[queen[n]].is=1;\n    tr[queen[n+1]].is=1;\n\n    tail++;\n}\n\nint main()\n{\n\n\n    int i,t,j,l;\n    double max;\n    jie[0]=1;\n    for(i=1;i<8;++i)\n    jie[i]=jie[i-1]*i;\n\n\n    scanf(\"%d\",&t);\n    for(;t>0;--t)\n    {\n    max=0;\n    scanf(\"%lf%d\",&r,&s);\n    for(i=0;i<s;++i)\n    scanf(\"%d\",w+i);\n        if(s>1)\n        for(i=0;i<jie[s];++i)\n        {\n            int k=2;\n            int pos=i;\n\n\n            tail=0;\n            memset(tr,0,sizeof(tr));\n            queen[tail++]=1;\n            in(0);\n\n            tr[1].is=1;\n\n            for(;k<s;++k)\n            {\n                in(pos*jie[k]/jie[s-1]);\n                pos=pos%(jie[s-1]/jie[k]);\n\n\n            }\n\n\n\n            for(j=0;j<jie[tail];++j)\n            {\n                int k=tail-1;\n                int nhh;\n                int pos=j;\n                int sub;\n                double temp;\n\n                int pailie[7];\n                for(nhh=0;nhh<6;++nhh)\n                pailie[nhh]=0;\n\n                for(l=0;l<tail;++l)\n                {\n                    int i;\n\n                    sub=pos/jie[k];\n                    for(i=0;sub!=0||pailie[i]==1;)\n                    {\n                        if(pailie[i]==1)\n                        ++i;\n                        else if(pailie[i]==0)\n                        {\n                            --sub;\n                            ++i;}\n\n                    }\n                    pailie[i]=1;\n                    pos=pos%jie[k];\n                    --k;\n                    tr[queen[l]].wei=w[i];\n                }\n\n                calcw(1);\n                temp=calclr();\n                if(temp<=r)\n                max=max>temp?max:temp;\n\n\n\n            }\n\n\n\n\n\n        }\n\n\n        else\n        {\n            max=-1;\n            printf(\"-1\\n\");\n        }\n        if(max>0)\n        printf(\"%.16lf\\n\",max);\n        else if(max==0)\n        printf(\"-1\\n\");\n\n    }\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Mobile Computing\npublic class Main{\n\n\tdouble r, best;\n\tint n;\n\tint[] ws, w;\n\tSet<String>[] trees;\n\n\tint bit(int s){\n\t\tint c = 0;\n\t\tfor(int j=0;j<n;j++)if(((s>>j)&1)>0)c++;\n\t\treturn c;\n\t}\n\tboolean sub(int s, int t){\n\t\tfor(int j=0;j<n;j++)if(((t>>j)&1)>0&&((s>>j)&1)==0)return false;\n\t\treturn true;\n\t}\n\t\n\t\n\tclass M{\n\t\tdouble x;\n\t\tboolean leaf;\n\t\tint w;\n\t\tM left, right;\n\t\tpublic M(double x, boolean leaf, int w) {\n\t\t\tthis.x = x;\n\t\t\tthis.leaf = leaf;\n\t\t\tthis.w = w;\n\t\t\tleft = right = null;\n\t\t}\n\t\tint get(){\n\t\t\tif(leaf)return w;\n\t\t\treturn left.get()+right.get();\n\t\t}\n\t\tvoid val(){\n\t\t\tif(leaf){\n\t\t\t\tmin = Math.min(min, x); max = Math.max(max, x); return;\n\t\t\t}\n\t\t\tint w1 = left.get(), w2 = right.get();\n\t\t\tdouble a = w2*1.0/(w1+w2);\n//\t\t\tSystem.out.println(\"A:\"+a+\" X:\"+x);\n\t\t\tleft.x = x-a;\n\t\t\tright.x = x+1-a;\n\t\t\tleft.val();\n\t\t\tright.val();\n\t\t}\n\t\tvoid f(){\n\t\t\tif(leaf){\n\t\t\t\tSystem.out.print(\"x\"); return;\n\t\t\t}\n\t\t\tSystem.out.print(\"(\");\n\t\t\tleft.f();\n\t\t\tSystem.out.print(\",\");\n\t\t\tright.f();\n\t\t\tSystem.out.print(\")\");\n\t\t}\n\t}\n\t\n\tdouble min, max;\n\tboolean[] used;\n\tint[] order;\n\tvoid dfs(int k){\n\t\tif(k==n){\n\t\t\tfor(String t:trees[n]){\n\t\t\t\ts = (t+\"$\").toCharArray();\n\t\t\t\tid = 0;\n\t\t\t\tint a = 0;\n\t\t\t\tfor(int i=0;i<s.length;i++){\n\t\t\t\t\tif(s[i]=='?'){\n\t\t\t\t\t\ts[i] = (char)(order[a++]+'0');\n\t\t\t\t\t}\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"S:\"+new String(s));\n\t\t\t\tM root = exp();\n//\t\t\t\troot.f();\n//\t\t\t\tSystem.out.println();\n\t\t\t\tmin = max = 0;\n\t\t\t\tif(!root.leaf){\n\t\t\t\t\troot.x = 0;\n\t\t\t\t\troot.val();\n\t\t\t\t}\n\t\t\t\tdouble res = max-min;\n//\t\t\t\tSystem.out.println(min+\" - \"+max+\" RES:\"+res);\n\t\t\t\t\n\t\t\t\tif(res<r)best = Math.max(best, res);\n\t\t\t\troot.val();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(used[i])continue;\n\t\t\tused[i]=true;\n\t\t\torder[k] = i;\n\t\t\tdfs(k+1);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n\t\n\tchar[] s;\n\tint id;\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\tM exp(){\n\t\tchar ch = get();\n\t\tif(ch=='('){\n\t\t\tM res = new M(0, false, 0);\n\t\t\tres.left = exp();\n\t\t\tget();\n\t\t\tres.right = exp();\n\t\t\tget();\n\t\t\treturn res;\n\t\t}\n\t\tM res = new M(0, true, ws[ch-'0']);\n\t\treturn res;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\ttrees = new Set[7];\n\t\tfor(int i=1;i<=6;i++)trees[i] = new HashSet<String>();\n\t\ttrees[1].add(\"?\");\n\t\tfor(int i=2;i<=6;i++){\n\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\tfor(String left:trees[j])for(String right:trees[i-j])trees[i].add(\"(\"+left+\",\"+right+\")\");\n\t\t\t}\n//\t\t\tSystem.out.println(\"Size:\"+trees[i].size());\n//\t\t\tdebug(trees[i]);\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tr = sc.nextDouble(); n = sc.nextInt();\n\t\t\tws = new int[n];\n\t\t\tfor(int i=0;i<n;i++)ws[i]=sc.nextInt();\n\t\t\tw = new int[1<<n];\n\t\t\tfor(int i=0;i<1<<n;i++){\n\t\t\t\tint s = 0;\n\t\t\t\tfor(int j=0;j<n;j++)if(((i>>j)&1)>0)s+=ws[n-1-j];\n\t\t\t\tw[i] = s;\n\t\t\t}\n//\t\t\tif(n==1){\n//\t\t\t\tSystem.out.printf(\"%.8f\\n\", 0.0);\n//\t\t\t\tcontinue;\n//\t\t\t}\n\t\t\tbest = -1;\n\t\t\tused = new boolean[n];\n\t\t\torder = new int[n];\n\t\t\tdfs(0);\n\t\t\tSystem.out.printf(\"%.8f\\n\", best);\n\t\t}\n\t}\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Mobile Computing\npublic class Main{\n\n\tdouble r, best;\n\tint n;\n\tint[] ws, w;\n\tSet<String>[] trees;\n\t\n\tclass M{\n\t\tdouble x;\n\t\tboolean leaf;\n\t\tint w;\n\t\tM left, right;\n\t\tpublic M(double x, boolean leaf, int w) {\n\t\t\tthis.x = x;\n\t\t\tthis.leaf = leaf;\n\t\t\tthis.w = w;\n\t\t\tleft = right = null;\n\t\t}\n\t\tint get(){\n\t\t\tif(leaf)return w;\n\t\t\treturn left.get()+right.get();\n\t\t}\n\t\tvoid val(){\n\t\t\tif(leaf){\n\t\t\t\tmin = Math.min(min, x); max = Math.max(max, x); return;\n\t\t\t}\n\t\t\tint w1 = left.get(), w2 = right.get();\n\t\t\tdouble a = w2*1.0/(w1+w2);\n\t\t\tleft.x = x-a;\n\t\t\tright.x = x+1-a;\n\t\t\tleft.val();\n\t\t\tright.val();\n\t\t}\n\t}\n\t\n\tdouble min, max;\n\tboolean[] used;\n\tint[] order;\n\tvoid dfs(int k){\n\t\tif(k==n){\n\t\t\tfor(String t:trees[n]){\n\t\t\t\ts = (t+\"$\").toCharArray();\n\t\t\t\tid = 0;\n\t\t\t\tint a = 0;\n\t\t\t\tfor(int i=0;i<s.length;i++){\n\t\t\t\t\tif(s[i]=='?'){\n\t\t\t\t\t\ts[i] = (char)(order[a++]+'0');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tM root = exp();\n\t\t\t\tmin = max = 0;\n\t\t\t\tif(!root.leaf){\n\t\t\t\t\troot.x = 0;\n\t\t\t\t\troot.val();\n\t\t\t\t}\n\t\t\t\tdouble res = max-min;\n\t\t\t\tif(res<r)best = Math.max(best, res);\n\t\t\t\troot.val();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(used[i])continue;\n\t\t\tused[i]=true;\n\t\t\torder[k] = i;\n\t\t\tdfs(k+1);\n\t\t\tused[i]=false;\n\t\t}\n\t}\n\t\n\tchar[] s;\n\tint id;\n\tchar get(){\n\t\treturn s[id++];\n\t}\n\tM exp(){\n\t\tchar ch = get();\n\t\tif(ch=='('){\n\t\t\tM res = new M(0, false, 0);\n\t\t\tres.left = exp();\n\t\t\tget();\n\t\t\tres.right = exp();\n\t\t\tget();\n\t\t\treturn res;\n\t\t}\n\t\tM res = new M(0, true, ws[ch-'0']);\n\t\treturn res;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\ttrees = new Set[7];\n\t\tfor(int i=1;i<=6;i++)trees[i] = new HashSet<String>();\n\t\ttrees[1].add(\"?\");\n\t\tfor(int i=2;i<=6;i++){\n\t\t\tfor(int j=1;j<i;j++){\n\t\t\t\tfor(String left:trees[j])for(String right:trees[i-j])trees[i].add(\"(\"+left+\",\"+right+\")\");\n\t\t\t}\n\t\t}\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T--!=0){\n\t\t\tr = sc.nextDouble(); n = sc.nextInt();\n\t\t\tws = new int[n];\n\t\t\tfor(int i=0;i<n;i++)ws[i]=sc.nextInt();\n\t\t\tw = new int[1<<n];\n\t\t\tfor(int i=0;i<1<<n;i++){\n\t\t\t\tint s = 0;\n\t\t\t\tfor(int j=0;j<n;j++)if(((i>>j)&1)>0)s+=ws[n-1-j];\n\t\t\t\tw[i] = s;\n\t\t\t}\n\t\t\tbest = -1;\n\t\t\tused = new boolean[n];\n\t\t\torder = new int[n];\n\t\t\tdfs(0);\n\t\t\tSystem.out.printf(\"%.8f\\n\", best);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\t//2040 start\n\t//2123 cording end\n\t//2321 sample matched\n\t\n\tint n;\n\tint [] data, accdata;\n\tint [] work;\n\tboolean [] used;\n\tboolean isNA;\n\tdouble ans, length;\n\tdouble EPS = 1.0e-08;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner (System.in);\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tlength = sc.nextDouble();\n\t\t\tn = sc.nextInt();\n\t\t\tdata = new int[n];\n\t\t\tfor(int i = 0 ; i < n;i ++){\n\t\t\t\tdata[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\t\n\t\t\twork = new int[n];\n\t\t\tused = new boolean[n];\n\t\t\tisNA = false;\n\t\t\tans = -1.0;\n\t\t\tdfs(0);\n\t\t\t\n\t\t\tif(ans < 0){\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dfs(int deep) {\n\t\tif(deep == n){\n\t\t\taccdata = new int[n + 1];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\taccdata[i+1] = accdata[i] + work[i];\n\t\t\t}\n\t\t\tHashMap<Double, Double> res = dfs2(0, n-1);\n//\t\t\tSystem.out.println(\"work = \" + Arrays.toString(work));\n//\t\t\tSystem.out.println(\"acc = \" + Arrays.toString(accdata));\n//\t\t\tSystem.out.println();\n\t\t\tfor(double d: res.keySet()){\n\t\t\t\tdouble value = d + res.get(d);\n\t\t\t\tif(value > length + EPS){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans = Math.max(ans, value);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(! used[i]){\n\t\t\t\tused[i] = true;\n\t\t\t\twork[deep] = data[i];\n\t\t\t\tdfs(deep + 1);\n\t\t\t\twork[deep] = -1;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate HashMap<Double, Double> dfs2(int i, int j) {\n\t\tHashMap<Double, Double> res = new HashMap<Double,Double>();\n\t\tif(i == j){\n\t\t\tres.put(0.0, 0.0);\n\t\t\treturn res;\n\t\t}\n\t\tif(i + 1 == j){\n\t\t\tdouble right = (double)work[i]/(work[i] + work[j]);\n\t\t\tdouble left =  (double)work[j]/(work[i] + work[j]);\n\t\t\tres.put(left, right);\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tfor(int k = i; k < j; k++){\n\t\t\tHashMap<Double, Double> resleft = dfs2(i, k);\n\t\t\tHashMap<Double, Double> resright = dfs2(k+1, j);\n\t\t\tdouble nowvalue1 = (double)(accdata[k + 1] - accdata[i]);\n\t\t\tdouble nowvalue2 = (double)(accdata[j + 1] - accdata[k + 1]);\n\t\t\tfor(double leftkey: resleft.keySet()){\n\t\t\t\tfor(double rightkey: resright.keySet()){\n\t\t\t\t\tdouble nowvalueR =  nowvalue1 / (accdata[j + 1] - accdata[i]);\n\t\t\t\t\tdouble nowvalueL =  nowvalue2 / (accdata[j + 1] - accdata[i]);\n\t\t\t\t\tdouble valueright = Math.max(resleft.get(leftkey) - nowvalueL, resright.get(rightkey) + nowvalueR);   \n\t\t\t\t\tdouble valueleft = Math.max(rightkey - nowvalueR, leftkey + nowvalueL);\n\t\t\t\t\tres.put(valueleft, valueright);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef max_w(mbls)\n  len = mbls.length\n  \n  if len == 1\n    mbl = mbls.first\n    return mbl[1] + mbl[2]\n  end\n\n  mw = 0.0\n\n  for i in (0...(len - 1))\n    wi0, l0, r0 = mbls[i]\n    wi1, l1, r1 = mbls[i + 1]\n\n    nwi = wi0 + wi1\n    li = wi1 / nwi\n    ri = wi0 / nwi\n    nl0 = l0 + li\n    nr0 = r0 - li\n    nl1 = l1 - ri\n    nr1 = r1 + ri\n    nmbl = [nwi, (nl0 > nl1) ? nl0 : nl1, (nr0 > nr1) ? nr0 : nr1]\n\n    nmbls = mbls[0...i] + [nmbl] + mbls[(i + 2)...len]\n    w = max_w(nmbls)\n    mw = w if mw < w && w < $rw\n  end\n\n  mw\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  $rw = gets.to_f\n  sn = gets.to_i\n\n  wis = sn.times.map{gets.to_f}\n  #p [rw, wis]\n\n  mbls = wis.map{|wi| [wi, 0.0, 0.0]}\n  #p mbls\n  \n  mw = 0.0\n\n  mbls.permutation.each do |mbls0|\n    w = max_w(mbls0)\n    mw = w if mw < w && w < $rw\n  end\n\n  puts (mw == 0.0) ? -1 : mw\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef max_w(mbls)\n  len = mbls.length\n  \n  if len == 1\n    mbl = mbls.first\n    return mbl[1] + mbl[2]\n  end\n\n  mw = -1.0\n\n  for i in (0...(len - 1))\n    wi0, l0, r0 = mbls[i]\n    wi1, l1, r1 = mbls[i + 1]\n\n    nwi = wi0 + wi1\n    li = wi1 / nwi\n    ri = wi0 / nwi\n    nl0 = l0 + li\n    nr0 = r0 - li\n    nl1 = l1 - ri\n    nr1 = r1 + ri\n    nmbl = [nwi, (nl0 > nl1) ? nl0 : nl1, (nr0 > nr1) ? nr0 : nr1]\n\n    nmbls = mbls[0...i] + [nmbl] + mbls[(i + 2)...len]\n    w = max_w(nmbls)\n    mw = w if mw < w && w < $rw\n  end\n\n  mw\nend\n\n### main\n\nn = gets.to_i\n\nn.times do\n  $rw = gets.to_f\n  sn = gets.to_i\n\n  wis = sn.times.map{gets.to_f}\n  #p [rw, wis]\n\n  mbls = wis.map{|wi| [wi, 0.0, 0.0]}\n  #p mbls\n  \n  mw = -1.0\n  \n  mbls.permutation.each do |mbls0|\n    w = max_w(mbls0)\n    if mw < w && w < $rw\n      mw = w\n    end\n  end\n\n  puts (mw < 0.0 ? -1 : mw)\nend"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from itertools import combinations\n    from sys import stdin\n    f_i = stdin\n    \n    def dfs(base, stones):\n        key = tuple(stones)\n        if key in rec:\n            return set((base + l, base + r) for l, r in rec[key])\n        \n        edges = set()\n        positions = set()\n        for i in range(1, len(stones)):\n            for tpl in combinations(stones, i):\n                s1 = list(tpl)\n                s2 = stones[:]\n                for s in s1:\n                    s2.remove(s)\n                \n                w1 = sum(s1)\n                w2 = sum(s2)\n                w = w1 + w2\n                \n                b1 = base - w2 / w\n                b2 = base + w1 / w\n                \n                left_tree_ends = dfs(b1, s1)\n                right_tree_ends = dfs(b2, s2)\n                \n                for ll, lr in left_tree_ends:\n                    for rl, rr in right_tree_ends:\n                        if ll < rl:\n                            l = ll\n                        else:\n                            l = rl\n                        if lr < rr:\n                            r = rr\n                        else:\n                            r = lr\n                        edges.add((l - base, r - base))\n                        positions.add((l, r))\n        \n        rec[key] = edges\n        return positions\n    \n    num = int(f_i.readline())\n    \n    rec = dict()\n    for i in range(num):\n        r = float(f_i.readline())\n        s = int(f_i.readline())\n        \n        stones = sorted(int(f_i.readline()) for i in range(s))\n        \n        for stone in stones:\n            rec[(stone,)] = {(0, 0)}\n        \n        edge_set = dfs(0, stones)\n        try:\n            ans = max(b - a for a, b in edge_set if b - a < r)\n            print(ans)\n        except ValueError:\n            print(-1)\n\nsolve()\n"
  }
]