[
  {
    "language": "Scala",
    "code": "class Field (var value: List[Int]) {\n    def get: List[Int] = {\n        this.value\n    }\n    def update(y: Int, x: Int): Unit = {\n        val bits = this.value(y) ^ (1 << x)\n        this.value = (0 to 9).toList.map(i => if(i == y) bits else this.value(i))\n    }\n}\nobject Main {\n    var fld = new Field(List(1))\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val orig = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            fld = new Field(orig)\n            var i = 0\n            var flag = true\n            var ans = List(1)\n            while(flag) {\n                fld = new Field(orig)\n                ans = total_flip(i, 0, Nil)\n                if(fld.get(9) == 0) {\n                    ans.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n                    flag = false\n                }\n                else i += 1\n            }\n        }\n    }\n    def beam(y: Int, x: Int): Unit = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foreach(p => fld.update(p._1, p._2))\n    }\n\n    def row_flip(y: Int, x: Int, bits: Int, acc: Int): Int = {\n        if(x == 10) acc\n        else {\n            if((bits & (1 << x)) != 0) {\n                beam(y, x)\n                row_flip(y, x + 1, bits, acc + (1 << x))\n            }\n            else row_flip(y, x + 1, bits, acc)\n        }\n    }\n\n    def total_flip(bits: Int, y: Int, ans: List[Int]): List[Int] = {\n        if(y == 10) ans\n        else if(y == 0) total_flip(bits, y + 1, List(row_flip(0, 0, bits, 0)))\n        else total_flip(bits, y + 1, ans ::: List(row_flip(y, 0, fld.get(y-1), 0)))\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  val fld = Array.ofDim[Int](10)\n  val ans = Array.ofDim[Int](10)\n\n  def beam(y: Int, x: Int) = {\n    val beams = \n      List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1))\n      .filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n    for(b <- beams) {\n      fld(b._1) ^= (1 << b._2)\n    }\n  }\n\n  def init(orig: Array[Int]) = {\n    for(y <- 0 to 9) {\n      fld(y) = orig(y)\n      ans(y) = 0\n    }\n  }\n\n  def row_flip(y: Int, bits: Int) = {\n    for(x <- 0 to 9) {\n      if((bits & (1 << x)) != 0) {\n        beam(y, x)\n        ans(y) |= (1 << x)\n      }\n    }\n  }\n\n  def flip(bits: Int) = {\n    row_flip(0, bits)\n    for(y <- 1 to 9) row_flip(y, fld(y - 1))\n  }\n\n  def solve(orig: Array[Int]) = {\n    var i = 0\n    var flag = true\n    while(flag) {\n      init(orig)\n      flip(i)\n      if(fld(9) == 0) {\n        ans.foreach(bits => println(\n          Integer.toBinaryString(bits)\n            .reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n        flag = false\n      }\n      else i += 1\n    }\n  }\n\n  def main(args:Array[String]) = {\n    val sc = new java.util.Scanner(System.in)\n    val n = sc.nextInt\n    sc.nextLine\n    for(_ <- 1 to n) {\n      val orig = (1 to 10).toArray.map(_ => \n        Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n      solve(orig)\n    }\n  }"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def change(a: Array[Array[Int]], x: Int, y: Int) {\n    val dx = Seq(0, -1, 0, 1, 0)\n    val dy = Seq(0, 0, 1, 0, -1)\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def solve(a: Array[Array[Int]]): Option[Array[Array[Int]]] = {\n    val test = (n: Int) => {\n      val b = a.map(_.clone)\n      val c = Array.ofDim[Int](10,10)\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      if (b.map(_.sum).sum == 0) {\n        Some(c)\n      } else {\n        None\n      }\n      System.gc()\n    }\n    for(i <- 0 until (1<<10)) {\n      test(i) match {\n        case Some(c) => return Some(c)\n        case _ => \n      }\n    }\n    return None\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).get.foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def change(a: Array[Array[Int]], x: Int, y: Int) {\n    val dx = Seq(0, -1, 0, 1, 0)\n    val dy = Seq(0, 0, 1, 0, -1)\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= x\n      if x < 10\n      if 0 <= y\n      if y < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def solve(a: Array[Array[Int]]): Option[Array[Array[Int]]] = {\n    val test = (n: Int) => {\n      val b = a.map(_.clone)\n      val c = Array.ofDim[Int](10,10)\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      if (b.map(_.sum).sum == 0) {\n        Some(c)\n      } else {\n        None\n      }\n    }\n    for(i <- 0 until (1<<10)) {\n      test(i) match {\n        case Some(c) => return Some(c)\n        case _ => \n      }\n    }\n    return None\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).getOrElse(Array.ofDim[Int](10,10)).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  val dx = Seq(0, -1, 0, 1, 0)\n  val dy = Seq(0, 0, 1, 0, -1)\n  val b = Array.ofDim[Int](10, 10)\n  val c = Array.ofDim[Int](10, 10)\n  val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def test (a: Array[Array[Int]], n: Int) = {\n    for(i <- 0 until 10; j <- 0 until 10) {\n      b(i)(j) = a(i)(j)\n      c(i)(j) = 0\n    }\n    for(i <- 0 until 10) {\n      if((n & (1 << i)) != 0) {\n        change(b, 0, i)\n        c(0)(i) = 1\n      }\n    }\n    for(i <- 1 until 10) {\n      for(j <- 0 until 10) {\n        if(b(i-1)(j) == 1) {\n          change(b, i, j)\n          c(i)(j) = 1\n        }\n      }\n    }\n    b.map(_.sum).sum == 0\n  }\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    var i = 0\n    while(i < (1 << 2)) {\n      if(test(a, i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  val dx = Seq(0, -1, 0, 1, 0)\n  val dy = Seq(0, 0, 1, 0, -1)\n  val b = Array.ofDim[Int](10, 10)\n  val c = Array.ofDim[Int](10, 10)\n  val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def test (a: Array[Array[Int]], n: Int) = {\n    for(i <- 0 until 10; j <- 0 until 10) {\n      b(i)(j) = a(i)(j)\n      c(i)(j) = 0\n    }\n    for(i <- 0 until 10) {\n      if((n & (1 << i)) != 0) {\n        change(b, 0, i)\n        c(0)(i) = 1\n      }\n    }\n    for(i <- 1 until 10) {\n      for(j <- 0 until 10) {\n        if(b(i-1)(j) == 1) {\n          change(b, i, j)\n          c(i)(j) = 1\n        }\n      }\n    }\n    b.forall(_.forall(_ == 0))\n  }\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(a, i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "class Field (var value: List[Int]) {\n    def get: List[Int] = {\n        this.value\n    }\n    def update(y: Int, x: Int): Unit = {\n        val bits = this.value(y) ^ (1 << x)\n        this.value = (0 to 9).toList.map(i => if(i == y) bits else this.value(i))\n    }\n}\nobject Main {\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val orig = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            var fld = new Field(orig)\n            var i = 0\n            var flag = true\n            var ans = List(1)\n            while(flag) {\n                fld = new Field(orig)\n                ans = total_flip(i, 0, Nil, fld)\n                if(fld.get(9) == 0) {\n                    ans.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n                    flag = false\n                }\n                else i += 1\n            }\n        }\n    }\n    def beam(y: Int, x: Int, fld: Field): Field = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foreach(p => fld.update(p._1, p._2))\n        fld\n    }\n\n    def row_flip(y: Int, x: Int, bits: Int, acc: Int, fld: Field): Int = {\n        if(x == 10) acc\n        else {\n            if((bits & (1 << x)) != 0) row_flip(y, x + 1, bits, acc + (1 << x), beam(y, x, fld))\n            else row_flip(y, x + 1, bits, acc, fld)\n        }\n    }\n\n    def total_flip(bits: Int, y: Int, ans: List[Int], fld: Field): List[Int] = {\n        if(y == 10) ans\n        else if(y == 0) total_flip(bits, y + 1, List(row_flip(0, 0, bits, 0, fld)), fld)\n        else total_flip(bits, y + 1, ans ::: List(row_flip(y, 0, fld.get(y-1), 0, fld)), fld)\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      val dx = Seq(0, -1, 0, 1, 0)\n      val dy = Seq(0, 0, 1, 0, -1)\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n  val fld = Array.ofDim[Int](10)\n  val ans = Array.ofDim[Int](10)\n\n  def beam(y: Int, x: Int) = {\n    val beams = \n      List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1))\n      .filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n    for(b <- beams) {\n      fld(b._1) ^= (1 << b._2)\n    }\n  }\n\n  def init(orig: Array[Int]) = {\n    for(y <- 0 to 9) {\n      fld(y) = orig(y)\n      ans(y) = 0\n    }\n  }\n\n  def row_flip(y: Int, bits: Int) = {\n    for(x <- 0 to 9) {\n      if((bits & (1 << x)) != 0) {\n        beam(y, x)\n        ans(y) |= (1 << x)\n      }\n    }\n  }\n\n  def flip(bits: Int) = {\n    row_flip(0, bits)\n    for(y <- 1 to 9) row_flip(y, fld(y - 1))\n  }\n\n  def solve(orig: Array[Int]) = {\n    var i = 0\n    var flag = true\n    while(flag) {\n      init(orig)\n      flip(i)\n      if(fld(9) == 0) {\n        ans.foreach(bits => println(\n          Integer.toBinaryString(bits)\n            .reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n        flag = false\n      }\n      else i += 1\n    }\n  }\n\n  def main(args:Array[String]) = {\n    val sc = new java.util.Scanner(System.in)\n    val n = sc.nextInt\n    sc.nextLine\n    for(_ <- 1 to n) {\n      val orig = (1 to 10).toArray.map(_ => \n        Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n      solve(orig)\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n  import scala.io.StdIn.{readLine}\n  for (testCase← 0 until readLine().toInt){\n    val field = Field()\n    for (y ← 0 until 10){\n      readLine().split(' ').map(_.toInt).zipWithIndex.foreach{\n        case (0, x) ⇒ field(x, y) = Off\n        case (1, x) ⇒ field(x, y) = On\n      }\n    }\n    val raw = Field()\n    (0 until 1024).flatMap(canResetField(field, _)).flatten.flatten.foreach(c ⇒ raw(c) = On)\n    println((0 until 10).map(y ⇒ (0 until 10).map(x ⇒ raw(x, y) match {case Off ⇒ 0 case On ⇒ 1}).mkString(\"\",\" \",\"\\n\")).mkString)\n  }\n  case class Coordinate(x:Int, y:Int){\n    def +(that:Coordinate):Coordinate = Coordinate(x + that.x, y + that.y)\n  }\n  def BeamLine(initial:Int):Iterable[Coordinate] = (0 until 10).filter{x ⇒ ((1 << x) & initial) != 0}.map{Coordinate(_, 0)}\n  sealed trait Lamp{\n    def switch:Lamp\n  }\n  object On extends Lamp{\n    override def switch:Lamp = Off\n  }\n  object Off extends Lamp{\n    override def switch:Lamp = On\n  }\n  object Field{\n    def apply():Field = new Field()\n    private val relationalEffectArea:Iterable[Coordinate] = Coordinate(0, -1)::Coordinate(-1, 0)::Coordinate(0, 0)::Coordinate(1, 0)::Coordinate(0, 1)::Nil\n  }\n  class Field{\n    private val mArray:Array[Array[Lamp]]= Array.tabulate(10){_ ⇒ Array.tabulate(10){_ ⇒ Off}}\n    def apply(x:Int, y:Int):Lamp = mArray(x)(y)\n    def apply(coordinate: Coordinate):Lamp = mArray(coordinate.x)(coordinate.y)\n    def update(x:Int, y:Int, value:Lamp):Unit = mArray(x)(y) = value\n    def update(coordinate: Coordinate, value:Lamp):Unit = mArray(coordinate.x)(coordinate.y) = value\n    def shootBeam(beam:Coordinate):Unit = Field.relationalEffectArea.map{_ + beam}.filter{case Coordinate(x, y) ⇒ (0 until 10).contains(x) && (0 until 10).contains(y)}.foreach{case Coordinate(x, y) ⇒ mArray(x)(y) = mArray(x)(y).switch}\n  }\n  def canResetField(field: Field, initial:Int):Option[Iterable[Iterable[Coordinate]]] = {\n    var res:List[Iterable[Coordinate]] = BeamLine(initial)::Nil\n    res.foreach{_.foreach{field.shootBeam(_)}}\n    for (y ← 1 until 10){\n      val l = (0 until 10).filter{field(_, y - 1) == On}.map{Coordinate(_, y)}\n      l.foreach{field.shootBeam(_)}\n      res = l::res\n    }\n    (0 until 10).forall{field(_, 9) == Off} match{\n      case true ⇒ {\n        res.foreach(_.foreach(c ⇒ field.shootBeam(c)))\n        Some(res)\n      }\n      case false ⇒ {\n        res.foreach(_.foreach(c ⇒ field.shootBeam(c)))\n        None\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "object Main {\n    val fld = Array.ofDim[Int](10)\n    val ans = Array.ofDim[Int](10)\n    val my = List(0, -1,  0, 1, 0)\n    val mx = List(0,  0, -1, 0, 1)\n    def beam(y: Int, x: Int) = {\n        val target = my.zip(mx).map(mv => (mv._1 + y, mv._2 + x))\n            .filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        for(p <- target) {\n            fld(p._1) ^= (1 << p._2)\n        }\n    }\n\n    def init(orig: Array[Int]) = {\n        for(y <- 0 to 9) {\n            fld(y) = orig(y)\n            ans(y) = 0\n        }\n    }\n\n    def row_flip(y: Int, bits: Int) = {\n        for(x <- 0 to 9) {\n            if((bits & (1 << x)) != 0) {\n                beam(y, x)\n                ans(y) |= (1 << x)\n            }\n        }\n    }\n\n    def flip(y: Int, bits: Int) = {\n        row_flip(0, bits)\n        for(y <- 1 to 9) row_flip(y, fld(y - 1))\n    }\n\n    def solve(orig: Array[Int]) = {\n        var i = 0\n        var flag = true\n        while(flag) {\n            init(orig)\n            flip(0, i)\n            if(fld(9) == 0) {\n                ans.foreach(bits => \n                    println(Integer.toBinaryString(bits).reverse.padTo(10, '0')\n                            .split(\"\").mkString(\" \")))\n                flag = false\n            }\n            else i += 1\n        }\n    }\n\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(_ <- 1 to n) {\n            val orig = (1 to 10).toArray.map(_ => \n                Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            solve(orig)\n        }\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  val dx = Seq(0, -1, 0, 1, 0)\n  val dy = Seq(0, 0, 1, 0, -1)\n  val b = Array.ofDim[Int](10, 10)\n  val c = Array.ofDim[Int](10, 10)\n  val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def test (a: Array[Array[Int]], n: Int) => {\n    for(i <- 0 until 10; j <- 0 until 10) {\n      b(i)(j) = a(i)(j)\n      c(i)(j) = 0\n    }\n    for(i <- 0 until 10) {\n      if((n & (1 << i)) != 0) {\n        change(b, 0, i)\n        c(0)(i) = 1\n      }\n    }\n    for(i <- 1 until 10) {\n      for(j <- 0 until 10) {\n        if(b(i-1)(j) == 1) {\n          change(b, i, j)\n          c(i)(j) = 1\n        }\n      }\n    }\n    b.map(_.sum).sum == 0\n  }\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def change(a: Array[Array[Int]], x: Int, y: Int) {\n    val dx = Seq(0, -1, 0, 1, 0)\n    val dy = Seq(0, 0, 1, 0, -1)\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= x\n      if x < 10\n      if 0 <= y\n      if y < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def solve(a: Array[Array[Int]]): Option[Array[Array[Int]]] = {\n    val test = (n: Int) => {\n      val b = a.map(_.clone)\n      val c = Array.ofDim[Int](10,10)\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      if (b.map(_.sum).sum == 0) {\n        Some(c)\n      } else {\n        None\n      }\n    }\n    for(i <- 0 until (1<<10)) {\n      test(i) match {\n        case Some(c) => return Some(c)\n        case _ => \n      }\n    }\n    return None\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).get.foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val dx = Seq(0, -1, 0, 1, 0)\n    val dy = Seq(0, 0, 1, 0, -1)\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n    val fld = Array.ofDim[Int](10)\n    val ans = Array.ofDim[Int](10)\n\n    def beam(y: Int, x: Int) = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        for(p <- dir) {\n            fld(p._1) ^= (1 << p._2)\n        }\n    }\n\n    def init(orig: Array[Int]) = {\n        for(y <- 0 to 9) {\n            fld(y) = orig(y)\n            ans(y) = 0\n        }\n    }\n\n    def row_flip(y: Int, bits: Int) = {\n        for(x <- 0 to 9) {\n            if((bits & (1 << x)) != 0) {\n                beam(y, x)\n                ans(y) |= (1 << x)\n            }\n        }\n    }\n\n    def flip(y: Int, bits: Int) = {\n        row_flip(0, bits)\n        for(y <- 1 to 9) row_flip(y, fld(y - 1))\n    }\n\n    def solve(orig: Array[Int]) = {\n        var i = 0\n        var flag = true\n        while(flag) {\n            init(orig)\n            flip(0, i)\n            if(fld(9) == 0) {\n                ans.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n                flag = false\n            }\n            else flag = false\n        }\n    }\n\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(_ <- 1 to n) {\n            val orig = (1 to 10).toArray.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            solve(orig)\n        }\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n    val fld = Array.ofDim[Int](10)\n    val ans = Array.ofDim[Int](10)\n\n    def beam(y: Int, x: Int) = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        for(p <- dir) {\n            fld(p._1) ^= (1 << p._2)\n        }\n    }\n\n    def init(orig: Array[Int]) = {\n        for(y <- 0 to 9) {\n            fld(y) = orig(y)\n            ans(y) = 0\n        }\n    }\n\n    def row_flip(y: Int, bits: Int) = {\n        for(x <- 0 to 9) {\n            if((bits & (1 << x)) != 0) {\n                beam(y, x)\n                ans(y) |= (1 << x)\n            }\n        }\n    }\n\n    def flip(y: Int, bits: Int) = {\n        row_flip(0, bits)\n        for(y <- 1 to 9) row_flip(y, fld(y - 1))\n    }\n\n    def solve(orig: Array[Int]) = {\n        var i = 0\n        var flag = true\n        while(flag) {\n            init(orig)\n            flip(0, i)\n            if(fld(9) == 0) {\n                ans.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n                flag = false\n            }\n            else i += 1\n        }\n    }\n\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(_ <- 1 to n) {\n            val orig = (1 to 10).toArray.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            solve(orig)\n        }\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      val dx = Seq(0, -1, 0, 1, 0)\n      val dy = Seq(0, 0, 1, 0, -1)\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      //solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val fld = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            solve(0, 0, Nil, fld, Nil).foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n        }\n    }\n\n    def beam(y: Int, x: Int, fld: List[Int]): List[Int] = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foldLeft(fld)((acc, p) => flip(acc, p._1, p._2) )\n    }\n\n    def flip(fld: List[Int], y: Int, x: Int): List[Int] = {\n        val bits = fld(y) ^ (1 << x)\n        (0 to 9).toList.map((i) => if(i == y) bits else fld(i))\n    }\n\n    def holizontal(y: Int, x: Int, bits: Int, acc: Int, fld: List[Int]): (Int, List[Int]) = {\n        if(x == 10) (acc, fld)\n        else {\n            if((bits & (1 << x)) != 0) holizontal(y, x + 1, bits, acc + (1 << x), beam(y, x, fld))\n            else holizontal(y, x + 1, bits, acc, fld)\n        }\n    }\n\n    def solve(bits: Int, y: Int, ans: List[Int], fld: List[Int], nfld: List[Int]): List[Int] = {\n        if(y == 0) {\n            val ret = holizontal(0, 0, bits, 0, fld)\n            solve(bits, y + 1, List(ret._1), fld, ret._2)\n        }\n        else if(bits == 1024) {\n            println(\"no ans\")\n            ans\n        }\n        else if(y == 10) if(nfld(9) == 0) ans else solve(bits + 1, 0, Nil, fld, nfld)\n        else {\n            val ret = holizontal(y, 0, nfld(y-1), 0, nfld)\n            solve(bits, y + 1, ans ::: List(ret._1), fld, ret._2)\n        }\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      val dx = Seq(0, -1, 0, 1, 0)\n      val dy = Seq(0, 0, 1, 0, -1)\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    for(i <- 0 until (1<<10)) {\n      if(test(i)) {\n        return c\n      }\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def change(a: Array[Array[Int]], x: Int, y: Int) {\n    val dx = Seq(0, -1, 0, 1, 0)\n    val dy = Seq(0, 0, 1, 0, -1)\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def solve(a: Array[Array[Int]]): Option[Array[Array[Int]]] = {\n    val test = (n: Int) => {\n      val b = a.map(_.clone)\n      val c = Array.ofDim[Int](10,10)\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      if (b.map(_.sum).sum == 0) {\n        Some(c)\n      } else {\n        None\n      }\n    }\n    for(i <- 0 until (1<<10)) {\n      test(i) match {\n        case Some(c) => return Some(c)\n        case _ => \n      }\n      System.gc()\n    }\n    return None\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).get.foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def change(a: Array[Array[Int]], x: Int, y: Int) {\n    val dx = Seq(0, -1, 0, 1, 0)\n    val dy = Seq(0, 0, 1, 0, -1)\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def solve(a: Array[Array[Int]]): Option[Array[Array[Int]]] = {\n    val test = (n: Int) => {\n      val b = a.map(_.clone)\n      val c = Array.ofDim[Int](10,10)\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      if (b.map(_.sum).sum == 0) {\n        Some(c)\n      } else {\n        None\n      }\n    }\n    for(i <- 0 until (1<<10)) {\n      test(i) match {\n        case Some(c) => return Some(c)\n        case _ => \n      }\n    }\n    return None\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).get.foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      val dx = Seq(0, -1, 0, 1, 0)\n      val dy = Seq(0, 0, 1, 0, -1)\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to 5) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      val dx = Seq(0, -1, 0, 1, 0)\n      val dy = Seq(0, 0, 1, 0, -1)\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a)\n      //solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  val dx = Seq(0, -1, 0, 1, 0)\n  val dy = Seq(0, 0, 1, 0, -1)\n  val b = Array.ofDim[Int](10, 10)\n  val c = Array.ofDim[Int](10, 10)\n  val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def test (a: Array[Array[Int]], n: Int) = {\n    for(i <- 0 until 10; j <- 0 until 10) {\n      b(i)(j) = a(i)(j)\n      c(i)(j) = 0\n    }\n    for(i <- 0 until 10) {\n      if((n & (1 << i)) != 0) {\n        change(b, 0, i)\n        c(0)(i) = 1\n      }\n    }\n    for(i <- 1 until 10) {\n      for(j <- 0 until 10) {\n        if(b(i-1)(j) == 1) {\n          change(b, i, j)\n          c(i)(j) = 1\n        }\n      }\n    }\n    b.map(_.sum).sum == 0\n  }\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(a, i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n  import scala.io.StdIn.{readLine}\n  for (testCase← 0 until readLine().toInt){\n    val field = Field()\n    for (y ← 0 until 10){\n      readLine().split(' ').map(_.toInt).zipWithIndex.foreach{\n        case (0, x) ⇒ field(x, y) = Off\n        case (1, x) ⇒ field(x, y) = On\n      }\n    }\n    val raw = Field()\n    (0 until 1024).flatMap(canResetField(field, _)).flatten.flatten.foreach(c ⇒ raw(c) = On)\n    print((0 until 10).map(y ⇒ (0 until 10).map(x ⇒ raw(x, y) match {case Off ⇒ 0 case On ⇒ 1}).mkString(\"\",\" \",\"\\n\")).mkString)\n  }\n  case class Coordinate(x:Int, y:Int){\n    def +(that:Coordinate):Coordinate = Coordinate(x + that.x, y + that.y)\n  }\n  def BeamLine(initial:Int):Iterable[Coordinate] = (0 until 10).filter{x ⇒ ((1 << x) & initial) != 0}.map{Coordinate(_, 0)}\n  sealed trait Lamp{\n    def switch:Lamp\n  }\n  object On extends Lamp{\n    override def switch:Lamp = Off\n  }\n  object Off extends Lamp{\n    override def switch:Lamp = On\n  }\n  object Field{\n    def apply():Field = new Field()\n    private val relationalEffectArea:Iterable[Coordinate] = Coordinate(0, -1)::Coordinate(-1, 0)::Coordinate(0, 0)::Coordinate(1, 0)::Coordinate(0, 1)::Nil\n  }\n  class Field{\n    private val mArray:Array[Array[Lamp]]= Array.tabulate(10){_ ⇒ Array.tabulate(10){_ ⇒ Off}}\n    def apply(x:Int, y:Int):Lamp = mArray(x)(y)\n    def apply(coordinate: Coordinate):Lamp = mArray(coordinate.x)(coordinate.y)\n    def update(x:Int, y:Int, value:Lamp):Unit = mArray(x)(y) = value\n    def update(coordinate: Coordinate, value:Lamp):Unit = mArray(coordinate.x)(coordinate.y) = value\n    def shootBeam(beam:Coordinate):Unit = Field.relationalEffectArea.map{_ + beam}.filter{case Coordinate(x, y) ⇒ (0 until 10).contains(x) && (0 until 10).contains(y)}.foreach{case Coordinate(x, y) ⇒ mArray(x)(y) = mArray(x)(y).switch}\n  }\n  def canResetField(field: Field, initial:Int):Option[Iterable[Iterable[Coordinate]]] = {\n    var res:List[Iterable[Coordinate]] = BeamLine(initial)::Nil\n    res.foreach{_.foreach{field.shootBeam(_)}}\n    for (y ← 1 until 10){\n      val l = (0 until 10).filter{field(_, y - 1) == On}.map{Coordinate(_, y)}\n      l.foreach{field.shootBeam(_)}\n      res = l::res\n    }\n    (0 until 10).forall{field(_, 9) == Off} match{\n      case true ⇒ {\n        res.foreach(_.foreach(c ⇒ field.shootBeam(c)))\n        Some(res)\n      }\n      case false ⇒ {\n        res.foreach(_.foreach(c ⇒ field.shootBeam(c)))\n        None\n      }\n    }\n  }\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "class Field (var value: List[Int]) {\n    def get: List[Int] = {\n        this.value\n    }\n    def update(y: Int, x: Int): Unit = {\n        val bits = this.value(y) ^ (1 << x)\n        this.value = (0 to 9).toList.map(i => if(i == y) bits else this.value(i))\n    }\n    def init(fld:List[Int]): Unit = {\n        this.value = fld\n    }\n}\nobject Main {\n    var fld = new Field(List(1))\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val orig = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            fld = new Field(orig)\n            var i = 0\n            var flag = true\n            var ans = List(1)\n            while(flag) {\n                fld.init(orig)\n                ans = total_flip(i, 0, Nil)\n                if(fld.get(9) == 0) {\n                    ans.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n                    flag = false\n                }\n                else i += 1\n            }\n        }\n    }\n    def beam(y: Int, x: Int): Unit = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foreach(p => fld.update(p._1, p._2))\n    }\n\n    def row_flip(y: Int, x: Int, bits: Int, acc: Int): Int = {\n        if(x == 10) acc\n        else {\n            if((bits & (1 << x)) != 0) {\n                beam(y, x)\n                row_flip(y, x + 1, bits, acc + (1 << x))\n            }\n            else row_flip(y, x + 1, bits, acc)\n        }\n    }\n\n    def total_flip(bits: Int, y: Int, ans: List[Int]): List[Int] = {\n        if(y == 10) ans\n        else if(y == 0) total_flip(bits, y + 1, List(row_flip(0, 0, bits, 0)))\n        else total_flip(bits, y + 1, ans ::: List(row_flip(y, 0, fld.get(y-1), 0)))\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n      val dx = Seq(0, -1, 0, 1, 0)\n      val dy = Seq(0, 0, 1, 0, -1)\n      for {\n        d <- dx.zip(dy)\n        xi = x + d._1\n        yi = y + d._2\n        if 0 <= xi\n        if xi < 10\n        if 0 <= yi\n        if yi < 10\n      } {\n        a(xi)(yi) = (a(xi)(yi)+1)%2\n      }\n    }\n    val b = Array.ofDim[Int](10, 10)\n    val c = Array.ofDim[Int](10, 10)\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    sc.nextLine()\n    for(_ <- 1 to n) {\n      val a = (for(_ <- 1 to 10) yield sc.nextLine().split(\" \").map(_.toInt).toArray).toArray\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "class Field (var value: List[Int]) {\n    def get: List[Int] = {\n        this.value\n    }\n    def update(y: Int, x: Int): Unit = {\n        val bits = this.value(y) ^ (1 << x)\n        this.value = (0 to 9).toList.map(i => if(i == y) bits else this.value(i))\n    }\n}\nobject Main {\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val orig = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            loop(0, false, orig, Nil)\n        }\n    }\n    def beam(y: Int, x: Int, fld: Field): Field = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foreach(p => fld.update(p._1, p._2))\n        fld\n    }\n\n    def row_flip(y: Int, x: Int, bits: Int, acc: Int, fld: Field): Int = {\n        if(x == 10) acc\n        else {\n            if((bits & (1 << x)) != 0) row_flip(y, x + 1, bits, acc + (1 << x), beam(y, x, fld))\n            else row_flip(y, x + 1, bits, acc, fld)\n        }\n    }\n\n    def total_flip(bits: Int, y: Int, ans: List[Int], fld: Field): List[Int] = {\n        if(y == 10) ans\n        else if(y == 0) total_flip(bits, y + 1, List(row_flip(0, 0, bits, 0, fld)), fld)\n        else total_flip(bits, y + 1, ans ::: List(row_flip(y, 0, fld.get(y-1), 0, fld)), fld)\n    }\n\n    def loop(bits: Int, flag: Boolean, orig: List[Int], ret: List[Int]): Unit = {\n        if(flag) ret.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n        else {\n            val fld = new Field(orig)\n            val ret = total_flip(bits, 0, Nil, fld)\n            if(fld.get(9) == 0) loop(bits + 1, true, Nil, ret)\n            else loop(bits + 1, false, orig, Nil)\n        }\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  val dx = Seq(0, -1, 0, 1, 0)\n  val dy = Seq(0, 0, 1, 0, -1)\n  val b = Array.ofDim[Int](10, 10)\n  val c = Array.ofDim[Int](10, 10)\n  val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n    for {\n      d <- dx.zip(dy)\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    val test = (n: Int) => {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        b(i)(j) = a(i)(j)\n        c(i)(j) = 0\n      }\n      for(i <- 0 until 10) {\n        if((n & (1 << i)) != 0) {\n          change(b, 0, i)\n          c(0)(i) = 1\n        }\n      }\n      for(i <- 1 until 10) {\n        for(j <- 0 until 10) {\n          if(b(i-1)(j) == 1) {\n            change(b, i, j)\n            c(i)(j) = 1\n          }\n        }\n      }\n      b.map(_.sum).sum == 0\n    }\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val fld = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            for(bits <- 0 to (1 << 10) - 1) {\n                val list = solve(bits, 0, Nil, fld)\n                if(list.size != 0) list.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n            }\n        }\n    }\n\n    def beam(y: Int, x: Int, fld: List[Int]): List[Int] = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foldLeft(fld)((acc, p) => flip(acc, p._1, p._2) )\n    }\n\n    def flip(fld: List[Int], y: Int, x: Int): List[Int] = {\n        val bits = fld(y) ^ (1 << x)\n        (0 to 9).toList.map((i) => if(i == y) bits else fld(i))\n    }\n\n    def to_zero_all_one_line(y: Int, x: Int, bits: Int, acc: Int, fld: List[Int]): (Int, List[Int]) = {\n        if(x == 10) (acc, fld)\n        else {\n            if((bits & (1 << x)) != 0) to_zero_all_one_line(y, x + 1, bits, acc + (1 << x), beam(y, x, fld))\n            else to_zero_all_one_line(y, x + 1, bits, acc, fld)\n        }\n    }\n\n    def solve(bits: Int, y: Int, ans: List[Int], fld: List[Int]): List[Int] = {\n        if(y == 0) {\n            val ret = to_zero_all_one_line(0, 0, bits, 0, fld)\n            solve(bits, y + 1, List(ret._1), ret._2)\n        }\n        else if(y == 10) if(fld(9) == 0) ans else List()\n        else {\n            val ret = to_zero_all_one_line(y, 0, fld(y-1), 0, fld)\n            solve(bits, y + 1, ans ::: List(ret._1), ret._2)\n        }\n    }\n}"
  },
  {
    "language": "Scala",
    "code": "import scala.math._\n\nobject Main {\n  val sc = new java.util.Scanner(System.in)\n  val dx = Seq(0, -1, 0, 1, 0)\n  val dy = Seq(0, 0, 1, 0, -1)\n  val dxy = dx.zip(dy)\n  val b = Array.ofDim[Int](10, 10)\n  val c = Array.ofDim[Int](10, 10)\n  val change = (a: Array[Array[Int]], x: Int, y: Int) => {\n    for {\n      d <- dxy\n      xi = x + d._1\n      yi = y + d._2\n      if 0 <= xi\n      if xi < 10\n      if 0 <= yi\n      if yi < 10\n    } {\n      a(xi)(yi) = (a(xi)(yi)+1)%2\n    }\n  }\n  def test (a: Array[Array[Int]], n: Int) = {\n    for(i <- 0 until 10; j <- 0 until 10) {\n      b(i)(j) = a(i)(j)\n      c(i)(j) = 0\n    }\n    for(i <- 0 until 10) {\n      if((n & (1 << i)) != 0) {\n        change(b, 0, i)\n        c(0)(i) = 1\n      }\n    }\n    for(i <- 1 until 10) {\n      for(j <- 0 until 10) {\n        if(b(i-1)(j) == 1) {\n          change(b, i, j)\n          c(i)(j) = 1\n        }\n      }\n    }\n    b.forall(_.forall(_ == 0))\n  }\n  def solve(a: Array[Array[Int]]): Array[Array[Int]] = {\n    var i = 0\n    while(i < (1 << 10)) {\n      if(test(a, i)) {\n        return c\n      }\n      i += 1\n    }\n    return c\n  }\n  def main(args: Array[String]) {\n    val n = sc.nextInt()\n    val a = Array.ofDim[Int](10, 10)\n    for(_ <- 1 to n) {\n      for(i <- 0 until 10; j <- 0 until 10) {\n        a(i)(j) = sc.nextInt\n      }\n      solve(a).foreach(s => println(s.mkString(\" \")))\n    }\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main {\n    def main(args:Array[String]) = {\n        val sc = new java.util.Scanner(System.in)\n        val n = sc.nextInt\n        sc.nextLine\n        for(i <- 1 to n) {\n            val fld = (1 to 10).toList.map(_ => Integer.parseInt(sc.nextLine.split(\" \").mkString(\"\").reverse, 2))\n            for(bits <- 0 to (1 << 10) - 1) {\n                val list = solve(bits, 0, Nil, fld, Nil)\n                if(list.size != 0) list.foreach(bits => println(Integer.toBinaryString(bits).reverse.padTo(10, '0').split(\"\").mkString(\" \")))\n            }\n        }\n    }\n\n    def beam(y: Int, x: Int, fld: List[Int]): List[Int] = {\n        val dir = List((y, x), (y - 1, x), (y, x - 1), (y + 1, x), (y, x + 1)).filter(p => 0 <= p._1 && p._1 < 10 && 0 <= p._2 && p._2 < 10)\n        dir.foldLeft(fld)((acc, p) => flip(acc, p._1, p._2) )\n    }\n\n    def flip(fld: List[Int], y: Int, x: Int): List[Int] = {\n        val bits = fld(y) ^ (1 << x)\n        (0 to 9).toList.map((i) => if(i == y) bits else fld(i))\n    }\n\n    def holizontal(y: Int, x: Int, bits: Int, acc: Int, fld: List[Int]): (Int, List[Int]) = {\n        if(x == 10) (acc, fld)\n        else {\n            if((bits & (1 << x)) != 0) holizontal(y, x + 1, bits, acc + (1 << x), beam(y, x, fld))\n            else holizontal(y, x + 1, bits, acc, fld)\n        }\n    }\n\n    def solve(bits: Int, y: Int, ans: List[Int], fld: List[Int], nfld: List[Int]): List[Int] = {\n        if(y == 0) {\n            val ret = holizontal(0, 0, bits, 0, fld)\n            solve(bits, y + 1, List(ret._1), fld, ret._2)\n        }\n        else if(y == 10) if(nfld(9) == 0) ans else List()\n        else {\n            val ret = holizontal(y, 0, nfld(y-1), 0, nfld)\n            solve(bits, y + 1, ans ::: List(ret._1), fld, ret._2)\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\n\ntypedef long long ll;\nconst double Eps = 1e-5;\n\nusing namespace std;\n\nint state[10][10];\nint fired[10][10];\n\nvoid fire(int x, int y)\n{\n\tint dx[] = { 0, 0, 1, 0, -1 };\n\tint dy[] = { 0, -1, 0, 1, 0 };\n\tfor (int i = 0; i < 5; ++i)\n\t{\n\t\tint tx = x + dx[i];\n\t\tint ty = y + dy[i];\n\t\tif (0 <= tx && tx < 10\n\t\t\t&& 0 <= ty && ty < 10)\n\t\t{\n\t\t\tstate[ty][tx] = state[ty][tx] ? 0 : 1;\n\t\t}\n\t}\n\tfired[y][x] = 1;\n}\nbool is_alloff()\n{\n\tfor (int i = 0; i < 10; ++i)\n\t\tfor (int j = 0; j < 10; ++j)\n\t\t\tif (state[i][j])\n\t\t\t\treturn false;\n\treturn true;\n}\nvoid print_state(int s[10][10])\n{\n\tfor (int i = 0; i < 10; ++i)\n\t{\n\t\tfor (int j = 0; j < 9; ++j)\n\t\t\tprintf(\"%d \", s[i][j]);\n\t\tprintf(\"%d\\n\", s[i][9]);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--)\n\t{\n\t\tint defState[10][10];\n\t\tfor (int i = 0; i < 10; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 10; ++j)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\", &t);\n\t\t\t\tdefState[i][j] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int subset = 0; subset < 1 << 10; ++subset)\n\t\t{\n\t\t\tmemcpy(state, defState, sizeof(state));\n\t\t\tmemset(fired, 0, sizeof(fired));\n\n\t\t\tfor (int i = 0; i < 10; ++i)\n\t\t\t\tif (subset & 1 << i)\n\t\t\t\t\tfire(i, 0);\n\n\t\t\tfor (int i = 1; i < 10; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < 10; ++j)\n\t\t\t\t{\n\t\t\t\t\tif (state[i-1][j])\n\t\t\t\t\t\tfire(j, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (is_alloff())\n\t\t\t\tbreak;\n\t\t}\n\t\tprint_state(fired);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\t//cout << \"y:\" << y << \" x:\" << x << endl;\n\tif(f[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tf[ny][nx] = 0;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int y,int x)\n{\n\t//cout << \"y:\" << y << \" x:\" << x << endl;\n\tans.clear();\n\tREP(i,1,9)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(f[i][j] == 1) cnt++;\n\t\t}\n\t}\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nbool mem[12][12],cop[12][12],done[12][12];\n\nint main(){\n  int n;cin>>n;\n  while(n--){\n    lol(i,10)lol(j,10)cin>>mem[i][j];\n    bool flag[10]={0};\n    for(int p=1;p<=1024;p++){\n      lol(i,10)lol(j,10)cop[i][j]=mem[i][j];\n      for(int k=0;k<10;k++){\n\tlol(i,10){\n\t  if(!flag[i])continue;\n\t  for(int j=max(0,i-1);j<=min(9,i+1);j++)cop[k][j]^=1;\n\t  cop[k+1][i]^=1;\n\t}\n\tlol(i,10)done[k][i]=flag[i];\n\tlol(i,10)flag[i]=cop[k][i];\n      }\n      bool na=false;\n      lol(i,10)na&=flag[i];\n      if(!na){\n\tcout<<endl;\n\tlol(i,10){\n\t  lol(j,10)cout<<done[i][j]<<\" \";\n\t  cout<<endl;\n\t}\n\tbreak;\n      }\n      for(int i=0;i<10;i++){\n\tint r=pow(2,i);\n\tif(p%r==0)flag[i]^=1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint mp[10][10],b[10][10];\n\nvoid mark(int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nvoid copy(int a[10][10],int b[10][10]){\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)a[i][j]=b[i][j];\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n    copy(b,mp);\n    int ans[10][10]={};\n    for(int i=0;!check();i++){\n      copy(mp,b),copy(b,mp);\n      for(int j=0;j<10;j++)if((ans[0][j]=(i>>j)%2))mark(0,j);\n      \n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(i=0;i<n;++i)\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n\nbool inside(int x,int y)\n{\n\treturn(0<=x&&x<10 && 0<=y&&y<10);\n}\n\nint main()\n{\n\tint i,j,k;\n\tint dx[5]={1,-1,0,0,0};\n\tint dy[5]={0,0,0,-1,1};\n\n\tint C;\n\tcin >>C;\n\tfor(int cases=0;cases<C;++cases)\n\t{\n\t\tint f[10][10]={0};\n\t\trep(i,10)rep(j,10) scanf(\" %d\",&f[i][j]);\n\n\t\tint ans[10][10]={0};\n\n\t\t//1???????????????????????????????±????\n\t\tint mask;\n\t\tfor(mask=0; mask<(1<<10); ++mask)\n\t\t{\n\t\t\t//???????????§?°??????????????¨????\n\t\t\tint ta[10][10]={0};\n\t\t\t//?????£???????????¶???\n\t\t\tint t[10][10]={0};\n\t\t\trep(i,10)rep(j,10) t[i][j]=f[i][j];\n\t\t\t//1??????????????¢\n\t\t\trep(i,10)\n\t\t\t{\n\t\t\t\tif(mask>>i&1)\n\t\t\t\t{//?????¢?????????\n\t\t\t\t\tta[0][i]=1;\n\t\t\t\t\trep(j,5)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx=i+dx[j];\n\t\t\t\t\t\tint ny=0+dy[j];\n\t\t\t\t\t\tif(inside(nx,ny)) t[ny][nx]=!t[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(i=0;i<10-1;++i)\n\t\t\t{//i???????????¨???\n\t\t\t\trep(j,10)\n\t\t\t\t{\n\t\t\t\t\tif(t[i][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tta[i+1][j]=1;\n\t\t\t\t\t\trep(k,5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tint ny=i+1+dy[k];\n\t\t\t\t\t\t\tif(inside(nx,ny)) t[ny][nx]=!t[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool valid=true;\n\t\t\trep(i,10)rep(j,10) valid&=(t[i][j]==0);\n\n\t\t\tif(valid)\n\t\t\t{\n\t\t\t\trep(i,10)rep(j,10) ans[i][j]=ta[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//output\n\t\trep(i,10)\n\t\t{\n\t\t\trep(j,10)\n\t\t\t{\n\t\t\t\tif(j) printf(\" \");\n\t\t\t\tprintf(\"%d\",ans[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int state[10][10];\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        int ans[10][10] = {0};\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) {\n                    state[i][j]     = 1 - state[i][j];\n                    state[i+1][j-1] = 1 - state[i+1][j-1];\n                    state[i+1][j]   = 1 - state[i+1][j];\n                    state[i+1][j+1] = 1 - state[i+1][j+1];\n                    state[i+2][j]   = 1 - state[i+2][j];\n                    ans[i+1][j] = 1;\n                }\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint souchi[11][11];\nint xx[]={1,-1,0,0,0};\nint yy[]={0,0,1,-1,0};\n\nvoid f(int a,int b){\n\tint i;\n\tfor(i=0;i<5;i++){\n\t\tif(a+xx[i]<0||10<=a+xx[i]||b+yy[i]<0||10<=b+yy[i])continue;\n\t\tsouchi[a+xx[i]][b+yy[i]]^=1;\n\t}\n}\n\nint main() {\n\tint n=in();\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tint a,b;\n\t\tint tmp[11][11];\n\t\tint res[11][11];\n\t\tfor(a=0;a<10;a++){\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tcin>>tmp[a][b];\n\t\t\t}\n\t\t}\n\t\tint bit;\n\t\tfor(bit=0;bit<1<<10;bit++){\n\t\t\tfor(a=0;a<10;a++){\n\t\t\t\tfor(b=0;b<10;b++){\n\t\t\t\t\tsouchi[a][b]=tmp[a][b];\n\t\t\t\t\tres[a][b]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tif(bit>>b&1){\n\t\t\t\t\tf(0,b);\n\t\t\t\t\tres[0][b]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(a=0;a<9;a++){\n\t\t\t\tfor(b=0;b<10;b++){\n\t\t\t\t\tif(souchi[a][b]){\n\t\t\t\t\t\tf(a+1,b);\n\t\t\t\t\t\tres[a+1][b]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=true;\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tif(souchi[9][b])ok=false;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tfor(a=0;a<10;a++){\n\t\t\t\t\tfor(b=0;b<10;b++){\n\t\t\t\t\t\tcout<<res[a][b];\n\t\t\t\t\t\tif(b!=9)cout<<\" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class U>\nvector<T> make_v(U size, const T& init){ return vector<T>(static_cast<size_t>(size), init); }\n\ntemplate<class... Ts, class U>\nauto make_v(U size, Ts... rest) { return vector<decltype(make_v(rest...))>(static_cast<size_t>(size), make_v(rest...)); }\n\ntemplate<class T> void chmin(T &a, const T &b){ a = (a < b ? a : b); }\ntemplate<class T> void chmax(T &a, const T &b){ a = (a > b ? a : b); }\n\nvoid solve() {\n    auto v = make_v(10, 10, 0);\n    auto ans = v;\n    for (int i = 0; i < 10; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            cin >> v[i][j];\n        }\n    }\n    auto s = v;\n    auto flip = [&](int y, int x)  {\n        ans[y][x] ^= 1; v[y][x] ^= 1;\n        if(y) v[y-1][x] ^= 1;\n        if(x) v[y][x-1] ^= 1;\n        if(y != 9) v[y+1][x] ^= 1;\n        if(x != 9) v[y][x+1] ^= 1;\n    };\n    for (int i = 0; i < (1 << 10); ++i) {\n        for (int j = 0; j < 10; ++j) {\n            for (int k = 0; k < 10; ++k) {\n                ans[j][k] = 0;\n            }\n        }\n        v = s;\n        for (int j = 0; j < 10; ++j) {\n            if(i & (1 << j)) flip(0, j);\n        }\n        for (int j = 1; j < 10; ++j) {\n            for (int k = 0; k < 10; ++k) {\n                if(v[j-1][k]) flip(j, k);\n            }\n        }\n        int ok = 1;\n        for (int j = 0; j < 10; ++j) {\n            if(v[9][j]) ok = 0;\n        }\n        if(ok){\n            for (int j = 0; j < 10; ++j) {\n                for (int k = 0; k < 10; ++k) {\n                    printf(k ? \" %d\" : \"%d\", ans[j][k]);\n                }\n                puts(\"\");\n            }\n            return;\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while(n--) {\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint I,flg;\nint t[10][10],u[10][10];\nint ans[10][10];\nvoid check();\nvoid dfs(int);\nvoid compute(int,int);\nint main(){\n  cin>>I;\n  while(I--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tu[i][j]=t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\n\n\nvoid dfs(int x){\n  if(flg)return;\n  if(x==10)check();\n  ans[0][x]=0;\n  dfs(x+1);\n  ans[0][x]=1;\n  dfs(x+1);\n}\n\n\nvoid check(){\n  if(flg)return;\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)t[i][j]=u[i][j];\n  for(int i=0;i<10;i++)if(ans[0][i])compute(0,i);\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(t[i-1][j]==1){\n\tans[i][j]=1;\n\tcompute(i,j);\n      }\n    }\n  }\n  int cnt=0;\n  for(int i=0;i<10;i++)cnt+=t[9][i];\n  if(cnt==0){\n    flg=1;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j)cout<<' ';\n\tcout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}\n\nvoid compute(int y,int x){\n  t[y][x]=!t[y][x];\n  if(y>0)t[y-1][x]=!t[y-1][x];\n  if(x>0)t[y][x-1]=!t[y][x-1];\n  if(y<9)t[y+1][x]=!t[y+1][x];\n  if(x<9)t[y][x+1]=!t[y][x+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(y==1){\n\t\tnow[x][y]=0;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(1,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(1,y+1);\n\t\tflip(x,y);\n\t\t\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(1,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tnow[x][y]=0;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(1,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,-1,sizeof(res));\n\t\tcheck(1,1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 1;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintAns() const\n\t{\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tDetermineShootingPoints( M );\n\n\t\tM.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        \n        bool box[12][12]={0};\n        \n        for(int i=1; i<=10; i++){\n            for(int j=1; j<=10; j++){\n                cin>>box[i][j];\n            }\n        }\n        //cout<<\"----------------------\"<<endl;\n        \n        bool box2[12][12]={0};\n\n        for(int i=0; i<(1<<10 - 1); i++){\n            memcpy(box2, box, sizeof(box));\n            int l[12][12]={0};\n            for(int j=1; j<=10; j++){\n                l[0][j]= (i>>j)%2;\n            }\n            \n            for(int j=1; j<=10; j++){\n                for(int k=1; k<=10; k++){\n                    if(l[j-1][k]==1){\n                        box2[j][k]=(box2[j][k]+1)%2;\n                        box2[j][k+1]=(box2[j][k+1]+1)%2;\n                        box2[j][k-1]=(box2[j][k-1]+1)%2;\n                        box2[j-1][k]=(box2[j-1][k]+1)%2;\n                        box2[j+1][k]=(box2[j+1][k]+1)%2;\n                    }\n                }\n                \n                for(int k=1; k<=10; k++){\n                    l[j][k]=box2[j][k];\n                }\n            }\n            \n            bool end_flag=true;\n            for(int i=1; i<=10; i++){\n                if(l[10][i]==1){\n                    end_flag=false;\n                    break;\n                }\n            }\n            \n            \n            if(end_flag){\n                for(int i=0; i<=9; i++){\n                    for(int j=1; j<=10; j++){\n                        cout<<l[i][j];\n                        if(j==10)break;\n                        cout<<\" \";\n                    }\n                    cout<<endl;\n                }\n                break;\n            }\n        }\n        //cout<<\"============================\"<<endl;\n\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++)\n    if( 0<=y+dy[k] && 0<=x+dx[k] && y+dy[k]<10 && x+dx[k]<10)\n      b[y+dy[k]][x+dx[k]]=b[y+dy[k]][x+dx[k]]?0:1;\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++)\n    if(p[i])rev(i,0);\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n\telse cout << endl;\n      }\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nbool orig[10][10];\nbool work[10][10];\nbool ans[10][10];\n\n\nint dx[5] = {-1,0,0,0,1};\nint dy[5] = {0,-1,0,1,0};\n\nbool debug = false;\n\nvoid flip(int x, int y){\n\tfor(int i=0;i<5;i++){\n\t\tif(0 <= x+dx[i] && x+dx[i] <10 &&\n\t\t0 <= y+dy[i] && y+dy[i] < 10){\n\t\t\twork[x+dx[i]][y+dy[i]] = 1 - work[x+dx[i]][y+dy[i]];\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(void){\n\tint n;\n\tint tmp;\n\tbool isfirst = true;\n\tstring str;\n\t\n\tcin >> n;\n\tcin.ignore();\n\t\n\tfor(int cas=0;cas<n;cas++){\n\t\tmemset(orig, false, sizeof(orig));\n\t\t\n\t\tif(!isfirst) cout << endl;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tgetline(cin,str);\n\t\t\tistringstream iss(str);\n\t\t\tif(debug) cout << i << \" \" << str << endl;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tiss >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\torig[i][j] = false;\n\t\t\t\t}else{\n\t\t\t\t\torig[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i < 1 << 10; i++){\n\t\t\tif(debug) cout << i <<endl;\n\t\t\t\n\t\t\tcopy(orig, orig+10*10, work);\n\t\t\t//1sÚÉÎ·é\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif(i & 1 << j){\n\t\t\t\t\tflip(0,j);\n\t\t\t\t\tans[0][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\tans[0][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(work[j-1][k]){\n\t\t\t\t\t\tflip(j,k);\n\t\t\t\t\t\tans[j][k] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans[j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//check ended or not\n\t\t\tbool isended = true;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(work[j][k]){ isended = false;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isended){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\t\tif(k==9){\n\t\t\t\t\t\t\tcout << ans[j][k] << endl;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcout << ans[j][k] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tisfirst = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct P{int x,y,z;};\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++)\n    if( 0<=y+dy[k] && 0<=x+dx[k] && y+dy[k]<10 && x+dx[k]<10)\n      b[y+dy[k]][x+dx[k]]=b[y+dy[k]][x+dx[k]]?0:1;\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++)\n    if(p[i])rev(i,0);\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n\telse cout << endl;\n      }\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    p[cnt]=0;\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\nint field[12][12];\nint afield[12][12];\n\nvoid search(int y,int x) {\n  int sum = 0;\n  if(field[y][x] == 1) sum++;\n  for(int i=0;i<4;i++) {\n    if(field[y+dy[i]][x+dx[i]] == 1) {\n      sum++;\n    }\n  }\n\n  if(sum >= 3) {\n    afield[y][x] = 1;\n    if(field[y][x] == 1) field[y][x] = 0;\n    else field[y][x] = 1;\n    for(int i=0;i<4;i++) {\n      if(field[y+dy[i]][x+dx[i]] == 1) {\n\tfield[y+dy[i]][x+dx[i]] = 0;\n      }\n      else if(field[y+dy[i]][x+dx[i]] == 0) {\n\tfield[y+dy[i]][x+dx[i]] = 1;\n      }\n    }\n  }\n  return;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for(int i=0;i<n;i++) {\n\n    for(int j=0;j<12;j++) { //init field\n      for(int k=0;k<12;k++) {\n\tfield[j][k] = 0;\n\tafield[j][k] = 0;\n      }\n    }\n\n    for(int j=0;j<10;j++) { //input field\n      for(int k=0;k<10;k++) {\n\tcin >> field[j+1][k+1];\n      }\n    }\n\n    for(int j=0;j<10;j++) {\n      for(int k=0;k<10;k++) {\n\tsearch(j+1,k+1);\n      }\n    }\n\n    for(int j=0;j<10;j++) {\n      for(int k=0;k<10;k++) {\n\tif(k != 0) cout << \" \";\n\tcout << afield[j+1][k+1];\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint S3[1024];\n\trep(S,1024){\n\t\tint stat=0;\n\t\trep(j,10) if(S&(1<<j)) {\n\t\t\tstat^=1<<j;\n\t\t\tif(j>0) stat^=1<<(j-1);\n\t\t\tif(j<9) stat^=1<<(j+1);\n\t\t}\n\t\tS3[S]=stat;\n\t}\n\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint org[10]={};\n\t\trep(i,10) rep(j,10) {\n\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\torg[i]|=tmp<<j;\n\t\t}\n\n\t\tint ans;\n\t\trep(S,1024){\n\t\t\tint grid[10];\n\t\t\trep(i,10) grid[i]=org[i];\n\n\t\t\tgrid[0]^=S3[S];\n\t\t\tgrid[1]^=S;\n\t\t\tfor(int i=1;i<10;i++){\n\t\t\t\tint pttn=grid[i-1];\n\t\t\t\tgrid[i-1]=0;\n\t\t\t\tgrid[i]^=S3[pttn];\n\t\t\t\tif(i<10) grid[i+1]^=pttn;\n\t\t\t}\n\n\t\t\tif(grid[9]==0){ ans=S; break; }\n\t\t}\n\n\t\trep(j,10) printf(\"%d%c\",!!(ans&(1<<j)),j<9?' ':'\\n');\n\t\torg[0]^=S3[ans];\n\t\torg[1]^=ans;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint pttn=org[i-1];\n\t\t\torg[i-1]=0;\n\t\t\torg[i]^=S3[pttn];\n\t\t\tif(i<10) org[i+1]^=pttn;\n\t\t\trep(j,10) printf(\"%d%c\",!!(pttn&(1<<j)),j<9?' ':'\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n#define debug(x) cout << #x << \" = \" << x << endl;\n#define sq(x) ((x)*(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nconst int MAX_N = 11;\nint v[MAX_N][MAX_N];\n\nint answer[MAX_N][MAX_N];\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\n\nint isOn(int x, int y){\n    int sum = v[y][x];\n    rep(i,5){\n        int nx = x+dx[i], ny = y+dy[i];\n        if(nx < 0 || nx >= 10 || ny < 0 || ny >= 10) continue;\n        sum += answer[ny][nx];\n    }\n    return sum%2;\n}\n\nbool check(int state){\n\tmemset(answer, 0, sizeof(answer));\n    rep(i, 10){\n        answer[0][9-i] = (state>>i)&1;\n    }\n    FOR(i, 1, 10){\n        rep(j, 10){\n           if(isOn(j, i-1)) answer[i][j] = 1;\n        }\n    }\n\n    rep(i, 10){\n        if(isOn(i, 9)) return false;\n    }\n\n    return true;\n}\n\nint main(){\n\tint dataset;\n\tcin >> dataset;\n\twhile(dataset--){\n\t\trep(i, 10) rep(j, 10) cin >> v[i][j];\n        for(int state = 0; state < (1<<10); state++){\n            if(check(state)) break;\n        }\n\n        rep(i, 10){\n            rep(j, 10) cout << (j?\" \":\"\") << answer[i][j];\n            cout << endl;\n        }\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n\nusing namespace std;\n\n\nvector<int> GaussJordanMod2(vector<vector<unsigned int> > a){\n\tint n=a.size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(a[j][i/32]>>(i&31)&1){\n\t\t\t\ta[i].swap(a[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tunsigned int rev=a[i][i/32]&~((1<<(i&31))-1);\t\t\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j||!(a[j][i/32]>>(i&31)&1))continue;\n\t\t\ta[j][i/32] ^= rev;\n\t\t\tfor(int k=i/32+1;k<(n+1+32-1)/32;k++){\n\t\t\t\ta[j][k] ^= a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> res(n);\n\tfor(int i=0;i<n;i++)res[i]=a[i][n/32]>>n%32&1;\n\treturn res;\n}\n\n\nint main(){\n\tint dy[]={0,1,0,-1,0};\n\tint dx[]={0,0,1,0,-1};\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tvector<vector<unsigned int> > a(100,vector<unsigned int>((101+31)/32,0));\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint y=i/10,x=i%10;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tint ny=y+dy[j],nx=x+dx[j];\n\t\t\t\tif(0<=ny&&ny<10&&0<=nx&&nx<10){\n\t\t\t\t\ta[ny*10+nx][i/32] |= 1<<(i&31);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\ta[i][100/32] |= c<<(100&31);\n\t\t}\n\t\tvector<int> ans(GaussJordanMod2(a));\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcout<<ans[i*10];\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tcout<<' '<<ans[i*10+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,1,0,0,0};\nconst int dy[] = {0,0,0,-1,1};\n\nint main() {\n  int Tc; cin >> Tc;\n  \n  while(Tc--) {\n    \n    int arr[10][10];\n    int arr2[10][10];\n    \n    for(int i=0; i<10; i++)\n      for(int j=0; j<10; j++)\n\tcin >> arr[i][j];\n    \n    bool good = 0;\n    for(int I=0; I<(1<<10); I++) {\n      memset(arr2, 0, sizeof(arr2));\n      bool ok = 1;\n      for(int i=0; i<10; i++) {\n\tfor(int j=0; j<10; j++) {\n\t  \n\t  if(i == 0) {\n\t    if((I>>j) & 1) {\n\t      if(arr[0][j] == 0) {\n\t\tarr[0][j] = arr2[0][j] = 1;\n\t      }\n\t    }\n\t  }\n\t  else {\n\t    if(arr[i-1][j] == 1) {\n\t      arr2[i][j] = 1;\n\t      for(int k=0; k<5; k++) {\n\t\tif(i+dy[k]>=0 && i+dy[k]<10 && j+dx[k]>=0 && j+dx[k]<10) {\n\t\t  arr[i+dy[k]][j+dx[k]] = 1 - arr[i+dy[k]][j+dx[k]];\n\t\t}\n\t      }\n\t    }\n\t  }\n\t  \n\t} \n      }\n      \n      for(int i=0; i<10; i++) {\n\tif(arr[9][i]) ok = 0;\n      }\n      if(ok) {\n\tgood = 1;\n\tbreak;\n      }\n    }\n    if(good) {\n      for(int i=0; i<10; i++) {\n\tfor(int j=0; j<10; j++) {\n\t  if(j) cout << \" \";\n\t  cout << arr2[i][j];\n\t}\n\tcout << endl;\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(temp[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(temp[ny][nx] == 1) temp[ny][nx] = 0;\n\t\t\t\telse temp[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int y,int x)\n{\n\trep(i,10) rep(j,10) temp[i][j] = f[i][j];\n\tans.clear();\n\tREP(i,1,9)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(temp[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9 && x == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1001001001;\n\nint N;\nint map[12][12];\n\nint main(){\n    std::cin >> N;\n\n    REP(_, N){\n        FOR(i, 1, 11){\n            FOR(j, 1, 11){\n                std::cin >> map[i][j];\n            }\n        }\n\n        FOR(i, 1, 11){\n            FOR(j, 1, 11){\n                if(map[i-1][j] == 1 && map[i][j-1] == 1){\n                    printf(\"1\");\n                    map[i][j] = !map[i][j];\n                    map[i+1][j] = !map[i+1][j];\n                    map[i][j+1] = !map[i][j+1];\n                }else{\n                    printf(\"0\");\n                }\n                \n                if(j < 10){printf(\" \");}\n                else{puts(\"\");}\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool grid[10][10];\n\nvoid rev(int y,int x){\n  int dy[] = {1,0,-1,0,0}, dx[] = {0,1,0,-1,0};\n\n  for(int i=0;i<5;i++){\n    int sy = y+dy[i], sx = x+dx[i];\n    if(sy<0 || sx<0 || sy>10 || sx>10)continue;\n    grid[sy][sx] = !grid[sy][sx];\n  }\n}\n\nint main(){\n  int t;\n  bool tmp[10][10];\n  bool ans[10][10];\n\n  cin >> t;\n  while(t--){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin >> grid[i][j];\n\ttmp[i][j] = grid[i][j];\n      }\n    }\n\n    for(int i=0;i<(1<<10);i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++)grid[j][k] = tmp[j][k];\n      }\n\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  rev(0,j);\n\t  ans[0][j] = true;\n\t}else ans[0][j] = false;\n      }\n\n      for(int j=1;j<10;j++){\n\tfor(int k=0;k<10;k++){\n\t  if(grid[j-1][k]){\n\t    rev(j,k);\n\t    ans[j][k] = true;\n\t  }else ans[j][k] = false;\n\t}\n      }\n\n      bool f = false;\n      for(int j=0;j<10;j++)f |= grid[9][j];\n      if(!f)break;\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<9;j++)cout << ans[i][j] << \" \";\n      cout << ans[i][9] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint state[10][10];\nint ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = 1 - state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = 1 - ans[y][x];\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        for (int j=0; j<10; ++j) {\n            if ((bt>>j) & 1) {\n                pass(0, j);\n            }\n        }\n        for (int i=1; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i-1][j] == 1) {\n                    pass(i, j);\n                }\n            }\n        }\n        bool ok = true;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) ok = false;\n            }\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        solve();\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i) for(int j = 0; j < MAX; ++j) m[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) &&\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+5)%sz]][j+dj[(k+5)%sz]] == 1 && inRange(i+di[(k+5)%sz]) && inRange(j+dj[(k+5)%sz])) &&\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+6)%sz]][j+dj[(k+6)%sz]] == 1 && inRange(i+di[(k+6)%sz]) && inRange(j+dj[(k+6)%sz])) &&\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+7)%sz]][j+dj[(k+7)%sz]] == 1 && inRange(i+di[(k+7)%sz]) && inRange(j+dj[(k+7)%sz]))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint S3[1024];\n\trep(S,1024){\n\t\tint stat=0;\n\t\trep(j,10) if(S&(1<<j)) {\n\t\t\tstat^=1<<j;\n\t\t\tif(j>0)  stat^=1<<(j-1);\n\t\t\tif(j<10) stat^=1<<(j+1);\n\t\t}\n\t\tS3[S]=stat;\n\t}\n\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint org[10]={};\n\t\trep(i,10) rep(j,10) {\n\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\torg[i]|=tmp<<j;\n\t\t}\n\n\t\tint ans;\n\t\trep(S,1024){\n\t\t\tint grid[10]={};\n\t\t\trep(i,10) grid[i]=org[i];\n\n\t\t\tgrid[0]^=S3[S];\n\t\t\tgrid[1]^=S;\n\t\t\tfor(int i=1;i<10;i++){\n\t\t\t\tint pttn=grid[i-1];\n\t\t\t\tgrid[i-1]=0;\n\t\t\t\tgrid[i]^=S3[pttn];\n\t\t\t\tif(i<10) grid[i+1]^=pttn;\n\t\t\t}\n\n\t\t\tif(grid[9]==0){ ans=S; break; }\n\t\t}\n\n\t\trep(j,10) printf(\"%d%c\",!!(ans&(1<<j)),j<9?' ':'\\n');\n\t\torg[0]^=S3[ans];\n\t\torg[1]^=ans;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint pttn=org[i-1];\n\t\t\torg[i-1]=0;\n\t\t\torg[i]^=S3[pttn];\n\t\t\tif(i<10) org[i+1]^=pttn;\n\t\t\trep(j,10) printf(\"%d%c\",!!(pttn&(1<<j)),j<9?' ':'\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint S3[1024];\n\trep(S,1024){\n\t\tint stat=0;\n\t\trep(j,10) if(S&(1<<j)) {\n\t\t\tstat^=1<<j;\n\t\t\tif(j>0) stat^=1<<(j-1);\n\t\t\tif(j<9) stat^=1<<(j+1);\n\t\t}\n\t\tS3[S]=stat;\n\t}\n\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint org[10]={};\n\t\trep(i,10) rep(j,10) {\n\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\torg[i]|=tmp<<j;\n\t\t}\n\n\t\tint ans=-1;\n\t\trep(S,1024){\n\t\t\tint grid[10];\n\t\t\trep(i,10) grid[i]=org[i];\n\n\t\t\tgrid[0]^=S3[S];\n\t\t\tgrid[1]^=S;\n\t\t\tfor(int i=1;i<10;i++){\n\t\t\t\tint pttn=grid[i-1];\n\t\t\t\tgrid[i-1]=0;\n\t\t\t\tgrid[i]^=S3[pttn];\n\t\t\t\tif(i<9) grid[i+1]^=pttn;\n\t\t\t}\n\n\t\t\tif(grid[9]==0){ ans=S; break; }\n\t\t}\nif(ans==-1)while(1);\n\n\t\trep(j,10) printf(\"%d%c\",!!(ans&(1<<j)),j<9?' ':'\\n');\n\t\torg[0]^=S3[ans];\n\t\torg[1]^=ans;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint pttn=org[i-1];\n\t\t\torg[i-1]=0;\n\t\t\torg[i]^=S3[pttn];\n\t\t\tif(i<10) org[i+1]^=pttn;\n\t\t\trep(j,10) printf(\"%d%c\",!!(pttn&(1<<j)),j<9?' ':'\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\t//if(!fir)cout<<endl;\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp+2-(panel[j]>>k)&1)%2)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check[10];\n\t\t\tfor(int j=0;j<10;j++)check[j]=(panel[9]>>j)&1;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tcheck[j]+=(ans[8]>>j);\n\t\t\t\tif((ans[9]>>j)&1){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint x=j+k;\n\t\t\t\t\t\tif(0<=x&&x<10)check[x]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<10;j++)check[j]=check[j]%2;\n\t\t\tif(check[9]==0){\n\t\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tint tmp=(ans[y]>>x)&1;\n\t\t\t\t\t\tprintf(x==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n \nint board[12][12];\nint used[12];\nint mask[12];\nint all = (1 << 10) - 1;\n \nint makeCurrMask(int curr, int m){\n    for(int i=0;i<10;i++){\n        if((m >> i) & 1){\n            int t = (i == 0) ? (7 >> 1) : (7 << (i - 1));\n            curr ^= t;\n        }\n    }\n    return curr & all;\n}\n\nvoid solve(){\n    memset(mask, 0, sizeof(mask));\n    memset(used, 0, sizeof(used));\n    for(int y=0;y<10;y++){\n        int m = 0;\n        for(int x=0;x<10;x++){\n            m = ((m << 1) + board[y][x]);\n        }\n        mask[y] = m;\n    }\n\n    for(int line=0;line<1<<10;++line){\n        int prev = makeCurrMask(mask[0], line);\n        int curr = mask[1] ^ line;\n\n        used[0] = line;\n\n        for(int y=1;y<9;++y){\n            int doit = prev;\n            int nprev = makeCurrMask(curr, doit);\n            int ncurr = mask[y+1] ^ doit;\n\n            prev = nprev;\n            curr = ncurr;\n\n            used[y] = doit;\n        }\n\n        used[9] = prev;\n\n        if(curr ^ prev){\n            continue;\n        } else {\n            break;\n        }\n    }\n}\n \nvoid output(){\n    for(int y=0;y<10;y++){\n        int m = used[y];\n        for(int x=9;x>=0;x--){\n            if(x != 9)cout << \" \";\n            cout << (((m >> x) & 1) ? 1 : 0);\n        }\n        cout << endl;\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n \n    for(int t=0;t<n;t++){\n        for(int y=0;y<10;y++){\n            for(int x=0;x<10;x++)cin >> board[y][x];\n        }\n        solve();\n        output();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(y==1){\n\t\tnow[x][y]=0;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\tflip(x,y);\n\t\t\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tnow[x][y]=0;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,-1,sizeof(res));\n\t\tcheck(1,1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int p[][12],int q[][12],int x){\n  int i,j;\n  int r[12][12],s[12][12];\n  if(x==11){\n    for(i=2;i<10;i++){\n      for(j=1;j<11;j++){\n\tif(p[j][i]){\n\t  p[j  ][i  ]=(p[j  ][i  ]+1)%2;\n\t  p[j-1][i+1]=(p[j-1][i+1]+1)%2;\n\t  p[j  ][i+1]=(p[j  ][i+1]+1)%2;\n\t  p[j+1][i+1]=(p[j+1][i+1]+1)%2;\n\t  p[j  ][i+2]=(p[j  ][i+2]+1)%2;\n\t  q[j][i+1]=1;\n\t}\n      }\n    }\n    for(i=1;i<11;i++){\n      if(p[i][10])\n\tbreak;\n    }\n    if(i==11){\n      for(i=1;i<11;i++){\n\tfor(j=1;j<10;j++)\n\t  cout<<q[j][i]<<\" \";\n\tcout<<q[i][j]<<endl;\n      }\n      return 1;\n    }\n  }else if(x==10){\n    if(p[x][1]){\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }else{\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      if(f(r,s,x+1))\n\treturn 1;\n    }\n  }else{\n      if(p[x][1]){\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x+1][0]=(r[x+1][0]+1)%2;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x+1][1]=(r[x+1][1]+1)%2;\n      r[x+2][1]=(r[x+2][1]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      s[x+1][1]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }else{\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      if(f(r,s,x+1))\n\treturn 1;\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x+1][0]=(r[x+1][0]+1)%2;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x+1][1]=(r[x+1][1]+1)%2;\n      r[x+2][1]=(r[x+2][1]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      s[x+1][1]=1;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  int i,j,k;\n  int q[12][12],r[12][12],n;\n  int (*p)[12][12];\n  cin>>n;\n  p=new int[n][12][12];\n  for(i=0;i<n;i++)\n    for(j=1;j<11;j++)\n      for(k=1;k<11;k++)\n\tcin>>p[i][k][j];\n  for(i=0;i<n;i++){\n    memcpy(r,&p[i][0][0],sizeof(r));\n    memset(q,0,sizeof(q));\n    f(r,q,1);\n    memcpy(r,&p[i][0][0],sizeof(r));\n    memset(q,0,sizeof(q));\n    r[1][0]=(r[1][0]+1)%2;\n    r[0][1]=(r[0][1]+1)%2;\n    r[1][1]=(r[1][1]+1)%2;\n    r[2][1]=(r[2][1]+1)%2;\n    r[1][2]=(r[1][2]+1)%2;\n    q[1][1]=1;\n    f(r,q,1);\n  }\n  delete [] p;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10];\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)ans[0][j]=(i&(1<<j));\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n    cout <<endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\t//Answer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[5] = { 0, 1, 0, -1, 0 };\nconst int dy[5] = {-1, 0, 1,  0, 0 };\n\nint in[10][10];\nint cnt[10][10];\nint ans[10][10];\n\nint color(int y, int x )\n{\n\tint tmp = in[y][x];\n\trep (k, 5 ){\n\t\tint nx = x + dx[k];\n\t\tint ny = y + dy[k];\n\t\tif (nx < 0 || nx >= 10 || ny < 0 || ny >= 10 ) continue;\n\t\ttmp += cnt[ny][nx];\n\t} // end rep\n\t\n\treturn tmp%2;\n}\n\nint solve()\n{\n\tfor (int i = 1; i < 10; i++ ) rep (j, 10 ) if (color(i-1, j ) ) cnt[i][j] = 1;\n\trep (i, 10 ) if (color(9, i ) ) return -1;\n\t\n\tint ret = 0;\n\trep (i, 10 ) rep (j, 10 ) ret += cnt[i][j];\n\n\treturn ret;\t\n}\n\nvoid dfs ()\n{\n\tint res = -1;\n\trep (i, 1<<10 ){\n\t\tmemset (cnt, 0, sizeof (cnt ) );\n\t\trep (j, 10 ) cnt[0][j] = (i>>j) & 1;\n\t\tint t = solve();\n\t\tif (t >= 0 && (res < 0 || res > t ) ){\n\t\t\tres = t;\n\t\t\tmemcpy (ans, cnt, sizeof (cnt ) );\n\t\t} // end if\n\t} // end rep\n}\n\nint main()\n{\n\tint T; cin >> T;\n\twhile (T--){\n\t\tmemset (in, 0, sizeof (in ) );\n\t\tmemset (ans, 0, sizeof (ans ) );\n\t\trep (i, 10 ) rep (j, 10 ) cin >> in[i][j];\n\t\tdfs ();\n\t\trep (i, 10 ) rep (j, 10 ) cout << ans[i][j] << ( j < 9 ? ' ' : '\\n' );\n\t} // end while\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n\nusing namespace std;\n\n\n\nvector<int> GaussJordanMod2(vector<vector<int> > a){\n\tint n=a.size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(a[j][i]){\n\t\t\t\ta[i].swap(a[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j||a[j][i]==0)continue;\n\t\t\tfor(int k=i;k<n+1;k++){\n\t\t\t\ta[j][k] = (a[j][k]-a[i][k]+2)%2;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> res(n);\n\tfor(int i=0;i<n;i++)res[i]=a[i][n];\n\treturn res;\n}\n\n\nint main(){\n\tint dy[]={0,1,0,-1,0};\n\tint dx[]={0,0,1,0,-1};\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tvector<vector<int> > a(100,vector<int>(101,0));\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint y=i/10,x=i%10;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tint ny=y+dy[j],nx=x+dx[j];\n\t\t\t\tif(0<=ny&&ny<10&&0<=nx&&nx<10){\n\t\t\t\t\ta[ny*10+nx][i]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\ta[i][100]=c;\n\t\t}\n\t\tvector<int> ans(GaussJordanMod2(a));\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcout<<ans[i*10];\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tcout<<' '<<ans[i*10+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint t[10][10];\nint s[10][10];\nint u[10][10];\nint main(){\n\tint a;\n\tscanf(\"%d\",&a);\n\twhile(a--){\n\t\tfor(int i=0;i<10;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\tscanf(\"%d\",&t[i][j]);\n\t\tfor(int i=0;i<(1<<10);i++){\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\ts[j][k]=t[j][k];\n\t\t\t\t\tu[j][k]=0;\n\t\t\t\t}\n\t\t\tfor(int j=0;j<10;j++)if(i&(1<<j)){\n\t\t\t\ts[0][j]=(s[0][j]+1)%2;\n\t\t\t\tif(j<9)s[0][j+1]=(s[0][j+1]+1)%2;\n\t\t\t\tif(j)s[0][j-1]=(s[0][j-1]+1)%2;\n\t\t\t\ts[1][j]=(s[1][j]+1)%2;\n\t\t\t\tu[0][j]=1;\n\t\t\t}\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(s[j-1][k]%2){\n\t\t\t\t\t\tu[j][k]=1;\n\t\t\t\t\t\ts[j][k]=(s[j][k]+1)%2;\n\t\t\t\t\t\ts[j-1][k]=(s[j-1][k]+1)%2;\n\t\t\t\t\t\tif(k)s[j][k-1]=(s[j][k-1]+1)%2;\n\t\t\t\t\t\tif(k<9)s[j][k+1]=(s[j][k+1]+1)%2;\n\t\t\t\t\t\tif(j<9)s[j+1][k]=(s[j+1][k]+1)%2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<10;j++)if(s[9][j]%2)ok=false;\n\t\t\tif(!ok)continue;\n\t\t\telse{\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\t\tif(k)printf(\" \");\n\t\t\t\t\t\tprintf(\"%d\",u[j][k]);\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n#define INV (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tbool bSCont = true;\n\t\tCMap M = q[0];\n\t\t\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1 && bSCont; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 && bSCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tCMap add = M;\n\t\t\t\t\tint ti = INV, tj = INV;\n\t\t\t\t\tconst int di[4][5] = {\n\t\t\t\t\t\t{0,-1,-1,-1,0},\n\t\t\t\t\t\t{-1,-1,0,1,1},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{1,1,0,-1,-1}\n\t\t\t\t\t};\n\t\t\t\t\tconst int dj[4][5] = {\n\t\t\t\t\t\t{-1,-1,0,1,1,},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{1,1,0,-1,-1},\n\t\t\t\t\t\t{0,-1,-1,-1,0}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tbool bCont = true;\n\t\t\t\t\t\tfor(int l = 0; l < sizeof(*di)/sizeof(**di) && bCont; ++l){\n\t\t\t\t\t\t\tif( add.m[i+di[k][l]][j+dj[k][l]] != 0 ){\n\t\t\t\t\t\t\t\tti = INV;\n\t\t\t\t\t\t\t\ttj = INV;\n\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tswitch( k ){\n\t\t\t\t\t\t\t\t\tcase 0: ti = i + 1; tj = j; break;\n\t\t\t\t\t\t\t\t\tcase 1: ti = i; tj = j - 1; break;\n\t\t\t\t\t\t\t\t\tcase 2: ti = i - 1; tj = j; break;\n\t\t\t\t\t\t\t\t\tcase 3: ti = i; tj = j + 1; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( bCont )\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif( ti != INV && tj != INV ){\n\t\t\t\t\t\tadd.PassParticle( ti, tj );\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints_(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt_valid = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0/*-1,-1,0,1, 1, 1, 0,-1*/};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1/* 0, 1,1,1,-0,-1,-1,-1*/};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\t\t\t\t\tif( inRange( i+di[k], 1, MAX - 1) && inRange( j+dj[k], 1, MAX-1 ) )\n\t\t\t\t\t\t++cnt_valid;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 == cnt_valid ){\n\t\t\t\t\tstm.PassParticle( i, j );\n\t\t\t\t\tans.m[i][j] = 1;\n\t\t\t\t\tgoto RETRY;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\nRETRY:;\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tbool bSCont = true;\n\n\t\tfor(int i = 1; i < MAX - 1 && bSCont; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 && bSCont; ++j){\n\t\t\t\tif( stm.m[i][j] == 1 ){\n\t\t\t\t\tint ti = INV, tj = INV;\n\t\t\t\t\tvector< pair<int, int > > vt;\n\t\t\t\t\tconst int di[4][5] = {\n\t\t\t\t\t\t{0,-1,-1,-1,0},\n\t\t\t\t\t\t{-1,-1,0,1,1},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{1,1,0,-1,-1}\n\t\t\t\t\t};\n\t\t\t\t\tconst int dj[4][5] = {\n\t\t\t\t\t\t{-1,-1,0,1,1,},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{1,1,0,-1,-1},\n\t\t\t\t\t\t{0,-1,-1,-1,0}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tbool bCont = true;\n\t\t\t\t\t\tfor(int l = 0; l < sizeof(*di)/sizeof(**di) && bCont; ++l){\n\t\t\t\t\t\t\tif( stm.m[i+di[k][l]][j+dj[k][l]] != 0 ){\n\t\t\t\t\t\t\t\tti = INV;\n\t\t\t\t\t\t\t\ttj = INV;\n\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tswitch( k ){\n\t\t\t\t\t\t\t\t\tcase 0: ti = i + 1; tj = j; break;\n\t\t\t\t\t\t\t\t\tcase 1: ti = i; tj = j - 1; break;\n\t\t\t\t\t\t\t\t\tcase 2: ti = i - 1; tj = j; break;\n\t\t\t\t\t\t\t\t\tcase 3: ti = i; tj = j + 1; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( bCont ){\n\t\t\t\t\t\t\tvt.push_back( make_pair( ti, tj ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( vt.size() > 0 ){\n\t\t\t\t\t\tdouble maxEfficient = 0.499;\n\t\t\t\t\t\t\n\t\t\t\t\t\tti = INV; tj = INV;\n\t\t\t\t\t\tfor(unsigned int t = 0; t < vt.size(); ++t){\n\t\t\t\t\t\t\tint cnt1 = 0;\n\t\t\t\t\t\t\tint invCnt = 0;\n\t\t\t\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\t\t\tif( !inRange(vt[t].first+di[k], 1, MAX-1) || !inRange(vt[t].second+dj[k],1,MAX-1) )\n\t\t\t\t\t\t\t\t\tinvCnt++;\n\t\t\t\t\t\t\t\tif( stm.m[vt[t].first+di[k]][vt[t].second+dj[k]] == 1 )\n\t\t\t\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif( (double)cnt1 / ( 5 - invCnt ) > maxEfficient ){\n\t\t\t\t\t\t\t\tmaxEfficient = (double)cnt1 / (5 - invCnt);\n\t\t\t\t\t\t\t\tti = vt[t].first; tj = vt[t].second;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( ti != INV && tj != INV ){\n\t\t\t\t\t\t\tstm.PassParticle( ti, tj );\n\t\t\t\t\t\t\tans.m[ti][tj] = 1;\n\t\t\t\t\t\t\tbSCont = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    int mp[12][12],ans[12][12];\n    for(int i=1;i<=10;i++)for(int j=1;j<=10;j++) cin>>mp[i][j];\n    int cp[12][12];\n\n    for(int i=0;i<(1<<10);i++){\n      \n      for(int j=1;j<=10;j++)\n\tfor(int k=1;k<=10;k++)cp[j][k]=mp[j][k],ans[j][k]=0;\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  cp[1][j+1]=!cp[1][j+1];\n\t  cp[1][j]=!cp[1][j];\n\t  cp[1][j+2]=!cp[1][j+2];\n\t  cp[2][j+1]=!cp[2][j+1];\n\t  ans[1][j+1]=1;\n\t}\n      }\n      for(int j=2;j<=10;j++){\n\tfor(int k=1;k<=10;k++){\n\t  if(cp[j-1][k]){\n\t    cp[j-1][k]=!cp[j-1][k];\n\t    cp[j][k]=!cp[j][k];\n\t    cp[j][k-1]=!cp[j][k-1];\n\t    cp[j][k+1]=!cp[j][k+1];\n\t    cp[j+1][k]=!cp[j+1][k];\n\t    ans[j][k]=1;\n\t  }\n\t}\n      }\n      int f=0;\n      for(int j=1;j<=10;j++)\n\tfor(int k=1;k<=10;k++)\n\t  if(cp[j][k])f=1;\n      if(!f)break;\n    }\n\n    for(int i=1;i<=10;i++){\n      for(int j=1;j<=10;j++){\n\tif(j!=1)cout<<' ';\n\tcout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define SIZE 10\nusing namespace std;\n\nclass State{\npublic:\n  int data[SIZE][SIZE];\n  int put[SIZE][SIZE];\n  State() {\n    fill((int*)put, (int*)put+SIZE*SIZE, 0);\n  }\n  void puts(int x, int y) {\n    static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n    put[y][x] = 1;\n    for(int k = 0; k < 5; k++) {\n      int nx = x + d[k][0];\n      int ny = y + d[k][1];\n      if(nx < 0 || nx >= SIZE) continue;\n      if(ny < 0 || ny >= SIZE) continue;\n      data[ny][nx] = -(data[ny][nx] - 1);\n    }\n  }\n  bool isAll0() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(data[i][j] != 0) return false;\n      }\n    }\n    return true;\n  }\n  void show() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcout << put[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool rec(State s, int x, int y) {\n  static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n  if(s.isAll0()) {\n    s.show();\n    return true;\n  }\n\n  for(int i = y; i < SIZE; i++) {\n    int j;\n    if(i == y) j = x;\n    else       j = 0;\n    for(; j < SIZE; j++) {\n      bool flag = false;\n      /*for(int k = 0; k < 5; k++) {\n\tint nx = j + d[k][0];\n\tint ny = i + d[k][1];\n\tif(nx < 0 || nx >= SIZE) continue;\n\tif(ny < 0 || ny >= SIZE) continue;\n\tif(s.data[ny][nx] == 1) {\n\t  flag = true;\n\t  break;\n\t}\n\t}*/\n      flag = true;\n      if(flag) {\n\tif(i > 0 && s.data[i-1][j] == 0) continue;\n\tState tmp = s;\n\ttmp.puts(j, i);\n\tint nx, ny;\n\tnx = j + 1;\n\tny = i;\n\tif(nx >= SIZE) {\n\t  nx = 0;\n\t  ny++;\n\t}\n\tif(rec(tmp, nx, ny)) {\n\t  return true;\n\t}\n\tif(i > 0 && s.data[i-1][j] == 1) return false;\n      }\n    }\n  }\n  return false;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    if(t != 0) cout << endl;\n    State s;\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcin >> s.data[i][j];\n      }\n    }\n    rec(s, 0, 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n#define INV (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\t/* corner */\n\t{\n\t\tif( stm.m[1][1] == 1 ){\n\t\t\tif( stm.m[1][2] == 1 && stm.m[2][1] == 1 ){\n\t\t\t\tstm.PassParticle( 1, 1 );\n\t\t\t\tans.m[1][1] = 1;\n\t\t\t}\n\t\t}\n\t\tif( stm.m[1][MAX-2] == 1 ){\n\t\t\tif( stm.m[1][MAX-3] == 1 && stm.m[2][MAX-2] == 1 ){\n\t\t\t\tstm.PassParticle( 1, MAX-2 );\n\t\t\t\tans.m[1][MAX-2] = 1;\n\t\t\t}\n\t\t}\n\t\tif( stm.m[MAX-2][1] == 1 ){\n\t\t\tif( stm.m[MAX-3][1] == 1 && stm.m[MAX-2][2] == 1 ){\n\t\t\t\tstm.PassParticle( MAX-2, 1 );\n\t\t\t\tans.m[MAX-2][1] = 1;\n\t\t\t}\n\t\t}\n\t\tif( stm.m[MAX-2][MAX-2] == 1 ){\n\t\t\tif( stm.m[MAX-2][MAX-3] == 1 && stm.m[MAX-3][MAX-2] == 1 ){\n\t\t\t\tstm.PassParticle( MAX-2, MAX-2 );\n\t\t\t\tans.m[MAX-2][MAX-2] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\twhile( !stm.NoLight() ){\n\t\tvector< pair<int, int > > vt;\n\t\tbool bSCont = true;\n\n\t\t/* deko */\n\t\t{\n\t\t\tconst int ci[] = {1,1,1,1,4,5,6,7,4,5,6,7,MAX-2,MAX-2,MAX-2,MAX-2};\n\t\t\tconst int cj[] = {4,5,6,7,1,1,1,1,MAX-2,MAX-2,MAX-2,MAX-2,4,5,6,7};\n\n\t\t\tfor(int i = 0; i < sizeof(ci)/sizeof(*ci); ++i ){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int j = 0; j < sizeof(di)/sizeof(*di); ++j){\n\t\t\t\t\tif( stm.m[ci[i]+di[j]][cj[i]+dj[j]] == 1 &&\n\t\t\t\t\t\tinRange(ci[i]+di[j],1,MAX-1) && inRange(cj[i]+dj[j],1,MAX-1) )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\t\t\t\tif( cnt1 == 4 ){\n\t\t\t\t\tint ccnt1 = 0;\n\t\t\t\t\tconst int ddi[] = {-1,-1,1,1};\n\t\t\t\t\tconst int ddj[] = {1,1,-1,-1};\n\n\t\t\t\t\tfor( int j = 0; j < sizeof(ddi)/sizeof(*ddi); ++j){\n\t\t\t\t\t\tif( stm.m[ci[i]+ddi[j]][cj[i]+ddj[j]] == 1 &&\n\t\t\t\t\t\t\tinRange(ci[i]+ddi[j],1,MAX-1) && inRange(ci[i]+ddi[j],1,MAX-1) )\n\t\t\t\t\t\t\t++ccnt1;\n\t\t\t\t\t}\n\t\t\t\t\tif( ccnt1 <= 1 ){\n\t\t\t\t\t\tstm.PassParticle( ci[i], cj[i] );\n\t\t\t\t\t\tans.m[ci[i]][cj[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* other */\n\t\tfor(int i = 1; i < MAX - 1 && bSCont; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 && bSCont; ++j){\n\t\t\t\tif( stm.m[i][j] == 1 ){\n\t\t\t\t\t\n\t\t\t\t\tconst int di[][2] = { {0,-1}, {-1,0}, {0,1}, {1,0} };\n\t\t\t\t\tconst int dj[][2] = { {-1,0}, {0,1}, {1,0}, {0,-1} };\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tbool bCont = true;\n\t\t\t\t\t\tint ti1, tj1, ti2, tj2;\n\n\t\t\t\t\t\tfor(int l = 0; l < sizeof(*di)/sizeof(**di) && bCont; ++l){\n\t\t\t\t\t\t\tif( stm.m[i+di[k][l]][j+dj[k][l]] != 0 ||\n\t\t\t\t\t\t\t\t!inRange(i+di[k][l],1,MAX-1) || !inRange(j+dj[k][l],1,MAX-1) ){\n\t\t\t\t\t\t\t\t\tti1 = tj1 = ti2 = tj2 = INV;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tswitch( k ){\n\t\t\t\t\t\t\t\t\tcase 0: ti1 = i + 1; tj1 = j; ti2 = i; tj2 = j + 1; break;\n\t\t\t\t\t\t\t\t\tcase 1: ti1 = i; tj1 = j - 1; ti2 = i + 1; tj2 = j; break;\n\t\t\t\t\t\t\t\t\tcase 2: ti1 = i - 1; tj1 = j; ti2 = i; tj2 = j - 1; break;\n\t\t\t\t\t\t\t\t\tcase 3: ti1 = i; tj1 = j + 1; ti2 = i - 1; tj2 = j; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( bCont ){\n\t\t\t\t\t\t\tif( inRange(ti1,1,MAX-1) && inRange(tj1,1,MAX-1) )\n\t\t\t\t\t\t\t\tvt.push_back( make_pair( ti1, tj1 ) );\n\t\t\t\t\t\t\tif( inRange(ti2,1,MAX-1) && inRange(tj2,1,MAX-1) )\n\t\t\t\t\t\t\t\tvt.push_back( make_pair( ti2, tj2 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( vt.size() > 0 ){\n\t\t\tint ti = INV, tj = INV;\n\t\t\tint max1 = 0;\n\t\t\tdouble maxEfficient = 0.499;\n\t\t\t\n\t\t\tfor(unsigned int t = 0; t < vt.size(); ++t){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint invCnt = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( !inRange(vt[t].first+di[k], 1, MAX-1) || !inRange(vt[t].second+dj[k],1,MAX-1) )\n\t\t\t\t\t\tinvCnt++;\n\t\t\t\t\tif( stm.m[vt[t].first+di[k]][vt[t].second+dj[k]] == 1 )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tif( (double)cnt1 / ( 5 - invCnt ) > maxEfficient ){\n\t\t\t\t\t\tmaxEfficient = (double)cnt1 / (5 - invCnt);\n\t\t\t\t\t\tti = vt[t].first;\n\t\t\t\t\t\ttj = vt[t].second;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ti != INV && tj != INV ){\n\t\t\t\t//cout << ti << ' ' << tj << '\\n';\n\t\t\t\tstm.PassParticle( ti, tj );\n\t\t\t\tans.m[ti][tj] = 1;\n\t\t\t\tbSCont = false;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint dx[5]={0,1,0,-1,0};\nint dy[5]={1,0,-1,0,0};\n\ntypedef struct{\n\tint m[12][12];\n\tint l[12][12];\n}state;\n\nstate push(state t,int x,int y){\n\tt.l[x][y]=(t.l[x][y]+1)%2;\n\tfor(int i=0;i<5;i++){\n\t\tt.m[x+dx[i]][y+dy[i]]=(t.m[x+dx[i]][y+dy[i]]+1)%2;\n\t}\n\treturn t;\n}\n\nint cal(state t,int b){\n\tfor(int i=1;i<=10;i++){\n\t\tif(b%2)t=push(t,i,1);\n\t\tb/=2;\n\t}\n\tfor(int i=2;i<=10;i++){\n\t\tfor(int j=1;j<=10;j++){\n\t\t\tif(t.m[j][i-1]){\n\t\t\t\tt=push(t,j,i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=10;i++){\n\t\tfor(int j=1;j<=10;j++){\n\t\t\tif(t.m[j][i]){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=10;i++){\n\t\tfor(int j=1;j<=10;j++){\n\t\t\tcout<<t.l[j][i];\n\t\t\tif(j==10){\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\telse cout<<\" \";\n\t\t}\n\t}\n\t\n\treturn 1;\n}\n\nint main(){\n\tint n;cin>>n;\n\twhile(n--){\n\t\tstate tmp;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++){\n\t\t\t\tcin>>tmp.m[j][i];\n\t\t\t\ttmp.l[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<=1023;i++){\n\t\t\tif(cal(tmp,i))break;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\t//if(!fir)cout<<endl;\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp-(panel[j]>>k)&1)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans[9]==0){\n\t\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\t\tint tmp=(ans[i]>>j)&1;\n\t\t\t\t\t\tprintf(j==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\tif(!fir)cout<<endl;\n\t\tint panel[10]={},ans[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp-(panel[j]>>k)&1)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans[9]==0){\n\t\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\t\tint tmp=(ans[i]>>j)&1;\n\t\t\t\t\t\tprintf(j==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint S3[1024];\n\nint main()\n{\n\trep (S, 1024 ){\n\t\tint stat = 0;\n\t\trep (j, 10 ) if (S & (1<<j) ) {\n\t\t\tstat ^= 1<<j;\n\t\t\tif (j > 0 ) stat ^= 1<<(j-1);\n\t\t\tif (j < 9 ) stat ^= 1<<(j+1);\n\t\t} // end rep\n\t\tS3[S] = stat;\n\t} // end rep\n\tint T; scanf (\"%d\", &T );\n\twhile (T--){\n\t\tint org[10] = {};\n\t\trep (i, 10 ) rep (j, 10 ){\n\t\t\tint tmp; scanf (\"%d\", &tmp );\n\t\t\torg[i] |= tmp<<j;\n\t\t} // end rep\n\t\t\n\t\tint ans = -1;\n\t\trep (S, 1024 ){\n\t\t\tint grid[10];\n\t\t\trep (i, 10 ) grid[i] = org[i];\n\t\t\n\t\t\tgrid[0] ^= S3[S];\n\t\t\tgrid[1] ^= S;\n\t\t\tfor (int i = 1; i < 10; i++ ){\n\t\t\t\tint pttn = grid[i-1];\n\t\t\t\tgrid[i-1] = 0;\n\t\t\t\tgrid[i] ^= S3[pttn];\n\t\t\t\tif (i < 9 ) grid[i+1]^=pttn;\n\t\t\t} // end if\n\t\t\tif (grid[9] == 0 ){\n\t\t\t\tans = S; break;\n\t\t\t} // end if\n\t\t} // end rep\n\t\tif (ans == -1 ) while (1 );\n\t\n\t\trep (j, 10 ) printf (\"%d%c\", !!(ans&(1<<j)), j<9 ? ' ' :'\\n' );\n\t\torg[0] ^= S3[ans];\n\t\torg[1] ^= ans;\n\t\tfor (int i = 1; i < 10; i++ ){\n\t\t\tint pttn = org[i-1];\n\t\t\torg[i-1] = 0;\n\t\t\torg[i] ^= S3[pttn];\n\t\t\tif (i < 10 ) org[i+1]^=pttn;\n\t\t\trep (j, 10 ) printf (\"%d%c\", !!(pttn&(1<<j)), j<9 ? ' ' : '\\n' ); \n\t\t} // end for\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool grid[10][10];\nint dy[] = {1,0,-1,0,0}, dx[] = {0,1,0,-1,0};\n\nvoid rev(int y,int x){\n  for(int i=0;i<5;i++){\n    int sy = y+dy[i], sx = x+dx[i];\n    if(sy<0 || sx<0 || sy>=10 || sx>=10)continue;\n    grid[sy][sx] = !grid[sy][sx];\n  }\n}\n\nint main(){\n  int t;\n  bool tmp[10][10];\n  int ans[10][10];\n\n  cin >> t;\n  while(t--){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++)cin >> tmp[i][j];\n    }\n    \n    for(int i=0;i<(1<<10);i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++)grid[j][k] = tmp[j][k];\n      }\n\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  rev(0,j);\n\t  ans[0][j] = 1;\n\t}else ans[0][j] = 0;\n      }\n\n      for(int j=1;j<10;j++){\n\tfor(int k=0;k<10;k++){\n\t  if(grid[j-1][k]){\n\t    rev(j,k);\n\t    ans[j][k] = 1;\n\t  }else ans[j][k] = 0;\n\t}\n      }\n\n      bool f = false;\n      for(int j=0;j<10;j++)f |= grid[9][j];\n      if(!f)break;\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<9;j++)cout << ans[i][j] << \" \";\n      cout << ans[i][9] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(y==1){\n\t\tnow[x][y]=0;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(1,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(1,y+1);\n\t\tflip(x,y);\n\t\t\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(1,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tnow[x][y]=0;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(1,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,-1,sizeof(res));\n\t\tcheck(1,1);\n\t\tif(res[1][1]==-1)while(1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n\nconst int INF = 1001001001;\n\nint N;\nint map[12][12];\nbool used[12][12];\n\nint reverse(int x, int y){\n    map[y][x] = !map[y][x];\n    map[y][x-1] = !map[y][x-1];\n    map[y-1][x] = !map[y-1][x];\n    map[y][x+1] = !map[y][x+1];\n    map[y+1][x] = !map[y+1][x];\n}\n\nint main(){\n    scanf(\"%d\", &N);\n\n    REP(_, N){\n        FOR(i, 1, 11){\n            FOR(j, 1, 11){\n                scanf(\"%d\", &map[i][j]);\n            }\n        }\n\n        REP(state, 1<<10){\n            memset(used, 0, sizeof(used));\n\n            FOR(i, 1, 11){\n                if(state >> (i-1) & 1){\n                    used[1][i] = true;\n                    reverse(i, 1);\n                }\n            }\n\n            FOR(i, 2, 11){\n                FOR(j, 1, 11){\n                    if(map[i-1][j] == 1){\n                        used[i][j] = true;\n                        reverse(j, i);\n                    }\n                }\n            }\n\n            bool f = false;\n            FOR(i, 1, 11){\n                f |= map[10][i];\n            }\n\n            if(f){\n                FOR(i, 1, 11){\n                    FOR(j, 1, 11){\n                        if(used[i][j]){reverse(j, i);}\n                    }\n                }\n                continue;\n            }\n\n            FOR(i, 1, 11){\n                FOR(j, 1, 11){\n                    printf(\"%d\", used[i][j]);\n                    if(j < 10){putchar(' ');}\n                    else{puts(\"\");}\n                }\n            } \n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define l(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool m[12][12],c[12][12],d[12][12],q;\nint main(){int n;cin>>n;l(u,n){l(i,10)l(j,10)cin>>m[i][j];\nbool f[10],t[10]={0};for(int p=1;p<=1024;p++){\nl(i,10)f[i]=t[i];l(i,10)l(j,10)c[i][j]=m[i][j];l(k,10){l(i,10)\nif(f[i]){for(int j=max(0,i-1);j<=min(9,i+1);j++)c[k][j]^=1;c[k+1][i]^=1;}\nl(i,10)d[k][i]=f[i];l(i,10)f[i]=c[k][i];}q=0;l(i,10)q|=f[i];\nif(!q){l(i,10){l(j,10){if(j)cout<<\" \";cout<<d[i][j];}cout<<endl;}\nbreak;}l(i,10)if(p%(int)pow(2,i)==0)t[i]^=1;\n}}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nbool orig[10][10];\nbool work[10][10];\nbool ans[10][10];\n\n\nint dx[5] = {-1,0,0,0,1};\nint dy[5] = {0,-1,0,1,0};\n\nbool debug = false;\n\nvoid flip(int x, int y){\n\tfor(int i=0;i<5;i++){\n\t\tif(0 <= x+dx[i] && x+dx[i] <10 &&\n\t\t0 <= y+dy[i] && y+dy[i] < 10){\n\t\t\twork[x+dx[i]][y+dy[i]] = 1 - work[x+dx[i]][y+dy[i]];\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(void){\n\tint n;\n\tint tmp;\n\tbool isfirst = true;\n\tstring str;\n\t\n\tcin >> n;\n\tcin.ignore();\n\t\n\tfor(int cas=0;cas<n;cas++){\n\t\tmemset(orig, false, sizeof(orig));\n\t\t\n\t\t//if(!isfirst) cout << endl;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tgetline(cin,str);\n\t\t\tistringstream iss(str);\n\t\t\tif(debug) cout << i << \" \" << str << endl;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tiss >> tmp;\n\t\t\t\tif(tmp == 0){\n\t\t\t\t\torig[i][j] = false;\n\t\t\t\t}else{\n\t\t\t\t\torig[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i < 1 << 10; i++){\n\t\t\tif(debug) cout << i <<endl;\n\t\t\t\n\t\t\tcopy(orig, orig+10*10, work);\n\t\t\t//1sÚÉÎ·é\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif(i & 1 << j){\n\t\t\t\t\tflip(0,j);\n\t\t\t\t\tans[0][j] = true;\n\t\t\t\t}else{\n\t\t\t\t\tans[0][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(work[j-1][k]){\n\t\t\t\t\t\tflip(j,k);\n\t\t\t\t\t\tans[j][k] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans[j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//check ended or not\n\t\t\tbool isended = true;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(work[j][k]){ isended = false;}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(isended){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\t\tif(k==9){\n\t\t\t\t\t\t\tcout << ans[j][k] << endl;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcout << ans[j][k] << \" \";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tisfirst = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define SIZE 10\nusing namespace std;\n\nclass State{\npublic:\n  int data[SIZE][SIZE];\n  int put[SIZE][SIZE];\n  State() {\n    fill((int*)put, (int*)put+SIZE*SIZE, 0);\n  }\n  void puts(int x, int y) {\n    static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n    put[y][x] = 1;\n    for(int k = 0; k < 5; k++) {\n      int nx = x + d[k][0];\n      int ny = y + d[k][1];\n      if(nx < 0 || nx >= SIZE) continue;\n      if(ny < 0 || ny >= SIZE) continue;\n      data[ny][nx] = -(data[ny][nx] - 1);\n    }\n  }\n  bool isAll0() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(data[i][j] != 0) return false;\n      }\n    }\n    return true;\n  }\n  void show() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(j != 0) cout << ' ';\n\tcout << put[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool rec(State s, int x, int y) {\n  static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n  if(s.isAll0()) {\n    s.show();\n    return true;\n  }\n\n  for(int i = y; i < SIZE; i++) {\n    int j;\n    if(i == y) j = x;\n    else       j = 0;\n    for(; j < SIZE; j++) {\n      bool flag = false;\n      /*for(int k = 0; k < 5; k++) {\n\tint nx = j + d[k][0];\n\tint ny = i + d[k][1];\n\tif(nx < 0 || nx >= SIZE) continue;\n\tif(ny < 0 || ny >= SIZE) continue;\n\tif(s.data[ny][nx] == 1) {\n\t  flag = true;\n\t  break;\n\t}\n\t}*/\n      flag = true;\n      if(flag) {\n\tif(i > 0 && s.data[i-1][j] == 0) continue;\n\tState tmp = s;\n\ttmp.puts(j, i);\n\tint nx, ny;\n\tnx = j + 1;\n\tny = i;\n\tif(nx >= SIZE) {\n\t  nx = 0;\n\t  ny++;\n\t}\n\tif(rec(tmp, nx, ny)) {\n\t  return true;\n\t}\n\tif(i > 0 && s.data[i-1][j] == 1) return false;\n      }\n    }\n  }\n  return false;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    State s;\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcin >> s.data[i][j];\n      }\n    }\n    rec(s, 0, 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint a[10][10],b[10][10],c[10][10],TEST;\nint dx[]={0,0,0,1,-1};\nint dy[]={0,1,-1,0,0};\nbool solve(int x){\n  r(i,10)if((x>>i)&1){\n    c[0][i]=1;\n    r(j,5){\n      int y=dy[j];\n      int x=dx[j]+i;\n      if(y<0||x<0||y>9||x>9)continue;\n      b[y][x]=(b[y][x]+1)%2;\n    }\n  }\n  for(int i=0;i<9;i++){\n    r(j,10){\n      if(b[i][j]){\n        c[i+1][j]=1;\n        r(k,5){\n          int y=i+dy[k]+1;\n          int x=j+dx[k];\n          if(y<0||x<0||y>9||x>9)continue;\n          b[y][x]=(b[y][x]+1)%2;\n        }\n      }\n    }\n  }\n  r(i,10)r(j,10)if(b[i][j])return 0;\n  return 1;\n}\nint main(){\n  cin>>TEST;\n  while(TEST--){\n    r(i,10)r(j,10)cin>>a[i][j];\n    for(int i=0;i<(1<<10);i++){\n      r(k,10)r(j,10)b[k][j]=a[k][j];\n      memset(c,0,sizeof(c));\n      if(solve(i)){\n        r(i,10){\n          r(j,10){\n            if(j)cout<<' ';\n            cout<<c[i][j];\n          }\n          cout<<endl;\n        }\n        goto L;\n      }\n    }L:;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool canPut(int y, int x){\n\tint sy = y - 1;\n\tint ty = y + 1;\n\tint sx = x - 1;\n\tint tx = x + 1;\n\tif(sy < 0 || ty >= 10 || sx < 0 || tx >= 10)return false;\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1 && canPut(ny, nx)){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(!canPut(y, x)){\n\t\treturn dfs(n + 1);\n\t}\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tdfs(0);\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tcout << used[y][x] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\twhile(n--){\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp+(panel[j]>>k)&1)%2)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check=ans[8];\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif((ans[9]>>j)&1){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint x=j+k;\n\t\t\t\t\t\tif(0<=x&&x<10){\n\t\t\t\t\t\t\tif((check>>x)&1)check&=~(1<<x);\n\t\t\t\t\t\t\telse check|=1<<x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==panel[9]){\n\t\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tint tmp=(ans[y]>>x)&1;\n\t\t\t\t\t\tprintf(x==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt_valid = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\t\t\t\t\tif( inRange( i+di[k], 1, MAX - 1) && inRange( j+dj[k], 1, MAX-1 ) )\n\t\t\t\t\t\t++cnt_valid;\n\t\t\t\t}\n\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint cnt_valid = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0/*-1,-1,0,1, 1, 1, 0,-1*/};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1/* 0, 1,1,1,-0,-1,-1,-1*/};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\t\t\t\t\tif( inRange( i+di[k], 1, MAX - 1) && inRange( j+dj[k], 1, MAX-1 ) )\n\t\t\t\t\t\t++cnt_valid;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 == cnt_valid ){\n\t\t\t\t\tstm.PassParticle( i, j );\n\t\t\t\t\tans.m[i][j] = 1;\n\t\t\t\t\tgoto RETRY;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\nRETRY:;\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 1;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nchar inputs[10][10];\nchar tmp[10][10];\nchar ans[10][10];\nint dx[] = {0, 1, 0, -1, 0};\nint dy[] = {-1, 0, 1, 0, 0};\n\nvoid through(int y, int x){\n  ans[y][x] = '1';\n  for(int i=0;i<5;i++){\n    int ty = y + dy[i];\n    int tx = x + dx[i];\n    if(ty<0 || ty>=10) continue;\n    if(tx<0 || tx>=10) continue;\n    if(tmp[ty][tx] == '1')tmp[ty][tx] = '0';\n    else tmp[ty][tx] = '1';\n  }\n}\n\nbool check(){\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(tmp[i-1][j] == '1') through(i, j);\n    }\n  }\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(tmp[i][j] == '1') return false;\n    }\n  }\n  return true;\n}\n\nmain(){\n  int t;\n  cin >> t;\n  for(int tc=1;tc<=t;tc++){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin >> inputs[i][j];\n      }\n    }\n    for(int i=0;i<(1<<10);i++){\n      fill(ans[0], ans[10], '0');\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++){\n \t  tmp[j][k] = inputs[j][k];\n\t}\n      }\n      for(int j=0;j<10;j++){\n\tif(i & (1<<j)) through(0, j);\n      }\n      /*for(int j=0;j<10;j++){\n\tcout << ans[0][j];\n\t}cout << endl;*/\n      if(check()) break;\n    }\n    for(int i=0;i<10;i++){\n      cout << ans[i][0];\n      for(int j=1;j<10;j++){\n\tcout << ' ' << ans[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12];\nint mask[12];\nint all = (1 << 10) - 1;\n\nint makeCurrMask(int curr, int m){\n\tfor(int i=0;i<10;i++){\n\t\tif((m >> i) & 1){\n\t\t\tint t = (i == 0) ? (7 >> 1) : (7 << (i - 1));\n\t\t\tcurr ^= t;\n\t\t}\n\t}\n\treturn curr & all;\n}\n\nbool dfs(int prev, int curr, int index){\n\tif(index >= 10){\n\t\tif(prev)return false;\n\t\treturn true;\n\t}\n\tfor(int m=0;m<(1<<10);m++){\n\t\tif(index > 0 && prev ^ m)continue;\n\t\tint ncurr = makeCurrMask(curr, m);\n\t\tint next = mask[index+1] ^ m;\n\n\t\tused[index] = m;\n\t\tif(dfs(ncurr, next, index + 1)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(mask, 0, sizeof(mask));\n\tmemset(used, 0, sizeof(used));\n\tfor(int y=0;y<10;y++){\n\t\tint m = 0;\n\t\tfor(int x=0;x<10;x++){\n\t\t\tm = ((m << 1) + board[y][x]);\n\t\t}\n\t\tmask[y] = m;\n\t}\n\tdfs(-1, mask[0], 0);\n}\n\nvoid output(){\n\tfor(int y=0;y<10;y++){\n\t\tint m = used[y];\n\t\tfor(int x=9;x>=0;x--){\n\t\t\tcout << (((m >> x) & 1) ? 1 : 0) << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\toutput();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int p[][12],int q[][12],int x){\n  int i,j;\n  int r[12][12],s[12][12];\n  if(x==11){\n    for(i=2;i<10;i++){\n      for(j=1;j<11;j++){\n\tif(p[j][i]){\n\t  p[j  ][i  ]=(p[j  ][i  ]+1)%2;\n\t  p[j-1][i+1]=(p[j-1][i+1]+1)%2;\n\t  p[j  ][i+1]=(p[j  ][i+1]+1)%2;\n\t  p[j+1][i+1]=(p[j+1][i+1]+1)%2;\n\t  p[j  ][i+2]=(p[j  ][i+2]+1)%2;\n\t  q[j][i+1]=1;\n\t}\n      }\n    }\n    for(i=1;i<11;i++){\n      if(p[i][10])\n\tbreak;\n    }\n    if(i==11){\n      for(i=1;i<11;i++){\n\tfor(j=1;j<10;j++)\n\t  cout<<q[j][i]<<\" \";\n\tcout<<q[j][i]<<endl;\n      }\n      return 1;\n    }\n  }else if(x==10){\n    if(p[x][1]){\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }else{\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      if(f(r,s,x+1))\n\treturn 1;\n    }\n  }else{\n      if(p[x][1]){\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x+1][0]=(r[x+1][0]+1)%2;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x+1][1]=(r[x+1][1]+1)%2;\n      r[x+2][1]=(r[x+2][1]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      s[x+1][1]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }else{\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      if(f(r,s,x+1))\n\treturn 1;\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x+1][0]=(r[x+1][0]+1)%2;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x+1][1]=(r[x+1][1]+1)%2;\n      r[x+2][1]=(r[x+2][1]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      s[x+1][1]=1;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  int i,j,k;\n  int q[12][12],r[12][12],n;\n  int (*p)[12][12];\n  cin>>n;\n  p=new int[n][12][12];\n  for(i=0;i<n;i++)\n    for(j=1;j<11;j++)\n      for(k=1;k<11;k++)\n\tcin>>p[i][k][j];\n  for(i=0;i<n;i++){\n    memcpy(r,&p[i][0][0],sizeof(r));\n    memset(q,0,sizeof(q));\n    f(r,q,1);\n    memcpy(r,&p[i][0][0],sizeof(r));\n    memset(q,0,sizeof(q));\n    r[1][0]=(r[1][0]+1)%2;\n    r[0][1]=(r[0][1]+1)%2;\n    r[1][1]=(r[1][1]+1)%2;\n    r[2][1]=(r[2][1]+1)%2;\n    r[1][2]=(r[1][2]+1)%2;\n    q[1][1]=1;\n    f(r,q,1);\n  }\n  delete [] p;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nint S3[1024];\n\nint main()\n{\n\trep (S, 1024 ){\n\t\tint stat = 0;\n\t\trep (j, 10 ) if (S & (1<<j) ) {\n\t\t\tstat ^= 1<<j;\n\t\t\tif (j > 0 ) stat ^= 1<<(j-1);\n\t\t\tif (j < 9 ) stat ^= 1<<(j+1);\n\t\t} // end rep\n\t\tS3[S] = stat;\n\t} // end rep\n\tint T; scanf (\"%d\", &T );\n\twhile (T--){\n\t\tint org[10] = {};\n\t\trep (i, 10 ) rep (j, 10 ){\n\t\t\tint tmp; scanf (\"%d\", &tmp );\n\t\t\torg[i] |= tmp<<j;\n\t\t} // end rep\n\t\t\n\t\tint ans = -1;\n\t\trep (S, 1024 ){\n\t\t\tint grid[10];\n\t\t\trep (i, 10 ) grid[i] = org[i];\n\t\t\n\t\t\tgrid[0] ^= S3[S];\n\t\t\tgrid[1] ^= S;\n\t\t\tfor (int i = 1; i < 10; i++ ){\n\t\t\t\tint pttn = grid[i-1];\n\t\t\t\tgrid[i-1] = 0;\n\t\t\t\tgrid[i] ^= S3[pttn];\n\t\t\t\tif (i < 9 ) grid[i+1]^=pttn;\n\t\t\t} // end if\n\t\t\tif (grid[9] == 0 ){\n\t\t\t\tans = S; break;\n\t\t\t} // end if\n\t\t} // end rep\n\t\n\t\trep (j, 10 ) printf (\"%d%c\", !!(ans&(1<<j)), j<9 ? ' ' :'\\n' );\n\t\torg[0] ^= S3[ans];\n\t\torg[1] ^= ans;\n\t\tfor (int i = 1; i < 10; i++ ){\n\t\t\tint pttn = org[i-1];\n\t\t\torg[i-1] = 0;\n\t\t\torg[i] ^= S3[pttn];\n\t\t\tif (i < 10 ) org[i+1]^=pttn;\n\t\t\trep (j, 10 ) printf (\"%d%c\", !!(pttn&(1<<j)), j<9 ? ' ' : '\\n' ); \n\t\t} // end for\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD NUM000007\n#define EPS 0.0000001\n#define NUM 30000\nusing namespace std;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 9 && col >= 0 && col <= 9)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint diff_row[5] = {-1,0,0,0,1},diff_col[5] = {0,-1,0,1,0};\n\nint main(){\n\n\tint N,table[10][10],work[10][10],calc_row,calc_col;\n\tbool tmp[10][10],ans[10][10],FLG;\n\tscanf(\"%d\",&N);\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tscanf(\"%d\",&table[i][k]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 1024; i++){\n\n\t\t\tfor(int a = 0; a < 10; a++){\n\t\t\t\tfor(int b = 0; b < 10; b++){\n\t\t\t\t\twork[a][b] = table[a][b];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tif(i & (1 << k)){\n\t\t\t\t\ttmp[0][k] = true;\n\t\t\t\t}else{\n\t\t\t\t\ttmp[0][k] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int a = 0; a < 10; a++){\n\t\t\t\tif(tmp[0][a]){\n\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\tcalc_row = 0+diff_row[b];\n\t\t\t\t\t\tcalc_col = a+diff_col[b];\n\n\t\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == true){\n\t\t\t\t\t\t\twork[calc_row][calc_col] = 1 - work[calc_row][calc_col];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int row = 1; row <= 9; row++){\n\t\t\t\tfor(int col = 0; col <= 9; col++){\n\t\t\t\t\tif(work[row-1][col] == 1){\n\t\t\t\t\t\ttmp[row][col] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ttmp[row][col] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int a = 0; a <= 9; a++){\n\t\t\t\t\tif(tmp[row][a]){\n\t\t\t\t\t\tfor(int b = 0; b < 5; b++){\n\t\t\t\t\t\t\tcalc_row = row+diff_row[b];\n\t\t\t\t\t\t\tcalc_col = a+diff_col[b];\n\n\t\t\t\t\t\t\tif(rangeCheck(calc_row,calc_col) == true){\n\t\t\t\t\t\t\t\twork[calc_row][calc_col] = 1 - work[calc_row][calc_col];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tFLG = true;\n\t\t\tfor(int a = 0; a <= 9; a++){\n\t\t\t\tif(work[9][a] == 1){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tfor(int a = 0; a < 10; a++){\n\t\t\t\t\tfor(int b = 0; b < 10; b++)ans[a][b] = tmp[a][b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int k = 0; k < 9; k++){\n\t\t\t\tif(ans[i][k]){\n\t\t\t\t\tprintf(\"1 \");\n\t\t\t\t}else{\n\t\t\t\t\tprintf(\"0 \");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans[i][9]){\n\t\t\t\tprintf(\"1\\n\");\n\t\t\t}else{\n\t\t\t\tprintf(\"0\\n\");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint t[102][102], tt[102][102];\nint ans[102][102];\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 0, 0, 1};\n\nbool solve(int bit){\n  memcpy(t, tt, sizeof(tt));\n  memset(ans, 0, sizeof(ans));\n\n  for(int i = 0; i < 10; i++){\n    if(bit & (1 << i)){\n      ans[0][i] = true;\n\n      for(int j = 0; j < 4; j++){\n        int nx = i + dx[j];\n        int ny = dy[j];\n        if(nx < 0 || 10 <= nx || ny < 0 || 10 <= ny) continue;\n        t[ny][nx] = !t[ny][nx];\n      }\n    }\n  }\n\n  for(int i = 1; i < 10; i++){\n    for(int j = 0; j < 10; j++){\n      if(t[i - 1][j]){\n        ans[i][j] = true;\n\n        for(int k = 0; k < 4; k++){\n          int nx = j + dx[k];\n          int ny = i + dy[k];\n          if(nx < 0 || 10 <= nx || ny < 0 || 10 <= ny) continue;\n          t[ny][nx] = !t[ny][nx];\n        }\n      }\n    }\n  }\n\n  for(int i = 0; i < 10; i++){\n    if(t[9][i]){\n      return false;\n    }\n  }\n\n  return true;\n}\n\nint main(){\n  int T;\n  cin >> T;\n\n  while(T--){\n    for(int i = 0; i < 10; i++){\n      for(int j = 0; j < 10; j++){\n        cin >> tt[i][j];\n      }\n    }\n\n    for(int bit = 0; bit < (1 << 10); bit++){\n      bool flg = solve(bit);\n\n      if(flg){\n        for(int i = 0; i < 10; i++){\n          for(int j = 0; j < 10; j++){\n            if(j != 0) cout << \" \";\n            cout << ans[i][j];\n          }\n          cout << endl;\n        }\n\n        break;\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tint TryPassParticle(int i, int j)\n\t{\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\n\t\treturn cnt1;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz],1,MAX-1) && inRange(j+dj[(k+2)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz],1,MAX-1) && inRange(j+dj[(k+3)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz],1,MAX-1) && inRange(j+dj[(k+4)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+6)%sz],j+dj[(k+6)%sz]) ){\n\t\t\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << endl;\n\t\tM.Print();*/\n\t\t\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tBFS( M, Answer );\n\t\t//cout << \"-----------------------------\\n\";\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\tif(!fir)cout<<endl;\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp+2-(panel[j]>>k)&1)%2)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check[10];\n\t\t\tfor(int j=0;j<10;j++)check[j]=(panel[9]>>j)&1;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tcheck[j]+=(ans[8]>>j)&1;\n\t\t\t\tif((ans[9]>>j)&1){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint x=j+k;\n\t\t\t\t\t\tif(0<=x&&x<10)check[x]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<10;j++)check[j]=check[j]%2;\n\t\t\tif(check[9]==0){\n\t\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tint tmp=(ans[y]>>x)&1;\n\t\t\t\t\t\tprintf(x==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nbool check(VVB& G)\n{\n  for(int i=1;i<=10;i++)\n    for(int j=0;j<10;j++)\n      if(G[i][j])\n\treturn false;\n  return true;\n}\n\nvoid next(VVB& G,int bit)\n{\n  for(int i=0;i<10;i++)\n    G[0][i] = ((bit>>i)&1)?1:0; \n}\n\nvoid execute(VVB&G,VVB& ans)\n{\n  ans.resize(11);\n  for(int i=1;i<11;i++)\n    {\n      ans[i].resize(10);\n      for(int j=0;j<10;j++)\n\tans[i][j] = false;\n    }\n\n  for(int i=1;i<11;i++)\n    {\n      for(int j=0;j<10;j++)\n\t{\n\t  if(G[i-1][j])\n\t    {\n\t      G[i][j] = !G[i][j];\n\t      ans[i][j] = true;\n\t      for(int k=0;k<4;k++)\n\t\t{\n\t\t  int nx = j + dx[k];\n\t\t  int ny = i + dy[k];\n\t\t  if(!(0 <= nx && nx < 10 && 0 <= ny && ny <= 10))\n\t\t    continue;\n\t\t  G[ny][nx] = !G[ny][nx];\n\t\t}\n\n\t    }\n\t}\n    }\n\n}\n\nint main()\n{\n  int n;\n  cin >> n;\n  while(n-- > 0)\n    {\n      VVB G;\n      G.resize(11);\n      G[0].resize(10);\n      for(int i=1;i<=10;i++)\n\t{\n\t  G[i].resize(10);\n\t  for(int j=0;j<10;j++)\n\t    {\n\t      bool b;\n\t      cin >> b;\n\t      G[i][j] = b;\n\t    }\n\t}\n\n\n      for(int m=0;m<=(1<<10)-1;m++)\n\t{\n\t  VVB pre_G = G;\n\t  VVB ans;\n\t  next(G,m);\n\n\t  execute(G,ans);\n\n\t  if(check(G))\n\t    {\n\t      for(int i=1;i<=10;i++)\n\t\t{\n\t\t  for(int j=0;j<10;j++)\n\t\t    {\n\t\t      cout << ans[i][j];\n\t\t      j == 9?cout << endl:cout << \" \";\n\t\t    }\n\t\t}\n\t      break;\n\t    }\n\t  G = pre_G;\n\t}\n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint a[12][12];\nint f[12][12];\nint res[12][12];\nint b[20] = {1};\nint dh[5] = {0, 0, 0, 1, -1};\nint dw[5] = {0, 1, -1, 0, 0};\n\nsigned main(void){\n  int i, j, k, l;\n  rep1(i, 20)b[i] = b[i - 1] << 1;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    for(;n--;){\n      rep(i, 10)rep(j, 10)scanf(\"%d\", &a[i + 1][j + 1]);\n      rep(k, b[10]){\n        rep(i, 12)rep(j, 12){\n          f[i][j] = a[i][j];\n          res[i][j] = 0;\n        }\n        for(int x = k, d = 1;x;x /= 2){\n          res[1][d] = x % 2;\n          if(x % 2 == 1)rep(l, 5)f[1 + dh[l]][d + dw[l]] ^= 1;\n          ++d;\n        }\n\n        rep1(i, 10)rep(j, 10)if(f[i][j + 1] == 1){\n          res[i + 1][j + 1] = 1;\n          rep(l, 5)f[i + 1 + dh[l]][j + 1 + dw[l]] ^= 1;\n        }\n        bool isok = true;\n        rep(i, 10)rep(j, 10)if(f[i + 1][j + 1] == 1)isok = false;\n        if(isok){\n          rep(i, 10){\n            rep(j, 9)printf(\"%d \", res[i + 1][j + 1]);\n            printf(\"%d\\n\", res[i + 1][j + 1]);\n          }\n          break;\n        }\n      }\n    }\n\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12];\nint mask[12];\nint all = (1 << 10) - 1;\n\nint makeCurrMask(int curr, int m){\n\tfor(int i=0;i<10;i++){\n\t\tif((m >> i) & 1){\n\t\t\tint t = (i == 0) ? (7 >> 1) : (7 << (i - 1));\n\t\t\tcurr ^= t;\n\t\t}\n\t}\n\treturn curr & all;\n}\n\nbool dfs(int prev, int curr, int index){\n\tif(index >= 10){\n\t\tif(prev)return false;\n\t\treturn true;\n\t}\n\tfor(int m=0;m<(1<<10);m++){\n\t\tif(index > 0 && prev ^ m)continue;\n\t\tint ncurr = makeCurrMask(curr, m);\n\t\tint next = mask[index+1] ^ m;\n\n\t\tused[index] = m;\n\t\tif(dfs(ncurr, next, index + 1)){\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(mask, 0, sizeof(mask));\n\tmemset(used, 0, sizeof(used));\n\tfor(int y=0;y<10;y++){\n\t\tint m = 0;\n\t\tfor(int x=0;x<10;x++){\n\t\t\tm = ((m << 1) + board[y][x]);\n\t\t}\n\t\tmask[y] = m;\n\t}\n\tdfs(-1, mask[0], 0);\n}\n\nvoid output(){\n\tfor(int y=0;y<10;y++){\n\t\tint m = used[y];\n\t\tfor(int x=9;x>=0;x--){\n\t\t\tif(x != 9)cout << \" \";\n\t\t\tcout << (((m >> x) & 1) ? 1 : 0);\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\toutput();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n ) for(int i=b;i<n;i++)\n#define rep(i,n)    REP(i,0,n)\n\n#define UNFILLED false\n#define FILLED true\n\n#define ORI true\n#define DUP false;\nchar inp[20][20];\nbool m[20][20];\nint _r,_c;\ntypedef struct Info{\n  int x,y,r,c,rot;\n};\n\nclass Piece{\npublic:\n  int r[4],c[4];\n  bool m[4][20][20];\n  vector<Info> Put;\n  int black;\n  bool dup[4];\n  bool operator<(const Piece & a)const{\n    return Put.size() > a.Put.size();\n  }\n};\n\nvoid rotate(Piece & a,int k){\n  static bool tmp[20][20];\n  rep(i,a.r[k-1]){\n    rep(j,a.c[k-1]){\n      tmp[i][j]=a.m[k-1][i][j];\n    }\n  }\n  \n  rep(i,a.r[k-1]){\n    rep(j,a.c[k-1]){\n      a.m[k][j][i]=tmp[i][a.c[k-1]-j-1];\n    }\n  }\n  a.r[k]=a.c[k-1];\n  a.c[k]=a.r[k-1];\n}\n\nvoid duplicate_check(Piece & a){\n  rep(i,4)a.dup[i]=ORI;\n  REP(i,1,4){\n    rotate(a,i);\n  }\n  return;\n  rep(k,4){\n    REP(l,k+1,4){\n      bool flag = false;\n      if ( a.r[k] !=a.r[l] ||a.c[k] != a.c[l])continue;\n      rep(i,a.r[k] && !flag)\n\trep(j,a.c[k] && !flag)\n\tif(a.m[k][i][j]!=a.m[l][i][j] )flag=true;\n      if (flag == false)a.dup[l]=DUP;\n    }\n  }\n}\n\nbool can_put(int x,int y,Piece & a,int r,int c,int k){\n  //if ( x + a.c[k]-1 >=c ||y+a.r[k]-1>= r)return false;\n  rep(i,a.r[k]){\n    rep(j,a.c[k]){\n      if ( a.m[k][i][j]==UNFILLED ){\n      }else if (a.m[k][i][j]==FILLED ){\n\t//if ( x+j >=c || y+i >=r)return false;\n\tif ( m[y+i][x+j] == FILLED)return false;\n      }\n    }\n  }\n  return true;\n}\n\nvoid construct(int n,Piece * in,int r,int c){\n  Info ins;\n  rep(l,n){\n    rep(i,r){\n      rep(j,c){\n\trep(k,4){\n\t  if (in[l].dup[k] == ORI && can_put(j,i,in[l],r,c,k) == true){\n\t    ins.x=j,ins.y=i,ins.r=in[l].r[k],ins.c=in[l].c[k];\n\t    ins.rot=k;\n\t    in[l].Put.push_back(ins);\n\t  }\n\t}\n      }\n    }\n  }\n}\n\n\nbool Operation(Piece &in,int me,int flag){\n  //flag=0 check,flag=1 put ,flag=2 remove\n  int x=in.Put[me].x,y=in.Put[me].y,r=in.Put[me].r,c=in.Put[me].c,k=in.Put[me].rot;\n  rep(i,r){\n    rep(j,c){\n      if ( x+j>=_c || y+i>=_r)continue;\n      if( flag == 0){\n\tif ( m[y+i][x+j]==FILLED){\n\t  if (in.m[k][i][j]==FILLED)return false;\n\t}\n      }else if ( flag == 1){\n\tif( in.m[k][i][j]==FILLED)m[y+i][x+j]=FILLED;\n      }else if ( flag == 2){\n\tif (in.m[k][i][j]==FILLED)m[y+i][x+j]=UNFILLED;\n      }\n    }\n  }\n\n  return true;\n}\n\n\n\nbool solve(int n,int now,Piece *in){\n  if ( n == now){\n    return true;\n  }\n\n  rep(i,in[now].Put.size()){\n    if ( Operation(in[now],i,0) ){\n      Operation(in[now],i,1);\n      if (solve(n,now+1,in)){\n\tOperation(in[now],i,2);\n\n\treturn true;\n      }\n      Operation(in[now],i,2);\n    }\n  }\n\n\n  return false;\n}\n\n\nmain(){\n  int r,c;\n  char tmp[20];\n\n\n  while(cin>>r >>c && r){\n    _r=r;_c=c;\n    Piece in[10];\n    Piece sol[10];\n    rep(i,10)in[i].Put.clear(),sol[i].Put.clear();\n    int white = 0;\n    rep(i,r){\n      cin>>inp[i];\n      rep(j,c){\n\tif ( inp[i][j]=='#')m[i][j]=FILLED;\n\telse m[i][j]=UNFILLED,white++;\n      }\n    }\n    int n;\n    cin>>n;\n    rep(k,n){\n      cin>>in[k].r[0]>>in[k].c[0];\n      in[k].black=0;\n      rep(i,in[k].r[0]){\n\tcin>>tmp;\n\trep(j,in[k].c[0]){\n\t  if ( tmp[j] == '#')in[k].m[0][i][j]=FILLED,in[k].black++;\n\t  else in[k].m[0][i][j]=UNFILLED;\n\t}\n      }\n      duplicate_check(in[k]);\n    }\n    \n\n\n    construct(n,in,r,c);\n\n    int q;\n    int test[10];\n    cin>>q;\n    rep(i,q){\n      int m;\n      cin>>m;\n      int total=0,ind;\n      rep(j,m){\n\tcin>>ind;\n\ttest[j]=ind;\n\ttotal+=in[ind-1].black;\n\tsol[j]=in[ind-1];\n      }      \n\n      rep(j,m){\n\tif(  test[j] >n)total=-1;\n\tREP(k,j+1,m)if (test[j] == test[k])total=-1;\n      }\n      if ( white !=total){puts(\"NO\");continue;}\n      \n      //sort(sol,sol+m);\n      \n      if ( solve(m,0,sol) )puts(\"YES\");\n      else puts(\"NO\");\n      \n    }\n\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint state[10][10];\nint ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = 1 - state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = 1 - ans[y][x];\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        for (int j=0; j<10; ++j) {\n            if ((bt>>j) % 10 == 1) {\n                pass(0, j);\n            }\n        }\n        for (int i=1; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i-1][j] == 1) {\n                    pass(i, j);\n                }\n            }\n        }\n        bool ok = true;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) ok = false;\n            }\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        solve();\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool canPut(int y, int x){\n\tint sy = y - 1;\n\tint ty = y + 1;\n\tint sx = x - 1;\n\tint tx = x + 1;\n\tif(sy < 0 || ty >= 10 || sx < 0 || tx >= 10)return false;\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1 && canPut(ny, nx)){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tdfs(0);\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tcout << used[y][x] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={0,0,0,1,-1},dy[]={-1,1,0,0,0};\n\nint d[10][10], b[10][10], a[10][10];\n\nvoid flip(int x, int y) {\n  a[y][x]=1;\n  for(int i=0; i<5; i++) {\n    b[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n  }\n}\n\nint main() {\n\n  int n;\n  cin>> n;\n  while(n--) {\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcin>> d[i][j];\n      }\n    }\n\n    for(int i=0; i<1024; i++) {\n      memset(a, 0, sizeof(a));\n      memcpy(b, d, sizeof(b));\n      for(int j=0; j<10; j++) {\n\tif((i>>j-1) & 1) flip(j, 0);\n      }\n\n      for(int j=1; j<10; j++) {\n\tfor(int k=0; k<10; k++) {\n\t  if(b[j-1][k]) flip(k, j);\n\t}\n      }\n\n      int cnt=0;\n      for(int j=0; j<10; j++) {\n\tif(b[9][j]){\n\t  cnt++; break;\n\t}\n      }\n\n      if(!cnt) break;\n    }\n\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcout << a[i][j]<< (j==9 ? \"\" : \" \");\n      }\n      cout<< endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,0,-1},dy[] = {1,0,-1,0,0};\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tif(m) cout << endl;\n\t\tint a[10][10],b[10][10] = {};\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\tfor(int k = 0;k < 10;k++) cin >> a[j][k];\n\t\t}\n\t\tfor(int j = 0;j < 1024;j++){\n\t\t\tint t[10][10];\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tt[k][l] = a[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(j >> k & 1){\n\t\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\t\tint nx = dx[l],ny = k + dy[l];\n\t\t\t\t\t\tif(ny >= 0 && ny < 10){\n\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 9;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tif(t[k][l]){\n\t\t\t\t\t\tb[k + 1][l] = 1;\n\t\t\t\t\t\tfor(int n = 0;n < 5;n++){\n\t\t\t\t\t\t\tint nx = k + 1 + dx[n],ny = l + dy[n];\n\t\t\t\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(t[9][k]) flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\t\tfor(int l = 0;l < 10;l++) {\n\t\t\t\t\t\tcout << (!l ? \"\" : \" \") << b[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(temp[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(temp[ny][nx] == 1) temp[ny][nx] = 0;\n\t\t\t\telse temp[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int y,int x)\n{\n\trep(i,10) rep(j,10) temp[i][j] = f[i][j];\n\tans.clear();\n\tREP(i,1,9)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(temp[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(ny < 0 || ny >= 10 || nx < 0 || nx >= 10)continue;\n\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tif(!dfs(0)){\n\t\twhile(1);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tif(t > 0)cout << endl;\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tif(y > 0)cout << endl;\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tif(x > 0)cout << \" \";\n\t\t\t\tcout << used[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nvoid frip(int y, int x, int map[10][10]){\n\tif(y < 0 || x < 0 || y >= 10 || x >= 10){\n\t\treturn;\n\t}else{\n\t\tmap[y][x] = !map[y][x];\n\t}\n}\n\nvoid frips(int y, int x, int map[10][10]){\n\tfrip(y - 1, x, map);\n\tfrip(y + 1, x, map);\n\tfrip(y, x, map);\n\tfrip(y, x - 1, map);\n\tfrip(y, x + 1, map);\n}\n\nint main(){\n\t\n\tint n;\n\t\n\tint origin[10][10];\n\t\n\tint f_point[10][10];\n\t\n\tint map[10][10];\n\t\n\tbool checker;\n\t\n\tcin >> n;\n\t\n\tint N = 10;\n\n\tfor(int loop = 0; loop < n; loop++){\n\t\t\n\t\tif(loop != 0){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tcin >> origin[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1 << N); i++){\n\t\t\t\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tfor(int y = 0; y < N; y++){\n\t\t\t\t\tmap[y][x] = origin[y][x];\n\t\t\t\t\tf_point[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int x = 0; x < N; x++){\n\t\t\t\tif((i & (1 << (N - x - 1))) != 0){\n\t\t\t\t\tfrips(0, x, map);\n\t\t\t\t\tf_point[0][x] = 1;\n\t\t\t\t}else{\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 1; y < N; y++){\n\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\tif(map[y - 1][x]){\n\t\t\t\t\t\tfrips(y, x, map);\n\t\t\t\t\t\tf_point[y][x] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchecker = true;\n\t\t\t\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tif(map[N - 1][x]){\n\t\t\t\t\tchecker = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(checker){\n\t\t\t\tfor(int y = 0; y < N; y++){\n\t\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\t\tif(f_point[y][x]){\n\t\t\t\t\t\t\tprintf(\"1 \");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tprintf(\"0 \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P pair<int, int>\nconst int H = 10;\nconst int W = 10;\n\nint my[5] = {1, -1, 0, 0, 0};\nint mx[5] = {0, 0, 1, -1, 0};\n\nvector< vector<int> > ans;\n\nbool end(int v[H][W]){\n  REP(i, H) REP(j, W) if(v[i][j] == 1) return false;\n  return true;\n}\n\nbool next(int v[H][W], int y, int x){\n  int a = 0, b = 0;\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n      if(v[ny][nx]) ++a;\n      else ++b;\n    }\n  }\n  return a > b;\n}\n\nvoid rev(int v[H][W], int y, int x){\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = (v[ny][nx] + 1) % 2;\n  }\n}\n\nvoid dfs(int y, int x, int v[H][W], vector< vector<int> > &u){\n  if(end(v)) { ans = u; return ; }\n  FOR(i, y, H){\n    REP(j, W){\n      if(i == y && j <= x) continue;\n      if(!next(v, i, j) || u[i][j]) continue;\n      rev(v, i, j);\n      u[i][j] = 1;\n      dfs(i, j, v, u);\n      u[i][j] = 0;\n      rev(v, i, j);\n    }\n  }\n}\n\nint main() {\n  int T; cin >>T;\n  REP(t, T){\n    ans = vector< vector<int> >();\n    int v[H][W];\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    vector< vector<int> > u(H, vector<int>(W, 0));\n    dfs(0, -1, v, u);\n    REP(i, H){\n      REP(j, W) cout <<ans[i][j] <<(j + 1 == W ? \"\" : \" \");\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[5] = {0,0,0,1,-1};\nint dy[5] = {0,1,-1,0,0};\nvector<vector<int> > solve(vector<vector<int> > m_){\n\tvector<vector<int> > ans = m_;\n\t\n\t// 0..1023 ツづδ仰ーツプ, iツづ個各ツビツッツトツづ債暗ェツ氾板湘」ツづ個猟アツ子ツづ個督鳴づ陛サツづーツ表ツつキ\n\tfor(int i=0 ; i < 1024 ; i++ ){\n\t\tvector<vector<int> > m = m_;\n\t\tint d[10][10] = {0};\n\t\t\n\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\t// i ツづ警ツ氾板姪堋づ個ビツッツトツづーツ偲ヲツづィツ出ツつキ\n\t\t\tif( i & (1 << x) ){\n\t\t\t\td[0][x] = 1;\n\t\t\t\tfor(int j=0 ; j < 5 ; j++ ){\n\t\t\t\t\tint mx = x + dx[j];\n\t\t\t\t\tint my = 0 + dy[j];\n\t\t\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\t\t\tm[my][mx] = (m[my][mx])? 0 : 1 ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=1 ; y < 10 ; y++ ){\n\t\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\t\tif( m[y-1][x] == 1 ){\n\t\t\t\t\td[y][x] = 1;\n\t\t\t\t\tfor(int j=0 ; j < 5 ; j++ ){\n\t\t\t\t\t\tint mx = x + dx[j];\n\t\t\t\t\t\tint my = y + dy[j];\n\t\t\t\t\t\tif( mx < 0 || my < 0 || mx >= 10 || my >= 10 ) continue;\n\t\t\t\t\t\tm[my][mx] = (m[my][mx])? 0 : 1 ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool flag = true;\n\t\tfor(int y=0 ; y < 10 ; y++ ){\n\t\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\t\tif( m[y][x] ){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( flag ){\n\t\t\tfor(int y=0 ; y < 10 ; y++ ){\n\t\t\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\t\t\tans[y][x] = d[y][x];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor( ; n-- ; ){\n\t\tvector<vector<int> > m(10);\n\t\t\n\t\tfor(int y=0 ; y < 10 ; y++ ){\n\t\t\tvector<int> v(10);\n\t\t\tm[y] = v;\n\t\t\t\n\t\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\t\tcin >> m[y][x];\n\t\t\t}\n\t\t}\n\t\tvector<vector<int> > ans = solve( m );\n\t\tfor(int y=0 ; y < 10 ; y++ ){\n\t\t\tfor(int x=0 ; x < 10 ; x++ ){\n\t\t\t\tcout << ans[y][x];\n\t\t\t\tif( x != 9 ) \n\t\t\t\t\tcout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++)\n    if( 0<=y+dy[k] && 0<=x+dx[k] && y+dy[k]<10 && x+dx[k]<10)\n      b[y+dy[k]][x+dx[k]]=b[y+dy[k]][x+dx[k]]?0:1;\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++)\n    if(p[i])rev(i,0);\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n\telse cout << endl;\n      }\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    p[cnt]=0;\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool field[11][11], ans[11][11];\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcin >> field[i][j];\n      }\n    }\n    \n    for(int y = 0 ; y < 10 ; y++){\n      for(int x = 0 ; x < 10 ; x++){\n\tif(y == 0 && x == 0){\n\t  if(field[0][0] && field[0][1] && field[1][0] && field[1][1]) ans[0][0] = 1;\n\t}\n\telse if(y == 0 && x == 9){\n\t  if(field[0][9] && field[0][8] && field[1][8] && field[1][9]) ans[0][9] = 1;\n\t}\n\telse if(y == 9 && x == 0){\n\t  if(field[9][0] && field[8][0] && field[8][1] && field[9][1]) ans[9][0] = 1;\n\t}\n\telse if(y == 9 && x == 9){\n\t  if(field[9][9] && field[9][8] && field[8][9] && field[8][8]) ans[9][9] = 1;\n\t}\n\telse if(y == 0){\n\t  if(field[0][x] && field[0][x+1] && field[1][x] && field[0][x-1]) ans[0][x] = 1;\n\t}\n\telse if(x == 0){\n\t  if(field[y][0] && field[y+1][0] && field[y][1] && field[y-1][0]) ans[y][0] = 1;\n\t}\n\telse if(field[y][x] && field[y-1][x] && field[y+1][x] && field[y][x-1] && field[y][x+1]){\n\t  ans[y][x] = 1;\n\t}\n\telse if(!field[y][x] && !field[y][x+1] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y+1][x] && field[y+1][x+1] && field[y-1][x+1] &&\n\t\tfield[y][x+2]){\n\t  ans[y][x] = 1, ans[y][x+1] = 1;\n\t}\n      }\n    }\n\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcout << ans[i][j];\n\tif(j != 9) cout << ' ';\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        \n        bool box[12][12]={0};\n        \n        for(int i=1; i<=10; i++){\n            for(int j=1; j<=10; j++){\n                cin>>box[i][j];\n            }\n        }\n        //cout<<\"----------------------\"<<endl;\n        \n        bool box2[12][12]={0};\n\n        for(int i=0; i<(1<<10 - 1); i++){\n            memcpy(box2, box, sizeof(box));\n            int l[12][12]={0};\n            for(int j=1; j<=10; j++){\n                l[0][j]= (i>>j)%2;\n            }\n            \n            for(int j=1; j<=10; j++){\n                for(int k=1; k<=10; k++){\n                    if(l[j-1][k]==1){\n                        box2[j][k]=(box2[j][k]+1)%2;\n                        box2[j][k+1]=(box2[j][k+1]+1)%2;\n                        box2[j][k-1]=(box2[j][k-1]+1)%2;\n                        box2[j-1][k]=(box2[j-1][k]+1)%2;\n                        box2[j+1][k]=(box2[j+1][k]+1)%2;\n                    }\n                }\n                \n                for(int k=1; k<=10; k++){\n                    l[j][k]=box2[j][k];\n                }\n            }\n            \n            bool end_flag=true;\n            for(int i=1; i<=10; i++){\n                if(l[10][i]==1){\n                    end_flag=false;\n                    break;\n                }\n            }\n            \n            \n            if(end_flag){\n                for(int i=0; i<=9; i++){\n                    for(int j=1; j<=10; j++){\n                        cout<<l[i][j];\n                        if(j==10)break;\n                        cout<<\" \";\n                    }\n                    if(i==9)break;\n                    cout<<endl;\n                }\n                break;\n                \n            }\n        }\n        //cout<<\"============================\"<<endl;\n\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nstruct UF {\n    vi e;\n    UF(int n) : e(n, -1) {}\n    bool same_set(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\n    void join(int a, int b) {\n        a = find(a), b = find(b);\n        if(a == b) return;\n        if(e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n    }\n};\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    while(n--) {\n\n        vector<vector<int>> v(10);\n\n        for(int i=0; i<10; ++i){\n            for(int j=0; j<10; ++j){\n                int a; cin >> a;\n                v[i].push_back(a);\n            }\n        }\n\n        bool f = false;\n        for(int bit=0; bit<(1<<10); ++bit){\n            int arr[15][15]={0};\n\n            int ans[10][10]={0};\n            for(int i=0; i<10; ++i){\n                if(bit >> i & 1){\n                    ans[0][i]=1;\n                    if(i==0){\n                        arr[0][0] ^= 1;\n                        arr[1][0] ^= 1;\n                        arr[0][1] ^= 1;\n                    }else if(i==9){\n                        arr[0][i] ^= 1;\n                        arr[1][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                    }else{\n                        arr[0][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                        arr[0][i+1] ^= 1;\n                        arr[1][i] ^= 1;\n                    }\n                }\n            }\n\n            for(int i=1; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i-1][j] == 0 && v[i-1][j]==1){\n                        ans[i][j]=1;\n                        if(j==0){\n                            arr[i][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }else if(j==9){\n                            arr[i][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                        }else{\n                            arr[i][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }\n                    }\n                }\n            }\n            bool d = true;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i][j]!=v[i][j]) d= false;\n                }\n            }\n            if(!d) continue;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(j) cout << \" \";\n                    cout << ans[i][j];\n                }\n                cout << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\nint dx[]={-1,0,1,0,0};\nint dy[]={0,-1,0,1,0};\n\nint main() {\n\tint n ; cin >> n ;\n\twhile(n--){\n\t\tint field[10][10];\n\t\tfor(int i=0;i<10;i++) for(int j=0;j<10;j++) cin >> field[i][j];\n\t\tint tmp_ans[10][10]={0}; bool failed=false;\n\t\tint tmp_field[10][10];\n\t\tfor(int i=0;i<1<<10;i++){\n\t\t\tmemset(tmp_ans,0,sizeof(tmp_ans));\n\t\t\tmemcpy(tmp_field,field,sizeof(field));\n\t\t\tfor(int j=0;j<10;j++) tmp_ans[0][10-1-j]= i>>j & 1;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif(tmp_ans[0][j]){\n\t\t\t\t\tfor(int m=0;m<=4;m++)\n\t\t\t\t\t\tif(0<=j+dx[m] && j+dx[m]<10 && 0<=dy[m] ) (tmp_field[dy[m]][j+dx[m]])^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int l=1;l<10;l++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(tmp_field[l-1][k]){\n\t\t\t\t\t\ttmp_ans[l][k]=true;\n\t\t\t\t\t\tfor(int m=0;m<=4;m++)\n\t\t\t\t\t\t\tif(0<=k+dx[m] && k+dx[m]<10 && 0<=l+dy[m] && l+dy[m]<10) tmp_field[l+dy[m]][k+dx[m]]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<10;j++) if(tmp_field[9][j]) failed=true;\n\t\t\tif(!failed) break;\n\t\t}\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++) {if(j) cout << ' ' ; cout << tmp_ans[i][j] ;}\n\t\t\tcout << '\\n' ;\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool field[11][11], ans[11][11];\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcin >> field[i][j];\n      }\n    }\n    \n    memset(ans, 0, sizeof(ans));\n    \n    for(int y = 0 ; y < 10 ; y++){\n      for(int x = 0 ; x < 10 ; x++){\n\tif(y == 0 && x == 0){\n\t  if(field[0][0] && field[0][1] && field[1][0] && field[1][1]) ans[0][0] = 1;\n\t}\n\telse if(y == 0 && x == 9){\n\t  if(field[0][9] && field[0][8] && field[1][8] && field[1][9]) ans[0][9] = 1;\n\t}\n\telse if(y == 9 && x == 0){\n\t  if(field[9][0] && field[8][0] && field[8][1] && field[9][1]) ans[9][0] = 1;\n\t}\n\telse if(y == 9 && x == 9){\n\t  if(field[9][9] && field[9][8] && field[8][9] && field[8][8]) ans[9][9] = 1;\n\t}\n\telse if(y == 0){\n\t  if(field[0][x] && field[0][x+1] && field[1][x] && field[0][x-1]) ans[0][x] = 1;\n\t}\n\telse if(x == 0){\n\t  if(field[y][0] && field[y+1][0] && field[y][1] && field[y-1][0]) ans[y][0] = 1;\n\t}\n\telse if(y == 9){\n\t  if(field[9][x] && field[9][x+1] && field[8][x] && field[9][x-1]) ans[9][x] = 1;\n\t}\n\telse if(x == 9){\n\t  if(field[y][9] && field[y+1][9] && field[y][8] && field[y-1][9]) ans[y][0] = 1;\n\t}\n\telse if(field[y][x] && field[y-1][x] && field[y+1][x] && field[y][x-1] && field[y][x+1]){\n\t  ans[y][x] = 1;\n\t}\n\telse if(!field[y][x] && !field[y][x+1] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y+1][x] && field[y+1][x+1] && field[y-1][x+1] &&\n\t\tfield[y][x+2]){\n\t  ans[y][x] = 1, ans[y][x+1] = 1;\n\t}\n\telse if(!field[y][x] && !field[y+1][x] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y][x+1] && field[y+1][x-1] && field[y+1][x+1] &&\n\t\tfield[y+2][x]){\n\t  ans[y][x] = 1, ans[y+1][x] = 1;\n\t}\n      }\n    }\n    \n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcout << ans[i][j];\n\tif(j != 9) cout << ' ';\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define SIZE 10\nusing namespace std;\n\nclass State{\npublic:\n  int data[SIZE][SIZE];\n  int put[SIZE][SIZE];\n  State() {\n    fill((int*)put, (int*)put+SIZE*SIZE, 0);\n  }\n  void puts(int x, int y) {\n    static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n    put[y][x] = 1;\n    for(int k = 0; k < 5; k++) {\n      int nx = x + d[k][0];\n      int ny = y + d[k][1];\n      if(nx < 0 || nx >= SIZE) continue;\n      if(ny < 0 || ny >= SIZE) continue;\n      data[ny][nx] = -(data[ny][nx] - 1);\n    }\n  }\n  bool isAll0() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(data[i][j] != 0) return false;\n      }\n    }\n    return true;\n  }\n  void show() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcout << put[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool rec(State s, int x, int y) {\n  static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n  if(s.isAll0()) {\n    s.show();\n    return true;\n  }\n\n  for(int i = y; i < SIZE; i++) {\n    for(int j = x; j < SIZE; j++) {\n      bool flag = false;\n      for(int k = 0; k < 5; k++) {\n\tint nx = j + d[k][0];\n\tint ny = i + d[k][1];\n\tif(nx < 0 || nx >= SIZE) continue;\n\tif(ny < 0 || ny >= SIZE) continue;\n\tif(s.data[ny][nx] == 1) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      flag = true;\n      if(flag) {\n\tif(i > 0 && s.data[i-1][j] == 0) continue;\n\tState tmp = s;\n\ttmp.puts(j, i);\n\tint nx, ny;\n\tnx = j + 1;\n\tny = i;\n\tif(nx >= SIZE) {\n\t  nx = 0;\n\t  ny++;\n\t}\n\tif(rec(tmp, nx, ny)) {\n\t  return true;\n\t}\n\tif(i > 0 && s.data[i-1][j] == 1) return false;\n      }\n    }\n  }\n  return false;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    State s;\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcin >> s.data[i][j];\n      }\n    }\n    rec(s, 0, 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint state[10][10];\nint ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = 1 - state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = 1 - ans[y][x];\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int j=0; j<10; ++j) {\n            if ((bt>>j) & 1) {\n                pass(0, j);\n            }\n        }\n        for (int i=1; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i-1][j] == 1) {\n                    pass(i, j);\n                }\n            }\n        }\n        bool ok = true;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) ok = false;\n            }\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        solve();\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(y==1){\n\t\tnow[x][y]=0;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\tflip(x,y);\n\t\t\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tnow[x][y]=0;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,-1,sizeof(res));\n\t\tcheck(1,1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum{W=10,H=10};\n\nbool clear(bool field[H+2][W+2]){\n  bool ok=true;\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)if(field[i][j])ok=false;\n  return ok;\n}\n\nint main(){\n  int n;\n  bool field[H+2][W+2];\n  bool dup[H+2][W+2];\n  int bit[H+2];\n  cin>>n;\n  while(n-->0){\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>field[i][j];\n    for(bit[1]=0; bit[1] < (1<<10); bit[1]++){\n      for(int i=2;i<=H;i++)bit[i]=0;\n      for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)dup[i][j]=field[i][j];\n      for(int j=1;j<=W;j++){\n        if(!((bit[1]>>j)&1))continue;\n        dup[0][j]^=1;\n        dup[0][j-1]^=1;\n        dup[0][j+1]^=1;\n        dup[0-1][j]^=1;\n        dup[0+1][j]^=1;\n      }\n      for(int i=2;i<=H;i++){\n        for(int j=1;j<=W;j++){\n          if(dup[i-1][j]){\n            bit[i]^=(1<<j);\n            dup[i][j]^=1;\n            dup[i][j-1]^=1;\n            dup[i][j+1]^=1;\n            dup[i-1][j]^=1;\n            dup[i+1][j]^=1;\n          }\n        }\n      }\n      if(clear(dup))break;\n    }\n    for(int i=1;i<=H;i++){\n      for(int j=1;j<=W;j++){\n        if(j!=1)cout<<\" \";\n        if(bit[i]&(1<<j))cout<<\"1\";\n      else cout<<\"0\";\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={0,0,0,1,-1},dy[]={-1,1,0,0,0};\n\nint d[10][10], b[10][10], a[10][10];\n\nvoid flip(int x, int y) {\n  a[y][x]=1;\n  for(int i=0; i<5; i++) {\n    b[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n  }\n}\n\nint main() {\n\n  int n;\n  cin>> n;\n  while(n--) {\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcin>> d[i][j];\n      }\n    }\n\n    for(int i=0; i<1024; i++) {\n      memset(a, 0, sizeof(a));\n      memcpy(b, d, sizeof(b));\n      for(int j=0; j<10; j++) {\n\tif((i>>j) & 1) flip(j, 0);\n      }\n\n      for(int j=1; j<10; j++) {\n\tfor(int k=0; k<10; k++) {\n\t  if(b[j-1][k]) flip(k, j);\n\t}\n      }\n\n      int cnt=0;\n      for(int j=0; j<10; j++) {\n\tif(b[9][j]){\n\t  cnt++; break;\n\t}\n      }\n\n      if(!cnt) break;\n    }\n\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcout << a[i][j]<< (j==9 ? \"\" : \" \");\n      }\n      cout<< endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,s,y,x,i;\nint d[12][12],b[12][12],a[12][12];\nint dx[] = { 0,0,0,1,-1};\nint dy[] = {-1,1,0,0, 0};\n\nvoid flip(int x, int y)\n{\n\ta[y][x] = 1;\n\tfor(int i=0; i<5; i++)\n\t{\n\t\tb[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\twhile(n--)\n\t{\n\t\tfor(y=1; y<=10; y++)\n\t\tfor(x=1; x<=10; x++)\n\t\t{\n\t\t\tcin >> d[y][x];\n\t\t}\n\t\tfor(i=0; i<1024; i++)\n\t\t{\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tmemcpy(b,d,sizeof(d));\n\n\t\t\tfor(y=1,x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tif((i>>(x-1))&1) flip(x,y);\n\t\t\t}\n\n\t\t\tfor(y=2; y<=10; y++)\n\t\t\tfor(x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tif(b[y-1][x]) flip(x,y);\n\t\t\t}\n\n\t\t\tfor(y=10,x=1,s=0; x<=10; x++)\n\t\t\t{\n\t\t\t\ts+=b[y][x];\n\t\t\t}\n\n\t\t\tif(s==0) break;\n\t\t}\n\n\t\tfor(y=1; y<=10; y++)\n\t\t{\n\t\t\tfor(x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tcout << a[y][x] << (x==10?\"\":\" \");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nint memo[11][1024];\n\nint main(){\n\tint sw[1024];\n\tfor(int i=0;i<1024;i++){\n\t\tsw[i]=0;\n\t\tif(i&1)\t\tsw[i]^=3;\n\t\tfor(int j=1;j<9;j++)\tif(i&(1<<j))\tsw[i]^=(7<<(j-1));\n\t\tif(i&512)\tsw[i]^=768;\n\t}\n\n\tint t;\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint cell[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcell[i]=0;\n\t\t\tfor(int j=0,tmp;j<10;j++)\tscanf(\"%d\",&tmp),cell[i]|=(tmp<<(9-j));\n\t\t}\n\n\t\tfor(int i=0;i<1024;i++)\tmemo[0][i]=0;\n\t\tfor(int r=1;r<10;r++){\n\t\t\tfor(int i=0;i<1024;i++){\n\t\t\t\tmemo[r][i]=-1;\n\t\t\t\tfor(int b=0;b<1024;b++){\n\t\t\t\t\tif(memo[r-1][b]==-1)\tcontinue;\n\t\t\t\t\tif((cell[r-1]^memo[r-1][b]^sw[b]^i)==0)\tmemo[r][i]=b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[10];\n\t\tfor(int i=0,j=memo[10-i][0];i<10;i++,j=memo[10-i][j])\tans[i]=j;\n\t\tfor(int i=9;i>=0;i--){\n\t\t\tprintf(\"\");\n\t\t\tfor(int k=9;k>=0;k--)\tprintf(\"%s%d\",(k==9?\"\":\" \"),(bool)(ans[i]&(1<<k)));\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int all = (1 << 10) - 1;\n\nint board[12][12];\nint mask[12];\nint conv[(1<<10)+10];\nint save[12];\n\nint main(){\n\tfor(int line=0;line<1<<10;++line){\n\t\tint m = 0;\n\n\t\tfor(int i=0;i<10;++i){\n\t\t\tif((line >> i) & 1){\n\t\t\t\tm ^= 7 << i;\n\t\t\t}\n\t\t}\n\n\t\tconv[line] = (m >> 1) & all;\n\t}\n\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;++t){\n\t\tfor(int y=0;y<10;++y){\n\t\t\tint m = 0;\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tcin >> board[y][x];\n\t\t\t}\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tm = (m << 1) + board[y][x];\n\t\t\t}\n\t\t\tmask[y] = m;\n\t\t}\n\n\t\tbool found = false;\n\t\tfor(int line=0;line<1<<10;++line){\n\t\t\tint prev = mask[0] ^ conv[line];\n\t\t\tint curr = mask[1] ^ line;\n\n\t\t\tsave[0] = line;\n\n\t\t\tfor(int y=1;y<9;++y){\n\t\t\t\tint doit = prev;\n\t\t\t\tint nprev = curr ^ conv[doit];\n\t\t\t\tint ncurr = mask[y+1] ^ doit;\n\n\t\t\t\tprev = nprev;\n\t\t\t\tcurr = ncurr;\n\n\t\t\t\tsave[y] = doit;\n\t\t\t}\n\n\t\t\tsave[9] = prev;\n\n\t\t\tif(curr ^ prev){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int y=0;y<10;++y){\n\t\t\t\tint m = save[y];\n\t\t\t\tfor(int x=9;x>=0;--x){\n\t\t\t\t\tif(x != 9)cout << \" \";\n\t\t\t\t\tcout << (((m >> x) & 1) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\n\t\tif(!found)while(true);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint t[10][10],u[10][10],ans[10][10],n,flg;\nint compute();\nvoid dfs(int);\nvoid change(int,int);\nint main(){\n  cin>>n;\n  while(n--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\nvoid dfs(int x){\n  if(x==10){\n    if(compute()){\n      for(int i=0;i<10;i++){\n\tfor(int j=0;j<10;j++){\n\t  if(j)cout<<' ';\n\t  cout<<ans[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n    return;\n  }\n  ans[0][x]=0;\n  dfs(x+1);\n  ans[0][x]=1;\n  dfs(x+1);\n}\n\nint compute(){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      u[i][j]=t[i][j];\n\n  for(int i=0;i<10;i++){\n    if(ans[0][i])change(0,i);\n  }\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(u[i-1][j]){\n\tans[i][j]=1;\n\tchange(i,j);\n      }\n    }\n  }\n  for(int i=0;i<10;i++){\n    if(u[9][i])return 0;\n  }\n  return 1;\n}\n\nvoid change(int y,int x){\n  u[y][x]=!u[y][x];\n  if(y>0)u[y-1][x]=!u[y-1][x];\n  if(x>0)u[y][x-1]=!u[y][x-1];\n  if(y<9)u[y+1][x]=!u[y+1][x];\n  if(x<9)u[y][x+1]=!u[y][x+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int dx[] = {0, 0, 0, 1, -1};\nconst int dy[] = {0, 1, -1, 0, 0};\n\nvoid reverse(vector<vint>& board, int x, int y)\n{\n\trep(i, 5)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\n\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\tboard[nx][ny] = !board[nx][ny];\n\t}\n}\n\n\nvoid bitinitialize(vector<vint>& board, vector<vint>& ans, int bit)\n{\n\trep(i, 10) if(bit & 1 << i)\n\t{\n\t\treverse(board, i, 0);\n\t\tans[i][0] = 1;\n\t}\n}\n\n\nvoid fill(vector<vint>& board, vector<vint>& ans)\n{\n\tREP(y, 1, 10) rep(x, 10)\n\t{\n\t\tif(board[x][y-1])\n\t\t{\n\t\t\treverse(board, x, y);\n\t\t\tans[x][y] = 1;\n\t\t}\n\t}\n}\n\n\nbool check(vector<vint>& board)\n{\n\trep(i, 10) rep(j, 10)\n\t\tif(board[i][j]) return false;\n\t\n\treturn true;\n}\n\n\nint main()\n{\n    int n;\n\tcin >> n;\n\t\n\twhile(n--)\n\t{\n\t\tvector<vint> answer(10, vint(10));\n\t\t\n\t\trep(y, 10) rep(x, 10)\n\t\t\tcin >> answer[x][y];\n\t\t\n\t\trep(bit, 1 << 10)\n\t\t{\n\t\t\tvector<vint> board(answer);\n\t\t\tvector<vint> ans(10, vint(10, 0));\n\t\t\t\n\t\t\tbitinitialize(board, ans, bit);\n\t\t\t\n\t\t\tfill(board, ans);\n\t\t\t\t\t\t\n\t\t\tif(check(board))\n\t\t\t{\n\t\t\t\trep(y, 10) rep(x, 10)\n\t\t\t\t\tcout << ans[x][y] << (x == 9 ? \"\\n\" : \" \");\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\twhile(n--){\n\t\tint panel[10]={},ans[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp-(panel[j]>>k)&1)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans[9]==0){\n\t\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\t\tint tmp=(ans[i]>>j)&1;\n\t\t\t\t\t\tprintf(j==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint souchi[11][11];\nint xx[]={1,-1,0,0,0};\nint yy[]={0,0,1,-1,0};\n\nvoid f(int a,int b){\n\tint i;\n\tfor(i=0;i<5;i++){\n\t\tif(a+xx[i]<0||10<=a+xx[i]||b+yy[i]<0||10<=b+yy[i])continue;\n\t\tsouchi[a+xx[i]][b+yy[i]]^=1;\n\t}\n}\n\nint main() {\n\tint n=in();\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tint a,b;\n\t\tint tmp[11][11];\n\t\tint res[11][11];\n\t\tfor(a=0;a<10;a++){\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tcin>>tmp[a][b];\n\t\t\t}\n\t\t}\n\t\tint bit;\n\t\tfor(bit=0;bit<1<<10;bit++){\n\t\t\tfor(a=0;a<10;a++){\n\t\t\t\tfor(b=0;b<10;b++){\n\t\t\t\t\tsouchi[a][b]=tmp[a][b];\n\t\t\t\t\tres[a][b]=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tif(bit>>b&1){\n\t\t\t\t\tf(0,b);\n\t\t\t\t\tres[0][b]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(a=0;a<9;a++){\n\t\t\t\tfor(b=0;b<10;b++){\n\t\t\t\t\tif(souchi[a][b]){\n\t\t\t\t\t\tf(a+1,b);\n\t\t\t\t\t\tres[a+1][b]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok=true;\n\t\t\tfor(b=0;b<10;b++){\n\t\t\t\tif(souchi[9][b])ok=false;\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tfor(a=0;a<10;a++){\n\t\t\t\t\tfor(b=0;b<10;b++){\n\t\t\t\t\t\tcout<<res[a][b]<<\" \";\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,0,-1},dy[] = {1,0,-1,0,0};\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tint a[10][10],b[10][10] = {};\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\tfor(int k = 0;k < 10;k++) cin >> a[j][k];\n\t\t}\n\t\tfor(int j = 0;j < 1024;j++){\n\t\t\tint t[10][10];\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tt[k][l] = a[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(j >> k & 1){\n\t\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\t\tint nx = dx[l],ny = k + dy[l];\n\t\t\t\t\t\tif(ny >= 0 && ny < 10){\n\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 9;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tif(t[k][l]){\n\t\t\t\t\t\tb[k + 1][l] = 1;\n\t\t\t\t\t\tfor(int n = 0;n < 5;n++){\n\t\t\t\t\t\t\tint nx = k + 1 + dx[n],ny = l + dy[n];\n\t\t\t\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(t[9][k]) flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\t\tfor(int l = 0;l < 10;l++) {\n\t\t\t\t\t\tcout << (!l ? \"\" : \" \") << b[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint L[10][10]; \nint F[10][10]; \nint R[10][10];\n\nvoid init() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            F[i][j] = 0;\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cin >> L[i][j];\n        }\n    }\n}\n\nbool check( int r, int c ) {\n    int b = L[r][c];\n    b ^= F[r][c];\n    if ( r - 1 >= 0 ) b ^= F[r-1][c];\n    if ( r + 1 < 10 ) b ^= F[r+1][c];\n    if ( c - 1 >= 0 ) b ^= F[r][c-1];\n    if ( c + 1 < 10 ) b ^= F[r][c+1];\n    return b == 1;\n}\n\nvoid output() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cout << F[i][j];\n            if ( j + 1 < 10 ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid flip( int r, int c ) {\n    int b = L[r][c];\n    b ^= F[r][c];\n    if ( r - 1 >= 0 ) b ^= F[r-1][c];\n    if ( r + 1 < 10 ) b ^= F[r+1][c];\n    if ( c - 1 >= 0 ) b ^= F[r][c-1];\n    if ( c + 1 < 10 ) b ^= F[r][c+1];\n    R[r][c] = b;\n}\n\nbool solve( int r ) {\n    if ( r >= 10 ) {\n        return true;\n    }\n    if ( r == 0 ) {\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                F[r][j] = i & ( 1 << j ) ? 1 : 0;\n            }\n            if ( solve( r + 1 ) ) return true;\n        }\n    } else if ( r < 10 ) {\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                F[r][j] = i & ( 1 << j ) ? 1 : 0;\n            }\n            bool flag = true;\n            for ( int j = 0; j < 10; ++ j ) {\n                if ( check( r - 1, j ) ) flag = false;\n            }\n            if ( flag && solve( r + 1 ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            init();\n            input();\n            solve( 0 );\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    while(--n >= 0){\n         vector<int> x(10);\n         for(int i=0; i<10; ++i){\n             int a = 1;\n             for(int j=0; j<10; ++j){\n                 int b;\n                 cin >> b;\n                 if(b)\n                     x[i] |= a;\n                 a <<= 1;\n             }\n         }\n\n         vector<vector<int> > dp(11, vector<int>(1<<10, 0));\n         for(int i=0; i<10; ++i){\n             for(int j=0; j<(1<<10); ++j){\n                 int tmp = x[i];\n                 tmp ^= dp[i][j];\n                 tmp ^= j;\n                 tmp ^= (j<<1) & ((1<<10)-1);\n                 tmp ^= (j>>1);\n                 dp[i+1][tmp] = j;\n             }\n         }\n\n         vector<int> ret(10);\n         int j = 0;\n         for(int i=9; i>=0; --i)\n             j = ret[i] = dp[i+1][j];\n\n         for(int i=0; i<10; ++i){\n             bitset<10> bs(ret[i]);\n             cout << bs[0];\n             for(int j=1; j<10; ++j)\n                 cout << ' ' << bs[j];\n             cout << endl;\n         }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define SIZE 10\nusing namespace std;\n\nclass State{\npublic:\n  int data[SIZE][SIZE];\n  int put[SIZE][SIZE];\n  State() {\n    fill((int*)put, (int*)put+SIZE*SIZE, 0);\n  }\n  void puts(int x, int y) {\n    static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n    put[y][x] = 1;\n    for(int k = 0; k < 5; k++) {\n      int nx = x + d[k][0];\n      int ny = y + d[k][1];\n      if(nx < 0 || nx >= SIZE) continue;\n      if(ny < 0 || ny >= SIZE) continue;\n      data[ny][nx] = -(data[ny][nx] - 1);\n    }\n  }\n  bool isAll0() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(data[i][j] != 0) return false;\n      }\n    }\n    return true;\n  }\n  void show() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcout << put[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool rec(State s, int x, int y) {\n  static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n  if(s.isAll0()) {\n    s.show();\n    return true;\n  }\n\n  for(int i = y; i < SIZE; i++) {\n    int j;\n    if(i == y) j = x;\n    else       j = 0;\n    for(; j < SIZE; j++) {\n      bool flag = false;\n      /*for(int k = 0; k < 5; k++) {\n\tint nx = j + d[k][0];\n\tint ny = i + d[k][1];\n\tif(nx < 0 || nx >= SIZE) continue;\n\tif(ny < 0 || ny >= SIZE) continue;\n\tif(s.data[ny][nx] == 1) {\n\t  flag = true;\n\t  break;\n\t}\n\t}*/\n      flag = true;\n      if(flag) {\n\tif(i > 0 && s.data[i-1][j] == 0) continue;\n\tState tmp = s;\n\ttmp.puts(j, i);\n\tint nx, ny;\n\tnx = j + 1;\n\tny = i;\n\tif(nx >= SIZE) {\n\t  nx = 0;\n\t  ny++;\n\t}\n\tif(rec(tmp, nx, ny)) {\n\t  return true;\n\t}\n\tif(i > 0 && s.data[i-1][j] == 1) return false;\n      }\n    }\n  }\n  return false;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    State s;\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcin >> s.data[i][j];\n      }\n    }\n    rec(s, 0, 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(f[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(f[ny][nx] == 1) f[ny][nx] = 0;\n\t\t\t\telse f[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int y,int x)\n{\n\t//cout << \"y:\" << y << \" x:\" << x << endl;\n\tans.clear();\n\trep(i,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(f[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(0,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(temp[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(temp[ny][nx] == 1) temp[ny][nx] = 0;\n\t\t\t\telse temp[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int y,int x)\n{\n\trep(i,10) rep(j,10) temp[i][j] = f[i][j];\n\tans.clear();\n\tREP(i,1,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(temp[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9 && x == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\t//cout << \"y:\" << y << \" x:\" << x << endl;\n\tif(f[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(f[ny][nx] == 1) f[ny][nx] = 0;\n\t\t\t\telse f[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int y,int x)\n{\n\t//cout << \"y:\" << y << \" x:\" << x << endl;\n\tans.clear();\n\tREP(i,1,9)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(f[i][j] == 1) cnt++;\n\t\t}\n\t}\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nvoid flip(vvi& a,int i,int j)\n{\n\tint di[]={-1,0,0,0,1};\n\tint dj[]={0,-1,0,1,0};\n\trep(k,5){\n\t\tint ni=i+di[k],nj=j+dj[k];\n\t\tif(0<=ni && ni<10 && 0<=nj && nj<10)\n\t\t\ta[ni][nj]^=1;\n\t}\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tvvi a(10,vi(10));\n\t\trep(i,10) rep(j,10)\n\t\t\tcin>>a[i][j];\n\t\trep(k,1<<10){\n\t\t\tvvi b=a;\n\t\t\tvvi res(10,vi(10));\n\t\t\trep(i,10)\n\t\t\t\tif(k&(1<<i))\n\t\t\t\t\tflip(b,0,i);\n\t\t\trepi(i,1,10)\n\t\t\t\trep(j,10)\n\t\t\t\t\tif(b[i-1][j]){\n\t\t\t\t\t\tflip(b,i,j);\n\t\t\t\t\t\tres[i][j]=1;\n\t\t\t\t\t}\n\t\t\tif(count(allof(b[9]),0)==10){\n\t\t\t\trep(i,10)\n\t\t\t\t\trep(j,10)\n\t\t\t\t\t\tcout<<res[i][j]<<(j==9?'\\n':' ');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nstruct UF {\n    vi e;\n    UF(int n) : e(n, -1) {}\n    bool same_set(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\n    void join(int a, int b) {\n        a = find(a), b = find(b);\n        if(a == b) return;\n        if(e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n    }\n};\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    int cnt=0;\n    while(n--) {\n        if(cnt) cout << endl;\n        cnt++;\n        vector<vector<int>> v(10);\n\n        for(int i=0; i<10; ++i){\n            for(int j=0; j<10; ++j){\n                int a; cin >> a;\n                v[i].push_back(a);\n            }\n        }\n\n        bool f = false;\n        for(int bit=0; bit<(1<<10); ++bit){\n            int arr[15][15]={0};\n\n            int ans[10][10]={0};\n            for(int i=0; i<10; ++i){\n                if(bit >> i & 1){\n                    ans[0][i]=1;\n                    if(i==0){\n                        arr[0][0] ^= 1;\n                        arr[1][0] ^= 1;\n                        arr[0][1] ^= 1;\n                    }else if(i==9){\n                        arr[0][i] ^= 1;\n                        arr[1][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                    }else{\n                        arr[0][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                        arr[0][i+1] ^= 1;\n                        arr[1][i] ^= 1;\n                    }\n                }\n            }\n\n            for(int i=1; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if((arr[i-1][j] == 0 && v[i-1][j]==1) || (arr[i-1][j]==1 && v[i-1][j]==0)){\n                        ans[i][j]=1;\n                        if(j==0){\n                            arr[i][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }else if(j==9){\n                            arr[i][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                        }else{\n                            arr[i][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }\n                    }\n                }\n            }\n            bool d = true;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i][j]!=v[i][j]) d= false;\n                }\n            }\n            if(!d) continue;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(j) cout << \" \";\n                    cout << ans[i][j];\n                }\n                cout << endl;\n            }\n            break;\n        }\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-- > 0){\n    int imap[11][11],syokurin[11][11];\n    rep(i,10){\n      rep(j,10){\n\tsyokurin[i][j] = 0;\n\tcin >> imap[i][j];\n      }\n    }\n\n    rep(i,10){\n      rep(j,10){\n\tif(imap[i][j] == 0)continue;\n\tsyokurin[i][j]++;\n\trep(k,4){\n\t  int nx = j+dx[k],ny = i+dy[k];\n\t  if(!(0<=nx && nx <10 && 0<=ny && ny <10))continue;\n\t  syokurin[ny][nx]++;\n\t}\n      }\n    }\n\n    rep(i,10){\n      rep(j,10){\n\tif(syokurin[i][j] == 1)cout << 0;\n\telse syokurin[i][j]%2 == 0?cout << 0:cout << 1;\n\tif(j!=9)cout << \" \";\n      }\n      cout << endl;\n    }\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int state[10][10];\n    int ans[10][10];\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) {\n                    state[i][j]     = 1 - state[i][j];\n                    state[i+1][j-1] = 1 - state[i+1][j-1];\n                    state[i+1][j]   = 1 - state[i+1][j];\n                    state[i+1][j+1] = 1 - state[i+1][j+1];\n                    state[i+2][j]   = 1 - state[i+2][j];\n                    ans[i+1][j] = 1;\n                }\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(_Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,_Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int dir[][2] = {{0,0},{1,0},{-1,0},{0,1},{0,-1}};\n\nint dfs(int n, vector<vector<int> > &v, vector<vector<int> > &f){\n    pf(\"---- %d ----\\n\", n);\n    REP(y,10) pr(join(v[y]));\n\n    if(n < 10){\n        int y = n / 10, x = n % 10, ret;\n\n        ret = dfs(n+1,v,f);\n        if(ret > 0) return 1;\n        REP(j,5){\n            int mx = x + dir[j][0], my = y + dir[j][1];\n            if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n            v[my][mx] ^= 1;\n        }\n        f[y][x] = 1;\n\n        ret = dfs(n+1,v,f);\n        if(ret > 0) return 1;\n        REP(j,5){\n            int mx = x + dir[j][0], my = y + dir[j][1];\n            if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n            v[my][mx] ^= 1;\n        }\n        f[y][x] = 0;\n        return 0;\n    }\n\n    vector<vector<int> > v0 = v, f0 = f;\n    FROMTO(i,n,100){\n        int y = i / 10, x = i % 10;\n        if(v0[y-1][x] == 0) continue;\n        REP(j,5){\n            int mx = x + dir[j][0], my = y + dir[j][1];\n            if(mx < 0 || my < 0 || mx >= 10 || my >= 10) continue;\n            v0[my][mx] ^= 1;\n        }\n        f0[y][x] = 1;\n    }\n\n    pf(\"---- check ----\\n\");\n    REP(y,10){\n        pr(join(v0[y]));\n        REP(x,10){\n            if(v0[y][x]) return 0;\n        }\n    }\n    f = f0;\n    return 1;\n}\n\nvector<vector<int> > fm;\n\nvoid solve(vector<vector<int> > &v){\n    vector<vector<int> > f(10, vector<int>(10));\n    if(!dfs(0,v,f)) throw;\n    REP(y,10) cout << join(f[y]) << endl;\n    fm = f;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    REP(i,n){\n        vector<vector<int> > v(10, vector<int>(10));\n        REP(y,10) REP(x,10)\n            cin >> v[y][x];\n        solve(v);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(ny < 0 || ny >= 10 || nx < 0 || nx >= 10)continue;\n\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tif(!dfs(0)){\n\t\twhile(1);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tif(x > 0)cout << \" \";\n\t\t\t\tcout << used[y][x];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nbool mem[12][12],cop[12][12],done[12][12];\n\nint main(){\n  int n;cin>>n;\n  while(n--){\n    lol(i,10)lol(j,10)cin>>mem[i][j];\n    bool flag[10],tmp[10];\n    for(int p=1;p<=1024;p++){\n      lol(i,10)flag[i]=tmp[i];\n      lol(i,10)lol(j,10)cop[i][j]=mem[i][j];\n      for(int k=0;k<10;k++){\n\tlol(i,10){\n\t  if(!flag[i])continue;\n\t  for(int j=max(0,i-1);j<=min(9,i+1);j++)cop[k][j]^=1;\n\t  cop[k+1][i]^=1;\n\t}\n\tlol(i,10)done[k][i]=flag[i];\n\tlol(i,10)flag[i]=cop[k][i];\n      }\n      bool na=false;\n      lol(i,10)na|=flag[i];\n      if(!na){\n\tlol(i,10){\n\t  lol(j,10){\n\t    if(j)cout<<\" \";\n\t    cout<<done[i][j];\n\t  }\n\t  cout<<endl;\n\t}\n      }\n      for(int i=0;i<10;i++){\n\tint r=pow(2,i);\n\tif(p%r==0)tmp[i]^=1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t}\n\telse if(y==1){\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\tflip(x,y);\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,0,sizeof(res));\n\t\tcheck(1,1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint I,flg;\nint t[10][10],u[10][10];\nint ans[10][10];\nvoid check();\nvoid dfs(int);\nvoid compute(int,int);\nint main(){\n  cin>>I;\n  while(I--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tu[i][j]=t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\n\n\nvoid dfs(int x){\n  if(flg)return;\n  if(x==10)check();\n  ans[0][x]=0;\n  dfs(x+1);\n  ans[0][x]=1;\n  dfs(x+1);\n}\n\n\nvoid check(){\n  if(flg)return;\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)t[i][j]=u[i][j];\n  for(int i=0;i<10;i++)if(ans[0][i])compute(0,i);\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(t[i-1][j]==1){\n\tans[i][j]=1;\n\tcompute(i,j);\n      }\n    }\n  }\n  int cnt=0;\n  for(int i=0;i<10;i++)cnt+=t[9][i];\n  if(cnt==0){\n    flg=1;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j)cout<<' ';\n\tcout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}\n\nvoid compute(int y,int x){\n  t[y][x]=!t[y][x];\n  if(y>0)t[y-1][x]=!t[y-1][x];\n  if(x>0)t[y][x-1]=!t[y][x-1];\n  if(y<9)t[y+1][x]=!t[y+1][x];\n  if(x<9)t[y][x+1]=!t[y][x+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 1;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0/*-1,-1,0,1, 1, 1, 0,-1*/};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1/* 0, 1,1,1,-0,-1,-1,-1*/};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 == 5 ){\n\t\t\t\t\tstm.PassParticle( i, j );\n\t\t\t\t\tans.m[i][j] = 1;\n\t\t\t\t\tgoto RETRY;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\nRETRY:;\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n\n#ifdef _DEBUG\n#define typeof(X) std::identity<decltype(X)>::type //C++0x (for vs2010)\n#else\n#define typeof(X) __typeof__(X) // for gcc\n#endif\n\n#define sz(a)  int((a).size())\n#define FOREACH(it, c) for (typeof((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define FOR(i,count) for (int i = 0; i < (int)(count); i++)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\nconst int MODULO = 100000 ;\nconst int INF = 100000000; //1e8\n\ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\ntypedef complex<double> Cd;\n\nusing namespace std;\n\nbool flip[10][10];\nbool tmp[10][10];\n\nbool get(int h,int w){\n\tstatic int dh[] = {1,0,0,0,-1};\n\tstatic int dw[] = {0,1,0,-1,0};\n\tbool ret = flip[h][w];\n\tFOR(i,5){\n\t\tint nh = dh[i]+h,nw = dw[i]+w;\n\t\tif(0 <= nh && nh < 10 && 0 <= nw && nw < 10)\n\t\t\tret ^= tmp[nh][nw];\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint n; cin>>n;\n\twhile(n--){\n\t\tFOR(i,10) FOR(j,10){ int x; cin>>x; flip[i][j] = x == 1; }\n\t\tFOR(i,2<<10){\n\t\t\tmemset(tmp,0,sizeof(tmp));\n\t\t\tFOR(j,10) tmp[0][j] = (i & (1 << j)) != 0;\n\t\t\tfor(int j = 1; j < 10; j++) for(int k = 0; k < 10; k++){\n\t\t\t\ttmp[j][k] = get(j-1,k);\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\tFOR(j,10) if(get(9,j)){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(ok) break;\n\t\t}\n\t\tFOR(i,10) FOR(j,10) printf(\"%d%c\",tmp[i][j],j == 9 ? '\\n' : ' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++){\n\n    int ny=y+dy[k],nx=x+dx[k];\n\n    if( 0<=ny && 0<=nx && ny<10 && nx<10)\n      b[ny][nx]=!b[ny][nx];\n  }\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++){\n    if(p[i])rev(i,0);\n    ans[0][i]=p[i];\n  }\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    p[cnt]=0;\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++){\n\n    int ny=y+dy[k],nx=x+dx[k];\n\n    if( 0<=ny && 0<=nx && ny<10 && nx<10)\n      b[ny][nx]=!b[ny][nx];\n  }\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++){\n    if(p[i])rev(i,0);\n    ans[0][i]=p[i];\n  }\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    p[cnt]=0;\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(temp[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(temp[ny][nx] == 1) temp[ny][nx] = 0;\n\t\t\t\telse temp[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int y,int x)\n{\n\trep(i,10) rep(j,10) temp[i][j] = f[i][j];\n\tans.clear();\n\tREP(i,1,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(temp[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9 && x == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\t//if(!fir)cout<<endl;\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp+(panel[j]>>k)&1)%2)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check=ans[8];\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif((ans[9]>>j)&1){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint x=j+k;\n\t\t\t\t\t\tif(0<=x&&x<10){\n\t\t\t\t\t\t\tif((check>>x)&1)check&=~(1<<x);\n\t\t\t\t\t\t\telse check|=1<<x;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(check==panel[9]){\n\t\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tint tmp=(ans[y]>>x)&1;\n\t\t\t\t\t\tprintf(x==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool grid[10][10];\n\nvoid rev(int y,int x){\n  int dy[] = {1,0,-1,0,0}, dx[] = {0,1,0,-1,0};\n\n  for(int i=0;i<5;i++){\n    int sy = y+dy[i], sx = x+dx[i];\n    if(sy<0 || sx<0 || sy>=10 || sx>=10)continue;\n    grid[sy][sx] = !grid[sy][sx];\n  }\n}\n\nint main(){\n  int t;\n  bool tmp[10][10];\n  int ans[10][10];\n\n  cin >> t;\n  while(t--){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin >> grid[i][j];\n\ttmp[i][j] = grid[i][j];\n      }\n    }\n    \n    for(int i=0;i<(1<<10);i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++)grid[j][k] = tmp[j][k];\n      }\n\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  rev(0,j);\n\t  ans[0][j] = 1;\n\t}else ans[0][j] = 0;\n      }\n\n      for(int j=1;j<10;j++){\n\tfor(int k=0;k<10;k++){\n\t  if(grid[j-1][k]){\n\t    rev(j,k);\n\t    ans[j][k] = 1;\n\t  }else ans[j][k] = 0;\n\t}\n      }\n\n      bool f = false;\n      for(int j=0;j<10;j++)f |= grid[9][j];\n      if(!f)break;\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<9;j++)cout << ans[i][j] << \" \";\n      cout << ans[i][9] << endl;\n    }\n    //if(t)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(temp[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(temp[ny][nx] == 1) temp[ny][nx] = 0;\n\t\t\t\telse temp[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int y,int x)\n{\n\trep(i,10) rep(j,10) temp[i][j] = f[i][j];\n\tans.clear();\n\trep(i,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(temp[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(0,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool canPut(int y, int x){\n\tint sy = y - 1;\n\tint ty = y + 1;\n\tint sx = x - 1;\n\tint tx = x + 1;\n\tif(sy < 0 || ty >= 10 || sx < 0 || tx >= 10)return false;\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1 && canPut(ny, nx)){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tdfs(0);\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tcout << used[y][x] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint LC[10][10];\nint L[10][10]; \nint F[10][10]; \n\nvoid init() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            L[i][j] = LC[i][j];\n            F[i][j] = 0;\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cin >> LC[i][j];\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cout << F[i][j];\n            if ( j + 1 < 10 ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid flip( int r, int c ) {\n    F[r][c] = 1;\n    L[r][c] = !L[r][c];\n    if ( r - 1 >= 0 ) L[r-1][c] = !L[r-1][c];\n    if ( r + 1 < 10 ) L[r+1][c] = !L[r+1][c];\n    if ( c - 1 >= 0 ) L[r][c-1] = !L[r][c-1];\n    if ( c + 1 < 10 ) L[r][c+1] = !L[r][c+1];\n}\n\nbool solve( int r ) {\n    if ( r >= 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            if ( L[r-1][i] == 1 ) return false;\n        }\n        return true;\n    }\n    if ( r == 0 ) {\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            init();\n            for ( int j = 0; j < 10; ++ j ) {\n                if ( i & ( 1 << j ) ) flip( r, j );\n            }\n            if ( solve( r + 1 ) ) return true;\n        }\n        return 0;\n    } else if ( r < 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            if ( L[r-1][i] ) {\n                F[r][i] = 1;\n                flip( r, i );\n            }\n        }\n        if ( solve( r + 1 ) ) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            input();\n            solve( 0 );\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint LC[10][10];\nint L[10][10]; \nint F[10][10]; \n\nvoid init() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            L[i][j] = LC[i][j];\n            F[i][j] = 0;\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cin >> LC[i][j];\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cout << F[i][j];\n            if ( j + 1 < 10 ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid flip( int r, int c ) {\n    L[r][c] = !L[r][c];\n    if ( r - 1 >= 0 ) L[r-1][c] = !L[r-1][c];\n    if ( r + 1 < 10 ) L[r+1][c] = !L[r+1][c];\n    if ( c - 1 >= 0 ) L[r][c-1] = !L[r][c-1];\n    if ( c + 1 < 10 ) L[r][c+1] = !L[r][c+1];\n}\n\nbool solve( int r ) {\n    if ( r >= 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            if ( L[r-1][i] == 1 ) return false;\n        }\n        return true;\n    }\n    if ( r == 0 ) {\n        init();\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                if ( i & ( 1 << j ) ) F[r][j] = 1;\n                if ( i & ( 1 << j ) ) flip( r, j );\n            }\n            if ( solve( r + 1 ) ) return true;\n        }\n    } else if ( r < 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            if ( L[r-1][i] ) {\n                F[r][i] = 1;\n                flip( r, i );\n            }\n        }\n        if ( solve( r + 1 ) ) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            input();\n            solve( 0 );\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <list>\n\nstd::list<int> dfs(std::vector<std::vector<bool>> &state, const int &idx = 1) {\n\tif (idx < 10) {\n\t\tint res = 0;\n\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\tres <<= 1;\n\t\t\tif (state.at(idx - 1).at(i)) {\n\t\t\t\tres += 1;\n\t\t\t\tfor (const auto &index : { i - 1, i, i + 1 }) {\n\t\t\t\t\tif (index >= 0 && index < 10) {\n\t\t\t\t\t\tstate.at(idx).at(index) = !state.at(idx).at(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx != 9) {\n\t\t\t\t\tstate.at(idx + 1).at(i) = !state.at(idx + 1).at(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(state, idx + 1);\n\t\tif (list.size() + idx == 9) {\n\t\t\tlist.push_front(res);\n\t\t\treturn list;\n\t\t}\n\t\telse {\n\t\t\treturn list;\n\t\t}\n\t}\n\telse {\n\t\tbool is_on = false;\n\t\tfor (const auto &cell : state.at(9)) {\n\t\t\tis_on = is_on || cell;\n\t\t}\n\t\tif (is_on) {\n\t\t\treturn std::list<int>{0};\n\t\t}\n\t\telse {\n\t\t\treturn std::list<int>{};\n\t\t}\n\t}\n}\nstd::list<int> solve(std::vector<std::vector<bool>> &state) {\n\tfor (auto i = 0; i < 1023; ++i) {\n\t\tauto copy = state;\n\t\tfor (auto j = 0; j < 10; ++j) {\n\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\tfor (const auto &idx : { j - 1, j, j + 1 }) {\n\t\t\t\t\tif (idx >= 0 && idx < 10) {\n\t\t\t\t\t\tcopy.at(0).at(idx) = !copy.at(0).at(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcopy.at(1).at(j) = !copy.at(1).at(j);\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(copy);\n\t\tif (list.size() == 9) {\n\t\t\tlist.push_front(i);\n\t\t\treturn list;\n\t\t}\n\t}\n\treturn std::list<int>{};\n}\nint main() {\n\tint n;\n\tfor (std::cin >> n; n > 0; --n) {\n\t\tstd::vector<std::vector<bool>> state(10, std::vector<bool>(10, false));\n\t\tbool input;\n\t\tfor (auto &line : state) {\n\t\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\t\tstd::cin >> input;\n\t\t\t\tstate.at(0).at(i) = input;\n\t\t\t}\n\t\t}\n\t\tauto res = solve(state);\n\t\tfor (const auto &line : res) {\n\t\t\tfor (auto i = 512; i > 0; i >>= 1) {\n\t\t\t\tstd::cout << static_cast<int>((i & (line)) != 0) << ((i != 1) ? ' ' : '\\n');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nint a[12][12];\nint f[12][12];\nint res[12][12];\nint b[20] = {1};\nint dh[5] = {0, 0, 0, 1, -1};\nint dw[5] = {0, 1, -1, 0, 0};\n\nsigned main(void){\n  int i, j, k, l;\n  rep1(i, 20)b[i] = b[i - 1] << 1;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int(n);\n    for(;n--;){\n      rep(i, 10)rep(j, 10)scanf(\"%d\", &a[i + 1][j + 1]);\n      rep(k, b[10]){\n        rep(i, 12)rep(j, 12){\n          f[i][j] = a[i][j];\n          res[i][j] = 0;\n        }\n        for(int x = k, d = 1;x;x /= 2){\n          res[1][d++] = x % 2;\n          if(x % 2 == 1)rep(l, 5)f[1 + dh[l]][d + dw[l]] ^= 1;\n        }\n\n        rep1(i, 10)rep(j, 10)if(f[i][j + 1] == 1){\n          res[i + 1][j + 1] = 1;\n          rep(l, 5)f[i + 1 + dh[l]][j + 1 + dw[l]] ^= 1;\n        }\n        bool isok = true;\n        rep(i, 10)rep(j, 10)if(f[i + 1][j + 1] == 1)isok = false;\n        if(isok){\n          rep(i, 10){\n            rep(j, 9)printf(\"%d \", res[i + 1][j + 1]);\n            printf(\"%d\\n\", res[i + 1][j + 1]);\n          }\n          break;\n        }\n      }\n    }\n\n\n/*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<climits>\nusing namespace std;\n#define SIZE 100\n\nclass ExtendedLightsOut{\n public:\n  char M[SIZE], P[SIZE], A[SIZE];\n  bool solved;\n  int min_value;\n\n  bool check(){\n    for ( int i = 0; i < SIZE; i++ ) if ( M[i] == '1' ) return false;\n    return true;\n  }\n\n  void flipM( int pos ){ M[pos] = ( M[pos] == '0' ) ? '1' : '0'; }\n  void flipP( int pos ){ P[pos] = ( P[pos] == '0' ) ? '1' : '0'; }\n\n  void press( int pos ){\n    int x, y, nx, ny;\n    x = pos / 10;\n    y = pos % 10;\n\n    flipM( pos );\n    flipP( pos );\n\n    nx = x + 1;\n    ny = y;\n    if ( 0 <= nx && 0 <= ny && nx < 10 && ny < 10 ) flipM( nx*10 + ny );\n\n    nx = x;\n    ny = y + 1;\n    if ( 0 <= nx && 0 <= ny && nx < 10 && ny < 10 ) flipM( nx*10 + ny );\n\n    nx = x - 1;\n    ny = y;\n    if ( 0 <= nx && 0 <= ny && nx < 10 && ny < 10 ) flipM( nx*10 + ny );\n\n    nx = x;\n    ny = y - 1;\n    if ( 0 <= nx && 0 <= ny && nx < 10 && ny < 10 ) flipM( nx*10 + ny );\n\n  }\n\n  bool recursive( int pos ){\n    if ( pos == SIZE ) return check();\n\n    if ( pos < 10 ){\n      if ( recursive( pos + 1 ) ) return true;\n      press( pos );\n      if ( recursive( pos + 1 ) ) return true;\n      press( pos );\n    } else {\n      int p = pos - 20;\n      if ( p > 0 && M[p] == '1' ) return false;\n      int v = pos - 10;\n      if ( M[v] == '1' ) {\n\tpress( pos );\n\tif ( recursive( pos + 1 ) ) return true;\n\tpress( pos );\n      } else {\n\tif ( recursive( pos + 1 ) ) return true;\n      }\n    }\n    return false;\n  }\n\n  void print(){\n    for ( int i = 0; i < 10; i++ ){\n      for ( int j = 0; j < 10; j++ ){\n\tif ( j ) printf(\" \");\n\tprintf(\"%c\", P[i*10+j] );\n      }\n      printf(\"\\n\");\n    }\n  }\n\n  void work(){\n    for ( int i = 0; i < SIZE; i++ ){\n\tP[i] = '0';\n    }\n    solved = false;\n    min_value = INT_MAX;\n    if ( recursive( 0 ) ){\n      print();\n    }else{\n      cout << \"NO SOLUTION\" << endl;\n    }\n  }\n\n  void read(){\n    for ( int i = 0; i < SIZE; i++ ){\n      cin >> M[i];\n    }\n  }\n};\n\nmain(){\n  ExtendedLightsOut ELO;\n  int tcase;\n  cin >> tcase;\n  for ( int i = 1; i <= tcase; i++ ){\n    ELO.read();\n    ELO.work();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <map>\n#include <algorithm>\n#include <bitset>\n#include <set>\n#include <functional>\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\ntypedef long long int lint;\ntypedef vector<vector<int> > matrix;\n\nint dy[5] = { -1, 0, 0, 0, 1 };\nint dx[5] = { 0, -1, 0, 1, 0 };\n\nvoid print(matrix& mat) {\n\tREP(y, 10) {\n\t\tREP(x, 10) {\n\t\t\tcout << mat[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nmatrix mk_matrix(int n) {\n\tmatrix mat(n);\n\tREP(i, n) {\n\t\tmat[i] = vector<int>(10, 0);\n\t}\n\treturn mat;\n}\n\nvoid push(matrix& mat, int y, int x) {\n\tREP(i, 5) {\n\t\tint nx = x + dx[i];\n\t\tif (nx < 0 || nx >= 10) continue;\n\t\tint ny = y + dy[i];\n\t\tif (ny < 0 || ny >= 10) continue;\n\t\tmat[ny][nx] ^= 1;\n\t}\n}\n\nvoid solve(matrix& mat) {\n\t//?????????????????¨????????????????????????\n\tREP(i, 1024) {\n\t\tmatrix mat_tmp = mat;\n\t\tmatrix pushed = mk_matrix(10);\n\t\tint tmp = i;\n\t\tREP(j, 10) {\n\t\t\tif (!tmp) break;\n\t\t\tif (tmp & 1) {\n\t\t\t\tpush(mat_tmp, 0, j);\n\t\t\t\tpushed[0][j] = 1;\n\t\t\t\t//print(mat_tmp);\n\t\t\t}\n\t\t\ttmp >>= 1;\n\t\t}\n\n\t\tFOR(y, 1, 10) {\n\t\t\tREP(x, 10) {\n\t\t\t\tif (mat_tmp[y - 1][x]) {\n\t\t\t\t\tpush(mat_tmp, y, x);\n\t\t\t\t\tpushed[y][x] = 1;\n\t\t\t\t\t//print(mat_tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << i << endl;\n\t\t//print(mat_tmp);\n\t\tif (find(mat_tmp[9].begin(), mat_tmp[9].end(), 1) == mat_tmp[9].end()) {\n\t\t\tprint(pushed);\n\t\t\t//cout << \"solved.\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool AOJ0131()\n{\n\tmatrix mat = mk_matrix(10);\n\tREP(i, 10) {\n\t\tREP(j, 10) {\n\t\t\tcin >> mat[i][j];\n\t\t}\n\t}\n\n\tsolve(mat);\n\n\treturn true;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tREP(i, n) AOJ0131();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint I,flg;\nint t[10][10],u[10][10];\nint ans[10][10];\nvoid check();\nvoid dfs(int);\nvoid compute(int,int);\nint main(){\n  cin>>I;\n  while(I--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tu[i][j]=t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\n\n\nvoid dfs(int x){\n  if(flg)return;\n  if(x==10){\n    check();\n  }else{\n    ans[0][x]=0;\n    dfs(x+1);\n    ans[0][x]=1;\n    dfs(x+1);\n  }\n}\n\n\nvoid check(){\n  if(flg)return;\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)t[i][j]=u[i][j];\n  for(int i=0;i<10;i++)if(ans[0][i]==1)compute(0,i);\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(t[i-1][j]==1){\n\tans[i][j]=1;\n\tcompute(i,j);\n      }\n    }\n  }\n  /*\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(j)cout<<' ';\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  */\n  int cnt=0;\n  for(int i=0;i<10;i++)cnt+=t[9][i];\n  if(cnt==0){\n    flg=1;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j)cout<<' ';\n\tcout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}\n\nvoid compute(int y,int x){\n  t[y][x]=(t[y][x]*-1)+1;\n  if(y>0)t[y-1][x]=(t[y-1][x]*-1)+1;\n  if(x>0)t[y][x-1]=(t[y][x-1]*-1)+1;\n  if(y<9)t[y+1][x]=(t[y+1][x]*-1)+1;\n  if(x<9)t[y][x+1]=(t[y][x+1]*-1)+1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 1;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 > max1 && cnt1 >= 3 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint ans[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\n\nvoid change(int y,int x)\n{\n\tif(f[y-1][x] == 1)\n\t{\n\t\tans[y][x] = 1;\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tf[ny][nx] = !f[ny][nx];\t\t\t\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool check(int *used)\n{\n\tmemset(ans,0,sizeof(ans));\n\tmemcpy(f,temp,sizeof(temp));\n\n\trep(i,10)\n\t{\n\t\tans[0][i] = used[i];\n\t\tif(used[i])\n\t\t{\n\t\t\trep(j,5)\n\t\t\t{\n\t\t\t\tint nx = i + dx[j];\n\t\t\t\tint ny = dy[j];\n\n\t\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t\t{\n\t\t\t\t\t\tf[ny][nx] = !f[ny][nx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i,1,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tchange(i,j);\t\n\t\t}\n\t}\n\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(f[i][j] == 1) cnt++;\n\n\tif(cnt == 0)\n\t{\n\t\treturn true;\n\t}\n\telse return false;\n}\n\nbool dfs(int i,int *t)\n{\n\tif(i == 10)\n\t{\n\t\tif(check(t)) return true;\n\t\telse return false;\n\t}\n\n\tif(dfs(i+1,t)) return true;\n\tt[i] = 1;\n\tif(dfs(i+1,t)) return true;\n\tt[i] = 0;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> temp[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint t[10];\n\t\tmemset(t,0,sizeof(t));\n\t\tdfs(0,t);\n\t\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcout << ans[j][k];\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define SIZE 10\nusing namespace std;\n\nclass State{\npublic:\n  int data[SIZE][SIZE];\n  int put[SIZE][SIZE];\n  State() {\n    fill((int*)put, (int*)put+SIZE*SIZE, 0);\n  }\n  void puts(int x, int y) {\n    static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n    put[y][x] = 1;\n    for(int k = 0; k < 5; k++) {\n      int nx = x + d[k][0];\n      int ny = y + d[k][1];\n      if(nx < 0 || nx >= SIZE) continue;\n      if(ny < 0 || ny >= SIZE) continue;\n      data[ny][nx] = -(data[ny][nx] - 1);\n    }\n  }\n  bool isAll0() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(data[i][j] != 0) return false;\n      }\n    }\n    return true;\n  }\n  void show() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcout << put[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool rec(State s, int x, int y) {\n  static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n  if(s.isAll0()) {\n    s.show();\n    return true;\n  }\n\n  for(int i = y; i < SIZE; i++) {\n    for(int j = x; j < SIZE; j++) {\n      bool flag = false;\n      for(int k = 0; k < 5; k++) {\n\tint nx = j + d[k][0];\n\tint ny = i + d[k][1];\n\tif(nx < 0 || nx >= SIZE) continue;\n\tif(ny < 0 || ny >= SIZE) continue;\n\tif(s.data[ny][nx] == 1) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if(flag) {\n\tif(i > 0 && s.data[i-1][j] == 0) continue;\n\tState tmp = s;\n\ttmp.puts(j, i);\n\tint nx, ny;\n\tnx = j + 1;\n\tny = i;\n\tif(nx >= SIZE) {\n\t  nx = 0;\n\t  ny++;\n\t}\n\tif(rec(tmp, nx, ny)) {\n\t  return true;\n\t}\n\tif(i > 0 && s.data[i-1][j] == 1) return false;\n      }\n    }\n  }\n  return false;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    State s;\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcin >> s.data[i][j];\n      }\n    }\n    rec(s, 0, 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n#define INFTY 1 << 28\n\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap(){ memset( m, 0, sizeof(*m) * sizeof(**m) ); }\n\tvoid PassParticle(int i, int j){\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\tbool NoLight() const {\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] ) return false;\n\t\treturn true;\n\t}\n\tvoid Print() const {\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintAns() const {\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tbool operator==(const CMap &t) const {\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] ) ++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D ){\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\n\t\tAnswer.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,-1,1};\n\nint ori[10][10];\nint arr[10][10];\nint arr2[10][10];\n    \nvoid flip(int i, int j) {\n  arr[i][j] = 1 - arr[i][j];\n  arr2[i][j] = 1 - arr2[i][j];\n  for(int k=0; k<4; k++) {\n    int nx = j+dx[k], ny = i+dy[k];\n    if(0<=ny && ny<10 && 0<=nx && nx<10) {\n      arr[ny][nx] = 1 - arr[ny][nx];\n    }\n  }\n}\n\nint main() {\n  int Tc; cin >> Tc;\n  \n  while(Tc--) {\n    \n    for(int i=0; i<10; i++)\n      for(int j=0; j<10; j++)\n\tcin >> ori[i][j];\n    \n    bool good = 0;\n    for(int I=0; I<(1<<10); I++) {\n      memset(arr2, 0, sizeof(arr2));\n      memcpy(arr, ori, sizeof(ori));\n      bool ok = 1;\n      for(int i=0; i<10; i++) {\n\tfor(int j=0; j<10; j++) {\n\t  \n\t  if(i == 0) {\n\t    if((I>>j) & 1) {\n\t      if(arr[0][j] == 0) flip(0, j);\n\t    }\n          }\n\t  else {\n\t    if(arr[i-1][j] == 1) flip(i, j);\n\t  }\n\t  \n\t} \n      }\n      \n      for(int i=0; i<10; i++) {\n\tif(arr[9][i]) ok = 0;\n      }\n      if(ok) {\n\tgood = 1;\n\tbreak;\n      }\n    }\n    if(good) {\n      for(int i=0; i<10; i++) {\n\tfor(int j=0; j<10; j++) {\n\t  if(j) cout << \" \";\n\t  cout << arr2[i][j];\n\t}\n\tcout << endl;\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintAns() const\n\t{\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\n\t\tAnswer.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nbool ans[10][10];\nbool ba[10][10];\nint dx[] = {-1,0,0,0,1};\nint dy[] = {0, -1,0, 1, 0};\n\nbool judge(int x, int y) {\n  int res = ba[x][y];\n  REP(k,5) {\n    int xx = x + dx[k];\n    int yy = y + dy[k];\n    if (xx < 0 || xx >= 10 || yy < 0 || yy >= 10) continue;\n    if (ans[xx][yy]) res++;\n  }\n  return res % 2;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    REP(y,10)\n      REP(x,10)\n      cin >> ba[x][y];\n    \n    for (int i=0; i<(1<<10); ++i) {\n      memset(ans, 0, sizeof(ans));\n      REP(j,10)\n        if ((i>>j)&1)\n          ans[j][0] = 1;\n      for(int y=1; y<10; ++y) {\n        REP(x,10) {\n          if (judge(x,y-1))\n            ans[x][y] = 1;\n        }\n      }\n      bool f = 1;\n      REP(i,10)\n        if (judge(i, 9)) f = 0;\n      if (f) \n        break;\n    }\n    REP(y,10) {\n      REP(x,10)\n        cout << ans[x][y] << \" \";\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10\n\nusing namespace std;\n\nbool dp1[N][N], dp2[N][N];\n\nvoid reverse(int i, int j){\n  if(!(i>=0 && i<N)) return;\n  if(!(j>=0 && j<N)) return;\n  dp1[i][j] = !dp1[i][j];\n}\n\nint main(){\n  int n;\n  cin >> n;\n  for(int k=0; k<n; ++k){\n    for(int i=0; i<N; ++i){\n      for(int j=0; j<N; ++j){ \n\tcin >> dp1[i][j];\n\tdp2[i][j] = 0;\n      }\n    }\n    for(int i=0; i<N; ++i){\n      for(int j=1; j<N; ++j){\n\tif(dp1[i][j]){\n\t  dp2[i+1][j] = 1;\n\t  reverse(i, j);\n\t  reverse(i+1, j-1);\n\t  reverse(i+1, j);\n\t  reverse(i+1, j+1);\n\t  reverse(i+2, j);\n\t}\n      }\n    }\n    for(int i=0; i<N; ++i){\n      for(int j=0; j<N; ++j){ \n\tcout << dp2[i][j];\n\tif(j != N-1) cout << \" \";\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nvoid turn(int x, int y, int data[10][10]) {\n\tint dx[5] = {0,1,0,-1,0};\n\tint dy[5] = {0,0,1,0,-1};\n\t\n\tREP(i, 5) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (!(nx >= 0 && nx < 10 && ny >= 0 && ny < 10)) continue;\n\t\tdata[ny][nx]++;\n\t}\n}\n\nbool check(int data[10][10]) {\n\tbool res = true;\n\t\n\tREP(i, 10) if (data[9][i] & 1) res = false;\n\t\n\treturn res;\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tint in[10][10];\n\t\tREP(i, 10) REP(j, 10) scanf(\"%d\", &in[i][j]);\n\t\t\n\t\tbool ans[10][10];\n\t\tint data[10][10];\n\t\t\n\t\tREP(i, 1<<10) {\n\t\t\tmemset(ans, 0, sizeof(ans));\n\t\t\tmemcpy(data, in, sizeof(in));\n\t\t\t\n\t\t\tREP(j, 10) if ((i >> j) & 1) {\n\t\t\t\tans[0][j] = true;\n\t\t\t\tturn(j, 0, data);\n\t\t\t}\n\t\t\tFOR(j, 1, 10) REP(k, 10) {\t\n\t\t\t\tif (data[j - 1][k] & 1) {\n\t\t\t\t\tans[j][k] = true;\n\t\t\t\t\tturn(k, j, data);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (check(data)) break;\n\t\t}\n\t\t\n\t\tREP(j, 10) REP(k, 10)\n\t\t\tprintf(\"%d%c\", ans[j][k] ? 1 : 0, k == 9 ? '\\n' : ' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tint TryPassParticle(int i, int j)\n\t{\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\n\t\treturn cnt1;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &m, vector<CMap> &vRet){\n\tqueue<CMap> q;\n\t\n\tq.push( m );\n\twhile( !q.empty() ){\n\t\tbool bCont;\n\t\tCMap M = q.front();\n\t\tq.pop();\n\n\t\tdo{\n\t\t\tbCont = false;\n\t\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\t\tint ci = NIL, cj = NIL, max1 = 0;\n\t\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1) && \n\t\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz],1,MAX-1) && inRange(j+dj[(k+2)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz],1,MAX-1) && inRange(j+dj[(k+3)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz],1,MAX-1) && inRange(j+dj[(k+4)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while( bCont );\n\t\tvRet.push_back( M );\n\t}\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\t//EraseBlocks( M );\n\t\t/*cout << endl;\n\t\tM.Print();*/\n\t\t\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <functional>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <set>\n#include <typeinfo>\n#define PI 3.14159265359\n#define INF 99999999\n#define rep(i, n) for(int i=0; i<n; i++)\n#define REP(n) rep(i, n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\nusing namespace std;\ntypedef pair<int, int> P;\n \nint n;\nconst int dx[5] = {-1, 0, 0, 0, 1};\nconst int dy[5] = {0, -1, 0, 1, 0};\nint tile[10][10];\nint flip[10][10];\n\nint get(int x, int y)\n{\n\tint c = tile[y][x];\n\trep(d, 5)\n\t{\n\t\tint x2 = x + dx[d];\n\t\tint y2 = y + dy[d];\n\t\tif (0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10)\n\t\t{\n\t\t\tc += flip[y2][x2];\n\t\t}\n\t}\n\treturn c % 2;\n}\n\nvoid print()\n{\n\trep(i, 10)\n\t{\n\t\trep(j, 10)\n\t\t{\n\t\t\tif (j == 9)\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", flip[i][j]);\n\t\t\t} else {\n\t\t\t\tprintf(\"%d \", flip[i][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nbool calc()\n{\n\tfor (int i=1; i<10; i++)\n\t{\n\t\tfor (int j=0; j<10; j++)\n\t\t{\n\t\t\tif (get(j, i-1) != 0)\n\t\t\t{\n\t\t\t\tflip[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int j=0; j<10; j++)\n\t{\n\t\tif (get(j, 9) != 0)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nint main()\n{\n\tcin >> n;\n\n\tREP(n)\n\t{\n\t\trep(j, 10)\n\t\t{\n\t\t\trep(k, 10)\n\t\t\t{\n\t\t\t\tcin >> tile[j][k];\n\t\t\t}\n\t\t}\n\n\t\tfor (int j=0; j<(1<<10); j++)\n\t\t{\n\t\t\tmemset(flip, 0, sizeof(flip));\n\t\t\tfor (int k=0; k<10; k++)\n\t\t\t{\n\t\t\t\tflip[0][10-k-1] = j >> k & 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (calc())\n\t\t\t{\n\t\t\t\tprint();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t//デバッグ\n\t\trep(j, 10)\n\t\t{\n\t\t\trep(k, 10)\n\t\t\t{\n\t\t\t\tprintf(\"%d \", tile[j][k]);\t\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\t*/\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\nint dx[]={-1,0,1,0,0};\nint dy[]={0,-1,0,1,0};\n\nint main() {\n\tint n ; cin >> n ;\n\twhile(n--){\n\t\tint field[10][10];\n\t\tfor(int i=0;i<10;i++) for(int j=0;j<10;j++) cin >> field[i][j];\n\t\tint tmp_ans[10][10]={0};\n\t\tint tmp_field[10][10];\n\t\tfor(int i=0;i<1<<10;i++){\n\t\t\tbool failed=false;\n\t\t\tmemset(tmp_ans,0,sizeof(tmp_ans));\n\t\t\tmemcpy(tmp_field,field,sizeof(field));\n\t\t\tfor(int j=0;j<10;j++) tmp_ans[0][10-1-j]= i>>j & 1;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tif(tmp_ans[0][j]){\n\t\t\t\t\tfor(int m=0;m<=4;m++)\n\t\t\t\t\t\tif(0<=j+dx[m] && j+dx[m]<10 && 0<=dy[m] ) (tmp_field[dy[m]][j+dx[m]])^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int l=1;l<10;l++){\n\t\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\t\tif(tmp_field[l-1][k]){\n\t\t\t\t\t\ttmp_ans[l][k]=true;\n\t\t\t\t\t\tfor(int m=0;m<=4;m++)\n\t\t\t\t\t\t\tif(0<=k+dx[m] && k+dx[m]<10 && 0<=l+dy[m] && l+dy[m]<10) tmp_field[l+dy[m]][k+dx[m]]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<10;j++) if(tmp_field[9][j]) failed=true;\n\t\t\tif(!failed) break;\n\t\t}\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++) {if(j) cout << ' ' ; cout << tmp_ans[i][j] ;}\n\t\t\tcout << '\\n' ;\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nconst int B=10;\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    vector< vector<int> > ans(B),tans,ban(B);\n    rep(i,B){\n      ans[i].resize(B);\n      ban[i].resize(B);\n    }\n    rep(i,B)rep(j,B)cin>>ban[i][j];\n    int mina=B*B;\n    rep(k,1<<B){\n      int tmin=0;\n      rep(i,B){\n        rep(j,B){\n          if(!i)ans[i][j]=!!(1<<j&k);\n          else{\n            int t=ban[i-1][j]+ans[i-1][j];\n            if(j)t+=ans[i-1][j-1];\n            if(j+1<B)t+=ans[i-1][j+1];\n            if(i>1)t+=ans[i-2][j];\n            ans[i][j]=t%2;\n          }\n          tmin+=ans[i][j];\n        }\n      }\n      rep(i,B){\n        rep(j,B){\n          int t=ans[i][j]+ban[i][j];\n          if(j)t+=ans[i][j-1];\n          if(i)t+=ans[i-1][j];\n          if(j+1<B)t+=ans[i][j+1];\n          if(i+1<B)t+=ans[i+1][j];\n        }\n      }\n\n      int odd=0;\n      rep(j,B){\n        int t=ban[B-1][j]+ans[B-1][j]+ans[B-2][j];\n        if(j)t+=ans[B-1][j-1];\n        if(j+1<B)t+=ans[B-1][j+1];\n        odd+=t%2;\n      }\n      if(!odd && tmin<mina){\n        mina=tmin;\n        tans=ans;\n      }\n    }\n    rep(i,B){\n      rep(j,B){\n        if(j)cout<<\" \";\n        cout<<tans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nbool solve( int data[10][10], int answer[10][10], int t )\n{\n\tif( t == 8 ){\n\t\tfor( int i = 0;i < 10;i++ ){\n\t\t\tfor( int j = 0;j < 10;j++ ){\n\t\t\t\tif( data[j][i] == 1 ) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tfor( int i = 1;i < 9;i++ ){\n\t\tif( data[i][t] == 1 ){\n\t\t\tdata[i][t] = !data[i][t];\n\t\t\tdata[i - 1][t + 1] = !data[i - 1][t + 1];\n\t\t\tdata[i][t + 1] = !data[i][t + 1];\n\t\t\tdata[i + 1][t + 1] = !data[i + 1][t + 1];\n\t\t\tdata[i][t + 2] = !data[i][t + 2];\n\n\t\t\tanswer[i][t + 1] = 1;\n\n\t\t}\n\t}\n\n\treturn solve( data, answer, t + 1 );\n\n}\n\n\n\nint main(int argc, char const* argv[])\n{\n\tint data[10][10];\n\tint answer[10][10];\n\tint n;\n\n\tcin >> n;\n\n\tfor( int k = 0;k < n;k++ ){\n\n\t\tfor( int i = 0;i < 10;i++ ){\n\t\t\tfor( int j = 0;j < 10;j++ ){\n\t\t\t\tcin >> data[j][i];\n\t\t\t\tanswer[j][i] = 0;\n\t\t\t}\n\t\t}\n\n\t\tsolve( data, answer, 0 );\n\n\t\tfor( int i = 0;i < 10;i++ ){\n\t\t\tfor( int j = 0;j < 10;j++ ){\n\t\t\t\tcout << ( (j == 0) ? \"\" : \" \" ) << answer[j][i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(f[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(f[ny][nx] == 1) f[ny][nx] = 0;\n\t\t\t\telse f[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int y,int x)\n{\n\t//cout << \"y:\" << y << \" x:\" << x << endl;\n\tans.clear();\n\trep(i,10)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(f[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P pair<int, int>\nconst int H = 10;\nconst int W = 10;\ntypedef vector< vector<int> > ivv;\ntypedef vector<int> iv;\n\nint my[5] = {1, -1, 0, 0, 0};\nint mx[5] = {0, 0, 1, -1, 0};\n\nclass C{\n  public:\n    ivv u;\n    int t;\n    C(){}\n    C(ivv _u, int _t){ u = _u; t = _t; }\n};\n\nqueue<C> open;\nset<ivv> S;\n\nvoid rev(ivv &v, int y, int x){\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = (v[ny][nx] + 1) % 2;\n  }\n}\n\nbool next(ivv v, ivv &u, int y, int x){\n  REP(i, H) REP(j, W) if(u[i][j]) rev(v, i, j);\n  int a = 0, b = 0;\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n      if(v[ny][nx]) ++a;\n      else ++b;\n    }\n  }\n  return a > b;\n}\n\n\nbool end(ivv v, ivv &u){\n  REP(i, H) REP(j, W) if(u[i][j]) rev(v, i, j);\n  REP(i, H) REP(j, W) if(v[i][j] == 1) return false;\n  return true;\n}\n\nivv bfs(ivv &v){\n  open = queue<C>();\n  S = set<ivv>();\n  ivv _u(H, iv(W, 0));\n  open.push(C(_u, 0));\n  S.insert(_u);\n  while(!open.empty()){\n    C tmp = open.front(); open.pop();\n    ivv u = tmp.u; int t = tmp.t;\n    //cout <<\"---------------\" <<endl;\n    //cout <<open.size() <<endl;\n    //REP(i, H){\n    //  REP(j, W) cout <<u[i][j] <<\" \";\n    //  cout <<endl;\n    //}\n    if(end(v, u)) return u;\n    REP(y, H){\n      REP(x, W){\n        if(!u[y][x] && next(v, u, y, x)){\n          rev(v, y, x);\n          u[y][x] = true;\n          if(S.find(u) == S.end()){\n            S.insert(u);\n            open.push(C(u, t + 1));\n          }\n          u[y][x] = false;\n          rev(v, y, x);\n        }\n      }\n    }\n  }\n  return ivv();\n}\n\nint main() {\n  int T; cin >>T;\n  REP(t, T){\n    ivv v(H, iv(W));\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    ivv ans = bfs(v);\n    REP(i, H){\n      REP(j, W) cout <<ans[i][j] <<(j + 1 == W ? \"\" : \" \");\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define EPS 1e-8\n#define DEB 1\n\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {-1,0,1,0};\nint field[16][16],tmp[16][16];\nvector<pair<int,int> > v;\n\nvoid touch(int x, int y){\n\ttmp[y][x] ^= 1;\n\trep(k,4){\n\t\tint tx = x + dx[k];\n\t\tint ty = y + dy[k];\n\t\tif( tx<0 || ty<0 || tx>=10 || ty>=10 )continue;\n\t\ttmp[ty][tx] ^= 1;\n\t}\n}\nbool ok(){\n\trep(i,10)rep(j,10)if( tmp[i][j]==1 ) return false;\n\treturn true;\n}\nint main(){\n\tint t;\n\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\trep(i,10)rep(j,10)scanf(\"%d\",&field[i][j]);\n\n\t\trep(i,1<<10){\n\t\t\tv.clear();\n\t\t\trep(j,10)rep(k,10)tmp[j][k]=field[j][k];\n\t\t\t\n\t\t\trep(j,10)if( (1<<j)&i ){\n\t\t\t\ttouch(j,0);\n\t\t\t\tv.push_back(mp(j,0));\n\t\t\t}\n\t\t\tREP(k,1,10){\n\t\t\t\trep(j,10){\n\t\t\t\t\tif( tmp[k-1][j]==1 ){\n\t\t\t\t\t\ttouch(j,k);\n\t\t\t\t\t\tv.push_back(mp(j,k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ok() ){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tint ans[10][10];\n\t\tmemset(ans,0,sizeof(ans));\n\t\trep(i,v.size())ans[v[i].second][v[i].first] = 1;\n\t\trep(i,10){\n\t\t\trep(j,10){\n\t\t\t\tif( j>0 )putchar(' ');\n\t\t\t\tprintf(\"%d\",ans[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t\t   \n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Board\n{\npublic:\n\tBoard()\n\t{\n\t\tmemset( m_board, 0, sizeof(m_board) );\n\t}\n\t~Board()\n\t{\n\t}\n\n\tvoid input()\n\t{\n\t\tfor( int i = 1; i < 11; ++i ){\n\t\t\tint bits = 0;\n\t\t\tfor( int j = 0; j < 10; ++j ){\n\t\t\t\tbits <<= 1;\n\t\t\t\tint n;\n\t\t\t\tcin >> n;\n\t\t\t\tbits |= n;\n\t\t\t}\n\t\t\tm_board[ i ] = bits;\n\t\t}\n\t}\n\tvoid output()\n\t{\n\t\tfor( int i = 0; i < 10; ++i ){\n\t\t\tint bit = 1 << 9;\n\t\t\tbool first = true;\n\t\t\tfor( int j = 0; j < 10; ++j ){\n\t\t\t\tif( first ){\n\t\t\t\t\tfirst = false;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << ( m_correct[ i ] & bit ? 1 : 0 );\n\t\t\t\tbit >>= 1;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tbool light( int bits )\n\t{\n\t\tmemset( m_correct, 0, sizeof(m_correct) );\n\n\t\tint mask = ( 1 << 10 ) - 1;\n\t\tfor( int i = 1; i < 11; ++i ){\n\t\t\tm_correct[ i - 1 ] = bits;\n\n\t\t\tm_board[ i - 1 ] ^= bits & mask;\n\t\t\tm_board[ i + 1 ] ^= bits & mask;\n\n\t\t\tm_board[ i ] ^= bits;\n\t\t\tm_board[ i ] ^= ( bits << 1 );\n\t\t\tm_board[ i ] ^= ( bits >> 1 ) & mask;\n\t\t\tif( i > 1 && m_board[ i - 1 ] != 0 ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbits = m_board[ i ];\n\t\t}\n\t\treturn true;\n\t}\n\nprivate:\n\tint m_board[ 12 ];\n\tint m_correct[ 10 ];\n};\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tBoard board;\n\t\t\tboard.input();\n\n\t\t\tfor( int j = 0; j < ( 1 << 10 ); ++j ){\n\t\t\t\tif( board.light( j ) ){\n\t\t\t\t\tboard.output();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint main(){\n  int n;\n  cin >> n;\n  while(n-- > 0){\n    int imap[11][11],syokurin[11][11];\n    rep(i,10){\n      rep(j,10){\n\tsyokurin[i][j] = 0;\n\tcin >> imap[i][j];\n      }\n    }\n\n    rep(i,10){\n      rep(j,10){\n\tif(imap[i][j] == 0)continue;\n\tsyokurin[i][j]++;\n\trep(k,4){\n\t  int nx = j+dx[k],ny = i+dy[k];\n\t  if(!(0<=nx && nx <10 && 0<=ny && ny <10))continue;\n\t  syokurin[ny][nx]++;\n\t}\n      }\n    }\n\n    rep(i,10){\n      rep(j,10){\n\tif(syokurin[i][j] == 1)cout << 0;\n\telse syokurin[i][j]%2 == 0?cout << 0:cout << 1;\n\tif(j!=9)cout << \" \";\n      }\n      cout << endl;\n    }\n    if(n != 0)cout << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<iostream>\n\nusing namespace std;\n\nvector<int> GaussJordanMod2(vector<vector<unsigned int> > a){\n\tint n=a.size();\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i;j<n;j++){\n\t\t\tif(a[j][i/32]>>(i&31)&1){\n\t\t\t\ta[i].swap(a[j]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tunsigned int rev=a[i][i/32]&~((1<<(i&31))-1);\t\t\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(i==j||!(a[j][i/32]>>(i&31)&1))continue;\n\t\t\ta[j][i/32] ^= rev;\n\t\t\tfor(int k=i/32+1;k<(n+1+32-1)/32;k++){\n\t\t\t\ta[j][k] ^= a[i][k];\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> res(n);\n\tfor(int i=0;i<n;i++)res[i]=a[i][n/32]>>n%32&1;\n\treturn res;\n}\n\n\nint main(){\n\tint dy[]={0,1,0,-1,0};\n\tint dx[]={0,0,1,0,-1};\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\tvector<vector<unsigned int> > a(100,vector<unsigned int>((101+31)/32,0));\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint y=i/10,x=i%10;\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tint ny=y+dy[j],nx=x+dx[j];\n\t\t\t\tif(0<=ny&&ny<10&&0<=nx&&nx<10){\n\t\t\t\t\ta[ny*10+nx][i/32] |= 1<<(i&31);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\ta[i][100/32] |= c<<(100&31);\n\t\t}\n\t\tvector<int> ans(GaussJordanMod2(a));cout<<endl;\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcout<<ans[i*10];\n\t\t\tfor(int j=1;j<10;j++){\n\t\t\t\tcout<<' '<<ans[i*10+j];\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nbool mem[12][12],cop[12][12],done[12][12];\n\nint main(){\n  int n;cin>>n;\n  while(n--){\n    lol(i,10)lol(j,10)cin>>mem[i][j];\n    bool flag[10],tmp[10];\n    for(int p=1;p<=1024;p++){\n      lol(i,10)flag[i]=tmp[i];\n      lol(i,10)lol(j,10)cop[i][j]=mem[i][j];\n      for(int k=0;k<10;k++){\n\tlol(i,10){\n\t  if(!flag[i])continue;\n\t  for(int j=max(0,i-1);j<=min(9,i+1);j++)cop[k][j]^=1;\n\t  cop[k+1][i]^=1;\n\t}\n\tlol(i,10)done[k][i]=flag[i];\n\tlol(i,10)flag[i]=cop[k][i];\n      }\n      bool na=false;\n      lol(i,10)na&=flag[i];\n      if(!na){\n\tcout<<endl;\n\tlol(i,10){\n\t  lol(j,10)cout<<done[i][j]<<\" \";\n\t  cout<<endl;\n\t}\n\tbreak;\n      }\n      for(int i=0;i<10;i++){\n\tint r=pow(2,i);\n\tif(p%r==0)tmp[i]^=1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<climits>\n#include<string>\n#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<cmath>\n#include<queue>\n#include<cstring>\n#include<stack>\n#include<functional>\n#include<sstream>\nusing namespace std;\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nint dx[5] = {0, 1, 0, -1, 0}, dy[5] = {0, 0, 1, 0, -1};\nint fld[10][10];\n\nvoid Reverse(int x, int y, int cnt[10][10])\n{\n\tfor(int i = 0; i < 5; i++)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10) cnt[ny][nx]++;\n\t}\n}\n\nint main(){\n\tint N;\n\tcin >> N;\n\tfor(int c = 0; c < N; c++)\n\t{\n\t\tfor(int i = 0; i < 10; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t{\n\t\t\t\tcin >> fld[i][j];\n\t\t\t}\n\t\t}\n\n\t\tbool ans = false;\n\t\tint out[10][10];\n\t\tfor(int p = 0; p < (1 << 10); p++)\n\t\t{\n\t\t\tint cnt[10][10] = {};\n\t\t\tfor(int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tout[0][i] = ((p >> i) & 1);\n\t\t\t\tif(out[0][i] == 1) Reverse(i, 0, cnt);\n\t\t\t}\n\t\t\tfor(int i = 0; i < 9; i++)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < 10; j++)\n\t\t\t\t{\n\t\t\t\t\tif(((fld[i][j] + cnt[i][j]) & 1) == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tout[i + 1][j] = 1;\n\t\t\t\t\t\tReverse(j, i + 1, cnt);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tout[i + 1][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tans = true;\n\t\t\tfor(int i = 0; i < 10; i++)\n\t\t\t{\n\t\t\t\tif(((fld[9][i] + cnt[9][i]) & 1) == 1) ans = false;\n\t\t\t}\n\t\t\tif(ans) break;\n\t\t}\n\n\t\tfor(int i = 0; i < 10; i++)\n\t\t{\n\t\t\tprintf(\"%d\", out[i][0]);\n\t\t\tfor(int j = 1; j < 10; j++)\n\t\t\t{\n\t\t\t\tprintf(\" %d\", out[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint t[10][10],s[10][10],ans[10][10];\nint dx[] = {0,-1,0,1,0};\nint dy[] = {-1,0,0,0,1};\n\nbool check(int *used){\n\tmemset(ans,0,sizeof(ans));\n\tmemcpy(s,t,sizeof(t));\n\n\tfor(int i=0;i<10;i++){\n\t\tans[0][i] = used[i];\n\t\tif(used[i]){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tint nx = i + dx[j];\n\t\t\t\tint ny = dy[j];\n\n\t\t\t\tif(nx>=0 && 10>nx && ny>=0 && 10>ny){\n\t\t\t\t\ts[ny][nx] = !s[ny][nx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(s[i-1][j]){ //ツ湘」ツつェ1ツづ按づァツづ篠必ツつクツ古オツつェツ必ツ要\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tint ny = i + dy[k];\n\n\t\t\t\t\tif(nx>=0 && 10>nx && ny>=0 && 10>ny){\n\t\t\t\t\t\ts[ny][nx] = !s[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(s[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool solve(int idx,int *used){\n\tif(idx == 10){\n\t\tif(check(used)){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif(solve(idx+1,used)) return true;\n\tused[idx] = 1;\n\tif(solve(idx+1,used)) return true;\n\tused[idx] = 0;\n\n\treturn false;\n}\n\nint main(void){\n\tint n;\n\tcin>>n;\n\n\twhile(n--){\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tcin>>t[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint used[10];\n\t\tmemset(used,0,sizeof(used));\n\t\tsolve(0,used);\n\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\tcout<<ans[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<ans[i][9]<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10];\nint dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++){\n\n    int ny=y+dy[k],nx=x+dx[k];\n\n    if( 0<=ny && 0<=nx && ny<10 && nx<10)\n      b[ny][nx]=!b[ny][nx];\n  }\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++){\n    if(p[i])rev(i,0);\n    ans[0][i]=p[i];\n  }\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    p[cnt]=0;\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintAns() const\n\t{\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\nvoid DFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.insert( q.begin(), add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tDFS( M, Answer );\n\n\t\tcout << '\\n';\n\t\tAnswer.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nvvint vv,tt,ans;\nint dd[]={0,1,0,-1,0};\nbool check(int y,int x){\n\tif(0<=y&&y<10&&0<=x&&x<10) return true;\n\treturn false;\n}\nvoid foo(int y,int x){\n\ttt[y][x]=1-tt[y][x];\n\trep(i,4){\n\t\tif(check(y+dd[i],x+dd[i+1])) tt[y+dd[i]][x+dd[i+1]]=1-tt[y+dd[i]][x+dd[i+1]];\n\t}\n}\nvoid mainmain(){\n\tint n;\n\tcin>>n;\n\trep(g,n){\n\t\t// vvint vv;\n\t\tinitvv(vv,10,10);\n\t\trep(i,10) rep(j,10) cin>>vv[i][j];\n\t\trep(i,1<<10){\n\t\t\ttt=vv;\n\t\t\tinitvv(ans,10,10,0);\n\t\t\trep(j,10){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tans[0][j]=1;\n\t\t\t\t\tfoo(0,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\treep(j,1,10){\n\t\t\t\trep(k,10){\n\t\t\t\t\tif(tt[j-1][k]==1){\n\t\t\t\t\t\tans[j][k]=1;\n\t\t\t\t\t\tfoo(j,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f=true;\n\t\t\trep(j,10){\n\t\t\t\tif(tt[9][j]==1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\trep(j,10){\n\t\t\t\t\trep(k,10){\n\t\t\t\t\t\tif(k) cout<<\" \";\n\t\t\t\t\t\tcout<<ans[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nclass Board\n{\npublic:\n\tBoard()\n\t{\n\t\tmemset( m_board, 0, sizeof(m_board) );\n\t}\n\t~Board()\n\t{\n\t}\n\n\tvoid input()\n\t{\n\t\tfor( int i = 1; i < 11; ++i ){\n\t\t\tint bits = 0;\n\t\t\tfor( int j = 0; j < 10; ++j ){\n\t\t\t\tbits <<= 1;\n\t\t\t\tint n;\n\t\t\t\tcin >> n;\n\t\t\t\tbits |= n;\n\t\t\t}\n\t\t\tm_board[ i ] = bits;\n\t\t}\n\t}\n\tvoid output()\n\t{\n\t\tfor( int i = 0; i < 10; ++i ){\n\t\t\tint bit = 1 << 9;\n\t\t\tbool first = true;\n\t\t\tfor( int j = 0; j < 10; ++j ){\n\t\t\t\tif( first ){\n\t\t\t\t\tfirst = false;\n\t\t\t\t}else{\n\t\t\t\t\tcout << \" \";\n\t\t\t\t}\n\t\t\t\tcout << ( m_correct[ i ] & bit ? 1 : 0 );\n\t\t\t\tbit >>= 1;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\tbool light( int bits )\n\t{\n\t\tmemset( m_correct, 0, sizeof(m_correct) );\n\t\tint board[ 12 ];\n\t\tmemcpy( board, m_board, sizeof(m_board) );\n\n\t\tint mask = ( 1 << 10 ) - 1;\n\t\tfor( int i = 1; i < 11; ++i ){\n\t\t\tm_correct[ i - 1 ] = bits;\n\n\t\t\tboard[ i - 1 ] ^= bits; board[ i - 1 ] &= mask;\n\t\t\tboard[ i + 1 ] ^= bits; board[ i + 1 ] &= mask;\n\n\t\t\tboard[ i ] ^= bits;\n\t\t\tboard[ i ] ^= ( bits << 1 );\n\t\t\tboard[ i ] ^= ( bits >> 1 );\n\t\t\tboard[ i ] &= mask;\n\t\t\tif( i > 1 && board[ i - 1 ] != 0 ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbits = board[ i ];\n\t\t}\n\n\t\treturn board[ 10 ] == 0;\n\t}\n\nprivate:\n\tint m_board[ 12 ];\n\tint m_correct[ 10 ];\n};\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n ){\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tBoard board;\n\t\t\tboard.input();\n\n\t\t\tfor( int j = 0; j < ( 1 << 10 ); ++j ){\n\t\t\t\tif( board.light( j ) ){\n\t\t\t\t\tboard.output();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<complex>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<iostream>\nusing namespace std;\nint field[10][10];\nbool greed(string top){\n    int a[10][10];\n    int ans[10][10];\n    for(int i = 0;i < 10;i++){\n        for(int j = 0;j < 10;j++){\n            ans[i][j] = 0;\n        }\n    }\n    for(int i = 0;i < 10;i++){\n        for(int j = 0;j < 10;j++){\n            a[i][j] = field[i][j];\n        }\n    }\n    for(int j = 0;j < 10;j++){\n        if(top[j]=='1'){\n            ans[0][j] = 1;\n            a[0][j] = 1 - a[0][j];\n            if(j!=0)a[0][j-1] = 1 - a[0][j-1];\n            if(j!=9)a[0][j+1] = 1 - a[0][j+1];\n            a[1][j] = 1 - a[1][j];\n        }\n    }\n    for(int i = 1;i < 10;i++){\n        for(int j = 0;j < 10;j++){\n            if(a[i-1][j]==1){\n                ans[i][j] = 1;\n                a[i][j] = 1 - a[i][j];\n                if(i!=9)a[i+1][j] = 1 - a[i+1][j];\n                if(j!=9)a[i][j+1] = 1 - a[i][j+1];\n                if(i!=0)a[i-1][j] = 1 - a[i-1][j];\n                if(j!=0)a[i][j-1] = 1 - a[i][j-1];\n            }\n        }\n    }\n    bool flg = false;\n    for(int j = 0;j < 10;j++){\n        if(a[9][j]==1){\n            flg = true;\n            break;\n        }\n    }\n    if(!flg){\n        for(int i = 0;i < 10;i++){\n            cout<<ans[i][0];\n            for(int j = 1;j < 10;j++){\n                cout<<\" \"<<ans[i][j];\n            }\n            cout<<endl;\n        }\n        return true;\n    }\n    else return false;\n}\nint cnt;\n\nvoid perm(int dep,string top){\n    if(dep == 10){\n        greed(top);\n\n        return;\n    }\n    perm(dep + 1,top);\n    top[dep] = '1';\n    perm(dep + 1,top);\n}\nint main(void){\n\n    int n;\n    cin>>n;\n    while(n--){\n        for(int i = 0;i < 10;i++)\n            for(int j = 0;j < 10;j++)\n                cin>>field[i][j];\n\n        perm(0,\"0000000000\");\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i) for(int j = 0; j < MAX; ++j) m[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) &&\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+5)%sz]][j+dj[(k+5)%sz]] == 1 && inRange(i+di[(k+5)%sz]) && inRange(j+dj[(k+5)%sz])) ||\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+6)%sz]][j+dj[(k+6)%sz]] == 1 && inRange(i+di[(k+6)%sz]) && inRange(j+dj[(k+6)%sz])) ||\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+7)%sz]][j+dj[(k+7)%sz]] == 1 && inRange(i+di[(k+7)%sz]) && inRange(j+dj[(k+7)%sz]))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10],b[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j],b[i][j]=mp[i][j];\n\n    int ans[10][10]={};\n    for(int i=0;!check(mp);i++){\n      for(int j=0;j<10;j++)for(int k=0;k<10;k++) mp[j][k]=b[j][k];\n      for(int j=0;j<10;j++)for(int k=0;k<10;k++) b[j][k]=mp[j][k];\n\n      for(int j=0;j<10;j++)if((ans[0][j]=((i>>j)%2)))mark(mp,0,j);\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n\tassert(ans[i][j]==0||ans[i][j]==1);\n      }\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[10][10];\nint main() {\n\tint n; cin >> n;\n\tfor (int h = 0; h < n; h++) {\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfor (int j = 1; j <= 10; j++)cin >> x[i][j];\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << 10); i++) {\n\t\t\tint bit[11]; for (int j = 0; j < 10; j++)bit[j + 1] = (i / (1 << j)) % 2;\n\t\t\tint T[12][12], V[12][12];\n\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\tfor (int k = 0; k < 12; k++) { T[j][k] = 0; V[j][k] = 0; }\n\t\t\t}\n\n\t\t\tfor (int j = 1; j <= 10; j++) {\n\t\t\t\tif (bit[j] == 1) {\n\t\t\t\t\tT[0][j]++; T[0][j] %= 2;\n\t\t\t\t\tT[1][j]++; T[1][j] %= 2;\n\t\t\t\t\tT[0][j - 1]++; T[0][j - 1] %= 2;\n\t\t\t\t\tT[0][j + 1]++; T[0][j + 1] %= 2;\n\t\t\t\t\tV[0][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (T[j - 1][k + 0] != x[j - 1][k + 0]) {\n\t\t\t\t\t\tT[j - 1][k + 0]++; T[j - 1][k + 0] %= 2;\n\t\t\t\t\t\tT[j + 0][k + 0]++; T[j + 0][k + 0] %= 2;\n\t\t\t\t\t\tT[j + 1][k + 0]++; T[j + 1][k + 0] %= 2;\n\t\t\t\t\t\tT[j + 0][k - 1]++; T[j + 0][k - 1] %= 2;\n\t\t\t\t\t\tT[j + 0][k + 1]++; T[j + 0][k + 1] %= 2;\n\t\t\t\t\t\tV[j][k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool OK = true; for (int k = 0; k < 10; k++) { if (T[9][k] != x[9][k])OK = false; }\n\t\t\tif (OK == true) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\t\tif (k)cout << ' '; cout << V[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,0,-1},dy[] = {1,0,-1,0,0};\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tint a[10][10];\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\tfor(int k = 0;k < 10;k++) cin >> a[j][k];\n\t\t}\n\t\tfor(int j = 0;j < 1024;j++){\n\t\t\tint b[10][10] = {},t[10][10];\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tt[k][l] = a[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif((j >> k) & 1){\n\t\t\t\t\tb[0][k] = 1;\n\t\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\t\tint nx = dx[l],ny = k + dy[l];\n\t\t\t\t\t\tif(ny >= 0 && ny < 10){\n\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 9;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tif(t[k][l]){\n\t\t\t\t\t\tb[k + 1][l] = 1;\n\t\t\t\t\t\tfor(int n = 0;n < 5;n++){\n\t\t\t\t\t\t\tint nx = k + 1 + dx[n],ny = l + dy[n];\n\t\t\t\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(t[9][k]) flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\t\tfor(int l = 0;l < 10;l++) {\n\t\t\t\t\t\tcout << (!l ? \"\" : \" \") << b[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint a[10];\nint b[10];\nint c[10];\n\nint main() {\n  int n, t;\n  bool solved;\n  scanf(\"%d\", &n);\n  for (int x=0; x<n; x++) {\n    for (int i=0; i<10; i++) a[i] = 0;\n    for (int i=0; i<10; i++) {\n      for (int j=0; j<10; j++) {\n        scanf(\"%d\", &t);\n        a[i] |= t<<j;\n      }\n    }\n\n    solved = false;\n    for (int i=0; i<(1<<10); i++) {\n      memcpy(b, a, sizeof(a));\n      b[0] ^= i;\n      b[0] ^= i<<1;\n      b[0] ^= i>>1;\n      b[0] &= (1<<10)-1;\n      b[1] ^= i;\n      for (int j=1; j<10; j++) {\n        b[j] ^= b[j-1];\n        b[j] ^= b[j-1]<<1;\n        b[j] ^= b[j-1]>>1;\n        b[j] &= (1<<10)-1;\n        if (j<9) {\n          b[j+1] ^= b[j-1];\n        }\n      }\n      if (!b[9]) {\n        c[0] = i;\n        for (int j=1; j<10; j++) {\n          c[j] = b[j-1];\n        }\n        solved = true;\n        break;\n      }\n    }\n\n    if (solved) {\n      for (int i=0; i<10; i++) {\n        for (int j=0; j<10; j++) {\n          if (j) putchar(' ');\n          printf(\"%d\", (c[i]>>j)&1);\n        }\n        putchar('\\n');\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nbool ans[10][10];\nbool ba[10][10];\nint dx[] = {-1,0,0,0,1};\nint dy[] = {0, -1,0, 1, 0};\n\nbool judge(int x, int y) {\n  int res = ba[x][y];\n  REP(k,5) {\n    int xx = x + dx[k];\n    int yy = y + dy[k];\n    if (xx < 0 || xx >= 10 || yy < 0 || yy >= 10) continue;\n    if (ans[xx][yy]) res++;\n  }\n  return res % 2;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    REP(y,10)\n      REP(x,10)\n      cin >> ba[x][y];\n    \n    for (int i=0; i<(1<<10); ++i) {\n      memset(ans, 0, sizeof(ans));\n      REP(j,10)\n        if ((i>>j)&1)\n          ans[j][0] = 1;\n      for(int y=1; y<10; ++y) {\n        REP(x,10) {\n          if (judge(x,y-1))\n            ans[x][y] = 1;\n        }\n      }\n      bool f = 1;\n      REP(i,10)\n        if (judge(i, 9)) f = 0;\n      if (f) \n        break;\n    }\n    REP(y,10) {\n      REP(x,10) {\n        if (x) cout << \" \";\n        cout << ans[x][y];\n      }\n      cout << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tint TryPassParticle(int i, int j)\n\t{\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\n\t\treturn cnt1;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, max1 = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz],1,MAX-1) && inRange(j+dj[(k+2)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz],1,MAX-1) && inRange(j+dj[(k+3)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz],1,MAX-1) && inRange(j+dj[(k+4)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tint d = M.TryPassParticle( i+di[(k+6)%sz],j+dj[(k+6)%sz] );\n\t\t\t\t\t\t\t\tif( d > max1 )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmax1 = d;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << endl;\n\t\tM.Print();*/\n\t\t\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint N;\nint A[10][10],B[10][10],T[10][10];\nmain()\n{\n\tcin>>N;\n\tfor(;N--;)\n\t{\n\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>A[i][j];\n\t\tfor(int i=0;i<1<<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)for(int k=0;k<10;k++)T[j][k]=A[j][k],B[j][k]=0;\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(i>>j&1)\n\t\t\t\t{\n\t\t\t\t\tB[0][j]=1;\n\t\t\t\t\tT[0][j]^=1;\n\t\t\t\t\tT[1][j]^=1;\n\t\t\t\t\tif(j>0)T[0][j-1]^=1;\n\t\t\t\t\tif(j<9)T[0][j+1]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1;j<10;j++)\n\t\t\t{\n\t\t\t\tfor(int k=0;k<10;k++)\n\t\t\t\t{\n\t\t\t\t\tif(T[j-1][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tB[j][k]=1;\n\t\t\t\t\t\tT[j-1][k]^=1;\n\t\t\t\t\t\tT[j][k]^=1;\n\t\t\t\t\t\tif(k>0)T[j][k-1]^=1;\n\t\t\t\t\t\tif(k<9)T[j][k+1]^=1;\n\t\t\t\t\t\tif(j<9)T[j+1][k]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<10;j++)if(T[9][j])flag=false;\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=0;k<10;k++)cout<<B[j][k]<<(k==9?\"\\n\":\" \");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef long long ll;\n\nint main(){\n    int n;\n    cin >> n;\n    while(n!=0){\n        int bs[10][10]; \n        REP(i,10)REP(j,10)cin >> bs[i][j];\n        int flip[10][10]; \n        int ans[10][10]; \n        REP(i,1<<10){\n            memset(flip,0,sizeof(flip));\n            memset(ans,0,sizeof(ans));\n            REP(j,10){\n                if((i>>j)&1){\n                    ans[0][j]=1;\n                    flip[0][j]^=1;\n                    if(j-1>=0)flip[0][j-1]^=1;\n                    if(j+1<10)flip[0][j+1]^=1;\n                    flip[1][j]^=1;\n                }\n            }\n            FOR(y,1,10){\n                REP(x,10){\n                    if(flip[y-1][x] ^ bs[y-1][x]){\n                        ans[y][x]=1;\n                        flip[y-1][x]^=1;\n                        flip[y][x]^=1;\n                        if(x-1>=0)\n                            flip[y][x-1]^=1;\n                        if(x+1<10)\n                            flip[y][x+1]^=1;\n                        if(y+1<10)\n                            flip[y+1][x]^=1;\n                    }\n                }\n            }\n\n            int flag=1;\n            REP(y,10){\n                REP(x,10){\n                    if(flip[y][x] ^ bs[y][x]){\n                        flag=0;\n                        y=10;\n                        break;\n                    }\n                }\n            }\n\n            if(flag){\n                REP(y,10){\n                    REP(x,10){\n                        cout << ans[y][x]  << (x==9 ? \"\\n\" : \" \");\n                    }\n                }\n                break;\n            }\n        }\n        n--;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define BOARD_SIZE 10\n\nvoid init(int a[BOARD_SIZE])\n{\n\tfor (int i=0; i<BOARD_SIZE; i++) a[i] = 0;\n}\n\nvoid init(int a[][BOARD_SIZE])\n{\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) a[i][j] = 0;\n\t}\n}\n\nvoid copy(int a[][BOARD_SIZE], int b[][BOARD_SIZE])\n{\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) a[i][j] = b[i][j];\n\t}\n}\n\nbool next(int a[BOARD_SIZE])\n{\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tif (a[i] == 0) { a[i] = 1; return true; }\n\t\ta[i] = 0;\n\t}\n\treturn false;\n}\n\nvoid point(int a[], int board[][BOARD_SIZE], int i, int j)\n{\n\tboard[i][j] = 1 - board[i][j];\n\tif (i>0) board[i-1][j] = 1 - board[i-1][j];\n\tif (i<BOARD_SIZE-1) board[i+1][j] = 1 - board[i+1][j];\n\tif (j>0) board[i][j-1] = 1 - board[i][j-1];\n\tif (j<BOARD_SIZE-1) board[i][j+1] = 1 - board[i][j+1];\n}\n\nbool isCorrect(int board[][BOARD_SIZE])\n{\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board[i][j] == 1) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid show(int a[][BOARD_SIZE])\n{\n\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\tstd::cout << a[i][0];\n\t\tfor (int j=1; j<BOARD_SIZE; j++) {\n\t\t\tstd::cout << \" \" << a[i][j];\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}\n\nbool check(int a[], int board[][BOARD_SIZE], int ans[][BOARD_SIZE])\n{\n\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\tif (a[j] == 1) { point(a, board, 0, j); ans[0][j] = 1; }\n\t}\n\t\n\tfor (int i=1; i<BOARD_SIZE; i++) {\n\t\tfor (int j=0; j<BOARD_SIZE; j++) {\n\t\t\tif (board[i-1][j] == 1) { point(a, board, i, j); ans[i][j] = 1; }\n\t\t}\n\t}\n\treturn isCorrect(board);\n}\n\nint main()\n{\n\tint board[BOARD_SIZE][BOARD_SIZE];\n\tint board_cpy[BOARD_SIZE][BOARD_SIZE];\n\tint a[BOARD_SIZE];\n\tint ans[BOARD_SIZE][BOARD_SIZE];\n\tint n; std::cin >> n;\n\tfor (int k=0; k<n; k++) {\n\t\tfor (int i=0; i<BOARD_SIZE; i++) {\n\t\t\tfor (int j=0; j<BOARD_SIZE; j++) std::cin >> board[i][j];\n\t\t}\n\t\tinit(a);\n\t\tdo {\n\t\t\tinit(ans);\n\t\t\tcopy(board_cpy, board);\n\t\t\tif (check(a, board_cpy, ans)) { show(ans); break; }\n\t\t} while (next(a));\n\t}\n\t\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint a[10][10],b[10][10],ans[10][10];\nint dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){for(int i=0;i<10;i++){for(int j=0;j<10;j++){b[i][j]=a[i][j];ans[i][j]=0;}}}\n\nvoid rev(int x, int y){for(int k=0;k<5;k++){int ny=y+dy[k],nx=x+dx[k];\n    if( 0<=ny && 0<=nx && ny<10 && nx<10)b[ny][nx]=!b[ny][nx];}}\n\nint ok(void){for(int i=0;i<10;i++)for(int j=0;j<10;j++)if(b[i][j])return 0;return 1;}\n\nvoid solve(int p[]){\n  init();for(int i=0;i<10;i++){if(p[i])rev(i,0);ans[0][i]=p[i];}\n  for(int i=1;i<10;i++){for(int j=0;j<10;j++){if(b[i-1][j]){rev(j,i);ans[i][j]=1;}}}\n  if(ok()){for(int i=0;i<10;i++){for(int j=0;j<10;j++){\tcout << ans[i][j];if(j<9)cout << \" \";}cout << endl;}}}\n\nvoid func(int p[], int cnt){if(9<cnt)solve(p);else {p[cnt]=0;func(p,cnt+1);p[cnt]=1;func(p,cnt+1);}}\n\nint main(void){\n  int n;cin >> n;\n  while(n--){for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin >> a[i][j];\n    int p[10]={0};func(p,0);\n  }return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    int state[10][10];\n    int ans[10][10];\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) {\n                    state[i][j]     = 1 - state[i][j];\n                    state[i+1][j-1] = 1 - state[i+1][j-1];\n                    state[i+1][j]   = 1 - state[i+1][j];\n                    state[i+1][j+1] = 1 - state[i+1][j+1];\n                    state[i+2][j]   = 1 - state[i+2][j];\n                    ans[i+1][j] = 1;\n                }\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,0,-1,1,-1};\nconst int dx[] = {0,-1,0,1,0,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nconst int W = 10,H = 10;\nint tile[W][H];\nint opt[W][H];\nint flip[W][H];\n\nint get(int x,int y){\n  int c = tile[x][y];\n  rep(i,5){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(value(nx,ny,W,H)){\n      c += flip[nx][ny];\n    }\n  }\n  return c % 2;\n}\n\nint calc(){\n  REP(i,1,W){\n    rep(j,H){\n      if(get(i-1,j) != 0){\n        flip[i][j] = 1;\n      }\n    }\n  }\n  rep(j,H){\n    if(get(W-1,j) != 0)\n      return -1;\n  }\n  int res = 0;\n  rep(i,W){\n    rep(j,H){\n      res += flip[i][j];\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int res = -1;\n  rep(i,1 << H){\n    memset(flip, 0, sizeof(flip));\n    rep(j,W){\n      flip[0][H-j-1] = i >> j & 1;\n    }\n    if(calc() != -1){\n      break;\n    }\n  }\n  rep(i,W){\n    rep(j,H){\n      if(j) cout << ' ';\n      cout << flip[i][j] ;\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  rep(x,n){\n    rep(i,W){\n      rep(j,H){\n        cin >> tile[i][j];\n      }\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nbool mem[12][12],cop[12][12],done[12][12];\n\nint main(){\n  int n;cin>>n;\n  while(n--){\n    lol(i,10)lol(j,10)cin>>mem[i][j];\n    bool flag[10],tmp[10]={0};\n    for(int p=1;p<=1024;p++){\n      lol(i,10)flag[i]=tmp[i];\n      lol(i,10)lol(j,10)cop[i][j]=mem[i][j];\n      for(int k=0;k<10;k++){\n\tlol(i,10){\n\t  if(!flag[i])continue;\n\t  for(int j=max(0,i-1);j<=min(9,i+1);j++)cop[k][j]^=1;\n\t  cop[k+1][i]^=1;\n\t}\n\tlol(i,10)done[k][i]=flag[i];\n\tlol(i,10)flag[i]=cop[k][i];\n      }\n      bool na=false;\n      lol(i,10)na|=flag[i];\n      if(!na){\n\tlol(i,10){\n\t  lol(j,10){\n\t    if(j)cout<<\" \";\n\t    cout<<done[i][j];\n\t  }\n\t  cout<<endl;\n\t}\n\tbreak;\n      }\n      for(int i=0;i<10;i++){\n\tint r=pow(2,i);\n\tif(p%r==0)tmp[i]^=1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P pair<int, int>\nconst int H = 10;\nconst int W = 10;\n\nint my[5] = {1, -1, 0, 0, 0};\nint mx[5] = {0, 0, 1, -1, 0};\n\nvector< vector<int> > ans;\nset< vector< vector<int> > > S;\n\nbool end(int v[H][W]){\n  REP(i, H) REP(j, W) if(v[i][j] == 1) return false;\n  return true;\n}\n\nbool next(int v[H][W], int y, int x){\n  int a = 0, b = 0;\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n      if(v[ny][nx]) ++a;\n      else ++b;\n    }\n  }\n  return a > b;\n}\n\nvoid rev(int v[H][W], int y, int x){\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = (v[ny][nx] + 1) % 2;\n  }\n}\n\nvoid dfs(int v[H][W], vector< vector<int> > &u){\n  if(end(v)) { ans = u; return ; }\n  if(S.find(u) != S.end()) return ;\n  S.insert(u);\n  REP(i, H){\n    REP(j, W){\n      if(!next(v, i, j) || u[i][j]) continue;\n      rev(v, i, j);\n      u[i][j] = 1;\n      dfs(v, u);\n      u[i][j] = 0;\n      rev(v, i, j);\n    }\n  }\n}\n\nint main() {\n  int T; cin >>T;\n  REP(t, T){\n    ans = vector< vector<int> >();\n    S = set< vector< vector<int> > >();\n    int v[H][W];\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    vector< vector<int> > u(H, vector<int>(W, 0));\n    dfs(v, u);\n    REP(i, H){\n      REP(j, W) cout <<ans[i][j] <<(j + 1 == W ? \"\" : \" \");\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvoid flip(int x,int y,int stage[10][10]){\n\tconst int t[][2] = {{0,0},{-1,0},{1,0},{0,1},{0,-1}};\n\tfor(int i=0;i<5;i++){\n\t\tint dx = x+t[i][0];\n\t\tint dy = y+t[i][1];\n\n\t\tif(dx < 0 || dx >= 10 || dy < 0 || dy >= 10) continue;\n\n\t\tstage[dy][dx]*=-1;\n\t}\n}\n\nbool checkStage(int store[10][10],int x,int y){\n\treturn store[y][x] == -1 ? true : false;\n}\n\nbool isClear(int store[10][10]){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(store[y][x]==1) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid writeResult(int result[10][10]){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tprintf(\"%d%s\",result[y][x],x==9 ? \"\\n\" : \" \");\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint stage[10][10];\n\t\t\t\n\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\tint num;\n\t\t\t\t\tscanf(\"%d\",&num);\n\t\t\t\t\tstage[y][x] = (num == 0 ? -1 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S=0;S<(1 << 10)-1;S++){\n\t\t\t\tint store[10][10];\n\t\t\t\tint result[10][10];\n\t\t\t\tmemset(result,0,sizeof(result));\n\t\t\t\t//memset(store,0,sizeof(store));\n\t\t\t\tmemcpy(store,stage,sizeof(stage));\n\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif((S>>j) & 1){\n\t\t\t\t\t\tflip(j,0,store);\n\t\t\t\t\t\tresult[0][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int y=1;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tflip(x,y,store);\n\t\t\t\t\t\tif(!checkStage(store,x,y-1)){\n\t\t\t\t\t\t\tflip(x,y,store);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tresult[y][x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(isClear(store)){\n\t\t\t\t\twriteResult(result);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int dx[5] = {-1, 0, 0, 0, 1};\nconst int dy[5] = {0, -1, 0, 1, 0};\n\nconst int SIZE = 10;\nint tile[SIZE][SIZE];\nint flip[SIZE][SIZE];\n\nint get(int x, int y)\n{\n    int c = tile[x][y];\n\n    for (int d = 0; d < 5; ++d) {\n        int x2 = x + dx[d];\n        int y2 = y + dy[d];\n\n        if (0 <= x2 && x2 < SIZE && 0 <= y2 && y2 < SIZE)\n            c += flip[x2][y2];\n    }\n\n    return c % 2;\n}\n\nbool calc()\n{\n    for (int i = 1; i < SIZE; ++i) \n        for (int j = 0; j < SIZE; j++) \n            if (get(i - 1, j) != 0) \n                flip[i][j] = 1;\n\n    for (int j = 0; j < SIZE; ++j)\n        if (get(SIZE - 1, j) != 0)\n            return false;\n\n    return true;\n}\n\nvoid solve()\n{\n    for (int i = 0; i < 1 << SIZE; ++i) {\n        memset(flip, 0, sizeof(flip));\n        for (int j = 0; j < SIZE; ++j) \n            flip[0][SIZE - j - 1] = i >> j & 1;\n\n        if(calc())\n            break;\n    }\n\n    for (int i = 0; i < SIZE; ++i)\n        for (int j = 0; j < SIZE; ++j) \n            cout << flip[i][j] << ((j == SIZE - 1) ? '\\n' : ' ');\n}\n\nint main()\n{\n    int n;\n    \n    cin >> n;\n    while (n--) {\n        for (int i = 0; i < SIZE; ++i)\n            for (int j = 0; j < SIZE; ++j)\n                cin >> tile[i][j];\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nstruct UF {\n    vi e;\n    UF(int n) : e(n, -1) {}\n    bool same_set(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\n    void join(int a, int b) {\n        a = find(a), b = find(b);\n        if(a == b) return;\n        if(e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n    }\n};\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    int cnt=0;\n    while(n--) {\n        vector<vector<int>> v(10);\n\n        for(int i=0; i<10; ++i){\n            for(int j=0; j<10; ++j){\n                int a; cin >> a;\n                v[i].push_back(a);\n            }\n        }\n\n        bool f = false;\n        for(int bit=0; bit<(1<<10); ++bit){\n            int arr[15][15]={0};\n\n            int ans[10][10]={0};\n            for(int i=0; i<10; ++i){\n                if(bit >> i & 1){\n                    ans[0][i]=1;\n                    if(i==0){\n                        arr[0][0] ^= 1;\n                        arr[1][0] ^= 1;\n                        arr[0][1] ^= 1;\n                    }else if(i==9){\n                        arr[0][i] ^= 1;\n                        arr[1][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                    }else{\n                        arr[0][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                        arr[0][i+1] ^= 1;\n                        arr[1][i] ^= 1;\n                    }\n                }\n            }\n\n            for(int i=1; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if((arr[i-1][j] == 0 && v[i-1][j]==1) || (arr[i-1][j]==1 && v[i-1][j]==0)){\n                        ans[i][j]=1;\n                        if(j==0){\n                            arr[i][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }else if(j==9){\n                            arr[i][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                        }else{\n                            arr[i][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }\n                    }\n                }\n            }\n            bool d = true;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i][j]!=v[i][j]) d= false;\n                }\n            }\n            if(!d) continue;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(j) cout << \" \";\n                    cout << ans[i][j];\n                }\n                cout << endl;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i) for(int j = 0; j < MAX; ++j) m[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) &&\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t/*(M.m[i+di[(k+5)%sz]][j+dj[(k+5)%sz]] == 1 && inRange(i+di[(k+5)%sz]) && inRange(j+dj[(k+5)%sz])) ||*/\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+6)%sz]][j+dj[(k+6)%sz]] == 1 && inRange(i+di[(k+6)%sz]) && inRange(j+dj[(k+6)%sz])) /*||*/\n\t\t\t\t\t\t\t\t/* (M.m[i+di[(k+7)%sz]][j+dj[(k+7)%sz]] == 1 && inRange(i+di[(k+7)%sz]) && inRange(j+dj[(k+7)%sz]))*/\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \n\nclass Point\n{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0, double y = 0) :x(x), y(y) {}\n\n\n\tPoint operator + (Point p) { return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p) { return Point(x - p.x, y - p.y); }\n\tPoint operator * (double k) { return Point(x * k, y * k); }\n\tPoint operator / (double k) { return Point(x / k, y / k); }\n\tbool operator < (const Point &p)const { return x != p.x ? x < p.x : y < p.y; }\n\tbool operator ==(const Point &p)const { return fabs(x - p.x) < EPS&&fabs(y - p.y) < EPS; }\n\n\tdouble abs() { return sqrt(norm()); }\n\tdouble norm() { return x*x + y*y; }\n};\ntypedef Point Vector;\nstruct Segment\n{\n\tPoint p1, p2;\n};\ntypedef Segment Line;\nclass Circle\n{\npublic:\n\tPoint c;\n\tdouble r;\n\tCircle(Point c = Point(), double r = 0.0) :c(c), r(r) {}\n};\n\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }//??????\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }//??????\nbool isOrthogonal(Vector a, Vector b) { return fabs(dot(a, b)) < EPS; }//??´??????\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) { return isOrthogonal(a1 - a2, b1 - b2); }\nbool isOrthogonal(Line l1, Line l2) { return fabs(dot(l1.p2 - l1.p1, l2.p2 - l2.p1)) < EPS; }\nbool isParallel(Vector a, Vector b) { return fabs(cross(a, b)) < EPS; }//?????????\nbool isParallel(Point a1, Point a2, Point b1, Point b2) { return isParallel(a1 - a2, b1 - b2); }\nbool isParallel(Line l1, Line l2) { return fabs(cross(l1.p2 - l1.p1, l2.p2 - l2.p1)) < EPS; }\nPoint project(Line s, Point p)\n{\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / base.norm();\n\treturn s.p1 + base*r;\n}\n\n\nint dx[5] = { 0,-1,0,1,0 }, dy[5] = { 1,0,0,0,-1 };\nbool check(int a[12][12])\n{\n\tint t = 0;\n\tfor (int i = 1; i <= 10; i++)for (int j = 1; j <= 10; j++)t += a[i][j];\n\treturn t == 0;\n}\nvoid paint(int f[12][12], int x, int y)\n{\n\tfor (int k = 0; k < 5; k++)\n\t{\n\t\tf[x + dx[k]][y + dy[k]]++;\n\t\tf[x + dx[k]][y + dy[k]] %= 2;\n\t}\n}\nint main()\n{\n\tint n; cin >> n;\n\twhile (n--)\n\t{\n\t\tint a[12][12] = {};\n\t\tbool ans[12][12] = {};\n\t\tfor (int i = 1; i <= 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= 10; j++)\n\t\t\t{\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < 1024; c++)\n\t\t{\n\t\t\tint f[12][12];\n\t\t\tmemset(ans, 0, sizeof ans);\n\t\t\tfor (int i = 0; i < 12; i++)for (int j = 0; j < 12; j++)f[i][j] = a[i][j];\n\t\t\tbitset<10> b(c);\n\t\t\tfor (int i = 1; i <= 10; i++)\n\t\t\t{\n\t\t\t\tans[1][i] = b[i - 1];\n\t\t\t\tif (b[i - 1])\n\t\t\t\t{\n\t\t\t\t\tpaint(f, 1, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 2; i <= 10; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 1; j <= 10; j++)\n\t\t\t\t{\n\t\t\t\t\tif (f[i - 1][j])\n\t\t\t\t\t{\n\t\t\t\t\t\tpaint(f, i, j);\n\t\t\t\t\t\tans[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(f))break;\n\t\t}\n\t\tfor (int i = 1; i <= 10; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= 10; j++)\n\t\t\t{\n\t\t\t\tcout << ans[i][j];\n\t\t\t\tif (j != 10)cout << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\nint a[10][10],b[10][10],m[10][10];\n\nvoid rev(int x,int y) {\n\tb[y][x]=1;\n\tif (x>0) a[y][x-1]=1-a[y][x-1];\n\tif (x<9) a[y][x+1]=1-a[y][x+1];\n\tif (y>0) a[y-1][x]=1-a[y-1][x];\n\tif (y<9) a[y+1][x]=1-a[y+1][x];\n\ta[y][x]=1-a[y][x];\n}\n\nint main() {\n\tint n,i,j,k;\n\tcin >> n;\n\tfor (n;n>0;n--) {\n\t\tfor (i=0;i<10;i++) for (j=0;j<10;j++) cin >> m[i][j];\n\t\tfor (k=0;k<1024;k++) {\n\t\t\tmemset(a,0,sizeof(a)); memset(b,0,sizeof(b));\n\t\t\tfor (i=0,j=k;i<10;i++,j/=2)  if (j % 2==1) rev(i,0); \n\t\t\tfor (i=1;i<10;i++) for (j=0;j<10;j++) if (m[i-1][j]!=a[i-1][j]) rev(j,i);\n\t\t\tfor (i=0;i<10;i++) if (m[9][i]!=a[9][i]) break;\n\t\t\tif (i==10) break; \n\t\t}\n\t\tfor (i=0;i<10;i++) {\n\t\t\tcout << b[i][0];\n\t\t\tfor (j=1;j<10;j++) cout << ' ' << b[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint OriginalData[10][10], Ans[10][10], Tmp[10][10];\nint Used[10];\n\nbool judge() {\n\tint dx[] = { 0,-1,0,1,0 };\n\tint dy[] = { -1,0,0,0,1 };\n\tint currentX, currentY;\n\n\tmemset(Ans, 0, sizeof(Ans));\n\tmemcpy(Tmp, OriginalData, sizeof(Tmp));\n\n\tfor (int j = 0; j < 10; j++) {\n\t\tAns[0][j] = Used[j];\n\t\tif (Used[j]) {\n\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\tcurrentX = dx[k];\n\t\t\t\tcurrentY = j + dy[k];\n\n\t\t\t\tif (currentX<0 || currentX>9 || currentY<0 || currentY>9) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tTmp[currentX][currentY] = !Tmp[currentX][currentY];\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i < 10; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (Tmp[i - 1][j]) {\n\t\t\t\tAns[i][j] = 1;\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tcurrentX = i + dx[k];\n\t\t\t\t\tcurrentY = j + dy[k];\n\n\t\t\t\t\tif (currentX<0 || currentX>9 || currentY<0 || currentY>9) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tTmp[currentX][currentY] = !Tmp[currentX][currentY];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < 10; i++) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tif (Tmp[i][j]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool solve(int col) {\n\tif (col == 10) {\n\t\tif (judge()) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (solve(col + 1)) {\n\t\treturn true;\n\t}\n\tUsed[col] = 1;\n\tif (solve(col + 1)) {\n\t\treturn true;\n\t}\n\tUsed[col] = 0;\n\t\n\treturn false;\n}\n\nint main() {\n\tint n;\n\n\tcin >> n;\n\twhile (n--) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tcin >> OriginalData[i][j];\n\t\t\t}\n\t\t}\n\t\tmemset(Used, 0, sizeof(Used));\n\t\tsolve(0);\n\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tcout << Ans[i][j] << (j == 9 ? \"\\n\" : \" \");\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\tif(!fir)cout<<endl;\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif(tmp-(panel[j]>>k)&1)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans[9]==0){\n\t\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\t\tint tmp=(ans[i]>>j)&1;\n\t\t\t\t\t\tprintf(j==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,s,y,x,i;\nint d[12][12],b[12][12],a[12][12];\nint dx[] = { 0,0,0,1,-1};\nint dy[] = {-1,1,0,0, 0};\n\nvoid flip(x, y)\n{\n\ta[y][x] = 1;\n\tfor(i=0; i<5; i++)\n\t{\n\t\tb[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\twhile(n--)\n\t{\n\t\tfor(y=1; y<=10; y++)\n\t\tfor(x=1; x<=10; x++)\n\t\t{\n\t\t\tcin >> d[y][x];\n\t\t}\n\n\t\tfor(i=0; i<1024; i++)\n\t\t{\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tmemcpy(b,d,sizeof(d));\n\n\t\t\tfor(y=1,x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tif((i>>(x-1))&1) flip(x,y);\n\t\t\t}\n\n\t\t\tfor(y=2; y<=10; y++)\n\t\t\tfor(x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tif(b[y-1][x]) flip(x,y);\n\t\t\t}\n\n\t\t\tfor(y=10,x=1,s=0; x<=10; x++)\n\t\t\t{\n\t\t\t\ts+=b[y][x];\n\t\t\t}\n\n\t\t\tif(s==0) break;\n\t\t}\n\n\t\tfor(y=1; y<=10; y++)\n\t\t{\n\t\t\tfor(x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tcout << a[y][x] << (x==10?\"\":\" \");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\nint n = 10;\nbool in(int a, int b){\n    if(a < 0 || a >= n || b < 0 || b >= n)return false;\n    return true;\n}\nint dx[] = {0,0,1,0,-1};\nint dy[] = {0,1,0,-1,0};\n\nsigned main(void) {\n    int num;\n    cin >> num;\n    while(num--){\n        vvi a(n,vi(n));\n        rep(i,n)rep(j,n)cin >> a[i][j];\n        rep(bit, 1<<n){\n            vvi t = a;\n            vvi ans(n,vi(n,0));\n            rep(i,n)if(bit&(1<<i)){\n                ans[0][i]++;\n                rep(j,5){\n                    int x = 0 + dx[j];\n                    int y = i + dy[j];\n                    if(in(x,y))t[x][y] ^= 1;\n                }\n            }\n            rep(i,n-1)rep(j,n)if(t[i][j]){\n                ans[i+1][j]++;\n                rep(k,5){\n                    int x = i+1 + dx[k];\n                    int y = j + dy[k];\n                    if(in(x,y))t[x][y] ^= 1;\n                }\n            }\n            bool c = true;\n            rep(j,n)if(t[n-1][j])c = false;\n            if(c){\n                rep(i,n)rep(j,n)cout << ans[i][j] << \" \\n\"[j == n-1];\n            }\n        }\n        vvi ans(n,vi(n,0));\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nvoid frip(int y, int x, int map[10][10]){\n\tif(y < 0 || x < 0 || y >= 10 || x >= 10){\n\t\treturn;\n\t}else{\n\t\tmap[y][x] = !map[y][x];\n\t}\n}\n\nvoid frips(int y, int x, int map[10][10]){\n\tfrip(y - 1, x, map);\n\tfrip(y + 1, x, map);\n\tfrip(y, x, map);\n\tfrip(y, x - 1, map);\n\tfrip(y, x + 1, map);\n}\n\nint main(){\n\t\n\tint n;\n\t\n\tint origin[10][10];\n\t\n\tint f_point[10][10];\n\t\n\tint map[10][10];\n\t\n\tbool checker;\n\t\n\tcin >> n;\n\t\n\tint N = 10;\n\n\tfor(int loop = 0; loop < n; loop++){\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tcin >> origin[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1 << N); i++){\n\t\t\t\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tfor(int y = 0; y < N; y++){\n\t\t\t\t\tmap[y][x] = origin[y][x];\n\t\t\t\t\tf_point[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int x = 0; x < N; x++){\n\t\t\t\tif((i & (1 << (N - x - 1))) != 0){\n\t\t\t\t\tfrips(0, x, map);\n\t\t\t\t\tf_point[0][x] = 1;\n\t\t\t\t}else{\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 1; y < N; y++){\n\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\tif(map[y - 1][x]){\n\t\t\t\t\t\tfrips(y, x, map);\n\t\t\t\t\t\tf_point[y][x] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchecker = true;\n\t\t\t\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tif(map[N - 1][x]){\n\t\t\t\t\tchecker = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(checker){\n\t\t\t\tfor(int y = 0; y < N; y++){\n\t\t\t\t\tif(f_point[y][0]){\n\t\t\t\t\t\tprintf(\"1\");\n\t\t\t\t\t}else{\n\t\t\t\t\t\tprintf(\"0\");\n\t\t\t\t\t}\n\t\t\t\t\tfor(int x = 1; x < N; x++){\n\t\t\t\t\t\tif(f_point[y][x]){\n\t\t\t\t\t\t\tprintf(\" 1\");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tprintf(\" 0\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <list>\n\nstd::list<int> dfs(std::vector<std::vector<bool>> &state, const int &idx = 1) {\n\tif (idx < 10) {\n\t\tint res = 0;\n\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\tres <<= 1;\n\t\t\tif (state.at(idx - 1).at(i)) {\n\t\t\t\tres += 1;\n\t\t\t\tfor (const auto &index : { i - 1, i, i + 1 }) {\n\t\t\t\t\tif (index >= 0 && index < 10) {\n\t\t\t\t\t\tstate.at(idx).at(index) = !state.at(idx).at(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx != 9) {\n\t\t\t\t\tstate.at(idx + 1).at(i) = !state.at(idx + 1).at(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(state, idx + 1);\n\t\tif (list.size() + idx == 9) {\n\t\t\tlist.push_front(res);\n\t\t\treturn list;\n\t\t}\n\t\telse {\n\t\t\treturn list;\n\t\t}\n\t}\n\telse {\n\t\tbool is_on = false;\n\t\tfor (const auto &cell : state.at(9)) {\n\t\t\tis_on = is_on || cell;\n\t\t}\n\t\tif (is_on) {\n\t\t\treturn std::list<int>{0};\n\t\t}\n\t\telse {\n\t\t\treturn std::list<int>{};\n\t\t}\n\t}\n}\nstd::list<int> solve(std::vector<std::vector<bool>> &state) {\n\tfor (auto i = 0; i < 1023; ++i) {\n\t\tauto copy = state;\n\t\tfor (auto j = 0; j < 10; ++j) {\n\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\tfor (const auto &idx : { j - 1, j, j + 1 }) {\n\t\t\t\t\tif (idx >= 0 && idx < 10) {\n\t\t\t\t\t\tcopy.at(0).at(idx) = !copy.at(0).at(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcopy.at(1).at(j) = !copy.at(1).at(j);\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(copy);\n\t\tif (list.size() == 9) {\n\t\t\tlist.push_front(i);\n\t\t\treturn list;\n\t\t}\n\t}\n\treturn std::list<int>{};\n}\nint main() {\n\tint n;\n\tfor (std::cin >> n; n > 0; --n) {\n\t\tstd::vector<std::vector<bool>> state(10, std::vector<bool>(10, false));\n\t\tbool input;\n\t\tfor (auto &line : state) {\n\t\t\tfor (auto &cell : line) {\n\t\t\t\tstd::cin >> input;\n\t\t\t\tcell = input;\n\t\t\t}\n\t\t}\n\t\tauto res = solve(state);\n\t\tfor (const auto &line : res) {\n\t\t\tfor (auto i = 512; i > 0; i >>= 1) {\n\t\t\t\tstd::cout << static_cast<int>((i & (line)) != 0) << ((i != 1) ? ' ' : '\\n');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nvoid frip(int y, int x, int map[10][10]){\n\tif(y < 0 || x < 0 || y >= 10 || x >= 10){\n\t\treturn;\n\t}else{\n\t\tmap[y][x] = !map[y][x];\n\t}\n}\n\nvoid frips(int y, int x, int map[10][10]){\n\tfrip(y - 1, x, map);\n\tfrip(y + 1, x, map);\n\tfrip(y, x, map);\n\tfrip(y, x - 1, map);\n\tfrip(y, x + 1, map);\n}\n\nint main(){\n\t\n\tint n;\n\t\n\tint origin[10][10];\n\t\n\tint f_point[10][10];\n\t\n\tint map[10][10];\n\t\n\tbool checker;\n\t\n\tcin >> n;\n\t\n\tint N = 10;\n\n\tfor(int loop = 0; loop < n; loop++){\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tcin >> origin[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < (1 << N); i++){\n\t\t\t\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tfor(int y = 0; y < N; y++){\n\t\t\t\t\tmap[y][x] = origin[y][x];\n\t\t\t\t\tf_point[y][x] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int x = 0; x < N; x++){\n\t\t\t\tif((i & (1 << (N - x - 1))) != 0){\n\t\t\t\t\tfrips(0, x, map);\n\t\t\t\t\tf_point[0][x] = 1;\n\t\t\t\t}else{\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y = 1; y < N; y++){\n\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\tif(map[y - 1][x]){\n\t\t\t\t\t\tfrips(y, x, map);\n\t\t\t\t\t\tf_point[y][x] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchecker = true;\n\t\t\t\n\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\tif(map[N - 1][x]){\n\t\t\t\t\tchecker = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(checker){\n\t\t\t\tfor(int y = 0; y < N; y++){\n\t\t\t\t\tfor(int x = 0; x < N; x++){\n\t\t\t\t\t\tif(f_point[y][x]){\n\t\t\t\t\t\t\tprintf(\"1 \");\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tprintf(\"0 \");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nstruct UF {\n    vi e;\n    UF(int n) : e(n, -1) {}\n    bool same_set(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\n    void join(int a, int b) {\n        a = find(a), b = find(b);\n        if(a == b) return;\n        if(e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n    }\n};\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    int cnt=0;\n    while(n--) {\n        if(cnt) cout << endl;\n        cnt++;\n        vector<vector<int>> v(10);\n\n        for(int i=0; i<10; ++i){\n            for(int j=0; j<10; ++j){\n                int a; cin >> a;\n                v[i].push_back(a);\n            }\n        }\n\n        bool f = false;\n        for(int bit=0; bit<(1<<10); ++bit){\n            int arr[15][15]={0};\n\n            int ans[10][10]={0};\n            for(int i=0; i<10; ++i){\n                if(bit >> i & 1){\n                    ans[0][i]=1;\n                    if(i==0){\n                        arr[0][0] ^= 1;\n                        arr[1][0] ^= 1;\n                        arr[0][1] ^= 1;\n                    }else if(i==9){\n                        arr[0][i] ^= 1;\n                        arr[1][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                    }else{\n                        arr[0][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                        arr[0][i+1] ^= 1;\n                        arr[1][i] ^= 1;\n                    }\n                }\n            }\n\n            for(int i=1; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if((arr[i-1][j] == 0 && v[i-1][j]==1) || (arr[i-1][j]==1 && v[i-1][j]==0)){\n                        ans[i][j]=1;\n                        if(j==0){\n                            arr[i][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }else if(j==9){\n                            arr[i][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                        }else{\n                            arr[i][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }\n                    }\n                }\n            }\n            bool d = true;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i][j]!=v[i][j]) d= false;\n                }\n            }\n            if(!d) continue;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(j) cout << \" \";\n                    cout << ans[i][j];\n                }\n                cout << endl;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 最初の一行さえ決め打ちしてしまえば、あとは必然的に決まる\n// 全探索2^10 * 9\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[5] = {0,0,1,-1,0};\nint dj[5] = {1,-1,0,0,0};\n\nint main(){\n    int n;\n    cin >> n;\n    while(n-- > 0){\n        vector<vector<int>> mat(10, vector<int>(10));\n        for(int i = 0; i < 10; i++){\n            for(int j = 0; j < 10; j++){\n                cin >> mat[i][j];\n            }\n        }\n        for(int s = 0; s < 1<<10; s++){\n            vector<vector<int>> cp = mat, ans(10, vector<int>(10, 0));\n            for(int j = 0; j < 10; j++){\n                if((s>>j)&1)    continue;\n                ans[0][j] = 1;\n                for(int k = 0; k < 5; k++){\n                    int ni = 0+di[k], nj = j+dj[k];\n                    if(inRange(ni,0,10)&&inRange(nj,0,10)){\n                        cp[ni][nj] = 1-cp[ni][nj];\n                    }\n                }\n            }\n            for(int i = 1; i < 10; i++){\n                for(int j = 0; j < 10; j++){\n                    if(cp[i-1][j] == 0) continue;\n                    ans[i][j] = 1;\n                    for(int k = 0; k < 5; k++){\n                        int ni = i+di[k], nj = j+dj[k];\n                        if(inRange(ni,0,10)&&inRange(nj,0,10)){\n                            cp[ni][nj] = 1-cp[ni][nj];\n                        }\n                    }\n                }\n            }\n            bool valid = true;\n            for(int j = 0; j < 10; j++) valid &= !cp[9][j];\n            if(valid){\n                // answer.\n                for(int i = 0; i < 10; i++){\n                    for(int j = 0; j < 10; j++){\n                        cout << ans[i][j] << \" \\n\"[j==9];\n                    }\n                }\n                break;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\nenum{W=10,H=10};\n\nbool clear(bool field[H][W]){\n  bool ok=true;\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)if(field[i][j])ok=false;\n  return ok;\n}\n\nint main(){\n  int n;\n  bool field[H][W];\n  bool dup[H][W];\n  int bit[H];\n  cin>>n;\n  while(n-->0){\n\n    for(bit[0]=0; bit[0] < (1<<10); bit[0]++){\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>field[i][j];\n      for(int i=1;i<H;i++)bit[i]=0;\n      for(int i=0;i<H;i++)for(int j=0;j<W;j++)dup[i][j]=field[i][j];\n      for(int j=0;j<W;j++){\n        if(!((bit[0]>>j)&1))continue;\n        dup[0][j]^=1;\n        dup[1][j]^=1;\n        if(j>0)dup[0][j-1]^=1;\n        if(j<W-1)dup[0][j+1]^=1;\n      }\n\n      for(int i=1;i<H;i++){\n        for(int j=0;j<W;j++){\n          if(dup[i-1][j]){\n            bit[i]^=(1<<j);\n            dup[i][j]^=1;\n            dup[i-1][j]^=1;\n            if(i<H-1)dup[i+1][j]^=1;\n            if(j>0)dup[i][j-1]^=1;\n            if(j<W-1)dup[i][j+1]^=1;\n          }\n        }\n      }\n      if(clear(dup))break;\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        if(j!=0)cout<<\" \";\n        if(bit[i]&(1<<j))cout<<\"1\";\n        else cout<<\"0\";\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint state[10][10];\nint ans[10][10];\n\ninline bool valid(int i, int j) {\n    return 0 <= i && i < 10 && 0 <= j && j < 10;\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        for (int j=0; j<10; ++j) {\n            if ((bt>>j) % 10 == 1) {\n                state[0][j] = 1 - state[0][j];\n                if (valid(1, j-1)) state[1][j-1] = 1 - state[1][j-1];\n                if (valid(1, j))   state[1][j]   = 1 - state[1][j];\n                if (valid(1, j+1)) state[1][j+1] = 1 - state[1][j+1];\n                if (valid(2, j))   state[2][j]   = 1 - state[2][j];\n                ans[0][j] = 1;\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) {\n                    state[i][j] = 1 - state[i][j];\n                    if (valid(i+1, j-1)) state[i+1][j-1] = 1 - state[i+1][j-1];\n                    if (valid(i+1, j))   state[i+1][j]   = 1 - state[i+1][j];\n                    if (valid(i+1, j+1)) state[i+1][j+1] = 1 - state[i+1][j+1];\n                    if (valid(i+2, j))   state[i+2][j]   = 1 - state[i+2][j];\n                    if (valid(i+1, j))   ans[i+1][j] = 1 - ans[i+1][j];\n                }\n            }\n        }\n        bool ok = true;\n        for (int j=0; j<10; ++j) {\n            if (state[9][j] == 1) ok = false;\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        solve();\n        cout << \"ans:\" << endl;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n        cout << \"state:\" << endl;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << state[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvoid flip(int x,int y,int stage[10][10]){\n\tconst int t[][2] = {{0,0},{-1,0},{1,0},{0,1},{0,-1}};\n\tfor(int i=0;i<5;i++){\n\t\tint dx = x+t[i][0];\n\t\tint dy = y+t[i][1];\n\n\t\tif(dx < 0 || dx >= 10 || dy < 0 || dy >= 10) continue;\n\n\t\tstage[dy][dx]*=-1;\n\t}\n}\n\nbool checkStage(int store[10][10],int x,int y){\n\treturn store[y][x] == -1 ? true : false;\n}\n\nbool isClear(int store[10][10]){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(store[y][x]==1) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid writeResult(int result[10][10]){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tprintf(\"%d%s\",result[y][x],x==9 ? \"\\n\" : \" \");\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint stage[10][10];\n\t\t\t\n\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\tint num;\n\t\t\t\t\tscanf(\"%d\",&num);\n\t\t\t\t\tstage[y][x] = (num == 0 ? -1 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S=0;S<(1 << 10)-1;S++){\n\t\t\t\tint store[10][10];\n\t\t\t\tint result[10][10];\n\t\t\t\tmemset(result,0,sizeof(result));\n\t\t\t\t//memset(store,0,sizeof(store));\n\t\t\t\tmemcpy(store,stage,sizeof(stage));\n\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif(S & (1<<j)){\n\t\t\t\t\t\tflip(j,0,store);\n\t\t\t\t\t\tresult[0][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int y=1;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tflip(x,y,store);\n\t\t\t\t\t\tif(!checkStage(store,x,y-1)){\n\t\t\t\t\t\t\tflip(x,y,store);\n\t\t\t\t\t\t\tresult[y][x] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tresult[y][x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(isClear(store)){\n\t\t\t\t\twriteResult(result);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint t[10][10],u[10][10],ans[10][10],n,flg;\nint compute();\nvoid dfs(int);\nvoid change(int,int);\nint main(){\n  cin>>n;\n  while(n--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\nvoid dfs(int x){\n  if(flg)return;\n  if(x==10){\n\n    \n    if(compute()){\n      flg=1;\n      for(int i=0;i<10;i++){\n\tfor(int j=0;j<10;j++){\n\t  if(j)cout<<' ';\n\t  cout<<ans[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n    \n    return;\n  }\n\n  dfs(x+1);\n  ans[0][x]=1;\n  dfs(x+1);\n  ans[0][x]=0;\n}\n\nint compute(){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      u[i][j]=t[i][j];\n\n  for(int i=0;i<10;i++){\n    if(ans[0][i])change(0,i);\n  }\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(u[i-1][j]){\n\tans[i][j]=1;\n\tchange(i,j);\n      }\n    }\n  }\n  for(int i=0;i<10;i++){\n    if(u[9][i])return 0;\n  }\n  return 1;\n}\n\nvoid change(int y,int x){\n  u[y][x]=!u[y][x];\n  if(y>0)u[y-1][x]=!u[y-1][x];\n  if(x>0)u[y][x-1]=!u[y][x-1];\n  if(y<9)u[y+1][x]=!u[y+1][x];\n  if(x<9)u[y][x+1]=!u[y][x+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nconst vector<int> dir = { 0, 1, 0, -1 };\nint Q, x;\nint main() {\n\tcin >> Q;\n\twhile (Q--) {\n\t\tvector<int> a(10);\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tcin >> x; a[i] |= x << j;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 1 << 10; i++) {\n\t\t\tvector<int> b = a, c(10); c[0] = i;\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint tx = dir[k], ty = j + dir[k ^ 1];\n\t\t\t\t\t\tif (0 <= tx && tx < 10 && 0 <= ty && ty < 10) {\n\t\t\t\t\t\t\tb[tx] ^= 1 << ty;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tb[0] ^= 1 << j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < 9; j++) {\n\t\t\t\tc[j + 1] = b[j];\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (b[j] & (1 << k)) {\n\t\t\t\t\t\tfor (int l = 0; l < 4; l++) {\n\t\t\t\t\t\t\tint tx = j + 1 + dir[l], ty = k + dir[l ^ 1];\n\t\t\t\t\t\t\tif (0 <= tx && tx < 10 && 0 <= ty && ty < 10) {\n\t\t\t\t\t\t\t\tb[tx] ^= 1 << ty;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tb[j + 1] ^= 1 << k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (b[9] == 0) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\t\tif (k) cout << ' ';\n\t\t\t\t\t\tcout << ((c[j] & (1 << k)) ? 1 : 0);\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint a[10][10], b[10][10], c[10][10];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(i, 10)rep(j, 10)scanf(\"%d\", &a[i][j]);\n\t\trep(i, 1 << 10) {\n\t\t\trep(j, 10)rep(k, 10)b[j][k] = a[j][k];\n\t\t\tmemset(c, 0, sizeof(c));\n\t\t\trep(j, 10)rep(k, 10) {\n\t\t\t\tif (!j) {\n\t\t\t\t\tif (i >> k & 1)continue;\n\t\t\t\t}\n\t\t\t\telse if (!b[j - 1][k])continue;\n\t\t\t\tc[j][k] = 1; b[j][k] = !b[j][k];\n\t\t\t\trep(t, 4) {\n\t\t\t\t\tint nx = j + dx[t], ny = k + dy[t];\n\t\t\t\t\tif (0 <= nx&&nx < 10 && 0 <= ny&&ny < 10)b[nx][ny] = !b[nx][ny];\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ok = true;\n\t\t\trep(j, 10)rep(k, 10) {\n\t\t\t\tif (b[j][k]) { ok = false; break; }\n\t\t\t}\n\t\t\tif (!ok)continue;\n\t\t\trep(j, 10) {\n\t\t\t\trep(k, 10) {\n\t\t\t\t\tif (k)printf(\" \");\n\t\t\t\t\tprintf(\"%d\", c[j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t}\n\telse if(y==1){\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\tflip(x,y);\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,0,sizeof(res));\n\t\tcheck(1,1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n#define INV (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tcout << \"Shot: \" << i << \",\" << j << endl;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tvector< pair<int, int > > vt;\n\t\tbool bSCont = true;\n\n\t\t/* corner \n\t\t{\n\t\t\tif( stm.m[1][1] == 1 ){\n\t\t\t\tif( stm.m[1][2] == 1 && stm.m[2][1] == 1 ){\n\t\t\t\t\tstm.PassParticle( 1, 1 );\n\t\t\t\t\tans.m[1][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( stm.m[1][MAX-2] == 1 ){\n\t\t\t\tif( stm.m[1][MAX-3] == 1 && stm.m[2][MAX-2] == 1 ){\n\t\t\t\t\tstm.PassParticle( 1, MAX-2 );\n\t\t\t\t\tans.m[1][MAX-2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( stm.m[MAX-2][1] == 1 ){\n\t\t\t\tif( stm.m[MAX-3][1] == 1 && stm.m[MAX-2][2] == 1 ){\n\t\t\t\t\tstm.PassParticle( MAX-2, 1 );\n\t\t\t\t\tans.m[MAX-2][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( stm.m[MAX-2][MAX-2] == 1 ){\n\t\t\t\tif( stm.m[MAX-2][MAX-3] == 1 && stm.m[MAX-3][MAX-2] == 1 ){\n\t\t\t\t\tstm.PassParticle( MAX-2, MAX-2 );\n\t\t\t\t\tans.m[MAX-2][MAX-2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\n\t\t/* deko */\n\t\t{\n\t\t\tconst int ci[] = {1,1,1,1,4,5,6,7,4,5,6,7,MAX-2,MAX-2,MAX-2,MAX-2};\n\t\t\tconst int cj[] = {4,5,6,7,1,1,1,1,MAX-2,MAX-2,MAX-2,MAX-2,4,5,6,7};\n\n\t\t\tfor(int i = 0; i < sizeof(ci)/sizeof(*ci); ++i ){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1, 0};\n\t\t\t\tconst int dj[] = {0, 0,1,0,-1};\n\n\t\t\t\tfor(int j = 0; j < sizeof(di)/sizeof(*di); ++j){\n\t\t\t\t\tif( stm.m[ci[i]+di[j]][cj[i]+dj[j]] == 1 )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\t\t\t\tif( cnt1 == 4 ){\n\t\t\t\t\tint ccnt1 = 0;\n\t\t\t\t\tconst int ddi[] = {-1,-1, 1, 1};\n\t\t\t\t\tconst int ddj[] = {-1, 1, 1,-1};\n\n\t\t\t\t\tfor( int j = 0; j < sizeof(ddi)/sizeof(*ddi); ++j){\n\t\t\t\t\t\tif( stm.m[ci[i]+ddi[j]][cj[i]+ddj[j]] == 1 )\n\t\t\t\t\t\t\t++ccnt1;\n\t\t\t\t\t}\n\t\t\t\t\tif( ccnt1 <= 1 ){\n\t\t\t\t\t\tstm.PassParticle( ci[i], cj[i] );\n\t\t\t\t\t\tans.m[ci[i]][cj[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* other */\n\t\tfor(int i = 1; i < MAX - 1 && bSCont; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 && bSCont; ++j){\n\t\t\t\tif( stm.m[i][j] == 1 ){\n\t\t\t\t\tconst int di[][3] = {\n\t\t\t\t\t\t{0,-1,0},\n\t\t\t\t\t\t{-1,0,1},\n\t\t\t\t\t\t{0,1,0},\n\t\t\t\t\t\t{1,0,-1}\n\t\t\t\t\t};\n\t\t\t\t\tconst int dj[][3] = {\n\t\t\t\t\t\t{-1,0,1},\n\t\t\t\t\t\t{0,1,0},\n\t\t\t\t\t\t{1,0,-1},\n\t\t\t\t\t\t{0,-1,0}\n\t\t\t\t\t};\n\t\t\t\t\t/* \n\t\t\t\t\tconst int di[][2] = { {0,-1}, {-1,0}, {0,1}, {1,0} };\n\t\t\t\t\tconst int dj[][2] = { {-1,0}, {0,1}, {1,0}, {0,-1} };\n\t\t\t\t\t*/\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tbool bCont = true;\n\t\t\t\t\t\tint tti, ttj;\n\n\t\t\t\t\t\tfor(int l = 0; l < sizeof(*di)/sizeof(**di) && bCont; ++l){\n\t\t\t\t\t\t\tif( stm.m[i+di[k][l]][j+dj[k][l]] != 0 ||\n\t\t\t\t\t\t\t\t!inRange(i+di[k][1],1,MAX-1) ||\n\t\t\t\t\t\t\t\t!inRange(j+dj[k][1],1,MAX-1) ){\n\t\t\t\t\t\t\t\t\ttti = ttj = INV;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tswitch( k ){\n\t\t\t\t\t\t\t\t\tcase 0: tti = i + 1; ttj = j; break;\n\t\t\t\t\t\t\t\t\tcase 1: tti = i; ttj = j - 1; break;\n\t\t\t\t\t\t\t\t\tcase 2: tti = i - 1; ttj = j; break;\n\t\t\t\t\t\t\t\t\tcase 3: tti = i; ttj = j + 1; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( bCont ){\n\t\t\t\t\t\t\tif( inRange(tti,1,MAX-1) && inRange(ttj,1,MAX-1) )\n\t\t\t\t\t\t\t\tvt.push_back( make_pair( tti, ttj ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( vt.size() > 0 ){\n\t\t\tint ti = INV, tj = INV;\n\t\t\tint max1 = 0;\n\t\t\tdouble maxEfficient = 0.499;\n\t\t\t\n\t\t\tfor(unsigned int t = 0; t < vt.size(); ++t){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint invCnt = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( !inRange(vt[t].first+di[k], 1, MAX-1) || !inRange(vt[t].second+dj[k],1,MAX-1) )\n\t\t\t\t\t\tinvCnt++;\n\t\t\t\t\tif( stm.m[vt[t].first+di[k]][vt[t].second+dj[k]] == 1 )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tif( (double)cnt1 / ( 5 - invCnt ) > maxEfficient ){\n\t\t\t\t\t\tmaxEfficient = (double)cnt1 / (5 - invCnt);\n\t\t\t\t\t\tti = vt[t].first;\n\t\t\t\t\t\ttj = vt[t].second;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ti != INV && tj != INV ){\n\t\t\t\tstm.PassParticle( ti, tj );\n\t\t\t\tans.m[ti][tj] = 1;\n\t\t\t\tbSCont = false;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nint a[10];\nint b[10];\nint c[10];\n\nint main() {\n  int n, t;\n  bool solved;\n  scanf(\"%d\", &n);\n  for (int x=0; x<n; x++) {\n    for (int i=0; i<10; i++) a[i] = 0;\n    for (int i=0; i<10; i++) {\n      for (int j=0; j<10; j++) {\n        scanf(\"%d\", &t);\n        a[i] |= t<<j;\n      }\n    }\n\n    solved = false;\n    for (int i=0; i<(1<<10); i++) {\n      memcpy(b, a, sizeof(a));\n      b[0] ^= i;\n      b[0] ^= i<<1;\n      b[0] ^= i>>1;\n      b[1] ^= i;\n      for (int j=1; j<10; j++) {\n        b[j] ^= b[j-1];\n        b[j] ^= b[j-1]<<1;\n        b[j] ^= b[j-1]>>1;\n        if (j<9) {\n          b[j+1] ^= b[j-1];\n        }\n      }\n      if (!b[9]) {\n        c[0] = i;\n        for (int j=1; j<10; j++) {\n          c[j] = b[j-1];\n        }\n        solved = true;\n        break;\n      }\n    }\n\n    if (solved) {\n      for (int i=0; i<10; i++) {\n        for (int j=0; j<10; j++) {\n          if (j) putchar(' ');\n          printf(\"%d\", (c[i]>>j)&1);\n        }\n        putchar('\\n');\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; ++i)\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define P pair<int, int>\nconst int H = 10;\nconst int W = 10;\ntypedef vector< vector<int> > ivv;\ntypedef vector<int> iv;\n\nint my[5] = {1, -1, 0, 0, 0};\nint mx[5] = {0, 0, 1, -1, 0};\n\nclass C{\n  public:\n    ivv u;\n    int t, y, x;\n    C(){}\n    C(ivv _u, int _t, int _y, int _x){ u = _u; t = _t; y = _y; x = _x; }\n};\n\nqueue<C> open;\n\nvoid rev(ivv &v, int y, int x){\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W) v[ny][nx] = (v[ny][nx] + 1) % 2;\n  }\n}\n\nbool next(ivv v, ivv &u, int y, int x){\n  REP(i, H) REP(j, W) if(u[i][j]) rev(v, i, j);\n  int a = 0, b = 0;\n  REP(i, 5){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W){\n      if(v[ny][nx]) ++a;\n      else ++b;\n    }\n  }\n  return a > b;\n}\n\n\nbool end(ivv v, ivv &u){\n  REP(i, H) REP(j, W) if(u[i][j]) rev(v, i, j);\n  REP(i, H) REP(j, W) if(v[i][j] == 1) return false;\n  return true;\n}\n\nivv bfs(ivv &v){\n  open = queue<C>();\n  ivv _u(H, iv(W, 0));\n  open.push(C(_u, 0, 0, -1));\n  while(!open.empty()){\n    C tmp = open.front(); open.pop();\n    ivv u = tmp.u; int t = tmp.t;\n    if(end(v, u)) return u;\n    FOR(y, tmp.y, H){\n      REP(x, W){\n        if(y == tmp.y && x <= tmp.x) continue;\n        if(!u[y][x] && next(v, u, y, x)){\n          rev(v, y, x);\n          u[y][x] = true;\n          open.push(C(u, t + 1, y, x));\n          u[y][x] = false;\n          rev(v, y, x);\n        }\n      }\n    }\n  }\n  return ivv();\n}\n\nint main() {\n  int T; cin >>T;\n  REP(t, T){\n    ivv v(H, iv(W));\n    REP(i, H) REP(j, W) cin >>v[i][j];\n    ivv ans = bfs(v);\n    REP(i, H){\n      REP(j, W) cout <<ans[i][j] <<(j + 1 == W ? \"\" : \" \");\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint input[10][10], state[10][10], ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = !state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = !ans[y][x];\n}\n\nint main() {\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> input[i][j];\n            }\n        }\n        for (int bt=0; bt<(1<<10); ++bt) {\n            memcpy(state, input, sizeof(input));\n            memset(ans, 0, sizeof(ans));\n            for (int j=0; j<10; ++j) {\n                if ((bt>>j) & 1) {\n                    pass(0, j);\n                }\n            }\n            for (int i=1; i<10; ++i) {\n                for (int j=0; j<10; ++j) {\n                    if (state[i-1][j] == 1) {\n                        pass(i, j);\n                    }\n                }\n            }\n            if (accumulate(state[9], state[9] + 10, 0) == 0) break;\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10]={};\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)if((ans[0][j]=((i>>j)%2)))mark(mp,0,j);\n\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n      cout <<endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i) for(int j = 0; j < MAX; ++j) m[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]]               == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) &&\n\n\t\t\t\t\t\t\t( M.m[i+di[(k+5)%sz]][j+dj[(k+5)%sz]] == 1 && inRange(i+di[(k+5)%sz]) && inRange(j+dj[(k+5)%sz]) ||\n\t\t\t\t\t\t\tM.m[i+di[(k+7)%sz]][j+dj[(k+7)%sz]] == 1 && inRange(i+di[(k+7)%sz]) && inRange(j+dj[(k+7)%sz]) )\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz]) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint S3[1024];\n\trep(S,1024){\n\t\tint stat=0;\n\t\trep(j,10) if(S&(1<<j)) {\n\t\t\tstat^=1<<j;\n\t\t\tif(j>0) stat^=1<<(j-1);\n\t\t\tif(j<9) stat^=1<<(j+1);\n\t\t}\n\t\tS3[S]=stat;\n\t}\n\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint org[10]={};\n\t\trep(i,10) rep(j,10) {\n\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\torg[i]|=tmp<<j;\n\t\t}\n\n\t\tint ans=-1;\n\t\trep(S,1024){\n\t\t\tint grid[10];\n\t\t\trep(i,10) grid[i]=org[i];\n\n\t\t\tgrid[0]^=S3[S];\n\t\t\tgrid[1]^=S;\n\t\t\tfor(int i=1;i<10;i++){\n\t\t\t\tint pttn=grid[i-1];\n\t\t\t\tgrid[i-1]=0;\n\t\t\t\tgrid[i]^=S3[pttn];\n\t\t\t\tif(i<10) grid[i+1]^=pttn;\n\t\t\t}\n\n\t\t\tif(grid[9]==0){ ans=S; break; }\n\t\t}\nif(ans==-1)while(1);\n\n\t\trep(j,10) printf(\"%d%c\",(bool)(ans&(1<<j)),j<9?' ':'\\n');\n\t\torg[0]^=S3[ans];\n\t\torg[1]^=ans;\n\t\tfor(int i=1;i<10;i++){\n\t\t\tint pttn=org[i-1];\n\t\t\torg[i-1]=0;\n\t\t\torg[i]^=S3[pttn];\n\t\t\tif(i<10) org[i+1]^=pttn;\n\t\t\trep(j,10) printf(\"%d%c\",(bool)(pttn&(1<<j)),j<9?' ':'\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(i=0;i<n;++i)\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define sc second\n\nbool inside(int x,int y)\n{\n\treturn(0<=x&&x<10 && 0<=y&&y<10);\n}\n\nint main()\n{\n\tint i,j,k;\n\tint dx[5]={1,-1,0,0,0};\n\tint dy[5]={0,0,0,-1,1};\n\n\tint C;\n\tcin >>C;\n\tfor(int cases=0;cases<C;++cases)\n\t{\n\t\tint f[10][10]={0};\n\t\trep(i,10)rep(j,10) scanf(\" %d\",&f[i][j]);\n\n\t\tint ans[10][10]={0};\n\n\t\t//1???????????????????????????????±????\n\t\tint mask;\n\t\tfor(mask=0; mask<(1<<10); ++mask)\n\t\t{\n\t\t\t//???????????§?°??????????????¨????\n\t\t\tint ta[10][10]={0};\n\t\t\t//?????£???????????¶???\n\t\t\tint t[10][10]={0};\n\t\t\trep(i,10)rep(j,10) t[i][j]=f[i][j];\n\t\t\t//1??????????????¢\n\t\t\trep(i,10)\n\t\t\t{\n\t\t\t\tif(mask>>i&1)\n\t\t\t\t{//?????¢?????????\n\t\t\t\t\tta[0][i]=1;\n\t\t\t\t\trep(j,5)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx=i+dx[j];\n\t\t\t\t\t\tint ny=0+dy[j];\n\t\t\t\t\t\tif(inside(nx,ny)) t[ny][nx]=!t[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(i=0;i<10-1;++i)\n\t\t\t{//i???????????¨???\n\t\t\t\trep(j,10)\n\t\t\t\t{\n\t\t\t\t\tif(t[i][j]==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tta[i+1][j]=1;\n\t\t\t\t\t\trep(k,5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint nx=j+dx[k];\n\t\t\t\t\t\t\tint ny=i+1+dy[k];\n\t\t\t\t\t\t\tif(inside(nx,ny)) t[ny][nx]=!t[ny][nx];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbool valid=true;\n\t\t\trep(i,10) valid&=(t[9][i]==0);\n\n\t\t\tif(valid)\n\t\t\t{\n\t\t\t\trep(i,10)rep(j,10) ans[i][j]=ta[i][j];\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t//output\n\t\trep(i,10)\n\t\t{\n\t\t\trep(j,10)\n\t\t\t{\n\t\t\t\tif(j) printf(\" \");\n\t\t\t\tprintf(\"%d\",ans[i][j]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\n\nbool ans[10][10];\nint ban[10][10];\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    rep(i,10)rep(j,10)cin>>ban[i][j];\n\n\n    rep(k,1<<10){\n      memset(ans,0,sizeof(ans));\n      rep(i,10){\n        rep(j,10){\n          if(!i){\n            ans[i][j]=!!(1<<i&k);\n          }else{\n            int t=ans[i-1][j]+ban[i-1][j];\n            if(j<9)t+=ans[i-1][j+1];\n            if(j)t+=ans[i-1][j-1];\n            if(i>1)t+=ans[i-2][j];\n            ans[i][j]=t%2;\n          }\n        }\n      }\n      int odd=0;\n      rep(j,10)odd+=ans[9][j];\n      if(!odd)break;\n    }\n    rep(i,10){\n      rep(j,10){\n        if(j)cout<<\" \";\n        cout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={0,0,0,1,-1},dy[]={-1,1,0,0,0};\n\nint d[11][11], b[11][11], a[11][11];\n\nvoid flip(int x, int y) {\n  a[y][x]=1;\n  for(int i=0; i<5; i++) {\n    b[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n  }\n}\n\nint main() {\n\n  int n;\n  cin>> n;\n  while(n--) {\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcin>> d[i][j];\n      }\n    }\n\n    for(int i=0; i<1024; i++) {\n      memset(a, 0, sizeof(a));\n      memcpy(b, d, sizeof(d));\n      for(int j=0; j<10; j++) {\n\tif((i>>j) & 1) flip(j, 0);\n      }\n\n      for(int j=1; j<10; j++) {\n\tfor(int k=0; k<10; k++) {\n\t  if(b[j-1][k]) flip(k, j);\n\t}\n      }\n\n      int cnt=0;\n      for(int j=0; j<10; j++) {\n\tif(b[9][j]) {\n\t  cnt=1; break;\n\t}\n      }\n      \n      if(cnt==0) break;\n    }\n\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcout << a[i][j]<< (j==9 ? \"\" : \" \");\n      }\n      cout<< endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        \n        bool box[12][12]={0};\n        \n        for(int i=1; i<=10; i++){\n            for(int j=1; j<=10; j++){\n                cin>>box[i][j];\n            }\n        }\n        //cout<<\"----------------------\"<<endl;\n        \n        bool box2[12][12]={0};\n\n        for(int i=0; i<(1<<10 - 1); i++){\n            memcpy(box2, box, sizeof(box));\n            int l[12][12]={0};\n            for(int j=1; j<=10; j++){\n                l[0][j]= (i>>j)%2;\n            }\n            \n            for(int j=1; j<=10; j++){\n                for(int k=1; k<=10; k++){\n                    if(l[j-1][k]==1){\n                        box2[j][k]=(box2[j][k]+1)%2;\n                        box2[j][k+1]=(box2[j][k+1]+1)%2;\n                        box2[j][k-1]=(box2[j][k-1]+1)%2;\n                        box2[j-1][k]=(box2[j-1][k]+1)%2;\n                        box2[j+1][k]=(box2[j+1][k]+1)%2;\n                    }\n                }\n                \n                for(int k=1; k<=10; k++){\n                    l[j][k]=box2[j][k];\n                }\n            }\n            \n            bool end_flag=true;\n            for(int i=1; i<=10; i++){\n                if(l[10][i]==1){\n                    end_flag=false;\n                    break;\n                }\n            }\n            \n            \n            if(end_flag){\n                for(int i=1; i<=10; i++){\n                    for(int j=1; j<=10; j++){\n                        cout<<l[i][j];\n                        if(j==10)break;\n                        cout<<\" \";\n                    }\n                    cout<<endl;\n                }\n                break;\n            }\n        }\n        //cout<<\"============================\"<<endl;\n\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nusing namespace std;\ntypedef long long  ll;\n/** Problem0131 : Coctor's Strange Particles **/\n// true : 点灯  false : 消灯\nbool board[10][10];\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\n\nvoid flip(int x, int y)\n{\n\tint nx, ny;\n\tboard[x][y] = !board[x][y];\n\trep(i, 4) {\n\t\tnx = x+dx[i]; ny = y+dy[i];\n\t\tif (0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\tboard[nx][ny] = !board[nx][ny];\n\t}\n}\n\nint main()\n{\n\tint n;\n\tbool stamp[10][10];\n\tbool copy[10][10];\n\tcin >> n;\n\twhile (n-- > 0) {\n\t\trep(j,10) rep(k,10) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tboard[k][j] = c==1;\n\t\t\tcopy[k][j] = board[k][j];\n\t\t}\n\t\t\n\t\t/** Lights-Out Game Mode\n\t\twhile (1) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tflip(x, y);\n\t\t\t\n\t\t\trep(y, 10) {\n\t\t\t\tif (board[0][y])\n\t\t\t\t\tcout << '1';\n\t\t\t\telse\n\t\t\t\t\tcout  << '0';\n\t\t\t\tREP(x, 1, 10) {\n\t\t\t\t\tif (board[x][y])\n\t\t\t\t\t\tcout << ' ' << '1';\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << ' ' << '0';\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t} **/\n\t\t\n\t\t\n\t\tfor (int i=0; i<1024; i++) {\n\t\t\trep(y, 10) rep(x, 10) board[x][y] = copy[x][y];\n\t\t\n\t\t\trep(j, 10) {\n\t\t\t\tstamp[j][0] = (i>>j&1);\n\t\t\t}\n\t\t\trep(j, 10) {\n\t\t\t\tif (stamp[j][0])\n\t\t\t\t\tflip(j, 0);\n\t\t\t}\n\t\t\t\n\t\t\tfor (int y=1; y<10; y++) {\n\t\t\t\tfor (int x=0; x<10; x++) {\n\t\t\t\t\tif (board[x][y-1]) {\n\t\t\t\t\t\tstamp[x][y] = true;\n\t\t\t\t\t\tflip(x, y);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstamp[x][y] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tbool flag=true;\n\t\t\trep(j, 10) {\n\t\t\t\tif (board[j][9]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\trep(y, 10) {\n\t\t\t\t\tif (stamp[0][y])\n\t\t\t\t\t\tcout << '1';\n\t\t\t\t\telse\n\t\t\t\t\t\tcout << '0';\n\t\t\t\t\t\n\t\t\t\t\tREP(x, 1, 10) {\n\t\t\t\t\t\tif (stamp[x][y])\n\t\t\t\t\t\t\tcout << ' ' << '1';\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcout << ' ' << '0';\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={0,0,0,1,-1},dy[]={-1,1,0,0,0};\n\nint d[10][10], b[10][10], a[10][10];\n\nvoid flip(int x, int y) {\n  a[y][x]=1;\n  for(int i=0; i<5; i++) {\n    b[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n  }\n}\n\nint main() {\n\n  int n;\n  cin>> n;\n  while(n--) {\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcin>> d[i][j];\n      }\n    }\n\n    for(int i=0; i<1024; i++) {\n      memset(a, 0, sizeof(a));\n      memcpy(b, d, sizeof(d));\n      for(int j=0; j<10; j++) {\n\tif((i>>j) & 1) flip(j, 0);\n      }\n\n      for(int j=1; j<10; j++) {\n\tfor(int k=0; k<10; k++) {\n\t  if(b[j-1][k]) flip(k, j);\n\t}\n      }\n\n      int cnt=0;\n      for(int j=0; j<10; j++) {\n\tif(b[9][j]) {\n\t  cnt=1; break;\n\t}\n      }\n      \n      if(cnt==0) break;\n    }\n\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcout << a[i][j]<< (j==9 ? \"\" : \" \");\n      }\n      cout<< endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX_M 10\n#define MAX_N 10\n\nconst int dx[5]={-1,0,0,0,1};\nconst int dy[5]={0,-1,0,1,0};\n\nint M,N,c;\nint tile[MAX_M][MAX_N],opt[MAX_M][MAX_N],flip[MAX_M][MAX_N];\n\nint get(int x,int y)\n{\n\tint c=tile[x][y];\n\tfor(int d=0;d<5;d++)\n\t{\n\t\tint x2=x+dx[d],y2=y+dy[d];\n\t\tif(0<=x2 && x2<M && 0<=y2 && y2<N)\n\t\t\tc+=flip[x2][y2];\n\t}\n\treturn c%2;\n}\n\nint calc()\n{\n\tfor(int i=1;i<M;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tif(get(i-1,j) !=0)\n\t\t\t\tflip[i][j]=1;\n\tfor(int j=0;j<N;j++)\n\t\tif(get(M-1,j)!=0)\n\t\t\treturn -1;\n\tint res=0;\n\tfor(int i=0;i<M;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tres+=flip[i][j];\n\treturn res;\n}\n\nvoid solve()\n{\n\tmemset(opt,0,sizeof(opt));\n\tint res=-1;\n\tfor(int i=0;i<1<<N;i++)\n\t{\n\t\tmemset(flip,0,sizeof(flip));\n\t\t\n\t\tfor(int j=0;j<N;j++)\n\t\t\tflip[0][N-j-1]=i>>j&1;\n\t\tint num=calc();\n\t\tif(num>=0)\n\t\t{\n\t\t\tres=num;\n\t\t\tmemcpy(opt,flip,sizeof(flip));\n\t\t}\n\t}\n\tfor(int i=0;i<M;i++)\n\t\tfor(int j=0;j<N;j++)\n\t\t\tprintf(\"%d%c\",opt[i][j],j+1==N?'\\n':' ');\n}\n\nint main()\n{\n\tN=10;\n\tM=10;\n\tint x;\n\tscanf(\"%d\",&x);\n\tfor(c=0;c<x;c++)\n\t{\n\t\tfor(int i=0;i<M;i++)\n\t\t\tfor(int j=0;j<N;j++)\n\t\t\t{\n\t\t\t\tint t;\n\t\t\t\tscanf(\"%d\",&t);\n\t\t\t\ttile[i][j]=t;\n\t\t\t}\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint state[10][10];\nint ans[10][10];\n\ninline bool valid(int i, int j) {\n    return 0 <= i && i < 10 && 0 <= j && j < 10;\n}\n\nvoid push(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (valid(y + dy[i], x + dx[i])) {\n            state[y + dy[i]][x + dx[i]] = 1 - state[y + dy[i]][x + dx[i]];\n        }\n    }\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        for (int j=0; j<10; ++j) {\n            if ((bt>>j) % 10 == 1) {\n                push(0, j);\n                ans[0][j] = 1 - ans[0][j];\n            }\n        }\n        for (int i=1; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i-1][j] == 1) {\n                    push(i, j);\n                    ans[i][j] = 1 - ans[i][j];\n                }\n            }\n        }\n        bool ok = true;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) ok = false;\n            }\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        solve();\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstring>\n#define MAX 12\n#define INFTY 1 << 28\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap(){ memset( m, 0, sizeof(*m) * sizeof(**m) ); }\n\tvoid PassParticle(int i, int j){\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\tbool NoLight() const {\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] ) return false;\n\t\treturn true;\n\t}\n\tvoid Print() const {\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintAns() const {\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tbool operator==(const CMap &t) const {\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] ) ++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D ){\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\n\t\tAnswer.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int dx[5] = {-1,0,0,0,1};\nconst int dy[5] = {0,-1,0,1,0};\n\nint arr[10][10];\nint ans[10][10],flip[10][10];\n\nint get(int x,int y){\n  int c = arr[x][y];\n  for(int d = 0 ; d < 5 ; d++){\n    int x2 = x + dx[d], y2 = y + dy[d];\n    if(0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10){\n      c += flip[x2][y2];\n    }\n  }\n  return c % 2;\n}\n\nint calc(){\n  for(int i = 1 ; i < 10 ; i++){\n    for(int j = 0 ; j < 10 ; j++){\n      if(get(i-1,j) != 0){\n        flip[i][j] = 1;\n      }\n    }\n  }\n\n  for(int j = 0 ; j < 10 ; j++){\n    if(get(9,j) != 0){\n      return -1;\n    }\n  }\n\n  int res = 0;\n  for(int i = 0 ; i < 10 ; i++){\n    for(int j = 0 ; j < 10 ; j++){\n      res += flip[i][j];\n    }\n  }\n  return res;\n}\n\nvoid solve(){\n  int res = -1;\n\n  for(int i = 0 ; i < (1<<10) ; i++){\n    memset(flip,0,sizeof(flip));\n    for(int j = 0 ; j < 10 ; j++){\n      flip[0][10-j-1] = i >> j & 1;\n    }\n    int num = calc();\n    if(num >= 0 && (res < 0 || res > num)){\n      res = num;\n      memcpy(ans,flip,sizeof(ans));   \n    }\n  }\n\n  for(int i = 0 ; i < 10 ; i++){\n    for(int j = 0 ; j < 10 ; j++){\n      printf(\"%d%c\" ,ans[i][j], j+1 == 10 ? '\\n' : ' ');\n    }\n  }\n}\n\nint main(){\n  int Tc;\n\n  cin >> Tc;\n  while(Tc--){\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n        cin >> arr[i][j];\n      }\n    }\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(y==11){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(y==1){\n\t\tnow[x][y]=0;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(1,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(1,y+1);\n\t\tflip(x,y);\n\t\t\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(1,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tnow[x][y]=0;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(1,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tmemset(fie,0,sizeof(fie));\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,-1,sizeof(res));\n\t\tcheck(1,1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int H = 10;\nconst int W = 10;\nint G[H][W];\nint ans[H][W];\n\nvoid put(int i, int j) {\n  const static int di[5] = {0,1,0,-1,0};\n  const static int dj[5] = {1,0,-1,0,0};\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    G[ni][nj] ^= 1;\n  }\n}\n\nbool rec(int i, int j) {\n  if(j == W) {\n    ++i;\n    j = 0;\n  }\n\n  if(i == H) {\n    for(int j = 0; j < W; ++j) {\n      if(G[H-1][j]) return false;\n    }\n    return true;\n  }\n\n  if(i == 0) {\n    ans[i][j] = 0;\n    if(rec(i, j+1)) return true;\n    ans[i][j] = 1;\n    put(i, j);\n    if(rec(i, j+1)) return true;\n    put(i, j);\n  } else {\n    if(G[i-1][j]) {\n      ans[i][j] = 1;\n      put(i, j);\n      if(rec(i, j+1)) return true;\n      put(i, j);\n    } else {\n      ans[i][j] = 0;\n      if(rec(i, j+1)) return true;\n    }\n  }\n  return false;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    rec(0, 0);\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(j) cout << \" \";\n        cout << ans[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 12\nusing namespace std;\n\nbool IsLeft(int m[MAX][MAX]){\n\tfor(int i = 1; i < MAX - 1; ++i){\n\t\tfor(int j = 1; j < MAX - 1; ++j){\n\t\t\tif( m[i][j] ) return true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid PassParticle(int m[MAX][MAX], int i, int j){\n\tconst int di[] = {0,-1,0,1,0};\n\tconst int dj[] = {0,0,1,0,-1};\n\n\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n}\nvoid PrintMap(int m[MAX][MAX]){\n\tfor(int i = 1; i < MAX - 1; ++i){\n\t\tcout << m[i][1];\n\t\tfor(int j = 2; j < MAX - 1; ++j){\n\t\t\tcout << ' ' << m[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D ){\n\t\tint pi, pj; /* 1ðÅà½­½]³¹çêéÀW */\n\t\tint M[MAX][MAX] = {{0,},};\n\t\tint Answer[MAX][MAX] = {{0,},};\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\twhile( IsLeft(M) ){\n\t\t\tint max = 0;\n\t\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tif( M[i+di[k]][j+dj[k]] ) ++cnt;\n\t\t\t\t\t}\n\t\t\t\t\tif( cnt > max ){ pi = i; pj = j; max = cnt; }\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tPassParticle( M, pi, pj );\n\t\t\tAnswer[pi][pj] = 1;\n\t\t}\n\t\tPrintMap( Answer );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef complex<double> P;\n\nconst int mask = (1<<10)-1;\n\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  while(n --> 0){\n    int data[10] = { 0 };\n    REP(i,10) REP(j,10){\n      int tmp; scanf(\"%d\",&tmp);\n      if(tmp == 1) data[i] |= (1 << j);\n    }\n\n    REP(k,(1<<10)){\n      int d[10]; REP(i,10) d[i] = data[i];\n      d[0] ^= k; d[0] ^= (k<<1); d[0] ^= (k>>1);\n      d[1] ^= k;\n\n      int ans[10] = { k };\n      for(int i=0; i<9; i++){\n        int tmp = 0;\n        REP(j,10){\n          if(d[i] & (1<<j)){\n            tmp |= (1<<j);\n          }\n        }\n        d[i] ^= tmp;\n        d[i+1] ^= tmp; d[i+1] ^= (tmp<<1); d[i+1] ^= (tmp>>1);\n        if(i!=8) d[i+2] ^= tmp;\n        ans[i+1] = tmp;\n      }\n      if((d[9] & mask) == 0){\n        REP(i,10) REP(j,10)\n          printf(\"%d%c\",((ans[i]&(1<<j))==0?0:1),(j==9?'\\n':' '));\n        break;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define SORT(x) sort((x).begin(),(x).end())\n#define all(x) (x).begin(),(x).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint flip[10][10];\nint f[10][10];\nint ans[10][10];\nint dx[5]={0,0,0,1,-1};\nint dy[5]={0,1,-1,0,0};\nint n;\nint color(int x,int y)\n{\n\tint res=f[x][y];\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0||nx>=10||ny<0||ny>=10)continue;\n\t\tres+=flip[nx][ny];\n\t}\n\treturn res%2;\n}\nint culc()\n{\n\tfor(int i=1;i<10;i++)\n\t{\n\t\tfor(int j=0;j<10;j++)\n\t\t{\n\t\t\tif(color(i-1,j)==1)flip[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<10;i++)if(color(9,i)==1)return -1;\n\treturn 1;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int s=0;s<n;s++)\n\t{\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tcin >> f[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++)\n\t\t{\n\t\t\tmemset(flip,0,sizeof(flip));\n\t\t\tfor(int j=0;j<10;j++)flip[0][j]=(i>>j)&1;\n\t\t\tint num=culc();\n\t\t\tif(num<0)continue;\n\t\t\telse goto end;\n\t\t}\n\t\tend:;\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tcout << flip[i][j];\n\t\t\t\tif(j!=9)cout << ' ';\n\t\t\t\telse cout << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* bit DP, O(n*2^(2n)) */\n\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint main(){\n\tint sw[1024];\n\trep(S,1024){\n\t\tsw[S]=0;\n\t\tif(S&1) sw[S]^=3;\n\t\tfor(int i=1;i<9;i++) if(S&(1<<i)) sw[S]^=(7<<(i-1));\n\t\tif(S&512) sw[S]^=768;\n\t}\n\n\tint T; scanf(\"%d\",&T);\n\twhile(T--){\n\t\tint cell[10]={};\n\t\trep(i,10){\n\t\t\tcell[i]=0;\n\t\t\trep(j,10){\n\t\t\t\tint tmp; scanf(\"%d\",&tmp);\n\t\t\t\tcell[i]|=(tmp<<(9-j));\n\t\t\t}\n\t\t}\n\n\t\tstatic int dp[11][1024];\n\t\t// dp[r][stat] : rsÚÌXCb`ðµûstat(bit\\»)Åµ½Æ«ÉAr-1sÚª·×Ä0ÉÈéæ¤Èr-1sÚÌXCb`Ìµû\n\t\trep(S,1024) dp[0][S]=0;\n\t\trep(r,10){\n\t\t\trep(S,1024){\n\t\t\t\tdp[r+1][S]=-1;\n\t\t\t\trep(B,1024){\n\t\t\t\t\tif(dp[r][B]==-1) continue;\n\t\t\t\t\tif((cell[r]^dp[r][B]^sw[B]^S)==0) dp[r+1][S]=B;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[10];\n\t\tfor(int i=0,S=dp[10-i][0];i<10;i++,S=dp[10-i][S]) ans[i]=S;\n\t\tfor(int i=9;i>=0;i--){\n\t\t\trep(k,10) printf(\"%d%c\",!!(ans[i]&(1<<(9-k))),k<9?' ':'\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[5] = { -1, 0, 0, 0, 1 };\nconst int dy[5] = {  0,-1, 0, 1, 0 };\nint stage[10][10];\nint cnt[10][10];\n\nint Color(int y, int x ){\n\tint tmp = stage[y][x];\n\trep (i, 5 ){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (nx >= 10 || ny >= 10 || nx < 0 || ny < 0 ) continue;\n\t\ttmp += cnt[ny][nx];\n\t} // end rep\n\n\treturn tmp%2;\n}\n\nint solve(){\n\tfor (int y = 1; y < 10; y++)\n\t\trep (x, 10 )\n\t\t\tif (Color(y-1, x ) ) cnt[y][x]=1;\n\trep (i, 10 )\n\t\t\tif (Color(9, i ) ) return -1;\n\n\tint ret=0;\n\trep (y, 10 ) rep (x, 10 ) ret+=cnt[y][x];\n\n\treturn ret;\n}\n\nint ans[10][10];\n\nvoid bit_dfs(){\n\n\tint res = -1;\n\trep (i, 1<<10 ){\n\t\tmemset (cnt, 0, sizeof (cnt ) );\n\t\trep (j, 10 ) cnt[0][j]=(i>>j)&1;\n\t\tint t = solve();\n\t\tif (t >= 0 && (res < 0 || res > t ) ){\n\t\t\tres = t;\n\t\t\tmemcpy (ans, cnt, sizeof(cnt ) );\n\t\t} // end if\n\t} // end rep\n}\n\nint main()\n{\n\tint T; scanf(\"%d\", &T );\n\twhile (T--){\n\t\tmemset (ans, 0, sizeof(ans ) );\n\t\tmemset (cnt, 0, sizeof(cnt ) );\n\t\tmemset (stage, 0, sizeof(stage ) );\n\t\trep (y, 10 ) rep (x, 10 ) cin >> stage[y][x];\n\t\tbit_dfs();\n\t\trep (y, 10 ) rep (x, 10 ) cout << ans[y][x] << (x < 9 ? ' ' : '\\n' );\n\t} // end while\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint a[10][10], b[10][10], res[10][10];\nint dy[] = {-1,0,0,1,0}, dx[] = {0,-1,0,0,1};\n\nint judge(int *used){\n  memcpy(b, a, sizeof(a));\n  memset(res, 0, sizeof(res));\n\n  rep(i, 10){\n    if(!used[i]) continue;\n    res[0][i] = 1;\n    rep(d, 5){\n      int ny = dy[d], nx = i + dx[d];\n\n      if(ny < 0 || nx < 0 || ny >= 10 || nx >= 10) continue;\n      b[ny][nx] = !b[ny][nx];\n    }\n  }\n  \n  REP(i, 1, 10){\n    rep(j, 10){\n      if(!b[i-1][j]) continue;\n      res[i][j] = 1;\n      rep(d, 5){\n\tint ny = i + dy[d], nx = j + dx[d];\n\n\tif(ny < 0 || nx < 0 || ny >= 10 || nx >= 10) continue;\n\tb[ny][nx] = !b[ny][nx];\n      }\n    }\n  }\n \n  rep(i, 10) rep(j, 10) if(b[i][j]) return 0;\n\n \n  return 1;\n}\n\nbool solve(int i, int *used){\n  if(i == 10){\n    if(judge(used)) return 1;\n    return 0;\n  }\n\n  if(solve(i+1, used)) return 1;\n  used[i] = 1;\n  if(solve(i+1, used)) return 1;\n  used[i] = 0;\n\n  return 0;\n}\n\nint main(){\n  int n;\n  scanf(\"%d\", &n);\n  while(n--){\n    rep(i, 10) rep(j, 10) scanf(\"%d\", &a[i][j]);\n\n    int used[10];\n    memset(used, 0, sizeof(used));\n    solve(0, used);\n\n    rep(i, 10){\n      rep(j, 10) printf(j?\" %d\":\"%d\", res[i][j]); puts(\"\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        for(int roop=0; roop<n; roop++){\n            bool box[12][12]={0};\n            \n            for(int i=1; i<=10; i++){\n                for(int j=1; j<=10; j++){\n                    cin>>box[i][j];\n                }\n            }\n            //cout<<\"----------------------\"<<endl;\n            \n            bool box2[12][12]={0};\n            \n            for(int i=0; i<(1<<10 - 1); i++){\n                memcpy(box2, box, sizeof(box));\n                int l[12][12]={0};\n                for(int j=1; j<=10; j++){\n                    l[0][j]= (i>>j)%2;\n                }\n                \n                for(int j=1; j<=10; j++){\n                    for(int k=1; k<=10; k++){\n                        if(l[j-1][k]==1){\n                            box2[j][k]=(box2[j][k]+1)%2;\n                            box2[j][k+1]=(box2[j][k+1]+1)%2;\n                            box2[j][k-1]=(box2[j][k-1]+1)%2;\n                            box2[j-1][k]=(box2[j-1][k]+1)%2;\n                            box2[j+1][k]=(box2[j+1][k]+1)%2;\n                        }\n                    }\n                    \n                    for(int k=1; k<=10; k++){\n                        l[j][k]=box2[j][k];\n                    }\n                }\n                \n                bool end_flag=true;\n                for(int i=1; i<=10; i++){\n                    if(l[10][i]==1){\n                        end_flag=false;\n                        break;\n                    }\n                }\n                \n                \n                if(end_flag){\n                    for(int i=0; i<=9; i++){\n                        for(int j=1; j<=10; j++){\n                            cout<<l[i][j];\n                            if(j==10)break;\n                            cout<<\" \";\n                        }\n                        cout<<endl;\n                    }\n                    break;\n                    \n                }\n            }\n            //cout<<\"============================\"<<endl;\n            \n            \n\n        }\n                \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz],1,MAX-1) && inRange(j+dj[(k+2)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz],1,MAX-1) && inRange(j+dj[(k+3)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz],1,MAX-1) && inRange(j+dj[(k+4)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tfor(int i = 0; i < N; i++) {\n\t\tint in[16][16] = {0};\n\t\tint react[3][3] = {{0,1,0},{1,1,1},{0,1,0}};\n\n\t\t/* input */\n\t\tfor(int j = 0; j < 10; j++) {\n\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\tcin >> in[j + 1][k + 1];\n\t\t\t}\n\t\t}\n\n\t\t/* search */\n\t\tfor(int j = 0; j < 1U << 10; j++) {\n\t\t\tint ans[16][16] = {0};\n\t\t\tint table[16][16] = {0};\n\t\t\tmemcpy(table, in, sizeof(in));\n\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\tif(j & (1U << k)) {\n\t\t\t\t\tfor(int l = 0; l < 3; l++) {\n\t\t\t\t\t\tfor(int m = 0; m < 3; m++) {\n\t\t\t\t\t\t\ttable[l][k + m] ^= react[l][m];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans[0][k] = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tans[0][k] = 0;\n\t\t\t}\n\t\t\tfor(int k = 1; k < 10; k++) {\n\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\tif(table[k - 1 + 1][l + 1] == 1) {\n\t\t\t\t\t\tfor(int m = 0; m < 3; m++)\n\t\t\t\t\t\t\tfor(int n = 0; n < 3; n++)\n\t\t\t\t\t\t\t\ttable[k + m][l + n] ^= react[m][n];\n\t\t\t\t\t\tans[k][l] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tans[k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0; k < 10; k++)\n\t\t\t\tif(table[10][k + 1]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t}\n\t\t\tif(flag) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif(l)\n\t\t\t\t\t\t\tcout << \" \";\n\t\t\t\t\t\tcout << ans[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint main(){\n  int n;\n  cin >> n;\n  \n  while(n-- > 0){\n    int imap[11][11],syokurin[11][11],solve[11][11];\n    rep(i,10){\n      rep(j,10){\n\tsyokurin[i][j] = solve[i][j] = 0;\n\tcin >> imap[i][j];\n      }\n    }\n\n    while(true)\n      {\n\trep(i,10){\n\t  rep(j,10){\n\t    if(imap[i][j] == 0)continue;\n\t    syokurin[i][j]++;\n\t    rep(k,4){\n\t      int nx = j+dx[k],ny = i+dy[k];\n\t      if(!(0<=nx && nx <10 && 0<=ny && ny <10))continue;\n\t      syokurin[ny][nx]++;\n\t    }\n\t  }\n\t}\t\n\n\trep(i,10){\n\t  rep(j,10){\n\t    if(syokurin[i][j] == 1)continue;\n\t    if(syokurin[i][j]%2 != 0){\n\t      solve[i][j] = 1;\n\t      imap[i][j] = imap[i][j] == 0?1:0;\n\t      rep(k,4){\n\t\tint nx = j+dx[k],ny = i+dy[k];\n\t\tif(!(0<=nx && nx <10 && 0<=ny && ny <10))continue;\n\t\timap[ny][nx] = imap[ny][nx]==0?1:0;\n\t      }\n\t    }\n\t  }\n\t}\n\n\trep(i,10)rep(j,10)syokurin[i][j] = 0;\n\tbool fin = true;\n\trep(i,10)rep(j,10)if(imap[i][j] == 1)fin = false;\n\t  if(fin)break;\n      }\n\n    rep(i,10){\n      rep(j,10){\n\tcout << solve[i][j];\n\tif(j != 9)cout << \" \";\n      }\n      cout << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nconst int N = 10;\nint a[N][N];\nbool isClick[N][N];\n\nvoid Click(int x,int y)\n{\n\tint dx[] = {0,1,-1,0, 0,};\n\tint dy[] = {0,0, 0,1,-1,};\n\tfor(int i = 0;i < 5; ++i)\n\t{\n\t\tif(x+dx[i] >= 0 && x+dx[i] < N && y+dy[i] >= 0 && y+dy[i] < N)\n\t\t\ta[x+dx[i]][y+dy[i]] = !a[x+dx[i]][y+dy[i]];\n\t}\n}\n\nvoid AllDelete()\n{\n\tint original[N][N];\n\tint i,j;\n\tfor(i=0;i<N;++i)for(j=0;j<N;++j)original[i][j]=a[i][j];\n\n\tunsigned mask=0;\n\tfor(;;)\n\t{\n\t\tfor(i=0;i<N;++i)\n\t\t\tfor(j=0;j<N;++j)\n\t\t\t\ta[i][j] = original[i][j],isClick[i][j] = false;\n\t\tfor(j = 0;j < N;++j)\n\t\t{\n\t\t\tif(mask & (1<<j))\n\t\t\t\tClick(0,j), isClick[0][j] = true;\n\t\t}\n\t\t++mask;\n\t\tfor(i = 1; i < N; ++i)\n\t\t\tfor(j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif(a[i-1][j])\n\t\t\t\t\tClick(i,j), isClick[i][j] = true;\n\t\t\t}\n\t\tbool isEnd = true;\n\t\tfor(j = 0; j < N; ++j)\n\t\t{\n\t\t\tif(a[N-1][j]) isEnd = false;\n\t\t}\n\t\tif(isEnd) return;\n\t}\n}\n\nint main(void)\n{\n\tint n,i,j;\n\tscanf(\"%d\",&n);\n\twhile(n--)\n\t{\n\t\tfor(i=0;i<N;++i)\n\t\t\tfor(j=0;j<N;++j)\n\t\t\t{\n\t\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t\t\tisClick[i][j] = false;\n\t\t\t}\n\n\t\tAllDelete();\n\t\tfor(i=0;i<N;++i)\n\t\t{\n\t\t\tfor(j=0;j<N;++j)\n\t\t\t\tprintf(\"%s%d%s\",(j?\" \":\"\"),isClick[i][j],(N-j==1?\"\\n\":\"\"));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n#define INV (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tvector< pair<int, int > > vt;\n\t\tbool bSCont = true;\n\n\t\tfor(int i = 1; i < MAX - 1 && bSCont; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 && bSCont; ++j){\n\t\t\t\tif( stm.m[i][j] == 1 ){\n\t\t\t\t\t\n\t\t\t\t\tconst int di[][2] = { {0,-1}, {-1,0}, {0,1}, {1,0} };\n\t\t\t\t\tconst int dj[][2] = { {-1,0}, {0,1}, {1,0}, {0,-1} };\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tbool bCont = true;\n\t\t\t\t\t\tint ti1, tj1, ti2, tj2;\n\n\t\t\t\t\t\tfor(int l = 0; l < sizeof(*di)/sizeof(**di) && bCont; ++l){\n\t\t\t\t\t\t\tif( stm.m[i+di[k][l]][j+dj[k][l]] != 0 ||\n\t\t\t\t\t\t\t\t!inRange(i+di[k][l],1,MAX-1) || !inRange(j+dj[k][l],1,MAX-1) ){\n\t\t\t\t\t\t\t\t\tti1 = tj1 = ti2 = tj2 = INV;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tswitch( k ){\n\t\t\t\t\t\t\t\t\tcase 0: ti1 = i + 1; tj1 = j; ti2 = i; tj2 = j + 1; break;\n\t\t\t\t\t\t\t\t\tcase 1: ti1 = i; tj1 = j - 1; ti2 = i + 1; tj2 = j; break;\n\t\t\t\t\t\t\t\t\tcase 2: ti1 = i - 1; tj1 = j; ti2 = i; tj2 = j - 1; break;\n\t\t\t\t\t\t\t\t\tcase 3: ti1 = i; tj1 = j + 1; ti2 = i - 1; tj2 = j; break;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( bCont ){\n\t\t\t\t\t\t\tif( inRange(ti1,1,MAX-1) && inRange(tj1,1,MAX-1) )\n\t\t\t\t\t\t\t\tvt.push_back( make_pair( ti1, tj1 ) );\n\t\t\t\t\t\t\tif( inRange(ti2,1,MAX-1) && inRange(tj2,1,MAX-1) )\n\t\t\t\t\t\t\t\tvt.push_back( make_pair( ti2, tj2 ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( vt.size() > 0 ){\n\t\t\tint ti = INV, tj = INV;\n\t\t\tint max1 = 0;\n\t\t\tdouble maxEfficient = 0.499;\n\t\t\t\n\t\t\tfor(unsigned int t = 0; t < vt.size(); ++t){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint invCnt = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( !inRange(vt[t].first+di[k], 1, MAX-1) || !inRange(vt[t].second+dj[k],1,MAX-1) )\n\t\t\t\t\t\tinvCnt++;\n\t\t\t\t\tif( stm.m[vt[t].first+di[k]][vt[t].second+dj[k]] == 1 )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tif( (double)cnt1 / ( 5 - invCnt ) > maxEfficient ){\n\t\t\t\t\t\tmaxEfficient = (double)cnt1 / (5 - invCnt);\n\t\t\t\t\t\tti = vt[t].first; tj = vt[t].second;\n\t\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ti != INV && tj != INV ){\n\t\t\t\t// cout << ti << ' ' << tj << '\\n';\n\t\t\t\tstm.PassParticle( ti, tj );\n\t\t\t\tans.m[ti][tj] = 1;\n\t\t\t\tbSCont = false;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint t[10][10],s[10][10],ans[10][10];\nint dx[] = {0,-1,0,1,0};\nint dy[] = {-1,0,0,0,1};\n\nbool check(int *used){\n\tmemset(ans,0,sizeof(ans));\n\tmemcpy(s,t,sizeof(t));\n\tmemcpy(ans,used,sizeof(used));\n\n\tfor(int i=0;i<10;i++){\n\t\tif(used[i]){\n\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\tint nx = i + dx[j];\n\t\t\t\tint ny = dy[j];\n\n\t\t\t\tif(nx>=0 && 10>nx && ny>=0 && 10>ny){\n\t\t\t\t\ts[ny][nx] = !s[ny][nx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(s[i-1][j]){ //ツ湘」ツつェ1ツづ按づァツづ篠必ツつクツ古オツつェツ必ツ要\n\t\t\t\tans[i][j] = 1;\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tint nx = j + dx[k];\n\t\t\t\t\tint ny = i + dy[k];\n\n\t\t\t\t\tif(nx>=0 && 10>nx && ny>=0 && 10>ny){\n\t\t\t\t\t\ts[ny][nx] = !s[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(s[i][j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool solve(int idx,int *used){\n\tif(idx == 10){\n\t\tif(check(used)){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif(solve(idx+1,used)) return true;\n\tused[idx] = 1;\n\tif(solve(idx+1,used)) return true;\n\tused[idx] = 0;\n\n\treturn false;\n}\n\nint main(void){\n\tint n;\n\tcin>>n;\n\n\twhile(n--){\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tcin>>t[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint used[10];\n\t\tmemset(used,0,sizeof(used));\n\t\tsolve(0,used);\n\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<9;j++){\n\t\t\t\tcout<<ans[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<ans[i][9]<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\nint a[10][10],b[10][10];\n\nvoid rev(int x,int y) {\n\tb[y][x]=1;\n\tif (x>0) a[y][x-1]=1-a[y][x-1];\n\tif (x<10) a[y][x+1]=1-a[y][x+1];\n\tif (y>0) a[y-1][x]=1-a[y-1][x];\n\tif (y<10) a[y+1][x]=1-a[y+1][x];\n\ta[y][x]=1-a[y][x];\n}\n\nint main() {\n\tint n,i,j,k,m[10][10];\n\tcin >> n;\n\tfor (n;n>0;n--) {\n\t\tfor (i=0;i<10;i++) for (j=0;j<10;j++) cin >> m[i][j];\n\t\tfor (k=0;k<1024;k++) {\n\t\t\tmemset(a,0,sizeof(a)); memset(b,0,sizeof(b));\n\t\t\tfor (i=0,j=k;i<10;i++,j/=2)  if (j % 2==1) rev(i,0); \n\t\t\tfor (i=1;i<10;i++) for (j=0;j<10;j++) if (m[i-1][j]!=a[i-1][j]) rev(j,i);\n\t\t\tfor (i=0;i<10;i++) if (m[9][i]!=a[9][i]) break;\n\t\t\tif (i==10) break; \n\t\t}\n\t\tfor (i=0;i<10;i++) {\n\t\t\tcout << b[i][0];\n\t\t\tfor (j=1;j<10;j++) cout << ' ' << b[i][j];\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint input[10][10], state[10][10], ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = !state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = !ans[y][x];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> input[i][j];\n            }\n        }\n        for (int bt=0; bt<(1<<10); ++bt) {\n            memcpy(state, input, sizeof(input));\n            memset(ans, 0, sizeof(ans));\n            for (int j=0; j<10; ++j) {\n                if ((bt>>j) & 1) {\n                    pass(0, j);\n                }\n            }\n            for (int i=1; i<10; ++i) {\n                for (int j=0; j<10; ++j) {\n                    if (state[i-1][j] == 1) {\n                        pass(i, j);\n                    }\n                }\n            }\n            if (accumulate(state[9], state[9] + 10, 0) == 0) break;\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\ninline bool valid(int i, int j) {\n    return 0 <= i && i < 10 && 0 <= j && j < 10;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    int state[10][10];\n    int ans[10][10];\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) {\n                    state[i][j] = 1 - state[i][j];\n                    if (valid(i+1, j-1)) state[i+1][j-1] = 1 - state[i+1][j-1];\n                    if (valid(i+1, j))   state[i+1][j]   = 1 - state[i+1][j];\n                    if (valid(i+1, j+1)) state[i+1][j+1] = 1 - state[i+1][j+1];\n                    if (valid(i+2, j))   state[i+2][j]   = 1 - state[i+2][j];\n                    ans[i+1][j] = 1;\n                }\n            }\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<bitset>\nusing namespace std;\n\n#define N 10\n\nclass CMap{\npublic:\n\tint m[N+2][N+2];\n\tint ans[N+2][N+2];\n\n\tCMap(){ Reset(); ResetAnswer(); }\n\t\n\tvoid Reset(){\n\t\tfor(int i = 0; i < N+2; ++i){\n\t\t\tfor(int j = 0; j < N+2; ++j){\n\t\t\t\tm[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tvoid ResetAnswer(){\n\t\tfor(int i = 0; i < N+2; ++i){\n\t\t\tfor(int j = 0; j < N+2; ++j){\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tbool inline static inRange(int t){\n\t\treturn ( 1 <= t && t < N + 1 );\n\t}\n\n\tbool PassParticle(int i, int j, bool bConsiderEfficiency = false)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( bConsiderEfficiency ){\n\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 ) cnt1++; else cnt0++;\n\t\t}\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tans[ i ][ j ] = 1;\n\t\treturn true;\n\t}\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < N+1; ++i)\n\t\t\tfor(int j = 1; j < N+1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(int i = 1; i < N+1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < N+1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintAnswer() const{\n\t\tfor(int i = 1; i < N+1; ++i){\n\t\t\tcout << ans[i][1];\n\t\t\tfor(int j = 2; j < N+1; ++j)\n\t\t\t\tcout << ' ' << ans[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nbool DetermineShootingPoints(CMap &M){\n\tfor(unsigned int i = 2; i < N+1; ++i){\n\t\tfor(unsigned int j = 1; j < N+1; ++j){\n\t\t\tif( M.m[i-1][j] == 1 ){\n\t\t\t\tM.PassParticle( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tif( M.NoLight() )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tbool bCont = true;\n\t\tCMap M;\n\t\tbitset<N> B;\n\n\t\tfor(int i = 1; i < N+1; ++i)\n\t\t\tfor(int j = 1; j < N+1; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tfor(unsigned long L = 0; L < (unsigned long)pow(2.0,(double)N) && bCont; ++L){\n\t\t\tB = L;\n\t\t\t//cout << L << \": \" << B.to_string() << endl;\n\t\t\tCMap Tmp = M;\n\t\t\tfor(unsigned int bits = 0; bits < B.size() && bCont; ++bits){\n\t\t\t\tif( B[bits] )\n\t\t\t\t\tM.PassParticle(1,N-bits);//break;\n\t\t\t}\n\t\t\tif( DetermineShootingPoints( M ) ){\n\t\t\t\tbCont = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tM = Tmp;\n\t\t}\n\t\t//cout << \"END.\\n\";\n\t\t//cout << \"CURRENT MAP:\\n\";\n\t\t//M.Print();\n\t\t//cout << \"ANSWER:\\n\";\n\t\tM.PrintAnswer();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\nusing namespace std;\n\nint c[10][10];\nint f[10][10];\nbool s[10][10];\nint hanten[2] = { 1,0 };\nint dx[5] = { -1,0,0,1,0 }, dy[5] = { 0,-1,1,0,0 };\nint main() {\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tmemset(s, false, sizeof(s));\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tfor (int e = 0; e < 10; e++) {\n\t\t\t\tscanf(\"%d\",&c[d][e]);\n\t\t\t}\n\t\t}\n\t\tfor (int g = 0; g < 1024; g++) {\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tf[h][i] = c[h][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tif (g & (1 << h)) {\n\t\t\t\t\ts[0][h] = true;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tint x = dx[i], y = h + dy[i];\n\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 1; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tif (f[h - 1][i]) {\n\t\t\t\t\t\ts[h][i] = true;\n\t\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\t\tint x = h+dx[j], y = i + dy[j];\n\t\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool K = true;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (f[i][j])K = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (K) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\t\tif (j)cout << \" \";\n\t\t\t\t\t\tcout << s[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++){\n\n    int ny=y+dy[k],nx=x+dx[k];\n\n    if( 0<=ny && 0<=nx && ny<10 && nx<10)\n      b[ny][nx]=!b[ny][nx];\n  }\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++){\n    if(p[i])rev(i,0);\n    ans[0][i]=p[i];\n  }\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint input[10][10], state[10][10], ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = !state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = !ans[y][x];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> input[i][j];\n            }\n        }\n        for (int bt=0; bt<(1<<10); ++bt) {\n            memcpy(state, input, sizeof(input));\n            memset(ans, 0, sizeof(ans));\n            for (int j=0; j<10; ++j) {\n                if ((bt>>j) & 1) {\n                    pass(0, j);\n                }\n            }\n            for (int i=1; i<10; ++i) {\n                for (int j=0; j<10; ++j) {\n                    if (state[i-1][j] == 1) {\n                        pass(i, j);\n                    }\n                }\n            }\n            if (accumulate(state[9], state[9] + 10, 0) == 0) break;\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//38\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define M ((1<<10)-1)\n\nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    unsigned u[10]={};\n    for(int y=0;y<10;y++){\n      for(int x=0;x<10;x++){\n\tint b;\n\tcin>>b;\n\tu[y]=(u[y]<<1)+b;\n      }\n    }\n    unsigned a[10];\n    for(a[0]=0;;a[0]++){\n      unsigned c[10];\n      copy(u,u+10,c);\n      c[0]^=a[0]^(a[0]<<1&M)^a[0]>>1;\n      c[1]^=a[0];\n      for(int i=1;i<9;i++){\n\ta[i]=c[i-1];\n\tc[i]^=a[i]^(a[i]<<1&M)^a[i]>>1;\n\tc[i+1]^=a[i];\n      }\n      a[9]=c[8];\n      if((a[9]^(a[9]<<1&M)^a[9]>>1^c[9])==0){\n\tbreak;\n      }\n    }\n    for(int y=0;y<10;y++){\n      for(int x=9;x>=0;x--){\n\tcout<<!!(1<<x&a[y])<<((x==0)?'\\n':' ');\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nconst int mod = 2;\nstruct Mod {\npublic:\n\tint num;\n\tMod() : Mod(0) { ; }\n\tMod(long long int n) : num((n % mod + mod) % mod) {\n\t\tstatic_assert(mod<INT_MAX / 2, \"mod is too big, please make num 'long long int' from 'int'\");\n\t}\n\tMod(int n) : Mod(static_cast<long long int>(n)) { ; }\n\toperator int() { return num; }\n};\n\nMod operator+(const Mod a, const Mod b) { return Mod((a.num + b.num) % mod); }\nMod operator+(const long long int a, const Mod b) { return Mod(a) + b; }\nMod operator+(const Mod a, const long long int  b) { return b + a; }\nMod operator++(Mod &a) { return a + Mod(1); }\nMod operator-(const Mod a, const Mod b) { return Mod((mod + a.num - b.num) % mod); }\nMod operator-(const long long int a, const Mod b) { return Mod(a) - b; }\nMod operator--(Mod &a) { return a - Mod(1); }\nMod operator*(const Mod a, const Mod b) { return Mod(((long long)a.num * b.num) % mod); }\nMod operator*(const long long int a, const Mod b) { return Mod(a)*b; }\nMod operator*(const Mod a, const long long int b) { return Mod(b)*a; }\nMod operator*(const Mod a, const int b) { return Mod(b)*a; }\nMod operator+=(Mod &a, const Mod b) { return a = a + b; }\nMod operator+=(long long int &a, const Mod b) { return a = a + b; }\nMod operator-=(Mod &a, const Mod b) { return a = a - b; }\nMod operator-=(long long int &a, const Mod b) { return a = a - b; }\nMod operator*=(Mod &a, const Mod b) { return a = a * b; }\nMod operator*=(long long int &a, const Mod b) { return a = a * b; }\nMod operator*=(Mod& a, const long long int &b) { return a = a * b; }\nMod operator^(const Mod a, const int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = (a * a) ^ (n / 2);\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod mod_pow(const Mod a, const long long  int n) {\n\tif (n == 0) return Mod(1);\n\tMod res = mod_pow((a * a), (n / 2));\n\tif (n % 2) res = res * a;\n\treturn res;\n}\nMod inv(const Mod a) { return a ^ (mod - 2); }\nMod operator/(const Mod a, const Mod b) {\n\tassert(b.num != 0);\n\treturn a * inv(b);\n}\nMod operator/(const long long int a, const Mod b) {\n\treturn Mod(a) / b;\n}\nMod operator/=(Mod &a, const Mod b) {\n\treturn a = a / b;\n}\n\n#define MAX_MOD_N 1024000\n\nMod fact[MAX_MOD_N], factinv[MAX_MOD_N];\nvoid init(const int amax = MAX_MOD_N) {\n\tfact[0] = Mod(1); factinv[0] = 1;\n\tfor (int i = 0; i < amax - 1; ++i) {\n\t\tfact[i + 1] = fact[i] * Mod(i + 1);\n\t\tfactinv[i + 1] = factinv[i] / Mod(i + 1);\n\t}\n}\nMod comb(const int a, const int b) {\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\n/* verified AOJ1327 One-Dimensional Cellular Automaton\n~Matrix~\n??????????°????????¨?????????§??????\nvector iostream cmath cassert ??????\nMatrix a(VV), b(VV);\n?????????:a*b\n????????????:l*a\n???:a+b\n???:a-b\n??¢???:a.transport()\n?????????:a.cofactor()\n?????????:a.det()\na???i???j??????:a.get(i,j)???\na???i??????j?????????k?????£??\\:set(i,j,k)\n????????????a[i][j] (a[i][j]=k)\na???x???:a.pow(x)\nn*n?????¬??????E:Matrix(n)\nm*n 0??????:Matrix(m,n)\nm*n ??¨????´????p?????????:Matrix(m,n,p)\nRow???row??§????????????(m*1??????):Matrix(row)\n**(??´??°??????)**\n????§????:a.triangulate()\n?????????:a.rank()\n?????????:a.inverse()\n//(????????????a.det()?????????a.pre_inverse()??§?±??????? ??´??°???)\n??¬??????????¶???????:a.rowReduction()\n//??£???????¬?????¨????????§£??????\n***\n*/\n\n#include <vector>\n#include <iostream>\n#include <cmath>\n#include <cassert>\nusing namespace std;\n\ntypedef Mod Elem;\ntypedef vector<Elem> Row;\ntypedef vector<Row> VV;\n\ntypedef long double ld;\nconst ld EPS = 1e-11;\n\nconst bool isZero(const Elem e) {\n\treturn e.num == 0;\n}\n\nstruct Matrix {\n\tVV matrix;\n\tint n, m;\n\n\tMatrix(const VV &matrix_);\n\texplicit Matrix(int n_);\n\texplicit Matrix(const Row &row);\n\tMatrix(int m_, int n_);\n\tMatrix(int m_, int n_, Elem e);\n\n\tconst Elem get(const int i, const int j) const;\n\tvoid set(const int x, const int y, const Elem k);\n\n\tconst Matrix operator + (const Matrix &rhs) const;\n\tconst Matrix operator * (const Matrix &rhs) const;\n\tconst Matrix operator - (const Matrix &rhs) const;\n\tMatrix &operator += (const Matrix &rhs);\n\tMatrix &operator *= (const Matrix &rhs);\n\tMatrix &operator -= (const Matrix &rhs);\n\n\tRow &operator[](const int x);\n\n\tconst Matrix transport() const;\n\tconst Matrix pow(int x) const;\n\tconst Matrix cofactor(int x, int y) const;\n\tconst Elem det() const;\n\n\tconst Matrix triangulate() const;\n\tconst int rank() const;\n\n\t//?????????????????¨????????°???(?????????)*(?????????)?????????\n\t//A:matrix,return det A * A^-1\n\tconst Matrix pre_inverse() const;\n\tconst Matrix inverse() const;\n\tconst Matrix rowReduction() const;\n};\n\nconst Matrix operator * (const Elem lambda, const Matrix &rhs) {\n\tMatrix tmp(rhs);\n\tfor (int i = 0; i < rhs.m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++)\n\t\t\ttmp.set(i, j, tmp.get(i, j) * lambda);\n\treturn tmp;\n}\n\nMatrix::Matrix(const VV &matrix_) : matrix(matrix_) {\n\tm = matrix_.size();\n\tif (m == 0) n = 0;\n\telse n = matrix_[0].size();\n}\nMatrix::Matrix(int n_) : m(n_), n(n_) {\n\tmatrix = VV(n, Row(n, 0));\n\tfor (int i = 0; i < n; ++i)\n\t\tset(i, i, 1);\n}\nMatrix::Matrix(const Row &row) : m(1), n(row.size()), matrix(VV(1, row)) {\n\t//size???m???vector<Elem>??????mx1???????????????\n\t(*this) = transport();\n}\nMatrix::Matrix(int m_, int n_) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, 0));\n}\nMatrix::Matrix(int m_, int n_, Elem e) : m(m_), n(n_) {\n\tmatrix = VV(m, Row(n, e));\n}\n\nconst Elem Matrix::get(const int i, const int j) const {\n\tif (0 <= i && i < m && 0 <= j && j < n)\n\t\treturn matrix[i][j];\n\n\tcerr << \"get(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\nvoid Matrix::set(const int i, const int j, const Elem k) {\n\tif (0 <= i && i < m && 0 <= j && j < n) {\n\t\t*(matrix[i].begin() + j) = k;\n\t\treturn;\n\t}\n\tcerr << \"set(\" << i << \",\" << j << \")is not exist.\" << endl;\n\tthrow;\n}\n\nconst Matrix Matrix::operator + (const Matrix &rhs) const {\n\tassert(m == rhs.m && n == rhs.n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\ttmp.set(i, j, get(i, j) + rhs.get(i, j));\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator * (const Matrix &rhs) const {\n\tassert(n == rhs.m);\n\n\tMatrix tmp(m, rhs.n, 0);\n\tElem sum;\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < rhs.n; j++) {\n\t\t\tsum = 0;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tsum += get(i, k) * rhs.get(k, j);\n\t\t\t}\n\t\t\ttmp.set(i, j, sum);\n\t\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::operator - (const Matrix &rhs) const {\n\treturn *this + ((Elem)-1 * rhs);\n}\n\nMatrix &Matrix::operator += (const Matrix &rhs) {\n\treturn *this = *this + rhs;\n}\n\nMatrix &Matrix::operator *= (const Matrix &rhs) {\n\treturn *this = *this * rhs;;\n}\n\nMatrix &Matrix::operator -= (const Matrix &rhs) {\n\treturn *this = *this - rhs;\n}\n\nRow &Matrix::operator[](const int x) {\n\treturn matrix[x];\n}\n\nconst Matrix Matrix::transport() const {\n\tVV tmp;\n\tfor (int i = 0; i < n; i++) {\n\t\tRow row;\n\t\tfor (int j = 0; j < m; j++)\n\t\t\trow.push_back(get(j, i));\n\t\ttmp.push_back(row);\n\t}\n\treturn tmp;\n}\n\nconst Matrix Matrix::pow(int x) const {\n\tMatrix tmp(*this), e(m);\n\tfor (int i = 1; i <= x; i <<= 1) {\n\t\tif ((x & i) > 0)\n\t\t\te = e * tmp;\n\t\ttmp = tmp * tmp;\n\t}\n\treturn e;\n}\n\nconst Matrix Matrix::cofactor(int x, int y) const {\n\tVV tmp;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (x == i) continue;\n\t\tRow row;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (y == j) continue;\n\t\t\trow.push_back(get(i, j));\n\t\t}\n\t\ttmp.push_back(row);\n\t}\n\treturn Matrix(tmp);\n}\n\nconst Elem Matrix::det() const {\n\tassert(n == m);\n\n\tif (m == 1)\n\t\treturn get(0, 0);\n\tElem sum = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tsum += ((i % 2 == 0 ? 1 : -1) * get(i, 0)) * Matrix(cofactor(i, 0)).det();\n\t}\n\treturn sum;\n}\n\nconst Matrix Matrix::triangulate() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\te = tmp.get(j, p) / tmp.get(i, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int Matrix::rank() const {\n\tMatrix tmp(triangulate());\n\tfor (int i = min(tmp.m - 1, tmp.n - 1); i >= 0; i--) {\n\t\tfor (int j = tmp.n - 1; j >= i; j--)\n\t\t\tif (isZero(tmp.get(i, j)))\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\treturn i + 1;\n\t}\n\treturn 0;\n}\n\nconst Matrix Matrix::pre_inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n, 0);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, ((i + j) % 2 == 0 ? 1 : -1)*cofactor(i, j).det());\n\treturn tmp.transport();\n}\n\n/*O(n!)????£?\nconst Matrix Matrix::inverse() const {\nMatrix tmp(pre_inverse());\nElem e = det();\nassert(!isZero(e));\ntmp = 1 / e * tmp;\nreturn tmp.transport();\n}*/\n\nconst Matrix Matrix::inverse() const {\n\tassert(m == n);\n\n\tMatrix tmp(m, n * 2), tmp2(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp.set(i, j, get(i, j));\n\tfor (int i = 0; i < m; i++)\n\t\ttmp.set(i, i + n, 1);\n\n\ttmp = tmp.rowReduction();\n\n\t//?????????????????¨??????????????????????????§??????\n\tfor (int i = 0; i < m; i++)\n\t\tassert(isZero(tmp.get(i, i) - 1));\n\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\ttmp2.set(i, j, tmp.get(i, j + n));\n\n\treturn tmp2;\n}\n\n/*\na b c j\nd e f k\ng h i l\n\nax+by+cz=j;\ndx+ey+fz=k;\ngx+hy+iz=l;\n\n|\nV\n\n1 0 0 x\n0 1 0 y\n0 0 1 z\n???????????????\n*/\nconst Matrix Matrix::rowReduction() const {\n\tMatrix tmp(*this);\n\tElem e;\n\tint p = 0;\n\tfor (int i = 0; i < m && p < n; i++, p++) {\n\t\tif (isZero(tmp.get(i, p))) {\n\t\t\ttmp.set(i, p, 0);\n\t\t\tbool flag = true;\n\t\t\tfor (int j = i + 1; j < m; j++)\n\t\t\t\tif (!isZero(tmp.get(j, p))) {\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t\ttmp.set(i, k, tmp.get(i, k) + tmp.get(j, k));\n\t\t\t\t\t//tmp[i].swap(tmp[j]);\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\ti--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\te = 1 / tmp.get(i, p);\n\t\ttmp.set(i, p, 1);\n\t\tfor (int k = i + 1; k < n; k++)\n\t\t\ttmp.set(i, k, tmp.get(i, k)*e);\n\t\tfor (int j = 0; j < m; j++) {\n\t\t\tif (i == j) continue;\n\t\t\te = tmp.get(j, p);\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\ttmp.set(j, k, tmp.get(j, k) - tmp.get(i, k) * e);\n\t\t}\n\t}\n\treturn tmp;\n}\n\nconst int dx[] = { 0,-1,0,1,0 };\nconst int dy[] = {0, 0,1,0,-1 };\nint main() {\n\tint N; cin >> N;\n\twhile (N--) {\n\t\tMatrix mat(100, 101);\n\t\tfor (int y = 0; y < 10; ++y) {\n\t\t\tfor (int x = 0; x < 10; ++x) {\n\t\t\t\tint num = y * 10 + x;\n\t\t\t\tint a; cin >> a;\n\t\t\t\tfor (int k = 0; k < 5; ++k) {\n\t\t\t\t\tint nextx = x + dx[k];\n\t\t\t\t\tint nexty = y + dy[k];\n\t\t\t\t\tif (nextx>=0&&nextx<10&&nexty>=0&&nexty<10) {\n\t\t\t\t\t\tint nextnum = nexty * 10 + nextx;\n\t\t\t\t\t\tmat[num][nextnum] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tmat[num][100] = a;\n\t\t\t}\n\t\t}\n\t\tMatrix ans = mat.rowReduction();\n\t\tfor (int i = 0; i < 10; ++i) {\n\t\t\tfor (int j = 0; j < 10; ++j) {\n\t\t\t\tif (ans[i * 10 + j][100]) {\n\t\t\t\t\tcout << 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcout << 0;\n\t\t\t\t}\n\t\t\t\tif (j == 9)cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint default_state[10][10];\nint state[10][10];\nint ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = 1 - state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = 1 - ans[y][x];\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        memcpy(state, default_state, sizeof(default_state));\n        memset(ans, 0, sizeof(ans));\n        for (int j=0; j<10; ++j) {\n            if ((bt>>j) & 1) {\n                pass(0, j);\n            }\n        }\n        for (int i=1; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i-1][j] == 1) {\n                    pass(i, j);\n                }\n            }\n        }\n        bool ok = true;\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if (state[i][j] == 1) ok = false;\n            }\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> default_state[i][j];\n            }\n        }\n        solve();\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 10;\nbool m[MAX][MAX],tmp[MAX][MAX];\nbool ans[MAX][MAX];\nint num;\nint dx[] = {-1,0,0,0,1};\nint dy[] = {0,-1,0,1,0};\n\nvoid input(){\n  num = 0;\n\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++){\n      cin >> m[i][j];\n      if(m[i][j]) num++;\n    }\n}\n\nbool isInside(int y, int x){\n  return 0<=y&&y<MAX&&0<=x&&x<MAX;\n}\n\nvoid rev(int y, int x, int& now){\n  for(int i = 0; i < 5; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n\n    if(isInside(ny,nx)){\n      tmp[ny][nx] = !tmp[ny][nx];\n      if(tmp[ny][nx]) now++;\n      else now--;\n    }\n  }\n}\n\nvoid print(){\n  for(int i = 0; i < MAX; i++){\n    for(int j = 0; j < MAX; j++){\n      if(j) cout << \" \";\n      cout << ans[i][j];\n    }\n    cout << endl;\n  }\n}\n\nvoid solve(){\n\n  for(int i = 0; i < (1<<MAX); i++){\n    memset(ans,false,sizeof(ans));\n    memcpy(tmp,m,sizeof(m));\n\n    int now = num;\n\n    for(int j = 0; j < MAX; j++){\n      if(i&(1<<j)){\n\tans[0][j] = true;\n\trev(0,j,now);\n      }\n    }\n\n    for(int j = 1; j < MAX; j++)\n      for(int k = 0; k < MAX; k++){\n\tif(tmp[j-1][k]){\n\t  ans[j][k] = true;\n\t  rev(j,k,now);\n\t}\n      }\n\n    if(now == 0){\n      print();\n      break;\n    }\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  while(n--){\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint input[10][10], state[10][10], ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = !state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = !ans[y][x];\n}\n\nint main() {\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> input[i][j];\n            }\n        }\n        for (int bt=0; bt<(1<<10); ++bt) {\n            memcpy(state, input, sizeof(input));\n            memset(ans, 0, sizeof(ans));\n            for (int j=0; j<10; ++j) {\n                if ((bt>>j) & 1) {\n                    pass(0, j);\n                }\n            }\n            for (int i=1; i<10; ++i) {\n                for (int j=0; j<10; ++j) {\n                    if (state[i-1][j] == 1) {\n                        pass(i, j);\n                    }\n                }\n            }\n            if (accumulate(state[9], state[9] + 10, 0) == 0) break;\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint L[10][10]; \nint F[10][10]; \nint R[10][10];\n\nvoid init() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            F[i][j] = 0;\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cin >> L[i][j];\n        }\n    }\n}\n\nbool check( int r, int c ) {\n    int b = L[r][c];\n    b ^= F[r][c];\n    if ( r - 1 >= 0 ) b ^= F[r-1][c];\n    if ( r + 1 < 10 ) b ^= F[r+1][c];\n    if ( c - 1 >= 0 ) b ^= F[r][c-1];\n    if ( c + 1 < 10 ) b ^= F[r][c+1];\n    return b == 1;\n}\n\nvoid output() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cout << F[i][j];\n            if ( j + 1 < 10 ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid flip( int r, int c ) {\n    int b = L[r][c];\n    b ^= F[r][c];\n    if ( r - 1 >= 0 ) b ^= F[r-1][c];\n    if ( r + 1 < 10 ) b ^= F[r+1][c];\n    if ( c - 1 >= 0 ) b ^= F[r][c-1];\n    if ( c + 1 < 10 ) b ^= F[r][c+1];\n    R[r][c] = b;\n}\n\nbool check() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            if ( R[i][j] ) return false;\n        }\n    }\n    return true;\n}\n\nbool solve( int r ) {\n    if ( r >= 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                flip( i, j );\n            }\n        }\n        return check();\n    }\n    if ( r == 0 ) {\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                F[r][j] = i & ( 1 << j ) ? 1 : 0;\n            }\n            if ( solve( r + 1 ) ) return true;\n        }\n    } else if ( r < 10 ) {\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                F[r][j] = i & ( 1 << j ) ? 1 : 0;\n            }\n            bool flag = true;\n            for ( int j = 0; j < 10; ++ j ) {\n                if ( check( r - 1, j ) ) flag = false;\n            }\n            if ( flag && solve( r + 1 ) ) return true;\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            init();\n            input();\n            solve( 0 );\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintAns() const\n\t{\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 &&\n\t\t\t\t\t\tinRange( i+di[k], 1, MAX - 1) &&\n\t\t\t\t\t\tinRange( j+dj[k], 1, MAX - 1 ) )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\n\t\tAnswer.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10];\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)ans[0][i]=(1&(1<<j));\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n    cout <<endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tint TryPassParticle(int i, int j)\n\t{\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\n\t\treturn cnt1;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {0,1,0,-1};\n\t\t\t\t\tconst int dj[] = {1,0,-1,0};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < 2; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%(sz-1)]][j+dj[(k+1)%(sz-1)]] == 0 ){\n\t\t\t\t\t\t\t\tint d1 = M.TryPassParticle(i+di[(k+2)%(sz-1)], j+dj[(k+2)%(sz-1)]);\n\t\t\t\t\t\t\t\tint d2 = M.TryPassParticle(i+di[(k+3)%(sz-1)], j+dj[(k+3)%(sz-1)]);\n\t\t\t\t\t\t\t\tif( d1 > max1 ){\n\t\t\t\t\t\t\t\t\tmax1 = d1;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+2)%(sz-1)];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+2)%(sz-1)];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( d2 > max1 ){\n\t\t\t\t\t\t\t\t\tmax1 = d2;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+3)%(sz-1)];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+3)%(sz-1)];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nconst int all = (1 << 10) - 1;\n\nint mask[12];\nint conv[(1<<10)+10];\nint save[12];\n\nint main(){\n\tfor(int line=0;line<1<<10;++line){\n\t\tint m = 0;\n\n\t\tfor(int i=0;i<10;++i){\n\t\t\tif((line >> i) & 1){\n\t\t\t\tm ^= 7 << i;\n\t\t\t}\n\t\t}\n\n\t\tconv[line] = (m >> 1) & all;\n\t}\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile(n--){\n\t\tfor(int y=0;y<10;++y){\n\t\t\tint m = 0, f;\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tscanf(\"%d\", &f);\n\t\t\t\tm = (m << 1) + f;\n\t\t\t}\n\t\t\tmask[y] = m;\n\t\t}\n\n\t\tfor(int line=0;line<1<<10;++line){\n\t\t\tint prev = mask[0] ^ conv[line];\n\t\t\tint curr = mask[1] ^ line;\n\n\t\t\tsave[0] = line;\n\n\t\t\tfor(int y=1;y<9;++y){\n\t\t\t\tint doit = prev;\n\t\t\t\tint nprev = curr ^ conv[doit];\n\t\t\t\tint ncurr = mask[y+1] ^ doit;\n\n\t\t\t\tprev = nprev;\n\t\t\t\tcurr = ncurr;\n\n\t\t\t\tsave[y] = doit;\n\t\t\t}\n\n\t\t\tsave[9] = prev;\n\n\t\t\tif(curr ^ prev){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int y=0;y<10;++y){\n\t\t\t\tint m = save[y];\n\t\t\t\tfor(int x=9;x>=0;--x){\n\t\t\t\t\tif(x != 9)printf(\" \");\n\t\t\t\t\tprintf(\"%d\", (m >> x) & 1);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int dx[] = {0,1,0,-1,0};\nconst int dy[] = {0,0,1,0,-1};\n\nint tile[10][10];\nint tmp[10][10];\nint correct(int x,int y){\n\treturn x < 10 && x >= 0 && y < 10 && y >= 0;\n}\nint getColor(int x,int y){\n\tint ret = tile[y][x];\n\trep(i,5){\n\t\tint sx = x + dx[i] , sy = y + dy[i];\n\t\tif(!correct(sx,sy))continue;\n\t\tif(tmp[sy][sx])ret++;\n\t}\n\treturn ret%2;\n}\n\nint solve(int upperMost){\n\trep(i,10)rep(j,10)tmp[i][j] = 0;\n\trep(i,10)tmp[0][10-i-1] = (upperMost>>i) & 1;\n\t//rep(i,10)cout << tmp[0][i] << endl;\n\t\n\tfor(int i = 1 ; i < 10 ; i++){\n\t\trep(j,10){\n\t\t\tif(getColor(j,i-1) == 1){\n\t\t\t\ttmp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\trep(i,10)rep(j,10)\n\t\tif(getColor(j,i))return 0;\n\treturn 1;\n}\nint main(){\n\tint N; cin >> N;\n\twhile(N--){\n\t\trep(i,10)rep(j,10)cin >> tile[i][j];\n\t\trep(bit,1<<10){\n\t\t\tif( solve(bit) ){\n\t\t\t\trep(i,10){\n\t\t\t\t\trep(j,10)cout << (j?\" \":\"\") << tmp[i][j];\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint light[10][10];\nbool solve(int n){\n  int ans[10][10];\n  int rslt[10];\n  REP(i,10){\n    if(i==0) REP(j,10)ans[i][j] = (n>>j&1);\n    else REP(j,10) ans[i][j] = rslt[j];\n    REP(j,10) rslt[j] = light[i][j];\n    REP(j,10){\n      if(j-1>=0)rslt[j] ^= ans[i][j-1];\n      rslt[j] ^= ans[i][j];\n      if(j+1<10)rslt[j] ^= ans[i][j+1];\n      if(i-1>=0)rslt[j] ^= ans[i-1][j];\n    }\n  }\n  bool right = true;\n  REP(j,10) if(rslt[j]) right = false;\n  if(right){\n    REP(y,10){\n      REP(x,10){\n        if(x) cout<<\" \";\n        cout<<ans[y][x];\n      }\n      cout<<endl;\n    }\n  }\n  return right;\n}\n\n\nint main(void){\n  int N;\n  cin>>N;\n  while(N--){\n    REP(y,10)REP(x,10) cin>>light[y][x];\n    REP(i,1<<10) if(solve(i)) break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MAX_ROW = 110;\nconst int MAX_COL = 110;\nstruct BitMatrix {\n    int n, m;\n    bitset<MAX_COL> val[MAX_ROW];\n    BitMatrix(int n_ = 1, int m_ = 1) {n = n_; m = m_;}\n    inline bitset<MAX_COL>& operator [] (int i) {return val[i];}\n    inline friend ostream& operator << (ostream& s, BitMatrix M) {\n        s << endl; \n        for (int i = 0; i < M.n; ++i) {\n            for (int j = 0; j < M.m; ++j) s << M.val[i][j];\n            s << endl;\n        }\n        return s;\n    }\n};\n\ninline BitMatrix operator * (BitMatrix A, BitMatrix B) {\n    BitMatrix R(A.n, B.m);\n    BitMatrix tB(B.m, B.n);\n    for (int i = 0; i < tB.n; ++i) for (int j = 0; j < tB.m; ++j) tB[i][j] = B[j][i];\n    for (int i = 0; i < R.n; ++i) for (int j = 0; j < R.m; ++j) R[i][j] = (A[i] & tB[j]).any();\n    return R;\n}\n\ninline BitMatrix pow(BitMatrix A, long long n) {\n    BitMatrix R(A.n, A.n);\n    for (int i = 0; i < A.n; ++i) R[i][i] = 1;\n    while (n > 0) {\n        if (n & 1) R = R * A;\n        A = A * A;\n        n >>= 1;\n    }\n    return R;\n}\n\nvector<vector<int> > Gauss_Jordan(BitMatrix A, vector<int> b) {\n\tint rank = 0;\n    for (int i = 0; i < A.n; ++i) { A[i][A.m] = b[i]; }\n    \n    vector<int> core, rem;\n\tfor (int i = 0; i < A.m; ++i) {\n\t\tint pivot = -1;\n\t\tfor (int j = rank; j < A.n; ++j) {\n\t\t\tif (A[j][i]) {\n\t\t\t\tpivot = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (pivot != -1) {\n            core.push_back(i);\n\t\t\tswap(A[pivot], A[rank]);\n\t\t\tfor (int j = 0; j < A.n; ++j) if (j != rank && A[j][i]) A[j] ^= A[rank];\n\t\t\t++rank;\n\t\t}\n        else rem.push_back(i);\n\t}\n    \n    vector<vector<int> > res;\n    for (int i = rank; i < A.n; ++i) \n        if (A[i][A.m]) return res;     // return -1;\n    \n    vector<int> sol(A.m, 0);\n    for (int i = 0; i < core.size(); ++i) sol[core[i]] = A[i][A.m];\n    res.push_back(sol);\n    \n    for (int i = 0; i < rem.size(); ++i) {\n        vector<int> temp(A.m, 0);\n        temp[rem[i]] = 1;\n        for (int j = 0; j < core.size(); ++j) temp[core[j]] = A[j][rem[i]];\n        res.push_back(temp);\n    }\n    \n    return res;     // return A[0].size()-rank;\n};\n\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint n;\nint main() {\n  while (cin >> n) {\n    for (int i = 0; i < n; ++i) {\n    BitMatrix A(100, 100);\n    vector<int> b(100, 0);\n    for (int i = 0; i < 10; ++i) {\n      for (int j = 0; j < 10; ++j) {\n\tA[i*10+j][i*10+j] = 1;\n\tfor (int k = 0; k < 4; ++k) {\n\t  int ni = i + dx[k], nj = j + dy[k];\n\t  if (ni < 0 || ni >= 10 || nj < 0 || nj >= 10) continue;\n\t  A[i*10+j][ni*10+nj] = 1;\n\t}\n\tint l;\n\tcin >> l;\n\tb[i*10+j] = l;\n      }\n    }\n    vector<int> res = Gauss_Jordan(A, b)[0];\n    for (int i = 0; i < 10; ++i) {\n      for (int j = 0; j < 10; ++j) {\n\tcout << res[i*10+j];\n\tif (j != 9) cout << \" \";\n      }\n      cout << endl;\n    }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum{W=10,H=10};\n\nbool clear(bool field[H+2][W+2]){\n  bool ok=true;\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)if(field[i][j])ok=false;\n  return ok;\n}\n\nint main(){\n  int n;\n  bool field[H+2][W+2];\n  bool dup[H+2][W+2];\n  int bit[H+2];\n  cin>>n;\n  for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)cin>>field[i][j];\n  for(bit[1]=0; bit[1] < (1<<10); bit[1]++){\n    for(int i=2;i<=H;i++)bit[i]=0;\n    for(int i=1;i<=H;i++)for(int j=1;j<=W;j++)dup[i][j]=field[i][j];\n    for(int j=1;j<=W;j++){\n      if(!((bit[1]>>j)&1))continue;\n      dup[0][j]^=1;\n      dup[0][j-1]^=1;\n      dup[0][j+1]^=1;\n      dup[0-1][j]^=1;\n      dup[0+1][j]^=1;\n    }\n    for(int i=2;i<=H;i++){\n      for(int j=1;j<=W;j++){\n        if(dup[i-1][j]){\n          bit[i]^=(1<<j);\n          dup[i][j]^=1;\n          dup[i][j-1]^=1;\n          dup[i][j+1]^=1;\n          dup[i-1][j]^=1;\n          dup[i+1][j]^=1;\n        }\n      }\n    }\n    if(clear(dup))break;\n  }\n  for(int i=1;i<=H;i++){\n    for(int j=1;j<=W;j++){\n      if(j!=1)cout<<\" \";\n      if(bit[i]&(1<<j))cout<<\"1\";\n      else cout<<\"0\";\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint I,flg;\nint t[10][10],u[10][10];\nint ans[10][10];\nvoid check();\nvoid dfs(int);\nvoid compute(int,int);\nint main(){\n  cin>>I;\n  while(I--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tu[i][j]=t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\n\n\nvoid dfs(int x){\n  if(flg)return;\n  if(x==10)check();\n  else{\n    ans[0][x]=0;\n    dfs(x+1);\n    ans[0][x]=1;\n    dfs(x+1);\n  }\n}\n\n\nvoid check(){\n  if(flg)return;\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)t[i][j]=u[i][j];\n  for(int i=0;i<10;i++)if(ans[0][i])compute(0,i);\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(t[i-1][j]==1){\n\tans[i][j]=1;\n\tcompute(i,j);\n      }\n    }\n  }\n  int cnt=0;\n  for(int i=0;i<10;i++)cnt+=t[9][i];\n  if(cnt==0){\n    flg=1;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j)cout<<' ';\n\tcout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}\n\nvoid compute(int y,int x){\n  t[y][x]=!t[y][x];\n  if(y>0)t[y-1][x]=!t[y-1][x];\n  if(x>0)t[y][x-1]=!t[y][x-1];\n  if(y<9)t[y+1][x]=!t[y+1][x];\n  if(x<9)t[y][x+1]=!t[y][x+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint field[10][10];\nint f2[10][10];\nint f3[10][10];\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, -1, 0, 1\n};\n\nbool inside(int x, int y){\n\tif(x >= 0 && x < 10 && y >= 0 && y < 10)\n\t\treturn true;\n\telse return false;\n}\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < 10; j++){\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tcin >> field[j][k];\n\t\t\t}\n\t\t}\n\t\tfor(int j = 0; j < 1024; j++){\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tfor(int l = 0; l < 10; l++){\n\t\t\t\t\tf2[k][l] = field[k][l];\n\t\t\t\t\tf3[k][l] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tif(((j >> k) & 1) == 1){\n\t\t\t\t\tfor(int l = 0; l < 4; l++){\n\t\t\t\t\t\tif(inside(k + dx[l], dy[l]))\n\t\t\t\t\t\t\tf2[dy[l]][k+dx[l]] = (f2[dy[l]][k+dx[l]] + 1) % 2;\n\t\t\t\t\t}\n\t\t\t\t\tf2[0][k] = (f2[0][k] + 1) % 2;\n\t\t\t\t\tf3[0][k] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 1; k < 10; k++){\n\t\t\t\tfor(int l = 0; l < 10; l++){\n\t\t\t\t\tif(f2[k-1][l] == 1){\n\t\t\t\t\t\tf3[k][l] = 1;\n\t\t\t\t\t\tfor(int m = 0; m < 4; m++){\n\t\t\t\t\t\t\tif(inside(k + dy[m], l + dx[m]))\n\t\t\t\t\t\t\t\tf2[k+dy[m]][l+dx[m]] = (f2[k+dy[m]][l+dx[m]] + 1) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf2[k][l] = (f2[k][l] + 1) % 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool f = true;\n\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\tif(f2[9][k] == 1){\n\t\t\t\t\tf = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f) break;\n\t\t}\n\t\tfor(int j = 0; j < 10; j++){\n\t\t\tfor(int k = 0; k < 9; k++){\n\t\t\t\tcout << f3[j][k] << \" \";\n\t\t\t}\n\t\t\tcout << f3[j][9] << endl;\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint f[10][10];\nint temp[10][10];\nint dx[5] = {1,0,0,-1,0};\nint dy[5] = {0,1,0,0,-1};\nvector<pair<int,int> > ans;\n\nvoid change(int y,int x)\n{\n\tif(temp[y-1][x] == 1)\n\t{\n\t\tans.push_back(make_pair(y,x));\n\t\trep(i,5)\n\t\t{\n\t\t\tint ny = y + dy[i];\n\t\t\tint nx = x + dx[i];\n\n\t\t\tif(0 <= nx && nx < 10 && 0 <= ny && ny < 10)\n\t\t\t{\n\t\t\t\tif(temp[ny][nx] == 1) temp[ny][nx] = 0;\n\t\t\t\telse temp[ny][nx] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int y,int x)\n{\n\trep(i,10) rep(j,10) temp[i][j] = f[i][j];\n\tans.clear();\n\tREP(i,1,9)\n\t{\n\t\trep(j,10)\n\t\t{\n\t\t\tif(i == y)\n\t\t\t{\n\t\t\t\tif(j >= x)\n\t\t\t\t{\n\t\t\t\t\tchange(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i > y)\n\t\t\t{\n\t\t\t\tchange(i,j);\t\n\t\t\t}\n\t\t}\n\t}\n\tint cnt = 0;\n\trep(i,10) rep(j,10) if(temp[i][j] == 1) cnt++;\n\n\tif(cnt == 0) return;\n\telse\n\t{\n\t\tif(y == 9)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\telse if(x < 9)\n\t\t{\n\t\t\tdfs(y,x+1);\n\t\t}\n\t\telse if(x == 9)\n\t\t{\n\t\t\tdfs(y+1,0);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\trep(i,n)\n\t{\n\t\tmemset(f,0,sizeof(f));\n\t\tmemset(temp,0,sizeof(temp));\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tcin >> f[j][k];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdfs(1,0);\n\n\t\tbool p[10][10];\n\t\trep(j,10) rep(k,10) p[j][k] = false;\n\n\t\trep(j,ans.size())\n\t\t{\n\t\t\tp[ans[j].first][ans[j].second] = true;\n\t\t}\n\t\t\n\n\t\trep(j,10)\n\t\t{\n\t\t\trep(k,10)\n\t\t\t{\n\t\t\t\tif(p[j][k]) cout << 1;\n\t\t\t\telse cout << 0;\n\n\t\t\t\tif(k == 9) cout << endl;\n\t\t\t\telse cout << \" \";\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dx[5] = { -1, 0, 0, 0, 1 };\nconst int dy[5] = {  0,-1, 0, 1, 0 };\nint stage[10][10];\nint cnt[10][10];\n\nint Color(int y, int x ){\n\tint tmp = stage[y][x];\n\trep (i, 5 ){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif (nx >= 10 || ny >= 10 || nx < 0 || ny < 0 ) continue;\n\t\ttmp += cnt[ny][nx];\n\t} // end rep\n\n\treturn tmp%2;\n}\n\nint solve(){\n\tfor (int y = 1; y < 10; y++)\n\t\trep (x, 10 )\n\t\t\tif (Color(y-1, x ) ) cnt[y][x]=1;\n\trep (i, 10 )\n\t\t\tif (Color(9, i ) ) return -1;\n\n\tint ret=0;\n\trep (y, 10 ) rep (x, 10 ) ret+=cnt[y][x];\n\n\treturn ret;\n}\n\nint ans[10][10];\n\nvoid bit_dfs(){\n\n\tint res = -1;\n\trep (i, 1<<10 ){\n\t\tmemset (cnt, 0, sizeof (cnt ) );\n\t\trep (j, 10 ) cnt[0][9-j]=(i>>j)&1;\n\t\tint t = solve();\n\t\tif (t >= 0 && (res < 0 || res > t ) ){\n\t\t\tres = t;\n\t\t\tmemcpy (ans, cnt, sizeof(cnt ) );\n\t\t} // end if\n\t} // end rep\n}\n\nint main()\n{\n\tint T; scanf(\"%d\", &T );\n\twhile (T--){\n\t\tmemset (ans, 0, sizeof(ans ) );\n\t\tmemset (cnt, 0, sizeof(cnt ) );\n\t\tmemset (stage, 0, sizeof(stage ) );\n\t\trep (y, 10 ) rep (x, 10 ) cin >> stage[y][x];\n\t\tbit_dfs();\n\t\trep (y, 10 ) rep (x, 10 ) cout << ans[y][x] << (x < 9 ? ' ' : '\\n' );\n\t} // end while\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stack>\n#include<functional>\n#include<list>\nusing namespace std;\n\nint c[10][10];\nint f[10][10];\nbool s[10][10];\nint hanten[2] = { 1,0 };\nint dx[5] = { -1,0,0,1,0 }, dy[5] = { 0,-1,1,0,0 };\nint main() {\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tfor (int e = 0; e < 10; e++) {\n\t\t\t\tscanf(\"%d\",&c[d][e]);\n\t\t\t}\n\t\t}\n\t\tfor (int g = 0; g < 1024; g++) {\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tf[h][i] = c[h][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tif (g & (1 << h)) {\n\t\t\t\t\ts[0][h] = true;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tint x = dx[i], y = h + dy[i];\n\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 1; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tif (f[h - 1][i]) {\n\t\t\t\t\t\ts[h][i] = true;\n\t\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\t\tint x = h+dx[j], y = i + dy[j];\n\t\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool K = true;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (f[i][j])K = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (K) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\t\tif (j)cout << \" \";\n\t\t\t\t\t\tcout << s[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint c[10][10];\nint f[10][10];\nbool s[10][10];\nint hanten[2] = { 1,0 };\nint dx[5] = { -1,0,0,1,0 }, dy[5] = { 0,-1,1,0,0 };\nint main() {\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tfor (int e = 0; e < 10; e++) {\n\t\t\t\tscanf(\"%d\",&c[d][e]);\n\t\t\t}\n\t\t}\n\t\tfor (int g = 0; g < 1024; g++) {\n\t\t\tmemset(s, 0, sizeof(s));\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tf[h][i] = c[h][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tif (g & (1 << h)) {\n\t\t\t\t\ts[0][h] = true;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tint x = dx[i], y = h + dy[i];\n\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 1; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tif (f[h - 1][i]) {\n\t\t\t\t\t\ts[h][i] = true;\n\t\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\t\tint x = h+dx[j], y = i + dy[j];\n\t\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool K = true;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (f[i][j])K = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (K) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\t\tif (j)cout << \" \";\n\t\t\t\t\t\tcout << s[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n\n#define MAX 12\n\nusing namespace std;\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int> > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintAns() const\n\t{\n\t\tint a[MAX][MAX] = {{0,},};\n\t\tfor( unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\ta[vHist[i].first][vHist[i].second] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << a[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << a[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 &&\n\t\t\t\t\t\tinRange( i+di[k], 1, MAX - 1) &&\n\t\t\t\t\t\tinRange( j+dj[k], 1, MAX - 1 ) )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid SearchShootingPoints(CMap &stm){\n\tfor(int i = 1; i < MAX - 1; ++i){\n\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\tint cnt1 = 0;\n\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 &&\n\t\t\t\t\tinRange( i+di[k], 1, MAX - 1) &&\n\t\t\t\t\tinRange( j+dj[k], 1, MAX - 1 ) )\n\t\t\t\t\t++cnt1;\n\n\t\t\tif( cnt1 >= 3 )\n\t\t\t{\n\t\t\t\tstm.PassParticle( i, j );\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tSearchShootingPoints( M );\n\n\t\tM.PrintAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,0,-1},dy[] = {1,0,-1,0,0};\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tint a[10][10],b[10][10] = {};\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\tfor(int k = 0;k < 10;k++) cin >> a[j][k];\n\t\t}\n\t\tfor(int j = 0;j < 1024;j++){\n\t\t\tint t[10][10];\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tt[k][l] = a[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(j >> k & 1){\n\t\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\t\tint nx = dx[l],ny = k + dy[l];\n\t\t\t\t\t\tif(ny >= 0 && ny < 10){\n\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 9;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tif(t[k][l]){\n\t\t\t\t\t\tb[k + 1][l] = 1;\n\t\t\t\t\t\tfor(int n = 0;n < 5;n++){\n\t\t\t\t\t\t\tint nx = k + 1 + dx[n],ny = l + dy[n];\n\t\t\t\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(t[9][k]) flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\t\tfor(int l = 0;l < 10;l++) {\n\t\t\t\t\t\tcout << (!l ? \"\" : \" \") << b[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tint TryPassParticle(int i, int j)\n\t{\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\n\t\treturn cnt1;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz],1,MAX-1) && inRange(j+dj[(k+2)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz],j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << endl;\n\t\tM.Print();*/\n\t\t\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tBFS( M, Answer );\n\t\t//cout << \"-----------------------------\\n\";\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int all = (1 << 10) - 1;\n\nint board[12][12];\nint mask[12];\nint conv[(1<<10)+10];\nint save[12];\n\nint main(){\n\tfor(int line=0;line<1<<10;++line){\n\t\tint m = 0;\n\n\t\tfor(int i=0;i<10;++i){\n\t\t\tif((line >> i) & 1){\n\t\t\t\tm ^= 7 << i;\n\t\t\t}\n\t\t}\n\n\t\tconv[line] = (m >> 1) & all;\n\t}\n\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;++t){\n\t\tfor(int y=0;y<10;++y){\n\t\t\tint m = 0;\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tcin >> board[y][x];\n\t\t\t}\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tm = (m << 1) + board[y][x];\n\t\t\t}\n\t\t\tmask[y] = m;\n\t\t}\n\n\t\tfor(int line=0;line<1<<10;++line){\n\t\t\tint prev = mask[0] ^ conv[line];\n\t\t\tint curr = mask[1] ^ line;\n\n\t\t\tsave[0] = line;\n\n\t\t\tfor(int y=1;y<9;++y){\n\t\t\t\tint doit = prev;\n\t\t\t\tint nprev = curr ^ conv[doit];\n\t\t\t\tint ncurr = mask[y+1] ^ doit;\n\n\t\t\t\tprev = nprev;\n\t\t\t\tcurr = ncurr;\n\n\t\t\t\tsave[y] = doit;\n\t\t\t}\n\n\t\t\tsave[9] = prev;\n\n\t\t\tif(curr ^ prev){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int y=0;y<10;++y){\n\t\t\t\tint m = save[y];\n\t\t\t\tfor(int x=9;x>=0;--x){\n\t\t\t\t\tif(x != 9)cout << \" \";\n\t\t\t\t\tcout << (((m >> x) & 1) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {-1, 0, 0, 0, 1};\n\nint n;\nint input[10][10], state[10][10], ans[10][10];\n\nvoid pass(int y, int x) {\n    for (int i=0; i<5; ++i) {\n        if (0 <= y + dy[i] && y + dy[i] < 10 && 0 <= x + dx[i] && x + dx[i] < 10) {\n            state[y + dy[i]][x + dx[i]] = !state[y + dy[i]][x + dx[i]];\n        }\n    }\n    ans[y][x] = !ans[y][x];\n}\n\nint main() {\n    cin >> n;\n    while (n --) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> input[i][j];\n            }\n        }\n        for (int bt=0; bt<(1<<10); ++bt) {\n            memcpy(state, input, sizeof(input));\n            memset(ans, 0, sizeof(ans));\n            for (int j=0; j<10; ++j) {\n                if ((bt>>j) & 1) {\n                    pass(0, j);\n                }\n            }\n            for (int i=1; i<10; ++i) {\n                for (int j=0; j<10; ++j) {\n                    if (state[i-1][j] == 1) {\n                        pass(i, j);\n                    }\n                }\n            }\n            if (accumulate(state[9], state[9] + 10, 0) == 0) break;\n        }\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n/*\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n*/\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(ny < 0 || ny >= 10 || nx < 0 || nx >= 10)continue;\n\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\t/*if(!allow(n)){\n\t\treturn false;\n\t}\n\t*/\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tif(!dfs(0)){\n\t\twhile(1);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tif(x > 0)cout << \" \";\n\t\t\t\tcout << used[y][x];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nconst int dx[5] = {-1, 0, 0, 0, 1};\nconst int dy[5] = {0, -1, 0, 1, 0};\n \nint arr[10][10];\nint ans[10][10], flip[10][10];\n \nint get(int x, int y)\n{\n    int c = arr[x][y];\n    for (int d = 0; d < 5; d++) {\n\tint x2 = x + dx[d], y2 = y + dy[d];\n\tif (0 <= x2 && x2 < 10 && 0 <= y2 && y2 < 10) {\n\t    c += flip[x2][y2];\n\t}\n    }\n    return c % 2;\n}\n \nint calc()\n{\n    for (int i = 1; i < 10; i++) {\n\tfor(int j = 0; j < 10; j++) {\n\t    if (get(i-1, j) != 0) {\n\t\tflip[i][j] = 1;\n\t    }\n\t}\n    }\n \n    for (int j = 0; j < 10; j++) {\n\tif (get(9, j) != 0) {\n\t    return -1;\n\t}\n    }\n \n    int res = 0;\n    for (int i = 0; i < 10; i++) {\n\tfor (int j = 0; j < 10; j++) {\n\t    res += flip[i][j];\n\t}\n    }\n    return res;\n}\n \nvoid solve()\n{\n    int res = -1;\n \n    for (int i = 0; i < (1<<10); i++) { \n\tmemset(flip, 0, sizeof(flip));\n\tfor (int j = 0; j < 10; j++) {\n\t    flip[0][10-j-1] = i >> j & 1;\n\t}\n\tint num = calc();\n\tif (num >= 0 && (res < 0 || res > num)) {\n\t    res = num;\n\t    memcpy(ans, flip, sizeof(ans));   \n\t}\n    }\n \n    for (int i = 0; i < 10; i++) {\n\tfor (int j = 0; j < 10; j++) {\n\t    printf(\"%d%c\", ans[i][j], j+1 == 10 ? '\\n' : ' ');\n\t}\n    }\n}\n \nint main()\n{\n    int Tc;\n    cin >> Tc;\n    while (Tc--) {\n\tfor (int i = 0; i < 10; i++) {\n\t    for (int j = 0; j < 10; j++) {\n\t\tcin >> arr[i][j];\n\t    }\n\t}\n\tsolve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n\nusing namespace std;\n\n#define reep(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reep(i, 0, n) \n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nvoid push(int light[10][10], int y, int x)\n{\n\tconst int dy[] = {-1, 0, 0, 0, 1};\n\tconst int dx[] = {0, -1, 0, 1, 0};\n\n\trep(i, 5){\n\t\tint py = y + dy[i];\n\t\tint px = x + dx[i];\n\t\tif(py<0 || 10<=py || px<0 || 10<=px)\n\t\t\tcontinue;\n\t\tlight[py][px] = !light[py][px];\n\t}\n}\n\nvoid simulate(int tmp[10][10], int j, bool output)\n{\n\trep(k, 10){\n\t\tif((j>>k)&1){\n\t\t\tpush(tmp, 0, k);\n\t\t\tif(output)\n\t\t\t\tprintf(\"%s1\", k?\" \":\"\");\n\t\t}else if(output)\n\t\t\tprintf(\"%s0\", k?\" \":\"\");\n\t}\n\tif(output)\n\t\tputs(\"\");\n\n\trep(k, 9){\n\t\trep(l, 10){\n\t\t\tif(tmp[k][l]){\n\t\t\t\tpush(tmp, k+1, l);\n\t\t\t\tif(output)\n\t\t\t\t\tprintf(\"%s1\", l?\" \":\"\");\n\t\t\t}else if(output)\n\t\t\t\tprintf(\"%s0\", l?\" \":\"\");\n\t\t}\n\t\tif(output)\n\t\t\tputs(\"\");\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\trep(i, n){\n\t\tint light[10][10];\n\t\trep(j, 10) rep(k, 10)\n\t\t\tscanf(\"%d\", &light[j][k]);\n\n\t\trep(j, 1<<10){\n\t\t\tint tmp[10][10];\n\t\t\trep(k, 10) rep(l, 10)\n\t\t\t\ttmp[k][l] = light[k][l];\n\n\t\t\tsimulate(tmp, j, false);\n\t\t\tbool ok = true;\n\t\t\trep(k, 10) rep(l, 10){\n\t\t\t\tif(tmp[k][l]){\n\t\t\t\t\tok = false;\n\t\t\t\t\tk=10;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ok){\n\t\t\t\tsimulate(light, j, true);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\nint ans[11][11]={};\n\nvector<vector<int> > d(int y,int x,vector<vector<int> > t){\n    int dx[]={0,0,0,-1,1};\n    int dy[]={-1,0,1,0,0};\n    rep(k,5){\n        int ddy=y+dy[k],ddx=x+dx[k];\n        if(ddx>=0&&ddy>=0&&ddx<10&&ddy<10){\n            t[ddy][ddx]=!t[ddy][ddx];\n        }\n    }\n    return t;\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(loop,n){\n        vector<vector<int> > data;\n        rep(i,10){\n            vector<int> a(10);\n            rep(j,10)cin>>a[j];\n            data.pb(a);\n        }\n//        rep(i,10){rep(j,10)cout<<data[i][j]<<\" \";cout<<endl;}\n        rep(i,1<<10){\n            vector<vector<int> > t=data;\n            rep(j,11)rep(k,11)ans[j][k]=0;\n            rep(j,10){\n                ans[0][j]=((i&(1<<j))!=0);\n                if(ans[0][j])t=d(0,j,t);\n            }\n            for(int j=1;j<10;j++){\n                for(int k=0;k<10;k++){\n                    if(t[j-1][k]==1){\n                        ans[j][k]=1;\n                        t=d(j,k,t);\n                    }\n                }\n            }\n            bool f=true;\n            rep(j,10){\n                if(t[9][j]==1)f=false;\n            }\n            if(f){\n                rep(j,10){\n                    rep(k,10){\n                        if(k)cout<<\" \";\n                        cout<<ans[j][k];\n                    }\n                    cout<<endl;\n                }\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={0,0,0,1,-1},dy[]={-1,1,0,0,0};\n\nint d[10][10], b[10][10], a[10][10];\n\nvoid flip(int x, int y) {\n  a[y][x]=1;\n  for(int i=0; i<5; i++) {\n    b[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n  }\n}\n\nint main() {\n\n  int n;\n  cin>> n;\n  while(n--) {\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcin>> d[i][j];\n      }\n    }\n\n    for(int i=0; i<1024; i++) {\n      memset(a, 0, sizeof(a));\n      memcpy(b, d, sizeof(d));\n      for(int j=0; j<10; j++) {\n\tif((i>>j) & 1) flip(j, 0);\n      }\n\n      for(int j=1; j<10; j++) {\n\tfor(int k=0; k<10; k++) {\n\t  if(b[j-1][k]) flip(k, j);\n\t}\n      }\n\n      int cnt=0;\n      for(int j=0; j<10; j++) {\n\tif(b[9][j]){\n\t  cnt++; break;\n\t}\n      }\n\n      if(!cnt) break;\n    }\n\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcout << a[i][j]<< (j==9 ? \"\" : \" \");\n      }\n      cout<< endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,s,d[12][12],b[12][12],a[12][12];\nint dx[] = { 0,0,0,1,-1};\nint dy[] = {-1,1,0,0, 0};\n\nvoid flip(int x, int y)\n{\n\ta[y][x] = 1;\n\tfor(int i=0; i<5; i++)\n\t{\n\t\tb[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n\t}\n}\n\nvoid func()\n{\n\tfor(int i=0; i<=1024; i++)\n\t{\n\t\tmemset(a,0,sizeof(d));\n\t\tmemcpy(b,d,sizeof(d));\n\n\t\tfor(int y=1,x=1; x<=10; x++)\n\t\t{\n\t\t\tif((i>>(x-1))&1) flip(x,y);\n\t\t}\n\n\t\tfor(int y=2; y<=10; y++)\n\t\tfor(int x=1; x<=10; x++)\n\t\t{\n\t\t\tif(b[y-1][x]) flip(x,y);\n\t\t}\n\n\t\ts=0;\n\t\tfor(int y=10,x=1; x<=10; x++)\n\t\t{\n\t\t\ts+=a[y][x];\n\t\t}\n\n\t\tif(s==0) return;\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\twhile(n--)\n\t{\n\t\tfor(int y=1; y<=10; y++)\n\t\tfor(int x=1; x<=10; x++)\n\t\t{\n\t\t\tcin >> d[y][x];\n\t\t}\n\n\t\tfunc();\n\n\t\tfor(int y=1; y<=10; y++)\n\t\t{\n\t\t\tfor(int x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tcout << a[y][x] << (x==10?\"\":\" \");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        for(int roop=0; roop<n; roop++){\n            bool box[12][12]={0};\n            \n            for(int i=1; i<=10; i++){\n                for(int j=1; j<=10; j++){\n                    cin>>box[i][j];\n                }\n            }\n            //cout<<\"----------------------\"<<endl;\n            \n            bool box2[12][12]={0};\n            \n            for(int i=0; i<(1<<10 - 1); i++){\n                memcpy(box2, box, sizeof(box));\n                int l[12][12]={0};\n                for(int j=1; j<=10; j++){\n                    l[0][j]= (i>>j)%2;\n                }\n                \n                for(int j=1; j<=10; j++){\n                    for(int k=1; k<=10; k++){\n                        if(l[j-1][k]==1){\n                            box2[j][k]=(box2[j][k]+1)%2;\n                            box2[j][k+1]=(box2[j][k+1]+1)%2;\n                            box2[j][k-1]=(box2[j][k-1]+1)%2;\n                            box2[j-1][k]=(box2[j-1][k]+1)%2;\n                            box2[j+1][k]=(box2[j+1][k]+1)%2;\n                        }\n                    }\n                    \n                    for(int k=1; k<=10; k++){\n                        l[j][k]=box2[j][k];\n                    }\n                }\n                \n                bool end_flag=true;\n                for(int i=1; i<=10; i++){\n                    if(l[10][i]==1){\n                        end_flag=false;\n                        break;\n                    }\n                }\n                \n                \n                if(end_flag){\n                    for(int i=0; i<=9; i++){\n                        for(int j=1; j<=10; j++){\n                            cout<<l[i][j];\n                            if(j==10)break;\n                            cout<<\" \";\n                        }\n                        if(i==9)break;\n                        cout<<endl;\n                    }\n                    break;\n                    \n                }\n            }\n            //cout<<\"============================\"<<endl;\n            \n            \n\n        }\n                \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main()\n{\n  int n;\n  cin >> n;\n  while(n--){\n    int dtct[10][10];\n    int dx[] = {-1, 0, 1, 0};\n    int dy[] = {0, 0, 0, 1};\n    for(int i = 0; i < 10; i++){\n      for(int j = 0; j < 10; j++){\n\tcin >> dtct[i][j];\n      }\n    }\n    \n    for(int i = 0; i < 1 << 10; i++){\n      int axi[10][10] = {{0}};\n      int tmp[10][10] = {{0}};\n      for(int j = 0; j < 10; j++){\n\taxi[0][j] = (i >> j) & 1;\n\tif(axi[0][j] == 0) continue;\n\tfor(int k = 0; k < 4; k++){\n\t  int nx = j + dx[k], ny = dy[k];\n\t  if(nx < 0 || 10 <= nx || ny < 0 || 10 <= ny) continue;\n\t  tmp[ny][nx]++;\n\t}\n      }\n      for(int j = 1; j < 10; j++){\n\tfor(int k = 0; k < 10; k++){\n\t  if((dtct[j-1][k]+tmp[j-1][k])%2 == 1){\n\t    axi[j][k] = 1;\n\t    for(int l = 0; l < 4; l++){\n\t      int nx = k + dx[l], ny = j + dy[l];\n\t      if(nx < 0 || 10 <= nx || ny < 0 || 10 <= ny) continue;\n\t      tmp[ny][nx]++;\n\t    }\n\t  }\n\t}\n      }\n      bool flag = true;\n      for(int j = 0; j < 10; j++){\n\tif((tmp[9][j]+dtct[9][j])%2 == 1) flag = false;\n      }\n      if(flag){\n\tfor(int j = 0; j < 10; j++){\n\t  for(int k = 0; k < 10; k++) cout << axi[j][k] << (k == 9 ? \"\\n\":\" \");\n\t}\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n#define INV (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\n\t\t//cout << \"Shot: \" << i << \",\" << j << endl;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tvector< pair<int, int > > vt;\n\t\tbool bSCont = true;\n\n\t\t/* corner */\n\t\t{\n\t\t\tif( stm.m[1][1] == 1 ){\n\t\t\t\tif( stm.m[1][2] == 1 && stm.m[2][1] == 1 &&\n\t\t\t\t\tstm.m[2][2] == 0  ){\n\t\t\t\t\tstm.PassParticle( 1, 1 );\n\t\t\t\t\tans.m[1][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( stm.m[1][MAX-2] == 1 ){\n\t\t\t\tif( stm.m[1][MAX-3] == 1 && stm.m[2][MAX-2] == 1 &&\n\t\t\t\t\tstm.m[2][MAX-3] == 0  ){\n\t\t\t\t\tstm.PassParticle( 1, MAX-2 );\n\t\t\t\t\tans.m[1][MAX-2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( stm.m[MAX-2][1] == 1 ){\n\t\t\t\tif( stm.m[MAX-3][1] == 1 && stm.m[MAX-2][2] == 1 &&\n\t\t\t\t\tstm.m[MAX-3][2] == 0  ){\n\t\t\t\t\tstm.PassParticle( MAX-2, 1 );\n\t\t\t\t\tans.m[MAX-2][1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( stm.m[MAX-2][MAX-2] == 1 ){\n\t\t\t\tif( stm.m[MAX-2][MAX-3] == 1 && stm.m[MAX-3][MAX-2] == 1 &&\n\t\t\t\t\tstm.m[MAX-3][MAX-3] == 0 ){\n\t\t\t\t\tstm.PassParticle( MAX-2, MAX-2 );\n\t\t\t\t\tans.m[MAX-2][MAX-2] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* deko */\n\t\t{\n\t\t\tconst int ci[32] = {1,1,1,1,1,1,1,1,2,3,4,5,6,7,8,9,2,3,4,5,6,7,8,9,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2};\n\t\t\tconst int cj[32] = {2,3,4,5,6,7,8,9,1,1,1,1,1,1,1,1,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,MAX-2,2,3,4,5,6,7,8,9};\n\n\t\t\tfor(int i = 0; i < sizeof(ci)/sizeof(*ci); ++i ){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1, 0};\n\t\t\t\tconst int dj[] = {0, 0,1,0,-1};\n\n\t\t\t\tfor(int j = 0; j < sizeof(di)/sizeof(*di); ++j){\n\t\t\t\t\tif( stm.m[ci[i]+di[j]][cj[i]+dj[j]] == 1 )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\t\t\t\tif( cnt1 == 4 ){\n\t\t\t\t\tint ccnt1 = 0;\n\t\t\t\t\tconst int ddi[] = {-1,-1, 1, 1};\n\t\t\t\t\tconst int ddj[] = {-1, 1, 1,-1};\n\n\t\t\t\t\tfor( int j = 0; j < sizeof(ddi)/sizeof(*ddi); ++j){\n\t\t\t\t\t\tif( stm.m[ci[i]+ddi[j]][cj[i]+ddj[j]] == 1 )\n\t\t\t\t\t\t\t++ccnt1;\n\t\t\t\t\t}\n\t\t\t\t\tif( ccnt1 == 1 ){\n\t\t\t\t\t\tstm.PassParticle( ci[i], cj[i] );\n\t\t\t\t\t\tans.m[ci[i]][cj[i]] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/* other */\n\t\tfor(int i = 1; i < MAX - 1 && bSCont; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 && bSCont; ++j){\n\t\t\t\tif( stm.m[i][j] == 1 ){\n\t\t\t\t\tconst int di[4][5] = {\n\t\t\t\t\t\t{0,-1,-1,-1,0},\n\t\t\t\t\t\t{-1,-1,0,1,1},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{1,1,0,-1,-1}\n\t\t\t\t\t};\n\t\t\t\t\tconst int dj[4][5] = {\n\t\t\t\t\t\t{-1,-1,0,1,1},\n\t\t\t\t\t\t{0,1,1,1,0},\n\t\t\t\t\t\t{1,1,0,-1,-1},\n\t\t\t\t\t\t{0,-1,-1,-1,0}\n\t\t\t\t\t};\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tbool bCont = true;\n\t\t\t\t\t\tint tti, ttj;\n\n\t\t\t\t\t\tfor(int l = 0; l < sizeof(*di)/sizeof(**di) && bCont; ++l){\n\t\t\t\t\t\t\tswitch( k )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcase 0: tti = i + 1; ttj = j; break;\n\t\t\t\t\t\t\t\tcase 1: tti = i; ttj = j - 1; break;\n\t\t\t\t\t\t\t\tcase 2: tti = i - 1; ttj = j; break;\n\t\t\t\t\t\t\t\tcase 3: tti = i; ttj = j + 1; break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( stm.m[i+di[k][l]][j+dj[k][l]] != 0 )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttti = ttj = INV;\n\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif( bCont ){\n\t\t\t\t\t\t\tif( inRange(tti,1,MAX-1) && inRange(ttj,1,MAX-1) &&\n\t\t\t\t\t\t\t\t(inRange(i+di[k][0],1,MAX-1) && inRange(j+dj[k][0],1,MAX-1)&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][1],1,MAX-1) && inRange(j+dj[k][1],1,MAX-1)&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][2],1,MAX-1) && inRange(j+dj[k][2],1,MAX-1)&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][3],1,MAX-1) && inRange(j+dj[k][3],1,MAX-1)&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][4],1,MAX-1) && inRange(j+dj[k][4],1,MAX-1))\n\t\t\t\t\t\t\t\t||\n\t\t\t\t\t\t\t\t((!inRange(i+di[k][0],1,MAX-1)||!inRange(j+dj[k][0],1,MAX-1))&&\n\t\t\t\t\t\t\t\t (!inRange(i+di[k][1],1,MAX-1)||!inRange(j+dj[k][1],1,MAX-1))&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][2],1,MAX-1) && inRange(j+dj[k][2],1,MAX-1)&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][3],1,MAX-1) && inRange(j+dj[k][3],1,MAX-1)&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][4],1,MAX-1) && inRange(j+dj[k][4],1,MAX-1)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t||\n\t\t\t\t\t\t\t\t(inRange(i+di[k][0],1,MAX-1) && inRange(j+dj[k][0],1,MAX-1)&&\n\t\t\t\t\t\t\t\t inRange(i+di[k][1],1,MAX-1) && inRange(j+dj[k][1],1,MAX-1)&&\n\t\t\t\t\t\t\t\t (!inRange(i+di[k][2],1,MAX-1) || !inRange(j+dj[k][2],1,MAX-1))&&\n\t\t\t\t\t\t\t\t (!inRange(i+di[k][3],1,MAX-1) || !inRange(j+dj[k][3],1,MAX-1))&&\n\t\t\t\t\t\t\t\t (!inRange(i+di[k][4],1,MAX-1) || !inRange(j+dj[k][4],1,MAX-1))\n\t\t\t\t\t\t\t\t )\n\t\t\t\t\t\t\t\t )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvt.push_back( make_pair( tti, ttj ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif( inRange(tti,1,MAX-1) && inRange(ttj,1,MAX-1) &&\n\t\t\t\t\t\t\t\tinRange(i+di[k][0],1,MAX-1) && inRange(j+dj[k][0],1,MAX-1)&&\n\t\t\t\t\t\t\t\t(!inRange(i+di[k][1],1,MAX-1)||!inRange(j+dj[k][1],1,MAX-1))&&\n\t\t\t\t\t\t\t\t(!inRange(i+di[k][2],1,MAX-1)||!inRange(j+dj[k][2],1,MAX-1))&&\n\t\t\t\t\t\t\t\t(!inRange(i+di[k][3],1,MAX-1)||!inRange(j+dj[k][3],1,MAX-1))&&\n\t\t\t\t\t\t\t\tinRange(i+di[k][4],1,MAX-1)&&inRange(j+dj[k][4],1,MAX-1) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint cnt1 = 0;\n\t\t\t\t\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\t\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\t\t\t\tif( stm.m[tti+di[k]][ttj+dj[k]] == 1 )\n\t\t\t\t\t\t\t\t\t\tcnt1++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( cnt1 == 5 ){\n\t\t\t\t\t\t\t\t\tstm.PassParticle( tti, ttj );\n\t\t\t\t\t\t\t\t\tans.m[tti][ttj] = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif( vt.size() > 0 )\n\t\t{\n\t\t\tint ti = INV, tj = INV;\n\t\t\tint max1 = 0;\n\t\t\tdouble maxEfficient = 0.499;\n\t\t\t\n\t\t\tfor(unsigned int t = 0; t < vt.size(); ++t){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tint invCnt = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0,-1,-1,1,1};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1,-1,1,1,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tif( !inRange(vt[t].first+di[k], 1, MAX-1) || !inRange(vt[t].second+dj[k],1,MAX-1) )\n\t\t\t\t\t\tinvCnt++;\n\t\t\t\t\tif( stm.m[vt[t].first+di[k]][vt[t].second+dj[k]] == 1 )\n\t\t\t\t\t\tcnt1++;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 )\n\t\t\t\t{\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tif( (double)cnt1 / ( 5 - invCnt ) > maxEfficient )\n\t\t\t\t\t{\n\t\t\t\t\t\tmaxEfficient = (double)cnt1 / (5 - invCnt);\n\t\t\t\t\t\tti = vt[t].first;\n\t\t\t\t\t\ttj = vt[t].second;\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( ti != INV && tj != INV )\n\t\t\t{\n\t\t\t\tstm.PassParticle( ti, tj );\n\t\t\t\tans.m[ti][tj] = 1;\n\t\t\t\tbSCont = false;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i) for(int j = 0; j < MAX; ++j) m[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) &&\n\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+5)%sz]][j+dj[(k+5)%sz]] == 1 && inRange(i+di[(k+5)%sz]) && inRange(j+dj[(k+5)%sz])) ||\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+5)%sz]][j+dj[(k+6)%sz]] == 1 && inRange(i+di[(k+6)%sz]) && inRange(j+dj[(k+6)%sz])) ||\n\t\t\t\t\t\t\t\t(M.m[i+di[(k+5)%sz]][j+dj[(k+7)%sz]] == 1 && inRange(i+di[(k+7)%sz]) && inRange(j+dj[(k+7)%sz]))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool grid[10][10];\n\nvoid rev(int y,int x){\n  int dy[] = {1,0,-1,0,0}, dx[] = {0,1,0,-1,0};\n\n  for(int i=0;i<5;i++){\n    int sy = y+dy[i], sx = x+dx[i];\n    if(sy<0 || sx<0 || sy>10 || sx>10)continue;\n    grid[sy][sx] = !grid[sy][sx];\n  }\n}\n\nint main(){\n  int t;\n  bool tmp[10][10];\n  bool ans[10][10];\n\n  cin >> t;\n  while(t--){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin >> grid[i][j];\n\ttmp[i][j] = grid[i][j];\n      }\n    }\n\n    for(int i=0;i<(1<<10);i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++)grid[j][k] = tmp[j][k];\n      }\n\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  rev(0,j);\n\t  ans[0][j] = true;\n\t}else ans[0][j] = false;\n      }\n\n      for(int j=1;j<10;j++){\n\tfor(int k=0;k<10;k++){\n\t  if(grid[j-1][k]){\n\t    rev(j,k);\n\t    ans[j][k] = true;\n\t  }else ans[j][k] = false;\n\t}\n      }\n\n      bool f = false;\n      for(int j=0;j<10;j++)f |= grid[9][j];\n      if(!f)break;\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<9;j++)cout << ans[i][j] << \" \";\n      cout << ans[i][9] << endl;\n    }\n    if(t)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool field[11][11], ans[11][11];\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcin >> field[i][j];\n      }\n    }\n    \n    memset(ans, 0, sizeof(ans));\n    \n    for(int y = 0 ; y < 10 ; y++){\n      for(int x = 0 ; x < 10 ; x++){\n\tif(y == 0 && x == 0){\n\t  if(field[0][0] && field[0][1] && field[1][0] && field[1][1]) ans[0][0] = 1;\n\t}\n\telse if(y == 0 && x == 9){\n\t  if(field[0][9] && field[0][8] && field[1][8] && field[1][9]) ans[0][9] = 1;\n\t}\n\telse if(y == 9 && x == 0){\n\t  if(field[9][0] && field[8][0] && field[8][1] && field[9][1]) ans[9][0] = 1;\n\t}\n\telse if(y == 9 && x == 9){\n\t  if(field[9][9] && field[9][8] && field[8][9] && field[8][8]) ans[9][9] = 1;\n\t}\n\telse if(y == 0){\n\t  if(field[0][x] && field[0][x+1] && field[1][x] && field[0][x-1]) ans[0][x] = 1;\n\t}\n\telse if(x == 0){\n\t  if(field[y][0] && field[y+1][0] && field[y][1] && field[y-1][0]) ans[y][0] = 1;\n\t}\n\telse if(y == 9){\n\t  if(field[9][x] && field[9][x+1] && field[8][x] && field[9][x-1]) ans[9][x] = 1;\n\t}\n\telse if(x == 9){\n\t  if(field[y][9] && field[y+1][9] && field[y][8] && field[y-1][9]) ans[y][0] = 1;\n\t}\n\telse if(field[y][x] && field[y-1][x] && field[y+1][x] && field[y][x-1] && field[y][x+1]){\n\t  ans[y][x] = 1;\n\t}\n\telse if(!field[y][x] && !field[y][x+1] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y+1][x] && field[y+1][x+1] && field[y-1][x+1] &&\n\t\tfield[y][x+2]){\n\t  ans[y][x] = 1, ans[y][x+1] = 1;\n\t}\n\telse if(!field[y][x] && !field[y+1][x] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y][x+1] && field[y+1][x-1] && field[y+1][x+1] &&\n\t\tfield[y+2][x]){\n\t  ans[y][x] = 1, ans[y+1][x] = 1;\n\t}\n      }\n    }\n    \n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcout << ans[i][j];\n\tif(j != 9) cout << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <ctype.h>\n#include <string>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <fstream>\n#include <sstream>\n#include <queue>\n#include <exception>\n#include <cmath>\n#include <numeric>\n#include <map>\n#include <algorithm>\n#include <bitset>\n#include <set>\n#include <functional>\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n\nusing namespace std;\ntypedef long long int lint;\ntypedef vector<vector<int> > matrix;\n\nint dy[5] = { -1, 0, 0, 0, 1 };\nint dx[5] = { 0, -1, 0, 1, 0 };\n\nvoid print(matrix& mat) {\n\tREP(y, 10) {\n\t\tREP(x, 10) {\n\t\t\tif (x) cout << \" \";\n\t\t\tcout << mat[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n}\n\nmatrix mk_matrix(int n) {\n\tmatrix mat(n);\n\tREP(i, n) {\n\t\tmat[i] = vector<int>(10, 0);\n\t}\n\treturn mat;\n}\n\nvoid push(matrix& mat, int y, int x) {\n\tREP(i, 5) {\n\t\tint nx = x + dx[i];\n\t\tif (nx < 0 || nx >= 10) continue;\n\t\tint ny = y + dy[i];\n\t\tif (ny < 0 || ny >= 10) continue;\n\t\tmat[ny][nx] ^= 1;\n\t}\n}\n\nvoid solve(matrix& mat) {\n\t//?????????????????¨????????????????????????\n\tREP(i, 1024) {\n\t\tmatrix mat_tmp = mat;\n\t\tmatrix pushed = mk_matrix(10);\n\t\tint tmp = i;\n\t\tREP(j, 10) {\n\t\t\tif (!tmp) break;\n\t\t\tif (tmp & 1) {\n\t\t\t\tpush(mat_tmp, 0, j);\n\t\t\t\tpushed[0][j] = 1;\n\t\t\t\t//print(mat_tmp);\n\t\t\t}\n\t\t\ttmp >>= 1;\n\t\t}\n\n\t\tFOR(y, 1, 10) {\n\t\t\tREP(x, 10) {\n\t\t\t\tif (mat_tmp[y - 1][x]) {\n\t\t\t\t\tpush(mat_tmp, y, x);\n\t\t\t\t\tpushed[y][x] = 1;\n\t\t\t\t\t//print(mat_tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//cout << i << endl;\n\t\t//print(mat_tmp);\n\t\tif (find(mat_tmp[9].begin(), mat_tmp[9].end(), 1) == mat_tmp[9].end()) {\n\t\t\tprint(pushed);\n\t\t\t//cout << \"solved.\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nbool AOJ0131()\n{\n\tmatrix mat = mk_matrix(10);\n\tREP(i, 10) {\n\t\tREP(j, 10) {\n\t\t\tcin >> mat[i][j];\n\t\t}\n\t}\n\n\tsolve(mat);\n\n\treturn true;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tREP(i, n) AOJ0131();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10]={};\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)if((ans[0][j]=(i>>j&1)))mark(mp,0,j);\n\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n      cout <<endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\n\nbool ans[10][10];\nint ban[10][10];\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    rep(i,10)rep(j,10)cin>>ban[i][j];\n\n    memset(ans,0,sizeof(ans));\n\n    rep(k,1024){\n      rep(i,10){\n        rep(j,10){\n          if(!i){\n            ans[i][j]=!!(1<<i&k);\n          }else{\n            int t=ans[i-1][j]+ban[i-1][j];\n            if(j<9)t+=ans[i-1][j+1];\n            if(j)t+=ans[i-1][j-1];\n            if(i>1)t+=ans[i-2][j];\n            ans[i][j]=t%2;\n          }\n        }\n      }\n      int odd=0;\n      rep(j,10)odd+=ans[9][j];\n      if(odd==0)break;\n    }\n    rep(i,10){\n      rep(j,10){\n        if(j)cout<<\" \";\n        cout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint n;\nint fie[13][13];\nint now[13][13];\nint res[13][13];\n\nvoid flip(int x,int y){\n\tfie[x][y]=1-fie[x][y];\n\tfie[x][y+1]=1-fie[x][y+1];\n\tfie[x][y-1]=1-fie[x][y-1];\n\tfie[x+1][y]=1-fie[x+1][y];\n\tfie[x-1][y]=1-fie[x-1][y];\n}\n\nvoid check(int x,int y){\n\tif(x==10 && y==10){\n\t\tint flag=0;\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)if(fie[j][i]==1)flag=1;\n\t\t}\n\t\tif(flag==0){\n\t\t\tfor(int i=1;i<=10;i++){\n\t\t\t\tfor(int j=1;j<=10;j++)res[j][i]=now[j][i];\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tif(y==1){\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\t\n\t\tflip(x,y);\n\t\tnow[x][y]=1;\n\t\tif(x<=9)check(x+1,y);\n\t\telse check(0,y+1);\n\t\tflip(x,y);\n\t}else{\n\t\tif(fie[x][y-1]==1){\n\t\t\tflip(x,y);\n\t\t\tnow[x][y]=1;\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t\tflip(x,y);\n\t\t}else{\n\t\t\tif(x<=9)check(x+1,y);\n\t\t\telse check(0,y+1);\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int kkk=0;kkk<n;kkk++){\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)scanf(\"%d\",&fie[j][i]);\n\t\t}\n\t\tmemset(now,0,sizeof(now));\n\t\tmemset(res,-1,sizeof(res));\n\t\tcheck(1,1);\n\t\tif(res[0][0]==-1)while(1);\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tfor(int j=1;j<=10;j++)printf(\"%d%c\",res[j][i],j==10?'\\n':' ');\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint t[10][10],u[10][10],ans[10][10],n,flg;\nint compute();\nvoid dfs(int);\nvoid change(int,int);\nint main(){\n  cin>>n;\n  while(n--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\nvoid dfs(int x){\n  if(x==10){\n    /*\n    for(int i=0;i<10;i++)cout<<ans[0][i];\n    cout<<endl;\n    */\n    \n    if(compute()){\n      for(int i=0;i<10;i++){\n\tfor(int j=0;j<10;j++){\n\t  if(j)cout<<' ';\n\t  cout<<ans[i][j];\n\t}\n\tcout<<endl;\n      }\n    }\n    \n    return;\n  }\n  ans[0][x]=0;\n  dfs(x+1);\n  ans[0][x]=1;\n  dfs(x+1);\n}\n\nint compute(){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      u[i][j]=t[i][j];\n      if(i)ans[i][j]=0;\n    }\n  }\n\n  for(int i=0;i<10;i++){\n    if(ans[0][i])change(0,i);\n  }\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(u[i-1][j]){\n\tans[i][j]=1;\n\tchange(i,j);\n      }\n    }\n  }\n  for(int i=0;i<10;i++){\n    if(u[9][i])return 0;\n  }\n  return 1;\n}\n\nvoid change(int y,int x){\n  u[y][x]=!u[y][x];\n  if(y>0)u[y-1][x]=!u[y-1][x];\n  if(x>0)u[y][x-1]=!u[y][x-1];\n  if(y<9)u[y+1][x]=!u[y+1][x];\n  if(x<9)u[y][x+1]=!u[y][x+1];\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint state[10][10];\nint ans[10][10];\n\ninline bool valid(int i, int j) {\n    return 0 <= i && i < 10 && 0 <= j && j < 10;\n}\n\nvoid solve() {\n    for (int bt=0; bt<(1<<10); ++bt) {\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                if ((i == 0 && (bt>>j) % 10 == 1) || (i != 0 && state[i][j] == 1)) {\n                    state[i][j] = 1 - state[i][j];\n                    if (valid(i+1, j-1)) state[i+1][j-1] = 1 - state[i+1][j-1];\n                    if (valid(i+1, j))   state[i+1][j]   = 1 - state[i+1][j];\n                    if (valid(i+1, j+1)) state[i+1][j+1] = 1 - state[i+1][j+1];\n                    if (valid(i+2, j))   state[i+2][j]   = 1 - state[i+2][j];\n                    ans[i][j] = 1;\n                }\n            }\n        }\n        bool ok = true;\n        for (int j=0; j<10; ++j) {\n            if (state[9][j] == 1) ok = false;\n        }\n        if (ok) return ;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n --) {\n        memset(state, 0, sizeof(state));\n        memset(ans, 0, sizeof(ans));\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cin >> state[i][j];\n            }\n        }\n        solve();\n        for (int i=0; i<10; ++i) {\n            for (int j=0; j<10; ++j) {\n                cout << (j == 0 ? \"\" : \" \") << ans[i][j];\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n\nconst int bans=10;\nbool tans[bans][bans];\nbool ans[bans][bans];\nint ban[bans][bans];\n\nmain(){\n  int n;\n  cin>>n;\n  while(n--){\n    rep(i,bans)rep(j,bans)cin>>ban[i][j];\n\n    int mina=bans*bans;\n    rep(k,1<<bans){\n      memset(ans,0,sizeof(ans));\n      int tmin=0;\n      rep(i,bans){\n        rep(j,bans){\n          int t=0;\n          if(!i){\n            ans[i][j]=!!(1<<i&k);\n          }else{\n            t=ans[i-1][j]+ban[i-1][j];\n            if(j<bans-1)t+=ans[i-1][j+1];\n            if(j)t+=ans[i-1][j-1];\n            if(i>1)t+=ans[i-2][j];\n            ans[i][j]=t%2;\n          }\n          tmin+=ans[i][j];\n        }\n      }\n      int odd=0;\n      rep(j,bans){\n        int t=ans[bans-1][j]+ban[bans-1][j]+ans[bans-2][j];\n        if(j<bans-1)t+=ans[bans-1][j+1];\n        if(j)t+=ans[bans-1][j-1];\n        odd+=t%2;\n      }\n      if(!odd && tmin<mina){\n        memcpy(tans,ans,sizeof(ans));\n        mina=tmin;\n      }\n    }\n    rep(i,bans){\n      rep(j,bans){\n        if(j)cout<<\" \";\n        cout<<tans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,s,d[12][12],b[12][12],a[12][12];\nint dx[] = { 0,0,0,1,-1};\nint dy[] = {-1,1,0,0, 0};\n\nvoid flip(int x, int y)\n{\n\ta[y][x] = 1;\n\tfor(int i=0; i<5; i++)\n\t{\n\t\tb[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n\t}\n}\n\nvoid func()\n{\n\tfor(int i=0; i<1024; i++)\n\t{\n\t\tmemset(a,0,sizeof(a));\n\t\tmemcpy(b,d,sizeof(d));\n\n\t\tfor(int y=1,x=1; x<=10; x++)\n\t\t{\n\t\t\tif((i>>(x-1))&1) flip(x,y);\n\t\t}\n\n\t\tfor(int y=2; y<=10; y++)\n\t\tfor(int x=1; x<=10; x++)\n\t\t{\n\t\t\tif(b[y-1][x]) flip(x,y);\n\t\t}\n\n\t\ts=0;\n\t\tfor(int y=10,x=1; x<=10; x++)\n\t\t{\n\t\t\ts+=b[y][x];\n\t\t}\n\n\t\tif(s==0) return;\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\twhile(n--)\n\t{\n\t\tfor(int y=1; y<=10; y++)\n\t\tfor(int x=1; x<=10; x++)\n\t\t{\n\t\t\tcin >> d[y][x];\n\t\t}\n\n\t\tfunc();\n\n\t\tfor(int y=1; y<=10; y++)\n\t\t{\n\t\t\tfor(int x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tcout << a[y][x] << (x==10?\"\":\" \");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint a[10][10], b[10][10], c[10][10];\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(i, n) {\n\t\trep(i, 10)rep(j, 10)scanf(\"%d\", &a[i][j]);\n\t\trep(i, 1 << 10) {\n\t\t\trep(j, 10)rep(k, 10)b[j][k] = a[j][k];\n\t\t\tmemset(c, 0, sizeof(c));\n\t\t\trep(j, 10)rep(k, 10) {\n\t\t\t\tif (!j) {\n\t\t\t\t\tif (i >> k & 1)continue;\n\t\t\t\t}\n\t\t\t\telse if (!b[j - 1][k])continue;\n\t\t\t\tc[j][k] = 1; b[j][k] = !b[j][k];\n\t\t\t\trep(t, 4) {\n\t\t\t\t\tint nx = j + dx[t], ny = k + dy[t];\n\t\t\t\t\tif (0 <= nx&&nx < 10 && 0 <= ny&&ny < 10)b[nx][ny] = !b[nx][ny];\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, 10)rep(k, 10) {\n\t\t\t\tif (b[j][k])goto g;\n\t\t\t}\n\t\t\trep(j, 10) {\n\t\t\t\trep(k, 10) {\n\t\t\t\t\tif (k)printf(\" \");\n\t\t\t\t\tprintf(\"%d\", c[j][k]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}g:;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool grid[10][10];\n\nvoid rev(int y,int x){\n  int dy[] = {1,0,-1,0,0}, dx[] = {0,1,0,-1,0};\n\n  for(int i=0;i<5;i++){\n    int sy = y+dy[i], sx = x+dx[i];\n    if(sy<0 || sx<0 || sy>10 || sx>10)continue;\n    grid[sy][sx] = !grid[sy][sx];\n  }\n}\n\nint main(){\n  int t;\n  bool tmp[10][10];\n  bool ans[10][10];\n\n  cin >> t;\n  while(t--){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin >> grid[i][j];\n\ttmp[i][j] = grid[i][j];\n      }\n    }\n\n    for(int i=0;i<(1<<10);i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++)grid[i][j] = tmp[i][j];\n      }\n\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  rev(0,j);\n\t  ans[0][j] = true;\n\t}else ans[0][j] = false;\n      }\n\n      for(int j=1;j<10;j++){\n\tfor(int k=0;k<10;k++){\n\t  if(grid[j-1][k]){\n\t    rev(j,k);\n\t    ans[j][k] = true;\n\t  }else ans[j][k] = false;\n\t}\n      }\n\n      bool f = false;\n      for(int j=0;j<10;j++)f |= grid[9][j];\n      if(!f)break;\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<9;j++)cout << ans[i][j] << \" \";\n      cout << ans[i][9] << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nconst int all = (1 << 10) - 1;\n\nint board[12][12];\nint mask[12];\n//int conv[(1<<10)+10];\nint save[12];\n\nint makeCurrMask(int curr, int m){\n    for(int i=0;i<10;i++){\n        if((m >> i) & 1){\n            int t = (i == 0) ? (7 >> 1) : (7 << (i - 1));\n            curr ^= t;\n        }\n    }\n    return curr & all;\n}\n\nint main(){\n\t/*\n\tfor(int line=0;line<1<<10;++line){\n\t\tint m = 0;\n\n\t\tfor(int i=0;i<10;++i){\n\t\t\tif((line >> i) & 1){\n\t\t\t\tm ^= 7 << i;\n\t\t\t}\n\t\t}\n\n\t\tconv[line] = (m >> 1) & all;\n\t}*/\n\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;++t){\n\t\tfor(int y=0;y<10;++y){\n\t\t\tint m = 0;\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tcin >> board[y][x];\n\t\t\t}\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tm = (m << 1) + board[y][x];\n\t\t\t}\n\t\t\tmask[y] = m;\n\t\t}\n\n\t\tfor(int line=0;line<1<<10;++line){\n\t\t\tint prev = makeCurrMask(mask[0], line);\n\t\t\tint curr = mask[1] ^ line;\n\n\t\t\tsave[0] = line;\n\n\t\t\tfor(int y=1;y<9;++y){\n\t\t\t\tint doit = prev;\n\t\t\t\tint nprev = makeCurrMask(curr, doit);\n\t\t\t\tint ncurr = mask[y+1] ^ doit;\n\n\t\t\t\tprev = nprev;\n\t\t\t\tcurr = ncurr;\n\n\t\t\t\tsave[y] = doit;\n\t\t\t}\n\n\t\t\tsave[9] = prev;\n\n\t\t\tif(curr ^ prev){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int y=0;y<10;++y){\n\t\t\t\tint m = save[y];\n\t\t\t\tfor(int x=9;x>=0;--x){\n\t\t\t\t\tif(x != 9)cout << \" \";\n\t\t\t\t\tcout << (((m >> x) & 1) ? 1 : 0);\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tcin>>n;\n\tfor(int i = 0; i < n; i++){\n\t\tchar field[10][10];\n\t\tfor(int j = 0; j < 10; j++)\n\t\t\tfor(int k = 0; k < 10; k++)\n\t\t\t\tcin>>field[j][k];\n\n\n\t\t// ツ催渉可づ可暗ェツ氾板湘」ツづ個づ青づつュツづィツつゥツつヲツつオツ陛サツづーツ個按津ィ\n\t\tfor(int s = 0; s < (1 << 10); s++){\n\t\t\tchar ret[10][10];\n\t\t\tchar sit[10][10];\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tsit[j][k]=field[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tif((s>>j)&1){\n\t\t\t\t\tret[0][j]='1';\n\t\t\t\t\tsit[0][j]=((sit[0][j]-'0')^1)+'0';\n\t\t\t\t\tif(j-1>=0){\n\t\t\t\t\t\tsit[0][j-1]=((sit[0][j-1]-'0')^1)+'0';\n\t\t\t\t\t}\n\t\t\t\t\tif(j+1<10){\n\t\t\t\t\t\tsit[0][j+1]=((sit[0][j+1]-'0')^1)+'0';\n\t\t\t\t\t}\n\t\t\t\t\tsit[1][j]=((sit[1][j]-'0')^1)+'0';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tret[0][j]='0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t// ツ湘」ツづ恵itツづーツ個ゥツづ、ツづ青づつュツづィツ陛板つキツつゥツづつ、ツつゥツづーツ考ツつヲツづゥ\n\t\t\tfor(int j = 1; j < 10; j++){\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\t// ツづ青づつュツづィツつゥツつヲツつキ\n\t\t\t\t\tif(sit[j-1][k]=='1'){\n\t\t\t\t\t\tret[j][k]='1';\n\t\t\t\t\t\tsit[j][k]=((sit[j][k]-'0')^1)+'0';\n\t\t\t\t\t\tif(j-1>=0){\n\t\t\t\t\t\t\tsit[j-1][k]=((sit[j-1][k]-'0')^1)+'0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(j+1<10){\n\t\t\t\t\t\t\tsit[j+1][k]=((sit[j+1][k]-'0')^1)+'0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k-1>=0){\n\t\t\t\t\t\t\tsit[j][k-1]=((sit[j][k-1]-'0')^1)+'0';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k+1<10){\n\t\t\t\t\t\t\tsit[j][k+1]=((sit[j][k+1]-'0')^1)+'0';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tret[j][k]='0';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool ff=false;\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tif(sit[j][k]=='1'){\n\t\t\t\t\t\tff=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ff)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!ff){\n\t\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\t\tcout<<ret[j][k];\n\t\t\t\t\t\tif(k==9)\n\t\t\t\t\t\t\tcout<<endl;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcout<<\" \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool grid[10][10];\n\nvoid rev(int y,int x){\n  int dy[] = {1,0,-1,0,0}, dx[] = {0,1,0,-1,0};\n\n  for(int i=0;i<5;i++){\n    int sy = y+dy[i], sx = x+dx[i];\n    if(sy<0 || sx<0 || sy>=10 || sx>=10)continue;\n    grid[sy][sx] = !grid[sy][sx];\n  }\n}\n\nint main(){\n  int t;\n  bool tmp[10][10];\n  int ans[10][10];\n\n  cin >> t;\n  while(t--){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin >> grid[i][j];\n\ttmp[i][j] = grid[i][j];\n      }\n    }\n    \n    for(int i=0;i<(1<<10);i++){\n      for(int j=0;j<10;j++){\n\tfor(int k=0;k<10;k++)grid[j][k] = tmp[j][k];\n      }\n\n      for(int j=0;j<10;j++){\n\tif(i&(1<<j)){\n\t  rev(0,j);\n\t  ans[0][j] = 1;\n\t}else ans[0][j] = 0;\n      }\n\n      for(int j=1;j<10;j++){\n\tfor(int k=0;k<10;k++){\n\t  if(grid[j-1][k]){\n\t    rev(j,k);\n\t    ans[j][k] = 1;\n\t  }else ans[j][k] = 0;\n\t}\n      }\n\n      bool f = false;\n      for(int j=0;j<10;j++)f |= grid[9][j];\n      if(!f)break;\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<9;j++)cout << ans[i][j] << \" \";\n      cout << ans[i][9] << endl;\n    }\n    if(t)cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i) for(int j = 0; j < MAX; ++j) m[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]]               == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) &&\n\n\t\t\t\t\t\t\tM.m[i+di[(k+5)%sz]][j+dj[(k+5)%sz]] == 1 && inRange(i+di[(k+5)%sz]) && inRange(j+dj[(k+5)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+7)%sz]][j+dj[(k+7)%sz]] == 1 && inRange(i+di[(k+7)%sz]) && inRange(j+dj[(k+7)%sz])\n\t\t\t\t\t\t\t){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz]) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Doctor's Strange Particles\n//Level: 2\n//Category: 全探索\n//Note: \n\n/**\n * 一番上の行に対する照射方法を固定すると、それより下の行が全て一意に決まる。\n * したがって、一番上の行だけを全探索してシミュレーションすればよい。\n *\n * オーダーは O(2^W HW)。\n */\n#include <iostream>\n#include <array>\n\nusing namespace std;\n\narray<int,1<<10> eff;\n\nbool solve(bool first) {\n    array<int,10> f;\n    for(int r = 0; r < 10; ++r) {\n        f[r] = 0;\n        for(int c = 0; c < 10; ++c) {\n            int v;\n            cin >> v;\n            f[r] |= (v << c);\n        }\n    }\n\n    array<int,10> ans;\n    for(int pat = 0; pat < (1<<10); ++pat) {\n        int prev = f[0] ^ eff[pat];\n        int pmask = pat;\n        ans[0] = pat;\n        for(int r = 1; r < 10; ++r) {\n            ans[r] = prev;\n            const int tmp = f[r] ^ eff[prev] ^ pmask;\n            pmask = prev;\n            prev = tmp;\n        }\n        if(prev == 0) break;\n    }\n    for(int r = 0; r < 10; ++r) {\n        for(int c = 0; c < 10; ++c) {\n            if(c > 0) cout << ' ';\n            cout << !!(ans[r] & (1<<c));\n        }\n        cout << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    for(int pat = 0; pat < (1<<10); ++pat) {\n        eff[pat] = pat;\n        for(int c = 0; c < 10; ++c) {\n            if(pat & (1<<c)) {\n                if(c > 0) eff[pat] ^= (1<<(c-1));\n                if(c < 9) eff[pat] ^= (1<<(c+1));\n            }\n        }\n    }\n\n    bool first = true;\n    int N;\n    cin >> N;\n    while(N-- && solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nint dx[]={-1,0,0,1};\nint dy[]={0,0,-1,0};\nint main()\n{\n    int n;\n\tcin>>n;\n\tbool fir=true;\n\twhile(n--){\n\t\t//if(!fir)cout<<endl;\n\t\tint panel[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tint tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tpanel[i]|=tmp<<j;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<10);i++){//1??????ans?????????\n\t\t\tint ans[10]={};\n\t\t\tans[0]=i;\n\t\t\tfor(int j=0;j<9;j++){//????????????ans????¨????\n\t\t\t\tfor(int k=0;k<10;k++){//?????????????????°???\n\t\t\t\t\tint tmp=0;\n\t\t\t\t\tfor(int l=0;l<4;l++){\n\t\t\t\t\t\tint nx=k+dx[l],ny=j+dy[l];\n\t\t\t\t\t\tif(0<=nx&&nx<10&&0<=ny&&ny<9)tmp+=(ans[ny]>>nx)&1;\n\t\t\t\t\t}\n\t\t\t\t\tif((tmp+2-(panel[j]>>k)&1)%2)ans[j+1]|=1<<k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint check[10];\n\t\t\tfor(int j=0;j<10;j++)check[j]=(panel[9]>>j)&1;\n\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\tcheck[j]+=(ans[8]>>j)&1;\n\t\t\t\tif((ans[9]>>j)&1){\n\t\t\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\t\t\tint x=j+k;\n\t\t\t\t\t\tif(0<=x&&x<10)check[x]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<10;j++)check[j]=check[j]%2;\n\t\t\tif(check[9]==0){\n\t\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tint tmp=(ans[y]>>x)&1;\n\t\t\t\t\t\tprintf(x==9?\"%d\\n\":\"%d \",tmp);\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfir=false;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint mask[12];\nint conv[(1<<10)+10];\nint save[12];\n\nint main(){\n\tfor(int line=0;line<1<<10;++line){\n\t\tint m = 0;\n\n\t\tif((line >> 0) & 1)m ^= 3;\n\t\tif((line >> 9) & 1)m ^= 3 << 8;\n\n\t\tfor(int i=1;i<9;++i){\n\t\t\tif((line >> i) & 1){\n\t\t\t\tm ^= 7 << (i - 1);\n\t\t\t}\n\t\t}\n\n\t\tconv[line] = m;\n\t}\n\n\tint n;\n\tscanf(\"%d\", &n);\n\n\twhile(n--){\n\t\tfor(int y=0;y<10;++y){\n\t\t\tint m = 0, f;\n\t\t\tfor(int x=0;x<10;++x){\n\t\t\t\tscanf(\"%d\", &f);\n\t\t\t\tm = (m << 1) + f;\n\t\t\t}\n\t\t\tmask[y] = m;\n\t\t}\n\n\t\tfor(int line=0;line<1<<10;++line){\n\t\t\tint prev = mask[0] ^ conv[line];\n\t\t\tint curr = mask[1] ^ line;\n\n\t\t\tsave[0] = line;\n\n\t\t\tfor(int y=1;y<9;++y){\n\t\t\t\tint doit = prev;\n\t\t\t\tint nprev = curr ^ conv[doit];\n\t\t\t\tint ncurr = mask[y+1] ^ doit;\n\n\t\t\t\tprev = nprev;\n\t\t\t\tcurr = ncurr;\n\n\t\t\t\tsave[y] = doit;\n\t\t\t}\n\n\t\t\tsave[9] = prev;\n\n\t\t\tif(curr ^ prev){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor(int y=0;y<10;++y){\n\t\t\t\tint m = save[y];\n\t\t\t\tfor(int x=9;x>=0;--x){\n\t\t\t\t\tif(x != 9)printf(\"%c\", ' ');\n\t\t\t\t\tprintf(\"%d\", (m >> x) & 1);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nstruct UF {\n    vi e;\n    UF(int n) : e(n, -1) {}\n    bool same_set(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\n    void join(int a, int b) {\n        a = find(a), b = find(b);\n        if(a == b) return;\n        if(e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n    }\n};\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    int cnt=0;\n    while(n--) {\n        if(cnt) cout << endl;\n        cnt++;\n        vector<vector<int>> v(10);\n\n        for(int i=0; i<10; ++i){\n            for(int j=0; j<10; ++j){\n                int a; cin >> a;\n                v[i].push_back(a);\n            }\n        }\n\n        bool f = false;\n        for(int bit=0; bit<(1<<10); ++bit){\n            int arr[15][15]={0};\n\n            int ans[10][10]={0};\n            for(int i=0; i<10; ++i){\n                if(bit >> i & 1){\n                    ans[0][i]=1;\n                    if(i==0){\n                        arr[0][0] ^= 1;\n                        arr[1][0] ^= 1;\n                        arr[0][1] ^= 1;\n                    }else if(i==9){\n                        arr[0][i] ^= 1;\n                        arr[1][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                    }else{\n                        arr[0][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                        arr[0][i+1] ^= 1;\n                        arr[1][i] ^= 1;\n                    }\n                }\n            }\n\n            for(int i=1; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if((arr[i-1][j] == 0 && v[i-1][j]==1) || (arr[i-1][j]==1 && v[i-1][j]==0)){\n                        ans[i][j]=1;\n                        if(j==0){\n                            arr[i][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }else if(j==9){\n                            arr[i][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                        }else{\n                            arr[i][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }\n                    }\n                }\n            }\n            bool d = true;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i][j]!=v[i][j]) d= false;\n                }\n            }\n            if(!d) continue;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(j) cout << \" \";\n                    cout << ans[i][j];\n                }\n                cout << endl;\n            }\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bitset>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a) (0<=(a)&&(a)<10)\nint dx[]={-1,0,1,0,0},dy[]={0,0,0,-1,1};\nvoid set(int *a,int b){\n\tbitset<10> c(b);\n\tstring t=c.to_string<char,char_traits<char>,allocator<char> >();\n\trep(i,10)a[i]=t[i]-'0';\n}\nvoid change(int t[10][10],int *a,int l){\n\trep(i,10){\n\t\trep(d,5){\n\t\t\tif(!ck(l+dy[d])||!ck(i+dx[d]))continue;\n\t\t\tt[l+dy[d]][i+dx[d]]^=a[i];\n\t\t}\n\t}\n}\nint main(){\n\tint n; cin>>n;\n\twhile(n--){\n\t\tint state[10][10]={0},axion[10][10],temp[10][10];\n\t\trep(i,10)rep(j,10)cin>>state[i][j];\n\t\trep(d,1<<10){\n\t\t\trep(i,10)rep(j,10)temp[i][j]=state[i][j];\n\t\t\tset(axion[0],d);\n\t\t\trep(i,10){\n\t\t\t\tchange(temp,axion[i],i);\n\t\t\t\tif(i<9)rep(j,10)axion[i+1][j]=temp[i][j];\n\t\t\t}\n\t\t\trep(i,10)rep(j,10)if(temp[i][j])goto NEXT;\n\t\t\trep(i,10){\n\t\t\t\trep(j,10)cout<<axion[i][j]<<(j<9?\" \":\"\");\n\t\t\t\tcout<<endl;\n\t\t\t}\n\t\t\tgoto END;\n\t\t\tNEXT:;\n\t\t}\n\t\tEND:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nint main(){\n  int n;\n  cin>>n;\n  while(n--){\n    int mp[12][12],ans[12][12];\n    for(int i=1;i<=10;i++)for(int j=1;j<=10;j++) cin>>mp[i][j];\n    int cp[12][12];\n \n    for(int i=0;i<(1<<10);i++){\n       \n      for(int j=1;j<=10;j++)\n    for(int k=1;k<=10;k++)cp[j][k]=mp[j][k],ans[j][k]=0;\n      for(int j=0;j<10;j++){\n    if(i&(1<<j)){\n      cp[1][j+1]=!cp[1][j+1];\n      cp[1][j]=!cp[1][j];\n      cp[1][j+2]=!cp[1][j+2];\n      cp[2][j+1]=!cp[2][j+1];\n      ans[1][j+1]=1;\n    }\n      }\n      for(int j=2;j<=10;j++){\n    for(int k=1;k<=10;k++){\n      if(cp[j-1][k]){\n        cp[j-1][k]=!cp[j-1][k];\n        cp[j][k]=!cp[j][k];\n        cp[j][k-1]=!cp[j][k-1];\n        cp[j][k+1]=!cp[j][k+1];\n        cp[j+1][k]=!cp[j+1][k];\n        ans[j][k]=1;\n      }\n    }\n      }\n      int f=0;\n      for(int j=1;j<=10;j++)\n    for(int k=1;k<=10;k++)\n      if(cp[j][k])f=1;\n      if(!f)break;\n    }\n \n    for(int i=1;i<=10;i++){\n      for(int j=1;j<=10;j++){\n    if(j!=1)cout<<' ';\n    cout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nint LC[10][10];\nint L[10][10]; \nint F[10][10]; \n\nvoid init() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            L[i][j] = LC[i][j];\n            F[i][j] = 0;\n        }\n    }\n}\n\nvoid input() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cin >> LC[i][j];\n        }\n    }\n}\n\nvoid output() {\n    for ( int i = 0; i < 10; ++ i ) {\n        for ( int j = 0; j < 10; ++ j ) {\n            cout << F[i][j];\n            if ( j + 1 < 10 ) cout << \" \";\n        }\n        cout << endl;\n    }\n}\n\nvoid flip( int r, int c ) {\n    L[r][c] = !L[r][c];\n    if ( r - 1 >= 0 ) L[r-1][c] = !L[r-1][c];\n    if ( r + 1 < 10 ) L[r+1][c] = !L[r+1][c];\n    if ( c - 1 >= 0 ) L[r][c-1] = !L[r][c-1];\n    if ( c + 1 < 10 ) L[r][c+1] = !L[r][c+1];\n}\n\nbool solve( int r ) {\n    if ( r >= 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                if ( L[i][j] ) return false;\n            }\n        }\n        return true;\n    }\n    if ( r == 0 ) {\n        init();\n        for ( int i = 0; i < (1<<10); ++ i ) {\n            for ( int j = 0; j < 10; ++ j ) {\n                if ( i & ( 1 << j ) ) F[r][j] = 1;\n                if ( i & ( 1 << j ) ) flip( r, j );\n            }\n            if ( solve( r + 1 ) ) return true;\n        }\n    } else if ( r < 10 ) {\n        for ( int i = 0; i < 10; ++ i ) {\n            if ( L[r-1][i] ) {\n                F[r][i] = 1;\n                flip( r, i );\n            }\n        }\n        if ( solve( r + 1 ) ) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    while ( cin >> n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            input();\n            solve( 0 );\n            output();\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint dy[] = {-1, 0, 0, 1};\nint dx[] = {0, -1, 1, 0};\n\nvoid solve() {\n  int a[10][10];\n  for (int i = 0; i < 10; i++) {\n    for (int j = 0; j < 10; j++) {\n      cin >> a[i][j];\n    }\n  }\n  int tmp[10][10];\n  for (int i = 0; i < 1 << 10; i++) {\n    memset(tmp, 0, sizeof(tmp));\n    for (int j = 0; j < 10; j++) {\n      if (i >> j & 1) tmp[0][j] = 1;\n    }\n    for (int j = 0; j + 1 < 10; j++) {\n      for (int k = 0; k < 10; k++) {\n        int sum = tmp[j][k];\n        for (int l = 0; l < 4; l++) {\n          int ny = j + dy[l], nx = k + dx[l];\n          if (ny >= 0 && ny < 10 && nx >= 0 && nx < 10) sum += tmp[ny][nx];\n        }\n        if ((sum + a[j][k]) % 2 == 0) continue;\n        tmp[j + 1][k] = 1;\n      }\n    }\n    int tmp2[10][10];\n    for (int j = 0; j < 10; j++) {\n      for (int k = 0; k < 10; k++) {\n        tmp2[j][k] = tmp[j][k];\n        for (int l = 0; l < 4; l++) {\n          int ny = j + dy[l], nx = k + dx[l];\n          if (ny >= 0 && ny < 10 && nx >= 0 && nx < 10) (tmp2[j][k] += tmp[ny][nx]) %= 2;\n        }\n      }\n    }\n    bool ng = false;\n    for (int j = 0; j < 10; j++) {\n      for (int k = 0; k < 10; k++) {\n        ng |= tmp2[j][k] != a[j][k];\n      }\n    }\n    if (ng) continue;\n    for (int j = 0; j < 10; j++) {\n      for (int k = 0; k < 10; k++) {\n        cout << tmp[j][k] << \" \\n\"[k + 1 == 10];\n      }\n    }\n    return;\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        for(int roop=0; roop<n; roop++){\n            bool box[12][12]={0};\n            \n            for(int i=1; i<=10; i++){\n                for(int j=1; j<=10; j++){\n                    cin>>box[i][j];\n                }\n            }\n            //cout<<\"----------------------\"<<endl;\n            \n            bool box2[12][12]={0};\n            \n            for(int i=0; i<(1<<11 - 1); i++){\n                memcpy(box2, box, sizeof(box));\n                int l[12][12]={0};\n                for(int j=0; j<10; j++){\n                    l[0][j]= (i>>j)%2;\n                    //cout<<l[0][j];\n                }\n                //cout<<endl;\n                \n                for(int j=1; j<=10; j++){\n                    for(int k=1; k<=10; k++){\n                        if(l[j-1][k]==1){\n                            box2[j][k]=(box2[j][k]+1)%2;\n                            box2[j][k+1]=(box2[j][k+1]+1)%2;\n                            box2[j][k-1]=(box2[j][k-1]+1)%2;\n                            box2[j-1][k]=(box2[j-1][k]+1)%2;\n                            box2[j+1][k]=(box2[j+1][k]+1)%2;\n                        }\n                    }\n                    \n                    for(int k=1; k<=10; k++){\n                        l[j][k]=box2[j][k];\n                    }\n                }\n                \n                bool end_flag=true;\n                for(int i=1; i<=10; i++){\n                    if(l[10][i]==1){\n                        end_flag=false;\n                        break;\n                    }\n                }\n                \n                \n                if(end_flag){\n                    for(int i=0; i<=9; i++){\n                        for(int j=1; j<=10; j++){\n                            cout<<l[i][j];\n                            if(j==10)break;\n                            cout<<\" \";\n                        }\n                        cout<<endl;\n                    }\n                    break;\n                    \n                }\n            }\n            //cout<<\"============================\"<<endl;\n            \n            \n\n        }\n                \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {-1,1,0,0};\nconst int dy[] = {0,0,-1,1};\n\nint ori[10][10];\nint arr[10][10];\nint arr2[10][10];\n    \nvoid flip(int i, int j) {\n  arr[i][j] = 1 - arr[i][j];\n  arr2[i][j] = 1 - arr2[i][j];\n  for(int k=0; k<4; k++) {\n    int nx = j+dx[k], ny = i+dy[k];\n    if(0<=ny && ny<10 && 0<=nx && nx<10) {\n      arr[ny][nx] = 1 - arr[ny][nx];\n    }\n  }\n}\n\nint main() {\n  int Tc; cin >> Tc;\n  \n  while(Tc--) {\n    \n    for(int i=0; i<10; i++)\n      for(int j=0; j<10; j++)\n\tcin >> ori[i][j];\n    \n    bool good = 0;\n    for(int I=0; I<(1<<10); I++) {\n      memset(arr2, 0, sizeof(arr2));\n      memcpy(arr, ori, sizeof(ori));\n      bool ok = 1;\n      for(int i=0; i<10; i++) {\n\tfor(int j=0; j<10; j++) {\n\t  \n\t  if(i == 0) {\n\t    if((I>>j) & 1) {\n\t      if(arr[0][j] == 0) flip(0, j);\n\t    }\n            else {\n\t      if(arr[0][j] == 1) flip(0, j);\n            }\n          }\n\t  else {\n\t    if(arr[i-1][j] == 1) flip(i, j);\n\t  }\n\t  \n\t} \n      }\n      \n      for(int i=0; i<10; i++) {\n\tif(arr[9][i]) ok = 0;\n      }\n      if(ok) {\n\tgood = 1;\n\tbreak;\n      }\n    }\n    if(good) {\n      for(int i=0; i<10; i++) {\n\tfor(int j=0; j<10; j++) {\n\t  if(j) cout << \" \";\n\t  cout << arr2[i][j];\n\t}\n\tcout << endl;\n      }\n    }\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10]={};\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)if((ans[0][j]=(i&(1<<j))))mark(mp,0,j);\n\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n    cout <<endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nvvi out(10,vi(10)),in(10,vi(10)),tmp(10,vi(10));\nvi top(10);\nint dx[]={-1,0,0,0,1};\nint dy[]={0,-1,0,1,0};\nbool solve2(){\n\trep(i,10)rep(j,10)out[i][j]=0;\n\ttmp=in;\n\trep(i,10)if(top[i]){\n\t\tout[0][i]=1;\n\t\trep(j,5){\n\t\t\tint nx=dx[j];\n\t\t\tint ny=i+dy[j];\n\t\t\tif(nx>=0&&nx<10&&ny>=0&&ny<10)tmp[nx][ny]=!tmp[nx][ny];\n\t\t}\n\t}\n\tloop(i,1,10)rep(j,10)if(tmp[i-1][j]){\n\t\tout[i][j]=1;\n\t\trep(k,5){\n\t\t\tint nx=i+dx[k];\n\t\t\tint ny=j+dy[k];\n\t\t\tif(nx>=0&&nx<10&&ny>=0&&ny<10)tmp[nx][ny]=!tmp[nx][ny];\n\t\t}\n\t}\n\tbool h=true;\n\trep(i,10)rep(j,10)if(tmp[i][j])h=false;\n\treturn h;\n}\nbool solve(int a){\n\tif(a==10)if(solve2())return true;\n\telse return false;\n\t\n\ttop[a]=1;\n\tif(solve(a+1))return true;\n\ttop[a]=0;\n\tif(solve(a+1))return true;\n\treturn false;\n}\nint main(){\n\tint n;\n\tcin>>n;\n\twhile(n--){\n\t\trep(i,10)top[i]=0;\n\t\trep(i,10)rep(j,10)cin>>in[i][j];\n\t\tsolve(0);\n\t\trep(i,10){\n\t\t\trep(j,9)cout<<out[i][j]<<\" \";\n\t\t\tcout<<out[i][9]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nenum{W=10,H=10};\n\nbool clear(bool field[H][W]){\n  bool ok=true;\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)if(field[i][j])ok=false;\n  return ok;\n}\n\nint main(){\n  int n;\n  bool field[H][W];\n  bool dup[H][W];\n  int bit[H];\n  cin>>n;\n  int t=0;\n  while(n-->0){\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>field[i][j];\n\n    for(bit[0]=0; bit[0] < (1<<10); bit[0]++){\n      for(int i=1;i<H;i++)bit[i]=0;\n      for(int i=0;i<H;i++)for(int j=0;j<W;j++)dup[i][j]=field[i][j];\n\n      for(int j=0;j<W;j++){\n        if(!((bit[0]>>j)&1))continue;\n        dup[0][j]^=1;\n        dup[1][j]^=1;\n        if(j>0)dup[0][j-1]^=1;\n        if(j<W-1)dup[0][j+1]^=1;\n      }\n\n      for(int i=1;i<H;i++){\n        for(int j=0;j<W;j++){\n          if(dup[i-1][j]){\n            bit[i]^=(1<<j);\n            dup[i][j]^=1;\n            dup[i-1][j]^=1;\n            if(i<H-1)dup[i+1][j]^=1;\n            if(j>0)dup[i][j-1]^=1;\n            if(j<W-1)dup[i][j+1]^=1;\n          }\n        }\n      }\n      if(clear(dup))break;\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n        if(j!=0)cout<<\" \";\n        if(bit[i]&(1<<j))cout<<\"1\";\n        else cout<<\"0\";\n      }\n      cout<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool field[11][11], ans[11][11];\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcin >> field[i][j];\n      }\n    }\n    \n    memset(ans, 0, sizeof(ans));\n    \n    for(int y = 0 ; y < 10 ; y++){\n      for(int x = 0 ; x < 10 ; x++){\n\tif(y == 0 && x == 0){\n\t  if(field[0][0] && field[0][1] && field[1][0]) ans[0][0] = 1;\n\t}\n\telse if(y == 0 && x == 9){\n\t  if(field[0][9] && field[0][8] && field[1][9]) ans[0][9] = 1;\n\t}\n\telse if(y == 9 && x == 0){\n\t  if(field[9][0] && field[8][0] && field[9][1]) ans[9][0] = 1;\n\t}\n\telse if(y == 9 && x == 9){\n\t  if(field[9][9] && field[9][8] && field[8][9]) ans[9][9] = 1;\n\t}\n\telse if(y == 0){\n\t  if(field[0][x] && field[0][x+1] && field[1][x] && field[0][x-1]) ans[0][x] = 1;\n\t}\n\telse if(x == 0){\n\t  if(field[y][0] && field[y+1][0] && field[y][1] && field[y-1][0]) ans[y][0] = 1;\n\t}\n\telse if(y == 9){\n\t  if(field[9][x] && field[9][x+1] && field[8][x] && field[9][x-1]) ans[9][x] = 1;\n\t}\n\telse if(x == 9){\n\t  if(field[y][9] && field[y+1][9] && field[y][8] && field[y-1][9]) ans[y][0] = 1;\n\t}\n\telse if(field[y][x] && field[y-1][x] && field[y+1][x] && field[y][x-1] && field[y][x+1]){\n\t  ans[y][x] = 1;\n\t}\n\telse if(!field[y][x] && !field[y][x+1] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y+1][x] && field[y+1][x+1] && field[y-1][x+1] &&\n\t\tfield[y][x+2]){\n\t  ans[y][x] = 1, ans[y][x+1] = 1;\n\t}\n\telse if(!field[y][x] && !field[y+1][x] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y][x+1] && field[y+1][x-1] && field[y+1][x+1] &&\n\t\tfield[y+2][x]){\n\t  ans[y][x] = 1, ans[y+1][x] = 1;\n\t}\n      }\n    }\n    \n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcout << ans[i][j];\n\tif(j != 9) cout << ' ';\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define INV (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tint from;\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfrom = 0;\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset(){\n\t\tfrom = 0;\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tbool PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\t\t/*if( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;*/\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i){\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\t\t}\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\t/*++n;\n\t\tif( n % 100 == 0 ){\n\t\t\tcout << \"*\";\n\t\t}*/\n\t\tCMap M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\t//M.Print();cout <<endl;\n\t\t\n\t\tbool bCont = true;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tconst int di[] = {0,-1,1,0,0};\n\t\t\t\tconst int dj[] = {0,0,0,1,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\tint cnt0 = 0;\n\t\t\t\t\tint cnt1 = 0;\n\t\t\t\t\tfor(int l = 0; l < sizeof(di)/sizeof(*di); ++l){\n\t\t\t\t\t\tint ti = i + di[k] + di[l];\n\t\t\t\t\t\tint tj = j + dj[k] + dj[l];\n\t\t\t\t\t\tif( inRange( ti,1,MAX-1 ) && inRange( tj,1,MAX-1 ) )\n\t\t\t\t\t\t\tif( M.m[ ti ][ tj ] == 1 )\n\t\t\t\t\t\t\t\t++cnt1;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t++cnt0;\n\t\t\t\t\t}\n\t\t\t\t\tif( cnt1 > cnt0 ){\n\t\t\t\t\t\tCMap add = M;\n\t\t\t\t\t\tif( add.PassParticle( i+di[k], j+dj[k] ) ){\n\t\t\t\t\t\t\tq.push( add );\n\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"\\nTOTAL: \" << n << ( bFailed ? \"\\nFAILED.\\n\" : \"\\nCOMPLETED.\\n\" );\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tAnswer.Reset();\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n\n#define MAX 12\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset(){\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid PassParticle(int i, int j)\n\t{\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k], 1, MAX - 1 ) && inRange( j + dj[k], 1, MAX - 1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n\n\tbool NoLight() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\t\n\tbool operator==(const CMap &t) const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1; ++j)\n\t\t\t\tif( t.m[i][j] != m[i][j] )\n\t\t\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\nvoid BFS(CMap &stm, CMap &ret){\n\tvector< CMap > q;\n\n\tq.push_back( stm );\n\n\twhile( !q.empty() ){\n\t\tCMap M = q[0];\n\t\tq.erase( q.begin() );\n\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tCMap add;\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 >= 3 )\n\t\t\t\t{\n\t\t\t\t\tadd = M;\n\t\t\t\t\tadd.PassParticle( i, j );\n\t\t\t\t\tif( q.end() == find( q.begin(), q.end(), add ) )\n\t\t\t\t\t\tq.push_back( add );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nvoid DetermineShootingPoints(CMap &stm, CMap &ans){\n\twhile( !stm.NoLight() ){\n\t\tint max1 = 0;\n\t\tint pi, pj;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tint cnt1 = 0;\n\t\t\t\tconst int di[] = {0,-1,0,1,0/*-1,-1,0,1, 1, 1, 0,-1*/};\n\t\t\t\tconst int dj[] = {0,0,1,0,-1/* 0, 1,1,1,-0,-1,-1,-1*/};\n\n\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\t\tif( stm.m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\t\t++cnt1;\n\n\t\t\t\tif( cnt1 == 5 ){\n\t\t\t\t\tstm.PassParticle( i, j );\n\t\t\t\t\tans.m[i][j] = 1;\n\t\t\t\t\tgoto RETRY;\n\t\t\t\t}\n\n\t\t\t\tif( cnt1 > max1 ){\n\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\tpi = i;\n\t\t\t\t\tpj = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstm.PassParticle( pi, pj );\n\t\tans.m[pi][pj] = 1;\nRETRY:;\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\t//Answer.Reset();\n\t\tDetermineShootingPoints( M, Answer );\n\t\tAnswer.Print();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10];\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)ans[0][j]=(i&(1<<j)),mark(mp,0,j);\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n    cout <<endl;\n    }\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<bitset>\nusing namespace std;\n\n#define N 10\n\nclass CMap{\npublic:\n\tint m[N+2][N+2];\n\tint ans[N+2][N+2];\n\n\tCMap(){ Reset(); }\n\t\n\tvoid Reset(){\n\t\tfor(int i = 0; i < N+2; ++i){\n\t\t\tfor(int j = 0; j < N+2; ++j){\n\t\t\t\tm[i][j] = 0;\n\t\t\t\tans[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool inline static inRange(int t){\n\t\treturn ( 1 <= t && t < N + 1 );\n\t}\n\n\tbool PassParticle(int i, int j, bool bConsiderEfficiency = false)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( bConsiderEfficiency ){\n\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 ) cnt1++; else cnt0++;\n\t\t}\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tans[ i ][ j ] = 1;\n\t\treturn true;\n\t}\n\tbool NoLight(int range = N + 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid PrintAnswer() const{\n\t\tfor(int i = 1; i < N+1; ++i){\n\t\t\tcout << ans[i][1];\n\t\t\tfor(int j = 2; j < N+1; ++j)\n\t\t\t\tcout << ' ' << ans[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nbool DetermineShootingPoints(CMap &M){\n\tfor(unsigned int i = 2; i < N+1; ++i){\n\t\tfor(unsigned int j = 1; j < N+1; ++j){\n\t\t\tif( M.m[i-1][j] == 1 ){\n\t\t\t\tM.PassParticle( i, j );\n\t\t\t}\n\t\t}\n\t}\n\tif( M.NoLight() )\n\t\treturn true;\n\telse\n\t\treturn false;\n}\n\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tbool bCont = true;\n\t\tCMap M;\n\t\tbitset<N> B;\n\n\t\tfor(int i = 1; i < N+1; ++i)\n\t\t\tfor(int j = 1; j < N+1; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tfor(unsigned long L = 0; L < (unsigned long)pow(2.0,(double)N) && bCont; ++L){\n\t\t\tB = L;\n\t\t\tfor(unsigned int bits = 0; bits < B.size() && bCont; ++bits){\n\t\t\t\tif( B[bits] == true )\n\t\t\t\t\tif( !M.PassParticle(1,N-bits,true) )\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif( DetermineShootingPoints( M ) ){\n\t\t\t\t\tbCont = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\t\n\t\t}\n\t\tcout << \" ----------------------- \\n\";\n\t\tM.PrintAnswer();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nint a[10][10],b[10][10],ans[10][10],dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\nvoid init(void){\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      b[i][j]=a[i][j];\n      ans[i][j]=0;\n    }\n  }\n}\n\nvoid rev(int x, int y){\n  for(int k=0;k<5;k++)\n    if( 0<=y+dy[k] && 0<=x+dx[k] && y+dy[k]<10 && x+dx[k]<10)\n      b[y+dy[k]][x+dx[k]]=b[y+dy[k]][x+dx[k]]?0:1;\n}\n\nint ok(void){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      if(b[i][j])return 0;\n  return 1;\n}\n\nvoid solve(int p[]){\n  init();\n\n  for(int i=0;i<10;i++)\n    if(p[i])rev(i,0);\n\n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(b[i-1][j]){\n\trev(j,i);\n\tans[i][j]=1;\n      }\n    }\n  }\n\n  if(ok()){\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcout << ans[i][j];\n\tif(j<9)cout << \" \";\n      }\n      cout << endl;\n    }\n  }\n}\n\nvoid func(int p[], int cnt){\n  if(9<cnt)solve(p);\n  else {\n    p[cnt]=0;\n    func(p,cnt+1);\n    p[cnt]=1;\n    func(p,cnt+1);\n  }\n}\n\nint main(void){\n  int n;\n\n  cin >> n;\n\n  while(n--){\n\n    for(int i=0;i<10;i++)\n      for(int j=0;j<10;j++)\n\tcin >> a[i][j];\n\n    int p[10]={0};\n    func(p,0);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t){\n\treturn (1 <= t && t < MAX-1);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap(){ Reset(); }\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i) && inRange(j)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k] ) && inRange( j+dj[k] ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k]) && inRange( j+dj[k]) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print()const{\n\t\tfor(unsigned int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tcout << m[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\t//cout << \"Entered EraseBlocks Function.\\n\";\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, cntCand = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz]) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz]) && inRange(j+dj[(k+2)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz]) && inRange(j+dj[(k+3)%sz]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz]) && inRange(j+dj[(k+4)%sz]) ){\n\t\t\t\t\t\t\t\tCMap Tmp = M;\n\t\t\t\t\t\t\t\tif( M.PassParticle( i+di[(k+6)%sz], j+dj[(k+6)%sz] ) ){\n\t\t\t\t\t\t\t\t\tcntCand++;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( cntCand == 1 ){\n\t\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( M );\n\t\t/*cout << \"Erase End.\\n\";\n\t\tcout << endl;\n\t\tM.Print();*/\n\t\tif( M.NoLight() ){\n\t\t\tret = M;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k]) && inRange(j+dj[k]) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz]) && inRange(j+dj[(k+1)%sz])){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint F[10][10];\nint T[10][10];\nint P[10];\n\nbool check() {\n    for (int i = 0; i < 10; i++)\n        for (int j = 0; j < 10; j++)\n            if (T[i][j]) return false;\n    return true;\n}\n\nbool solve(int c, int n) {\n    if (c == 10) return check();\n    for (int i = 0; i < 10; i++) {\n        if (n & (1<<i)) {\n            if (c-1 >= 0) T[c-1][i] = !T[c-1][i];\n            if (i-1 >= 0) T[c][i-1] = !T[c][i-1];\n            T[c][i]   = !T[c][i];\n            if (i+1 < 10) T[c][i+1] = !T[c][i+1];\n            if (c+1 < 10) T[c+1][i] = !T[c+1][i];\n        }\n    }\n    P[c] = n;\n    int next = 0;\n    for (int i = 0; i < 10; i++) {\n        if (T[c][i]) {\n            next |= (1<<i);\n        }\n    }\n    return solve(c+1, next);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        for (int i = 0; i < 10; i++) \n            for (int j = 0; j < 10; j++)\n                cin >> F[i][j];\n        for (int k = 0; k < 10; k++) for (int j = 0; j < 10; j++) T[k][j] = F[k][j];\n        for (int i = 0; i < (1<<10); i++) {\n            for (int k = 0; k < 10; k++) for (int j = 0; j < 10; j++) T[k][j] = F[k][j];\n            if (solve(0, i)) \n                break;\n        }\n        for (int i = 0; i < 10; i++) {\n            cout << (P[0] & 1);\n            for (int j = 1; j < 10; j++) {\n                cout << ' ' << (P[i] & (1<<j) ? 1 : 0);\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nvoid flip(vvi& a,int i,int j)\n{\n\tint di[]={-1,0,0,0,1};\n\tint dj[]={0,-1,0,1,0};\n\trep(k,5){\n\t\tint ni=i+di[k],nj=j+dj[k];\n\t\tif(0<=ni && ni<10 && 0<=nj && nj<10)\n\t\t\ta[ni][nj]^=1;\n\t}\n}\n\nint main()\n{\n\tint tc; cin>>tc;\n\twhile(tc--){\n\t\tvvi a(10,vi(10));\n\t\trep(i,10) rep(j,10)\n\t\t\tcin>>a[i][j];\n\t\trep(k,1<<10){\n\t\t\tvvi b=a;\n\t\t\tvvi res(10,vi(10));\n\t\t\trep(i,10)\n\t\t\t\tif(k&(1<<i)){\n\t\t\t\t\tflip(b,0,i);\n\t\t\t\t\tres[0][i]=1;\n\t\t\t\t}\n\t\t\trepi(i,1,10)\n\t\t\t\trep(j,10)\n\t\t\t\t\tif(b[i-1][j]){\n\t\t\t\t\t\tflip(b,i,j);\n\t\t\t\t\t\tres[i][j]=1;\n\t\t\t\t\t}\n\t\t\tint count1=0;\n\t\t\trep(i,10)\n\t\t\t\tcount1+=count(allof(b[i]),1);\n\t\t\tif(count1==0){\n\t\t\t\trep(i,10)\n\t\t\t\t\trep(j,10)\n\t\t\t\t\t\tcout<<res[i][j]<<(j==9?'\\n':' ');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int dx[]={-1,0,1,0,0};\nconst int dy[]={0,-1,0,1,0};\n\nint ans[10][10];\nint latte[10][10];\n\nvoid change(int y,int x){\n    for(int d=0;d<5;d++){\n        int ty=y+dy[d],tx=x+dx[d];\n        if(ty<0||ty>=10||tx<0||tx>=10)continue;\n        latte[ty][tx]=1-latte[ty][tx];\n    }\n}\n\nvoid solve(){\n    int fld[10][10];\n    for(int i=0;i<10;i++){\n        for(int j=0;j<10;j++){\n            cin>>fld[i][j];\n        }\n    }\n\n    for(int s=0;s<(1<<11);s++){\n        fill_n(*ans,100,0);\n\n        for(int i=0;i<10;i++)\n            for(int j=0;j<10;j++)\n                latte[i][j]=fld[i][j];\n\n        for(int i=0;i<10;i++){\n            if((s>>i)&1){\n                ans[0][i]=1;\n                change(0,i);\n            }\n        }\n\n        for(int i=1;i<10;i++){\n            for(int j=0;j<10;j++){\n                if(latte[i-1][j]){\n                    ans[i][j]=1;\n                    change(i,j);\n                }\n            }\n        }\n\n        bool f=true;\n        for(int i=0;i<10;i++){\n            for(int j=0;j<10;j++){\n                if(latte[i][j])f=false;\n            }\n        }\n\n        if(f){\n            for(int i=0;i<10;i++){\n                for(int j=0;j<10;j++){\n                    if(j)cout<<\" \";\n                    cout<<ans[i][j];\n                }\n                cout<<endl;\n            }\n            return;\n        }\n    }\n}\n\nint main(){\n    int N;\n    cin>>N;\n    while(N--)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint c[10][10];\nint f[10][10];\nbool s[10][10];\nint hanten[2] = { 1,0 };\nint dx[5] = { -1,0,0,1,0 }, dy[5] = { 0,-1,1,0,0 };\nint main() {\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tmemset(s, false, sizeof(s));\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tfor (int e = 0; e < 10; e++) {\n\t\t\t\tscanf(\"%d\",&c[d][e]);\n\t\t\t}\n\t\t}\n\t\tfor (int g = 0; g < 1024; g++) {\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tf[h][i] = c[h][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tif (g & (1 << h)) {\n\t\t\t\t\ts[0][h] = true;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tint x = dx[i], y = h + dy[i];\n\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 1; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tif (f[h - 1][i]) {\n\t\t\t\t\t\ts[h][i] = true;\n\t\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\t\tint x = h+dx[j], y = i + dy[j];\n\t\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool K = true;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (f[i][j])K = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (K) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\t\tif (j)cout << \" \";\n\t\t\t\t\t\tcout << s[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define l(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool m[12][12],c[12][12],d[12][12],q;\nint main(){int n;cin>>n;l(u,n){l(i,10)l(j,10)cin>>m[i][j];\nbool f[10],t[10]={0};for(int p=1;p<=1024;p++){\nl(i,10)f[i]=t[i];l(i,10)l(j,10)c[i][j]=m[i][j];l(k,10){l(i,10)\nif(f[i]){for(int j=max(0,i-1);j<=min(9,i+1);j++)c[k][j]^=1;c[k+1][i]^=1;}\nl(i,10)d[k][i]=f[i];l(i,10)f[i]=c[k][i];}q=0;l(i,10)q|=f[i];\nif(!q){l(i,10)l(j,10){if(j)cout<<\" \";cout<<d[i][j];}cout<<endl;\nbreak;}l(i,10)if(p%(int)pow(2,i)==0)t[i]^=1;\n}}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint I,flg;\nint t[10][10],u[10][10];\nint ans[10][10];\nvoid check();\nvoid dfs(int);\nvoid compute(int,int);\nint main(){\n  cin>>I;\n  while(I--){\n    flg=0;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tcin>>t[i][j];\n\tu[i][j]=t[i][j];\n\tans[i][j]=0;\n      }\n    }\n    dfs(0);\n  }\n  return 0;\n}\n\n\nvoid dfs(int x){\n  if(flg)return;\n  if(x==10){\n    check();\n  }else{\n    ans[0][x]=0;\n    dfs(x+1);\n    if(flg)return;\n    ans[0][x]=1;\n    dfs(x+1);\n  }\n}\n\n\nvoid check(){\n  if(flg)return;\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)t[i][j]=u[i][j];\n\n  for(int i=0;i<10;i++)if(ans[0][i]==1)compute(0,i);\n  \n  for(int i=1;i<10;i++){\n    for(int j=0;j<10;j++){\n      ans[i][j]=0;\n      if(t[i-1][j]==1){\n\tans[i][j]=1;\n\tcompute(i,j);\n      }\n    }\n  }\n  /*\n  for(int i=0;i<10;i++){\n    for(int j=0;j<10;j++){\n      if(j)cout<<' ';\n      cout<<t[i][j];\n    }\n    cout<<endl;\n  }\n  */\n  int cnt=0;\n  for(int i=0;i<10;i++)cnt+=t[9][i];\n  if(cnt==0){\n    flg=1;\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j)cout<<' ';\n\tcout<<ans[i][j];\n      }\n      cout<<endl;\n    }\n  }\n}\n\nvoid compute(int y,int x){\n  t[y][x]=(t[y][x]*-1)+1;\n  if(y>0)t[y-1][x]=(t[y-1][x]*-1)+1;\n  if(x>0)t[y][x-1]=(t[y][x-1]*-1)+1;\n  if(y<9)t[y+1][x]=(t[y+1][x]*-1)+1;\n  if(x<9)t[y][x+1]=(t[y][x+1]*-1)+1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nbool field[11][11], ans[11][11];\n\nint main(){\n  int n;\n  cin >> n;\n  while(n--){\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcin >> field[i][j];\n      }\n    }\n    \n    memset(ans, 0, sizeof(ans));\n    \n    for(int y = 0 ; y < 10 ; y++){\n      for(int x = 0 ; x < 10 ; x++){\n\tif(y == 0 && x == 0){\n\t  if(field[0][0] && field[0][1] && field[1][0] && field[1][1]) ans[0][0] = 1;\n\t}\n\telse if(y == 0 && x == 9){\n\t  if(field[0][9] && field[0][8] && field[1][8] && field[1][9]) ans[0][9] = 1;\n\t}\n\telse if(y == 9 && x == 0){\n\t  if(field[9][0] && field[8][0] && field[8][1] && field[9][1]) ans[9][0] = 1;\n\t}\n\telse if(y == 9 && x == 9){\n\t  if(field[9][9] && field[9][8] && field[8][9] && field[8][8]) ans[9][9] = 1;\n\t}\n\telse if(y == 0){\n\t  if(field[0][x] && field[0][x+1] && field[1][x] && field[0][x-1]) ans[0][x] = 1;\n\t}\n\telse if(x == 0){\n\t  if(field[y][0] && field[y+1][0] && field[y][1] && field[y-1][0]) ans[y][0] = 1;\n\t}\n\telse if(y == 9){\n\t  if(field[9][x] && field[9][x+1] && field[8][x] && field[9][x-1]) ans[9][x] = 1;\n\t}\n\telse if(x == 9){\n\t  if(field[y][9] && field[y+1][9] && field[y][8] && field[y-1][9]) ans[y][0] = 1;\n\t}\n\telse if(field[y][x] && field[y-1][x] && field[y+1][x] && field[y][x-1] && field[y][x+1]){\n\t  ans[y][x] = 1;\n\t}\n\telse if(!field[y][x] && !field[y][x+1] && field[y-1][x] && field[y][x-1] &&\n\t\tfield[y+1][x] && field[y+1][x+1] && field[y-1][x+1] &&\n\t\tfield[y][x+2]){\n\t  ans[y][x] = 1, ans[y][x+1] = 1;\n\t}\n      }\n    }\n\n    for(int i = 0 ; i < 10 ; i++){\n      for(int j = 0 ; j < 10 ; j++){\n\tcout << ans[i][j];\n\tif(j != 9) cout << ' ';\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int H = 10;\nconst int W = 10;\n\nvoid disp(vector< vector<int> > &v){\n  cout <<\"----------\" <<endl;\n  REP(i, H){\n    REP(j, W) cout <<v[i][j];\n    cout <<endl;\n  }\n}\n\nvoid shoot(int y, int x, vector< vector<int> > &v){\n  v[y][x] = !v[y][x];\n  if(y + 1 < H) v[y + 1][x] = !v[y + 1][x];\n  if(y - 1 > -1) v[y - 1][x] = !v[y - 1][x];\n  if(x + 1 < W) v[y][x + 1] = !v[y][x + 1];\n  if(x - 1 > -1) v[y][x - 1] = !v[y][x - 1];\n}\n\nvector<P> change(vector< vector<int> > &v){\n  vector<P> res;\n  FOR(y, 1, v.size()){\n    REP(x, v[y].size()){\n      if(v[y - 1][x] == 1){\n        shoot(y, x, v);\n        res.push_back(P(y, x));\n      }\n    }\n  }\n  return res;\n}\n\nbool check(vector< vector<int> > &v){\n  REP(i, v.size()) REP(j, v[i].size()) if(v[i][j] == 1) return false;\n  return true;\n}\n\nvector<P> solve(){\n  vector< vector<int> > v(H, vector<int>(W));\n  REP(i, H) REP(j, W) cin >>v[i][j];\n  vector<P> res;\n  REP(b, (1 << W)){\n    vector< vector<int> > vv = v;\n    vector<P> tmp;\n    REP(i, W){\n      if(!(1 & (b >> i))) continue;\n      shoot(0, i, vv);\n      tmp.push_back(P(0, i));\n    }\n    vector<P> ans = change(vv);\n    REP(i, tmp.size()) ans.push_back(tmp[i]);\n    if(check(vv)){ res = ans; break; }\n  }\n  return res;\n}\n\nint main() {\n  int N; cin >>N;\n  while(N--){\n    vector<P> r = solve();\n    vector< vector<int> > ans(H, vector<int>(W, 0));\n    REP(i, r.size()) ans[r[i].first][r[i].second] = 1;\n    REP(i, H){\n      REP(j, W) cout <<(j != 0 ? \" \": \"\") <<ans[i][j];\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <list>\n\nstd::list<int> dfs(std::vector<std::vector<bool>> &state, const int &idx = 1) {\n\tif (idx < 10) {\n\t\tint res = 0;\n\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\tres <<= 1;\n\t\t\tif (state.at(idx - 1).at(i)) {\n\t\t\t\tres += 1;\n\t\t\t\tfor (const auto &index : { i - 1, i, i + 1 }) {\n\t\t\t\t\tif (index >= 0 && index < 10) {\n\t\t\t\t\t\tstate.at(idx).at(index) = !state.at(idx).at(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx != 9) {\n\t\t\t\t\tstate.at(idx + 1).at(i) = !state.at(idx + 1).at(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(state, idx + 1);\n\t\tif (list.size() + idx == 9) {\n\t\t\tlist.push_front(res);\n\t\t\treturn list;\n\t\t}\n\t\telse {\n\t\t\treturn list;\n\t\t}\n\t}\n\telse {\n\t\tbool is_on = false;\n\t\tfor (const auto &cell : state.at(9)) {\n\t\t\tis_on = is_on || cell;\n\t\t}\n\t\tif (is_on) {\n\t\t\treturn std::list<int>{0};\n\t\t}\n\t\telse {\n\t\t\treturn std::list<int>{};\n\t\t}\n\t}\n}\nstd::list<int> solve(std::vector<std::vector<bool>> &state) {\n\tfor (auto i = 0; i < 1023; ++i) {\n\t\tauto copy = state;\n\t\tfor (auto j = 0; j < 10; ++j) {\n\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\tfor (const auto &idx : { j - 1, j, j + 1 }) {\n\t\t\t\t\tif (idx >= 0 && idx < 10) {\n\t\t\t\t\t\tcopy.at(0).at(idx) = !copy.at(0).at(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcopy.at(1).at(j) = !copy.at(1).at(j);\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(copy);\n\t\tif (list.size() == 9) {\n\t\t\tlist.push_front(i);\n\t\t\treturn list;\n\t\t}\n\t}\n\treturn std::list<int>{};\n}\nint main() {\n\tint n;\n\tfor (std::cin >> n; n > 0; --n) {\n\t\tstd::vector<std::vector<bool>> state(10, std::vector<bool>(10, false));\n\t\tint input;\n\t\tfor (auto &line : state) {\n\t\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\t\tstd::cin >> input;\n\t\t\t\tline.at(i) = input == 1;\n\t\t\t}\n\t\t}\n\t\tauto res = solve(state);\n\t\tfor (const auto &line : res) {\n\t\t\tfor (auto i = 512; i > 0; i >>= 1) {\n\t\t\t\tstd::cout << static_cast<int>((i & (line)) != 0) << ((i != 1) ? ' ' : '\\n');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<char,int> P;\n\nvoid flip(int x,int y,int stage[10][10]){\n\tconst int t[][2] = {{0,0},{-1,0},{1,0},{0,1},{0,-1}};\n\tfor(int i=0;i<5;i++){\n\t\tint dx = x+t[i][0];\n\t\tint dy = y+t[i][1];\n\n\t\tif(dx < 0 || dx >= 10 || dy < 0 || dy >= 10) continue;\n\n\t\tstage[dy][dx]*=-1;\n\t}\n}\n\nbool checkStage(int store[10][10],int x,int y){\n\treturn store[y][x] == -1 ? true : false;\n}\n\nbool isClear(int store[10][10]){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(store[y][x]==1) return false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nvoid writeResult(int result[10][10]){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tprintf(\"%d%s\",result[y][x],x==9 ? \"\\n\" : \" \");\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint stage[10][10];\n\t\t\t\n\t\t\tfor(int y=0;y<10;y++){\n\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\tint num;\n\t\t\t\t\tscanf(\"%d\",&num);\n\t\t\t\t\tstage[y][x] = (num == 0 ? -1 : 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int S=0;S<=(1 << 10)-1;S++){\n\t\t\t\tint store[10][10];\n\t\t\t\tint result[10][10];\n\t\t\t\tmemset(result,0,sizeof(result));\n\t\t\t\t//memset(store,0,sizeof(store));\n\t\t\t\tmemcpy(store,stage,sizeof(stage));\n\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif((S>>j) & 1){\n\t\t\t\t\t\tflip(j,0,store);\n\t\t\t\t\t\tresult[0][j]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int y=1;y<10;y++){\n\t\t\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\t\t\tflip(x,y,store);\n\t\t\t\t\t\tif(!checkStage(store,x,y-1)){\n\t\t\t\t\t\t\tflip(x,y,store);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tresult[y][x] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(isClear(store)){\n\t\t\t\t\twriteResult(result);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int dx[4] = {0,1,0,-1};\nconst int dy[4] = {1,0,-1,0};\n\nint main(){\n  int n;\n  cin >> n;\n  \n  while(n-- > 0){\n    int imap[11][11],syokurin[11][11],solve[11][11];\n    rep(i,10){\n      rep(j,10){\n\tsyokurin[i][j] = solve[i][j] = 0;\n\tcin >> imap[i][j];\n      }\n    }\n\n    while(true)\n      {\n\trep(i,10){\n\t  rep(j,10){\n\t    if(imap[i][j] == 0)continue;\n\t    syokurin[i][j]++;\n\t    rep(k,4){\n\t      int nx = j+dx[k],ny = i+dy[k];\n\t      if(!(0<=nx && nx <10 && 0<=ny && ny <10))continue;\n\t      syokurin[ny][nx]++;\n\t    }\n\t  }\n\t}\t\n\n\trep(i,10){\n\t  rep(j,10){\n\t    if(syokurin[i][j] == 1)continue;\n\t    if(syokurin[i][j]%2 != 0 && solve[i][j] != 1){\n\t      solve[i][j] = 1;\n\t      imap[i][j] = imap[i][j] == 0?1:0;\n\t      rep(k,4){\n\t\tint nx = j+dx[k],ny = i+dy[k];\n\t\tif(!(0<=nx && nx <10 && 0<=ny && ny <10))continue;\n\t\timap[ny][nx] = imap[ny][nx]==0?1:0;\n\t      }\n\t    }\n\t  }\n\t}\n\n\trep(i,10)rep(j,10)syokurin[i][j] = 0;\n\tbool fin = true;\n\trep(i,10)rep(j,10)if(imap[i][j] == 1)fin = false;\n\t  if(fin)break;\n      }\n\n    rep(i,10){\n      rep(j,10){\n\tcout << solve[i][j];\n\tif(j != 9)cout << \" \";\n      }\n      cout << endl;\n    }\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        \n        bool box[12][12]={0};\n        \n        for(int i=1; i<=10; i++){\n            for(int j=1; j<=10; j++){\n                cin>>box[i][j];\n            }\n        }\n        //cout<<\"----------------------\"<<endl;\n        \n        bool box2[12][12]={0};\n\n        for(int i=0; i<(1<<10 - 1); i++){\n            memcpy(box2, box, sizeof(box));\n            int l[12][12]={0};\n            for(int j=1; j<=10; j++){\n                l[0][j]= (i>>j)%2;\n            }\n            \n            for(int j=1; j<=10; j++){\n                for(int k=1; k<=10; k++){\n                    if(l[j-1][k]==1){\n                        box2[j][k]=(box2[j][k]+1)%2;\n                        box2[j][k+1]=(box2[j][k+1]+1)%2;\n                        box2[j][k-1]=(box2[j][k-1]+1)%2;\n                        box2[j-1][k]=(box2[j-1][k]+1)%2;\n                        box2[j+1][k]=(box2[j+1][k]+1)%2;\n                    }\n                }\n                \n                for(int k=1; k<=10; k++){\n                    l[j][k]=box2[j][k];\n                }\n            }\n            \n            bool end_flag=true;\n            for(int i=1; i<=10; i++){\n                if(l[10][i]==1){\n                    end_flag=false;\n                    break;\n                }\n            }\n            \n            \n            if(end_flag){\n                for(int i=1; i<=10; i++){\n                    for(int j=1; j<=10; j++){\n                        cout<<l[i][j];\n                        if(j==10)break;\n                        cout<<\" \";\n                    }\n                    cout<<endl;\n                }\n                break;\n            }\n        }\n        //cout<<\"============================\"<<endl;\n\n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[10][10];\nint main() {\n\tint n; cin >> n;\n\tfor (int h = 0; h < n; h++) {\n\t\tfor (int i = 0; i < 100; i++)cin >> x[i / 10][i % 10];\n\t\tfor (int i = 0; i < (1 << 10); i++) {\n\t\t\tint bit[10]; for (int j = 0; j < 10; j++)bit[j] = (i / (1 << j)) % 2;\n\t\t\tint T[11][10], V[10][10]; for (int j = 0; j < 110; j++) { T[j / 10][j % 10] = 0; V[j / 10][j % 10] = 0; }\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (bit[j] == 1) {\n\t\t\t\t\tT[0][j]++; V[0][j] = 1;\n\t\t\t\t\tif (j > 0)T[0][j - 1]++; if (j < 9)T[0][j + 1]++; T[1][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 1; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tif (T[j - 1][k] % 2 != x[j - 1][k]) {\n\t\t\t\t\t\tT[j - 1][k]++; T[j][k]++; T[j + 1][k]++; V[j][k] = 1;\n\t\t\t\t\t\tif (k > 0)T[j][k - 1]++; if (k < 9)T[j][k + 1]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool OK = true; for (int k = 0; k < 10; k++)if (T[9][k] % 2 != x[9][k])OK = false;\n\t\t\tif (OK == true) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\t\tif (k)cout << ' '; cout << V[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nvoid copy(int a[10][10],int b[10][10]){\n  for(int i=0;i<10;i++)for(int j=0;j<10;j++)a[i][j]=b[i][j];\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10],b[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    copy(b,mp);\n    int ans[10][10]={};\n    for(int i=0;!check(mp);i++){\n      copy(mp,b),copy(b,mp);\n      for(int j=0;j<10;j++)if((ans[0][j]=((i>>j)%2)))mark(mp,0,j);\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n      }\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int dx[] = {0, -1, 0, 1, 0};\nconst int dy[] = {0, 0, -1, 0, 1};\n\nint a[10][10];\nint grid[10][10];\nint res[10][10];\n\nbool ok(int i, int j)\n{\n\treturn i >= 0 && j >= 0 && i < 10 && j < 10;\n}\n\nvoid rev(int x, int y)\n{\n\tfor (int dir = 0; dir < 5; dir++){\n\t\tint nx = x + dx[dir];\n\t\tint ny = y + dy[dir];\n\t\tif (ok(nx, ny)) grid[nx][ny] ^= 1;\n\t}\n}\n\nvoid solve()\n{\n\tfor (int x = 0; x < (1 << 10); x++){\n\t\tmemset(res, 0, sizeof(res));\n\t\tmemcpy((void *)grid, (void *)a, sizeof(grid));\n\t\t\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tif (x & (1 << i)){\n\t\t\t\tres[0][i] = 1;\n\t\t\t\trev(0, i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i < 10; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tif (grid[i - 1][j]){\n\t\t\t\t\tres[i][j] = 1;\n\t\t\t\t\trev(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint f = 0;\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tf += grid[i][j];\n\t\t\t}\n\t\t}\n\t\tif (!f) break;\n\t}\n\t\n\tfor (int i = 0; i < 10; i++){\n\t\tfor (int j = 0; j < 10; j++){\n\t\t\tif (j) printf(\" \");\n\t\t\tprintf(\"%d\", res[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\twhile (n--){\n\t\tfor (int i = 0; i < 10; i++){\n\t\t\tfor (int j = 0; j < 10; j++){\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t}\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define MAX 12\n#define INFTY 1 << 28\nusing namespace std;\n\nbool IsLeft(int m[MAX][MAX]){\n\tfor(int i = 1; i < MAX - 1; ++i){\n\t\tfor(int j = 1; j < MAX - 1; ++j){\n\t\t\tif( m[i][j] ) return true;\n\t\t}\n\t}\n\treturn false;\n}\nvoid PassParticle(int m[MAX][MAX], int i, int j){\n\tconst int di[] = {0,-1,0,1,0};\n\tconst int dj[] = {0,0,1,0,-1};\n\n\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\tm[i+di[k]][j+dj[k]] = (m[i+di[k]][j+dj[k]] + 1) % 2;\n\t}\n}\nvoid PrintMap(int m[MAX][MAX]){\n\tfor(int i = 1; i < MAX - 1; ++i){\n\t\tcout << m[i][1];\n\t\tfor(int j = 2; j < MAX - 1; ++j){\n\t\t\tcout << ' ' << m[i][j];\n\t\t}\n\t\tcout << '\\n';\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D ){\n\t\tint pi, pj; /* 1ðÅà½­½]³¹çêéÀW */\n\t\tint M[MAX][MAX] = {{0,},};\n\t\tint Answer[MAX][MAX] = {{0,},};\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\tcin >> M[i][j];\n\t\t\t}\n\t\t}\n\n\t\twhile( IsLeft(M) ){\n\t\t\tint max1 = 0;\n\t\t\tint min0 = INFTY;\n\t\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\t\tfor(int j = 1; j < MAX - 1 ; ++j){\n\t\t\t\t\tint cnt1 = 0;\n\t\t\t\t\tint cnt0 = 0;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\n\t\t\t\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n\t\t\t\t\t\tif( M[i+di[k]][j+dj[k]] ) ++cnt1;\n\t\t\t\t\t\telse ++cnt0;\n\t\t\t\t\t}\n\t\t\t\t\tif( cnt1 > max1 && cnt0 < min0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tpi = i; pj = j;\n\t\t\t\t\t\tmax1 = cnt1;\n\t\t\t\t\t\tmin0 = cnt0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tPassParticle( M, pi, pj );\n\t\t\tAnswer[pi][pj] = 1;\n\t\t}\n\t\tPrintMap( Answer );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nbool mem[12][12],cop[12][12],done[12][12];\n\nint main(){\n  int n;cin>>n;\n  while(n--){\n    lol(i,10)lol(j,10)cin>>mem[i][j];\n    bool flag[10],tmp[10];\n    for(int p=1;p<=1024;p++){\n      lol(i,10)flag[i]=tmp[i];\n      lol(i,10)lol(j,10)cop[i][j]=mem[i][j];\n      for(int k=0;k<10;k++){\n\tlol(i,10){\n\t  if(!flag[i])continue;\n\t  for(int j=max(0,i-1);j<=min(9,i+1);j++)cop[k][j]^=1;\n\t  cop[k+1][i]^=1;\n\t}\n\tlol(i,10)done[k][i]=flag[i];\n\tlol(i,10)flag[i]=cop[k][i];\n      }\n      bool na=false;\n      lol(i,10)na|=flag[i];\n      if(!na){\n\tcout<<endl;\n\tlol(i,10){\n\t  lol(j,10){\n\t    if(j)cout<<\" \";\n\t    cout<<done[i][j];\n\t  }\n\t  cout<<endl;\n\t}\n      }\n      for(int i=0;i<10;i++){\n\tint r=pow(2,i);\n\tif(p%r==0)tmp[i]^=1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nstruct UF {\n    vi e;\n    UF(int n) : e(n, -1) {}\n    bool same_set(int a, int b) { return find(a) == find(b); }\n    int size(int x) { return -e[find(x)]; }\n    int find(int x) { return e[x] < 0 ? x : e[x] = find(e[x]); }\n\n    void join(int a, int b) {\n        a = find(a), b = find(b);\n        if(a == b) return;\n        if(e[a] > e[b]) swap(a, b);\n        e[a] += e[b]; e[b] = a;\n    }\n};\nint main() {\n    //cout << fixed << setprecision(15);\n\n    int n; cin >> n;\n    int cnt=0;\n    while(n--) {\n        if(cnt) cout << endl;\n        cnt++;\n        vector<vector<int>> v(10);\n\n        for(int i=0; i<10; ++i){\n            for(int j=0; j<10; ++j){\n                int a; cin >> a;\n                v[i].push_back(a);\n            }\n        }\n\n        bool f = false;\n        for(int bit=0; bit<(1<<10); ++bit){\n            int arr[15][15]={0};\n\n            int ans[10][10]={0};\n            for(int i=0; i<10; ++i){\n                if(bit >> i & 1){\n                    ans[0][i]=1;\n                    if(i==0){\n                        arr[0][0] ^= 1;\n                        arr[1][0] ^= 1;\n                        arr[0][1] ^= 1;\n                    }else if(i==9){\n                        arr[0][i] ^= 1;\n                        arr[1][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                    }else{\n                        arr[0][i] ^= 1;\n                        arr[0][i-1] ^= 1;\n                        arr[0][i+1] ^= 1;\n                        arr[1][i] ^= 1;\n                    }\n                }\n            }\n\n            for(int i=1; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if((arr[i-1][j] == 0 && v[i-1][j]==1) || (arr[i-1][j]==1 && v[i-1][j]==0)){\n                        ans[i][j]=1;\n                        if(j==0){\n                            arr[i][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }else if(j==9){\n                            arr[i][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                        }else{\n                            arr[i][j] ^= 1;\n                            arr[i][j-1] ^= 1;\n                            arr[i][j+1] ^= 1;\n                            arr[i+1][j] ^= 1;\n                            arr[i-1][j] ^= 1;\n                        }\n                    }\n                }\n            }\n            bool d = true;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(arr[i][j]!=v[i][j]) d= false;\n                }\n            }\n            if(!d) continue;\n            for(int i=0; i<10; ++i){\n                for(int j=0; j<10; ++j){\n                    if(j) cout << \" \";\n                    cout << ans[i][j];\n                }\n                cout << endl;\n            }\n            cout << endl;\n            break;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 10;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {0, 0, 1, 0, -1};\n\nbool solve(vector<vector<int> > state, vector<vector<int> >& ans)\n{\n  for (int i = 0; i < SIZE; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      if ((i == 0 && ans[i][j]) || (i > 0 && state[i-1][j])) {\n\tans[i][j] = 1;\n\tfor (int d = 0; d < 5; ++d) {\n\t  int xx = j + dx[d];\n\t  int yy = i + dy[d];\n\t  if (0 <= xx && xx < SIZE && 0 <= yy && yy < SIZE)\n\t    state[yy][xx] ^= 1;\n\t}\n      }\n    }\n  }\n\n  for (int i = 0; i < SIZE; ++i) {\n    for (int j = 0; j < SIZE; ++j) {\n      if (state[i][j])\n\treturn false;\n    }\n  }\n  return true;\n}\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    while (n--) {\n      vector<vector<int> > state(SIZE, vector<int>(SIZE));\n      for (int i = 0; i < SIZE; ++i) {\n\tfor (int j = 0; j < SIZE; ++j)\n\t  cin >> state[i][j];\n      }\n\n      for (int i = 0; i < (1 << SIZE); ++i) {\n\tvector<vector<int> > ans(SIZE, vector<int>(SIZE, 0));\n\tfor (int j = 0; j < SIZE; ++j) {\n\t  if (i & (1 << j))\n\t    ans[0][j] = 1;\n\t}\n\tif (solve(state, ans)) {\n\t  for (int i = 0; i < SIZE; ++i) {\n\t    for (int j = 0; j < SIZE-1; ++j) \n\t      cout << ans[i][j] << \" \";\n\t    cout << ans[i][SIZE-1] << endl;\n\t  }\n\t  break;\n\t}\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define fr first\n#define sc second\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> pip; \nconst int INF = (1<<25);\nconst int dx[]={0,0,0,1,-1},dy[]={-1,1,0,0,0};\n\nint d[10][10], b[10][10], a[10][10];\n\nvoid flip(int x, int y) {\n  a[y][x]=1;\n  for(int i=0; i<5; i++) {\n    b[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n  }\n}\n\nint main() {\n\n  int n;\n  cin>> n;\n  while(n--) {\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcin>> d[i][j];\n      }\n    }\n\n    for(int i=0; i<1024; i++) {\n      memset(a, 0, sizeof(a));\n      memcpy(b, d, sizeof(d));\n      for(int j=0; j<10; j++) {\n\tif((i>>j) & 1) flip(j, 0);\n      }\n\n      for(int j=1; j<10; j++) {\n\tfor(int k=0; k<10; k++) {\n\t  if(b[j-1][k]) flip(k, j);\n\t}\n      }\n\n      int cnt=0;\n      for(int j=0; j<10; j++) {\n\tcnt+=b[9][j];\n      }\n\n      if(cnt==0) break;\n    }\n\n    for(int i=0; i<10; i++) {\n      for(int j=0; j<10; j++) {\n\tcout << a[i][j]<< (j==9 ? \"\" : \" \");\n      }\n      cout<< endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nusing namespace std;\n\nint memo[11][1024];\n\nint main(){\n\tint sw[1024];\n\tfor(int i=0;i<1024;i++){\n\t\tsw[i]=0;\n\t\tif(i&1)\t\tsw[i]^=3;\n\t\tfor(int j=1;j<9;j++)\tif(i&(1<<j))\tsw[i]^=(7<<(j-1));\n\t\tif(i&512)\tsw[i]^=768;\n\t}\n\n\tint t;\tscanf(\"%d\",&t);\n\twhile(t--){\n\t\tint cell[10]={};\n\t\tfor(int i=0;i<10;i++){\n\t\t\tcell[i]=0;\n\t\t\tfor(int j=0,tmp;j<10;j++)\tscanf(\"%d\",&tmp),cell[i]|=(tmp<<(9-j));\n\t\t}\n\n\t\tfor(int i=0;i<1024;i++)\tmemo[0][i]=0;\n\t\tfor(int r=1;r<=10;r++){\n\t\t\tfor(int i=0;i<1024;i++){\n\t\t\t\tmemo[r][i]=-1;\n\t\t\t\tfor(int b=0;b<1024;b++){\n\t\t\t\t\tif(memo[r-1][b]==-1)\tcontinue;\n\t\t\t\t\tif((cell[r-1]^memo[r-1][b]^sw[b]^i)==0)\tmemo[r][i]=b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[10];\n\t\tfor(int i=0,j=memo[10-i][0];i<10;i++,j=memo[10-i][j])\tans[i]=j;\n\t\tfor(int i=9;i>=0;i--){\n\t\t\tfor(int k=9;k>=0;k--)\tprintf(\"%s%d\",(k==9?\"\":\" \"),(bool)(ans[i]&(1<<k)));\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#define MAX 12\n#define NIL (-1)\n\nusing namespace std;\n\ninline bool inRange(int t, int min, int max){\n\treturn (min <= t && t < max);\n}\n\nclass CMap{\npublic:\n\tint m[MAX][MAX];\n\tvector< pair<int, int > > vHist;\n\n\tCMap()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\n\tvoid Reset()\n\t{\n\t\tfor(int i = 0; i < MAX; ++i)\n\t\t\tfor(int j = 0; j < MAX; ++j)\n\t\t\t\tm[i][j] = 0;\n\t}\n\tint TryPassParticle(int i, int j)\n\t{\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\n\t\treturn cnt1;\n\t}\n\tbool PassParticle(int i, int j)\n\t{\n\t\tint cnt0 = 0;\n\t\tint cnt1 = 0;\n\t\tconst int di[] = {0,-1,0,1,0};\n\t\tconst int dj[] = {0,0,1,0,-1};\n\n\t\tif( !(inRange(i,1,MAX-1) && inRange(j,1,MAX-1)) )\n\t\t\treturn false;\n\n\t\tif( find( vHist.begin(), vHist.end(), make_pair(i,j) ) != vHist.end() )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tif( m[i+di[k]][j+dj[k]] == 1 )\n\t\t\t\t\tcnt1++;\n\t\t\t\telse\n\t\t\t\t\tcnt0++;\n\n\t\tif( cnt1 < cnt0 )\n\t\t\treturn false;\n\n\t\tfor(int k = 0; k < sizeof(di)/sizeof(*di); ++k)\n\t\t\tif( inRange( i+di[k],1,MAX-1 ) && inRange( j+dj[k],1,MAX-1 ) )\n\t\t\t\tm[i+di[k]][j+dj[k]] ^= 1;\n\n\t\tvHist.push_back( make_pair( i, j ) );\n\t\treturn true;\n\t}\n\tbool NoLight(int range = MAX - 1) const\n\t{\n\t\tfor(int i = 1; i < range; ++i)\n\t\t\tfor(int j = 1; j < range; ++j)\n\t\t\t\tif( m[i][j] == 1 ) return false;\n\t\treturn true;\n\t}\n\tvoid Print() const\n\t{\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n\tvoid PrintPassHist(){\n\t\tReset();\n\n\t\tfor(unsigned int i = 0; i < vHist.size(); ++i)\n\t\t\tm[ vHist[i].first ][ vHist[i].second ] = 1;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i){\n\t\t\tcout << m[i][1];\n\t\t\tfor(int j = 2; j < MAX - 1; ++j)\n\t\t\t\tcout << ' ' << m[i][j];\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\nvoid EraseBlocks(CMap &M){\n\tbool bCont;\n\tdo{\n\t\tbCont = false;\n\t\tfor(unsigned int i = 1; i < MAX-1; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint ci = NIL, cj = NIL, max1 = 0;\n\t\t\t\t\tconst int di[] = {-1,-1,0,1,1, 1, 0,-1};\n\t\t\t\t\tconst int dj[] = { 0, 1,1,1,0,-1,-1,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; k+=2){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1) && \n\t\t\t\t\t\t\tM.m[i+di[(k+2)%sz]][j+dj[(k+2)%sz]] == 0 && inRange(i+di[(k+2)%sz],1,MAX-1) && inRange(j+dj[(k+2)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+3)%sz]][j+dj[(k+3)%sz]] == 0 && inRange(i+di[(k+3)%sz],1,MAX-1) && inRange(j+dj[(k+3)%sz],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+4)%sz]][j+dj[(k+4)%sz]] == 0 && inRange(i+di[(k+4)%sz],1,MAX-1) && inRange(j+dj[(k+4)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tint d = M.TryPassParticle( i+di[(k+6)%sz],j+dj[(k+6)%sz] );\n\t\t\t\t\t\t\t\tif( d > max1 )\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmax1 = d;\n\t\t\t\t\t\t\t\t\tci = i+di[(k+6)%sz];\n\t\t\t\t\t\t\t\t\tcj = j+dj[(k+6)%sz];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif( M.PassParticle( ci, cj ) ){\n\t\t\t\t\t\tbCont = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}while( bCont );\n}\n\nvoid BFS(CMap &stm, CMap &ret){\n\tint n = 0;\n\tbool bFailed = true;\n\tqueue< CMap > q;\n\n\tq.push( stm );\n\twhile( !q.empty() ){\n\t\tbool bCont = true;\n\t\tCMap Tmp, M = q.front();\n\t\t\n\t\tq.pop();\n\n\t\tEraseBlocks( V, M );\n\t\t/*cout << endl;\n\t\tM.Print();*/\n\t\t\n\t\tif( M.NoLight() )\n\t\t{\n\t\t\tret = M;\n\t\t\tbFailed = false;\n\t\t\tbreak;\n\t\t}\n\t\tTmp = M;\n\n\t\tfor(unsigned int i = 1; i < MAX-1 && bCont; ++i){\n\t\t\tfor(unsigned int j = 1; j < MAX-1 && bCont; ++j){\n\t\t\t\tif( M.m[i][j] == 1 ){\n\t\t\t\t\tint max1 = 0;\n\t\t\t\t\tint ci = NIL, cj = NIL;\n\t\t\t\t\tconst int di[] = {-1,0,1,0};\n\t\t\t\t\tconst int dj[] = {0,1,0,-1};\n\t\t\t\t\tconst int sz = sizeof(di)/sizeof(*di);\n\n\t\t\t\t\tfor(int k = 0; k < sz; ++k){\n\t\t\t\t\t\tif( M.m[i+di[k]][j+dj[k]] == 0 && inRange(i+di[k],1,MAX-1) && inRange(j+dj[k],1,MAX-1) &&\n\t\t\t\t\t\t\tM.m[i+di[(k+1)%sz]][j+dj[(k+1)%sz]] == 0 && inRange(i+di[(k+1)%sz],1,MAX-1) && inRange(j+dj[(k+1)%sz],1,MAX-1)){\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+2)%sz], j+dj[(k+2)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif( M.PassParticle(i+di[(k+3)%sz], j+dj[(k+3)%sz]) ){\n\t\t\t\t\t\t\t\t\tq.push( M );\n\t\t\t\t\t\t\t\t\tM = Tmp;\n\t\t\t\t\t\t\t\t\tbCont = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tfor( int D = 0; D < n; ++D )\n\t{\n\t\tCMap M;\n\t\tCMap Answer;\n\n\t\tfor(int i = 1; i < MAX - 1; ++i)\n\t\t\tfor(int j = 1; j < MAX - 1 ; ++j)\n\t\t\t\tcin >> M.m[i][j];\n\n\t\tBFS( M, Answer );\n\t\tAnswer.PrintPassHist();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dx[] = {0,1,0,0,-1},dy[] = {1,0,-1,0,0};\n\nint main(){\n\tint m;\n\tcin >> m;\n\tfor(int i = 0;i < m;i++){\n\t\tint a[10][10],b[10][10] = {};\n\t\tfor(int j = 0;j < 10;j++){\n\t\t\tfor(int k = 0;k < 10;k++) cin >> a[j][k];\n\t\t}\n\t\tfor(int j = 0;j < 1024;j++){\n\t\t\tint t[10][10];\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tt[k][l] = a[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif((j >> k) & 1){\n\t\t\t\t\tb[0][k] = 1;\n\t\t\t\t\tfor(int l = 0;l < 4;l++){\n\t\t\t\t\t\tint nx = dx[l],ny = k + dy[l];\n\t\t\t\t\t\tif(ny >= 0 && ny < 10){\n\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0;k < 9;k++){\n\t\t\t\tfor(int l = 0;l < 10;l++){\n\t\t\t\t\tif(t[k][l]){\n\t\t\t\t\t\tb[k + 1][l] = 1;\n\t\t\t\t\t\tfor(int n = 0;n < 5;n++){\n\t\t\t\t\t\t\tint nx = k + 1 + dx[n],ny = l + dy[n];\n\t\t\t\t\t\t\tif(nx >= 0 && nx < 10 && ny >= 0 && ny < 10){\n\t\t\t\t\t\t\t\tt[nx][ny] = (t[nx][ny] + 1) % 2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool flag = true;\n\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\tif(t[9][k]) flag = false;\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tfor(int k = 0;k < 10;k++){\n\t\t\t\t\tfor(int l = 0;l < 10;l++) {\n\t\t\t\t\t\tcout << (!l ? \"\" : \" \") << b[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[12][12];\nint T[12][12], V[12][12];\nvoid compute(int X, int Y) {\n\tint dx[5] = { -1,0,0,0,1 }, dy[5] = { 0,-1,0,1,0 };\n\tfor (int i = 0; i < 5; i++) { T[X + dx[i]][Y + dy[i]]++; T[X + dx[i]][Y + dy[i]] %= 2; }\n}\nint main() {\n\tint n; cin >> n;\n\tfor (int h = 0; h < n; h++) {\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tfor (int j = 1; j <= 10; j++)cin >> x[i][j];\n\t\t}\n\n\t\tfor (int i = 0; i < (1 << 10); i++) {\n\t\t\tint bit[11]; for (int j = 0; j < 10; j++)bit[j + 1] = (i / (1 << j)) % 2;\n\t\t\tfor (int j = 0; j < 12; j++) {\n\t\t\t\tfor (int k = 0; k < 12; k++) { T[j][k] = 0; V[j][k] = 0; }\n\t\t\t}\n\n\t\t\tfor (int j = 1; j <= 10; j++) {\n\t\t\t\tif (bit[j] == 1) {\n\t\t\t\t\tcompute(1, j);\n\t\t\t\t\tV[1][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 2; j <= 10; j++) {\n\t\t\t\tfor (int k = 1; k <= 10; k++) {\n\t\t\t\t\tif (T[j - 1][k] != x[j - 1][k]) {\n\t\t\t\t\t\tcompute(j, k);\n\t\t\t\t\t\tV[j][k] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool OK = true; for (int k = 1; k <= 10; k++) { if (T[10][k] != x[10][k])OK = false; }\n\t\t\tif (OK == true) {\n\t\t\t\tfor (int j = 1; j <= 10; j++) {\n\t\t\t\t\tfor (int k = 1; k <= 10; k++) {\n\t\t\t\t\t\tif (k >= 2)cout << ' '; cout << V[j][k];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,s,y,x,i;\nint d[12][12],b[12][12],a[12][12];\nint dx[] = { 0,0,0,1,-1};\nint dy[] = {-1,1,0,0, 0};\n\nvoid flip(int x, int y)\n{\n\ta[y][x] = 1;\n\tfor(i=0; i<5; i++)\n\t{\n\t\tb[y+dy[i]][x+dx[i]] = 1-b[y+dy[i]][x+dx[i]];\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\twhile(n--)\n\t{\n\t\tfor(y=1; y<=10; y++)\n\t\tfor(x=1; x<=10; x++)\n\t\t{\n\t\t\tcin >> d[y][x];\n\t\t}\n\n\t\tfor(i=0; i<1024; i++)\n\t\t{\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tmemcpy(b,d,sizeof(d));\n\n\t\t\tfor(y=1,x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tif((i>>(x-1))&1) flip(x,y);\n\t\t\t}\n\n\t\t\tfor(y=2; y<=10; y++)\n\t\t\tfor(x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tif(b[y-1][x]) flip(x,y);\n\t\t\t}\n\n\t\t\tfor(y=10,x=1,s=0; x<=10; x++)\n\t\t\t{\n\t\t\t\ts+=b[y][x];\n\t\t\t}\n\n\t\t\tif(s==0) break;\n\t\t}\n\n\t\tfor(y=1; y<=10; y++)\n\t\t{\n\t\t\tfor(x=1; x<=10; x++)\n\t\t\t{\n\t\t\t\tcout << a[y][x] << (x==10?\"\":\" \");\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<math.h>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\nbool mem[12][12],cop[12][12],done[12][12];\n\nint main(){\n  int n;cin>>n;\n  while(n--){\n    lol(i,10)lol(j,10)cin>>mem[i][j];\n    bool flag[10],tmp[10];\n    for(int p=1;p<=1024;p++){\n      lol(i,10)flag[i]=tmp[i];\n      lol(i,10)lol(j,10)cop[i][j]=mem[i][j];\n      for(int k=0;k<10;k++){\n\tlol(i,10){\n\t  if(!flag[i])continue;\n\t  for(int j=max(0,i-1);j<=min(9,i+1);j++)cop[k][j]^=1;\n\t  cop[k+1][i]^=1;\n\t}\n\tlol(i,10)done[k][i]=flag[i];\n\tlol(i,10)flag[i]=cop[k][i];\n      }\n      bool na=false;\n      lol(i,10)na|=flag[i];\n      if(!na){\n\tcout<<endl;\n\tlol(i,10){\n\t  lol(j,10)cout<<done[i][j]<<\" \";\n\t  cout<<endl;\n\t}\n      }\n      for(int i=0;i<10;i++){\n\tint r=pow(2,i);\n\tif(p%r==0)tmp[i]^=1;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint F[10][10];\nint T[10][10];\nint P[10];\n\nbool check() {\n    for (int i = 0; i < 10; i++)\n        for (int j = 0; j < 10; j++)\n            if (T[i][j]) return false;\n    return true;\n}\n\nbool solve(int c, int n) {\n    for (int i = 0; i < 10; i++) {\n        if (n & (1<<i)) {\n            if (c-1 >= 0) T[c-1][i] = !T[c-1][i];\n            if (i-1 >= 0) T[c][i-1] = !T[c][i-1];\n            T[c][i]   = !T[c][i];\n            if (i+1 < 10) T[c][i+1] = !T[c][i+1];\n            if (c+1 < 10) T[c+1][i] = !T[c+1][i];\n        }\n    }\n    P[c] = n;\n    if (c == 9) return check();\n    int next = 0;\n    for (int i = 0; i < 10; i++) {\n        if (T[c][i]) {\n            next |= (1<<i);\n        }\n    }\n    return solve(c+1, next);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while (n--) {\n        for (int i = 0; i < 10; i++) \n            for (int j = 0; j < 10; j++)\n                cin >> F[i][j];\n        for (int i = 0; i < (1<<10); i++) {\n            for (int k = 0; k < 10; k++) for (int j = 0; j < 10; j++) T[k][j] = F[k][j];\n            if (solve(0, i)) \n                break;\n        }\n        for (int i = 0; i < 10; i++) {\n            cout << (P[i] & 1);\n            for (int j = 1; j < 10; j++) {\n                cout << ' ' << (P[i] & (1<<j) ? 1 : 0);\n            }\n            cout << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <fstream>\n#include <sstream>\n#include <math.h>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <string.h>\n\n\nusing namespace std;\n\n\nvoid f(bool box[12][12]){\n    for(int i=1; i<=10; i++){\n        for(int j=1; j<=10; j++){\n            cout<<box[i][j];\n        }\n        cout<<endl;\n    }\n    cout<<endl;\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        for(int roop=0; roop<n; roop++){\n            bool box[12][12]={0};\n            \n            for(int i=1; i<=10; i++){\n                for(int j=1; j<=10; j++){\n                    cin>>box[i][j];\n                }\n            }\n            //cout<<\"----------------------\"<<endl;\n            \n            bool box2[12][12]={0};\n            \n            for(int i=0; i<(1<<11 - 1); i++){\n                memcpy(box2, box, sizeof(box));\n                int l[12][12]={0};\n                for(int j=1; j<=10; j++){\n                    l[0][j]= (i>>(j-1))%2;\n                    //cout<<l[0][j];\n                }\n                \n                //cout<<endl;\n                \n                for(int j=1; j<=10; j++){\n                    for(int k=1; k<=10; k++){\n                        if(l[j-1][k]==1){\n                            box2[j][k]=(box2[j][k]+1)%2;\n                            box2[j][k+1]=(box2[j][k+1]+1)%2;\n                            box2[j][k-1]=(box2[j][k-1]+1)%2;\n                            box2[j-1][k]=(box2[j-1][k]+1)%2;\n                            box2[j+1][k]=(box2[j+1][k]+1)%2;\n                        }\n                    }\n                    \n                    for(int k=1; k<=10; k++){\n                        l[j][k]=box2[j][k];\n                    }\n                }\n                \n                bool end_flag=true;\n                for(int i=1; i<=10; i++){\n                    if(l[10][i]==1){\n                        end_flag=false;\n                        break;\n                    }\n                }\n                \n                \n                if(end_flag){\n                    for(int i=0; i<=9; i++){\n                        for(int j=1; j<=10; j++){\n                            cout<<l[i][j];\n                            if(j==10)break;\n                            cout<<\" \";\n                        }\n                        cout<<endl;\n                    }\n                    break;\n                    \n                }\n            }\n            //cout<<\"============================\"<<endl;\n            \n            \n\n        }\n                \n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Doctor's Strange Particles\n//Level: 2\n//Category: 全探索\n//Note: \n\n/**\n * 一番上の行に対する照射方法を固定すると、それより下の行が全て一意に決まる。\n * したがって、一番上の行だけを全探索してシミュレーションすればよい。\n *\n * オーダーは O(2^W HW)。\n */\n#include <iostream>\n#include <array>\n\nusing namespace std;\n\narray<int,1<<10> eff;\n\nbool solve(bool first) {\n    array<int,10> f;\n    for(int r = 0; r < 10; ++r) {\n        f[r] = 0;\n        for(int c = 0; c < 10; ++c) {\n            int v;\n            cin >> v;\n            f[r] |= (v << c);\n        }\n    }\n\n    array<int,10> ans;\n    for(int pat = 0; pat < (1<<10); ++pat) {\n        int prev = f[0] ^ pat;\n        int pmask = pat;\n        ans[0] = pat;\n        for(int r = 1; r < 10; ++r) {\n            ans[r] = prev;\n            const int tmp = f[r] ^ eff[prev] ^ pmask;\n            pmask = prev;\n            prev = tmp;\n        }\n        if(prev == 0) break;\n    }\n    for(int r = 0; r < 10; ++r) {\n        for(int c = 0; c < 10; ++c) {\n            if(c > 0) cout << ' ';\n            cout << !!(ans[r] & (1<<c));\n        }\n        cout << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    for(int pat = 0; pat < (1<<10); ++pat) {\n        eff[pat] = pat;\n        for(int c = 0; c < 10; ++c) {\n            if(pat & (1<<c)) {\n                if(c > 0) eff[pat] ^= (1<<(c-1));\n                if(c < 9) eff[pat] ^= (1<<(c+1));\n            }\n        }\n    }\n\n    bool first = true;\n    int N;\n    cin >> N;\n    while(N-- && solve(first)) {\n        first = false;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nvoid mark(int mp[10][10],int y,int x){\n  int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx=x+dx[i],ny=y+dy[i];\n    if(nx<0||ny<0||nx>=10||ny>=10)continue;\n    mp[ny][nx]=!mp[ny][nx];\n  }\n  mp[y][x]=!mp[y][x];\n}\n\nbool check(int mp[10][10]){\n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)if(mp[i][j])return 0;\n  return 1;\n}\n\nint main(){\n  int q;\n  cin>>q;\n  while(q--){\n    int mp[10][10];\n    for(int i=0;i<10;i++)for(int j=0;j<10;j++)cin>>mp[i][j];\n\n    int ans[10][10]={};\n    for(int i=0;i<(1<<10)&&!check(mp);i++){\n      for(int j=0;j<10;j++)if((ans[0][j]=((i>>j)%2)))mark(mp,0,j);\n\n      for(int j=1;j<10;j++)\n\tfor(int k=0;k<10;k++)\n\t  if((ans[j][k]=mp[j-1][k]))mark(mp,j,k);\n    }\n\n    for(int i=0;i<10;i++){\n      for(int j=0;j<10;j++){\n\tif(j) cout <<\" \";\n\tcout << ans[i][j];\n\tassert(ans[i][j]==0||ans[i][j]==1);\n      }\n      cout <<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <list>\n\nstd::list<int> dfs(std::vector<std::vector<bool>> &state, const int &idx = 1) {\n\tif (idx < 10) {\n\t\tint res = 0;\n\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\tres <<= 1;\n\t\t\tif (state.at(idx - 1).at(i)) {\n\t\t\t\tres += 1;\n\t\t\t\tfor (const auto &index : { i - 1, i, i + 1 }) {\n\t\t\t\t\tif (index >= 0 && index < 10) {\n\t\t\t\t\t\tstate.at(idx).at(index) = !state.at(idx).at(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (idx != 9) {\n\t\t\t\t\tstate.at(idx + 1).at(i) = !state.at(idx + 1).at(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(state, idx + 1);\n\t\tif (list.size() + idx == 9) {\n\t\t\tlist.push_front(res);\n\t\t\treturn list;\n\t\t}\n\t\telse {\n\t\t\treturn list;\n\t\t}\n\t}\n\telse {\n\t\tbool is_on = false;\n\t\tfor (const auto &cell : state.at(9)) {\n\t\t\tis_on = is_on || cell;\n\t\t}\n\t\tif (is_on) {\n\t\t\treturn std::list<int>{0};\n\t\t}\n\t\telse {\n\t\t\treturn std::list<int>{};\n\t\t}\n\t}\n}\nstd::list<int> solve(std::vector<std::vector<bool>> &state) {\n\tfor (auto i = 0; i < 1023; ++i) {\n\t\tauto copy = state;\n\t\tfor (auto j = 0; j < 10; ++j) {\n\t\t\tif ((i & (1 << j)) != 0) {\n\t\t\t\tfor (const auto &idx : { j - 1, j, j + 1 }) {\n\t\t\t\t\tif (idx >= 0 && idx < 10) {\n\t\t\t\t\t\tcopy.at(0).at(idx) = !copy.at(0).at(idx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcopy.at(1).at(j) = !copy.at(1).at(j);\n\t\t\t}\n\t\t}\n\t\tauto list = dfs(copy);\n\t\tif (list.size() == 9) {\n\t\t\tlist.push_front(i);\n\t\t\treturn list;\n\t\t}\n\t}\n\treturn std::list<int>{};\n}\nint main() {\n\tint n;\n\tfor (std::cin >> n; n > 0; --n) {\n\t\tstd::vector<std::vector<bool>> state(10, std::vector<bool>(10, false));\n\t\tbool input;\n\t\tfor (auto &line : state) {\n\t\t\tfor (auto i = 0; i < 10; ++i) {\n\t\t\t\tstd::cin >> input;\n\t\t\t\tline.at(i) = input;\n\t\t\t}\n\t\t}\n\t\tauto res = solve(state);\n\t\tfor (const auto &line : res) {\n\t\t\tfor (auto i = 512; i > 0; i >>= 1) {\n\t\t\t\tstd::cout << static_cast<int>((i & (line)) != 0) << ((i != 1) ? ' ' : '\\n');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int H = 10;\nconst int W = 10;\nint G[H][W];\nint ans[H][W];\n\nvoid put(int i, int j) {\n  static int di[] = {0,1,0,-1,0};\n  static int dj[] = {1,0,-1,0,0};\n  for(int k = 0; k < 5; ++k) {\n    int ni = i + di[k];\n    int nj = j + dj[k];\n    if(ni < 0 || ni >= H) continue;\n    if(nj < 0 || nj >= W) continue;\n    G[ni][nj] ^= 1;\n  }\n}\n\nbool rec(int i, int j) {\n  if(j == W) {\n    ++i;\n    j = 0;\n  }\n\n  if(i == H) {\n    for(int j = 0; j < W; ++j) {\n      if(G[H-1][j]) return false;\n    }\n    return true;\n  }\n\n  if(i == 0) {\n    ans[i][j] = 0;\n    if(rec(i, j+1)) return true;\n    ans[i][j] = 1;\n    put(i, j);\n    if(rec(i, j+1)) return true;\n    put(i, j);\n  } else {\n    if(G[i-1][j]) {\n      ans[i][j] = 1;\n      put(i, j);\n      if(rec(i, j+1)) return true;\n      put(i, j);\n    } else {\n      ans[i][j] = 0;\n      if(rec(i, j+1)) return true;\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  while(n--) {\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        cin >> G[i][j];\n      }\n    }\n    rec(0, 0);\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        if(j) cout << \" \";\n        cout << ans[i][j];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool canPut(int y, int x){\n\tint sy = y - 1;\n\tint ty = y + 1;\n\tint sx = x - 1;\n\tint tx = x + 1;\n\tif(sy < 0 || ty >= 10 || sx < 0 || tx >= 10)return false;\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1 && canPut(ny, nx)){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(!canPut(y, x)){\n\t\treturn dfs(n + 1);\n\t}\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tdfs(0);\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tif(t > 0)cout << endl;\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tif(y > 0)cout << endl;\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tif(x > 0)cout << \" \";\n\t\t\t\tcout << used[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nint board[12][12];\nint used[12][12];\n\nbool lastCheck(){\n\tfor(int y=0;y<10;y++){\n\t\tfor(int x=0;x<10;x++){\n\t\t\tif(board[y][x])return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool canPut(int y, int x){\n\tint sy = y - 1;\n\tint ty = y + 1;\n\tint sx = x - 1;\n\tint tx = x + 1;\n\tif(sy < 0 || ty >= 10 || sx < 0 || tx >= 10)return false;\n\treturn true;\n}\n\nbool allow(int n){\n\tfor(int i=0;i<n;i++){\n\t\tint y = i / 10;\n\t\tint x = i % 10;\n\n\t\tif(board[y][x] == 0)continue;\n\n\t\tbool ok = false;\n\t\tfor(int j=n;j<100;j++){\n\t\t\tint ny = j / 10;\n\t\t\tint nx = j % 10;\n\n\t\t\tint dy = abs(ny - y);\n\t\t\tint dx = abs(nx - x);\n\n\t\t\tif(dy >= 2)break;\n\t\t\tif(dy + dx <= 1 && canPut(ny, nx)){\n\t\t\t\tok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(!ok)return false;\n\t}\n\treturn true;\n}\n\nint pattern[] = {\n    0,1,0,\n    1,1,1,\n    0,1,0\n};\n\nvoid flip(int y, int x){\n\tint sy = y - 1;\n\tint sx = x - 1;\n\tfor(int i=0;i<3;i++)for(int j=0;j<3;j++){\n\t\tint ny = sy + i;\n\t\tint nx = sx + j;\n\t\tif(pattern[i*3+j]){\n\t\t\tboard[ny][nx] ^= 1;\n\t\t}\n\t}\n}\n\nbool dfs(int n){\n\tif(n >= 10 * 10){\n\t\treturn lastCheck();\n\t}\n\tif(!allow(n)){\n\t\treturn false;\n\t}\n\tint y = n / 10;\n\tint x = n % 10;\n\n\tif(!canPut(y, x)){\n\t\treturn dfs(n + 1);\n\t}\n\n\tif(dfs(n + 1)){\n\t\treturn true;\n\t}\n\n\tflip(y, x);\n\tused[y][x] = 1;\n\n\tif(dfs(n + 1))return true;\n\t\n\tused[y][x] = 0;\n\tflip(y, x);\n\n\treturn false;\n}\n\nvoid solve(){\n\tmemset(used, 0, sizeof(used));\n\tif(!dfs(0)){\n\t\twhile(1);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin >> n;\n\n\tfor(int t=0;t<n;t++){\n\t\tif(t > 0)cout << endl;\n\t\tfor(int y=0;y<10;y++){\n\t\t\tfor(int x=0;x<10;x++)cin >> board[y][x];\n\t\t}\n\t\tsolve();\n\t\tfor(int y=0;y<10;y++){\n\t\t\tif(y > 0)cout << endl;\n\t\t\tfor(int x=0;x<10;x++){\n\t\t\t\tif(x > 0)cout << \" \";\n\t\t\t\tcout << used[y][x];\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++>h>\nusing namespace std;\n\nint c[10][10];\nint f[10][10];\nbool s[10][10];\nint hanten[2] = { 1,0 };\nint dx[5] = { -1,0,0,1,0 }, dy[5] = { 0,-1,1,0,0 };\nint main() {\n\tint a; cin >> a;\n\tfor (int b = 0; b < a; b++) {\n\t\tmemset(s, false, sizeof(s));\n\t\tfor (int d = 0; d < 10; d++) {\n\t\t\tfor (int e = 0; e < 10; e++) {\n\t\t\t\tscanf(\"%d\",&c[d][e]);\n\t\t\t}\n\t\t}\n\t\tfor (int g = 0; g < 1024; g++) {\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tf[h][i] = c[h][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 0; h < 10; h++) {\n\t\t\t\tif (g & (1 << h)) {\n\t\t\t\t\ts[0][h] = true;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tint x = dx[i], y = h + dy[i];\n\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int h = 1; h < 10; h++) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tif (f[h - 1][i]) {\n\t\t\t\t\t\ts[h][i] = true;\n\t\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\t\tint x = h+dx[j], y = i + dy[j];\n\t\t\t\t\t\t\tif (x >= 0 && x < 10 && y >= 0 && y < 10) {\n\t\t\t\t\t\t\t\tf[x][y] = hanten[f[x][y]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool K = true;\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (f[i][j])K = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (K) {\n\t\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\t\tif (j)cout << \" \";\n\t\t\t\t\t\tcout << s[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tcout << endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define SIZE 10\nusing namespace std;\n\nclass State{\npublic:\n  int data[SIZE][SIZE];\n  int put[SIZE][SIZE];\n  State() {\n    fill((int*)put, (int*)put+SIZE*SIZE, 0);\n  }\n  void puts(int x, int y) {\n    static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n    put[y][x] = 1;\n    for(int k = 0; k < 5; k++) {\n      int nx = x + d[k][0];\n      int ny = y + d[k][1];\n      data[ny][nx] = -(data[ny][nx] - 1);\n    }\n  }\n  bool isAll0() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tif(data[i][j] != 0) return false;\n      }\n    }\n    return true;\n  }\n  void show() {\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcout << put[i][j];\n      }\n      cout << endl;\n    }\n  }\n};\n\nbool rec(State s, int x, int y) {\n  static int d[5][2] = {{0,-1},{1,0},{0,1},{-1,0},{0,0}};\n  if(s.isAll0()) {\n    s.show();\n    return true;\n  }\n\n  for(int i = y; i < SIZE; i++) {\n    for(int j = x; j < SIZE; j++) {\n      bool flag = false;\n      for(int k = 0; k < 5; k++) {\n\tint nx = j + d[k][0];\n\tint ny = i + d[k][1];\n\tif(nx < 0 || nx >= SIZE) continue;\n\tif(ny < 0 || ny >= SIZE) continue;\n\tif(s.data[ny][nx] == 1) {\n\t  flag = true;\n\t  break;\n\t}\n      }\n      if(flag) {\n\tif(i > 0 && s.data[i-1][j] == 0) continue;\n\tState tmp = s;\n\ttmp.puts(j, i);\n\tint nx, ny;\n\tnx = j + 1;\n\tny = i;\n\tif(nx >= SIZE) {\n\t  nx = 0;\n\t  ny++;\n\t}\n\tif(rec(tmp, nx, ny)) {\n\t  return true;\n\t}\n\tif(i > 0 && s.data[i-1][j] == 1) return false;\n      }\n    }\n  }\n  return false;\n}\n\nmain() {\n  int n;\n  cin >> n;\n  for(int t = 0; t < n; t++) {\n    State s;\n    for(int i = 0; i < SIZE; i++) {\n      for(int j = 0; j < SIZE; j++) {\n\tcin >> s.data[i][j];\n      }\n    }\n    rec(s, 0, 0);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int p[][12],int q[][12],int x){\n  int i,j;\n  int r[12][12],s[12][12];\n  if(x==11){\n    for(i=2;i<10;i++){\n      for(j=1;j<11;j++){\n\tif(p[j][i]){\n\t  p[j  ][i  ]=(p[j  ][i  ]+1)%2;\n\t  p[j-1][i+1]=(p[j-1][i+1]+1)%2;\n\t  p[j  ][i+1]=(p[j  ][i+1]+1)%2;\n\t  p[j+1][i+1]=(p[j+1][i+1]+1)%2;\n\t  p[j  ][i+2]=(p[j  ][i+2]+1)%2;\n\t  q[j][i+1]=1;\n\t}\n      }\n    }\n    for(i=1;i<11;i++){\n      if(p[i][10])\n\tbreak;\n    }\n    if(i==11){\n      for(i=1;i<11;i++){\n\tfor(j=1;j<11;j++)\n\t  cout<<q[j][i];\n\tcout<<endl;\n      }\n      return 1;\n    }\n  }else if(x==10){\n    if(p[x][1]){\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }else{\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      if(f(r,s,x+1))\n\treturn 1;\n    }\n  }else{\n      if(p[x][1]){\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x+1][0]=(r[x+1][0]+1)%2;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x+1][1]=(r[x+1][1]+1)%2;\n      r[x+2][1]=(r[x+2][1]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      s[x+1][1]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }else{\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      if(f(r,s,x+1))\n\treturn 1;\n      memcpy(r,p,sizeof(r));\n      memcpy(s,q,sizeof(s));\n      r[x+1][0]=(r[x+1][0]+1)%2;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x+1][1]=(r[x+1][1]+1)%2;\n      r[x+2][1]=(r[x+2][1]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      s[x+1][1]=1;\n      r[x  ][1]=(r[x  ][1]+1)%2;\n      r[x-1][2]=(r[x-1][2]+1)%2;\n      r[x  ][2]=(r[x  ][2]+1)%2;\n      r[x+1][2]=(r[x+1][2]+1)%2;\n      r[x  ][3]=(r[x  ][3]+1)%2;\n      s[x  ][2]=1;\n      if(f(r,s,x+1))\n\treturn 1;\n    }\n  }\n  return 0;\n}\nint main(){\n  int i,j,k;\n  int q[12][12],r[12][12],n;\n  int (*p)[12][12];\n  cin>>n;\n  p=new int[n][12][12];\n  for(i=0;i<n;i++)\n    for(j=1;j<11;j++)\n      for(k=1;k<11;k++)\n\tcin>>p[i][k][j];\n  for(i=0;i<n;i++){\n    memcpy(r,&p[i][0][0],sizeof(r));\n    memset(q,0,sizeof(q));\n    f(r,q,1);\n    memcpy(r,&p[i][0][0],sizeof(r));\n    memset(q,0,sizeof(q));\n    r[1][0]=(r[1][0]+1)%2;\n    r[0][1]=(r[0][1]+1)%2;\n    r[1][1]=(r[1][1]+1)%2;\n    r[2][1]=(r[2][1]+1)%2;\n    r[1][2]=(r[1][2]+1)%2;\n    q[1][1]=1;\n    f(r,q,1);\n  }\n  delete [] p;\n  return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\nnear (y,x) = filter (\\(i,j) -> 0<=i && i<=9 && 0<=j && j<=9) [(y,x), (y-1,x), (y+1,x), (y,x-1), (y,x+1)]\nthrough :: STArray s (Int,Int) Int -> (Int,Int) -> ST s ()\nthrough arr (y,x) = mapM_ (\\(i,j) -> readArray arr (i,j) >>= writeArray arr (i,j) . (1-)) $ near (y,x)\n\ngetBit n = getBit' 0 n\ngetBit' _ 0 = []\ngetBit' i n = if odd n then i : getBit' (i+1) (n `div` 2) else getBit' (i+1) (n `div` 2)\n\ncalc :: [[Int]] -> Int -> Maybe [(Int,Int)]\ncalc field b = runST $ do\n    arr <- newListArray ((0,0),(9,9)) $ concat field :: ST s (STArray s (Int,Int) Int)\n    res <- newSTRef [] :: ST s (STRef s [(Int,Int)])\n    forM_ (getBit b) $ \\x -> do\n        through arr (0,x)\n        modifySTRef res ((0,x):)\n    forM_ [1..9] $ \\y -> do\n        forM_ [0..9] $ \\x -> do\n            c <- readArray arr (y-1,x)\n            when (c==1) $ do\n                through arr (y,x)\n                modifySTRef res ((y,x):)\n    p <- sequence [readArray arr (9,x) | x <- [0..9]]\n    (guard (all (==0) p) $>) <$> readSTRef res\n\nf field = fromJust $ getFirst $ foldMap First [calc field b | b <- [0..1023]]\n\ncreateField ps = runST $ do\n    arr <- newArray ((0,0),(9,9)) 0 :: ST s (STArray s (Int,Int) Int)\n    forM_ ps $ \\p -> writeArray arr p 1\n    sequence [sjoin <$> sequence [readArray arr (y,x) | x <- [0..9]] | y <- [0..9]]\n\n\nmain = getInt >>= flip replicateM (replicateM 10 getInts) >>= mapM_ (mapM_ putStrLn . createField . f)\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\nnear (y,x) = filter (\\(i,j) -> 0<=i && i<=9 && 0<=j && j<=9) [(y,x), (y-1,x), (y+1,x), (y,x-1), (y,x+1)]\nthrough :: STArray s (Int,Int) Int -> (Int,Int) -> ST s ()\nthrough arr (y,x) = mapM_ (\\(i,j) -> readArray arr (i,j) >>= writeArray arr (i,j) . (1-)) $ near (y,x)\n\ngetBit n = getBit' 0 n\ngetBit' _ 0 = []\ngetBit' i n = if odd n then i : getBit' (i+1) (n `div` 2) else getBit' (i+1) (n `div` 2)\n\ncalc :: [[Int]] -> Int -> Maybe [(Int,Int)]\ncalc field b = runST $ do\n    arr <- newListArray ((0,0),(9,9)) $ concat field :: ST s (STArray s (Int,Int) Int)\n    res <- newSTRef [] :: ST s (STRef s [(Int,Int)])\n    forM_ (getBit b) $ \\x -> do\n        through arr (0,x)\n        modifySTRef res ((0,x):)\n    forM_ [1..9] $ \\y -> do\n        forM_ [0..9] $ \\x -> do\n            c <- readArray arr (y-1,x)\n            when (c==1) $ do\n                through arr (y,x)\n                modifySTRef res ((y,x):)\n    p <- sequence [readArray arr (9,x) | x <- [0..9]]\n    (guard (all (==0) p) $>) <$> readSTRef res\n\nf field = head $ catMaybes [calc field b | b <- [0..1023]]\n\ncreateField ps = runST $ do\n    arr <- newArray ((0,0),(9,9)) 0 :: ST s (STArray s (Int,Int) Int)\n    forM_ ps $ \\p -> writeArray arr p 1\n    sequence [sjoin <$> sequence [readArray arr (y,x) | x <- [0..9]] | y <- [0..9]]\n\n\nmain = getInt >>= flip replicateM (replicateM 10 getInts) >>= mapM_ (mapM_ putStrLn . createField . f)\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport qualified Data.ByteString as BS\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\n--import qualified Data.Sequence as Sequence\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\n--import Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IArray\nimport Data.Array.MArray\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n\n-- templete\nreadInt = read :: String -> Int\nreadInteger = read :: String -> Integer\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetInteger = readLn :: IO Integer\ngetIntegers = map readInteger . words <$> getLine\ngetDouble = readLn :: IO Double\ngetDoubles = map readDouble . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nbinMap :: (a -> a -> b) -> [a] -> [b]\nbinMap f (x:xs@(y:_)) = f x y : binMap f xs\nbinMap _ _ = []\nsplitRec :: Int -> [a] -> [[a]]\nsplitRec _ [] = []\nsplitRec n xs = let (y,ys) = splitAt n xs in y : splitRec n ys\ninfixl 7 `divCeil`\ndivCeil :: Integral a => a -> a -> a\nx `divCeil` y = (x+y-1) `div` y\ncoverC :: Ord a => (a, a) -> a -> Bool\ncoverC (l,r) x = l<=x && x<=r\ncoverH :: Ord a => (a, a) -> a -> Bool\ncoverH (l,r) x = l<=x && x<r\n-- templete\n\nnear (y,x) = filter (\\(i,j) -> 0<=i && i<=9 && 0<=j && j<=9) [(y,x), (y-1,x), (y+1,x), (y,x-1), (y,x+1)]\nthrough :: STArray s (Int,Int) Int -> (Int,Int) -> ST s ()\nthrough arr (y,x) = mapM_ (\\(i,j) -> readArray arr (i,j) >>= writeArray arr (i,j) . (1-)) $ near (y,x)\n\ngetBit n = getBit' 0 n\ngetBit' _ 0 = []\ngetBit' i n = if odd n then i : getBit' (i+1) (n `div` 2) else getBit' (i+1) (n `div` 2)\n\ncalc :: [[Int]] -> Int -> Maybe [(Int,Int)]\ncalc field b = runST $ do\n    arr <- newListArray ((0,0),(9,9)) $ concat field :: ST s (STArray s (Int,Int) Int)\n    res <- newSTRef [] :: ST s (STRef s [(Int,Int)])\n    forM_ (getBit b) $ \\x -> do\n        through arr (0,x)\n        modifySTRef res ((0,x):)\n    forM_ [1..9] $ \\y -> do\n        forM_ [0..9] $ \\x -> do\n            c <- readArray arr (y-1,x)\n            when (c==1) $ do\n                through arr (y,x)\n                modifySTRef res ((y,x):)\n    p <- sequence [readArray arr (9,x) | x <- [0..9]]\n    (guard (all (==0) p) $>) <$> readSTRef res\n\nf field = fromJust $ getFirst $ Foldable.foldMap First [calc field b | b <- [0..1023]]\n\ncreateField ps = runST $ do\n    arr <- newArray ((0,0),(9,9)) 0 :: ST s (STArray s (Int,Int) Int)\n    forM_ ps $ \\p -> writeArray arr p 1\n    sequence [sjoin <$> sequence [readArray arr (y,x) | x <- [0..9]] | y <- [0..9]]\n\n\nmain = getInt >>= flip replicateM (replicateM 10 getInts) >>= mapM_ (mapM_ putStrLn . createField . f)\n"
  },
  {
    "language": "C",
    "code": "d,x,y,l,M[10],m[10],a[10];\nmain(){\n\tscanf(\"%*d\");\n\tfor(;~scanf(\"%d\",&d);){\n\t\tl=l*2+d;\n\t\tif(++x==10){\n\t\t\tM[y]=l;\n\t\t\tx=l=0;\n\t\t\tif(++y==10){\n\t\t\t\tfor(d=0;d<1<<10;d++){\n\t\t\t\t\tmemcpy(m,M,sizeof(m));\n\t\t\t\t\tl=d;\n\t\t\t\t\tfor(y=0;y<10;y++){\n\t\t\t\t\t\ta[y]=l;\n\t\t\t\t\t\tm[y]^=(l^l<<1^l>>1)&0x3ff;\n\t\t\t\t\t\tif(y+1<10)\n\t\t\t\t\t\t\tm[y+1]^=l;\n\t\t\t\t\t\tl=m[y];\n\t\t\t\t\t}\n\t\t\t\t\tif(m[9]==0){\n\t\t\t\t\t\tfor(y=0;y<10;y++)\n\t\t\t\t\t\t\tfor(x=10;x--;)\n\t\t\t\t\t\t\t\tprintf(\"%d%c\",a[y]>>x&1,x?' ':'\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=y=l=0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "d,x,y,l,M[10],m[10],a[10];\nmain(){\n\tscanf(\"%*d\");\n\tfor(;~scanf(\"%d\",&d);){\n\t\tl=l*2+d;\n\t\tif(++x==10){\n\t\t\tM[y]=l;\n\t\t\tx=l=0;\n\t\t\tif(++y==10){\n\t\t\t\tfor(d=0;d<1<<10;d++){\n\t\t\t\t\tmemcpy(m,M,sizeof(m));\n\t\t\t\t\ta[0]=l=d;\n\t\t\t\t\tfor(y=0;y<10;y++){\n\t\t\t\t\t\tm[y]^=l^l<<1^l>>1;\n\t\t\t\t\t\tif(y+1<10){\n\t\t\t\t\t\t\tm[y+1]^=l;\n\t\t\t\t\t\t\ta[y+1]=l=m[y];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(m[9]==0){\n\t\t\t\t\t\tfor(y=0;y<10;y++)\n\t\t\t\t\t\t\tfor(x=10;x--;)\n\t\t\t\t\t\t\t\tprintf(\"%d%c\",a[y]>>x&1,x?' ':'\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=y=l=0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nvoid xor(int map[][10], int y, int x)\n{\n    int i, j;\n    \n    for (i = -1; i <= 1; i++){\n        for (j = -1; j <= 1; j++){\n            if ((i == 0 || j == 0) && 0 <= y + i && y + i < 10\n                    && 0 <= x + j && x + j < 10){\n                map[y + i][x + j] ^= 1;\n            }\n        }\n    }\n}\n\nint main(void)\n{\n    int map[10][10], ans[10][10], rec[10][10];\n    int i, j, k;\n    int n;\n    int flag;\n    \n    scanf(\"%d\", &n);\n    \n    while (n-- != 0){\n        memset(map, 0, sizeof(map));\n        for (i = 0; i < 10; i++){\n            for (j = 0; j < 10; j++){\n                scanf(\"%d\", &map[i][j]);\n            }\n        }\n        \n        memcpy(rec, map, sizeof(map));\n        \n        for (i = 0; i < 1024; i++){\n            memset(ans, 0, sizeof(ans));\n            memcpy(map, rec, sizeof(rec));\n            for (j = 0; j < 10; j++){\n                if ((i >> j) & 1){\n                    ans[0][j] = 1;\n                    xor(map, 0, j);\n                }\n            }\n            \n            for (j = 1; j < 10; j++){\n                for (k = 0; k < 10; k++){\n                    if (map[j - 1][k] == 1){\n                        ans[j][k] = 1;\n                        xor(map, j, k);\n                    }\n                }\n            }\n            \n            flag = 1;\n            for (j = 0; j < 10; j++){\n                for (k = 0; k < 10; k++){\n                    if (map[j][k] != 0){\n                        flag = 0;\n                    }\n                }\n            }\n            \n            if (flag == 1){\n                for (j = 0; j < 10; j++){\n                    for (k = 0; k < 10; k++){\n                        printf(\"%d%c\", ans[j][k], k == 9 ? '\\n' : ' ');\n                    }\n                }\n                break;\n            }\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint d[15][15],e[15][15],a[15][15],f[15];\nint dx[]={-1,0,0,0,1};\nint dy[]={0,-1,0,1,0};\nint func(){\n\tint i,j,k,r=0;\n\tfor(i=2;i<=10;i++){\n\t\tfor(j=1;j<=10;j++){\n\t\t\tif(e[i-1][j]%2==1){\n\t\t\t\ta[i][j]=1;\n\t\t\t\t//e[i-1][j]++;\n\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\te[i+dy[k]][j+dx[k]]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(i=1;i<=10;i++)if(e[10][i]%2==1)r++;\n\treturn r;\n}\nint main(){\n\tint i,j,k,n;\n\tFILE *fp;\n\t//fp=fopen(\"test.txt\",\"r\");\n\tfp=stdin;\n\tfscanf(fp,\"%d\",&n);\n\twhile(n--){\n\t\tfor(i=1;i<=10;i++)for(j=1;j<=10;j++)fscanf(fp,\"%d\",&d[i][j]);\n\t\tfor(i=0;i<(1<<10);i++){\n\t\t\tmemset(a,0,sizeof(a));\n\t\t\tmemcpy(e,d,sizeof(d));\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(!( (i>>j)&1 )){\n\t\t\t\t\ta[1][j+1]=1;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\te[1+dy[k]][j+1+dx[k]]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(func()==0){\n\t\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\t\tfor(k=1;k<=10;k++){\n\t\t\t\t\t\tprintf(\"%d%s\",a[j][k],(k==10)?\"\\n\":\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint map[10][10];\nint result[10][10];\n\nint main(void) {\n\tint dataset_num,dataset_current;\n\tint i,j;\n\tscanf(\"%d\",&dataset_num);\n\tfor(dataset_current=0;dataset_current<dataset_num;dataset_current++) {\n\t\tfor(i=0;i<10;i++) {\n\t\t\tfor(j=0;j<10;j++) {\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tresult[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<9;i++) {\n\t\t\tfor(j=1;j<9;j++) {\n\t\t\t\tif(map[i-1][j] && map[i][j-1]) {\n\t\t\t\t\tif(map[i-1][j-1]) {\n\t\t\t\t\t\tresult[i-1][j-1]=1;\n\t\t\t\t\t\tif(i>1)map[i-2][j-1]=!map[i-2][j-1];\n\t\t\t\t\t\tif(j>1)map[i-1][j-2]=!map[i-1][j-2];\n\t\t\t\t\t\tmap[i-1][j-1]=!map[i-1][j-1];\n\t\t\t\t\t\tmap[i][j-1]=!map[i][j-1];\n\t\t\t\t\t\tmap[i-1][j]=!map[i-1][j];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult[i][j]=1;\n\t\t\t\t\t\tmap[i][j-1]=!map[i][j-1];\n\t\t\t\t\t\tmap[i-1][j]=!map[i-1][j];\n\t\t\t\t\t\tmap[i][j]=!map[i][j];\n\t\t\t\t\t\tmap[i][j+1]=!map[i][j+1];\n\t\t\t\t\t\tmap[i+1][j]=!map[i+1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(map[i-1][j] && map[i][j+1]) {\n\t\t\t\t\tif(map[i-1][j+1]) {\n\t\t\t\t\t\tresult[i-1][j+1]=1;\n\t\t\t\t\t\tif(i>1)map[i-2][j+1]=!map[i-2][j+1];\n\t\t\t\t\t\tif(j<8)map[i-1][j+2]=!map[i-1][j+2];\n\t\t\t\t\t\tmap[i-1][j+1]=!map[i-1][j+1];\n\t\t\t\t\t\tmap[i][j+1]=!map[i][j+1];\n\t\t\t\t\t\tmap[i-1][j]=!map[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(map[i+1][j] && map[i][j-1]) {\n\t\t\t\t\tif(map[i+1][j-1]) {\n\t\t\t\t\t\tresult[i+1][j-1]=1;\n\t\t\t\t\t\tif(i<8)map[i+2][j-1]=!map[i+2][j-1];\n\t\t\t\t\t\tif(j>1)map[i+1][j-2]=!map[i+1][j-2];\n\t\t\t\t\t\tmap[i+1][j-1]=!map[i+1][j-1];\n\t\t\t\t\t\tmap[i][j-1]=!map[i][j-1];\n\t\t\t\t\t\tmap[i+1][j]=!map[i+1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(map[i+1][j] && map[i][j+1]) {\n\t\t\t\t\tif(map[i+1][j+1]) {\n\t\t\t\t\t\tresult[i+1][j+1]=1;\n\t\t\t\t\t\tif(i<8)map[i+2][j+1]=!map[i+2][j+1];\n\t\t\t\t\t\tif(j<8)map[i+1][j+2]=!map[i+1][j+2];\n\t\t\t\t\t\tmap[i+1][j+1]=!map[i+1][j+1];\n\t\t\t\t\t\tmap[i][j+1]=!map[i][j+1];\n\t\t\t\t\t\tmap[i+1][j]=!map[i+1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++) {\n\t\t\tfor(j=0;j<9;j++) {\n\t\t\t\tprintf(\"%d \",result[i][j]);\n\t\t\t}\n\t\t\tprintf(\"%d\\n\",result[i][9]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint a[10][10],c[10][10];\nvoid f(int x,int y){\n  int ny,nx,i,j;\n  int X[]={0,0,1,0,-1};\n  int Y[]={0,1,0,-1,0};\n  a[y][x]=1;\n  for(i=0;i<5;i++){\n    nx=x+X[i];\n    ny=y+Y[i];\n    if(nx<0||ny<0||9<ny||9<nx)continue;\n    c[ny][nx]=1-c[ny][nx];\n  }\n}\nint main(){\n  int n,d[10][10],i,j,k,s;\n  scanf(\"%d\",&n);\n  while(n--){\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++)scanf(\"%d\",&d[i][j]);\n    }\n    for(i=0;i<1<<10;i++){\n      for(j=0;j<100;j++){\n\ta[j/10][j%10]=0;\n\tc[j/10][j%10]=d[j/10][j%10];\n      }\n      for(j=0;j<10;j++){\n\tif(i&1<<j)f(j,0);\n      }\n      for(j=0;j<9;j++){\n\tfor(k=0;k<10;k++){\n\t  if(c[j][k])f(k,j+1);\n\t}\n      }\n      for(j=s=0;j<10;j++)s+=c[9][j];\n      if(s==0)break;\n    }//printf(\"%d\\n\",i);\n    for(i=0;i<10;i++){\n      for(j=0;j<10;j++){\n\tif(j)printf(\" \");\n\tprintf(\"%d\",a[i][j]);\n      }\n      printf(\"\\n\");\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint status[12][12];\nint bombloc[12][12];\n\n\nint isbomb(int x,int y){\nint tv=0;\ntv += status[x][y];\ntv += status[x-1][y];\ntv += status[x+1][y];\n  tv += status[x][y-1];\n  tv += status[x][y+1];\n  if (tv>2) return 1; else return 0;\n}\nvoid bombed(int x,int y){\nstatus[x][y] = (status[x][y]==0);\nstatus[x+1][y] = (status[x+1][y]==0);\nstatus[x-1][y] = (status[x-1][y]==0);\nstatus[x][y+1] = (status[x][y+1]==0);\nstatus[x][y-1] = (status[x][y-1]==0);\n}\n\nint main(){\nint x,y;\n\nfor (x=1;x<=10;x++){\nfor (y=1;y<=10;y++){\n      scanf(\"%d\",&status[x][y]);\n    }\n  }\n  for (x=2;x<10;x++){\n    status[x][0]=status[x][2];\n    status[x][11]=status[x][9];\n  }\n  status[1][0]=status[1][1];\n  status[1][11]=status[1][10];\n  status[10][0]=status[10][1];\n  status[10][11]=status[10][10];\n\n  for (y=2;y<10;y++){\n    status[0][y]=status[1][y];\n    status[11][y]=status[10][y];\n  }\n  status[0][1]=status[2][1];\n  status[11][1]=status[9][1];\nstatus[0][10]=status[2][10];\nstatus[11][10]=status[9][10];\n\nfor (y=2;y<=9;y++){\nfor (x=2;x<=9;x++){\n      if (isbomb(x,y)){\n\tbombloc[x][y]=1;\n\tbombed(x,y);\n      } else bombloc[x][y]=0;\n    }\n  }\n\n  for (y=1;y<=10;y++){\n    printf(\"%d\",bombloc[1][y]);\n    for (x=2;x<=10;x++){\n      printf(\" %d\",bombloc[y][x]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "d,x,y,l,M[10],m[10],a[10];\nmain(){\n\tscanf(\"%*d\");\n\tfor(;~scanf(\"%d\",&d);){\n\t\tl=l*2+d;\n\t\tif(++x==10){\n\t\t\tM[y]=l;\n\t\t\tx=l=0;\n\t\t\tif(++y==10){\n\t\t\t\tfor(d=0;d<1<<10;d++){\n\t\t\t\t\tmemcpy(m,M,sizeof(m));\n\t\t\t\t\ta[0]=l=d;\n\t\t\t\t\tfor(y=0;y<9;y++){\n\t\t\t\t\t\tm[y]^=l^l<<1^l>>1;\n\t\t\t\t\t\tm[y+1]^=l;\n\t\t\t\t\t\ta[y+1]=l=m[y];\n\t\t\t\t\t}\n\t\t\t\t\tif(a[9]==0){\n\t\t\t\t\t\tfor(y=0;y<10;y++)\n\t\t\t\t\t\t\tfor(x=10;x--;)\n\t\t\t\t\t\t\t\tprintf(\"%d%c\",a[y]>>x&1,x?' ':'\\n');\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx=y=l=0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "int table[100][100] = {\n  {1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,},\n  {0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,},\n  {1,0,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,},\n  {0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,},\n  {1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,},\n  {0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,},\n  {1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,},\n  {1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,},\n  {0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,},\n  {0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,},\n  {0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,},\n  {0,1,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,},\n  {1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,},\n  {0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,0,0,},\n  {1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,0,},\n  {0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,},\n  {0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,},\n  {0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,},\n  {1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,},\n  {0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,},\n  {1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,},\n  {1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,},\n  {0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,},\n  {0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,0,},\n  {0,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,0,1,0,},\n  {1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,},\n  {1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,},\n  {0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,},\n  {1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,},\n  {1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,0,1,},\n  {0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,},\n  {0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,},\n  {0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,},\n  {0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,},\n  {0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,},\n  {0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,},\n  {0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,},\n  {0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,},\n  {1,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,},\n  {0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,},\n  {1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,},\n  {1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,0,},\n  {0,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,},\n  {0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,},\n  {0,1,1,1,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,0,},\n  {1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,},\n  {1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,},\n  {1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,1,},\n  {0,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,},\n  {0,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,},\n  {0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,},\n  {0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,1,1,0,},\n  {1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,1,},\n  {0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,},\n  {1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,},\n  {0,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,1,1,1,0,},\n  {1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,},\n  {0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,},\n  {0,0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,},\n  {0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,},\n  {1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,},\n  {0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,0,1,},\n  {1,0,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,},\n  {0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,},\n  {1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,},\n  {1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,},\n  {0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,},\n  {0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,},\n  {0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,},\n  {0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,},\n  {1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,},\n  {0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,},\n  {0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,},\n  {0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,},\n  {1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,},\n  {0,1,0,1,0,0,0,1,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,1,1,0,},\n  {0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,},\n  {0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,},\n  {0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,},\n  {0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,},\n  {0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,},\n  {1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,},\n  {1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,},\n  {1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,},\n  {0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,1,0,1,0,1,0,},\n  {0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,},\n  {0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,},\n  {0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,},\n  {0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,},\n  {0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,0,},\n  {0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,},\n  {0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,},\n  {1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,},\n  {0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,},\n  {0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,},\n  {0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,},\n  {0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,},\n  {0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,1,0,1,},\n  {0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,1,0,0,0,0,0,0,},\n  {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,},\n};\nint prob[100], ans[100];\n\nmain(b,c,i,j){\n  for(scanf(\"%d\",&c);b<=c;b++){\n    //printf(\"PUZZLE #%d\\n\",b);\n    for(i=0;i<100;i++)\n      scanf(\"%d\",prob+i),ans[i]=0;\n    for(i=0;i<100;i++)\n      if(prob[i])\n        for(j=0;j<100;j++)\n          ans[j]^=table[i][j];\n    for(j=0;j<10;printf(\"\\n\"),j++)\n      for(i=0;i<10;i++)\n        printf(i<9?\"%d \":\"%d\",ans[i+j*10]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n\nconst int pos[5][2] = {\n    {0, 0}, {-1, 1}, {0, 1}, {1, 1}, {0, 2}\n};\n\nint main(void) {\n    int n, i, j, k;\n    int s[10][10], p[10][10];\n\n    scanf(\"%d\", &n);\n\n    while (n--) {\n        for (i = 0; i < 10; i++) {\n            for (j = 0; j < 10; j++) {\n                scanf(\"%d\", &(s[i][j]));\n                p[i][j] = 0;\n            }\n        }\n\n        for (i = 0; i < 8; i++) {\n            for (j = 1; j < 9; j++) {\n                if (s[i][j] == 1) {\n                    for (k = 0; k < 5; k++) {\n                        s[i+pos[k][1]][j+pos[k][0]] ^= 1;\n                    }\n                    p[i+1][j] = 1;\n                }\n            }\n        }\n        for (i = 0; i < 10; i++) {\n            for (j = 0; j < 9; j++) {\n                printf(\"%d \", p[i][j]);\n            }\n            printf(\"%d\\n\", p[i][9]);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define N 14\n\nvoid print_map(int map[N][N]){\n  int j,k;\n\n  puts(\"\");\n  for(j=0;j<N;j++){\n    for(k=0;k<N;k++)\n      printf(\"%d \",map[j][k]);\n    puts(\"\");\n  }\n\n  return ;\n}\n\nvoid print_ans_map(int map[N][N]){\n  int j,k;\n\n  for(j=2;j<N-2;j++){\n    for(k=2;k<N-2;k++){\n      printf(\"%d\",map[j][k]);\n      if(k<N-3)\n        printf(\" \");\n    }\n    puts(\"\");\n  }\n\n  return ;\n}\n\nvoid copy_map(int map[N][N],int pre_map[N][N]){\n  int j,k;\n\n  for(j=0;j<N;j++)\n    for(k=0;k<N;k++)\n      pre_map[j][k]=map[j][k];\n}\n\nint inverse_map3(int map[N][N],int j,int k){\n  int count,maxC;\n  int p; // 0:situ(jap:sonoba) 1:up 2:down 3:left 4:right\n\n  maxC=0;\n\n  count=0;\n  count+=map[j-1][k];\n  count+=map[j+1][k];\n  count+=map[j][k-1];\n  count+=map[j][k+1];\n  if(maxC<count){\n    maxC=count;\n    p=0;\n  }\n\n  count=0;\n  count+=map[j-1-1][k];\n  count+=map[j-1+1][k];\n  count+=map[j-1][k-1];\n  count+=map[j-1][k+1];\n  if(maxC<count){\n    maxC=count;\n    p=1;\n  }\n\n  count=0;\n  count+=map[j+1-1][k];\n  count+=map[j+1+1][k];\n  count+=map[j+1][k-1];\n  count+=map[j+1][k+1];\n  if(maxC<count){\n    maxC=count;\n    p=2;\n  }\n\n  count=0;\n  count+=map[j-1][k-1];\n  count+=map[j+1][k-1];\n  count+=map[j][k-1-1];\n  count+=map[j][k-1+1];\n  if(maxC<count){\n    maxC=count;\n    p=3;\n  }\n\n  count=0;\n  count+=map[j-1][k+1];\n  count+=map[j+1][k+1];\n  count+=map[j][k+1-1];\n  count+=map[j][k+1+1];\n  if(maxC<count){\n    p=4;\n  }\n\n  return p;\n}\n\nvoid inverse_map2(int map[N][N],int j,int k){\n  map[j][k]++;\n  map[j-1][k]++;\n  map[j+1][k]++;\n  map[j][k-1]++;\n  map[j][k+1]++;\n\n  map[j][k]%=2;\n  map[j-1][k]%=2;\n  map[j+1][k]%=2;\n  map[j][k-1]%=2;\n  map[j][k+1]%=2;\n}\n\nvoid inverse_map_recursion(int map[N][N],int ans_map[N][N],int j,int k){\n\n  if(map[j][k]>0){\n    if(inverse_map3(map,j,k)==0 && ans_map[j][k]==0){\n      ans_map[j][k]=1;\n      inverse_map2(map,j,k);\n    }else if(inverse_map3(map,j,k)==1 && ans_map[j-1][k]==0){\n      ans_map[j-1][k]=1;\n      inverse_map2(map,j-1,k);\n    }else if(inverse_map3(map,j,k)==2 && ans_map[j+1][k]==0){\n      ans_map[j+1][k]=1;\n      inverse_map2(map,j+1,k);\n    }else if(inverse_map3(map,j,k)==3 && ans_map[j][k-1]==0){\n      ans_map[j][k-1]=1;\n      inverse_map2(map,j,k-1);\n    }else if(inverse_map3(map,j,k)==4 && ans_map[j][k+1]==0){\n      ans_map[j][k+1]=1;\n      inverse_map2(map,j,k+1);\n    }\n  }\n  k++;\n  if(k>=12){\n    k=2;\n    j++;\n  }\n  if(j>=12)\n    return ;\n  inverse_map_recursion(map,ans_map,j,k);\n}\n\nint main(void){\n  int i,j,k;\n  int n;\n  int map[N][N];\n  int ans_map[N][N];\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++){\n\n    for(j=0;j<N;j++)\n      for(k=0;k<N;k++){\n        map[j][k]=0;\n        ans_map[j][k]=0;\n      }\n\n    for(j=2;j<12;j++)\n      for(k=2;k<12;k++)\n        scanf(\"%d\",&map[j][k]);\n\n    inverse_map_recursion(map,ans_map,2,2);\n\n    print_ans_map(ans_map);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint i,j,n,s[12][12],a[12][12];\n\tscanf(\"%d\",&n);\n\twhile(1){\n\t\tfor(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(i=0;i<9;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(s[i][j]%2==1){\n\t\t\t\t\ta[i+1][j]=1;\n\t\t\t\t\ts[i][j]++;\n\t\t\t\t\ts[i+1][j]++;\n\t\t\t\t\ts[i+1][j-1]++;\n\t\t\t\t\ts[i+1][j+1]++;\n\t\t\t\t\ts[i+2][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf(), getchar()\n#include <string.h>         // memset()\n#include <stdbool.h>\n\n#define SZ_MATRIX 10\n\nshort lights[SZ_MATRIX][SZ_MATRIX];\nshort turn[SZ_MATRIX][SZ_MATRIX];\n\nbool\nget(int x, int y)\n{\n\tconst int dx[5] = {-1, 0, 0, 0, 1};\n\tconst int dy[5] = { 0,-1, 0, 1, 0};\n\n\tint c = lights[y][x];\n\tfor (int i = 0; i < 5; ++i)\n\t{\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx && nx < SZ_MATRIX && 0 <= ny && ny < SZ_MATRIX)\n\t\t\tc += turn[ny][nx];\n\t}\n\n\treturn (c % 2) != 0;\n}\n\nbool\ncalc()\n{\n\tfor (int y = 1; y < SZ_MATRIX; ++y)\n\t{\n\t\tfor (int x = 0; x < SZ_MATRIX; ++x)\n\t\t{\n\t\t\tif (get(x, y - 1))\n\t\t\t\tturn[y][x] = 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < SZ_MATRIX; ++x)\n\t{\n\t\tif (get(x, SZ_MATRIX - 1))\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid\nsolve()\n{\n\tfor (int i = 0; i < (1 << SZ_MATRIX); ++i)\n\t{\n\t\tmemset(turn, 0, sizeof(turn));\n\t\tfor (int j = 0; j < SZ_MATRIX; ++j)\n\t\t\tturn[0][SZ_MATRIX - j - 1] = (i >> j) & 1;\n\n\t\tif (calc())\n\t\t\tbreak;\n\t}\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint n;\n\tscanf(\"%d\\n\", &n);\n\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tfor (int y = 0; y < SZ_MATRIX; ++y)\n\t\t{\n\t\t\tint c;\n\t\t\tfor (int x = 0; x < SZ_MATRIX; ++x)\n\t\t\t{\n\t\t\t\tc = getchar();\n\t\t\t\twhile (c == ' ')\n\t\t\t\t\tc = getchar();\n\n\t\t\t\tlights[y][x] = (c == '1') ? 1 : 0;\n\t\t\t}\n\n\t\t\tc = getchar();\n\t\t}\n\n\t\tsolve();\n\t\tfor (int y = 0; y < SZ_MATRIX; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < SZ_MATRIX; ++x)\n\t\t\t\tprintf(\"%d%c\", turn[y][x], (x < SZ_MATRIX - 1) ? ' ' : '\\n');\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "int table[100][100] = {\n  {1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,},\n  {0,0,0,0,0,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,},\n  {1,0,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,},\n  {0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,},\n  {1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,},\n  {0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,},\n  {1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,},\n  {1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,},\n  {0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,},\n  {0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,},\n  {0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,},\n  {0,1,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,},\n  {1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,},\n  {0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,0,0,},\n  {1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,0,},\n  {0,1,0,1,0,1,0,0,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,},\n  {0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,},\n  {0,1,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,1,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,},\n  {1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,},\n  {0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,},\n  {1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,0,0,0,0,},\n  {1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,},\n  {0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,},\n  {0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,1,0,1,0,1,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,0,},\n  {0,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,0,0,0,1,0,1,0,},\n  {1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,},\n  {1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,},\n  {0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,},\n  {1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,},\n  {1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,0,1,},\n  {0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,},\n  {0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,},\n  {0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,},\n  {0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,},\n  {0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,},\n  {0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,},\n  {0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,},\n  {0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,},\n  {1,0,1,0,0,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,},\n  {0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,},\n  {1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,1,0,1,0,1,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,},\n  {1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,0,},\n  {0,1,1,0,1,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,1,0,},\n  {0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,},\n  {0,1,1,1,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,0,},\n  {1,1,0,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,1,0,0,0,1,1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,},\n  {1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,0,0,},\n  {1,1,0,1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,1,},\n  {0,1,1,0,1,1,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,1,0,},\n  {0,0,1,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,},\n  {0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,},\n  {0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,1,1,0,},\n  {1,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,1,},\n  {0,0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,},\n  {1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,0,1,1,},\n  {0,0,0,1,0,1,0,1,0,1,0,0,1,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,1,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,1,1,1,0,1,1,0,0,0,1,1,0,0,0,0,0,0,0,1,0,1,1,1,0,1,1,0,1,1,1,0,},\n  {1,0,0,0,1,0,1,0,0,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,},\n  {0,1,0,0,0,1,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,},\n  {0,0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,},\n  {0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,1,1,1,0,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,},\n  {1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,},\n  {0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,0,1,},\n  {1,0,1,1,0,1,1,1,0,0,1,0,0,0,0,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,},\n  {0,0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,0,1,1,1,0,0,0,1,1,0,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,},\n  {1,1,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,},\n  {1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,0,0,1,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,},\n  {0,1,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,1,1,0,0,1,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,},\n  {0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,0,0,1,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,},\n  {0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,},\n  {0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,},\n  {1,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,1,1,0,1,1,},\n  {0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,1,0,1,1,},\n  {0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,},\n  {0,1,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,},\n  {1,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,},\n  {0,1,0,1,0,0,0,1,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,1,1,0,},\n  {0,0,1,0,1,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,},\n  {0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,0,0,0,1,0,0,0,0,1,1,0,1,1,0,},\n  {0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,1,0,1,1,1,0,1,1,1,},\n  {0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,1,1,},\n  {0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,0,1,0,},\n  {1,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,1,1,1,0,0,0,1,1,1,0,0,1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,0,1,0,1,},\n  {1,0,1,0,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,0,1,0,0,0,1,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,},\n  {1,1,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,},\n  {0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,0,1,1,0,1,1,0,1,0,1,1,1,0,0,0,1,0,1,0,1,0,},\n  {0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,1,1,1,0,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,0,0,0,1,1,0,1,0,1,0,1,0,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,1,1,0,1,0,1,1,0,1,1,0,1,0,1,0,1,0,0,0,1,},\n  {0,0,0,1,1,0,1,0,1,1,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,},\n  {0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,0,0,1,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,1,1,0,0,0,0,0,1,1,0,1,0,0,0,0,0,0,0,1,},\n  {0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,},\n  {0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,1,0,1,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,0,0,1,0,1,0,0,},\n  {0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,1,1,0,0,0,1,1,1,0,0,0,0,0,0,0,0,0,0,1,0,1,1,0,0,0,1,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,0,},\n  {0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,0,0,1,0,1,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,0,0,1,1,1,0,},\n  {1,0,1,0,1,0,0,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,0,0,1,0,1,0,0,0,1,0,1,1,0,1,1,1,0,0,1,0,0,0,1,0,0,0,1,0,0,1,1,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,1,1,0,1,1,0,0,0,0,1,0,0,0,0,0,0,0,1,0,1,0,1,0,1,1,0,1,1,1,},\n  {0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,0,0,1,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,1,1,},\n  {0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,0,1,1,0,1,1,1,1,0,0,0,1,0,1,0,1,0,1,0,1,1,0,1,1,1,0,0,},\n  {0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,1,1,1,1,0,1,1,1,0,1,1,0,0,0,1,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,0,1,0,1,0,0,0,0,1,1,1,0,1,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,0,1,},\n  {0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,1,0,0,1,0,1,0,0,0,1,0,0,1,1,1,0,1,1,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,1,0,1,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,1,1,1,0,0,0,0,},\n  {0,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0,0,0,0,0,1,1,1,0,1,1,0,1,0,1,0,0,0,1,0,0,0,1,1,1,0,1,0,1,0,1,1,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,1,0,0,0,0,0,0,0,1,1,1,1,0,1,1,0,1,0,1,},\n  {0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,1,1,0,1,1,0,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,0,0,1,0,0,1,1,0,1,1,0,1,1,1,1,0,1,0,0,0,0,0,0,0,1,1,0,1,1,1,0,1,1,1,1,0,1,0,1,0,0,0,1,0,0,1,1,1,0,0,0,0,0,0,},\n  {0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1,1,1,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,1,0,0,0,0,1,1,1,0,0,0,1,1,0,1,0,0,0,0,0,0,0,0,1,1,0,1,1,0,0,0,1,1,0,1,0,0,0,1,0,1,0,0,0,0,1,1,0,1,0,1,0,1,},\n};\nint prob[100], ans[100];\n\nmain(b,c,i,j){\n  for(scanf(\"%d\",&c);b<=c;b++){\n    //printf(\"PUZZLE #%d\\n\",b);\n    for(i=0;i<100;i++)\n      scanf(\"%d\",prob+i),ans[i]=0;\n    for(i=0;i<100;i++)\n      if(prob[i])\n        for(j=0;j<100;j++)\n          ans[j]^=table[i][j];\n    for(j=0;j<10;printf(\"\\n\"),j++)\n      for(i=0;i<10;i++)\n        printf(i<9?\"%d \":\"%d\",ans[i+j*10]);\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,map[15][15],check[15][15];\n\nint main(){\n\tfor(scanf(\"%d\",&n);n>0;n--){\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tscanf(\"%d\",&map[i][j]);\n\t\t\t\tcheck[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=10;i++){\n\t\t\tfor(j=1;j<=10;j++){\n\t\t\t\tk=map[i][j]+map[i+1][j]+map[i-1][j]+map[i][j+1]+map[i][j-1];\n\t\t\t\tprintf(\"%d%s\",(k>1 && k%2==1)?1:0,(j==10)?\"\\n\":\" \");\n\t\t\t}\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nint i,j,k,n,map[15][15],mat[200][200],mmm[200][200];\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nint main(){\n\tfor(i=0;i<100;i++){\n\t\tmmm[i][i]=1;\n\t\tif(i%10>0)mmm[i-1][i]=1;\n\t\tif(i%10<9)mmm[i+1][i]=1;\n\t\tif(i>9)mmm[i-10][i]=1;\n\t\tif(i<90)mmm[i+10][i]=1;\n\t}\n\n\tfor(scanf(\"%d\",&n);n>0;n--){\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tfor(j=0;j<100;j++){\n\t\t\t\tmat[i][j]=mmm[i][j];\n\t\t\t}\n\t\t\tscanf(\"%d\",&mat[i][100]);\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\n\t\t\tif(mat[i][i]==0){\n\t\t\t\tfor(j=i+1;j<100;j++){\n\t\t\t\t\tif(mat[j][i]==1){\n\t\t\t\t\t\tfor(k=i;k<=100;k++){\n\t\t\t\t\t\t\tswap(&mat[i][k],&mat[j][k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(j=0;j<100;j++){\n\t\t\t\tif(j!=i && mat[j][i]==1){\n\t\t\t\t\tfor(k=i;k<=100;k++){\n\t\t\t\t\t\tif(mat[i][k]==1)mat[j][k]=!mat[j][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tfor(i=0;i<100;i++){\n\t\t\tprintf(\"%d%s\",mat[i][100],(i%10==9)?\"\\n\":\" \");\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   AOJ 0131\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint n;\nint ph[10][10];     //photon mult.\nint ph_org[10][10];\nint r[10][10];\n\nvoid inv(int i,int j)\n{\n\t    ph[i][j] ^=1;\n\t    if(i>0)\n\t      ph[i-1][j] ^=1;\n\t    if(i<9)\n\t      ph[i+1][j] ^=1;\n\t    if(j>0)\n\t      ph[i][j-1] ^=1;\n\t    if(j<9)\n\t      ph[i][j+1] ^=1;\n}\n\n\nvoid find1(int *y,int *x)\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    for(j=0;j<10;j++)\n      if(ph[i][j])\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t    }\n  *y=*x=-1;\n}\nvoid output()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    {\n      for(j=0;j<10;j++)\n\tprintf(\"%d \",r[i][j]);\n      printf(\"\\n\");\n    }\n  //printf(\"---------\\n\");\n}\nvoid display()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    {\n      for(j=0;j<10;j++)\n\tprintf(\"%d \",ph[i][j]);\n      printf(\"\\n\");\n    }\n  //printf(\"---------\\n\");\n}\n\nint is_all_off()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    for(j=0;j<10;j++)\n      if(ph[i][j])\n\treturn(0);\n  return(-1);\n}\nvoid solve()\n{\n  int y,x,i,pos,bit;\n\n  for(i=0;i<1024;i++)\n    {\n      memset(r,0,sizeof(int)*10*10);\n      memcpy(ph,ph_org,sizeof(int)*10*10);\n\n      for(pos=0;pos<10;pos++)\n\t{\n\t  bit = 1<<pos;\n\t  if(bit & i)\n\t    {\n\t      r[0][pos] ^= 1;\n\t      inv(0,pos);\n\t    }\n\t}\n      //display();\n      while(find1(&y,&x),y!=-1 && y < 9)\n\t{\n\t  r[y+1][x] ^= 1;\n\t  inv(y+1,x);\n\t  //display();\n\t  if(is_all_off())\n\t    return;\n\t}\n    }\n}\n\n \n\n\nmain()\n{\n  int i,j,k;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      for(j=0;j<10;j++)\n\tfor(k=0;k<10;k++)\n\t  scanf(\"%d\",&ph_org[j][k]);\n      solve();\n      output();\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint main(){\n\tint i,j,n,s[12][12],a[12][12];\n\tscanf(\"%d\",&n);\n\twhile(n--){\n\t\tfor(i=0;i<10;i++)for(j=0;j<10;j++)scanf(\"%d\",&s[i][j]);\n\t\tmemset(a,0,sizeof(a));\n\t\tfor(i=0;i<9;i++){\n\t\t\tfor(j=0;j<10;j++){\n\t\t\t\tif(s[i][j]%2==1){\n\t\t\t\t\ta[i+1][j]=1;\n\t\t\t\t\ts[i][j]++;\n\t\t\t\t\ts[i+1][j]++;\n\t\t\t\t\ts[i+1][j-1]++;\n\t\t\t\t\ts[i+1][j+1]++;\n\t\t\t\t\ts[i+2][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<10;i++){for(j=0;j<10;j++)printf(\"%d \",a[i][j]);printf(\"\\n\");}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint status[12][12];\nint bombloc[12][12];\n\n\nint isbomb(int x,int y){\nint tv=0;\ntv += status[x][y];\ntv += status[x-1][y];\ntv += status[x+1][y];\n  tv += status[x][y-1];\n  tv += status[x][y+1];\n  if (tv>2) return 1; else return 0;\n}\nvoid bombed(int x,int y){\nstatus[x][y] = (status[x][y]==0);\nstatus[x+1][y] = (status[x+1][y]==0);\nstatus[x-1][y] = (status[x-1][y]==0);\nstatus[x][y+1] = (status[x][y+1]==0);\nstatus[x][y-1] = (status[x][y-1]==0);\n}\n\nint main(){\nint x,y;\nint i,n;\nscanf(\"%d\",&n);\nfor (i=0;i<n;i++){\n\nfor (x=1;x<=10;x++){\nfor (y=1;y<=10;y++){\n      scanf(\"%d\",&status[x][y]);\n    }\n  }\n  for (x=2;x<10;x++){\n    status[x][0]=status[x][2];\n    status[x][11]=status[x][9];\n  }\n  status[1][0]=status[1][1];\n  status[1][11]=status[1][10];\n  status[10][0]=status[10][1];\n  status[10][11]=status[10][10];\n\n  for (y=2;y<10;y++){\n    status[0][y]=status[1][y];\n    status[11][y]=status[10][y];\n  }\n  status[0][1]=status[2][1];\n  status[11][1]=status[9][1];\nstatus[0][10]=status[2][10];\nstatus[11][10]=status[9][10];\n\nfor (y=2;y<=9;y++){\nfor (x=2;x<=9;x++){\n      if (isbomb(x,y)){\n\tbombloc[x][y]=1;\n\tbombed(x,y);\n      } else bombloc[x][y]=0;\n    }\n  }\nprintf(\"\\n\");\n  for (y=1;y<=10;y++){\n    printf(\"%d\",bombloc[1][y]);\n    for (x=2;x<=10;x++){\n      printf(\" %d\",bombloc[y][x]);\n    }\n    printf(\"\\n\");\n  }\nprintf(\"\\n\");\n  for (y=1;y<=10;y++){\n    printf(\"%d\",bombloc[1][y]);\n    for (x=2;x<=10;x++){\n      printf(\" %d\",status[y][x]);\n    }\n    printf(\"\\n\");\n}\n}\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define WIDTH 10\n#define HEIGHT 10\n\nint main(void) {\n\tint case_num,case_count;\n\tif(scanf(\"%d\",&case_num)!=1)return 1;\n\tfor(case_count=0;case_count<case_num;case_count++) {\n\t\tint search;\n\t\tint i,j;\n\t\tint status[HEIGHT];\n\t\tint answer[HEIGHT];\n\t\tfor(i=0;i<HEIGHT;i++) {\n\t\t\tstatus[i]=0;\n\t\t\tfor(j=0;j<WIDTH;j++) {\n\t\t\t\tint cur;\n\t\t\t\tif(scanf(\"%d\",&cur)!=1)return 1;\n\t\t\t\tif(cur!=0)status[i]|=(1<<j);\n\t\t\t}\n\t\t}\n\t\tfor(search=0;search<(1<<WIDTH);search++) {\n\t\t\tint prev_prev_status=0;\n\t\t\tint prev_status=search;\n\t\t\tint cur_status=0;\n\t\t\tfor(i=0;i<HEIGHT;i++) {\n\t\t\t\tanswer[i]=prev_status;\n\t\t\t\tcur_status=status[i]^prev_prev_status;\n\t\t\t\tif(prev_status&1)cur_status^=3;\n\t\t\t\tfor(j=1;j<WIDTH;j++) {\n\t\t\t\t\tif(prev_status&(1<<j))cur_status^=7<<(j-1);\n\t\t\t\t}\n\t\t\t\tcur_status&=(1<<WIDTH)-1;\n\t\t\t\tprev_prev_status=prev_status;\n\t\t\t\tprev_status=cur_status;\n\t\t\t}\n\t\t\tif(cur_status==0)break;\n\t\t}\n\t\tfor(i=0;i<HEIGHT;i++) {\n\t\t\tfor(j=0;j<WIDTH;j++) {\n\t\t\t\tprintf(\"%d%c\",(answer[i]&(1<<j))?1:0,j+1<WIDTH?' ':'\\n');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n   AOJ 0131\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint n;\nint ph[10][10];     //photon mult.\nint ph_org[10][10];\nint r[10][10];\n\nvoid inv(int i,int j)\n{\n\n\t    ph[i][j] ^=1;\n\t    if(i>0)\n\t      ph[i-1][j] ^=1;\n\t    if(i<9)\n\t      ph[i+1][j] ^=1;\n\t    if(j>0)\n\t      ph[i][j-1] ^=1;\n\t    if(j<9)\n\t      ph[i][j+1] ^=1;\n}\n\n\nvoid find1(int *y,int *x)\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    for(j=0;j<10;j++)\n      if(ph[i][j])\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t    }\n  *y=*x=-1;\n}\nvoid output()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    {\n      for(j=0;j<9;j++)\n\tprintf(\"%d \",r[i][j]);\n      printf(\"%d\",r[i][9]);\n      printf(\"\\n\");\n    }\n  //printf(\"---------\\n\");\n}\nvoid display()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    {\n      for(j=0;j<10;j++)\n\tprintf(\"%d \",ph[i][j]);\n      printf(\"\\n\");\n    }\n  //printf(\"---------\\n\");\n}\n\nint is_all_off()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    for(j=0;j<10;j++)\n      if(ph[i][j])\n\treturn(0);\n  return(-1);\n}\nvoid solve()\n{\n  int y,x,i,pos,bit;\n\n  for(i=0;i<1024;i++)\n    {\n      memset(r,0,sizeof(int)*10*10);\n      memcpy(ph,ph_org,sizeof(int)*10*10);\n\n      for(pos=0;pos<10;pos++)\n\t{\n\t  bit = 1<<pos;\n\t  if(bit & i)\n\t    {\n\t      r[0][pos] ^= 1;\n\t      inv(0,pos);\n\t    }\n\t}\n      //display();\n      while(find1(&y,&x),y!=-1 && y < 9)\n\t{\n\t  r[y+1][x] = 1;\n\t  inv(y+1,x);\n\t\n\t  if(is_all_off())\n\t    return;\n\t}\n    }\n}\n\n \n\n\nmain()\n{\n  int i,j,k;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      for(j=0;j<10;j++)\n\tfor(k=0;k<10;k++)\n\t  scanf(\"%d\",&ph_org[j][k]);\n      solve();\n      output();\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n   AOJ 0131\n  Title:\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\nint n;\nint ph[10][10];     //photon mult.\nint ph_org[10][10];\nint r[10][10];\n\nvoid inv(int i,int j)\n{\n\t    ph[i][j] ^=1;\n\t    if(i>0)\n\t      ph[i-1][j] ^=1;\n\t    if(i<9)\n\t      ph[i+1][j] ^=1;\n\t    if(j>0)\n\t      ph[i][j-1] ^=1;\n\t    if(j<9)\n\t      ph[i][j+1] ^=1;\n}\n\n\nvoid find1(int *y,int *x)\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    for(j=0;j<10;j++)\n      if(ph[i][j])\n\t{\n\t  *y=i;*x=j;\n\t  return;\n\t    }\n  *y=*x=-1;\n}\nvoid output()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    {\n      for(j=0;j<9;j++)\n\tprintf(\"%d \",r[i][j]);\n      printf(\"%d\",r[i][10]);\n      printf(\"\\n\");\n    }\n  //printf(\"---------\\n\");\n}\nvoid display()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    {\n      for(j=0;j<10;j++)\n\tprintf(\"%d \",ph[i][j]);\n      printf(\"\\n\");\n    }\n  //printf(\"---------\\n\");\n}\n\nint is_all_off()\n{\n  int i,j;\n\n  for(i=0;i<10;i++)\n    for(j=0;j<10;j++)\n      if(ph[i][j])\n\treturn(0);\n  return(-1);\n}\nvoid solve()\n{\n  int y,x,i,pos,bit;\n\n  for(i=0;i<1024;i++)\n    {\n      memset(r,0,sizeof(int)*10*10);\n      memcpy(ph,ph_org,sizeof(int)*10*10);\n\n      for(pos=0;pos<10;pos++)\n\t{\n\t  bit = 1<<pos;\n\t  if(bit & i)\n\t    {\n\t      r[0][pos] ^= 1;\n\t      inv(0,pos);\n\t    }\n\t}\n      //display();\n      while(find1(&y,&x),y!=-1 && y < 9)\n\t{\n\t  r[y+1][x] ^= 1;\n\t  inv(y+1,x);\n\t  //display();\n\t  if(is_all_off())\n\t    return;\n\t}\n    }\n}\n\n \n\n\nmain()\n{\n  int i,j,k;\n\n  scanf(\"%d\",&n);\n  for(i=0;i<n;i++)\n    {\n      for(j=0;j<10;j++)\n\tfor(k=0;k<10;k++)\n\t  scanf(\"%d\",&ph_org[j][k]);\n      solve();\n      output();\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0131: Doctor's Strange Particles\n// 2017.9.3 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nchar org[12][12], map[12][12], ans[12][12];\n\nvoid xor(int r, int c)\n{\n\tmap[r][c] ^= 1, map[r-1][c] ^= 1, map[r][c-1] ^= 1, map[r+1][c] ^= 1, map[r][c+1] ^= 1;\n}\n\nint check()\n{\n\tint r, c;\n\tfor (r = 1; r <= 10; r++) for (c = 1; c <= 10; c++) if (map[r][c]) return 0;\n\treturn 1;\n}\n\nint main()\n{\n\tint n, k, r, c, a;\n\n\tscanf(\"%d\", &n);\n\twhile (n-- > 0) {\n\t\tfor (r = 1; r <= 10; r++) for (c = 1; c <= 10; c++) scanf(\"%d\", &a), org[r][c] = a;\n\t\tfor (k = 0; k < 1024; k++) {\n\t\t\tmemcpy(map, org, sizeof(org));\n\t\t\tmemset(ans, 0, sizeof(ans));\n\t\t\tfor (a = 1, c = 1; c <= 10; c++, a <<= 1) ans[1][c] = ((k & a) == a);\n\t\t\tfor (c = 1; c <= 10; c++) if (ans[1][c]) xor(1, c);\n\t\t\tfor (r = 2; r <= 10; r++) for (c = 1; c <= 10; c++)\n\t\t\t\tif (map[r-1][c]) ans[r][c] = 1, xor(r, c);\n\t\t\t\n\t\t\tif (check()) {\n\t\t\t\tfor (r = 1; r <= 10; r++) {\n\t\t\t\t\tputchar(ans[r][1] + '0');\n\t\t\t\t\tfor (c = 2; c <= 10; c++) putchar(' '), putchar(ans[r][c] + '0');\n\t\t\t\t\tputchar('\\n');\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tfor(int z=0;z<n;z++){\n\t\t\tint[][] map = new int[10][10];\n\t\t\tint[][] input = new int[10][10];\n\t\t\tint[][] ans = new int[10][10];\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tinput[i][j] = sc.nextInt();\n\t\t\t\t\tmap[i][j] = input[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<1024;k++){\n\t\t\t\tStringBuffer sb = new StringBuffer(Integer.toBinaryString(k)).reverse();\n\t\t\t\tchar[] a = sb.toString().toCharArray();\n\t\t\t\tans = new int[10][10];\n\n\t\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\t\tif(a[i]=='1'){\n\t\t\t\t\t\tif(i!=0) map[0][i-1] = 1-map[0][i-1];\n\t\t\t\t\t\tmap[0][i] = 1-map[0][i];\n\t\t\t\t\t\tmap[1][i] = 1-map[1][i];\n\t\t\t\t\t\tif(i!=9) map[0][i+1] = 1-map[0][i+1];\n\t\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i=0;i<9;i++){\n\t\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\t\tif(j!=0) map[i+1][j-1] = 1-map[i+1][j-1];\n\t\t\t\t\t\t\tmap[i+1][j] = 1-map[i+1][j];\n\t\t\t\t\t\t\tif(j!=9) map[i+1][j+1] = 1-map[i+1][j+1];\n\t\t\t\t\t\t\tif(i!=8) map[i+2][j] = 1-map[i+2][j];\n\t\t\t\t\t\t\tans[i+1][j] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean flag = false;\n\t\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\t\tif(map[i][j]==1) flag = true;\n\t\t\t\t\t\tmap[i][j] = input[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag==false)\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif(j!=0) System.out.print(\" \");\n\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tboolean[][] map = new boolean[10][10];\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tmap[j][k] = (sc.nextInt() == 1)?true:false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 1 << 10; j++) {\n\t\t\t\tboolean[][] cpMap = new boolean[10][10];\n\t\t\t\tboolean[][] faMap = new boolean[10][10];\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcpMap[k] = Arrays.copyOf(map[k], 10);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif((j & 1 << k) != 0) {\n\t\t\t\t\t\tfaMap[0][k] = true;\n\t\t\t\t\t\tfa(cpMap,0,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 1; k < 10; k++) {\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif(cpMap[k-1][l]) {\n\t\t\t\t\t\t\tfa(cpMap,k,l);\n\t\t\t\t\t\t\tfaMap[k][l] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check(cpMap)) {\n\t\t\t\t\tshow(faMap);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void show(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tif(a[i][0]) {\n\t\t\t\tSystem.out.print(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.print(0);\n\t\t\t}\n\t\t\tfor(int j = 1; j < 10; j++) {\n\t\t\t\tif(a[i][j]) {\n\t\t\t\t\tSystem.out.print(\" \" + 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(\" \" + 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static boolean check(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tif(a[i][j]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void fa(boolean[][] a, int b, int c) {\n\t\ta[b][c] = (a[b][c])?false:true;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(fb(b + vy[i],c + vx[i])) {\n\t\t\t\ta[b + vy[i]][c + vx[i]] = (a[b + vy[i]][c + vx[i]])?false:true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean fb(int b, int c) {\n\t\tif(b < 0 || c < 0 || b >= 10 || c >= 10) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int[] vx = new int[] {1,0,-1,0};\n\tstatic int[] vy = new int[] {0,1,0,-1};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint INF = 1 << 24;\n\tint n;\n\tint [][] data, work, ans;\n\tint [] vx = {0,-1,0,1};\n\tint [] vy = {0,0,1,0};\n\tboolean flg;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tn = 10;\n\t\t\tdata = new int[n][n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\twork = new int[n][n];\n\t\t\tans = new int[n][n];\n\t\t\tflg = false;\n\t\t\tdfs(0);\n\t\t\t\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\tif(j != 9){\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate void dfs(int deep) {\n\t\tif(flg) return;\n\t\tif(deep == 10){\n\t\t\tboolean res = check();\n\t\t\tif(! res) return;\n\t\t\tflg = true;\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tans[i][j] = work[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\tfor(int i = 0 ; i <= 1; i++){\n\t\t\twork[0][deep] = i;\n\t\t\tfor(int j = 0; j < vx.length; j++){\n\t\t\t\tint x = vx[j] + deep;\n\t\t\t\tint y = vy[j];\n\t\t\t\tif(! isOK(x,y)) continue;\n\t\t\t\tdata[y][x] = data[y][x] ^ i;\n\t\t\t}\n\t\t\tdfs(deep + 1);\n\t\t\tfor(int j = 0; j < vx.length; j++){\n\t\t\t\tint x = vx[j] + deep;\n\t\t\t\tint y = vy[j];\n\t\t\t\tif(! isOK(x,y)) continue;\n\t\t\t\tdata[y][x] = data[y][x] ^ i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif(0 <= x && x < n && 0 <= y && y < n){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean check() {\n\t\tint [][] temp = new int[n][n];\n\t\tfor(int i = 0 ; i < n;i++){\n\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\ttemp[i][j] = data[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\tif(temp[i-1][j] == 1){\n\t\t\t\t\twork[i][j] = 1;\n\t\t\t\t\ttemp[i-1][j] = 0;\n\t\t\t\t\tfor(int k = 0; k < vx.length; k++){\n\t\t\t\t\t\tint x = vx[k] + j;\n\t\t\t\t\t\tint y = vy[k] + i;\n\t\t\t\t\t\tif(! isOK(x,y)) continue;\n\t\t\t\t\t\ttemp[y][x] = temp[y][x] ^ 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twork[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n; i++){\n\t\t\tif(temp[9][i] == 1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tint[][] inv;\n\n\n\n\tboolean isok(int i, int j) {\n\n\t\treturn i >= 0 && i < 10 && j >= 0 && j < 10;\n\n\t}\n\n\n\n\tvoid setTrans(int d[], int p) { // only for size == 100\n\n\t\tint i = p / 10;\n\n\t\tint j = p % 10;\n\n\t\tArrays.fill(d, 0);\n\n\t\tint[] di = { 0, 0, 0, 1, -1 };\n\n\t\tint[] dj = { 0, 1, -1, 0, 0 };\n\n\t\tfor (int z = 0; z < 5; z++) {\n\n\t\t\tint ni = i + di[z];\n\n\t\t\tint nj = j + dj[z];\n\n\t\t\tif (!isok(ni, nj))\n\n\t\t\t\tcontinue;\n\n\t\t\td[10 * ni + nj] = 1;\n\n\t\t}\n\n\t}\n\n\n\n\tvoid add(int[] to, int[] from) { // only for size==100\n\n\t\tfor (int i = 0; i < to.length; i++) {\n\n\t\t\tto[i] = from[i] ^ to[i];\n\n\t\t}\n\n\t}\n\n\n\n\tvoid swap(int[] a, int[] b) {\n\n\t\tint piv;\n\n\t\tfor (int i = 0; i < 100; i++) {\n\n\t\t\tpiv = a[i];\n\n\t\t\ta[i] = b[i];\n\n\t\t\tb[i] = piv;\n\n\t\t}\n\n\t}\n\n\n\n\tvoid init() { // set inv[][]\n\n\t\tinv = new int[100][100];\n\n\t\tint[][] trans = new int[100][100];\n\n\t\tfor (int i = 0; i < 100; i++) {\n\n\t\t\tsetTrans(trans[i], i);\n\n\n\n\t\t\tinv[i][i] = 1;\n\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++) {\n\n\t\t\tif (trans[i][i] == 0) {\n\n\t\t\t\tfor (int j = i + 1; j < 100; j++) {\n\n\t\t\t\t\tif (trans[j][i] == 1) {\n\n\t\t\t\t\t\tswap(trans[i], trans[j]);\n\n\t\t\t\t\t\tswap(inv[i], inv[j]);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = i + 1; j < 100; j++) {\n\n\t\t\t\tif (trans[j][i] == 1) {\n\n\t\t\t\t\tadd(trans[j], trans[i]); // ツ湘」ツ三ツ角ツ行ツ療アツ可サ\n\n\t\t\t\t\tadd(inv[j], inv[i]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfor (int i = 0; i < 100; i++) {\n\n\t\t\tif (trans[99 - i][99 - i] == 0) {\n\n\t\t\t\tfor (int j = i + 1; j < 100; j++) {\n\n\t\t\t\t\tif (trans[99 - j][99 - i] == 1) {\n\n\t\t\t\t\t\tswap(trans[99 - i], trans[99 - j]);\n\n\t\t\t\t\t\tswap(inv[99 - i], inv[99 - j]);\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor (int j = i + 1; j < 100; j++) {\n\n\t\t\t\tif (trans[99 - j][99 - i] == 1) {\n\n\t\t\t\t\tadd(trans[99 - j], trans[99 - i]); // ツ妥篠角ツ行ツ療アツ可サ\n\n\t\t\t\t\tadd(inv[99 - j], inv[99 - i]);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\n\n\tint[] ans(int in[]) {\n\n\t\tint[] ret = new int[100];\n\n\t\tfor (int i = 0; i < 100; i++) {\n\n\t\t\tfor (int j = 0; j < 100; j++) {\n\n\t\t\t\tret[i] ^= inv[i][j] * in[j];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn ret;\n\n\t}\n\n\n\n\tvoid run() {\n\n\t\tint n = sc.nextInt();\n\n\t\tinit();\n\n\t\tfor (int z = 0; z < n; z++) {\n\n\t\t\tint in[] = new int[100];\n\n\t\t\tfor (int i = 0; i < 100; i++) {\n\n\t\t\t\tin[i] = sc.nextInt();\n\n\t\t\t}\n\n\t\t\tint ans[] = ans(in);\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\n\t\t\t\t\tif (j != 0) {\n\n\t\t\t\t\t\tSystem.out.print(\" \");\n\n\t\t\t\t\t}\n\n\t\t\t\t\tSystem.out.print(ans[i * 10 + j]);\n\n\t\t\t\t}\n\n\t\t\t\tSystem.out.println();\n\n\t\t\t}\n\n\t\t}\n\n\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "package nofill_nosubmit;\nimport java.util.Scanner;\npublic class AOJ_0131 \n{\n\tstatic int a[][];\n\tstatic int light[][];\n\tstatic int first[];\n\tstatic boolean judge;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\ta=new int[10][10];\n\n\t\t\tfirst=new int[10];\n\t\t\tjudge=false;\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t\ta[i][j]=in.nextInt();\n\t\t\tmake(0,first);\n\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j!=9)\n\t\t\t\t\t\tSystem.out.print(light[i][j]+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(light[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void make(int n, int first[])\n\t{\n\t\tif(judge)\n\t\t\treturn;\n\t\tif(n==10)\n\t\t{\n\t\t\tlight=new int[10][10];\n\t\t\tsolve(first,light,a);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst[n]=0;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t\tfirst[n]=1;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic boolean solve(int first[],int light[][],int a[][])\n\t{\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tif(first[i]==1)\n\t\t\t{\n\t\t\t\tlight[0][i]=1;\n\n\t\t\t\tif(a[0][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\n\t\t\t\tif(i+1<10&&a[0][i+1]==1)\n\t\t\t\t\ta[0][i+1]=0;\n\t\t\t\telse if(i+1<10)\n\t\t\t\t\ta[0][i+1]=1;\n\n\t\t\t\tif(i-1>=0&&a[0][i-1]==1)\n\t\t\t\t\ta[0][i-1]=0;\n\t\t\t\telse if(i-1>=10)\n\t\t\t\t\ta[0][i-1]=1;\n\n\t\t\t\tif(a[1][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<9;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==1)\n\t\t\t\t{\n\t\t\t\t\tlight[i+1][j]=1;\n\t\t\t\t\tlightOn(i+1,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(light[i][j]==0)\n\t\t\t\t\tjudge=true;\n\t\t\t\tif(!judge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!judge)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn judge;\n\t}\n\n\tstatic void lightOn(int i,int j)\n\t{\n\t\tif(a[i][j]==1)\n\t\t\ta[i][j]=0;\n\t\telse\n\t\t\ta[i][j]=1;\n\n\t\tif(j+1<10&&a[i][j+1]==1)\n\t\t\ta[i][j+1]=0;\n\t\telse if(j+1<10)\n\t\t\ta[i][j+1]=1;\n\n\t\tif(a[i-1][j]==1)\n\t\t\ta[i-1][j]=0;\n\t\telse\n\t\t\ta[i-1][j]=1;\n\n\t\tif(i+1<10&&a[i+1][j]==1)\n\t\t\ta[i+1][j]=0;\n\t\telse if(i+1<10)\n\t\t\ta[i+1][j]=1;\n\n\t\tif(j-1>=0&&a[i][j-1]==1)\n\t\t\ta[i][j-1]=0;\n\t\telse if(j-1>=0)\n\t\t\ta[i][j-1]=1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic byte ans[][];\n\n\tpublic static boolean f(int a[][], int s[], int n) {\n\t\tif (10 <= n) {\n\t\t\tint b[][] = new int[10][10];\n\t\t\tans = new byte[10][10];\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (s[i] == 1) {\n\t\t\t\t\treverse(b, 0, i);\n\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (b[i - 1][j] == 1) {\n\t\t\t\t\t\treverse(b, i, j);\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(b)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[n] = 0;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts[n] = 1;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void reverse(int a[][], int i, int j) {\n\t\ta[i][j] = (a[i][j] + 1) % 2;\n\t\tif (0 <= i - 1) {\n\t\t\ta[i - 1][j] = (a[i - 1][j] + 1) % 2;\n\t\t}\n\t\tif (i + 1 < 10) {\n\t\t\ta[i + 1][j] = (a[i + 1][j] + 1) % 2;\n\t\t}\n\t\tif (0 <= j - 1) {\n\t\t\ta[i][j - 1] = (a[i][j - 1] + 1) % 2;\n\t\t}\n\t\tif (j + 1 < 10) {\n\t\t\ta[i][j + 1] = (a[i][j + 1] + 1) % 2;\n\t\t}\n\t}\n\n\tpublic static boolean check(int a[][]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint a[][];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = new int[10][10];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\ta[j][k] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(a, new int[10], 0);\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tString s = \"\";\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\tSystem.out.print(s + ans[j][k]);\n\t\t\t\t\ts = \" \";\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\npublic class Main {\n\tstatic int n;\n\tstatic int[][] f;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic boolean read() {\n\t\tf = new int[10][10];\n\t\tfor(int i = 0; i < 10; i++) for(int j = 0; j < 10; j++) f[i][j] = sc.nextInt(); \n\t\treturn true;\n\t}\n\t\n\tstatic void solve() {\n\t\tint k;\n\t\tint[][] ans = new int[10][10];\n\t\tfor(int i = 1; i < 9; i++) {\n\t\t\tfor(int j = 1; j < 9; j++) {\n\t\t\t\tk = f[i-1][j] + f[i+1][j] + f[i][j-1] + f[i][j+1];\n\t\t\t\tif(f[i][j] == 1) {\n\t\t\t\t\tif(f[i-1][j] == 1 && f[i+1][j] == 1 &&\n\t\t\t\t\t\t\tf[i][j-1] == 1 && f[i][j+1] == 1) {\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t} else if (k == 2) { \n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif(k == 3) ans[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tif(j == 9) {\n\t\t\t\t\tSystem.out.print(\"\" + ans[i][j] + \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(\"\" + ans[i][j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\twhile(n-- > 0 && read()) {\n\t\t\tsolve();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int a[][];\n\tstatic int b[][];\n\tstatic int light[][];\n\tstatic int first[];\n\tstatic boolean judge;\n\tstatic int dx[]={0,-1,0,1,0};\n\tstatic int dy[]={-1,0,0,0,1};\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\ta=new int[10][10];\n\t\t\tb=new int[10][10];\n\t\t\tfirst=new int[10];\n\t\t\tjudge=false;\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tint c=in.nextInt();\n\t\t\t\t\ta[i][j]=c;\n\t\t\t\t\tb[i][j]=c;\n\t\t\t\t}\n\t\t\tmake(0,first);\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j!=9)\n\t\t\t\t\t\tSystem.out.print(light[i][j]+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(light[i][j]);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tstatic void make(int n, int first[])//1行目の粒子通過パターンを全列挙\n\t{\n\t\tif(judge)\n\t\t\treturn;\n\t\tif(n==10)\n\t\t{\n\t\t\tlight=new int[10][10];\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t\ta[i][j]=b[i][j];\n\t\t\tjudge=solve(first,light,a);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst[n]=0;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t\tfirst[n]=1;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic boolean solve(int first[],int light[][],int a[][])\n\t{\n\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tif(first[i]==1)\n\t\t\t{\n\t\t\t\tlight[0][i]=1;\n\t\t\t\tfor(int j=0;j<5;j++)\n\t\t\t\t{\n\t\t\t\t\tint ny=dy[j];\n\t\t\t\t\tint nx=i+dx[j];\n\t\t\t\t\tif(nx>=0&&10>nx&&ny>=0&&10>ny)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\t\t\ta[ny][nx]=0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ta[ny][nx]=1;\t \n\t\t\t\t\t}\n\t\t\t\t}\n\n//\t\t\t\tif(a[0][i]==1)\n//\t\t\t\t\ta[0][i]=0;\n//\t\t\t\telse\n//\t\t\t\t\ta[0][i]=1;\n//\n//\t\t\t\tif(i+1<10&&a[0][i+1]==1)\n//\t\t\t\t\ta[0][i+1]=0;\n//\t\t\t\telse if(i+1<10)\n//\t\t\t\t\ta[0][i+1]=1;\n//\n//\t\t\t\tif(i-1>=0&&a[0][i-1]==1)\n//\t\t\t\t\ta[0][i-1]=0;\n//\t\t\t\telse if(i-1>=10)\n//\t\t\t\t\ta[0][i-1]=1;\n//\n//\t\t\t\tif(a[1][i]==1)\n//\t\t\t\t\ta[1][i]=0;\n//\t\t\t\telse\n//\t\t\t\t\ta[1][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<10;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i-1][j]==1)\n\t\t\t\t{\n\t\t\t\t\tlight[i][j]=1;\n\t\t\t\t\tlightOn(i,j);\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor(int i=0;i<10;i++)//全部消えてるかチェック\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==0)\n\t\t\t\t\tjudge=true;\n\t\t\t\telse\n\t\t\t\t\tjudge=false;\n\t\t\t\tif(!judge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!judge)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn judge;\n\t}\n\n\tstatic void lightOn(int i,int j) //粒子を通過させる　座標を含め5箇所を反転\n\t{\n\t\tfor(int k=0;k<5;k++)\n\t\t{\n\t\t\tint ny=i+dy[k];\n\t\t\tint nx=j+dx[k];\n\t\t\tif(nx>=0&&10>nx&&ny>=0&&10>ny)\n\t\t\t{\n\t\t\t\tif(a[ny][nx]==1)\n\t\t\t\t\ta[ny][nx]=0;\n\t\t\t\telse\n\t\t\t\t\ta[ny][nx]=1;\t \n\t\t\t}\n\t\t}\n\t\t\n\t\t\n//\t\tif(a[i][j]==1)\n//\t\t\ta[i][j]=0;\n//\t\telse\n//\t\t\ta[i][j]=1;\n//\n//\t\tif(j+1<10&&a[i][j+1]==1)\n//\t\t\ta[i][j+1]=0;\n//\t\telse if(j+1<10)\n//\t\t\ta[i][j+1]=1;\n//\n//\t\tif(a[i-1][j]==1)\n//\t\t\ta[i-1][j]=0;\n//\t\telse\n//\t\t\ta[i-1][j]=1;\n//\n//\t\tif(i+1<10&&a[i+1][j]==1)\n//\t\t\ta[i+1][j]=0;\n//\t\telse if(i+1<10)\n//\t\t\ta[i+1][j]=1;\n//\n//\t\tif(j-1>=0&&a[i][j-1]==1)\n//\t\t\ta[i][j-1]=0;\n//\t\telse if(j-1>=0)\n//\t\t\ta[i][j-1]=1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint MAX = 10;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int t=0;t<n;t++) {\n\t\t\tboolean[][] map = new boolean[MAX][MAX];\n\t\t\tfor(int i=0;i<MAX;i++) for(int j=0;j<MAX;j++) {\n\t\t\t\tmap[i][j] = sc.nextInt() == 0;\n\t\t\t}\n\t\t\tint ans = -1;\n\t\t\tboolean[][] fld = new boolean[MAX][MAX];\n\t\t\tfor(int i=0;i<1<<MAX;i++) {\n\t\t\t\tboolean[][] tmp = new boolean[MAX][MAX];\n\t\t\t\tfor(int j=0;j<MAX;j++) fill(fld[j], false);\n\t\t\t\tfor(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) tmp[j][k] = map[j][k];\n\t\t\t\tfor(int j=0;j<MAX;j++) if( ((i>>>j)&1) == 1 ) {\n\t\t\t\t\trev(j, 0, tmp);\n\t\t\t\t\tfld[0][j] = true;\n\t\t\t\t}\n\t\t\t\tfor(int j=1;j<MAX;j++) for(int k=0;k<MAX;k++) {\n\t\t\t\t\tif(!tmp[j-1][k]) {\n\t\t\t\t\t\trev(k, j, tmp);\n\t\t\t\t\t\tfld[j][k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean flg = true;\n\t\t\t\tfor(int k=0;k<MAX;k++) {\n\t\t\t\t\tflg &= tmp[MAX-1][k];\n\t\t\t\t}\n\t\t\t\tif(flg) {\n\t\t\t\t\tans = i; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0;j<MAX;j++) for(int k=0;k<MAX;k++) {\n\t\t\t\tSystem.out.print( (fld[j][k]? 1: 0) + ( k==MAX-1? \"\\n\": \" \" ) );\n\t\t\t}\n\t\t}\n\t}\n\tint dx[] = {-1,0,1,0,0};\n\tint dy[] = {0,-1,0,1,0};\n\tvoid rev(int x, int y, boolean[][] map) {\n\t\tfor(int i=0;i<5;i++) if( !( x+dx[i] < 0 || y+dy[i] < 0 || x+dx[i] >= MAX || y+dy[i] >= MAX ) ){\n\t\t\tmap[y+dy[i]][x+dx[i]] = !map[y+dy[i]][x+dx[i]];\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic byte ans[][];\n\n\tpublic static boolean f(int a[][], int s[], int n) {\n\t\tif (10 <= n) {\n\t\t\tint b[][] = new int[10][10];\n\t\t\tans = new byte[10][10];\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tb[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tif (s[i] == 1) {\n\t\t\t\t\treverse(a, 0, i);\n\t\t\t\t\tans[0][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 1; i < 10; i++) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (a[i - 1][j] == 1) {\n\t\t\t\t\t\treverse(a, i, j);\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (check(a)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t} else {\n\t\t\ts[n] = 0;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\ts[n] = 1;\n\t\t\tif (f(a, s, n + 1)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static void reverse(int a[][], int i, int j) {\n\t\ta[i][j] = (a[i][j] + 1) % 2;\n\t\tif (0 <= i - 1) {\n\t\t\ta[i - 1][j] = (a[i - 1][j] + 1) % 2;\n\t\t}\n\t\tif (i + 1 < 10) {\n\t\t\ta[i + 1][j] = (a[i + 1][j] + 1) % 2;\n\t\t}\n\t\tif (0 <= j - 1) {\n\t\t\ta[i][j - 1] = (a[i][j - 1] + 1) % 2;\n\t\t}\n\t\tif (j + 1 < 10) {\n\t\t\ta[i][j + 1] = (a[i][j + 1] + 1) % 2;\n\t\t}\n\t}\n\n\tpublic static boolean check(int a[][]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tif (a[i][j] == 1) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n;\n\t\tint a[][];\n\n\t\tn = sc.nextInt();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta = new int[10][10];\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\ta[j][k] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f(a, new int[10], 0)) {\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tString s = \"\";\n\t\t\t\t\tfor (int k = 0; k < 10; k++) {\n\t\t\t\t\t\tSystem.out.print(s + ans[j][k]);\n\t\t\t\t\t\ts = \" \";\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\npublic class Main {\n\tstatic int n;\n\tstatic int[][] f;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic boolean read() {\n\t\tf = new int[10][10];\n\t\tfor(int i = 0; i < 10; i++) for(int j = 0; j < 10; j++) f[i][j] = sc.nextInt(); \n\t\treturn true;\n\t}\n\t\n\tstatic void solve() {\n\t\tint k;\n\t\tint[][] ans = new int[10][10];\n\t\tfor(int i = 1; i < 9; i++) {\n\t\t\tfor(int j = 1; j < 9; j++) {\n\t\t\t\tif(f[i][j] == 1) {\n\t\t\t\t\tif(f[i-1][j] == 1 && f[i+1][j] == 1 &&\n\t\t\t\t\t\t\tf[i][j-1] == 1 && f[i][j+1] == 1) {\n\t\t\t\t\t\tans[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tk = f[i-1][j] + f[i+1][j] + f[i][j-1] + f[i][j+1];\n\t\t\t\t\tif(k == 3) ans[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tif(j == 9) {\n\t\t\t\t\tSystem.out.print(\"\" + ans[i][j] + \"\\n\");\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.print(\"\" + ans[i][j] + \" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tn = sc.nextInt();\n\t\twhile(n-- > 0 && read()) {\n\t\t\tsolve();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Doctor's Strange Particles\npublic class Main {\n\n\tstatic int[][] m;\n\tstatic int[][] tmp;\n\tstatic boolean[][] ans;\n\tstatic int[][] move = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};\n\t\n\tstatic boolean dfs(int k){\n\t\tif(k==10){\n\t\t\ttmp = new int[10][10];\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tif(ans[0][i]){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tint ni = 0+move[j][0];\n\t\t\t\t\t\tint nj = i+move[j][1];\n\t\t\t\t\t\tif(0<=ni&&ni<10&&0<=nj&&nj<10)tmp[ni][nj]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif((tmp[i-1][j]+m[i-1][j])%2==1){\n\t\t\t\t\t\tans[i][j] = true;\n\t\t\t\t\t\tfor(int v=0;v<5;v++){\n\t\t\t\t\t\t\tint ni = i+move[v][0];\n\t\t\t\t\t\t\tint nj = j+move[v][1];\n\t\t\t\t\t\t\tif(0<=ni&&ni<10&&0<=nj&&nj<10)tmp[ni][nj]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse ans[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif((tmp[i][j]+m[i][j])%2==1)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tans[0][k] = false;\n\t\t\tif(dfs(k+1))return true;\n\t\t\tans[0][k] = true;\n\t\t\treturn dfs(k+1);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\tm = new int[10][10];\n\t\t\tans = new boolean[10][10];\n\t\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)m[i][j]=sc.nextInt();\n\t\t\tdfs(0);\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif(j>0)System.out.print(\" \");\n\t\t\t\t\tSystem.out.print(ans[i][j]?\"1\":\"0\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic int[][] offset = new int[][]{\n\t\t\t{-1, 0}, {1, 0}, {0, 1}, {0, -1}\n\t};\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\tint size = Integer.parseInt(line);\n\t\t\n\t\tfor(int n=0; n<size; n++){\n\t\t\tint[][] data = new int[10][10];\n\t\t\tfor(int y=0; y<10; y++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] tmp = line.split(\" \");\n\t\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\t\tdata[y][x] = Integer.parseInt(tmp[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] button = solve(data);\n\t\t\t\n\t\t\tfor(int y=0; y<10; y++){\n\t\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\t\tSystem.out.print(button[y][x]);\n\t\t\t\t\tif(x!=9) System.out.print(\" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int[][] solve(int[][] prob){\n\t\tint is_break = 0;\n\t\tint[][] button = null;\n\t\tfor(int i=0; i<1024; i++){\n\t\t\tint[][] data = deepClone(prob);\n\t\t\tbutton = new int[10][10];\n\t\t\tint[] bin = num_to_bin(i);\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tif(bin[x]==1){\n\t\t\t\t\tbutton[0][x]=1;\n\t\t\t\t\tdata[0][x]^=1;\n\t\t\t\t\tfor(int d=0; d<3; d++){\n\t\t\t\t\t\tint xx = x+offset[d][0];\n\t\t\t\t\t\tint yy = offset[d][1];\n\t\t\t\t\t\tif(xx>=0 && yy>=0 && xx<10 && yy<10){\n\t\t\t\t\t\t\tdata[yy][xx]^=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y=1; y<10; y++){\n\t\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\t\tif(data[y-1][x]==1){\n\t\t\t\t\t\tbutton[y][x]^=1;\n\t\t\t\t\t\tdata[y][x]^=1;\n\t\t\t\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\t\t\t\tint xx = x+offset[d][0];\n\t\t\t\t\t\t\tint yy = y+offset[d][1];\n\t\t\t\t\t\t\tif(xx>=0 && yy>=0 && xx<10 && yy<10){\n\t\t\t\t\t\t\t\tdata[yy][xx]^=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tis_break = 1;\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tif(data[9][x]==1){\n\t\t\t\t\tis_break = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(is_break==1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn button;\n\t}\n\t\n\tpublic int[][] deepClone(int[][] data){\n\t\tint[][] copy = new int[10][10];\n\t\tfor(int y=0; y<10; y++){\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tcopy[y][x] = data[y][x];\n\t\t\t}\n\t\t}\n\t\treturn copy;\n\t}\n\t\n\tpublic int[] num_to_bin(int n){\n\t\tint[] bin = new int[10];\n\t\tfor(int i=0; i<10; i++){\n\t\t\tif(n%2 == 0){\n\t\t\t\tbin[i] = 0;\n\t\t\t}else{\n\t\t\t\tbin[i] = 1;\n\t\t\t}\n\t\t\tn = n/2;\n\t\t}\n\t\t\n\t\treturn bin;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int[][] dxy = { { -1, 0 }, { 0, -1 }, { 0, 0 }, { 0, 1 }, { 1, 0 } };\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n = scanner.nextInt();\n\t\tint MAX = 10;\n\t\twhile (n-- > 0) {\n\t\t\tboolean[][] map = new boolean[MAX][MAX];\n\t\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tmap[i][j] = scanner.nextInt() == 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] fld = new boolean[MAX][MAX];\n\t\t\tfor (int i = 0; i < 1 << 10; i++) {\n\t\t\t\tfor (boolean[] b : fld) {\n\t\t\t\t\tArrays.fill(b, false);\n\t\t\t\t}\n\t\t\t\tboolean[][] tmp = new boolean[MAX][MAX];\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\ttmp[j] = Arrays.copyOf(map[j], MAX);\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tif (((i >> j) & 1) == 1) {\n\t\t\t\t\t\tslove(0, j, tmp);\n\t\t\t\t\t\tfld[0][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j = 1; j < MAX; j++) {\n\t\t\t\t\tfor (int k = 0; k < MAX; k++) {\n\t\t\t\t\t\tif (!tmp[j - 1][k]) {\n\t\t\t\t\t\t\tslove(j, k, tmp);\n\t\t\t\t\t\t\tfld[j][k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean flag = true;\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tif (!tmp[MAX - 1][j]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flag) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < MAX; i++) {\n\t\t\t\tfor (int j = 0; j < MAX; j++) {\n\t\t\t\t\tSystem.out.print(fld[i][j] ? '1' : '0');\n\t\t\t\t\tSystem.out.print(j == MAX - 1 ? '\\n' : ' ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static void slove(int y, int x, boolean[][] tmp) {\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tint dy = y + dxy[i][0];\n\t\t\tint dx = x + dxy[i][1];\n\t\t\tif (0 <= dy && dy < 10 && 0 <= dx && dx < 10) {\n\t\t\t\ttmp[dy][dx] = !tmp[dy][dx];\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int a[][];\n\tstatic int b[][];\n\tstatic int light[][];\n\tstatic int first[];\n\tstatic boolean judge;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\ta=new int[10][10];\n\t\t\tb=new int[10][10];\n\t\t\tfirst=new int[10];\n\t\t\tjudge=false;\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tint c=in.nextInt();\n\t\t\t\t\ta[i][j]=c;\n\t\t\t\t\tb[i][j]=c;\n\t\t\t\t}\n\t\t\tmake(0,first);\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j!=9)\n\t\t\t\t\t\tSystem.out.print(light[i][j]+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(light[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void make(int n, int first[])//1行目の粒子通過パターンを前列挙\n\t{\n\t\tif(judge)\n\t\t\treturn;\n\t\tif(n==10)\n\t\t{\n\t\t\tlight=new int[10][10];\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t\ta[i][j]=b[i][j];\n\t\t\tjudge=solve(first,light,a);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst[n]=0;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t\tfirst[n]=1;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic boolean solve(int first[],int light[][],int a[][])\n\t{\n\t\t\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tif(first[i]==1)\n\t\t\t{\n\t\t\t\tlight[0][i]=1;\n\t\t\t\t\n\t\t\t\tif(a[0][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\n\t\t\t\tif(i+1<10&&a[0][i+1]==1)\n\t\t\t\t\ta[0][i+1]=0;\n\t\t\t\telse if(i+1<10)\n\t\t\t\t\ta[0][i+1]=1;\n\n\t\t\t\tif(i-1>=0&&a[0][i-1]==1)\n\t\t\t\t\ta[0][i-1]=0;\n\t\t\t\telse if(i-1>=10)\n\t\t\t\t\ta[0][i-1]=1;\n\n\t\t\t\tif(a[1][i]==1)\n\t\t\t\t\ta[1][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[1][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<9;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==1)\n\t\t\t\t{\n\t\t\t\t\tlight[i+1][j]=1;\n\t\t\t\t\tlightOn(i+1,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<10;i++)//全部消えてるかチェック\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==0)\n\t\t\t\t\tjudge=true;\n\t\t\t\telse\n\t\t\t\t\tjudge=false;\n\t\t\t\tif(!judge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!judge)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn judge;\n\t}\n\n\tstatic void lightOn(int i,int j) //粒子を通過させる　座標を含め5箇所を反転\n\t{\n\t\tif(a[i][j]==1)\n\t\t\ta[i][j]=0;\n\t\telse\n\t\t\ta[i][j]=1;\n\n\t\tif(j+1<10&&a[i][j+1]==1)\n\t\t\ta[i][j+1]=0;\n\t\telse if(j+1<10)\n\t\t\ta[i][j+1]=1;\n\n\t\tif(a[i-1][j]==1)\n\t\t\ta[i-1][j]=0;\n\t\telse\n\t\t\ta[i-1][j]=1;\n\n\t\tif(i+1<10&&a[i+1][j]==1)\n\t\t\ta[i+1][j]=0;\n\t\telse if(i+1<10)\n\t\t\ta[i+1][j]=1;\n\n\t\tif(j-1>=0&&a[i][j-1]==1)\n\t\t\ta[i][j-1]=0;\n\t\telse if(j-1>=0)\n\t\t\ta[i][j-1]=1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\n\npublic class Main{\n\tpublic static void main(String args[]){\n\t\ttry{\n\t\t\tnew Main();\n\t\t}catch(IOException e){\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic int[][] offset = new int[][]{\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1}\n\t};\n\t\n\tpublic Main() throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\tint size = Integer.parseInt(line);\n\t\t\n\t\tfor(int n=0; n<size; n++){\n\t\t\tint[][] data = new int[10][10];\n\t\t\tfor(int y=0; y<10; y++){\n\t\t\t\tline = in.readLine();\n\t\t\t\tString[] tmp = line.split(\" \");\n\t\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\t\tdata[y][x] = Integer.parseInt(tmp[x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint[][] button = solve(data);\n\t\t\t\n\t\t\tfor(int y=0; y<10; y++){\n\t\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\t\tSystem.out.print(button[y][x]);\n\t\t\t\t\tif(x!=9) System.out.print(\" \");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int[][] solve(int[][] prob){\n\t\tint is_break = 0;\n\t\tint[][] button = null;\n\t\tfor(int i=0; i<1024; i++){\n\t\t\tint[][] data = deepClone(prob);\n\t\t\tbutton = new int[10][10];\n\t\t\tint[] bin = num_to_bin(i);\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tif(bin[x]==1){\n\t\t\t\t\tbutton[0][x]=1;\n\t\t\t\t\tdata[0][x]^=1;\n\t\t\t\t\tfor(int d=0; d<3; d++){\n\t\t\t\t\t\tint xx = x+offset[d][0];\n\t\t\t\t\t\tint yy = offset[d][1];\n\t\t\t\t\t\tif(xx>=0 && yy>=0 && xx<10 && yy<10){\n\t\t\t\t\t\t\tdata[yy][xx]^=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int y=1; y<10; y++){\n\t\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\t\tif(data[y-1][x]==1){\n\t\t\t\t\t\tbutton[y][x]^=1;\n\t\t\t\t\t\tdata[y][x]^=1;\n\t\t\t\t\t\tfor(int d=0; d<4; d++){\n\t\t\t\t\t\t\tint xx = x+offset[d][0];\n\t\t\t\t\t\t\tint yy = y+offset[d][1];\n\t\t\t\t\t\t\tif(xx>=0 && yy>=0 && xx<10 && yy<10){\n\t\t\t\t\t\t\t\tdata[yy][xx]^=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tis_break = 1;\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tif(data[9][x]==1){\n\t\t\t\t\tis_break = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(is_break==1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn button;\n\t}\n\t\n\tpublic int[][] deepClone(int[][] data){\n\t\tint[][] copy = new int[10][10];\n\t\tfor(int y=0; y<10; y++){\n\t\t\tfor(int x=0; x<10; x++){\n\t\t\t\tcopy[y][x] = data[y][x];\n\t\t\t}\n\t\t}\n\t\treturn copy;\n\t}\n\t\n\tpublic int[] num_to_bin(int n){\n\t\tint[] bin = new int[10];\n\t\tfor(int i=0; i<10; i++){\n\t\t\tif(n%2 == 0){\n\t\t\t\tbin[i] = 0;\n\t\t\t}else{\n\t\t\t\tbin[i] = 1;\n\t\t\t}\n\t\t\tn = n/2;\n\t\t}\n\t\t\n\t\treturn bin;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tboolean[][] map = new boolean[10][10];\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tmap[j][k] = (sc.nextInt() == 1)?true:false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tIN:for(int j = 0; j < 1 << 10; j++) {\n\t\t\t\tboolean[][] cpMap = new boolean[10][10];\n\t\t\t\tboolean[][] faMap = new boolean[10][10];\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcpMap[k] = Arrays.copyOf(map[k], 10);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif((j & 1 << k) != 0) {\n\t\t\t\t\t\tfaMap[0][k] = true;\n\t\t\t\t\t\tfa(cpMap,0,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 1; k < 10; k++) {\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif(cpMap[k-1][l]) {\n\t\t\t\t\t\t\tfa(cpMap,k,l);\n\t\t\t\t\t\t\tfaMap[k][l] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(k != 1 && cpMap[k-2][l]) {\n\t\t\t\t\t\t\tcontinue IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check(cpMap)) {\n\t\t\t\t\tshow(faMap);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void show(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tif(a[i][0]) {\n\t\t\t\tSystem.out.print(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.print(0);\n\t\t\t}\n\t\t\tfor(int j = 1; j < 10; j++) {\n\t\t\t\tif(a[i][j]) {\n\t\t\t\t\tSystem.out.print(\" \" + 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(\" \" + 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static boolean check(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tif(a[i][j]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void fa(boolean[][] a, int b, int c) {\n\t\ta[b][c] = (a[b][c])?false:true;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(fb(b + vy[i],c + vx[i])) {\n\t\t\t\ta[b + vy[i]][c + vx[i]] = (a[b + vy[i]][c + vx[i]])?false:true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean fb(int b, int c) {\n\t\tif(b < 0 || c < 0 || b >= 10 || c >= 10) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int[] vx = new int[] {1,0,-1,0};\n\tstatic int[] vy = new int[] {0,1,0,-1};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static void push(int x, int y, boolean[][] p_array, boolean[][] e_array){\n\t\tp_array[y][x] = !p_array[y][x];\n\t\te_array[y][x] = !e_array[y][x];\n\t\t\n\t\tif(x != 0){\n\t\t\te_array[y][x-1] = !e_array[y][x-1];\n\t\t}\n\t\t\n\t\tif(x != SIZE-1){\n\t\t\te_array[y][x+1] = !e_array[y][x+1];\n\t\t}\n\t\t\n\t\tif(y != 0){\n\t\t\te_array[y-1][x] = !e_array[y-1][x];\n\t\t}\n\t\t\n\t\tif(y != SIZE-1){\n\t\t\te_array[y+1][x] = !e_array[y+1][x];\n\t\t}\n\t}\n\t\n\tpublic static void set(int x, int y, boolean sw, boolean[][] p_array, boolean[][] e_array){\n\t\tif(sw){\n\t\t\tpush(x,y,p_array,e_array);\n\t\t}\n\t}\n\t\n\tpublic static final int SIZE = 10;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tboolean[][] array = new boolean[SIZE][SIZE];\n\t\tboolean[][] effect_array = new boolean[SIZE][SIZE];\n\t\tboolean[][] put_array = new boolean[SIZE][SIZE];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\t\t\tarray[j][k] = sc.nextInt() == 0 ? false : true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int cur = 0; cur < (1 << SIZE); cur++){\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\t\t\t\tput_array[j][k] = effect_array[j][k] = false; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tset(9 , 0 , (((cur >> (SIZE - 10)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(8 , 0 , (((cur >> (SIZE -  9)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(7 , 0 , (((cur >> (SIZE -  8)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(6 , 0 , (((cur >> (SIZE -  7)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(5 , 0 , (((cur >> (SIZE -  6)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(4 , 0 , (((cur >> (SIZE -  5)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(3 , 0 , (((cur >> (SIZE -  4)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(2 , 0 , (((cur >> (SIZE -  3)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(1 , 0 , (((cur >> (SIZE -  2)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\tset(0 , 0 , (((cur >> (SIZE -  1)) % 2) == 0) ? false : true , put_array , effect_array);\n\t\t\t\t\n\t\t\t\tfor(int j = 1; j < SIZE; j++){\n\t\t\t\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\t\t\t\tif(array[j-1][k] != effect_array[j-1][k]){\n\t\t\t\t\t\t\tpush(k, j, put_array, effect_array);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboolean is_correct = true;\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\t\tif(array[9][j] != effect_array[9][j]){\n\t\t\t\t\t\tis_correct = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!is_correct){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tfor(int j = 0; j < SIZE; j++){\n\t\t\t\t\t\tboolean is_first = true;\n\t\t\t\t\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\t\t\t\t\tif(!is_first){\n\t\t\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tSystem.out.print(put_array[j][k] ? 1 : 0);\n\t\t\t\t\t\t\tif(is_first == true){\n\t\t\t\t\t\t\t\tis_first = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tboolean[][] map = new boolean[10][10];\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tmap[j][k] = (sc.nextInt() == 1)?true:false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 1 << 10; j++) {\n\t\t\t\tboolean[][] cpMap = new boolean[10][10];\n\t\t\t\tboolean[][] faMap = new boolean[10][10];\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcpMap[k] = Arrays.copyOf(map[k], 10);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif((j & 1 << k) == 1) {\n\t\t\t\t\t\tfaMap[0][k] = true;\n\t\t\t\t\t\tfa(cpMap,0,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 1; k < 10; k++) {\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif(cpMap[k-1][l]) {\n\t\t\t\t\t\t\tfa(cpMap,k,l);\n\t\t\t\t\t\t\tfaMap[k][l] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check(cpMap)) {\n\t\t\t\t\tshow(faMap);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void show(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tif(a[i][0]) {\n\t\t\t\tSystem.out.print(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.print(0);\n\t\t\t}\n\t\t\tfor(int j = 1; j < 10; j++) {\n\t\t\t\tif(a[i][j]) {\n\t\t\t\t\tSystem.out.print(\" \" + 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(\" \" + 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static boolean check(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tif(a[i][j]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void fa(boolean[][] a, int b, int c) {\n\t\ta[b][c] = (a[b][c])?false:true;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(fb(b + vy[i],c + vx[i])) {\n\t\t\t\ta[b + vy[i]][c + vx[i]] = (a[b + vy[i]][c + vx[i]])?false:true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean fb(int b, int c) {\n\t\tif(b < 0 || c < 0 || b >= 10 || c >= 10) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int[] vx = new int[] {1,0,-1,0};\n\tstatic int[] vy = new int[] {0,1,0,-1};\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\n  \npublic class Main {\n\tprivate static\t\t\tBufferedReader\tbr = null;\n\tprivate static\t\t\tCmp\t\t\t\tcr = null;\n\tprivate\tstatic\tfinal\tint[]\t\t\tSV = {  0, -1,  0,  1, 0 };\n\tprivate\tstatic\tfinal\tint[]\t\t\tSH = { -1,  0,  1,  0, 0 };\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tcr = new Cmp();\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tMap[]\tmap = new Map[100];\n\t\tint\t\tcnt = 0;\n\n\t\tinitMap(map);\n\t\tArrays.sort(map, cr);\n\t\tsolveMap(map);\n\n\t\tcnt = parseCnt();\n\t\twhile (cnt-- > 0) {\n\t\t\tlong[]\tans = new long[2];\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tString\tline = parseStdin().replaceAll(\" \", \"\");\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (line.charAt(j) == '1') {\n\t\t\t\t\t\tans[0] ^= map[i*10+j].b[0];\n\t\t\t\t\t\tans[1] ^= map[i*10+j].b[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdumpAns(ans);\n\t\t}\n\t}\n\n\tprivate static void dumpAns(long ans[]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tString sz = \"\";\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tint\tk = (i*10+j);\n\t\t\t\tint\ty = k/50;\n\t\t\t\tint\tx = k%50;\n\t\t\t\tint\tn = ((ans[y] & (1L<<(49-x))) != 0L) ? 1 : 0;\n\t\t\t\tsz += (j == 0) ? \"\"+n : \" \"+n;\n\t\t\t}\n\t\t\tSystem.out.println(sz);\n\t\t}\n\t}\n\n\tprivate static void initMap(Map map[]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tint\ty = (i*10+j);\n\t\t\t\tint\tx = y/50;\n\t\t\t\tint\tr = y%50;\n\t\t\t\tmap[y] = new Map();\n\t\t\t\tmap[y].b[x] |= 1L << (49-r);\n\t\t\t\tfor (int k = 0; k < SV.length; k++) {\n\t\t\t\t\tint\tni  = i + SV[k];\n\t\t\t\t\tint\tnj  = j + SH[k];\n\t\t\t\t\tif (0 <= ni && ni < 10 && 0 <= nj && nj < 10) {\n\t\t\t\t\t\tint\tny = (ni*10+nj);\n\t\t\t\t\t\tint\tnx = ny/50;\n\t\t\t\t\t\tint\tnr = ny%50;\n\t\t\t\t\t\tmap[y].b[2+nx] |= 1L << (49-nr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tprivate static void solveMap(Map map[]) {\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tint\tx = i/50;\n\t\t\tint\tr = i%50;\n\t\t\tfor (int j = i+1; j < map.length; j++) {\n\t\t\t\tif ((map[j].b[2+x] & (1L<<(49-r))) != 0L) {\n\t\t\t\t\tmap[j].b[0] ^= map[i].b[0];\n\t\t\t\t\tmap[j].b[1] ^= map[i].b[1];\n\t\t\t\t\tmap[j].b[2] ^= map[i].b[2];\n\t\t\t\t\tmap[j].b[3] ^= map[i].b[3];\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(map, i+1, map.length, cr);\n\t\t}\n\n\t\tfor (int i = 99; i >= 0; i--) {\n\t\t\tint\tx = i/50;\n\t\t\tint\tr = i%50;\n\t\t\tfor (int j = i-1; j >= 0; j--) {\n\t\t\t\tif ((map[j].b[2+x] & (1L<<(49-r))) != 0L) {\n\t\t\t\t\tmap[j].b[0] ^= map[i].b[0];\n\t\t\t\t\tmap[j].b[1] ^= map[i].b[1];\n\t\t\t\t\tmap[j].b[2] ^= map[i].b[2];\n\t\t\t\t\tmap[j].b[3] ^= map[i].b[3];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tprivate static int parseCnt() {\n\t\tint     cnt = 0;\n\t\tString  str = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tcnt = Integer.parseInt(str);\n\t\t}\n\n\t\treturn cnt;\n\t}\n \n\tprivate static String parseStdin() {\n\t\tString  stdin = null;\n\n\t\ttry {\n\t\t\tString  tmp = br.readLine();\n\t\t\tif (tmp != null) {\n\t\t\t\tif (!tmp.isEmpty()) stdin = tmp;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn stdin;\n\t}\n}\n\nclass Map {\n\tpublic\tlong[]\tb = new long[4];\n}\n\nclass Cmp implements Comparator<Map> {\n\tpublic int compare(Map it1, Map it2) {\n\t\tint\tret = (it2.b[2] == it1.b[2]) ? 0 : (it2.b[2] > it1.b[2]) ? 1 : -1;\n\n\t\tif (ret == 0) {\n\t\t\tret = (it2.b[3] == it1.b[3]) ? 0 : (it2.b[3] > it1.b[3]) ? 1 : -1;\n\t\t}\n\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Doctor's Strange Particles\npublic class Main{\n\n\tstatic int[][] m;\n\tstatic int[][] tmp;\n\tstatic boolean[][] ans;\n\tstatic int[][] move = {{0,1},{0,-1},{1,0},{-1,0},{0,0}};\n\t\n\tstatic boolean dfs(int k){\n\t\tif(k==10){\n\t\t\ttmp = new int[10][10];\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tif(ans[0][i]){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tint ni = 0+move[j][0];\n\t\t\t\t\t\tint nj = i+move[j][1];\n\t\t\t\t\t\tif(0<=ni&&ni<10&&0<=nj&&nj<10)tmp[ni][nj]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=1;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif((tmp[i-1][j]+m[i-1][j])%2==1){\n\t\t\t\t\t\tans[i][j] = true;\n\t\t\t\t\t\tfor(int v=0;v<5;v++){\n\t\t\t\t\t\t\tint ni = i+move[v][0];\n\t\t\t\t\t\t\tint nj = j+move[v][1];\n\t\t\t\t\t\t\tif(0<=ni&&ni<10&&0<=nj&&nj<10)tmp[ni][nj]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse ans[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif((tmp[i][j]+m[i][j])%2==1)return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse{\n\t\t\tans[0][k] = false;\n\t\t\tif(dfs(k+1))return true;\n\t\t\tans[0][k] = true;\n\t\t\treturn dfs(k+1);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t--!=0){\n\t\t\tm = new int[10][10];\n\t\t\tans = new boolean[10][10];\n\t\t\tfor(int i=0;i<10;i++)for(int j=0;j<10;j++)m[i][j]=sc.nextInt();\n\t\t\tdfs(0);\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif(j>0)System.out.print(\" \");\n\t\t\t\t\tSystem.out.print(ans[i][j]?\"1\":\"0\");\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\n  \npublic class Main {\n\tprivate static\t\t\tBufferedReader\tbr = null;\n\tprivate static\t\t\tCmp\t\t\t\tcr = null;\n\tprivate\tstatic\tfinal\tint[]\t\t\tSV = {  0, -1,  0,  1, 0 };\n\tprivate\tstatic\tfinal\tint[]\t\t\tSH = { -1,  0,  1,  0, 0 };\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tcr = new Cmp();\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tMap[]\tmap = new Map[100];\n\t\tint\t\tcnt = 0;\n\n\t\tinitMap(map);\n\t\tArrays.sort(map, cr);\n\t\tsolveMap(map);\n\n\t\tcnt = parseCnt();\n\t\twhile (cnt-- > 0) {\n\t\t\tlong[]\tans = new long[2];\n\n\t\t\tfor (int i = 0; i < 10; i++) {\n\t\t\t\tString\tline = parseStdin().replaceAll(\" \", \"\");\n\t\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\t\tif (line.charAt(j) == '1') {\n\t\t\t\t\t\tans[0] ^= map[i*10+j].b[0];\n\t\t\t\t\t\tans[1] ^= map[i*10+j].b[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdumpAns(ans);\n\t\t}\n\t}\n\n\tprivate static void dumpAns(long ans[]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tString sz = \"\";\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tint\tk = (i*10+j);\n\t\t\t\tint\ty = k/50;\n\t\t\t\tint\tx = k%50;\n\t\t\t\tint\tn = ((ans[y] & (1L<<(49-x))) != 0L) ? 1 : 0;\n\t\t\t\tsz += (j == 0) ? \"\"+n : \" \"+n;\n\t\t\t}\n\t\t\tSystem.out.println(sz);\n\t\t}\n\t}\n\n\tprivate static void initMap(Map map[]) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tfor (int j = 0; j < 10; j++) {\n\t\t\t\tint\ty = (i*10+j);\n\t\t\t\tint\tx = y/50;\n\t\t\t\tint\tr = y%50;\n\t\t\t\tmap[y] = new Map();\n\t\t\t\tmap[y].b[x] |= 1L << (49-r);\n\t\t\t\tfor (int k = 0; k < SV.length; k++) {\n\t\t\t\t\tint\tni  = i + SV[k];\n\t\t\t\t\tint\tnj  = j + SH[k];\n\t\t\t\t\tif (0 <= ni && ni < 10 && 0 <= nj && nj < 10) {\n\t\t\t\t\t\tint\tny = (ni*10+nj);\n\t\t\t\t\t\tint\tnx = ny/50;\n\t\t\t\t\t\tint\tnr = ny%50;\n\t\t\t\t\t\tmap[y].b[2+nx] |= 1L << (49-nr);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tprivate static void solveMap(Map map[]) {\n\t\tfor (int i = 0; i < map.length; i++) {\n\t\t\tint\tx = i/50;\n\t\t\tint\tr = i%50;\n\t\t\tfor (int j = i+1; j < map.length; j++) {\n\t\t\t\tif ((map[j].b[2+x] & (1L<<(49-r))) != 0L) {\n\t\t\t\t\tmap[j].b[0] ^= map[i].b[0];\n\t\t\t\t\tmap[j].b[1] ^= map[i].b[1];\n\t\t\t\t\tmap[j].b[2] ^= map[i].b[2];\n\t\t\t\t\tmap[j].b[3] ^= map[i].b[3];\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.sort(map, i+1, map.length, cr);\n\t\t}\n\n\t\tfor (int i = 99; i >= 0; i--) {\n\t\t\tint\tx = i/50;\n\t\t\tint\tr = i%50;\n\t\t\tfor (int j = i-1; j >= 0; j--) {\n\t\t\t\tif ((map[j].b[2+x] & (1L<<(49-r))) != 0L) {\n\t\t\t\t\tmap[j].b[0] ^= map[i].b[0];\n\t\t\t\t\tmap[j].b[1] ^= map[i].b[1];\n\t\t\t\t\tmap[j].b[2] ^= map[i].b[2];\n\t\t\t\t\tmap[j].b[3] ^= map[i].b[3];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n \n\tprivate static int parseCnt() {\n\t\tint     cnt = 0;\n\t\tString  str = null;\n\n\t\tif ((str = parseStdin()) != null) {\n\t\t\tcnt = Integer.parseInt(str);\n\t\t}\n\n\t\treturn cnt;\n\t}\n \n\tprivate static String parseStdin() {\n\t\tString  stdin = null;\n\n\t\ttry {\n\t\t\tString  tmp = br.readLine();\n\t\t\tif (tmp != null) {\n\t\t\t\tif (!tmp.isEmpty()) stdin = tmp;\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn stdin;\n\t}\n}\n\nclass Map {\n\tpublic\tlong[]\tb = new long[4];\n}\n\nclass Cmp implements Comparator<Map> {\n\tpublic int compare(Map it1, Map it2) {\n\t\tint\tret = (it2.b[2] == it1.b[2]) ? 0 : (it2.b[2] > it1.b[2]) ? 1 : -1;\n\n\t\tif (ret == 0) {\n\t\t\tret = (it2.b[3] == it1.b[3]) ? 0 : (it2.b[3] > it1.b[3]) ? 1 : -1;\n\t\t}\n\n\t\treturn ret;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tfor(int z=0;z<n;z++){\n\t\t\tint[][] map = new int[10][10];\n\t\t\tint[][] ans = new int[10][10];\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<8;i++){\n\t\t\t\tfor(int j=1;j<9;j++){\n\t\t\t\t\tif(map[i][j]==1){\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t\tmap[i+1][j-1] = 1-map[i+1][j-1];\n\t\t\t\t\t\tmap[i+1][j] = 1-map[i+1][j];\n\t\t\t\t\t\tmap[i+1][j+1] = 1-map[i+1][j+1];\n\t\t\t\t\t\tmap[i+2][j] = 1-map[i+2][j];\n\t\t\t\t\t\tans[i+1][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<10;i++){\n\t\t\t\tfor(int j=0;j<10;j++){\n\t\t\t\t\tif(j!=0) System.out.print(\" \");\n\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Main {\n\n    public static void main(String[] args) {\n\n\tScanner stdin = new Scanner(System.in);\n\n\tfinal int T = Integer.parseInt( stdin.nextLine() );\n\tfor ( int t = 0; t < T; t++ ) {\n\n\t    boolean[][] map = new boolean[10][10];\n\t    for ( int c = 0; c < 10; c++ ) {\n\t\tfinal String[] input = stdin.nextLine().split( \" \" );\n\t\tfor ( int r = 0; r < 10; r++ ) {\n\t\t    map[c][r] = input[r].equals( \"1\" );\n\t\t}\n\t    }\n\n\t    boolean[][] answer = new boolean[10][10];\n\n\t    for ( int c = 0; c < 8; c++ ) {\n\t\tfor ( int r = 0; r < 10; r++ ) {\n\t\t    if ( map[c][r] ) {\n\t\t\tput( map, c + 1, r );\n\t\t\tanswer[c + 1][r] = true;\n\t\t    }\n\t\t}\n\t    }\n\n\t    for ( int c = 0; c < 10; c++ ) {\n\t\tSystem.out.print( map[c][0] ? 1 : 0 );\n\t\tfor ( int r = 1; r < 10; r++ ) {\n\t\t    System.out.printf(\" %d\", ( answer[c][r] ? 1 : 0 ) );\n\t\t}\n\t\tSystem.out.println();\n\t    }\t    \n\t}\t\n    }\n\n    static int[] dx = { 0, 0, -1, 0, 1 };\n    static int[] dy = { 0, 1, 0, -1, 0 };\n    static void put( boolean[][] map, int y, int x ) {\n\tfor ( int i = 0; i < 5; i++ ) {\n\t    final int nx = x + dx[i];\n\t    final int ny = y + dy[i];\n\t    if ( 0 <= nx && nx < map.length  &&\n\t\t 0 <= ny && ny < map[0].length ){\n\t\t\n\t\tmap[ny][nx] = !map[ny][nx];\n\t    }\n\t}\n    }\n\n    static void printArray( boolean[][] array ) {\n\tfor ( boolean[] ar : array ) {\n\t    System.out.println( Arrays.toString( ar ) );\n\t}\t\n    }\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int a[][];\n\tstatic int light[][];\n\tstatic int first[];\n\tstatic boolean judge;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\ta=new int[10][10];\n\n\t\t\tfirst=new int[10];\n\t\t\tjudge=false;\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t\ta[i][j]=in.nextInt();\n\t\t\tmake(0,first);\n\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j!=9)\n\t\t\t\t\t\tSystem.out.print(light[i][j]+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(light[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void make(int n, int first[])\n\t{\n\t\tif(judge)\n\t\t\treturn;\n\t\tif(n==10)\n\t\t{\n\t\t\tlight=new int[10][10];\n\t\t\tsolve(first,light,a);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst[n]=0;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t\tfirst[n]=1;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic boolean solve(int first[],int light[][],int a[][])\n\t{\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tif(first[i]==1)\n\t\t\t{\n\t\t\t\tlight[0][i]=1;\n\n\t\t\t\tif(a[0][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\n\t\t\t\tif(i+1<10&&a[0][i+1]==1)\n\t\t\t\t\ta[0][i+1]=0;\n\t\t\t\telse if(i+1<10)\n\t\t\t\t\ta[0][i+1]=1;\n\n\t\t\t\tif(i-1>=0&&a[0][i-1]==1)\n\t\t\t\t\ta[0][i-1]=0;\n\t\t\t\telse if(i-1>=10)\n\t\t\t\t\ta[0][i-1]=1;\n\n\t\t\t\tif(a[1][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<9;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==1)\n\t\t\t\t{\n\t\t\t\t\tlight[i+1][j]=1;\n\t\t\t\t\tlightOn(i+1,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(light[i][j]==0)\n\t\t\t\t\tjudge=true;\n\t\t\t\tif(!judge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!judge)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn judge;\n\t}\n\n\tstatic void lightOn(int i,int j)\n\t{\n\t\tif(a[i][j]==1)\n\t\t\ta[i][j]=0;\n\t\telse\n\t\t\ta[i][j]=1;\n\n\t\tif(j+1<10&&a[i][j+1]==1)\n\t\t\ta[i][j+1]=0;\n\t\telse if(j+1<10)\n\t\t\ta[i][j+1]=1;\n\n\t\tif(a[i-1][j]==1)\n\t\t\ta[i-1][j]=0;\n\t\telse\n\t\t\ta[i-1][j]=1;\n\n\t\tif(i+1<10&&a[i+1][j]==1)\n\t\t\ta[i+1][j]=0;\n\t\telse if(i+1<10)\n\t\t\ta[i+1][j]=1;\n\n\t\tif(j-1>=0&&a[i][j-1]==1)\n\t\t\ta[i][j-1]=0;\n\t\telse if(j-1>=0)\n\t\t\ta[i][j-1]=1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint[][] a, b;\n\tint[][] tmp;\n\tint n;\n\n\tvoid run(){\n\t\tn=10;\n\t\tfor(int m=sc.nextInt(); m>0; m--){\n\t\t\ta=new int[n][n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\ta[j][i]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\ttmp=new int[n][n];\n\t\tb=new int[n][n];\n\t\tfor(int sup=0; sup<1<<n; sup++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tSystem.arraycopy(a[j], 0, tmp[j], 0, n);\n\t\t\t\tArrays.fill(b[j], 0);\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(((sup>>i)&1)!=0){\n\t\t\t\t\treverse(i, 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=1; j<n; j++){\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif(tmp[j-1][i]==1){\n\t\t\t\t\t\treverse(i, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tc+=tmp[n-1][i];\n\t\t\t}\n\t\t\tif(c==0){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tprint(b[j][i]+(i==n-1?\"\\n\":\" \"));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid reverse(int x, int y){\n\t\tint[] dx={0, 0, 0, -1, 1};\n\t\tint[] dy={0, -1, 1, 0, 0};\n\t\tfor(int i=0; i<5; i++){\n\t\t\tint x2=x+dx[i];\n\t\t\tint y2=y+dy[i];\n\t\t\tif(x2>=0&&x2<n&&y2>=0&&y2<n){\n\t\t\t\ttmp[y2][x2]=1-tmp[y2][x2];\n\t\t\t}\n\t\t}\n\t\tb[y][x]=1-b[y][x];\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tint INF = 1 << 24;\n\tint n;\n\tint [][] data, work, ans;\n\tint [] vx = {0,-1,0,1};\n\tint [] vy = {0,0,1,0};\n\tboolean flg;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint dataset = sc.nextInt();\n\t\twhile(dataset-- > 0){\n\t\t\tn = 10;\n\t\t\tdata = new int[n][n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\twork = new int[n][n];\n\t\t\tans = new int[n][n];\n\t\t\tflg = false;\n\t\t\tdfs(0);\n\t\t\t\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tSystem.out.print(ans[i][j]);\n\t\t\t\t\tif(j != 9){\n\t\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dfs(int deep) {\n\t\tif(flg) return;\n\t\tif(deep == 10){\n\t\t\tboolean res = check();\n\t\t\tif(! res) return;\n\t\t\tflg = true;\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\t\tans[i][j] = work[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ;\n\t\t}\n\t\tfor(int i = 0 ; i <= 1; i++){\n\t\t\twork[0][deep] = i;\n\t\t\tfor(int j = 0; j < vx.length; j++){\n\t\t\t\tint x = vx[j] + deep;\n\t\t\t\tint y = vy[j];\n\t\t\t\tif(! isOK(x,y)) continue;\n\t\t\t\tdata[y][x] = data[y][x] ^ i;\n\t\t\t}\n\t\t\tdfs(deep + 1);\n\t\t\tfor(int j = 0; j < vx.length; j++){\n\t\t\t\tint x = vx[j] + deep;\n\t\t\t\tint y = vy[j];\n\t\t\t\tif(! isOK(x,y)) continue;\n\t\t\t\tdata[y][x] = data[y][x] ^ i;\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean isOK(int x, int y) {\n\t\tif(0 <= x && x < n && 0 <= y && y < n){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean check() {\n\t\tint [][] temp = new int[n][n];\n\t\tfor(int i = 0 ; i < n;i++){\n\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\ttemp[i][j] = data[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tfor(int j = 0 ; j < n; j++){\n\t\t\t\tif(temp[i-1][j] == 1){\n\t\t\t\t\twork[i][j] = 1;\n\t\t\t\t\ttemp[i-1][j] = 0;\n\t\t\t\t\tfor(int k = 0; k < vx.length; k++){\n\t\t\t\t\t\tint x = vx[k] + j;\n\t\t\t\t\t\tint y = vy[k] + i;\n\t\t\t\t\t\tif(! isOK(x,y)) continue;\n\t\t\t\t\t\ttemp[y][x] = temp[y][x] ^ 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\twork[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < n; i++){\n\t\t\tif(temp[9][i] == 1){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int a[][];\n\tstatic int b[][];\n\tstatic int light[][];\n\tstatic int first[];\n\tstatic boolean judge;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\ta=new int[10][10];\n\t\t\tb=new int[10][10];\n\t\t\tfirst=new int[10];\n\t\t\tjudge=false;\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tint c=in.nextInt();\n\t\t\t\t\ta[i][j]=c;\n\t\t\t\t\tb[i][j]=c;\n\t\t\t\t}\n\t\t\tmake(0,first);\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j!=9)\n\t\t\t\t\t\tSystem.out.print(light[i][j]+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(light[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void make(int n, int first[])\n\t{\n\t\tif(judge)\n\t\t\treturn;\n\t\tif(n==10)\n\t\t{\n\t\t\tlight=new int[10][10];\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t\ta[i][j]=b[i][j];\n\t\t\tsolve(first,light,a);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst[n]=0;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t\tfirst[n]=1;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic boolean solve(int first[],int light[][],int a[][])\n\t{\n\t\t\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tif(first[i]==1)\n\t\t\t{\n\t\t\t\tlight[0][i]=1;\n\n\t\t\t\tif(a[0][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\n\t\t\t\tif(i+1<10&&a[0][i+1]==1)\n\t\t\t\t\ta[0][i+1]=0;\n\t\t\t\telse if(i+1<10)\n\t\t\t\t\ta[0][i+1]=1;\n\n\t\t\t\tif(i-1>=0&&a[0][i-1]==1)\n\t\t\t\t\ta[0][i-1]=0;\n\t\t\t\telse if(i-1>=10)\n\t\t\t\t\ta[0][i-1]=1;\n\n\t\t\t\tif(a[1][i]==1)\n\t\t\t\t\ta[1][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[1][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<9;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==1)\n\t\t\t\t{\n\t\t\t\t\tlight[i+1][j]=1;\n\t\t\t\t\tlightOn(i+1,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tfor(int i=0;i<10;i++)//全部消えてるかチェック\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==0)\n\t\t\t\t\tjudge=true;\n\t\t\t\telse\n\t\t\t\t\tjudge=false;\n\t\t\t\tif(!judge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!judge)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn judge;\n\t}\n\n\tstatic void lightOn(int i,int j) //粒子を通過させる　座標を含め5箇所を反転\n\t{\n\t\tif(a[i][j]==1)\n\t\t\ta[i][j]=0;\n\t\telse\n\t\t\ta[i][j]=1;\n\n\t\tif(j+1<10&&a[i][j+1]==1)\n\t\t\ta[i][j+1]=0;\n\t\telse if(j+1<10)\n\t\t\ta[i][j+1]=1;\n\n\t\tif(a[i-1][j]==1)\n\t\t\ta[i-1][j]=0;\n\t\telse\n\t\t\ta[i-1][j]=1;\n\n\t\tif(i+1<10&&a[i+1][j]==1)\n\t\t\ta[i+1][j]=0;\n\t\telse if(i+1<10)\n\t\t\ta[i+1][j]=1;\n\n\t\tif(j-1>=0&&a[i][j-1]==1)\n\t\t\ta[i][j-1]=0;\n\t\telse if(j-1>=0)\n\t\t\ta[i][j-1]=1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint[] dy = {0,0,1,-1,0};\n\tint[] dx = {1,-1,0,0,0};\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int n=in.nextInt(); n-- > 0; ){\n\t\t\tboolean[][] board = new boolean[10][10];\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\tint x = in.nextInt();\n\t\t\t\t\tboard[i][j] = x == 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] ans = solve(board);\n\t\t\tfor(int i=0; i<10; i++){\n\t\t\t\tfor(int j=0; j<10; j++){\n\t\t\t\t\tSystem.out.printf(\"%d%c\",ans[i][j]?1:0, j==9?'\\n':' ');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tboolean[][] check(boolean[][] board, int bit){\n\t\tboolean[][] tmp = new boolean[10][];\n\t\tboolean[][] ans = new boolean[10][10];\n\t\tfor(int i=0; i<10; i++){\n\t\t\ttmp[i] = board[i].clone();\n\t\t}\n\t\tfor(int j=0; j<10; j++)if(((bit>>j)&1) == 1){\n\t\t\tans[0][j] = true;\n\t\t\tfor(int k=0; k<5; k++){\n\t\t\t\tint ny = 0 + dy[k], nx = j + dx[k];\n\t\t\t\tif(0<=ny && ny<10 && 0<=nx && nx<10){\n\t\t\t\t\ttmp[ny][nx] = !tmp[ny][nx];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<10; i++){\n\t\t\tfor(int j=0; j<10; j++)if(tmp[i-1][j]){\n\t\t\t\tans[i][j] = true;\n\t\t\t\tfor(int k=0; k<5; k++){\n\t\t\t\t\tint ny = i + dy[k], nx = j + dx[k];\n\t\t\t\t\tif(0<=ny && ny<10 && 0<=nx && nx<10){\n\t\t\t\t\t\ttmp[ny][nx] = !tmp[ny][nx];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0; j<10; j++)if(tmp[9][j]) return null;\n\t\treturn ans;\n\t}\n\n\tboolean[][] solve(boolean[][] board){\n\t\tfor(int bit=0; bit<1<<10; bit++){\n\t\t\tboolean[][] ans = check(board, bit);\n\t\t\tif(ans != null) return ans;\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tboolean[][] map = new boolean[10][10];\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tmap[j][k] = (sc.nextInt() == 1)?true:false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < 1 << 10; j++) {\n\t\t\t\tboolean[][] cpMap = new boolean[10][10];\n\t\t\t\tboolean[][] faMap = new boolean[10][10];\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tcpMap[k] = Arrays.copyOf(map[k], 10);\n\t\t\t\t}\n\t\t\t\tfor(int k = 0; k < 10; k++) {\n\t\t\t\t\tif((j & 1 << k) == 1) {\n\t\t\t\t\t\tfaMap[0][k] = true;\n\t\t\t\t\t\tfa(cpMap,0,k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 1; k < 10; k++) {\n\t\t\t\t\tfor(int l = 0; l < 10; l++) {\n\t\t\t\t\t\tif(cpMap[k-1][l]) {\n\t\t\t\t\t\t\tfa(cpMap,k,l);\n\t\t\t\t\t\t\tfaMap[k][l] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(check(cpMap)) {\n\t\t\t\t\tshow(faMap);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void show(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tif(a[i][0]) {\n\t\t\t\tSystem.out.print(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.print(0);\n\t\t\t}\n\t\t\tfor(int j = 1; j < 10; j++) {\n\t\t\t\tif(a[i][j]) {\n\t\t\t\t\tSystem.out.print(\" \" + 1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.print(\" \" + 0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static boolean check(boolean[][] a) {\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\tfor(int j = 0; j < 10; j++) {\n\t\t\t\tif(a[i][j]) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static void fa(boolean[][] a, int b, int c) {\n\t\ta[b][c] = (a[b][c])?false:true;\n\t\tfor(int i = 0; i < 4; i++) {\n\t\t\tif(fb(b + vy[i],c + vx[i])) {\n\t\t\t\ta[b + vy[i]][c + vx[i]] = (a[b + vy[i]][c + vx[i]])?false:true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static boolean fb(int b, int c) {\n\t\tif(b < 0 || c < 0 || b >= 10 || c >= 10) return false;\n\t\treturn true;\n\t}\n\t\n\tstatic int[] vx = new int[] {1,0,-1,0};\n\tstatic int[] vy = new int[] {0,1,0,-1};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int a[][];\n\tstatic int b[][];\n\tstatic int light[][];\n\tstatic int first[];\n\tstatic boolean judge;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint N=in.nextInt();\n\t\twhile(N-->0)\n\t\t{\n\t\t\ta=new int[10][10];\n\t\t\tb=new int[10][10];\n\t\t\tfirst=new int[10];\n\t\t\tjudge=false;\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tint c=in.nextInt();\n\t\t\t\t\ta[i][j]=c;\n\t\t\t\t\tb[i][j]=c;\n\t\t\t\t}\n\t\t\tmake(0,first);\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t{\n\t\t\t\t\tif(j!=9)\n\t\t\t\t\t\tSystem.out.print(light[i][j]+\" \");\n\t\t\t\t\telse\n\t\t\t\t\t\tSystem.out.println(light[i][j]);\n\t\t\t\t}\n\t\t}\n\t}\n\n\tstatic void make(int n, int first[])//1行目の粒子通過パターンを全列挙\n\t{\n\t\tif(judge)\n\t\t\treturn;\n\t\tif(n==10)\n\t\t{\n\t\t\tlight=new int[10][10];\n\t\t\tfor(int i=0;i<10;i++)\n\t\t\t\tfor(int j=0;j<10;j++)\n\t\t\t\t\ta[i][j]=b[i][j];\n\t\t\tjudge=solve(first,light,a);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfirst[n]=0;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t\tfirst[n]=1;\n\t\t\tmake(n+1,first);\n\t\t\tif(judge)\n\t\t\t\treturn;\n\t\t}\n\t}\n\tstatic boolean solve(int first[],int light[][],int a[][])\n\t{\n\n\t\tfor(int i=0;i<10;i++)\n\t\t{\n\t\t\tif(first[i]==1)\n\t\t\t{\n\t\t\t\tlight[0][i]=1;\n\n\t\t\t\tif(a[0][i]==1)\n\t\t\t\t\ta[0][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[0][i]=1;\n\n\t\t\t\tif(i+1<10&&a[0][i+1]==1)\n\t\t\t\t\ta[0][i+1]=0;\n\t\t\t\telse if(i+1<10)\n\t\t\t\t\ta[0][i+1]=1;\n\n\t\t\t\tif(i-1>=0&&a[0][i-1]==1)\n\t\t\t\t\ta[0][i-1]=0;\n\t\t\t\telse if(i-1>=10)\n\t\t\t\t\ta[0][i-1]=1;\n\n\t\t\t\tif(a[1][i]==1)\n\t\t\t\t\ta[1][i]=0;\n\t\t\t\telse\n\t\t\t\t\ta[1][i]=1;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<10;i++)\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i-1][j]==1)\n\t\t\t\t{\n\t\t\t\t\tlight[i][j]=1;\n\t\t\t\t\tlightOn(i,j);\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor(int i=0;i<10;i++)//全部消えてるかチェック\n\t\t{\n\t\t\tfor(int j=0;j<10;j++)\n\t\t\t{\n\t\t\t\tif(a[i][j]==0)\n\t\t\t\t\tjudge=true;\n\t\t\t\telse\n\t\t\t\t\tjudge=false;\n\t\t\t\tif(!judge)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!judge)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn judge;\n\t}\n\n\tstatic void lightOn(int i,int j) //粒子を通過させる　座標を含め5箇所を反転\n\t{\n\t\tif(a[i][j]==1)\n\t\t\ta[i][j]=0;\n\t\telse\n\t\t\ta[i][j]=1;\n\n\t\tif(j+1<10&&a[i][j+1]==1)\n\t\t\ta[i][j+1]=0;\n\t\telse if(j+1<10)\n\t\t\ta[i][j+1]=1;\n\n\t\tif(a[i-1][j]==1)\n\t\t\ta[i-1][j]=0;\n\t\telse\n\t\t\ta[i-1][j]=1;\n\n\t\tif(i+1<10&&a[i+1][j]==1)\n\t\t\ta[i+1][j]=0;\n\t\telse if(i+1<10)\n\t\t\ta[i+1][j]=1;\n\n\t\tif(j-1>=0&&a[i][j-1]==1)\n\t\t\ta[i][j-1]=0;\n\t\telse if(j-1>=0)\n\t\t\ta[i][j-1]=1;\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { 0, -1, 0, 1 };\n        readonly int[] moveY = new int[] { 0, 0, 1, 0 };\n\n        int[,] map, state, ans;\n\n        public void Solve(int[,] map)\n        {\n            this.map = map;\n            state = new int[10, 10];\n\n            DFS(0);\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(ans[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private void DFS(int depth)\n        {\n            if (depth == 10)\n            {\n                if (CheckClear()) ans = (int[,])state.Clone();\n                return;\n            }\n\n            for (int i = 0; i < 2; i++)\n            {\n                state[0, depth] = i;\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int x = moveX[j] + depth;\n                    int y = moveY[j];\n\n                    if (!IsValid(x, y)) continue;\n\n                    map[y, x] = map[y, x] == i ? 0 : 1;\n                }\n\n                DFS(depth + 1);\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int x = moveX[j] + depth;\n                    int y = moveY[j];\n\n                    if (!IsValid(x, y)) continue;\n\n                    map[y, x] = map[y, x] == i ? 0 : 1;\n                }\n            }\n        }\n\n        private bool CheckClear()\n        {\n            int[,] temp = (int[,])map.Clone();\n\n            for (int i = 1; i < 10; i++)\n            {\n                if (i == 2)\n                {\n                    for (int j = 0; j < 10; j++)\n                    {\n                        if (temp[0, j] == 1) return false;\n                    }\n                }\n\n                for (int j = 0; j < 10; j++)\n                {\n                    if (temp[i - 1, j] == 1)\n                    {\n                        state[i, j] = 1;\n                        temp[i - 1, j] = 0;\n\n                        for (int k = 0; k < 4; k++)\n                        {\n                            int x = j + moveX[k];\n                            int y = i + moveY[k];\n\n                            if (!IsValid(x, y)) continue;\n\n                            temp[y, x] = temp[y, x] == 1 ? 0 : 1;\n                        }\n                    }\n                    else\n                    {\n                        state[i, j] = 0;\n                    }\n                }\n            }\n\n            for (int i = 0; i < 10; i++)\n            {\n                if (temp[9, i] == 1) return false;\n            }\n            return true;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position\n    {\n        internal int x, y;\n\n        public Position(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Puzzle\n    {\n        struct State\n        {\n            internal Position pos;\n            internal int[,] map;\n            internal List<Position> log;\n        }\n\n        State start;\n\n        public Puzzle()\n        {\n            start.pos = new Position(0, 0);\n            start.map = new int[10, 10];\n            start.log = new List<Position>();\n        }\n\n        public void MakeMap(int[] source, int i)\n        {\n            for (int j = 0; j < 10; j++)\n            {\n                start.map[i, j] = source[j];\n            }\n        }\n\n        public void Print()\n        {\n            List<Position> res = Solve();\n\n            int[,] resMap = new int[10, 10];\n\n            foreach (var p in res)\n            {\n                resMap[p.y, p.x] = 1;\n            }\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(resMap[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private List<Position> Solve()\n        {\n            Stack<State> stk = new Stack<State>();\n            stk.Push(start);\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n\n                if (CheckClear(cur.map)) return cur.log;\n\n                if (cur.pos.y == 10) continue;\n\n                State next;\n                next.pos.x = cur.pos.x + 1;\n                next.pos.y = cur.pos.y;\n\n                if (next.pos.x == 10)\n                {\n                    next.pos.x = 0;\n                    next.pos.y++;\n                }\n\n                bool isPush = false;\n                bool isKeep = false;\n\n                if (cur.pos.y == 0)\n                {\n                    isPush = true;\n                    isKeep = true;\n                }\n                else\n                {\n                    isPush = (cur.map[cur.pos.y - 1, cur.pos.x] == 1);\n                    isKeep = !isPush;\n                }\n\n                if (isPush)\n                {\n                    next.map = (int[,])cur.map.Clone();\n                    Reverse(cur.pos, next.map);\n                    next.log = new List<Position>(cur.log);\n                    next.log.Add(cur.pos);\n                    stk.Push(next);\n                }\n\n                if (isKeep)\n                {\n                    next.map = cur.map;\n                    next.log = cur.log;\n                    stk.Push(next);\n                }\n            }\n            return null;\n        }\n\n        private bool CheckClear(int[,] map)\n        {\n            foreach (var m in map)\n            {\n                if (m == 1) return false;\n            }\n            return true;\n        }\n\n        private void Reverse(Position pos, int[,] map)\n        {\n            map[pos.y, pos.x] = map[pos.y, pos.x] == 0 ? 1 : 0;\n            if (pos.x > 0) map[pos.y, pos.x - 1] = map[pos.y, pos.x - 1] == 0 ? 1 : 0;\n            if (pos.x < 9) map[pos.y, pos.x + 1] = map[pos.y, pos.x + 1] == 0 ? 1 : 0;\n            if (pos.y > 0) map[pos.y - 1, pos.x] = map[pos.y - 1, pos.x] == 0 ? 1 : 0;\n            if (pos.y < 9) map[pos.y + 1, pos.x] = map[pos.y + 1, pos.x] == 0 ? 1 : 0;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            while (n-- > 0)\n            {\n                Puzzle pz = new Puzzle();\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n                    pz.MakeMap(input, i);\n                }\n                pz.Print();\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position\n    {\n        internal int x, y;\n\n        public Position(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Puzzle\n    {\n        struct State\n        {\n            internal Position pos;\n            internal int[,] map;\n            internal List<Position> log;\n        }\n\n        State start;\n\n        public void Solve(int[,] map)\n        {\n            start.pos = new Position(0, 0);\n            start.map = map;\n            start.log = new List<Position>();\n\n            List<Position> res = DFS();\n\n            int[,] resMap = new int[10, 10];\n\n            foreach (var p in res)\n            {\n                resMap[p.y, p.x] = 1;\n            }\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(resMap[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private List<Position> DFS()\n        {\n            Stack<State> stk = new Stack<State>();\n            stk.Push(start);\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n\n                if (!CheckState(cur)) continue;\n\n                if (cur.pos.y == 10)\n                {\n                    if (CheckClear(cur.map)) return cur.log;\n                    continue;\n                }\n\n                State next;\n                next.pos.x = cur.pos.x + 1;\n                next.pos.y = cur.pos.y;\n\n                if (next.pos.x == 10)\n                {\n                    next.pos.x = 0;\n                    next.pos.y++;\n                }\n\n                bool isPush = false;\n                bool isKeep = false;\n\n                if (cur.pos.y == 0)\n                {\n                    isPush = true;\n                    isKeep = true;\n                }\n                else\n                {\n                    isPush = (cur.map[cur.pos.y - 1, cur.pos.x] == 1);\n                    isKeep = !isPush;\n                }\n\n                if (isPush)\n                {\n                    next.map = (int[,])cur.map.Clone();\n                    Reverse(cur.pos, next.map);\n                    next.log = new List<Position>(cur.log);\n                    next.log.Add(cur.pos);\n                    stk.Push(next);\n                }\n\n                if (isKeep)\n                {\n                    next.map = cur.map;\n                    next.log = cur.log;\n                    stk.Push(next);\n                }\n            }\n            return null;\n        }\n\n        private bool CheckState(State cur)\n        {\n            if (cur.pos.y >= 2)\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    if (cur.map[cur.pos.y - 2, i] == 1)\n                    {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        private bool CheckClear(int[,] map)\n        {\n            for (int i = 8; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (map[i, j] == 1) return false;\n                }\n            }\n            return true;\n        }\n\n        private void Reverse(Position pos, int[,] map)\n        {\n            map[pos.y, pos.x] = (map[pos.y, pos.x] + 1) % 2;\n            if (pos.x > 0) map[pos.y, pos.x - 1] = (map[pos.y, pos.x - 1] + 1) % 2;\n            if (pos.x < 9) map[pos.y, pos.x + 1] = (map[pos.y, pos.x + 1] + 1) % 2;\n            if (pos.y > 0) map[pos.y - 1, pos.x] = (map[pos.y - 1, pos.x] + 1) % 2;\n            if (pos.y < 9) map[pos.y + 1, pos.x] = (map[pos.y + 1, pos.x] + 1) % 2;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position\n    {\n        internal int x, y;\n\n        public Position(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Puzzle\n    {\n        struct State\n        {\n            internal Position pos;\n            internal int[,] map;\n            internal List<Position> log;\n        }\n\n        State start;\n\n        public void Solve(int[,] map)\n        {\n            start.pos = new Position(0, 0);\n            start.map = map;\n            start.log = new List<Position>();\n\n            List<Position> res = DFS();\n\n            int[,] resMap = new int[10, 10];\n\n            foreach (var p in res)\n            {\n                resMap[p.y, p.x] = 1;\n            }\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(resMap[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private List<Position> DFS()\n        {\n            Stack<State> stk = new Stack<State>();\n            stk.Push(start);\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n\n                if (CheckClear(cur.map)) return cur.log;\n\n                if (cur.pos.y == 10) continue;\n\n                State next;\n                next.pos.x = cur.pos.x + 1;\n                next.pos.y = cur.pos.y;\n\n                if (next.pos.x == 10)\n                {\n                    next.pos.x = 0;\n                    next.pos.y++;\n                }\n\n                bool isPush = false;\n                bool isKeep = false;\n\n                if (cur.pos.y == 0)\n                {\n                    isPush = true;\n                    isKeep = true;\n                }\n                else\n                {\n                    isPush = (cur.map[cur.pos.y - 1, cur.pos.x] == 1);\n                    isKeep = !isPush;\n                }\n\n                if (isPush)\n                {\n                    next.map = (int[,])cur.map.Clone();\n                    Reverse(cur.pos, next.map);\n                    next.log = new List<Position>(cur.log);\n                    next.log.Add(cur.pos);\n                    stk.Push(next);\n                }\n\n                if (isKeep)\n                {\n                    next.map = cur.map;\n                    next.log = cur.log;\n                    stk.Push(next);\n                }\n            }\n            return null;\n        }\n\n        private bool CheckClear(int[,] map)\n        {\n            foreach (var m in map)\n            {\n                if (m == 1) return false;\n            }\n            return true;\n        }\n\n        private void Reverse(Position pos, int[,] map)\n        {\n            map[pos.y, pos.x] = (map[pos.y, pos.x] + 1) % 2;\n            if (pos.x > 0) map[pos.y, pos.x - 1] = (map[pos.y, pos.x - 1] + 1) % 2;\n            if (pos.x < 9) map[pos.y, pos.x + 1] = (map[pos.y, pos.x + 1] + 1) % 2;\n            if (pos.y > 0) map[pos.y - 1, pos.x] = (map[pos.y - 1, pos.x] + 1) % 2;\n            if (pos.y < 9) map[pos.y + 1, pos.x] = (map[pos.y + 1, pos.x] + 1) % 2;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System;\n\npublic class hello\n{\n    public static void Main()\n    {\n        var T = int.Parse(Console.ReadLine().Trim());\n        while (T-- > 0)\n        {\n            var map = new bool[10][];\n            for (int i = 0; i < 10; i++)\n            {\n                map[i] = new bool[10];\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < 10; j++)\n                    if (line[j] == \"1\") map[i][j] = true;\n            }\n            getAns(map);\n        }\n    }\n    static void getAns(bool[][] map)\n    {\n        for (int i = 0; i < 1 << 10; i++)\n        {\n            if (check(map, i)) break;\n        }\n    }\n    static bool[] calcDown(bool[] w, bool[] a)\n    {\n        var res = new bool[10];\n        for (int i = 0; i < 10; i++)\n            if (a[i]) res[i] = !w[i];\n            else res[i] = w[i];\n        return res;\n    }\n    static bool[] calcSame(bool[] w, bool[] a)\n    {\n        var res = new bool[10];\n        if (a[0]) { res[0] = !w[0]; res[1] = !w[1]; }\n        else { res[0] = w[0]; res[1] = w[1]; }\n        for (int i = 1; i <= 8; i++)\n        {\n            if (a[i])\n            {\n                res[i - 1] = !res[i - 1];\n                res[i] = !res[i];\n                res[i + 1] = !w[i + 1];\n            }\n            else res[i + 1] = w[i + 1];\n        }\n        if (a[9]) { res[8] = !res[8]; res[9] = !res[9]; }\n        return res;\n    }\n    static bool check(bool[][] map, int a)\n    {\n        var work = new bool[10][];\n        var ans = new bool[10][];\n        for (int i = 0; i < 10; i++)\n        {\n            work[i] = new bool[10];\n            ans[i] = new bool[10];\n        }\n        for (int i = 0; i < 10; i++)\n            ans[0][i] = ((a >> i) & 1) == 1;\n        work[0] = calcSame(map[0], ans[0]);\n        work[1] = calcDown(map[1], ans[0]);\n        for (int i = 1; i < 10; i++)\n        {\n            ans[i] = work[i - 1];\n            work[i] = calcSame(work[i], ans[i]);\n            if (i <= 8) work[i + 1] = calcDown(map[i + 1], ans[i]);\n        }\n        if (work[9].All(x => x == false)) { print(ans); return true; }\n        else return false;\n    }\n    static void print(bool[][] ans)\n    {\n        for (int i = 0; i < 10; i++)\n        {\n            var p = new int[10];\n            for (int j = 0; j < 10; j++)\n                if (ans[i][j]) p[j] = 1;\n            Console.WriteLine(string.Join(\" \", p));\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position\n    {\n        internal int x, y;\n\n        public Position(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Puzzle\n    {\n        struct State\n        {\n            internal Position pos;\n            internal int[,] map;\n            internal List<Position> log;\n        }\n\n        State start;\n\n        public void Solve(int[,] map)\n        {\n            start.pos = new Position(0, 0);\n            start.map = map;\n            start.log = new List<Position>();\n\n            List<Position> res = DFS();\n\n            int[,] resMap = new int[10, 10];\n\n            foreach (var p in res)\n            {\n                resMap[p.y, p.x] = 1;\n            }\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(resMap[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private List<Position> DFS()\n        {\n            Stack<State> stk = new Stack<State>();\n            stk.Push(start);\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n\n                if (!CheckState(cur)) continue;\n\n                if (cur.pos.y == 10) return cur.log;\n\n                State next;\n                next.pos.x = cur.pos.x + 1;\n                next.pos.y = cur.pos.y;\n\n                if (next.pos.x == 10)\n                {\n                    next.pos.x = 0;\n                    next.pos.y++;\n                }\n\n                bool isPush = false;\n                bool isKeep = false;\n\n                if (cur.pos.y == 0)\n                {\n                    isPush = true;\n                    isKeep = true;\n                }\n                else\n                {\n                    isPush = (cur.map[cur.pos.y - 1, cur.pos.x] == 1);\n                    isKeep = !isPush;\n                }\n\n                if (isPush)\n                {\n                    next.map = (int[,])cur.map.Clone();\n                    Reverse(cur.pos, next.map);\n                    next.log = new List<Position>(cur.log);\n                    next.log.Add(cur.pos);\n                    stk.Push(next);\n                }\n\n                if (isKeep)\n                {\n                    next.map = cur.map;\n                    next.log = cur.log;\n                    stk.Push(next);\n                }\n            }\n            return null;\n        }\n\n        private bool CheckState(State cur)\n        {\n            if (cur.pos.y == 2)\n            {\n                for (int i = 0; i < 10; i++)\n                {\n                    if (cur.map[cur.pos.y - 2, i] == 1)\n                    {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n\n        private void Reverse(Position pos, int[,] map)\n        {\n            map[pos.y, pos.x] = (map[pos.y, pos.x] + 1) % 2;\n            if (pos.x > 0) map[pos.y, pos.x - 1] = (map[pos.y, pos.x - 1] + 1) % 2;\n            if (pos.x < 9) map[pos.y, pos.x + 1] = (map[pos.y, pos.x + 1] + 1) % 2;\n            if (pos.y > 0) map[pos.y - 1, pos.x] = (map[pos.y - 1, pos.x] + 1) % 2;\n            if (pos.y < 9) map[pos.y + 1, pos.x] = (map[pos.y + 1, pos.x] + 1) % 2;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Position\n    {\n        internal int x, y;\n\n        public Position(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    class Puzzle\n    {\n        struct State\n        {\n            internal Position pos;\n            internal int[,] map;\n            internal List<Position> log;\n        }\n\n        State start;\n\n        public void Solve(int[,] map)\n        {\n            start.pos = new Position(0, 0);\n            start.map = map;\n            start.log = new List<Position>();\n\n            List<Position> res = Solve();\n\n            int[,] resMap = new int[10, 10];\n\n            foreach (var p in res)\n            {\n                resMap[p.y, p.x] = 1;\n            }\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(resMap[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private List<Position> Solve()\n        {\n            Stack<State> stk = new Stack<State>();\n            stk.Push(start);\n\n            while (stk.Count > 0)\n            {\n                State cur = stk.Pop();\n\n                if (CheckClear(cur.map)) return cur.log;\n\n                if (cur.pos.y == 10) continue;\n\n                State next;\n                next.pos.x = cur.pos.x + 1;\n                next.pos.y = cur.pos.y;\n\n                if (next.pos.x == 10)\n                {\n                    next.pos.x = 0;\n                    next.pos.y++;\n                }\n\n                bool isPush = false;\n                bool isKeep = false;\n\n                if (cur.pos.y == 0)\n                {\n                    isPush = true;\n                    isKeep = true;\n                }\n                else\n                {\n                    isPush = (cur.map[cur.pos.y - 1, cur.pos.x] == 1);\n                    isKeep = !isPush;\n                }\n\n                if (isPush)\n                {\n                    next.map = (int[,])cur.map.Clone();\n                    Reverse(cur.pos, next.map);\n                    next.log = new List<Position>(cur.log);\n                    next.log.Add(cur.pos);\n                    stk.Push(next);\n                }\n\n                if (isKeep)\n                {\n                    next.map = cur.map;\n                    next.log = cur.log;\n                    stk.Push(next);\n                }\n            }\n            return null;\n        }\n\n        private bool CheckClear(int[,] map)\n        {\n            foreach (var m in map)\n            {\n                if (m == 1) return false;\n            }\n            return true;\n        }\n\n        private void Reverse(Position pos, int[,] map)\n        {\n            map[pos.y, pos.x] = map[pos.y, pos.x] == 0 ? 1 : 0;\n            if (pos.x > 0) map[pos.y, pos.x - 1] = map[pos.y, pos.x - 1] == 0 ? 1 : 0;\n            if (pos.x < 9) map[pos.y, pos.x + 1] = map[pos.y, pos.x + 1] == 0 ? 1 : 0;\n            if (pos.y > 0) map[pos.y - 1, pos.x] = map[pos.y - 1, pos.x] == 0 ? 1 : 0;\n            if (pos.y < 9) map[pos.y + 1, pos.x] = map[pos.y + 1, pos.x] == 0 ? 1 : 0;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { 0, -1, 0, 1 };\n        readonly int[] moveY = new int[] { 0, 0, 1, 0 };\n\n        int[,] map, state, ans;\n\n        public void Solve(int[,] map)\n        {\n            this.map = map;\n            state = new int[10, 10];\n\n            DFS(0);\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(ans[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private void DFS(int depth)\n        {\n            if (depth == 10)\n            {\n                if (CheckClear()) ans = (int[,])state.Clone();\n                return;\n            }\n\n            for (int i = 0; i < 2; i++)\n            {\n                state[0, depth] = i;\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int x = moveX[j] + depth;\n                    int y = moveY[j];\n\n                    if (!IsValid(x, y)) continue;\n\n                    map[y, x] = map[y, x] == i ? 0 : 1;\n                }\n\n                DFS(depth + 1);\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int x = moveX[j] + depth;\n                    int y = moveY[j];\n\n                    if (!IsValid(x, y)) continue;\n\n                    map[y, x] = map[y, x] == i ? 0 : 1;\n                }\n            }\n        }\n\n        private bool CheckClear()\n        {\n            int[,] temp = (int[,])map.Clone();\n\n            for (int i = 1; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (temp[i - 1, j] == 1)\n                    {\n                        state[i, j] = 1;\n                        temp[i - 1, j] = 0;\n\n                        for (int k = 0; k < 4; k++)\n                        {\n                            int x = j + moveX[k];\n                            int y = i + moveY[k];\n\n                            if (!IsValid(x, y)) continue;\n\n                            temp[y, x] = temp[y, x] == 1 ? 0 : 1;\n                        }\n                    }\n                    else\n                    {\n                        state[i, j] = 0;\n                    }\n                }\n            }\n\n            for (int i = 0; i < 10; i++)\n            {\n                if (temp[9, i] == 1) return false;\n            }\n            return true;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Puzzle\n    {\n        readonly int[] moveX = new int[] { 0, -1, 0, 1 };\n        readonly int[] moveY = new int[] { 0, 0, 1, 0 };\n\n        int[,] map, state, ans;\n\n        public void Solve(int[,] map)\n        {\n            this.map = map;\n            state = new int[10, 10];\n\n            DFS(0);\n\n            StringBuilder sb = new StringBuilder();\n\n            for (int i = 0; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (j != 0) sb.Append(\" \");\n\n                    sb.Append(ans[i, j]);\n                }\n                sb.Append(\"\\n\");\n            }\n            Console.Write(sb);\n        }\n\n        private void DFS(int depth)\n        {\n            if (depth == 10)\n            {\n                if (CheckClear()) ans = (int[,])state.Clone();\n                return;\n            }\n\n            for (int i = 0; i < 2; i++)\n            {\n                state[0, depth] = i;\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int x = moveX[j] + depth;\n                    int y = moveY[j];\n\n                    if (!IsValid(x, y)) continue;\n\n                    map[y, x] = map[y, x] ^ i;\n                }\n\n                DFS(depth + 1);\n\n                for (int j = 0; j < 4; j++)\n                {\n                    int x = moveX[j] + depth;\n                    int y = moveY[j];\n\n                    if (!IsValid(x, y)) continue;\n\n                    map[y, x] = map[y, x] ^ i;\n                }\n            }\n        }\n\n        private bool CheckClear()\n        {\n            int[,] temp = (int[,])map.Clone();\n\n            for (int i = 1; i < 10; i++)\n            {\n                for (int j = 0; j < 10; j++)\n                {\n                    if (temp[i - 1, j] == 1)\n                    {\n                        state[i, j] = 1;\n                        temp[i - 1, j] = 0;\n\n                        for (int k = 0; k < 4; k++)\n                        {\n                            int x = j + moveX[k];\n                            int y = i + moveY[k];\n\n                            if (!IsValid(x, y)) continue;\n\n                            temp[y, x] = temp[y, x] ^ 1;\n                        }\n                    }\n                    else\n                    {\n                        state[i, j] = 0;\n                    }\n                }\n            }\n\n            for (int i = 0; i < 10; i++)\n            {\n                if (temp[9, i] == 1) return false;\n            }\n            return true;\n        }\n\n        private bool IsValid(int x, int y)\n        {\n            if (x < 0) return false;\n            if (x > 9) return false;\n            if (y < 0) return false;\n            if (y > 9) return false;\n            return true;\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = int.Parse(Console.ReadLine());\n\n            Puzzle pz = new Puzzle();\n\n            while (n-- > 0)\n            {\n                int[,] map = new int[10, 10];\n\n                for (int i = 0; i < 10; i++)\n                {\n                    int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                    for (int j = 0; j < 10; j++)\n                    {\n                        map[i, j] = input[j];\n                    }\n                }\n                pz.Solve(map);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0131\n{\n    public class Program\n\n    {\n        public const int SIZE = 10;\n        public const int STL = 1;\n\n        static public int[,] map;\n        static public List<Tuple<int, int>> point;\n\n        static public int[] di = new int[] { 0, 0, 0, -1, 1 };\n        static public int[] dj = new int[] { 0, -1, 1, 0, 0 };\n\n        public static void Main(string[] args)\n        {\n            int n = RInt();\n\n            for (int lCnt = 0 ; lCnt < n ; lCnt++)\n            {\n                //initialize\n                map = new int[SIZE + STL * 2, SIZE + STL * 2];\n                for (int i = STL ; i < SIZE + STL ; i++)\n                {\n                    int[] items = RIntAr();\n                    for (int j = STL ; j < SIZE + STL ; j++)\n                    {\n                        map[i, j] = items[j - STL];\n                    }\n                }\n\n                //search\n                int[,] defaultMap = new int[SIZE + STL * 2, SIZE + STL * 2];\n                Array.Copy(map, defaultMap, map.Length);\n\n                point = new List<Tuple<int, int>>(SIZE * SIZE);\n                for (int k = 0 ; k < (1 << SIZE) ; k++)\n                {\n                    Array.Copy(defaultMap, map, map.Length);\n                    point.Clear();\n                    if (CanTurningOff(k))\n                    {\n                        break;\n                    }\n                }\n\n                //print\n                int[,] ans = new int[SIZE, SIZE];\n                foreach (var item in point) ans[item.Item1 - STL, item.Item2 - STL] = 1;\n                for (int i = 0 ; i < SIZE ; i++)\n                {\n                    for (int j = 0 ; j < SIZE ; j++)\n                    {\n                        Console.Write(ans[i, j]);\n                        if (j != SIZE - 1) Console.Write(\" \");\n                        else Console.Write(Environment.NewLine);\n                    }\n                }\n\n            }\n\n        }\n\n        private static bool CanTurningOff(int bit)\n        {\n            for (int i = STL ; i < SIZE + STL ; i++)\n            {\n                if (((bit >> i - 1) & 1) == 1) Reverse(STL, i);\n            }\n\n            for (int i = STL + 1 ; i < SIZE + STL ; i++)\n            {\n                for (int j = STL ; j < SIZE + STL ; j++)\n                {\n                    if (map[i - 1, j] == 1) Reverse(i, j);\n                }\n            }\n\n            for (int i = STL ; i < SIZE + STL ; i++)\n            {\n                if (map[SIZE + STL - 1, i] == 1) return false;\n            }\n            return true;\n        }\n\n        private static void Reverse(int i, int j)\n        {\n            point.Add(new Tuple<int, int>(i, j));\n            for (int k = 0 ; k < di.Length ; k++)\n            {\n                map[i + di[k], j + dj[k]] = map[i + di[k], j + dj[k]] ^ 1;\n            }\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            var map = new bool[10, 10];\n            for (int j = 0; j < 10; j++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                for (int k = 0; k < 10; k++)\n                    if (line[k] == \"1\") map[j, k] = true;\n            }\n                var ret = getAns(map);\n                print(ret);\n        }\n\n    }\n    public static void print (bool[,] map)\n    {\n        int t;\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++)\n            {\n                t = map[i, j] ? 1 : 0;\n                if (j == 9) Console.WriteLine(t);\n                else Console.Write(\"{0} \", t);\n            }\n    }\n    public static bool[,] getAns(bool[,] map)\n    {\n        var dx = new int[] { 0, 1, 0, -1, 0 };\n        var dy = new int[] { 1, 0, -1, 0, 0 };\n        var ret = new bool[10, 10];\n        for (int i = 0; i < 8; i++)\n        {\n            for (int j = 0; j < 10; j++)\n                if (map[i, j])\n                {\n                    ret[i + 1, j] = true;\n                    for (int k = 0; k < 5; k++)\n                    {\n                        var nx = i + 1 + dx[k];\n                        var ny = j + dy[k];\n                        if (ny >= 0 && ny < 10) map[nx, ny] = !map[nx, ny];\n                    }\n                }\n        }\n        return ret;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var n = int.Parse(Console.ReadLine().Trim());\n        for (int i = 0; i < n; i++)\n        {\n            var map = new bool[10, 10];\n            for (int j = 0; j < 10; j++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                for (int k = 0; k < 10; k++)\n                    if (line[k] == \"1\") map[j, k] = true;\n            }\n            var ret = getAns(map);\n            print(ret);\n        }\n\n    }\n    public static void print(bool[,] map)\n    {\n        int t;\n        for (int i = 0; i < 10; i++)\n            for (int j = 0; j < 10; j++)\n            {\n                t = map[i, j] ? 1 : 0;\n                if (j == 9) Console.WriteLine(t);\n                else Console.Write(\"{0} \", t);\n            }\n    }\n    public static bool[,] getAns(bool[,] map)\n    {\n        var dx = new int[] { 0, 1, 0, -1, 0 };\n        var dy = new int[] { 1, 0, -1, 0, 0 };\n        var ret = new bool[10, 10];\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 10; j++)\n                if (map[i, j])\n                {\n                    ret[i + 1, j] = true;\n                    for (int k = 0; k < 5; k++)\n                    {\n                        var nx = i + 1 + dx[k];\n                        var ny = j + dy[k];\n                        if (nx < 10 && ny >= 0 && ny < 10) map[nx, ny] = !map[nx, ny];\n                    }\n                }\n        }\n        return ret;\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef lightsout(x,y)\n  now=Time.now.to_f\n  succ=0\n  a=Array.new(x*y)\n  a.length.times{|i| a[i]=Array.new(2)}\n\n  #create problem\n  x.times {|i|\n    y.times {|j|\n      a[i+j*x][0]=1<<(i+j*x)\n      a[i+j*x][1]= 0 +\n        (1<<(i+j*x)) +\n        (i>0   ? 1<<(i-1+j*x) : 0) +\n        (i<x-1 ? 1<<(i+1+j*x) : 0) +\n        (j>0   ? 1<<(i+(j-1)*x) : 0) +\n        (j<y-1 ? 1<<(i+(j+1)*x) : 0) +\n=begin\n        (i>0   && j>0   ? 1<<(i-1+(j-1)*x) : 0) +\n        (i<x-1 && j>0   ? 1<<(i+1+(j-1)*x) : 0) +\n        (i>0   && j<y-1 ? 1<<(i-1+(j+1)*x) : 0) +\n        (i<x-1 && j<y-1 ? 1<<(i+1+(j+1)*x) : 0) +\n=end\n        0\n    }\n  }\n\n  #solve\n  (x*y).times {|i|\n    if a[i][1]&1<<i==0\n      (i+1).step(x*y-1) {|j|\n        if a[j][1]&1<<i!=0\n          a[i],a[j]=a[j],a[i]\n          succ=1\n          break\n        end\n      }\n      if succ==0 then break end #in 6*5 succ is always 1\n      succ=0\n    end\n\n    (x*y).times {|j|\n      if i==j then next end\n      if a[j][1]&1<<i!=0\n        a[j][0]^=a[i][0]\n        a[j][1]^=a[i][1]\n      end\n    }\n\n    #$stderr.printf(\"%d/%d passes\\r\",i+1,x*y)\n  }\n  #$stderr.print \"\\n\"\n\n\tgets.to_i.times{\n\t\tprob=[];ans=[0]*x*y\n\t\ty.times{prob+=gets.split.map(&:to_i)}\n\t\t(x*y).times{|i|if prob[i]>0 then (x*y).times{|j|ans[j]^=a[j][0][i]}end}\n\t\ty.times{|i|puts ans[i*x,x].map(&:to_s).join('')}\n\t}\n\n=begin\n  #output as C\n  print <<\"EOM\"\n#include <stdio.h>\nint table[#{x*y}][#{x*y}] = {\nEOM\n\n  a.each {|b|\n    print \"  {\"\n    a.length.times {|c|\n      print \"#{b[0][c]},\"\n    }\n    print \"},\\n\"\n  }\n\n  print <<\"EOM\"\n};\nint prob[#{x*y}], ans[#{x*y}];\n\nmain(b,c,i,j){\n  for(scanf(\"%d\",&c);b<=c;b++){\n    for(i=0;i<#{x*y};i++)\n      scanf(\"%d\",prob+i),ans[i]=0;\n    for(i=0;i<#{x*y};i++)\n      if(prob[i])\n        for(j=0;j<#{x*y};j++)\n          ans[j]^=table[i][j];\n    for(j=0;j<#{y};printf(\"\\\\n\"),j++)\n      for(i=0;i<#{x};i++)\n        printf(i<#{x-1}?\"%d \":\"%d\",ans[i+j*#{x}]);\n  }\n  return 0;\n}\nEOM\n$stderr.printf(\"%.3f ms\\n\",Time.now.to_f-now)\n=end\nend\n\nlightsout(10,10)"
  },
  {
    "language": "Ruby",
    "code": "def set(x, y, f)\n  f[y] ^= (1 << x)\nend\n\ndef isset?(x, y, f)\n  return (f[y] & (1 << x)) != 0\nend\n\ndef shoot(x, y, f)\n  set(x, y, f)\n  set(x - 1, y, f) if x > 0\n  set(x + 1, y, f) if x < 9\n  set(x, y - 1, f) if y > 0\n  set(x, y + 1, f) if y < 9\nend\n\n### main\n\nn = gets.strip.to_i\n\nmax_bits = 1 << 10\n\nn.times.each do\n  flds = []\n  10.times.each do\n    hl = gets.strip.gsub(/ /, '').reverse.to_i(2)\n    flds.push hl\n  end\n\n  for bits in (0...max_bits)\n    ans = []\n    flds0 = flds.clone\n\n    for x in (0..9)\n      if (bits & (1 << x)) != 0\n        shoot(x, 0, flds0)\n      end\n    end\n    ans.push bits\n\n    for y in (1..9)\n      by = 0\n      for x in (0..9)\n        if isset?(x, y - 1, flds0)\n          shoot(x, y, flds0)\n          by |= (1 << x)\n        end\n      end\n      ans.push by\n    end\n\n    if flds0[9] == 0\n      ans.each{|b| puts (\"%010b\" % b).reverse.split(\"\").join(\" \")}\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef lightsout(x,y)\n  now=Time.now.to_f\n  succ=0\n  a=Array.new(x*y)\n  a.length.times{|i| a[i]=Array.new(2)}\n\n  #create problem\n  x.times {|i|\n    y.times {|j|\n      a[i+j*x][0]=1<<(i+j*x)\n      a[i+j*x][1]= 0 +\n        (1<<(i+j*x)) +\n        (i>0   ? 1<<(i-1+j*x) : 0) +\n        (i<x-1 ? 1<<(i+1+j*x) : 0) +\n        (j>0   ? 1<<(i+(j-1)*x) : 0) +\n        (j<y-1 ? 1<<(i+(j+1)*x) : 0) +\n=begin\n        (i>0   && j>0   ? 1<<(i-1+(j-1)*x) : 0) +\n        (i<x-1 && j>0   ? 1<<(i+1+(j-1)*x) : 0) +\n        (i>0   && j<y-1 ? 1<<(i-1+(j+1)*x) : 0) +\n        (i<x-1 && j<y-1 ? 1<<(i+1+(j+1)*x) : 0) +\n=end\n        0\n    }\n  }\n\n  #solve\n  (x*y).times {|i|\n    if a[i][1]&1<<i==0\n      (i+1).step(x*y-1) {|j|\n        if a[j][1]&1<<i!=0\n          a[i],a[j]=a[j],a[i]\n          succ=1\n          break\n        end\n      }\n      if succ==0 then break end #in 6*5 succ is always 1\n      succ=0\n    end\n\n    (x*y).times {|j|\n      if i==j then next end\n      if a[j][1]&1<<i!=0\n        a[j][0]^=a[i][0]\n        a[j][1]^=a[i][1]\n      end\n    }\n\n    #$stderr.printf(\"%d/%d passes\\r\",i+1,x*y)\n  }\n  #$stderr.print \"\\n\"\n\n\tgets.to_i.times{\n\t\tprob=[];ans=[0]*x*y\n\t\ty.times{prob+=gets.split.map(&:to_i)}\n\t\t(x*y).times{|i|if prob[i]>0 then (x*y).times{|j|ans[j]^=a[j][0][i]}end}\n\t\ty.times{|i|puts ans[i*x,x].map(&:to_s).join(' ')}\n\t}\n\n=begin\n  #output as C\n  print <<\"EOM\"\n#include <stdio.h>\nint table[#{x*y}][#{x*y}] = {\nEOM\n\n  a.each {|b|\n    print \"  {\"\n    a.length.times {|c|\n      print \"#{b[0][c]},\"\n    }\n    print \"},\\n\"\n  }\n\n  print <<\"EOM\"\n};\nint prob[#{x*y}], ans[#{x*y}];\n\nmain(b,c,i,j){\n  for(scanf(\"%d\",&c);b<=c;b++){\n    for(i=0;i<#{x*y};i++)\n      scanf(\"%d\",prob+i),ans[i]=0;\n    for(i=0;i<#{x*y};i++)\n      if(prob[i])\n        for(j=0;j<#{x*y};j++)\n          ans[j]^=table[i][j];\n    for(j=0;j<#{y};printf(\"\\\\n\"),j++)\n      for(i=0;i<#{x};i++)\n        printf(i<#{x-1}?\"%d \":\"%d\",ans[i+j*#{x}]);\n  }\n  return 0;\n}\nEOM\n$stderr.printf(\"%.3f ms\\n\",Time.now.to_f-now)\n=end\nend\n\nlightsout(10,10)"
  },
  {
    "language": "Ruby",
    "code": "def set(x, y, f)\n  f[y] ^= (1 << x)\nend\n\ndef isset?(x, y, f)\n  return (f[y] & (1 << x)) != 0\nend\n\ndef shoot(x, y, f)\n  set(x, y, f)\n  set(x - 1, y, f) if x > 0\n  set(x + 1, y, f) if x < 9\n  set(x, y - 1, f) if y > 0\n  set(x, y + 1, f) if y < 9\nend\n\n### main\n\nn = gets.strip.to_i\n\nmax_bits = 1 << 10\n\nn.times.each do\n  flds = []\n  10.times.each do\n    hl = gets.strip.gsub(/ /, '').reverse.to_i(2)\n    flds.push hl\n  end\n\n  ans = []\n  for bits in (0...max_bits)\n    flds0 = flds.clone\n\n    for x in (0..9)\n      if (bits & (1 << x)) != 0\n        shoot(x, 0, flds0)\n      end\n    end\n    ans.push bits\n\n    for y in (1..9)\n      by = 0\n      for x in (0..9)\n        if isset?(x, y - 1, flds0)\n          shoot(x, y, flds0)\n          by |= (1 << x)\n        end\n      end\n      ans.push by\n    end\n\n    if flds0[9] == 0\n      ans.each{|b| puts (\"%010b\" % b).reverse.split(\"\").join(\" \")}\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "L = 10\n\n$<.gets.to_i.times do\n  field = Array.new(L) {$<.gets.split.map(&:to_i)}.flatten\n  result = Array.new(L * L, 0)\n  reverse = ->(x, y) {\n    [[0, 0], [1, 0], [0, -1], [-1, 0], [0, 1]].each do |dx, dy|\n      x1 = x + dx\n      y1 = y + dy\n      next if x1 < 0 or x1 >= L or y1 < 0 or y1 >= L\n      i = y1 * L + x1\n      field[i] = 1 - field[i]\n    end\n  }\n  top_row = ->(i) {\n    if i >= L\n      tmp1 = field.dup\n      tmp2 = result.dup\n      while i < L * L\n        x, y = i % L, i / L\n        if field[i - L] == 1\n          result[i] = 1\n          reverse.(x, y)\n        end\n        i += 1\n      end\n      if field.all? {|i| i.zero?}\n        puts result.each_slice(L).map {|a| a.join(\" \")}\n        true\n      else\n        field  = tmp1\n        result = tmp2\n        false\n      end\n    else\n      return true if top_row.(i + 1)\n      \n      result[i] = 1\n      reverse.(i % L, i / L)\n      return true if top_row.(i + 1)\n      reverse.(i % L, i / L)\n      result[i] = 0\n      false\n    end\n  }\n  top_row.(0)\nend\n"
  },
  {
    "language": "Ruby",
    "code": "def set(x, y, f)\n  f[y] ^= (1 << x)\nend\n\ndef shoot(x, y, f)\n  set(x, y, f)\n  set(x - 1, y, f) if x > 0\n  set(x + 1, y, f) if x < 9\n  set(x, y - 1, f) if y > 0\n  set(x, y + 1, f) if y < 9\nend\n\ndef count(x, y, f)\n  c = 0\n  b = 1 << x\n  c += 1 if (f[y] & b) != 0\n  c += 1 if x > 0 && (f[y] & (b >> 1)) != 0\n  c += 1 if x < 9 && (f[y] & (b << 1)) != 0\n  c += 1 if y > 0 && (f[y - 1] & b) != 0\n  c += 1 if y < 9 && (f[y + 1] & b) != 0\n  return c\nend\n\n### main\n\nn = gets.strip.to_i\n\nn.times.each do\n  flds = []\n  ans = []\n  10.times.each do\n    hl = gets.strip.gsub(/ /, '').reverse.to_i(2)\n    flds.push hl\n    ans.push 0\n  end\n\n  shoots = []\n\n  while true\n    counts = []\n    for y in (0..9)\n      for x in (0..9)\n        c = count(x, y, flds)\n        counts.push [c, x, y] if c > 0\n      end\n    end\n    break if counts.empty?\n\n    #p counts.sort{|a, b| b[0] <=> a[0]}\n    c, x, y = counts.max{|a, b| a[0] <=> b[0]}\n    #p [c, x, y]\n\n    shoots.push [x, y]\n    shoot(x, y, flds)\n    set(x, y, ans)\n    #flds.each{|bits| puts (\"%010b\" % bits).reverse}\n  end\n\n  ans.each{|bits| puts (\"%010b\" % bits).reverse.split(\"\").join(\" \")}\nend"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef lightsout(x,y)\n  #now=Time.now.to_f\n  succ=0\n  a=Array.new(x*y)\n  a.length.times{|i| a[i]=Array.new(2)}\n\n  #create problem\n  x.times{|i|\n    y.times{|j|\n      a[i+j*x][0]=1<<(i+j*x)\n      a[i+j*x][1]= 0 +\n        (1<<(i+j*x)) +\n        (i>0   ? 1<<(i-1+j*x) : 0) +\n        (i<x-1 ? 1<<(i+1+j*x) : 0) +\n        (j>0   ? 1<<(i+(j-1)*x) : 0) +\n        (j<y-1 ? 1<<(i+(j+1)*x) : 0) +\n        0\n    }\n  }\n\n  #solve\n  (x*y).times{|i|\n    if a[i][1]&1<<i==0\n      (i+1).step(x*y-1) {|j|\n        if a[j][1]&1<<i!=0\n          a[i],a[j]=a[j],a[i]\n          succ=1\n          break\n        end\n      }\n      if succ==0 then break end\n      succ=0\n    end\n\n    (x*y).times{|j|\n      if i!=j && a[j][1]&1<<i!=0\n        a[j][0]^=a[i][0]\n        a[j][1]^=a[i][1]\n      end\n    }\n\n    #$stderr.printf(\"%d/%d passes\\r\",i+1,x*y)\n  }\n  #$stderr.puts\n\n\tgets.to_i.times{\n\t\tprob=[];ans=[0]*x*y\n\t\ty.times{prob+=gets.split.map(&:to_i)}\n\t\t(x*y).times{|i|if prob[i]>0 then (x*y).times{|j|ans[j]^=a[j][0][i]}end}\n\t\ty.times{|i|puts ans[i*x,x].map(&:to_s).join(' ')}\n\t}\n\n=begin\n  #output as C\n  print <<\"EOM\"\n#include <stdio.h>\nint table[#{x*y}][#{x*y}]={\nEOM\n\n  a.each{|b|\n    print \"  {\"\n    a.length.times{|c|\n      print \"#{b[0][c]},\"\n    }\n    print \"},\\n\"\n  }\n\n  print <<\"EOM\"\n};\nint prob[#{x*y}], ans[#{x*y}];\n\nmain(b,c,i,j){\n  for(scanf(\"%d\",&c);b<=c;b++){\n    for(i=0;i<#{x*y};i++)\n      scanf(\"%d\",prob+i),ans[i]=0;\n    for(i=0;i<#{x*y};i++)\n      if(prob[i])\n        for(j=0;j<#{x*y};j++)\n          ans[j]^=table[i][j];\n    for(j=0;j<#{y};printf(\"\\\\n\"),j++)\n      for(i=0;i<#{x};i++)\n        printf(i<#{x-1}?\"%d \":\"%d\",ans[i+j*#{x}]);\n  }\n  return 0;\n}\nEOM\n$stderr.printf(\"%.3f ms\\n\",Time.now.to_f-now)\n=end\nend\n\nlightsout(10,10)"
  },
  {
    "language": "Ruby",
    "code": "def set(x, y, f)\n  f[y] ^= (1 << x)\nend\n\ndef isset?(x, y, f)\n  return (f[y] & (1 << x)) != 0\nend\n\ndef shoot(x, y, f)\n  set(x, y, f)\n  set(x - 1, y, f) if x > 0\n  set(x + 1, y, f) if x < 9\n  set(x, y - 1, f) if y > 0\n  set(x, y + 1, f) if y < 9\nend\n\ndef count(x, y, f)\n  c = 0\n  c += 1 if isset?(x, y, f)\n  c += 1 if x > 0 && isset?(x - 1, y, f)\n  c += 1 if x < 9 && isset?(x + 1, y, f)\n  c += 1 if y > 0 && isset?(x, y - 1, f)\n  c += 1 if y < 9 && isset?(x, y + 1, f)\n  return c\nend\n\ndef check_shoot(f, ans)\n  bits = 0\n  f.each{|b| bits |= b}\n  if bits == 0\n    ans.each{|b| puts (\"%010b\" % b).reverse.split(\"\").join(\" \")}\n    return true\n  end\n\n  counts = []\n  for y in (0..9)\n    for x in (0..9)\n      if ! isset?(x, y, ans)\n        c = count(x, y, f)\n        counts.push [c, x, y] if c > 0\n      end\n    end\n  end\n\n  for cnt in counts.sort{|a, b| b[0] <=> a[0]}\n    c, x, y = cnt\n\n    shoot(x, y, f)\n    set(x, y, ans)\n\n    return true if check_shoot(f, ans)\n\n    set(x, y, ans)\n    shoot(x, y, f)\n  end\n\n  return false\nend\n\n### main\n\nn = gets.strip.to_i\n\nn.times.each do\n  flds = []\n  ans = []\n  10.times.each do\n    hl = gets.strip.gsub(/ /, '').reverse.to_i(2)\n    flds.push hl\n    ans.push 0\n  end\n\n  check_shoot(flds, ans)\nend"
  },
  {
    "language": "Ruby",
    "code": "z=[0]\ns=r=0..9\ngets.to_i.times{m=r.map{gets.split.map(&:to_i)+z}+[z*11]\nputs ([[0,1].product(*[[0,1]]*9).find{|a|s=m.dup<<a+z\nr.map{|i|s[i]=s[i][r].zip(e=s[i-1],s[i-2],e.rotate,e.rotate(-1)).map{|l|l.inject(:+)%2}+z}\ns[9].all?{|j|j==0}}]+s[0,9]).map{|a|a[r]*\" \"}}"
  },
  {
    "language": "Ruby",
    "code": "def flip(x, y, grid)\n  dx = [0, 0, 1, 0, -1]\n  dy = [0, -1, 0, 1, 0]\n\n  for i in 0...5\n    if x + dx[i] >= 0 && x + dx[i] < 10 && y + dy[i] >= 0 && y + dy[i] < 10\n      grid[y + dy[i]][x + dx[i]] ^= 1 \n    end\n  end\n\nend\n\n\nn = gets.chomp.to_i\n\nn.times do\n  original = []\n  10.times do\n    original << gets.chomp.split.map(&:to_i)\n  end\n\n  for i in 0...(1 << 10)\n    clone = Marshal.load(Marshal.dump(original))\n    result = Array.new(10) { Array.new(10, 0) }\n    for j in 0...10\n      if i >> j & 1 == 1\n        flip(j, 0, clone)\n        result[0][j] = 1\n      end\n    end\n\n    for y in 1...10\n      for x in 0...10\n        if clone[y - 1][x] == 1\n          result[y][x] = 1\n          flip(x, y, clone)\n        end\n      end\n    end\n\n    unless clone.flatten.include?(1)\n      result.each do |row|\n        puts row.join(' ')\n      end\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def flip(x, y, grid)\n  dx = [0, 0, 1, 0, -1]\n  dy = [0, -1, 0, 1, 0]\n\n  for i in 0...5\n    if x + dx[i] >= 0 && x + dx[i] < 10 && y + dy[i] >= 0 && y + dy[i] < 10\n      grid[y + dy[i]][x + dx[i]] ^= 1 \n    end\n  end\n\nend\n\n\nn = gets.chomp.to_i\n\nn.times do\n  original = []\n  10.times do\n    original << gets.chomp.split.map(&:to_i)\n  end\n\n  for i in 0...(1 << 10)\n    clone = Marshal.load(Marshal.dump(original))\n    for j in 0...10\n      flip(j, 0, clone) if i >> j & 1 == 1\n    end\n\n    result = Array.new(10) { Array.new(10, 0) }\n\n    for y in 1...10\n      for x in 0...10\n        if clone[y - 1][x] == 1\n          result[y][x] = 1\n          flip(x, y, clone)\n        end\n      end\n    end\n\n    unless clone.flatten.include?(1)\n      result.each do |row|\n        puts row.join(' ')\n      end\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "dx = [0, 0, 1, 0, -1]\ndy = [0, -1, 0, 1, 0]\n\nn = gets.chomp.to_i\n\nn.times do\n  original = []\n  10.times do\n    original << gets.chomp.split.map(&:to_i)\n  end\n\n  for i in 0...(1 << 10)\n    clone = Marshal.load(Marshal.dump(original))\n    for j in 0...10\n      clone[0][j] ^= i >> j & 1\n    end\n\n    result = Array.new(10) { Array.new(10, 0) }\n\n    for y in 1...10\n      for x in 0...10\n        if clone[y - 1][x] == 1\n          result[y][x] = 1\n          for i in 0...5\n            if x + dx[i] >= 0 && x + dx[i] < 10 && y + dy[i] >= 0 && y + dy[i] < 10\n              clone[y + dy[i]][x + dx[i]] ^= 1 \n            end\n          end\n        end\n      end\n    end\n\n    unless clone.flatten.include?(1)\n      result.each do |row|\n        puts row.join(' ')\n      end\n      break\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "def set(x, y, f)\n  f[y] ^= (1 << x)\nend\n\ndef isset?(x, y, f)\n  return (f[y] & (1 << x)) != 0\nend\n\ndef shoot(x, y, f)\n  set(x, y, f)\n  set(x - 1, y, f) if x > 0\n  set(x + 1, y, f) if x < 9\n  set(x, y - 1, f) if y > 0\n  set(x, y + 1, f) if y < 9\nend\n\ndef count(x, y, f)\n  c = 0\n  c += 1 if isset?(x, y, f)\n  c += 1 if x > 0 && isset?(x - 1, y, f)\n  c += 1 if x < 9 && isset?(x + 1, y, f)\n  c += 1 if y > 0 && isset?(x, y - 1, f)\n  c += 1 if y < 9 && isset?(x, y + 1, f)\n  return c\nend\n\n### main\n\nn = gets.strip.to_i\n\nn.times.each do\n  flds = []\n  ans = []\n  10.times.each do\n    hl = gets.strip.gsub(/ /, '').reverse.to_i(2)\n    flds.push hl\n    ans.push 0\n  end\n\n  shoots = []\n\n  while true\n    counts = []\n    for y in (0..9)\n      for x in (0..9)\n        if ! isset?(x, y, ans)\n          c = count(x, y, flds)\n          counts.push [c, x, y] if c > 0\n        end\n      end\n    end\n    break if counts.empty?\n\n    #p counts.sort{|a, b| b[0] <=> a[0]}\n    c, x, y = counts.max{|a, b| a[0] <=> b[0]}\n    #p [c, x, y]\n\n    shoots.push [x, y]\n    shoot(x, y, flds)\n    set(x, y, ans)\n    #flds.each{|bits| puts (\"%010b\" % bits).reverse}\n  end\n\n  ans.each{|bits| puts (\"%010b\" % bits).reverse.split(\"\").join(\" \")}\nend"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar (\n\ttable, ans = [12][12]int{}, [12][12]int{}\n)\n\nfunc main() {\n\tscanner.Scan()\n\tn, _ := strconv.Atoi(scanner.Text())\n\tfor i := 0; i < n; i++ {\n\t\tfor j := 1; j < 11; j++ {\n\t\t\tscanner.Scan()\n\t\t\tinput := strings.Split(scanner.Text(), \" \")\n\t\t\ttmp := [10]int{}\n\t\t\tfor k := range input {\n\t\t\t\ttmp[k], _ = strconv.Atoi(input[k])\n\t\t\t}\n\t\t\tfor l := 1; l < 11; l++ {\n\t\t\t\ttable[j][l] = tmp[l-1]\n\t\t\t}\n\t\t}\n\t\tcheck(table, 1, ans)\n\t}\n}\n\nfunc check(table [12][12]int, i int, ans [12][12]int) {\n\tif i == 11 {\n\t\tsolve(table, 2, 1, ans)\n\t\treturn\n\t}\n\tans[1][i] = 0\n\tcheck(table, i+1, ans)\n\tans[1][i] = 1\n\tattack(table, 1, i)\n\tcheck(table, i+1, ans)\n\tattack(table, 1, i)\n}\n\nfunc solve(table [12][12]int, i, j int, ans [12][12]int) {\n\tif i == 11 {\n\t\tflag := true\n\t\tfor k := 1; k < 11; k++ {\n\t\t\tif table[10][k] == 1 {\n\t\t\t\tflag = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif flag {\n\t\t\tprintans(ans)\n\t\t}\n\t\treturn\n\t}\n\tif table[i-1][j] == 1 {\n\t\tans[i][j] = 1\n\t\tattack(table, i, j)\n\t\tif j == 10 {\n\t\t\tsolve(table, i+1, 1, ans)\n\t\t} else {\n\t\t\tsolve(table, i, j+1, ans)\n\t\t}\n\t\tattack(table, i, j)\n\t\tans[i][j] = 0\n\t} else {\n\t\tans[i][j] = 0\n\t\tif j == 10 {\n\t\t\tsolve(table, i+1, 1, ans)\n\t\t} else {\n\t\t\tsolve(table, i, j+1, ans)\n\t\t}\n\t}\n}\n\nfunc printans(ans [12][12]int) {\n\tfor i := 1; i < 11; i++ {\n\t\tfor j := 1; j < 11; j++ {\n\t\t\tfmt.Print(ans[i][j])\n\t\t\tif j < 10 {\n\t\t\t\tfmt.Print(\" \")\n\t\t\t}\n\t\t}\n\t\tfmt.Println()\n\t}\n}\n\nfunc attack(table [12][12]int, i, j int) {\n\ttable[i][j] = 1 - table[i][j]\n\ttable[i-1][j] = 1 - table[i-1][j]\n\ttable[i+1][j] = 1 - table[i+1][j]\n\ttable[i][j-1] = 1 - table[i][j-1]\n\ttable[i][j+1] = 1 - table[i][j+1]\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\n\nint cnt[10][10];\nint main() {\n\tint n; scanf(\"%d\", &n);\n\trep(t, n) {\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\tvector<P>v;\n\t\trep(i, 10)rep(j, 10) {\n\t\t\tint d; scanf(\"%d\", &d);\n\t\t\tif (!d)continue;\n\t\t\tcnt[i][j]++;\n\n\t\t\trep(k, 4) {\n\t\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\t\tif (0 <= nx&&nx < 10 && 0 <= ny&&ny < 10)cnt[nx][ny]++;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.array;\n\nint[] dx = [0, -1, 0, 1, 0];\nint[] dy = [-1, 0, 0, 0, 1];\nstring str;\nstring[10] s;\nchar[10][10] ch;\nint[10][10] ans;\n\nvoid main(){\n\tint n;\n\treadf(\"%d\\n\", &n);\n\tfor (int i = 0; i < n; i++) {\n\t\tforeach (j; 0..10) s[j] = replace(chomp(readln()), \" \", \"\");\n\t\t// try all patterns in 1st line\n\t\tfor (int j = 0; j  < 2^^10 ; j++) {\n\t\t\tstr = format(\"%010b\", j);\n\t\t\tforeach (k; 0..10) {\n\t\t\t\tch[k] = s[k];\n\t\t\t\tans[k] = 0;\n\t\t\t}\n\t\t\tif (solve()) break;\n\t\t}\n\t\t// print\n\t\tforeach (y; 0..10) {\n\t\t\twrite(ans[y][0]);\n\t\t\tforeach (x; 1..10) {\n\t\t\t\twrite(\" \", ans[y][x]);\n\t\t\t}\n\t\t\twriteln();\n\t\t}\n\t}\n}\n\nvoid toggle(int px, int py){\n\tint x, y;\n\tforeach (i; 0..5) {\n\t\tx = dx[i]+px;\n\t\ty = dy[i]+py;\n\t\tif (x < 0 || x > 9 || y < 0 || y > 9) continue;\n\n\t\tif(ch[y][x] == '0') ch[y][x] = '1';\n\t\telse ch[y][x] = '0';\n\t}\n}\n\nbool solve(){\n\tforeach (y; 0..10) {\n\t\tforeach (x; 0..10) {\n\t\t\tif ((y == 0 && str[x] == '1') || (y > 0 && ch[y-1][x] == '1')) {\n\t\t\t\ttoggle(x, y);\n\t\t\t\tans[y][x] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t// check\n\tforeach (y; 0..10)\n\t\tforeach (x; 0..10)\n\t\tif (ch[y][x] == '1') return false;\n\treturn true;\n}"
  },
  {
    "language": "Python",
    "code": "def f(x,y):\n  global B\n  B[y][x]^=1\n  if y>0: B[y-1][x]^=1\n  if y<9: B[y+1][x]^=1\n  if x>0: B[y][x-1]^=1\n  if x<9: B[y][x+1]^=1\n  return\nR=range(10)\nn=input()\nfor _ in [0]*n:\n  A=[map(int,raw_input().split()) for _ in R]\n  for p in range(1024):\n    B=[A[i][:] for i in R]\n    x=[]\n    for j in R:\n      if j==0: a=map(int,list(format(p,'010b')))\n      else: a=B[j-1]\n      for i in R:\n        if a[i]==1:\n          x.append((i,j))\n          f(i,j)\n    if sum(B[9])==0: break\n  for i,j in x: B[j][i]=1\n  for e in B: print \" \".join(map(str,e))"
  },
  {
    "language": "Python",
    "code": "def attack(table, i, j):\n    table[i][j] = 1 - table[i][j]\n    table[i-1][j] = 1 - table[i-1][j]\n    table[i+1][j] = 1 - table[i+1][j]\n    table[i][j-1] = 1 - table[i][j-1]\n    table[i][j+1] = 1 - table[i][j+1]\n\ndef printans(ans):\n    for i in range(1, 11):\n        for j in range(1, 11):\n            print(ans[i][j], end=\"\")\n            if j < 10:\n                print(\" \", end=\"\")\n        print(\"\")\n\ndef solve(table, i, j, ans):\n\n    #print(i,j)\n    if i == 11:\n        flag = True\n        for k in range(1,11):\n            if table[10][k] == 1:\n                flag = False\n                break\n        if flag:\n            printans(ans)\n        return\n\n    if table[i-1][j] == 1:\n        ans[i][j] = 1\n        attack(table, i, j)\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n        attack(table, i, j)\n        ans[i][j] = 0\n    else:\n        ans[i][j] = 0\n        if j == 10:\n            solve(table, i+1, 1, ans)\n        else:\n            solve(table, i, j+1, ans)\n\n\ndef check(table, i, ans):\n\n    if i == 11:\n        solve(table, 2, 1, ans)\n        return\n\n    ans[1][i] = 0\n    check(table, i+1, ans)\n\n    ans[1][i] = 1\n    attack(table, 1, i)\n    check(table, i+1, ans)\n    attack(table, 1, i)\n\nN = int(input())\n\nfor l in range(N):\n    table= [[0 for i in range(12)] for j in range(12)]\n    ans= [[0 for i in range(12)] for j in range(12)]\n    for i in range(1, 11):\n        nums = [int(k) for k in input().split()]\n        for j in range(1, 11):\n            table[i][j] = nums[j-1]\n\n    check(table, 1, ans)\n"
  },
  {
    "language": "Python",
    "code": "def f(x,y):\n  global B\n  B[y][x]^=1\n  if y>0: B[y-1][x]^=1\n  if y<9: B[y+1][x]^=1\n  if x>0: B[y][x-1]^=1\n  if x<9: B[y][x+1]^=1\n  return (x,y)\nR=range(10)\nn=input()\nfor _ in [0]*n:\n  A=[map(int,raw_input().split()) for _ in R]\n  for p in range(1024):\n    B=[e[:] for e in A]\n    x=[]\n    for j in R:\n      a=[map(int,list(format(p,'010b'))),B[j-1]][j!=0]\n      for i in R:\n        if a[i]==1: x.append(f(i,j))\n    if sum(B[9])==0: break\n  for i,j in x: B[j][i]=1\n  for e in B: print \" \".join(map(str,e))"
  },
  {
    "language": "Python",
    "code": "import itertools\ndef change(m, x, y):\n    m[y][x] ^= 1\n    if y>0: m[y-1][x] ^= 1\n    if x>0: m[y][x-1] ^= 1\n    if x<9: m[y][x+1] ^= 1\n    if y<9: m[y+1][x] ^= 1\nans = [[0] * 10 for i in xrange(10)]\nfor t in xrange(input()):\n    m = [map(int, raw_input().split()) for i in xrange(10)]\n    for p in itertools.product((0,1), repeat=10):\n        mm = [m[i][:] for i in xrange(10)]\n        for i in xrange(10):\n            if p[i]:\n                change(mm, i, 0)\n            ans[0][i] = p[i]\n        for i in xrange(9):\n            for j in xrange(10):\n                if mm[i][j]:\n                    change(mm, j, i+1)\n                    ans[i+1][j] = 1\n                else:\n                    ans[i+1][j] = 0\n        if not any(mm[9]):\n            for i in xrange(10):\n                print \" \".join(map(str, ans[i]))\n            break"
  },
  {
    "language": "Python",
    "code": "def f(x,y):\n  global B\n  B[y][x]^=1\n  if y>0: B[y-1][x]^=1\n  if y<9: B[y+1][x]^=1\n  if x>0: B[y][x-1]^=1\n  if x<9: B[y][x+1]^=1\n  return (x,y)\nR=range(10)\nn=input()\nfor _ in [0]*n:\n  A=[map(int,raw_input().split()) for _ in R]\n  for p in range(1024):\n    B=[e[:] for e in A]\n    x=[]\n    for j in R:\n      if j==0: a=map(int,list(format(p,'010b')))\n      else: a=B[j-1]\n      for i in R:\n        if a[i]==1: x.append(f(i,j))\n    if sum(B[9])==0: break\n  for i,j in x: B[j][i]=1\n  for e in B: print \" \".join(map(str,e))"
  },
  {
    "language": "Python",
    "code": "L = [(512,768,512)] + [(256>>i,896>>i,256>>i) for i in xrange(9)]\n\ndef put(f,x,y):\n    for yy,b in zip(xrange(y-1,y+2),L[x]):\n        f[yy] = f[yy] ^ b\n\ndef solve(F):\n    for i in xrange(1<<10):\n        f = [0] + F + [0]\n        ret = []\n        for x in (x for x in xrange(10) if 1<<x & i != 0):\n            put(f,x,1)\n            ret.append((x,0))\n        f.pop(0)\n        for y in xrange(9):\n            for x in (x for x in xrange(10) if 1<<(9-x) & f[y] != 0):\n                put(f,x,y+1)\n                ret.append((x,y+1))\n\n        if f[9] == 0:\n            return ret\n    \nfor _ in xrange(input()):\n    F = [int(raw_input().replace(\" \",\"\"),2) for _ in xrange(10)]\n    pos = solve(F)    \n    print \"\\n\".join([\" \".join(\"1\" if (x,y) in pos else \"0\" for x in xrange(10))\\\n                         for y in xrange(10)])"
  },
  {
    "language": "Python",
    "code": "from copy import deepcopy\n\ndef show(o):\n    for i in range(10):\n        print ' '.join(map(str, o[i]))\n\ndef e(o, i, j):\n    px = [-1, 0, 0, 1, 0]\n    py = [0, -1, 0, 0, 1]\n    for k in range(5):\n        if i + py[k] >= 0 and j + px[k] >= 0 and i + py[k] < 10 and j + px[k] < 10:\n            o[i + py[k]][j + px[k]] = 1 - o[i + py[k]][j + px[k]]\n\ndef f(o, n):\n    r = [[0] * 10 for i in range(10)]\n    for i in range(10):\n        if n >> i & 1 == 1:\n            e(o, 0, i)\n            r[0][i] = 1\n    for i in range(1, 10):\n        for j in range(10):\n            if o[i - 1][j] == 1:\n                e(o, i, j)\n                r[i][j] = 1\n    if 1 not in o[9]:\n        show(r)\n        return True\n    return False\n\nn = int(raw_input())\nfor _ in range(n):\n    o = [map(int, raw_input().split()) for i in range(10)]\n    for i in range(2 ** 10):\n        if f(deepcopy(o), i):\n            break"
  },
  {
    "language": "Python",
    "code": "from itertools import product\n\ndef upd(line, fix):\n  for i, v in enumerate(fix):\n   if v:\n     if i == 0:\n       line[i] = not line[i]\n       line[i + 1] = not line[i + 1]\n     elif i == 9:\n       line[i - 1] = not line[i - 1]\n       line[i] = not line[i]\n     else:\n       line[i - 1] = not line[i - 1]\n       line[i] = not line[i]\n       line[i + 1] = not line[i + 1]\n  return list(map(int, line))\n\ndef upd2(line, fix):\n  return [int(i != j) for i, j in zip(line, fix)]\n\nn = int(input())\nfor _ in range(n):\n  base_mp = [list(map(int, input().split())) for _ in range(10)]\n  for first_row in product([0, 1], repeat=10):\n    mp = [list(first_row)] + [[i for i in base_mp[j]] for j in range(10)]\n    save = []\n    for i in range(10):\n      save.append(mp[i])\n      mp[i + 1] = upd(mp[i + 1], mp[i])\n      if i == 9:continue\n      mp[i + 2] = upd2(mp[i + 2], mp[i])\n    \n    if not any(mp[10]):\n      for line in save:\n        print(*line)\n      break\n\n"
  },
  {
    "language": "Python",
    "code": "def f(x,y):\n  B[y][x]^=1\n  if y>0: B[y-1][x]^=1\n  if y<9: B[y+1][x]^=1\n  if x>0: B[y][x-1]^=1\n  if x<9: B[y][x+1]^=1\n  return\nR=range(10)\nn=input()\nfor _ in [0]*n:\n  A=[map(int,raw_input().split()) for i in R]\n  for p in range(1024):\n    B=A[:]\n    x=[]\n    for j in R:\n      if j==0: a=map(int,list(format(p,'010b')))\n      else: a=B[j-1]\n      for i in R:\n        if a[i]==1:\n          x.append((i,j))\n          f(i,j)\n    if sum(B[9])==0: break\n  for i,j in x: A[j][i]=1\n  for e in A: print \" \".join(map(str,e))"
  },
  {
    "language": "Python",
    "code": "L = [(512,768,512)] + [(256>>i,896>>i,256>>i) for i in xrange(9)]\n\ndef put(f,x,y):\n    for yy,b in zip(xrange(y-1,y+2),L[x]):\n        f[yy] = f[yy] ^ b\n\ndef solve(F):\n    for i in xrange(1<<10):\n        f = [0] + F + [0]\n        ret = []\n        for x in (x for x in xrange(10) if (1<<x & i) != 0):\n            put(f,x,1)\n            ret.append((x,0))\n        f.pop(0)\n        for y in xrange(9):\n            for x in (x for x in xrange(10) if (1<<(9-x) & f[y]) != 0):\n                put(f,x,y+1)\n                ret.append((x,y+1))\n        if f[9] == 0:\n            return ret\n    \nfor _ in xrange(input()):\n    F = [int(raw_input().replace(\" \",\"\"),2) for _ in xrange(10)]\n    P = solve(F)    \n    print \"\\n\".join([\" \".join(\"1\" if (x,y) in P else \"0\" for x in xrange(10))\\\n                         for y in xrange(10)])"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  let n: u32 = read();\n\n  for _ in 0 .. n {\n    let mut v: Vec<Vec<usize>> = Vec::new();\n    \n    v.push(vec![0; 10]);\n    \n    for _ in 0 .. 10 {\n      v.push(read_vec());\n    }\n\n    for i in 0 .. 1024 {\n      let mut cv = v.clone();\n      for j in 0 .. 10 {\n        if i & (1 << j) > 0 {\n          cv[0][j] = 1;\n        } else {\n          cv[0][j] = 0;\n        }\n      }\n      match pass(&mut cv) {\n        Some(ans) => {print_vec(&ans); break;},\n        None => {},\n      }\n    }\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\nfn print_vec(v: &Vec<Vec<usize>>) -> (){\n  let l = v[0].len();\n\n  for x in v {\n    for i in 0 .. l {\n      if i == l - 1 {\n        println!(\"{}\", x[i]);\n      } else {\n        print!(\"{} \", x[i]);\n      }\n    }\n  }\n}\n\nfn pass(v: &mut Vec<Vec<usize>>) -> Option<Vec<Vec<usize>>> {\n  let mut ans: Vec<Vec<usize>> = vec![vec![0; 10]; 10];\n  let dv: Vec<(isize, isize)> = vec![(0, 0), (-1, 0), (1, 0), (0, -1), (0, 1)];\n  \n  for i in 1 .. 11 {\n    for j in 0 .. 10 {\n      if v[i-1][j] == 1 {\n        ans[i-1][j] = 1;\n        for &(di, dj) in &dv {\n          let ni = i as isize + di;\n          let nj = j as isize + dj;\n          if ni >= 0 && ni <= 10 && nj >= 0 && nj <= 9 {\n            v[ni as usize][nj as usize] = 1 - v[ni as usize][nj as usize];\n          }\n        }\n      }\n    }\n  }\n  \n  if v[10] == vec![0; 10] {\n    Some(ans)\n  } else {\n    None\n  }\n}\n\n"
  }
]