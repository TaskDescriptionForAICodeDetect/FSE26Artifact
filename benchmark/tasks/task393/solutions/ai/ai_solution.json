[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_RC 1000\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint R, C;\nchar grid[MAX_RC][MAX_RC];\nint parent[MAX_RC][MAX_RC][2];\nint dist[MAX_RC][MAX_RC];\nPoint queue[MAX_RC * MAX_RC];\nint front, rear;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nvoid bfs(int sx, int sy) {\n    front = rear = 0;\n    memset(dist, -1, sizeof(dist));\n    dist[sx][sy] = 0;\n    queue[rear++] = (Point){sx, sy};\n    parent[sx][sy][0] = -1;\n    parent[sx][sy][1] = -1;\n\n    while (front < rear) {\n        Point p = queue[front++];\n        for (int d = 0; d < 4; d++) {\n            int nx = p.x + dx[d];\n            int ny = p.y + dy[d];\n            if (nx >= 0 && nx < R && ny >= 0 && ny < C && grid[nx][ny] != '#' && dist[nx][ny] == -1) {\n                dist[nx][ny] = dist[p.x][p.y] + 1;\n                parent[nx][ny][0] = p.x;\n                parent[nx][ny][1] = p.y;\n                queue[rear++] = (Point){nx, ny};\n            }\n        }\n    }\n}\n\nvoid get_path(Point from, Point to, Point* path, int* path_len) {\n    bfs(from.x, from.y);\n    *path_len = 0;\n    Point current = to;\n    while (current.x != from.x || current.y != from.y) {\n        path[(*path_len)++] = current;\n        current.x = parent[current.x][current.y][0];\n        current.y = parent[current.y][current.x][1];\n    }\n    path[(*path_len)++] = from;\n    for (int i = 0; i < *path_len / 2; i++) {\n        Point temp = path[i];\n        path[i] = path[*path_len - 1 - i];\n        path[*path_len - 1 - i] = temp;\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &R, &C);\n    for (int i = 0; i < R; i++) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    int T;\n    scanf(\"%d\", &T);\n    Point tasks[T];\n    for (int i = 0; i < T; i++) {\n        scanf(\"%d %d\", &tasks[i].x, &tasks[i].y);\n    }\n\n    Point current = tasks[0];\n    int light_on[MAX_RC][MAX_RC] = {0};\n    int total_cost = 0;\n    light_on[current.x][current.y] = 1;\n    total_cost += 1; // cost to switch on\n\n    for (int i = 1; i < T; i++) {\n        Point next = tasks[i];\n        Point path[MAX_RC * MAX_RC];\n        int path_len;\n        get_path(current, next, path, &path_len);\n\n        for (int j = 1; j < path_len; j++) {\n            Point p = path[j];\n            if (!light_on[p.x][p.y]) {\n                light_on[p.x][p.y] = 1;\n                total_cost += 1; // cost to switch on\n            }\n            total_cost += 1; // time unit cost\n        }\n\n        for (int j = path_len - 2; j >= 0; j--) {\n            Point p = path[j];\n            if (light_on[p.x][p.y] && (j == 0 || !light_on[path[j-1].x][path[j-1].y])) {\n                light_on[p.x][p.y] = 0;\n                total_cost += 1; // cost to switch off\n            }\n        }\n\n        current = next;\n    }\n\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            if (light_on[i][j]) {\n                total_cost += 1; // cost to switch off\n                light_on[i][j] = 0;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", total_cost);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Room {\n    int r, c;\n    bool operator==(const Room &other) const {\n        return r == other.r && c == other.c;\n    }\n};\n\nnamespace std {\n    template<>\n    struct hash<Room> {\n        size_t operator()(const Room &room) const {\n            return hash<int>()(room.r) ^ hash<int>()(room.c);\n        }\n    };\n}\n\nclass Office {\nprivate:\n    int R, C;\n    vector<vector<char>> grid;\n    unordered_map<Room, vector<Room>> adj;\n\n    void buildAdjacency() {\n        for (int r = 0; r < R; ++r) {\n            for (int c = 0; c < C; ++c) {\n                if (grid[r][c] == '.') {\n                    Room room{r, c};\n                    vector<Room> neighbors;\n                    if (r > 0 && grid[r-1][c] == '.') neighbors.push_back({r-1, c});\n                    if (r < R-1 && grid[r+1][c] == '.') neighbors.push_back({r+1, c});\n                    if (c > 0 && grid[r][c-1] == '.') neighbors.push_back({r, c-1});\n                    if (c < C-1 && grid[r][c+1] == '.') neighbors.push_back({r, c+1});\n                    adj[room] = neighbors;\n                }\n            }\n        }\n    }\n\n    vector<Room> getPath(Room start, Room end) {\n        unordered_map<Room, Room> parent;\n        queue<Room> q;\n        q.push(start);\n        parent[start] = {-1, -1};\n\n        while (!q.empty()) {\n            Room current = q.front();\n            q.pop();\n            if (current == end) break;\n            for (Room neighbor : adj[current]) {\n                if (parent.find(neighbor) == parent.end()) {\n                    parent[neighbor] = current;\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        vector<Room> path;\n        Room current = end;\n        while (!(current == start)) {\n            path.push_back(current);\n            current = parent[current];\n        }\n        path.push_back(start);\n        reverse(path.begin(), path.end());\n        return path;\n    }\n\npublic:\n    Office(int R, int C, const vector<vector<char>>& grid) : R(R), C(C), grid(grid) {\n        buildAdjacency();\n    }\n\n    int minimizeElectricity(const vector<Room>& tasks) {\n        if (tasks.empty()) return 0;\n\n        unordered_map<Room, bool> lightStatus;\n        Room current = tasks[0];\n        int totalCost = 0;\n        lightStatus[current] = true;\n        totalCost += 1; // Cost to turn on the first room\n\n        for (size_t i = 1; i < tasks.size(); ++i) {\n            Room next = tasks[i];\n            vector<Room> path = getPath(current, next);\n\n            for (size_t j = 1; j < path.size(); ++j) {\n                Room room = path[j];\n                if (!lightStatus[room]) {\n                    lightStatus[room] = true;\n                    totalCost += 1; // Cost to turn on\n                }\n                totalCost += 1; // Cost for time unit\n            }\n\n            for (size_t j = 0; j < path.size() - 1; ++j) {\n                Room room = path[j];\n                if (lightStatus[room]) {\n                    lightStatus[room] = false;\n                    totalCost += 1; // Cost to turn off\n                }\n            }\n            current = next;\n        }\n\n        for (auto& entry : lightStatus) {\n            if (entry.second) {\n                totalCost += 1; // Cost to turn off remaining lights\n            }\n        }\n\n        return totalCost;\n    }\n};\n\nint main() {\n    int R, C;\n    cin >> R >> C;\n    vector<vector<char>> grid(R, vector<char>(C));\n    for (int r = 0; r < R; ++r) {\n        for (int c = 0; c < C; ++c) {\n            cin >> grid[r][c];\n        }\n    }\n\n    int N;\n    cin >> N;\n    vector<Room> tasks(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> tasks[i].r >> tasks[i].c;\n    }\n\n    Office office(R, C, grid);\n    cout << office.minimizeElectricity(tasks) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:22:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private List<List<Integer>> adj;\n    private int[] parent;\n    private int[] depth;\n    private int R, C;\n    private int[][] roomToNode;\n    private int nodeCount;\n\n    public int minimalElectricityCost(char[][] grid, int[][] tasks) {\n        R = grid.length;\n        C = grid[0].length;\n        roomToNode = new int[R][C];\n        nodeCount = 0;\n\n        // Assign node numbers to rooms\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                if (grid[i][j] == '.') {\n                    roomToNode[i][j] = nodeCount++;\n                } else {\n                    roomToNode[i][j] = -1;\n                }\n            }\n        }\n\n        // Build adjacency list for the tree\n        adj = new ArrayList<>();\n        for (int i = 0; i < nodeCount; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        int[] dx = {-1, 1, 0, 0};\n        int[] dy = {0, 0, -1, 1};\n\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                if (grid[i][j] != '.') continue;\n                int u = roomToNode[i][j];\n                for (int k = 0; k < 4; k++) {\n                    int ni = i + dx[k];\n                    int nj = j + dy[k];\n                    if (ni >= 0 && ni < R && nj >= 0 && nj < C && grid[ni][nj] == '.') {\n                        int v = roomToNode[ni][nj];\n                        adj.get(u).add(v);\n                    }\n                }\n            }\n        }\n\n        // Initialize parent and depth for LCA\n        parent = new int[nodeCount];\n        depth = new int[nodeCount];\n        Arrays.fill(parent, -1);\n        Arrays.fill(depth, -1);\n\n        // BFS to set parent and depth (assuming tree is connected)\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(0);\n        parent[0] = -1;\n        depth[0] = 0;\n\n        while (!queue.isEmpty()) {\n            int u = queue.poll();\n            for (int v : adj.get(u)) {\n                if (parent[v] == -1 && v != parent[u]) {\n                    parent[v] = u;\n                    depth[v] = depth[u] + 1;\n                    queue.add(v);\n                }\n            }\n        }\n\n        int totalCost = 0;\n        int currentPos = roomToNode[tasks[0][0]][tasks[0][1]];\n        Set<Integer> lightsOn = new HashSet<>();\n        lightsOn.add(currentPos);\n        totalCost++; // cost to turn on the first room\n\n        for (int i = 1; i < tasks.length; i++) {\n            int nextPos = roomToNode[tasks[i][0]][tasks[i][1]];\n            int lca = findLCA(currentPos, nextPos);\n\n            // Path from currentPos to LCA\n            List<Integer> path1 = new ArrayList<>();\n            int u = currentPos;\n            while (u != lca) {\n                path1.add(u);\n                u = parent[u];\n            }\n\n            // Path from LCA to nextPos\n            List<Integer> path2 = new ArrayList<>();\n            u = nextPos;\n            while (u != lca) {\n                path2.add(u);\n                u = parent[u];\n            }\n            Collections.reverse(path2);\n\n            // Combine paths\n            List<Integer> fullPath = new ArrayList<>();\n            fullPath.addAll(path1);\n            fullPath.add(lca);\n            fullPath.addAll(path2);\n\n            // Simulate movement along the path\n            for (int room : fullPath) {\n                if (!lightsOn.contains(room)) {\n                    lightsOn.add(room);\n                    totalCost++; // cost to turn on\n                }\n            }\n\n            // Update current position\n            currentPos = nextPos;\n        }\n\n        // Turn off all lights\n        totalCost += lightsOn.size(); // cost to turn off\n        return totalCost;\n    }\n\n    private int findLCA(int u, int v) {\n        while (u != v) {\n            if (depth[u] > depth[v]) {\n                u = parent[u];\n            } else {\n                v = parent[v];\n            }\n        }\n        return u;\n    }\n}",
    "timestamp": "2025-08-05 21:23:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    static class Task {\n        int r, c;\n        Task(int r, int c) {\n            this.r = r;\n            this.c = c;\n        }\n    }\n\n    public int minimizeElectricity(int R, int C, List<Task> tasks, int lightOnCost, int lightSwitchCost) {\n        int[][] graph = new int[R][C];\n        boolean[][] visited = new boolean[R][C];\n        int totalCost = 0;\n        \n        int currentR = 0, currentC = 0;\n        for (Task task : tasks) {\n            // Find path between current location and task location\n            List<int[]> path = findPath(graph, currentR, currentC, task.r, task.c);\n            \n            // Calculate path traversal and light costs\n            for (int[] step : path) {\n                if (!visited[step[0]][step[1]]) {\n                    totalCost += lightSwitchCost;  // Switch on light\n                    visited[step[0]][step[1]] = true;\n                }\n                totalCost += lightOnCost;  // Light on cost while moving\n            }\n            \n            // Update current location\n            currentR = task.r;\n            currentC = task.c;\n        }\n        \n        // Turn off lights at the end\n        for (boolean[] row : visited) {\n            for (boolean light : row) {\n                if (light) {\n                    totalCost += lightSwitchCost;\n                }\n            }\n        }\n        \n        return totalCost;\n    }\n    \n    private List<int[]> findPath(int[][] graph, int startR, int startC, int endR, int endC) {\n        // Implement BFS or DFS to find shortest path between rooms\n        // This is a simplified implementation\n        List<int[]> path = new ArrayList<>();\n        int currentR = startR, currentC = startC;\n        \n        while (currentR != endR || currentC != endC) {\n            if (currentR < endR) currentR++;\n            else if (currentR > endR) currentR--;\n            else if (currentC < endC) currentC++;\n            else if (currentC > endC) currentC--;\n            \n            path.add(new int[]{currentR, currentC});\n        }\n        \n        return path;\n    }\n}",
    "timestamp": "2025-08-05 21:23:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_R 100\n#define MAX_C 100\n#define MAX_TASKS 100\n\ntypedef struct {\n    int r, c;\n} Room;\n\nint R, C, N;\nint grid[MAX_R][MAX_C];\nRoom tasks[MAX_TASKS];\nint light_status[MAX_R][MAX_C];\nint light_on_cost, light_switch_cost;\n\nint manhattan_distance(Room a, Room b) {\n    return abs(a.r - b.r) + abs(a.c - b.c);\n}\n\nint solve_task_routing() {\n    int total_electricity_cost = 0;\n    Room current_pos = tasks[0];\n\n    // Reset light status\n    memset(light_status, 0, sizeof(light_status));\n\n    // Turn on first room's light \n    total_electricity_cost += light_switch_cost;\n    light_status[current_pos.r][current_pos.c] = 1;\n\n    for (int i = 1; i < N; i++) {\n        Room next_task = tasks[i];\n        int path_distance = manhattan_distance(current_pos, next_task);\n\n        // Add path traversal time\n        total_electricity_cost += path_distance * light_on_cost;\n\n        // Check if new room's light needs to be switched on\n        if (!light_status[next_task.r][next_task.c]) {\n            total_electricity_cost += light_switch_cost;\n            light_status[next_task.r][next_task.c] = 1;\n        }\n\n        current_pos = next_task;\n    }\n\n    // Turn off all lights at the end\n    for (int i = 0; i < N; i++) {\n        total_electricity_cost += light_switch_cost;\n    }\n\n    return total_electricity_cost;\n}\n\nint main() {\n    scanf(\"%d %d %d %d %d\", &R, &C, &N, &light_on_cost, &light_switch_cost);\n\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &tasks[i].r, &tasks[i].c);\n    }\n\n    int min_electricity_cost = solve_task_routing();\n    printf(\"%d\\n\", min_electricity_cost);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:23:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <climits>\n#include <queue>\n\nclass Solution {\npublic:\n    int minimizeElectricityCost(\n        std::vector<std::vector<char>>& grid, \n        std::vector<std::pair<int, int>>& tasks, \n        int lightOnCost, \n        int lightSwitchCost\n    ) {\n        int R = grid.size();\n        int C = grid[0].size();\n        std::vector<std::vector<bool>> visited(R, std::vector<bool>(C, false));\n        std::vector<std::vector<int>> distances(R, std::vector<int>(C, INT_MAX));\n        \n        auto dijkstra = [&](int startX, int startY) {\n            std::priority_queue<\n                std::pair<int, std::pair<int, int>>, \n                std::vector<std::pair<int, std::pair<int, int>>>, \n                std::greater<>\n            > pq;\n            \n            pq.push({0, {startX, startY}});\n            distances[startX][startY] = 0;\n            \n            std::vector<std::pair<int, int>> directions = {{0,1}, {0,-1}, {1,0}, {-1,0}};\n            \n            while (!pq.empty()) {\n                auto [cost, pos] = pq.top();\n                pq.pop();\n                \n                int x = pos.first, y = pos.second;\n                \n                if (distances[x][y] < cost) continue;\n                \n                for (auto& [dx, dy] : directions) {\n                    int nx = x + dx, ny = y + dy;\n                    \n                    if (nx >= 0 && nx < R && ny >= 0 && ny < C && grid[nx][ny] != '#') {\n                        int newCost = cost + 1;\n                        \n                        if (newCost < distances[nx][ny]) {\n                            distances[nx][ny] = newCost;\n                            pq.push({newCost, {nx, ny}});\n                        }\n                    }\n                }\n            }\n        };\n        \n        int totalCost = 0;\n        int currentX = 0, currentY = 0;\n        \n        for (auto& [taskX, taskY] : tasks) {\n            // Reset distances for each task\n            std::fill(distances.begin(), distances.end(), std::vector<int>(C, INT_MAX));\n            std::fill(visited.begin(), visited.end(), std::vector<bool>(C, false));\n            \n            // Run Dijkstra from current position\n            dijkstra(currentX, currentY);\n            \n            // If task is unreachable\n            if (distances[taskX][taskY] == INT_MAX) return -1;\n            \n            // Path cost\n            totalCost += distances[taskX][taskY];\n            \n            // Light switch and on costs\n            totalCost += lightSwitchCost + lightOnCost * distances[taskX][taskY];\n            \n            // Update current position\n            currentX = taskX;\n            currentY = taskY;\n        }\n        \n        return totalCost;\n    }\n};",
    "timestamp": "2025-08-05 21:23:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_electricity_consumption(grid, tasks, switch_on_cost, switch_off_cost, electricity_cost):\n    def find_path_bfs(start, end):\n        from collections import deque\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        visited = [[False] * len(grid[0]) for _ in range(len(grid))]\n        queue = deque([(start, [])])\n        visited[start[0]][start[1]] = True\n        \n        while queue:\n            (x, y), path = queue.popleft()\n            if (x, y) == end:\n                return path\n            \n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and not visited[nx][ny] and grid[nx][ny] == '.':\n                    visited[nx][ny] = True\n                    queue.append(((nx, ny), path + [(nx, ny)]))\n        \n        return []\n    \n    def calculate_light_cost(duration, on=True):\n        return switch_on_cost + (electricity_cost * duration) + (0 if on else switch_off_cost)\n\n    total_cost = 0\n    position = tasks[0]\n    lights_on = set()\n    \n    for task in tasks:\n        path = find_path_bfs(position, task)\n        for i, room in enumerate(path):\n            if room not in lights_on:\n                total_cost += calculate_light_cost(1, True)\n                lights_on.add(room)\n            else:\n                total_cost += electricity_cost\n            \n            position = room\n        \n        if i == len(path) - 1 and room in lights_on:\n            total_cost += switch_off_cost\n            lights_on.discard(room)\n    \n    # Ensure all lights are off\n    for room in lights_on:\n        total_cost += switch_off_cost\n        \n    return total_cost\n\n# Example usage:\ngrid = [\n    ['.', '.', '#', '.', '.'],\n    ['.', '#', '#', '.', '.'],\n    ['.', '.', '.', '.', '.'],\n    ['#', '.', '#', '.', '#'],\n    ['.', '.', '.', '#', '.']\n]\ntasks = [(0, 0), (2, 2), (4, 0), (0, 4)]\nprint(min_electricity_consumption(grid, tasks, switch_on_cost=2, switch_off_cost=1, electricity_cost=1))",
    "timestamp": "2025-08-13 06:08:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass TaskManager {\n    static class Room {\n        int row, col;\n\n        Room(int row, int col) {\n            this.row = row;\n            this.col = col;\n        }\n    }\n\n    private int[][] grid;\n    private int R, C;\n    private int switchOnCost;\n    private int switchOffCost;\n    private int lightDurationCost;\n    private List<Room> tasks;\n\n    public TaskManager(int[][] grid, int switchOnCost, int switchOffCost, int lightDurationCost, List<Room> tasks) {\n        this.grid = grid;\n        this.R = grid.length;\n        this.C = grid[0].length;\n        this.switchOnCost = switchOnCost;\n        this.switchOffCost = switchOffCost;\n        this.lightDurationCost = lightDurationCost;\n        this.tasks = tasks;\n    }\n\n    public int computeMinimumElectricityConsumption() {\n        int totalCost = 0;\n        Room prevRoom = tasks.get(0);\n        totalCost += navigateAndOperate(prevRoom, true); //switch on at the first task\n\n        for (int i = 1; i < tasks.size(); i++) {\n            Room currentRoom = tasks.get(i);\n            totalCost += navigateRooms(prevRoom, currentRoom);\n            totalCost += navigateAndOperate(currentRoom, true);\n            totalCost += navigateAndOperate(prevRoom, false);\n            prevRoom = currentRoom;\n        }\n\n        // Turn off the light in the last room\n        totalCost += navigateAndOperate(prevRoom, false);\n\n        return totalCost;\n    }\n\n    private int navigateRooms(Room startRoom, Room endRoom) {\n        boolean[][] visited = new boolean[R][C];\n        Queue<Room> queue = new LinkedList<>();\n        queue.offer(startRoom);\n\n        int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        int distance = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                Room room = queue.poll();\n\n                if (room.row == endRoom.row && room.col == endRoom.col) {\n                    return distance;\n                }\n\n                for (int[] dir : directions) {\n                    int newRow = room.row + dir[0];\n                    int newCol = room.col + dir[1];\n\n                    if (isValidMove(newRow, newCol, visited)) {\n                        visited[newRow][newCol] = true;\n                        queue.offer(new Room(newRow, newCol));\n                    }\n                }\n            }\n            distance++;\n        }\n\n        return -1; // This should not occur given a valid office setup\n    }\n\n    private boolean isValidMove(int row, int col, boolean[][] visited) {\n        return row >= 0 && row < R && col >= 0 && col < C && grid[row][col] != -1 && !visited[row][col];\n    }\n\n    private int navigateAndOperate(Room room, boolean turnOn) {\n        int cost = turnOn ? switchOnCost : switchOffCost; \n        if (turnOn) {\n            cost += lightDurationCost;\n        }\n        return cost;\n    }\n\n    public static void main(String[] args) {\n        int[][] officeGrid = {\n                {0, 0, 0},\n                {0, -1, 0},\n                {0, 0, 0}\n        };\n        int switchOnCost = 2;\n        int switchOffCost = 1;\n        int lightDurationCost = 1;\n\n        List<Room> taskList = Arrays.asList(\n                new Room(0, 0),\n                new Room(2, 2),\n                new Room(0, 2)\n        );\n\n        TaskManager taskManager = new TaskManager(officeGrid, switchOnCost, switchOffCost, lightDurationCost, taskList);\n        int minimumCost = taskManager.computeMinimumElectricityConsumption();\n        System.out.println(\"Minimum Electricity Consumption: \" + minimumCost);\n    }\n}",
    "timestamp": "2025-08-13 06:08:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_R 100\n#define MAX_C 100\n#define INF 1000000\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int x, y, steps;\n} QueueNode;\n\nchar grid[MAX_R][MAX_C];\nbool visited[MAX_R][MAX_C];\nPoint tasks[MAX_R*MAX_C];\nint task_count;\nint dx[] = {1, -1, 0, 0};\nint dy[] = {0, 0, 1, -1};\nint R, C, task_cost_on, task_cost_off, light_cost;\nint optimal_light_cost = 0;\n\n// Function to check if a cell is within bounds and not a wall\nbool isValid(int x, int y) {\n    return x >= 0 && y >= 0 && x < R && y < C && grid[x][y] != '#';\n}\n\n// Function to find the shortest path between rooms using BFS\nint bfs(Point src, Point dest) {\n    if (src.x == dest.x && src.y == dest.y) return 0;\n\n    QueueNode queue[MAX_R * MAX_C];\n    int front = 0, rear = 0;\n\n    for(int i = 0; i < R; ++i) {\n        for(int j = 0; j < C; ++j) {\n            visited[i][j] = false;\n        }\n    }\n\n    visited[src.x][src.y] = true;\n    queue[rear++] = (QueueNode){src.x, src.y, 0};\n\n    while (front != rear) {\n        QueueNode current = queue[front++];\n        for (int dir = 0; dir < 4; ++dir) {\n            int newX = current.x + dx[dir];\n            int newY = current.y + dy[dir];\n\n            if (isValid(newX, newY) && !visited[newX][newY]) {\n                if (newX == dest.x && newY == dest.y) {\n                    return current.steps + 1;\n                }\n                visited[newX][newY] = true;\n                queue[rear++] = (QueueNode){newX, newY, current.steps + 1};\n            }\n        }\n    }\n    return INF;\n}\n\nvoid minimizeElectricityConsumption() {\n    Point currentRoom = tasks[0];\n    optimal_light_cost += task_cost_on;\n\n    for (int i = 1; i < task_count; ++i) {\n        int travel_time = bfs(currentRoom, tasks[i]);\n        \n        optimal_light_cost += (travel_time + 1) * light_cost;\n        \n        currentRoom = tasks[i];\n        \n        if (i < task_count - 1) {\n            optimal_light_cost += task_cost_on;\n        } else {\n            optimal_light_cost += task_cost_off;\n        }\n    }\n}\n\nint main() {\n    // Input grid dimensions\n    scanf(\"%d %d\", &R, &C);\n\n    // Input grid details\n    for (int i = 0; i < R; ++i) {\n        scanf(\"%s\", grid[i]);\n    }\n\n    // Input light switch costs and electricity cost\n    scanf(\"%d %d %d\", &task_cost_on, &task_cost_off, &light_cost);\n\n    // Input tasks\n    scanf(\"%d\", &task_count);\n    for (int i = 0; i < task_count; ++i) {\n        scanf(\"%d %d\", &tasks[i].x, &tasks[i].y);\n    }\n\n    minimizeElectricityConsumption();\n\n    // Output the minimum electricity cost\n    printf(\"%d\\n\", optimal_light_cost);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:09:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport heapq\n\nclass Solution:\n    def minimumElectricityCost(self, grid: List[List[str]], tasks: List[Tuple[int, int]], lightOnCost: int, lightSwitchCost: int) -> int:\n        R, C = len(grid), len(grid[0])\n        \n        def is_valid(x, y):\n            return 0 <= x < R and 0 <= y < C and grid[x][y] == '.'\n        \n        def manhattan_distance(x1, y1, x2, y2):\n            return abs(x1 - x2) + abs(y1 - y2)\n        \n        def find_path(start, end):\n            heap = [(0, start[0], start[1], set())]\n            visited = set()\n            \n            while heap:\n                cost, x, y, path = heapq.heappop(heap)\n                \n                if (x, y) == end:\n                    return cost, path\n                \n                if (x, y) in visited:\n                    continue\n                \n                visited.add((x, y))\n                \n                for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n                    nx, ny = x + dx, y + dy\n                    \n                    if is_valid(nx, ny) and (nx, ny) not in visited:\n                        new_path = path.copy()\n                        new_path.add((nx, ny))\n                        heapq.heappush(heap, (cost + 1, nx, ny, new_path))\n            \n            return float('inf'), set()\n        \n        total_cost = 0\n        current_pos = (0, 0)\n        lights_on = set()\n        \n        for task in tasks:\n            path_cost, path = find_path(current_pos, task)\n            \n            if path_cost == float('inf'):\n                return -1\n            \n            total_cost += path_cost\n            \n            for room in path:\n                if room not in lights_on:\n                    total_cost += lightSwitchCost\n                    lights_on.add(room)\n            \n            total_cost += path_cost * lightOnCost\n            current_pos = task\n        \n        total_cost += len(lights_on) * lightSwitchCost\n        \n        return total_cost",
    "timestamp": "2025-08-13 06:09:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    R, C = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(R)]\n    N = int(sys.stdin.readline())\n    tasks = [tuple(map(int, sys.stdin.readline().split())) for _ in range(N)]\n    tasks = [(x-1, y-1) for x, y in tasks]  # converting to 0-based\n\n    # Preprocess parent and depth for each room\n    parent = [[(-1, -1) for _ in range(C)] for _ in range(R)]\n    depth = [[-1 for _ in range(C)] for _ in range(R)]\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Find the first room (assuming tasks[0] is a valid starting point)\n    start_x, start_y = tasks[0]\n    q = deque()\n    q.append((start_x, start_y))\n    parent[start_x][start_y] = (start_x, start_y)\n    depth[start_x][start_y] = 0\n    \n    while q:\n        x, y = q.popleft()\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == '.' and parent[nx][ny] == (-1, -1):\n                parent[nx][ny] = (x, y)\n                depth[nx][ny] = depth[x][y] + 1\n                q.append((nx, ny))\n    \n    # Function to get path from u to v\n    def get_path(u, v):\n        ux, uy = u\n        vx, vy = v\n        path_u = []\n        path_v = []\n        while (ux, uy) != (vx, vy):\n            if depth[ux][uy] >= depth[vx][vy]:\n                path_u.append((ux, uy))\n                ux, uy = parent[ux][uy]\n            else:\n                path_v.append((vx, vy))\n                vx, vy = parent[vx][vy]\n        path_u.append((ux, uy))\n        path_v.reverse()\n        return path_u + path_v\n    \n    current_pos = tasks[0]\n    total_cost = 0\n    lights_on = set()\n    lights_on.add(current_pos)\n    \n    for i in range(1, N):\n        next_pos = tasks[i]\n        path = get_path(current_pos, next_pos)\n        # Entering rooms: turn on lights if not already on\n        for room in path[1:]:\n            if room not in lights_on:\n                lights_on.add(room)\n                total_cost += 1  # cost to turn on\n        # Leaving rooms: turn off lights if not needed anymore\n        for room in path[:-1]:\n            # Check if room is not in any future path\n            needed_in_future = False\n            for j in range(i+1, N):\n                if room in get_path(tasks[j-1], tasks[j]):\n                    needed_in_future = True\n                    break\n            if not needed_in_future and room in lights_on:\n                lights_on.remove(room)\n                total_cost += 1  # cost to turn off\n        current_pos = next_pos\n    \n    # Turn off all remaining lights\n    for room in list(lights_on):\n        total_cost += 1\n    print(total_cost)\n\nsolve()",
    "timestamp": "2025-08-13 06:09:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <climits>\n\nusing namespace std;\n\nstruct Edge {\n    int target, length;\n};\n\nvoid add_edge(vector<vector<Edge>>& graph, int u, int v, int length) {\n    graph[u].push_back({v, length});\n    graph[v].push_back({u, length});\n}\n\nint shortest_path(vector<vector<Edge>>& graph, int start, int end) {\n    vector<int> dist(graph.size(), INT_MAX);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    pq.push({0, start});\n    dist[start] = 0;\n\n    while (!pq.empty()) {\n        int curDist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (curDist > dist[u]) continue;\n\n        for (auto& edge : graph[u]) {\n            int v = edge.target;\n            int length = edge.length;\n\n            if (dist[u] + length < dist[v]) {\n                dist[v] = dist[u] + length;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist[end];\n}\n\nint main() {\n    int R, C, taskCount, switchOnCost, switchOffCost, electricityCost;\n    cin >> R >> C >> taskCount >> switchOnCost >> switchOffCost >> electricityCost;\n\n    vector<vector<char>> grid(R, vector<char>(C));\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n\n    vector<int> tasks(taskCount);\n    for (int i = 0; i < taskCount; ++i) {\n        int r, c;\n        cin >> r >> c;\n        tasks[i] = r * C + c;\n    }\n\n    vector<vector<Edge>> graph(R * C);\n    vector<vector<int>> directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n    \n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            if (grid[i][j] == '#') continue;\n            for (auto& dir : directions) {\n                int ni = i + dir[0], nj = j + dir[1];\n                if (ni >= 0 && ni < R && nj >= 0 && nj < C && grid[ni][nj] != '#') {\n                    add_edge(graph, i * C + j, ni * C + nj, 1);\n                }\n            }\n        }\n    }\n\n    int totalCost = 0;\n    int prevRoom = tasks[0];\n    totalCost += switchOnCost; \n\n    for (int i = 1; i < taskCount; ++i) {\n        int currentRoom = tasks[i];\n        int moveCost = shortest_path(graph, prevRoom, currentRoom);\n        totalCost += moveCost * electricityCost + switchOffCost + switchOnCost;\n        prevRoom = currentRoom;\n    }\n\n    totalCost += switchOffCost;\n\n    cout << totalCost << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:30:16"
  }
]