[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n  int x;\n  int y;\n  int time;\n  vector<int>xs;\n  vector<int>ys;\n};\nclass Compare {\npublic:\n  //aaが昇順に並ぶ\n  bool operator()(const aa&l, const aa&r) {\n    return l.time> r.time;\n  }\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\naa getway(const int fx,const int fy,const int tx,const int ty, const vector<vector<int>>&cans){\n  priority_queue<aa, vector<aa>, Compare>que;\n  que.push(aa{ fx,fy,0,{},{} });\n  int memo[100][100];\n  for (int i = 0; i < 100; ++i) {\n    for (int j = 0; j < 100; ++j) {\n      memo[i][j] = 99999999;\n    }\n  }\n  memo[fy][fx] = 0;\n  while (!que.empty()) {\n    aa atop(que.top());\n    que.pop();\n    if (atop.x == tx&&atop.y == ty)return atop;\n    else {\n      atop.xs.push_back(atop.x);\n      atop.ys.push_back(atop.y);\n    }\n    vector<int> axs(atop.xs);\n    vector<int> ays(atop.ys);\n    for (int i = 0; i < 4; ++i) {\n      int newx = atop.x + dx[i];\n      int newy = atop.y + dy[i];\n      if (cans[newy][newx]) {\n        if (memo[newy][newx]>atop.time + 1) {\n          memo[newy][newx] = atop.time + 1;\n          que.push(aa{ newx,newy,atop.time + 1,atop.xs,atop.ys });\n        }\n      }\n    }\n  }\n  assert(false);\n}\n\nint main() {\n  \n  /*int N; cin >> N;\n  vector<int>as;\n  vector<int>num(10001);\n  for (int i = 0; i < N; ++i) {\n    int a; scanf(\"%d\", &a);\n    num[a]++;\n  }\n  vector<long long int>nums;\n  for (int i = 0; i < 10001; ++i) {\n    if (num[i] > 1) {\n      string st(to_string(i)+to_string(i));\n      nums.push_back(stoll(st));\n      if (num[i] >= 3) {\n        nums.push_back(stoi(st));\n        nums.push_back(stoi(st));\n      }\n    }\n    else if (num[i]) {\n      for (int j = 0; j < 10001; ++j) {\n        if (i == j)continue;\n        if (num[j]) {\n          int atime = min(3,num[i] * num[j]);\n          string st(to_string(i) + to_string(j));\n          for (int i = 0; i < atime; ++i) {\n\n            nums.push_back(stoll(st));\n          }\n        }\n      }\n    }\n  }\n  for (int i = 0; i < 2; ++i) {\n\n    auto it = min_element(nums.begin(), nums.end());\n    nums.erase(it);\n  }\n  auto it = min_element(nums.begin(), nums.end());\n  cout << *it << endl;\n  return 0;*/\n  \n  int W, H, M; cin >>H>>W >> M;\n  vector<vector<int>>pers(H+2, vector<int>(W+2));\n  vector<vector<int>>ons(H + 2, vector<int>(W + 2));\n  vector<vector<int>>offs(H + 2, vector<int>(W + 2));\n  vector<vector<int>>cans(H + 2, vector<int>(W + 2));\n  for (int i = 1; i <= H; ++i) {\n    string st; cin >> st;\n    for (int j = 1; j <= W; ++j) {\n      if (st[j - 1] == '.') {\n        cans[i][j] = true;\n      }\n    }\n  }\n  for (int i = 1; i <= H; ++i) {\n    for (int j = 1; j <= W; ++j) {\n      int per; cin >> per;\n      pers[i][j] = per;\n    }\n  }\n  for (int i = 1; i <= H; ++i) {\n    for (int j = 1; j <= W; ++j) {\n      int per; cin >> per;\n      ons[i][j] = per;\n    }\n  }\n  for (int i = 1; i <= H; ++i) {\n    for (int j = 1; j <= W; ++j) {\n      int per; cin >> per;\n      offs[i][j] = per;\n    }\n  }\n  int fx, fy; cin >> fy >> fx;\n  fx++; fy++;\n  vector<int>xmoves;\n  vector<int>ymoves;\n  for (int i = 0; i < M-1; ++i) {\n    int tx, ty; cin >> ty >> tx; tx++; ty++;\n    aa ways= getway(fx, fy, tx, ty,cans);\n    xmoves.insert(xmoves.end(), ways.xs.begin(), ways.xs.end());\n    ymoves.insert(ymoves.end(), ways.ys.begin(), ways.ys.end());\n    fx = tx; fy = ty;\n    if (i == M - 2) {\n      xmoves.push_back(tx);\n      ymoves.push_back(ty);\n    }\n  }\n  vector<vector<vector<int>>>times(H + 2, vector<vector<int>>((W + 2), vector<int>()));\n  for (int i = 0; i < xmoves.size(); ++i) {\n    times[ymoves[i]][xmoves[i]].push_back(i);\n  }\n  long long int ans = 0;\n  for (int i =1; i < H + 1; ++i) {\n    for (int j = 1; j < W + 1; ++j) {\n      long long int cost = 0;\n      vector<int>ntimes(times[i][j]);\n      if (!ntimes.empty()) {\n        cost += ons[i][j]+offs[i][j];\n        for (int k = 0; k < ntimes.size() - 1; ++k) {\n          int byetime = ntimes[k + 1] - ntimes[k];\n          cost += min(byetime*pers[i][j], ons[i][j] + offs[i][j]);\n        }\n      }\n      \n      ans += cost;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\n\nvp trail;\n\nint r,c,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nbool dfs(int cx,int cy,int tx,int ty,vp &t,vs &field,vvi &visited){\n\tvisited[cx][cy]=1;\n\tif(cx==tx&&cy==ty){\n\t\tREP(i,t.size()){\n\t\t\ttrail.push_back(t[i]);\n\t\t}\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint x=cx+dx[i],y=cy+dy[i];\n\t\tif(x<0||y<0||x>=c||y>=r||field[y][x]=='#'||visited[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tvp nt(t);\n\t\tnt.push_back(make_pair(y,x));\n\t\tif(dfs(x,y,tx,ty,nt,field,visited))return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>r>>c>>m;\n\tvs field(r);\n\tREP(i,r){\n\t\tcin>>field[i];\n\t}\n\tvvi con(r,vi(c));\n\tvvi on(r,vi(c));\n\tvvi off(r,vi(c));\n\n\tREP(i,r)REP(j,c){\n\t\tcin>>con[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>on[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>off[i][j];\n\t}\n\n\tvp tasks(m);\n\tREP(i,m){\n\t\tcin>>tasks[i].first>>tasks[i].second;\n\t}\n\n\tFOR(i,1,m){\n\t\tvvi visited(r,vi(c));\n\t\tvp t;\n\t\tif(i==1){\n\t\t\tt.push_back(tasks[i-1]);\n\t\t}\n\t\tint x=tasks[i-1].second,y=tasks[i-1].first;\n\t\tint tx=tasks[i-1].second,ty=tasks[i-1].first;\n\t\tdfs(tasks[i-1].second,tasks[i-1].first,tasks[i].second,tasks[i].first,t,field,visited);\n\t}\n\n\tvvi last(r,vi(c,-1));\n\tint cost=0;\n\tREP(i,trail.size()){\n\t\tint y=trail[i].first,x=trail[i].second;\n\t\tif(last[y][x]==-1){\n\t\t\tcost+=on[y][x];\n\t\t}else if((i-last[y][x])*con[y][x]<on[y][x]+off[y][x]){\n\t\t\tcost+=(i-last[y][x])*con[y][x];\n\t\t}else{\n\t\t\tcost+=on[y][x]+off[y][x];\n\t\t}\n\t\tlast[y][x]=i;\n\t}\n\tint lt=trail.size();\n\tREP(y,r)REP(x,c){\n\t\tif(last[y][x]!=-1){\n\t\t\tcost+=off[y][x];\n\t\t}\n\t}\n\tcout<<cost<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n\ntemplate<typename T,typename S>\nostream& operator<<(ostream& os,const pair<T,S>& val){\n    os << \"(\" << val.first << \",\" << val.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& val){\n    os << \"[ \";\n    for(typename vector<T>::const_iterator it=val.begin();\n        it != val.end();++it){\n        os << *it << \" \";\n    }\n    os << \"]\";\n    return os;\n}\n\n#define mp(a,b) make_pair(a,b)\n\ntypedef pair<char,char> pii;\ntypedef vector<pii> vp1;\ntypedef vector<vp1> vp2;\ntypedef vector<vp2> vp3;\ntypedef vector<vp3> vp4;\ntypedef vector<vp4> vp5;\ntypedef vector<char> vc;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nint main(){\n    int R,C,M;\n    cin >> R >> C >> M;\n    vp5 route(R,vp4(C,vp3(R,vp2(C))));\n\n    vector<vc> is_room(R,vc(C));\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            char t;cin >> t;\n            is_room[r][c] = (t == '.');\n        }\n    }\n\n    for(int s_r=0;s_r<R;s_r++){\n        for(int s_c=0;s_c<C;s_c++){\n            stack<pair<pii,vp1> > S;\n            vector<vc> already(R,vc(C));\n            S.push(mp(mp(s_r,s_c),vp1(1,mp(s_r,s_c))));\n            while(not S.empty()){\n                pair<pii,vp1> p = S.top();\n                int r = p.first.first;\n                int c = p.first.second;\n                S.pop();\n                if(already[r][c]) continue;\n                already[r][c] = true;\n                route[s_r][s_c][r][c] = p.second;\n\n                for(int i=0;i<4;i++){\n                    int nr = r + dy[i],nc = c + dx[i];\n                    if(0 <= nr and nr < R and 0 <= nc and nc < C and\n                       is_room[nr][nc]){\n                        vector<pii> rou = p.second;\n                        rou.push_back(mp(nr,nc));\n                        S.push(mp(mp(nr,nc),rou));\n                    }\n                }\n            }\n        }\n    }\n\n    vector<vector<int> > consume(R,vector<int>(C));\n    vector<vector<int> > turn_on(R,vector<int>(C));\n    vector<vector<int> > turn_off(R,vector<int>(C));\n\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> consume[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_on[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_off[r][c];\n        }\n    }\n    // cerr << turn_on << endl;\n\n    vector<vector<int> > last_visit(R,vector<int>(C,-1));\n    int lr=-1,lc=-1;\n    int cur_time = 0;\n    int ret = 0;\n    for(int t_case=0;t_case<M;t_case++){\n        int gr,gc;\n        cin >> gr >> gc;\n        if(t_case == 0){\n            lr = gr;lc = gc;\n        }\n        vp1 rou = route[lr][lc][gr][gc];\n        for(size_t i=0;i<rou.size();i++){\n            if(i != 0) cur_time++;\n            int c_r = rou[i].first,c_c = rou[i].second;\n\n            if(last_visit[c_r][c_c] != -1){\n                ret += min(consume[c_r][c_c] * (cur_time - last_visit[c_r][c_c]),\n                           turn_off[c_r][c_c] + turn_on[c_r][c_c]);\n            }else{\n                ret += turn_on[c_r][c_c];\n            }\n            last_visit[c_r][c_c] = cur_time;\n            // cerr << c_r << \" \" << c_c << \" \" << cur_time << \" \" << ret << endl;\n        }\n        lr = gr,lc = gc;\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            if(last_visit[r][c] != -1) {\n                ret += turn_off[r][c];\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define maxn 60\n#define N 1010\nchar map[maxn][maxn];\nlong long nt,ti;\nbool use[maxn][maxn];\nint n,m,q;\nstruct task\n{\n    int r,c;\n}s[N];\nstruct visit\n{\n    int cnt;\n    long long int ti[N];\n}vis[maxn][maxn];\nstruct mat\n{\n    long long int keep;\n    long long int on;\n    long long int off;\n}cost[maxn][maxn];\nint dr[4]={-1,1,0,0};\nint dc[4]={0,0,-1,1};\nlong long min(long long a,long long b)\n{\n    return a>b?b:a;\n}\nvoid readin()\n{\n    for (int i=1;i<=n;i++)\n        scanf(\"%s\",map[i]+1);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%I64d\",&cost[i][j].keep);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%I64d\",&cost[i][j].on);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%I64d\",&cost[i][j].off);\n    for (int i=1;i<=q;i++)\n        scanf(\"%d %d\",&s[i].r,&s[i].c),s[i].r++,s[i].c++;\n}\nbool ok(int r,int c)\n{\n    if (r<1||r>n||c<1||c>m)return false;\n    if (map[r][c]=='#')return false;\n    return use[r][c];\n}\nbool dfs(int r,int c, task end,long long  tim)\n{\n    if (r==end.r&&c==end.c)\n    {\n        nt=tim;\n        return true;\n    }\n    use[r][c]=0;\n    vis[r][c].ti[++vis[r][c].cnt]=tim;\n    for (int i=0;i<=4;i++)\n    {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (ok(nr,nc))\n        {\n            if (dfs(r+dr[i],c+dc[i],end,tim+1))return true;\n        }\n    }\n    use[r][c]=1;\n    vis[r][c].cnt--;\n    return false;\n}\nvoid work()\n{\n    nt=0ll;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            vis[i][j].cnt=0;\n    for (int i=1;i<q;i++)\n    {\n        memset(use,1,sizeof use);\n        dfs(s[i].r,s[i].c,s[i+1],nt);\n    }\n    vis[s[q].r][s[q].c].ti[++vis[s[q].r][s[q].c].cnt]=nt;\n    long long ans=0;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=1;j<=m;j++)\n        {\n            long long sum=0;\n            //printf(\"cnt=%d : \",vis[i][j].cnt);\n            for (int k=1;k<vis[i][j].cnt;k++)\n            {\n                sum+=min(cost[i][j].on+cost[i][j].off,cost[i][j].keep*(vis[i][j].ti[k+1]-vis[i][j].ti[k]));\n                //printf(\"%I64d \",vis[i][j].ti[k]);\n                //printf(\"\\n\");\n            }\n            if (vis[i][j].cnt)sum+=cost[i][j].off+cost[i][j].on;\n            ans+=sum;\n        }\n    }\n    printf(\"%I64d\\n\",ans);\n}\nint main()\n{\n    while (scanf(\"%d %d %d\",&n,&m,&q)!=EOF)\n    {\n        readin();\n        work();\n    }\n    return 0;\n}\n/*\n3 3 5\n***\n*##\n**#\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 0\n2 1\n0 2\n2 0\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    //cout << a << \" \";\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    //o\n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        int a = M[make_pair(x[i - 1], y[i - 1])];\n        int b = M[make_pair(x[i], y[i])];\n        vector<bool> used(num, false);\n        bool end = false;\n        used[a] = true;\n        dfs(end, a, b, adjlist, node[i], used);\n    }\n\n\n    //x\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 50;\n\nint h, w, m, co[3][N][N], r, c, pr, pc, t;\nchar da[N][N];\nvector<int> ti[N][N];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nbool vis[N][N];\n\nint move(int y, int x, int cnt){\n  if(y == r && x == c) return cnt;\n  vis[y][x] = true;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n    if(da[ny][nx] == '#') continue;\n    if(vis[ny][nx]) continue;\n    int res = move(ny, nx, cnt+1);\n    if(res >= 0){\n      ti[y][x].push_back(t + cnt);\n      return res;\n    }\n  }\n  return -1;\n}\n\nmain(){\n  cin >> h >> w >> m;\n  for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> da[i][j];\n  for(int k=0;k<3;k++) for(int i=0;i<h;i++) for(int j=0;j<w;j++) cin >> co[k][i][j];\n  pr = -1;\n  t = 0;\n  for(int i=0;i<m;i++){\n    cin >> r >> c;\n    fill(vis[0], vis[N], false);\n    if(pr != -1) t += move(pr, pc, 0);\n    pr = r;\n    pc = c;\n    if(i + 1 == m) ti[r][c].push_back(t);\n  }\n  int ans = 0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      for(int k=0;k<ti[i][j].size();k++){\n        if(k > 0 && co[1][i][j] + co[2][i][j] > co[0][i][j] * (ti[i][j][k] - ti[i][j][k-1]))\n          ans += co[0][i][j] * (ti[i][j][k] - ti[i][j][k-1]);\n        else ans += co[1][i][j] + co[2][i][j];\n      }\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n\ntemplate<typename T,typename S>\nostream& operator<<(ostream& os,const pair<T,S>& val){\n    os << \"(\" << val.first << \",\" << val.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& val){\n    os << \"[ \";\n    for(typename vector<T>::const_iterator it=val.begin();\n        it != val.end();++it){\n        os << *it << \" \";\n    }\n    os << \"]\";\n    return os;\n}\n\n#define mp(a,b) make_pair(a,b)\n\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp1;\ntypedef vector<vp1> vp2;\ntypedef vector<vp2> vp3;\ntypedef vector<vp3> vp4;\ntypedef vector<vp4> vp5;\ntypedef vector<char> vc;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nint main(){\n    int R,C,M;\n    cin >> R >> C >> M;\n    vp5 route(R,vp4(C,vp3(R,vp2(C))));\n\n    vector<vc> is_room(R,vc(C));\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            char t;cin >> t;\n            is_room[r][c] = (t == '.');\n        }\n    }\n\n    for(int s_r=0;s_r<R;s_r++){\n        for(int s_c=0;s_c<C;s_c++){\n            stack<pair<pii,vp1> > S;\n            vector<vc> already(R,vc(C));\n            S.push(mp(mp(s_r,s_c),vp1(1,mp(s_r,s_c))));\n            while(not S.empty()){\n                pair<pii,vp1> p = S.top();\n                int r = p.first.first;\n                int c = p.first.second;\n                S.pop();\n                if(already[r][c]) continue;\n                already[r][c] = true;\n                route[s_r][s_c][r][c] = p.second;\n\n                for(int i=0;i<4;i++){\n                    int nr = r + dy[i],nc = c + dx[i];\n                    if(0 <= nr and nr < R and 0 <= nc and nc < C and\n                       is_room[nr][nc]){\n                        vector<pii> rou = p.second;\n                        rou.push_back(mp(nr,nc));\n                        S.push(mp(mp(nr,nc),rou));\n                    }\n                }\n            }\n        }\n    }\n\n    vector<vector<int> > consume(R,vector<int>(C));\n    vector<vector<int> > turn_on(R,vector<int>(C));\n    vector<vector<int> > turn_off(R,vector<int>(C));\n\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> consume[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_on[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_off[r][c];\n        }\n    }\n    // cerr << turn_on << endl;\n\n    vector<vector<int> > last_visit(R,vector<int>(C,-1));\n    int lr=-1,lc=-1;\n    int cur_time = 0;\n    int ret = 0;\n    for(int t_case=0;t_case<M;t_case++){\n        int gr,gc;\n        cin >> gr >> gc;\n        if(t_case == 0){\n            lr = gr;lc = gc;\n        }\n        vp1 rou = route[lr][lc][gr][gc];\n        for(size_t i=0;i<rou.size();i++){\n            if(i != 0) cur_time++;\n            int c_r = rou[i].first,c_c = rou[i].second;\n\n            if(last_visit[c_r][c_c] != -1){\n                ret += min(consume[c_r][c_c] * (cur_time - last_visit[c_r][c_c]),\n                           turn_off[c_r][c_c] + turn_on[c_r][c_c]);\n            }else{\n                ret += turn_on[c_r][c_c];\n            }\n            last_visit[c_r][c_c] = cur_time;\n            // cerr << c_r << \" \" << c_c << \" \" << cur_time << \" \" << ret << endl;\n        }\n        lr = gr,lc = gc;\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            if(last_visit[r][c] != -1) {\n                ret += turn_off[r][c];\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"stdio.h\"\n#include\"string.h\"\n#include\"algorithm\"\n#include\"queue\"\n#include\"map\"\nusing namespace std;\nint dp[3500][12],dep[3500];\nint next[12345],u[12345],first[12345],e;\nint on[12345],off[12345],stay[12345],last[12345];\nint n,m,k;struct pi{\n\tint x,y;\n}q[1234],r[1234];\nvoid dfs(int x,int fa)\n{\n\t\n\tdep[x]=dep[dp[x][0]]+1;\n    //printf(\"hua %d %d %d\\n\",r[x].x,r[x].y,dep[x]);\n\tfor(int i=1;i<12;i++)\n\tdp[x][i]=dp[dp[x][i-1]][i-1];\n\tfor(int i=first[x];~i;i=next[i])\n\tif(u[i]!=fa)\n\t{\n\t//\tprintf(\"ha %d %d\\n\",x,u[i]);\n\t\tdp[u[i]][0]=x;\n\t\tdfs(u[i],x);\n\t}\n}\nvoid add(int x,int y)\n{\n\tu[e]=y;next[e]=first[x];first[x]=e++;\n\t//u[e]=x;next[e]=first[y];first[y]=e++;\n}\nint getlca(int u,int v)\n{\n    if(dep[u]<dep[v])swap(u,v);\n    //printf(\"aa%d %d\\n\",u,v);\n    for(int i=11,st=1<<11;i>=0;i--,st>>=1)\n    if(dep[u]-dep[v]>=st)u=dp[u][i];\n    if(u==v)return u;\n    for(int i=11;i>=0;i--)\n    if(dp[u][i]!=dp[v][i])\n    {\n       u=dp[u][i];\n       v=dp[v][i];\n      // printf(\"aa%d %d\\n\",u,v);\n    }\n    \n    return dp[u][0];\n}\nint ans,tt;\nvoid go(int x,int ta)\n{\n\t++tt;\n\tif(last[x]==-1)\n\tans+=on[x]+off[x];   \n\telse ans+=min(on[x]+off[x],stay[x]*(tt-last[x]));\t\n//\tprintf(\"%d\\n\",x);\t\n//\tprintf(\"%d %d %d %d %d %d\\n\",r[x].x,r[x].y,last[x],tt,min(on[x]+off[x],stay[x]*(tt-last[x])),on[x]+off[x]);\n\tlast[x]=tt;\n\tif(x==ta)return;\n\tfor(int i=first[x];~i;i=next[i])\n\tif(dep[u[i]]<dep[x])\n\t{\n\t     go(u[i],ta);\n\t\t break;\t\n\t}\n}\n\nvoid go2(int x,int ta)\n{\n//\tif(last[x]==tt)goto st;\n\t\n//\tst:;\n\t\n\tfor(int i=first[x];~i;i=next[i])\n\tif(dep[u[i]]<dep[x])\n\t{\n\t\t if(x!=ta)\n\t     go2(u[i],ta);\n\t\t break;\t\n\t}\n\t++tt;\n\tif(last[x]==-1)\n\tans+=on[x]+off[x];\n\telse ans+=min(on[x]+off[x],stay[x]*(tt-last[x]));\t\n//\tprintf(\"%d\\n\",x);\n//\tprintf(\"%d %d %d %d %d %d\\n\",r[x].x,r[x].y,last[x],tt,min(on[x]+off[x],stay[x]*(tt-last[x])),on[x]+off[x]);\n\tlast[x]=tt;\n}\nchar mp[60][60];\n\nint vis[55][55];\nint main()\n{\n    while(~scanf(\"%d %d %d\",&n,&m,&k))\n    {\n    \ttt=ans=e=0;\n    \tmemset(first,-1,sizeof(first));\n    \tmemset(last,-1,sizeof(last));\n    \tmemset(dp,0,sizeof(dp));\n    \tmemset(dep,0,sizeof(dep));\n    \tfor(int i=0;i<n;i++)\n    \t{\n\t    \tscanf(\"%s\",mp[i]);\n\t    }\n\t    int w=0;\n\t    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        \n\t      {\n\t      \t vis[i][j]=++w;\n\t      \t r[w].x=i;\n\t      \t r[w].y=j;\n\t      \t if(mp[i][j]!='.')continue;\n      \t     if(i>0&&mp[i-1][j]=='.')\n      \t     {add(w,vis[i-1][j]); add(vis[i-1][j],w);}\n      \t     if(j>0&&mp[i][j-1]=='.')\n      \t     {add(w,vis[i][j-1]);add(vis[i][j-1],w);}\n\t\t\t   \t\t\t   \t\n      \t  }\n      \t  printf(\"%d\\n\",w); \n        for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        scanf(\"%d\",&stay[vis[i][j]]);\n\t    for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        scanf(\"%d\",&on[vis[i][j]]);\n        for(int i=0;i<n;i++)\n        for(int j=0;j<m;j++)\n        scanf(\"%d\",&off[vis[i][j]]);\n       \n        for(int i=0;i<k;i++)\n        {\n        \tscanf(\"%d %d\",&q[i].x,&q[i].y);\n        \tif(i==0)\n        \t{\n\t        \tdfs(vis[q[i].x][q[i].y],-1);\n\t        //\tputs(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n\t        }\n\t        else \n\t        {\n\t        \tint t1=vis[q[i-1].x][q[i-1].y];\n\t        \tint t2=vis[q[i].x][q[i].y];\n\t        \t//printf(\"ab%d %d\\n\",t1,t2);\n        \t\tint rp=getlca(t1,t2);\n        \t\t//printf(\"cd%d\\n\\n\",rp);\n        \t\tif(i>1)\n        \t\ttt--;\n        \t\tif(t1!=rp)\n        \t\t{\n\t\t        \tgo(t1,rp);\n\t\t\t\t\tif(t2!=rp)\n\t\t\t\t\ttt--;\t\n\t\t        }\n\t\t        if(t2!=rp)\n\t\t        {\n        \t\t\tgo2(t2,rp);\n        \t\t}\n        \t//\tputs(\"\");\n        \t}\n        }\n        printf(\"%d\\n\",ans);\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// #define double long double\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-6;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nbool inside(int x, int y, int H, int W) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int H, W, m;\n    cin >> H >> W >> m;\n    vector<string> s(H);\n    rep(i, H) cin >> s[i];\n    vvi power(H, vi(W));\n    rep(i, H) rep(j, W) cin >> power[i][j];\n    vvi on(H, vi(W));\n    rep(i, H) rep(j, W) cin >> on[i][j];\n    vvi off(H, vi(W));\n    rep(i, H) rep(j, W) cin >> off[i][j];\n    vector<Pii> task(m);\n    rep(i, m) cin >> task[i].first >> task[i].second;\n\n    vvvi time(H, vvi(W));\n    time[task[0].first][task[0].second].emplace_back(0);\n    std::function<bool(int,int,int,int,int,int)> dfs = [&](int x, int y, int px, int py, int i, int t) {\n        if (x == task[i].first && y == task[i].second) {\n            i++;\n            px = -1, py = -1;\n        }\n\n        if (i == m) {\n            return true;\n        }\n\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (!inside(nx, ny, H, W)) continue;\n            if (s[nx][ny] == '#') continue;\n            if (nx == px && ny == py) continue;\n            time[nx][ny].emplace_back(t);\n            if (dfs(nx, ny, x, y, i, t + 1)) {\n                return true;\n            }\n            time[nx][ny].pop_back();\n        }\n\n        return false;\n    };\n    dfs(task[0].first, task[0].second, -1, -1, 0, 1);\n\n    // rep(i, H) {\n    //     rep(j, W) {\n    //         cout << i << \" \" << j << \": \";\n    //         printV(time[i][j]);\n    //     }\n    // }\n\n    int ans = 0;\n    rep(i, H) {\n        rep(j, W) {\n            if (time[i][j].empty()) {\n                continue;\n            }\n            ans += on[i][j];\n            rep(k, (int)time[i][j].size() - 1) {\n                ans += min(power[i][j] * (time[i][j][k + 1] - time[i][j][k]), off[i][j] + on[i][j]);\n            }\n            ans += off[i][j];\n        }\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nint  dx[4]={1,0,-1,0};\nint  dy[4]={0,1,0,-1};\n\nclass Main{\npublic:\n\tvector<vector<bool>> passed;\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tREP(i,M){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tll res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//mid\n\t\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t\t}\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            adjlist[M[make_pair(i, j)]].push_back(M[make_pair(ni, nj)]);\n                            //adjlist[M[make_pair(ni, nj)]].push_back(M[make_pair(i, j)]);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n    \n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 60;\n\nll R, C, M;\nchar S[50][50];\nll unit[50][50], on[50][50], off[50][50], Y[1000], X[1000];\n\nbool dfs(ll y, ll x, ll gy, ll gx, vector<ll> &ty, vector<ll> &tx, vector< vector<bool> > &used) {\n  if(used[y][x]) return false;\n  used[y][x] = true;\n\n  ty.push_back(y);\n  tx.push_back(x);\n\n  if(y == gy && x == gx) return true;\n\n  ll dd[5] = { 0, -1, 0, 1, 0 };\n  REP(i, 0, 4) {\n    ll ny = y + dd[i], nx = x + dd[i + 1];\n    if(0 <= ny && ny < R && 0 <= nx && nx < C && S[ny][nx] == '.') {\n      if(dfs(ny, nx, gy, gx, ty, tx, used)) return true;\n    }\n  }\n\n  ty.resize(ty.size() - 1);\n  tx.resize(tx.size() - 1);\n\n  return false;\n}\n\nint main(void) {\n  cin >> R >> C >> M;\n  REP(i, 0, R) REP(j, 0, C) cin >> S[i][j];\n  REP(i, 0, R) REP(j, 0, C) cin >> unit[i][j];\n  REP(i, 0, R) REP(j, 0, C) cin >> on[i][j];\n  REP(i, 0, R) REP(j, 0, C) cin >> off[i][j];\n  REP(i, 0, M) cin >> Y[i] >> X[i];\n\n  ll y = Y[0], x = X[0];\n  ll ans = on[y][x], t = 1;\n\n  ll last[R][C];\n  REP(i, 0, R) REP(j, 0, C) last[i][j] = -INF;\n  last[y][x] = 0;\n\n  REP(i, 0, M - 1) {\n    vector<ll> ty, tx;\n    vector< vector<bool> > used(R, vector<bool>(C, false));\n    dfs(Y[i], X[i], Y[i + 1], X[i + 1], ty, tx, used);\n\n    REP(j, 1, ty.size()) {\n      y = ty[j];\n      x = tx[j];\n\n      if(last[y][x] < 0) {\n        ans += on[y][x];\n      } else {\n        ll d = t - last[y][x];\n        if(d * unit[y][x] <= off[y][x] + on[y][x]) {\n          ans += d * unit[y][x];\n        } else {\n          ans += off[y][x] + on[y][x];\n        }\n      }\n\n      last[y][x] = t++;\n    }\n  }\n\n  REP(i, 0, R) REP(j, 0, C) {\n    if(last[i][j] >= 0) ans += off[i][j];\n  }\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> ppii;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef priority_queue<pii, vp, greater<pii> > piq;\n\nconst int N = 55;\nconst int M = 1010;\nconst int K = 100010;\nconst int LIT = 2500;\nconst int INF = 1 << 28;\nconst int base = 137;\nconst double eps = 1e-10;\nconst int dir[5][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nconst int dir2[10][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}};\nconst int ABS(int a) {return a > 0 ? a : -a;}\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n\nconst pii nonvis = mp(-1, -1);\nint n, m, r;\nint use[N][N], on[N][N], off[N][N];\nint route[N * N * M][2], sav[N][N], cnt;\nchar g[N][N];\nvp v;\n\nvoid init()\n{\n    memset(g, 0, sizeof(g));\n    for(int i = 0; i < n; i++) scanf(\"%s\", &g[i]);\n    \n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n    scanf(\"%d\", &use[i][j]);\n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n    scanf(\"%d\", &on[i][j]);\n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n    scanf(\"%d\", &off[i][j]);\n    \n    v = vp(r);\n    for(int i = 0; i < r; i++) scanf(\"%d %d\", &v[i].fst, &v[i].snd);\n}\n\nvoid getroute(int p)\n{\n    pii vis[N][N];\n    for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) vis[i][j] = nonvis;\n    queue<pii> que;\n    que.push(v[p]);\n    vis[v[p].fst][v[p].snd] = mp(-2, -2);\n    \n    while(!que.empty())\n    {\n        pii pre = que.front();\n        que.pop();\n        if(pre == v[p + 1])\n        {\n            stack<pii> sta;\n            while(1)\n            {\n                sta.push(pre);\n                if(pre == v[p]) break;\n                pre = vis[pre.fst][pre.snd];\n            }\n            while(!sta.empty())\n            {\n                int x = sta.top().fst, y = sta.top().snd;\n                sta.pop();\n                route[cnt][0] = x;\n                route[cnt][1] = y;\n                cnt++;    \n            }\n            break;\n        }\n        int x = pre.fst, y = pre.snd;\n        for(int i = 0; i <= 3; i++)\n        {\n            int xx = x + dir[i][0];\n            int yy = y + dir[i][1];\n            if(xx < 0 || yy < 0 || xx >= n || yy >= m) continue;\n            if(g[xx][yy] == '#' || vis[xx][yy] != nonvis) continue;\n            que.push(mp(xx, yy));\n            vis[xx][yy] = pre;\n        }\n    }\n}\n\nvoid solve()\n{\n    cnt = 0;\n    for(int i = 1; i < r; i++) getroute(i - 1);\n    //for(int i = 0; i < cnt; i++) printf(\"%d %d\\n\", route[i][0], route[i][1]);\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    while(cin>>n>>m>>r)\n    {\n        init();\n        solve();\n    }\n    //while(1);\n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define foreach(i,v) for(int i=0;i<(int)v.size();i++)\n\nconst int N=55;\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\nchar mz[N][N];\nint con[N][N],on[N][N],off[N][N];\nint pre[N][N],dis[N][N];\nint tl[N*N];\nstruct point\n{\n    int x,y;\n    point(){}\n    point(int _x,int _y)\n    :x(_x),y(_y){}\n};\npoint task[1010];\nvector<int> load;\nqueue<point> q;\nint n,m;\nvoid bfs(int sx,int sy,int ex,int ey)\n{\n    while(!q.empty()) q.pop();\n    memset(pre,-1,sizeof(pre));\n    memset(dis,-1,sizeof(dis));\n    dis[sx][sy]=0;\n    q.push(point(sx,sy));\n    while(!q.empty())\n    {\n        point u=q.front(); q.pop();\n        int x=u.x, y=u.y;\n        if(x==ex && y==ey) break;\n        for(int d=0;d<4;d++)\n        {\n            int nx=x+dx[d], ny=y+dy[d];\n            if(nx<0 || nx>=n || ny<0 || ny>=m) continue;\n            if(dis[nx][ny]!=-1 || mz[nx][ny]=='#') continue;\n            dis[nx][ny]=dis[x][y]+1;\n            pre[nx][ny]=x*m+y;\n            q.push(point(nx,ny));\n        }\n    }\n    int ntl=0;\n    for(int x=ex,y=ey;pre[x][y]!=-1;)\n    {\n        int t=pre[x][y];\n        tl[ntl++]=t;\n        x=t/m; y=t%m;\n    }\n    for(int i=ntl-1;i>=0;i--) load.push_back(tl[i]);\n}\nint main()\n{\n//freopen(\"in.txt\",\"r\",stdin);\n    int q;\n    while(~scanf(\"%d%d%d\",&n,&m,&q))\n    {\n        for(int i=0;i<n;i++) scanf(\"%s\",mz[i]);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) scanf(\"%d\",&con[i][j]);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) scanf(\"%d\",&on[i][j]);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) scanf(\"%d\",&off[i][j]);\n        for(int i=0;i<q;i++) scanf(\"%d%d\",&task[i].x,&task[i].y);\n        load.clear();\n        for(int i=1;i<q;i++) bfs(task[i-1].x,task[i-1].y,task[i].x,task[i].y);\n        load.push_back(task[q-1].x*m+task[q-1].y);\n        memset(pre,-1,sizeof(pre));\n        int ans=0;\n        foreach(i,load)\n        {\n            int l=load[i];\n            int x=l/m, y=l%m;\n            if(pre[x][y]==-1)\n            {\n                ans+=on[x][y];\n                ans+=off[x][y];\n            }\n            else\n            {\n                int tmp=(i-pre[x][y])*con[x][y];\n                tmp=min(on[x][y]+off[x][y],tmp);\n                ans+=tmp;\n            }\n            pre[x][y]=i;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n\ntemplate<typename T,typename S>\nostream& operator<<(ostream& os,const pair<T,S>& val){\n    os << \"(\" << val.first << \",\" << val.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& val){\n    os << \"[ \";\n    for(typename vector<T>::const_iterator it=val.begin();\n        it != val.end();++it){\n        os << *it << \" \";\n    }\n    os << \"]\";\n    return os;\n}\n\n#define mp(a,b) make_pair(a,b)\n\ntypedef pair<char,char> pii;\ntypedef vector<pii> vp1;\ntypedef vector<vp1> vp2;\ntypedef vector<vp2> vp3;\ntypedef vector<vp3> vp4;\ntypedef vector<vp4> vp5;\ntypedef vector<char> vc;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nint main(){\n    int R,C,M;\n    cin >> R >> C >> M;\n    vp5 route(R,vp4(C,vp3(R,vp2(C))));\n\n    vector<vc> is_room(R,vc(C));\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            char t;cin >> t;\n            is_room[r][c] = (t == '.');\n        }\n    }\n\n    for(int s_r=0;s_r<R;s_r++){\n        for(int s_c=0;s_c<C;s_c++){\n            vp3 m_route(R,vp2(C));\n            m_route[s_r][s_c] = vp1(1,mp(s_r,s_c));\n            stack<pii> S;\n            S.push(mp(s_r,s_c));\n            while(not S.empty()){\n                pii p = S.top();\n                int r = p.first,c = p.second;\n                S.pop();\n                for(int i=0;i<4;i++){\n                    int nr = r + dy[i],nc = c + dx[i];\n                    if(0 <= nr and nr < R and 0 <= nc and nc < C and\n                       is_room[nr][nc] and m_route[nr][nc].size() == 0){\n                        m_route[nr][nc] = m_route[r][c];\n                        m_route[nr][nc].push_back(mp(nr,nc));\n                        S.push(mp(nr,nc));\n                    }\n                }\n            }\n            // cerr << m_route << endl;\n            route[s_r][s_c] = m_route;\n            // stack<pair<pii,vp1> > S;\n            // vector<vc> already(R,vc(C));\n            // S.push(mp(mp(s_r,s_c),vp1(1,mp(s_r,s_c))));\n            // while(not S.empty()){\n            //     pair<pii,vp1> p = S.top();\n            //     int r = p.first.first;\n            //     int c = p.first.second;\n            //     S.pop();\n            //     if(already[r][c]) continue;\n            //     already[r][c] = true;\n            //     route[s_r][s_c][r][c] = p.second;\n\n            //     for(int i=0;i<4;i++){\n            //         int nr = r + dy[i],nc = c + dx[i];\n            //         if(0 <= nr and nr < R and 0 <= nc and nc < C and\n            //            is_room[nr][nc] and not already[nr][nc]){\n            //             vector<pii> rou = p.second;\n            //             rou.push_back(mp(nr,nc));\n            //             S.push(mp(mp(nr,nc),rou));\n            //         }\n            //     }\n            // }\n        }\n    }\n\n    vector<vector<int> > consume(R,vector<int>(C));\n    vector<vector<int> > turn_on(R,vector<int>(C));\n    vector<vector<int> > turn_off(R,vector<int>(C));\n\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> consume[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_on[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_off[r][c];\n        }\n    }\n\n    vector<vector<int> > last_visit(R,vector<int>(C,-1));\n    int lr=-1,lc=-1;\n    int cur_time = 0;\n    int ret = 0;\n    for(int t_case=0;t_case<M;t_case++){\n        int gr,gc;\n        cin >> gr >> gc;\n        if(t_case == 0){\n            lr = gr;lc = gc;\n        }\n        vp1 rou = route[lr][lc][gr][gc];\n        for(size_t i=0;i<rou.size();i++){\n            if(i != 0) cur_time++;\n            int c_r = rou[i].first,c_c = rou[i].second;\n\n            if(last_visit[c_r][c_c] != -1){\n                ret += min(consume[c_r][c_c] * (cur_time - last_visit[c_r][c_c]),\n                           turn_off[c_r][c_c] + turn_on[c_r][c_c]);\n            }else{\n                ret += turn_on[c_r][c_c];\n            }\n            last_visit[c_r][c_c] = cur_time;\n            // cerr << c_r << \" \" << c_c << \" \" << cur_time << \" \" << ret << endl;\n        }\n        lr = gr,lc = gc;\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            if(last_visit[r][c] != -1) {\n                ret += turn_off[r][c];\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nbool in(int y,int x,int h,int w){\n  return 0<=y&&y<h&&0<=x&&x<w;\n}\nsigned main(){\n  int h,w,m;\n  cin>>h>>w>>m;\n  string s[h];\n  for(int i=0;i<h;i++) cin>>s[i];\n  int c[3][h][w];\n  for(int k=0;k<3;k++)\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>c[k][i][j];\n  \n  int y[m],x[m];\n  for(int i=0;i<m;i++) cin>>y[i]>>x[i];\n\n  vector<int> v[h][w];\n\n  \n\n  int ax[]={1,-1,0,0};\n  int ay[]={0,0,1,-1};\n\n  int cd=0;\n  for(int k=0;k<m-1;k++){\n    int cy=y[k],cx=x[k];\n    if(y[k]==y[k+1]&&x[k]==x[k+1]) continue;\n    queue<vector<int> > q;\n    vector<int> t(1,cy*w+cx);\n    q.push(t);\n    bool used[h][w];\n    memset(used,0,sizeof(used));\n    used[cy][cx]=1;\n    while(!q.empty()){\n      vector<int> p=q.front();q.pop();\n      int ty=p[p.size()-1]/w,tx=p[p.size()-1]%w;\n      if(ty==y[k+1]&&tx==x[k+1]){\n\tt=p;\n\tbreak;\n      }\n      for(int i=0;i<4;i++){\n\tint ny=ty+ay[i],nx=tx+ax[i];\n\tif(!in(ny,nx,h,w)) continue;\n\tif(used[ny][nx]||s[ny][nx]=='#') continue;\n\tused[ny][nx]=1;\n\tint np=ny*w+nx;\n\tp.push_back(np);\n\tq.push(p);\n\tp.pop_back();\n      }\n    }\n    for(int i=0;i<(int)t.size()-1;i++)\n      v[t[i]/w][t[i]%w].push_back(cd++);\n    //for(int i=0;i<(int)t.size()-1;i++) cout<<t[i]/w<<\" \"<<t[i]%w<<endl;\n  }\n  v[y[m-1]][x[m-1]].push_back(cd);\n  int ans=0;\n  for(int i=0;i<h;i++){\n    for(int j=0;j<w;j++){\n      //v[i][j].erase(unique(v[i][j].begin(),v[i][j].end()),v[i][j].end());\n      ans+=(c[1][i][j]+c[2][i][j])*v[i][j].size();\n      \n      for(int k=0;k<(int)v[i][j].size()-1;k++){\n\tif((v[i][j][k+1]-v[i][j][k])*c[0][i][j]<(c[1][i][j]+c[2][i][j]))\n\t  ans+=(v[i][j][k+1]-v[i][j][k])*c[0][i][j]-(c[1][i][j]+c[2][i][j]);\n      }\n      \n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint H, W, M;\nint idx(int x, int y){\n  return y*W+x;\n}\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> H >> W >> M;\n  VS vs(H);\n  REP(i,H) cin >> vs[i];\n  VVI cost(H, VI(W)), on(H, VI(W)), off(H, VI(W));\n  REP(y,H) REP(x,W) cin >> cost[y][x];\n  REP(y,H) REP(x,W) cin >> on[y][x];\n  REP(y,H) REP(x,W) cin >> off[y][x];\n  vector<PII> task(M);\n  REP(i,M) cin >> task[i].second >> task[i].first;\n\n  vector<PII> path;\n  path.PB(task[0]);\n  for(int i=0;i+1<M;++i){\n\tbool vis[50][50];\n\tfill((bool*)vis, (bool*)vis+50*50, false);\n\tPII par[50][50];\n\n\tqueue<PII> q;\n\tq.push(task[i]);\n\tvis[task[i].second][task[i].first] = true;\n\twhile(!vis[task[i+1].second][task[i+1].first]){\n\t  PII p = q.front(); q.pop();\n\t  REP(i,4){\n\t\tint tx = p.first + dx[i], ty = p.second + dy[i];\n\t\tif(tx < 0 || W <= tx || ty < 0 || H <= ty || vis[ty][tx] || vs[ty][tx] == '#') continue;\n\t\tvis[ty][tx] = true;\n\t\tpar[ty][tx] = p;\n\t\tq.push(MP(tx,ty));\n\t  }\n\t}\n\n\tvector<PII> tmp;\n\tPII p = task[i+1];\n\twhile(p != task[i]){\n\t  tmp.PB(p);\n\t  p = par[p.second][p.first];\n\t}\n\treverse(ALL(tmp));\n\tpath.insert(path.end(), ALL(tmp));\n  }\n\n  bool flag[50][50];\n  fill((bool*)flag, (bool*)flag+50*50, false);\n  LL ans = 0;\n  for(int i=0;i<SZ(path);++i){\n\tint x = path[i].first, y = path[i].second;\n\tif(!flag[y][x]){\n\t  flag[y][x] = true;\n\t  ans += on[y][x];\n\t}\n\tint j;\n\tfor(j=i+1;j<SZ(path);++j){\n\t  if(path[i] == path[j]){\n\t\tif((j-i)*cost[y][x] < on[y][x] + off[y][x])\n\t\t  ans += (j-i)*cost[y][x];\n\t\telse\n\t\t  ans += on[y][x] + off[y][x];\n\t\tbreak;\n\t  }\n\t}\n\tif(j == SZ(path)){\n\t  ans += off[y][x];\n\t}\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n#define mp make_pair\n\nconst int MAXN = 55;\nint R, C;\nchar mat[MAXN][MAXN];\nint viz[MAXN][MAXN];\nint powerPerTime[MAXN][MAXN];\nint turnOn[MAXN][MAXN];\nint turnOff[MAXN][MAXN];\nvector<int> times[MAXN][MAXN];\n\nvoid readMat(int k[MAXN][MAXN]) {\n  for (int i = 0; i < R; ++i)\n    for (int j = 0; j < C; ++j)\n      scanf(\"%d\", &k[i][j]);\n}\n\nint d[] = { 0, 1, 0, -1, 1, 0, -1, 0 };\n\nLL solveFor(int i, int j) {\n  vector<int> &v = times[i][j];\n  if (v.size() == 0)\n    return 0;\n  LL ans = turnOn[i][j];\n  for (int k = 0; k < (int)v.size() - 1; ++k) {\n    int timeSpent = v[k + 1] - v[k];\n    LL costStingAprind = turnOff[i][j] + turnOn[i][j];\n    LL costLasLumina = 1LL * timeSpent * powerPerTime[i][j];\n    ans += min(costLasLumina, costStingAprind);\n  }\n  ans += turnOff[i][j];\n  return ans;\n}\n\nvector< pair< int, pair<int, int> > > DFSrez;\nint tari, tarj;\nint dfsmark;\n\nbool DFSsol(int curi, int curj, int lvl) {\n  viz[curi][curj] = dfsmark;\n  if (curi == tari && curj == tarj)\n    return true;\n  for (int di = 0; di < 4; ++di) {\n    int ni = curi + d[di * 2], nj = curj + d[di * 2 + 1];\n    if (ni < 0 || nj < 0 || ni >= R || nj >= C)\n      continue;\n    if (mat[ni][nj] == '#')\n      continue;\n    if (viz[ni][nj] == dfsmark)\n      continue;\n    if (!DFSsol(ni, nj, lvl + 1))\n      continue;\n    DFSrez.push_back(mp(lvl + 1, mp(ni, nj)));\n    return true;\n  }\n  return false;\n}\n\nint main() {\n  int M;\n  scanf(\"%d%d%d\", &R, &C, &M);\n  memset(viz, 0xFF, sizeof viz);\n  for(int i=0; i<R; ++i)\n    for (int j = 0; j < C; ++j) {\n      scanf(\" %c\", &mat[i][j]);\n      if (mat[i][j] == '#')\n        continue;\n    }\n  readMat(powerPerTime);\n  readMat(turnOn);\n  readMat(turnOff);\n  int curi, curj;\n  scanf(\"%d%d\", &curi, &curj);\n  int curTime = 0;\n  times[curi][curj].push_back(0);\n  for (dfsmark = 0; dfsmark < M - 1; ++dfsmark) {\n    scanf(\"%d%d\", &tari, &tarj);\n    DFSrez.clear();\n    assert(DFSsol(curi, curj, curTime));\n    for (int itt = 0; itt < (int)DFSrez.size(); ++itt) {\n      auto &it = DFSrez[itt];\n      times[it.second.first][it.second.second].push_back(it.first);\n    }\n    curTime = DFSrez[0].first;\n    curi = tari, curj = tarj;\n  }\n  LL ans = 0;\n  for(int i=0; i<R; ++i)\n    for(int j=0; j<C; ++j)\n      ans += solveFor(i, j);\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-5;\nconst int inf=1e8;\nint n,m,x;\nvvi in;\nvs fil;\nvvi info;\nvp task;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n\tcin>>n>>m>>x;\n\tin=vvi(n*m);\n\tfil=vs(n);\n\trep(i,n)cin>>fil[i];\n\tinfo=vvi(n*m,vi(3));\n\trep(j,3)rep(i,n*m)cin>>info[i][j];\n\ttask=vp(x);\n\trep(i,x)cin>>task[i].first>>task[i].second;\n\tint tim=0;\n\trep(i,x-1){\n\t\tvvi used(n,vi(m,inf));\n\t\tused[task[i].first][task[i].second]=0;\n\t\tpriority_queue<pii>q;\n\t\tq.push(pii(task[i].first,task[i].second));\n\t\twhile(!q.empty()){\n\t\t\tpii p=q.top();\n\t\t\tq.pop();\n\t\t\trep(i,4){\n\t\t\t\tint nx=p.first+dx[i];\n\t\t\t\tint ny=p.second+dy[i];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||fil[nx][ny]=='#')continue;\n\t\t\t\tif(used[nx][ny]>1+used[p.first][p.second]){\n\t\t\t\t\tused[nx][ny]=1+used[p.first][p.second];\n\t\t\t\t\tq.push(pii(nx,ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint t=used[task[i+1].first][task[i+1].second],tmp=t;\n\t\tint x=task[i+1].first,y=task[i+1].second;\n\t\twhile(t){\n\t\t\trep(i,4){\n\t\t\t\tint nx=x+dx[i];\n\t\t\t\tint ny=y+dy[i];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m||fil[nx][ny]=='#')continue;\n\t\t\t\tif(used[x][y]!=used[nx][ny]+1)continue;\n\t\t\t\tt--;\n\t\t\t\tin[nx*m+ny].pb(tim+t);\n\t\t\t\tx=nx;y=ny;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\ttim+=tmp;\n\t}\n\tin[task[x-1].first*m+task[x-1].second].pb(tim);\n\tint out=0;\n\trep(i,n*m)if(in[i].size()){\n\t\tout+=info[i][1]+info[i][2];\n\t\trep(j,in[i].size()-1)out+=min((in[i][j+1]-in[i][j])*info[i][0],info[i][1]+info[i][2]);\n\t}\n\tcout<<out<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 60, PMAX = 1010;\nconst int dl[] = {1, 0, -1, 0};\nconst int dc[] = {0, 1, 0, -1};\n\nint N, M, Q;\nchar A[NMAX][NMAX];\nint B[NMAX][NMAX];\nint C[NMAX][NMAX];\nint D[NMAX][NMAX];\nint Dist[NMAX][NMAX];\nlist<int> E[NMAX][NMAX];\npair<int, int> from[NMAX][NMAX];\n\nvoid getPath(int startX, int startY, int finishX, int finishY, vector<pair<int, int>> &dest) {\n\tqueue<pair<int, int>> Q;\n\n\tbool witness[NMAX][NMAX] = {};\n\tQ.push({startX, startY});\n\twitness[startX][startY] = 1;\n\tDist[startX][startY] = 0;\n\tbool found = 0;\n\twhile (!Q.empty()) {\n\t\tint currX, currY;\n\t\ttie(currX, currY) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint newX = currX + dl[i];\n\t\t\tint newY = currY + dc[i];\n\t\t\tif (newX < 0 || newX >= N || newY < 0 || newY >= M)\n\t\t\t\tcontinue;\n\t\t\tif (A[newX][newY] != '.' || witness[newX][newY])\n\t\t\t\tcontinue;\n\t\t\tfrom[newX][newY] = {currX, currY};\n\t\t\tDist[newX][newY] = Dist[currX][currY] + 1;\n\t\t\twitness[newX][newY] = 1;\n\t\t\tQ.push({newX, newY});\n\t\t\tif (newX == finishX && newY == finishY) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tassert(found);\n\tint currX, currY;\n\ttie(currX, currY) = from[finishX][finishY];\n\tint newSize = dest.size() + Dist[currX][currY];\n\tassert(newSize < 2500000);\n\tdest.resize(newSize);\n\t--newSize;\n\twhile (currX != startX || currY != startY) {\n\t\tdest[newSize--] = {currX, currY};\n\t\ttie(currX, currY) = from[currX][currY];\n\t}\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tscanf(\"%d %d %d\", &N, &M, &Q);\n\tfor (i = 0; i < N; ++i)\n\t\tscanf(\"%s\", A[i]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &B[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &C[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &D[i][j]);\n\n\tvector<pair<int, int>> path;\n\tint lastX, lastY, currX, currY;\n\tscanf(\"%d %d\", &lastX, &lastY);\n\twhile (Q-- > 1) {\n\t\tscanf(\"%d %d\", &currX, &currY);\n\t\tassert(lastX != currX || lastY != currY);\n\t\tpath.push_back({lastX, lastY});\n\t\tgetPath(lastX, lastY, currX, currY, path);\n\t\tlastX = currX, lastY = currY;\n\t}\n\tpath.push_back({lastX, lastY});\n\n\tassert(path.size() < 2500000);\n\n\tfor (size_t i = 0; i < path.size(); ++i)\n\t\tE[path[i].first][path[i].second].push_back(i);\n\n\tbool lightOn[NMAX][NMAX] = {};\n\tint answer = 0;\n\tint currAdd = 0;\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tint x = path[i].first, y = path[i].second;\n\t\tanswer += currAdd;\n\t\tif (!lightOn[x][y])\n\t\t\tanswer += C[x][y];\n\t\tE[x][y].pop_front();\n\t\tint front = E[x][y].front();\n\t\tif (E[x][y].size() && (front - i) * B[x][y] < C[x][y] + D[x][y]) {\n\t\t\tif (!lightOn[x][y])\n\t\t\t\tcurrAdd += B[x][y];\n\t\t\tlightOn[x][y] = 1;\n\t\t} else {\n\t\t\tif (lightOn[x][y])\n\t\t\t\tcurrAdd -= B[x][y];\n\t\t\tlightOn[x][y] = 0;\n\t\t\tanswer += D[x][y];\n\t\t}\n\t}\n\n\tcout << answer << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,int> mp;\n  vector<int> V;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = mp.size();\n        V.push_back(i*C+j);\n      }\n    }\n  }\n  int n = mp.size();\n  vector< vector< vector<int> > > G(n,vector< vector<int> >(n,vector<int>(0)));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        int v = mp[x_*C+y_];\n        G[i][v] = vector<int>(1,v);\n      }\n    }\n  }\n  \n  for(int i = 0; i < n; ++i) G[i][i] = vector<int>(0);\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  /*\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      cout << \" (\" << V[i]/C << \", \" << V[i]%C << \") (\" << V[j]/C << \", \" << V[j]%C << \") : \";\n      for(int k = 0; k < G[i][j].size(); ++k){\n        cout << \" (\" << V[G[i][j][k]]/C << \", \" << V[G[i][j][k]]%C << \")\";\n      }cout << endl;\n    }\n  }\n  */\n  vector< vector<int> > P(R, vector<int>(C)), ON = P, OFF = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> ON[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OFF[i][j];\n  vector<int> X(M), Y(M);\n  for(int i = 0; i < M; ++i)\n    cin >> X[i] >> Y[i];\n  vector<int> T(n,-1);\n  T[mp[X[0]*C+Y[0]]] = 0;\n  int t = 0;\n  long long int ans = ON[X[0]][Y[0]] + OFF[X[0]][Y[0]];\n  for(int i = 0; i < M-1; ++i){\n    int v = mp[X[i]*C+Y[i]], v_ = mp[X[i+1]*C+Y[i+1]];\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += ON[r][c] + OFF[r][c];\n      }else{\n        ans += min(ON[r][c] + OFF[r][c], P[r][c]*(t-T[k]));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repf(i, a, b) for (int i = (a); i <= (b); ++i)\nconst int maxint = -1u>>1;\nconst int maxn = 50 + 2;\nconst int maxm = 1000 + 10;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint r, c, m;\nchar s[maxn][maxn];\nint open[maxn][maxn], inst[maxn][maxn], cl[maxn][maxn];\npair<int, int> rec[maxm];\nvector<pair<int, int> > p;\nvector<int> tm[maxn][maxn];\nbool used[maxn][maxn];\n\nbool dfs(int x1, int y1, int x2, int y2) {\n    if (x1 == x2 && y1 == y2) return true;\n    if (used[x1][y1]) return false;\n    used[x1][y1] = true;\n    p.push_back(make_pair(x1, y1));\n    for (int i = 0; i < 4; ++i) {\n        int tx = x1 + dx[i], ty = y1 + dy[i];\n        if (tx < 0 || ty < 0 || tx >= r || ty >= c || s[tx][ty] != '.') continue;\n        if (dfs(tx, ty, x2, y2)) return true;\n    }\n    p.pop_back();\n    return false;\n}\nint main() {\n    while (scanf(\"%d%d%d\", &r, &c, &m) == 3) {\n        for (int i = 0; i < r; ++i) {\n            scanf(\"%s\", s[i]);\n        }\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                tm[i][j].clear();\n                scanf(\"%d\", &inst[i][j]);\n            }\n        }\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                scanf(\"%d\", &open[i][j]);\n            }\n        }\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                scanf(\"%d\", &cl[i][j]);\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d%d\", &rec[i].first, &rec[i].second);\n        }\n        int now = 0;\n        for (int i = 1; i < m; ++i) {\n            memset(used, 0, sizeof(used));\n            p.clear();\n            dfs(rec[i - 1].first, rec[i - 1].second, rec[i].first, rec[i].second);\n            for (int j = 0; j < (int) p.size(); ++j) {\n                tm[p[j].first][p[j].second].push_back(now);\n                ++now;\n            }\n        }\n        tm[rec[m - 1].first][rec[m - 1].second].push_back(now);\n        int ans = 0;\n        for (int i = 0; i < r; ++i) {\n            for (int j = 0; j < c; ++j) {\n                if (tm[i][j].size() == 0) continue;\n                //printf(\"%d %d: \", i, j);for (int k = 0; k < (int)tm[i][j].size(); ++k) printf(\"%d \", tm[i][j][k]); printf(\"\\n\");\n                ans += open[i][j] + cl[i][j] + inst[i][j] * (tm[i][j].back() - tm[i][j].front());\n                for (int k = 1; k < (int)tm[i][j].size(); ++k) {\n                    if ((tm[i][j][k] - tm[i][j][k - 1]) * inst[i][j] > open[i][j] + cl[i][j]) {\n                        ans -= (tm[i][j][k] - tm[i][j][k - 1]) * inst[i][j] - open[i][j] - cl[i][j];\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 100000000\n#define EPS 1e-10\n#define MOD 1000000007\nusing namespace std;\ntypedef pair<int,int> P;\n\nint dr[4] = {1,0,-1,0};\nint dc[4] = {0,1,0,-1};\n\nint r, c, m;\nvector<int> t[50][50];\nchar brd[50][50];\nint x[3][50][50];\n\n\nqueue<P> que;\nint dist[50][50];\n\nint main(){\n\tcin >> r >> c >> m;\n\trep(i,r) rep(j,c){\n\t\tcin >> brd[i][j];\n\t}\n\trep(i,3) rep(j,r) rep(k,c) cin >> x[i][j][k];\n\tP st;\n\tint ti = 0;\n\trep(i,m){\n\t\tP en;\n\t\tcin >> en.first >> en.second;\n\t\tif(i == 0){\n\t\t\tst = en;\n\t\t\tt[st.first][st.second].push_back(ti);\n\t\t\tcontinue;\n\t\t}\n\t\trep(j,r) rep(k,c) dist[j][k] = INF;\n\t\tdist[st.first][st.second] = 0;\n\t\tque.push(st);\n\t\twhile(true){\n\t\t\tif(que.size() == 0) break;\n\t\t\tP q = que.front();\n\t\t\tque.pop();\n\t\t\trep(i,4){\n\t\t\t\tif(0>q.first+dr[i]||q.first+dr[i]>=r) continue;\n\t\t\t\tif(0>q.second+dc[i]||q.second+dc[i]>=c) continue;\n\t\t\t\tif(brd[q.first+dr[i]][q.second+dc[i]] == '#') continue;\n\t\t\t\tif(dist[q.first+dr[i]][q.second+dc[i]] != INF) continue;\n\t\t\t\tdist[q.first+dr[i]][q.second+dc[i]] = dist[q.first][q.second]+1;\n\t\t\t\tque.push(P(q.first+dr[i],q.second+dc[i]));\n\t\t\t}\n\t\t}\n\t\tint rr = en.first, cc = en.second;\n\t\twhile(true){\n\t\t\tif(dist[rr][cc] == 0) break;\n\t\t\tt[rr][cc].push_back(ti+dist[rr][cc]);\n\t\t\trep(i,4){\n\t\t\t\tif(0>rr+dr[i]||rr+dr[i]>=r) continue;\n\t\t\t\tif(0>cc+dc[i]||cc+dc[i]>=c) continue;\n\t\t\t\tif(dist[rr+dr[i]][cc+dc[i]] == dist[rr][cc]-1){\n\t\t\t\t\trr += dr[i];\n\t\t\t\t\tcc += dc[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tti += dist[en.first][en.second];\n\t\tst = en;\n\t}\n\tlong long ans = 0;\n\tlong long dp[2][1000];\n\trep(i,r) rep(j,c){\n\t\tif(t[i][j].size() == 0) continue;\n\t\tif(t[i][j].size() == 1){\n\t\t\tans += x[1][i][j]+x[2][i][j];\n\t\t\tcontinue;\n\t\t}\n\t\trep(k,2) rep(u,1000) dp[k][u] = INF;\n\t\trep(k,t[i][j].size()){\n\t\t\tif(k == 0){\n\t\t\t\tdp[0][0] = x[1][i][j]+x[2][i][j];\n\t\t\t\tdp[1][0] = x[1][i][j]+x[0][i][j]*(t[i][j][1]-t[i][j][0]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdp[0][k] = min(dp[0][k-1]+x[1][i][j]+x[2][i][j],dp[1][k-1]+x[2][i][j]);\n\t\t\tif(k != t[i][j].size()-1) dp[1][k] = min(dp[0][k-1]+x[1][i][j],dp[1][k-1])+x[0][i][j]*(t[i][j][k+1]-t[i][j][k]); \n\t\t}\n\t\tans += dp[0][t[i][j].size()-1];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint R, C, M, keep[60][60], on[60][60], off[60][60], X[2525], Y[2525];\nbool checked[60][60];\nvector<int> pass[60][60];\nchar board[60][60];\nint tot = 0;\n\nvoid read_input(int A[][60]) {\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n}\n\nint dfs(int x, int y, int tx, int ty, int d) {\n    if(x == tx && y == ty) return d;\n    for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(nx < 0 || nx >= R || ny < 0 || ny >= C) continue;\n        if(board[nx][ny] == '#' || checked[nx][ny]) continue;\n        checked[nx][ny] = true;\n        int val = dfs(nx, ny, tx, ty, d+1);\n        checked[nx][ny] = false;\n        if(val) {\n            pass[x][y].push_back(tot + d);\n            return val;\n        }\n    }\n    return 0;\n}\n\nvoid solve() {\n    for(int i=0; i<M-1; i++) {\n        checked[ X[i] ][ Y[i] ] = true;\n        tot += dfs(X[i], Y[i], X[i+1], Y[i+1], 0);\n        checked[ X[i] ][ Y[i] ] = false;\n    }\n    pass[ X[M-1] ][ Y[M-1] ].push_back(tot);\n\n    int ans = 0;\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            int N = pass[i][j].size();\n            if(!N) continue;\n            ans += on[i][j] + off[i][j];\n            for(int k=0; k<N-1; k++) {\n                int diff = pass[i][j][k+1] - pass[i][j][k];\n                int vl = on[i][j] + off[i][j];\n                int vr = keep[i][j] * diff;\n                ans += min(vl, vr);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &R, &C, &M);\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            scanf(\" %c\", &board[i][j]);\n        }\n    }\n    read_input(keep);\n    read_input(on);\n    read_input(off);\n    for(int i=0; i<M; i++) {\n        scanf(\"%d%d\", &X[i], &Y[i]);\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n\nstruct Room {\n\tint x, y;\n\tstd::vector<Room> neighbors() const {\n\t\treturn std::vector<Room>{ Room{x + 1, y}, Room{x - 1, y}, Room{x, y + 1}, Room{x, y - 1} };\n\t}\n\tbool operator==(const Room that) const { return x == that.x && y == that.y; }\n\tbool operator!=(const Room that) const { return !((*this) == that); }\n};\nbool set_next_room(const Room current, std::vector<std::vector<Room>>& next_room, std::vector<std::vector<int>> &searching, const std::vector<std::string> &office, const Room goal, const int current_step) {\n\tif (current == goal) return true;\n\tif (searching[current.y][current.x] == current_step) return false;\n\tsearching[current.y][current.x] = current_step;\n\tfor (const auto next : current.neighbors()) if (0 <= next.y && next.y < office.size() && 0 <= next.x && next.x < office[next.y].size() && office[next.y][next.x] != '#'){\n\t\tif (set_next_room(next, next_room, searching, office, goal, current_step)) {\n\t\t\tnext_room[current.y][current.x] = next;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nstruct Light {\n\tint hold, on, off;\n};\nint main() {\n\tint r, c, m; std::cin >> r >> c >> m;\n\tstd::vector<std::string> office(r); for (auto& o : office) std::cin >> o;\n\tstd::vector<std::vector<Room>> next_room(r, std::vector<Room>(c));\n\tstd::vector<std::vector<int>> searching(r, std::vector<int>(c, -1));\n\tstd::vector<std::vector<std::vector<int>>> visit_timing(r, std::vector<std::vector<int>>(c));\n\tstd::vector<std::vector<Light>> lights(r, std::vector<Light>(c));\n\tfor (auto ri = 0; ri < r; ++ri) for (auto ci = 0; ci < c; ++ci) {\n\t\tstd::cin >> lights[ri][ci].hold;\n\t}\n\tfor (auto ri = 0; ri < r; ++ri) for (auto ci = 0; ci < c; ++ci) {\n\t\tstd::cin >> lights[ri][ci].on;\n\t}\n\tfor (auto ri = 0; ri < r; ++ri) for (auto ci = 0; ci < c; ++ci) {\n\t\tstd::cin >> lights[ri][ci].off;\n\t}\n\tint current_time = 0;\n\tRoom current; std::cin >> current.y >> current.x;\n\tvisit_timing[current.y][current.x].push_back(0);\n\tfor (auto i = 1; i < m; ++i) {\n\t\tRoom dist; std::cin >> dist.y >> dist.x;\n\t\tset_next_room(current, next_room, searching, office, dist, i);\n\t\twhile (current != dist) {\n\t\t\tcurrent = next_room[current.y][current.x];\n\t\t\tvisit_timing[current.y][current.x].push_back(++current_time);\n\t\t}\n\t}\n\tint sum_cost = 0;\n\tfor (auto ri = 0; ri < r; ++ri) for (auto ci = 0; ci < c; ++ci) {\n\t\tsum_cost += visit_timing[ri][ci].size() * (lights[ri][ci].on + lights[ri][ci].off);\n\t\tfor (auto i = 1; i < visit_timing[ri][ci].size(); ++i) {\n\t\t\tauto time = visit_timing[ri][ci][i] - visit_timing[ri][ci][i - 1];\n\t\t\tif (lights[ri][ci].hold * time < lights[ri][ci].on + lights[ri][ci].off) {\n\t\t\t\tsum_cost += lights[ri][ci].hold * time - lights[ri][ci].on - lights[ri][ci].off;\n\t\t\t}\n\t\t}\n\t}\n\tstd::cout << sum_cost << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxn=100;\nconst long long INF=10000000000LL;\nstruct point\n{\n\tint x,y;\n\tpoint(){}\n\tpoint(int _x,int _y):x(_x),y(_y){}\n};\nvector<point> seq,st;\nint obx,oby;\nint s[]={0,1,0,-1};\nint t[]={1,0,-1,0};\nint r,c;\nchar a[maxn][maxn];\nint nov[maxn][maxn];\nbool dfs(int x,int y)\n{\n\tif(x==obx && y==oby) return true;\n\tif(x<0||x>=r||y<0||y>=c||a[x][y]=='#'||nov[x][y]==false) return false;\n\tnov[x][y]=false;\n\tfor(int p=0;p<4;p++)\n\t{\n\t\tif(dfs(x+s[p],y+t[p]))\n\t\t{\n\t\t\tst.push_back(point(x,y));\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nlong long x[maxn][maxn],y[maxn][maxn],z[maxn][maxn];\nlong long next[maxn][maxn];\nint e[10000],f[10000];\nint main()\n{\n\tint m;\n\twhile(scanf(\"%d%d%d\",&r,&c,&m)!=EOF)\n\t{\n\t\tfor(int i=0;i<r;i++) scanf(\"%s\",a[i]);\n\t\tfor(int i=0;i<r;i++)\n\t\t\tfor(int j=0;j<c;j++) \n\t\t\t\tscanf(\"%lld\",&x[i][j]);\n\t\tfor(int i=0;i<r;i++)\n\t\t\tfor(int j=0;j<c;j++) \n\t\t\t\tscanf(\"%lld\",&y[i][j]);\n\t\tfor(int i=0;i<r;i++)\n\t\t\tfor(int j=0;j<c;j++) \n\t\t\t\tscanf(\"%lld\",&z[i][j]);\n\t\tfor(int i=0;i<m;i++) \n\t\t{\n\t\t\tscanf(\"%d%d\",&e[i],&f[i]);\n\t\t}\n\t\tseq.clear();\n\t\tfor(int i=0;i<m-1;i++)\n\t\t{\n\t\t\tobx=e[i+1];oby=f[i+1];\n\t\t\tif(e[i]==e[i+1] && f[i]==f[i+1]) continue;\n\t\t\tfor(int p=0;p<r;p++)\n\t\t\t\tfor(int q=0;q<c;q++)\n\t\t\t\t\tnov[p][q]=true;\n\t\t\tst.clear();\n\t\t\tdfs(e[i],f[i]);\n\t\t\twhile(st.size()>0)\n\t\t\t{\n\t\t\t\tseq.push_back(st.back());\n\t\t\t\tst.pop_back();\n\t\t\t}\n\t\t}\n\t\tseq.push_back(point(e[m-1],f[m-1]));\n\t\tfor(int i=0;i<r;i++)\n\t\t\tfor(int j=0;j<c;j++)\n\t\t\t\tnext[i][j]=INF;\n\t\tlong long ans=0;\n\t\tfor(int i=seq.size()-1;i>=0;i--)\n\t\t{\n\t\t\tint p=seq[i].x,q=seq[i].y;\n\t\t\tans+=min((next[p][q]-i)*x[p][q],y[p][q]+z[p][q]);\n\t\t\tnext[p][q]=i;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint R, C, M, keep[60][60], on[60][60], off[60][60], X[2525], Y[2525];\nbool checked[60][60];\nvector<int> pass[60][60];\nchar board[60][60];\nint tot = 0;\n\nvoid read_input(int A[][60]) {\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n}\n\nint dfs(int x, int y, int tx, int ty, int d) {\n    if(x == tx && y == ty) return d;\n    for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(nx < 0 || nx >= R || ny < 0 || ny >= C) continue;\n        if(board[nx][ny] == '#' || checked[nx][ny]) continue;\n        checked[nx][ny] = true;\n        int val = dfs(nx, ny, tx, ty, d+1);\n        checked[nx][ny] = false;\n        if(val) {\n            pass[x][y].push_back(tot + d);\n            return val;\n        }\n    }\n    return 0;\n}\n\nvoid solve() {\n    for(int i=0; i<M-1; i++) {\n        memset(checked, false, sizeof(checked));\n        checked[ X[i] ][ Y[i] ] = true;\n        tot += dfs(X[i], Y[i], X[i+1], Y[i+1], 0);\n        if(i == M-2) pass[ X[i+1] ][ Y[i+1] ].push_back(tot);\n    }\n\n    int ans = 0;\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            int N = pass[i][j].size();\n            ans += on[i][j] + off[i][j];\n            for(int k=0; k<N-1; k++) {\n                int diff = pass[i][j][k+1] - pass[i][j][k];\n                int vl = on[i][j] + off[i][j];\n                int vr = keep[i][j] * diff;\n                ans += min(vl, vr);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &R, &C, &M);\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            scanf(\" %c\", &board[i][j]);\n        }\n    }\n    read_input(keep);\n    read_input(on);\n    read_input(off);\n    for(int i=0; i<M; i++) {\n        scanf(\"%d%d\", &X[i], &Y[i]);\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nstruct node\n{\n    int x, y;\n};\n\nconst int inf = 0x3f3f3f3f;\n\nchar s[60][60];\nint l[60][60];\nint k[60][60];\nint g[60][60];\nint rx[1010], ry[1010];\nint vis[60][60];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint r, c, m;\nint mx, my;\nvector <node> a;\nvector <node> z;\n\nint dfs(int x, int y, int fx, int fy)\n{\n    if(x == mx && y == my)\n        return 1;\n    for(int i = 0; i < 4; i++)\n    {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(nx < 0 || nx >= r || ny < 0 || ny >= c || s[nx][ny] == '#')\n            continue;\n        if(nx == fx && ny == fy)\n            continue;\n        if(dfs(nx, ny, x, y) == 1)\n        {\n            node xin;\n            xin.x = nx, xin.y = ny;\n            a.push_back(xin);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d\", &r, &c, &m))\n    {\n        memset(vis, -1, sizeof(vis));\n        for(int i = 0; i < r; i++)\n            scanf(\"%s\", s[i]);\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < c; j++)\n                scanf(\"%d\", &l[i][j]);\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < c; j++)\n                scanf(\"%d\", &k[i][j]);\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < c; j++)\n                scanf(\"%d\", &g[i][j]);\n        for(int i = 0; i < m; i++)\n            scanf(\"%d%d\", &rx[i], &ry[i]);\n        z.clear();\n        node qi;\n        qi.x = rx[0], qi.y = ry[0];\n        z.push_back(qi);\n        for(int i = 1; i < m; i++)\n        {\n            a.clear();\n            if(rx[i] == rx[i - 1] && ry[i] == ry[i - 1])\n                continue;\n            mx = rx[i], my = ry[i];\n            dfs(rx[i - 1], ry[i - 1], -1, -1);\n            for(int j = a.size() - 1; j >= 0; j--)\n            {\n                node aa = a[j];\n                z.push_back(aa);\n            }\n        }\n//        printf(\"\\n\\n\");\n//        for(int i = 0; i < z.size(); i++)\n//        {\n//            printf(\"%d %d\\n\", z[i].x, z[i].y);\n//        }\n        long long sum = 0;\n        int i;\n        for(i = 0; i < z.size(); i++)\n        {\n            int nx = z[i].x;\n            int ny = z[i].y;\n            sum += k[nx][ny] + g[nx][ny];\n            //cout << sum << endl;\n            if(vis[nx][ny] == -1)\n            {\n                vis[nx][ny] = i;\n                continue;\n            }\n            if((long long)(i - vis[nx][ny]) * l[nx][ny] <  k[nx][ny] + g[nx][ny])\n            {\n               // printf(\"%d\\n\", (k[nx][ny] + g[nx][ny]) - (i - vis[nx][ny) * l[nx][ny]);\n                sum -= (k[nx][ny] + g[nx][ny]) - (i - vis[nx][ny]) * l[nx][ny];\n            }\n            //printf(\"\\n\");\n            vis[nx][ny] = i;\n        }\n        //sum += g[rx[i]][ry[i]];\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nchar str[60][60];\nint t[60][60];\nint on[60][60];\nint off[60][60];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint v[60][60];\nint last[60][60];\nint row[1100];\nint col[1100];\nint n,m;\nint time;\nlong long ret;\nint dfs(int a,int b,int c,int d){\n\tv[a][b]=d;\n\tif(a==row[c]&&b==col[c]){\n\t\tif(!~last[a][b])ret+=on[a][b];\n\t\telse ret+=min(off[a][b]+on[a][b],t[a][b]*(d+time-last[a][b]));\n\t\tlast[a][b]=time+d;\n\t\treturn 1;\n\t}\n\tfor(int i=0;i<4;i++){\n\t\tif(a+dx[i]<0||b+dy[i]<0||a+dx[i]>=n||b+dy[i]>=m)continue;\n\t\tif(str[a+dx[i]][b+dy[i]]=='#')continue;\n\t\tif(~v[a+dx[i]][b+dy[i]])continue;\n\t\tint res=dfs(a+dx[i],b+dy[i],c,d+1);\n\t\tif(res){\n\t\t\tif(d){\n\t\t\t\tif(!~last[a][b])ret+=on[a][b];\n\t\t\t\telse ret+=min(off[a][b]+on[a][b],t[a][b]*(d+time-last[a][b]));\n\t\t\t\tlast[a][b]=time+d;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tn=a;\n\tm=b;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%s\",str[i]);\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&t[i][j]);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&on[i][j]);\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)scanf(\"%d\",&off[i][j]);\n\tret=0;\n\tfor(int i=0;i<c;i++){\n\t\tscanf(\"%d%d\",row+i,col+i);\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)last[i][j]=-1;\n\tlast[row[0]][col[0]]=0;\n\ttime=0;\n\tret+=on[row[0]][col[0]];\n\tfor(int i=1;i<c;i++){\n\t\tfor(int j=0;j<a;j++)for(int k=0;k<b;k++)v[j][k]=-1;\n\t\tdfs(row[i-1],col[i-1],i,0);\n\t\ttime+=v[row[i]][col[i]];\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(~last[i][j])ret+=off[i][j];\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <climits>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint dy[] = {0, 1, 0, -1};\nint dx[] = {1, 0, -1, 0};\n\nvector<string> room;\nvector<vector<int> > dir;\n\nbool dfs(int y0, int x0, int y1, int x1){\n\tif(y0 == y1 && x0 == x1)\n\t\treturn true;\n\n\tfor(int i=0; i<4; ++i){\n\t\tdir[y0][x0] = i;\n\t\tint y = y0 + dy[i];\n\t\tint x = x0 + dx[i];\n\t\tif(room[y][x] == '#' || (dir[y][x] != -1 && dir[y][x] == (i+2)%4))\n\t\t\tcontinue;\n\t\tif(dfs(y, x, y1, x1))\n\t\t\treturn true;\n\t}\n\n\tdir[y0][x0] = -1;\n\treturn false;\n}\n\nint main()\n{\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\n\troom.assign(h+2, string(w+2, '#'));\n\tfor(int i=1; i<=h; ++i){\n\t\tfor(int j=1; j<=w; ++j){\n\t\t\tcin >> room[i][j];\n\t\t}\n\t}\n\n\tvector<vector<int> > per(h+2, vector<int>(w+2));\n\tvector<vector<int> > on = per, off = per;\n\tfor(int i=1; i<=h; ++i){\n\t\tfor(int j=1; j<=w; ++j){\n\t\t\tcin >> per[i][j];\n\t\t}\n\t}\n\tfor(int i=1; i<=h; ++i){\n\t\tfor(int j=1; j<=w; ++j){\n\t\t\tcin >> on[i][j];\n\t\t}\n\t}\n\tfor(int i=1; i<=h; ++i){\n\t\tfor(int j=1; j<=w; ++j){\n\t\t\tcin >> off[i][j];\n\t\t}\n\t}\n\tvector<int> taskY(m), taskX(m);\n\tfor(int i=0; i<m; ++i){\n\t\tcin >> taskY[i] >> taskX[i];\n\t\t++ taskY[i];\n\t\t++ taskX[i];\n\t}\n\n\tint t = 0;\n\tdir.assign(h+2, vector<int>(w+2, -1));\n\tvector<vector<int> > prev(h+2, vector<int>(w+2, -1));\n\tint y = taskY[0];\n\tint x = taskX[0];\n\tprev[y][x] = 0;\n\tint ret = on[y][x];\n\n\tfor(int i=1; i<m; ++i){\n\t\tdfs(y, x, taskY[i], taskX[i]);\n\t\twhile(y != taskY[i] || x != taskX[i]){\n\t\t\tint d = dir[y][x];\n\t\t\tdir[y][x] = -1;\n\t\t\ty += dy[d];\n\t\t\tx += dx[d];\n\t\t\t++ t;\n\n\t\t\tif(prev[y][x] == -1){\n\t\t\t\tret += on[y][x];\n\t\t\t}else{\n\t\t\t\tret += min(off[y][x] + on[y][x], per[y][x] * (t - prev[y][x]));\n\t\t\t}\n\t\t\tprev[y][x] = t;\n\t\t}\n\t}\n\n\tfor(int i=1; i<=h; ++i){\n\t\tfor(int j=1; j<=w; ++j){\n\t\t\tif(prev[i][j] != -1){\n\t\t\t\tret += off[i][j];\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\nint  dx[]={1,0,-1,0};\nint  dy[]={0,1,0,-1};\n\nstruct Task{\n\tint y,x;int t;\n\tTask(int y,int x,int t):y(y),x(x),t(t){};\n};\n\nclass Main{\npublic:\n\n\n\n\tvector<vector<bool>> passed;\n\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tqueue<Task> que;\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tREP(i,M){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tint res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//mid\n\t\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t\t}\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,vector<P> >P2;\nbool used[51][51];\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\nstring s[51];\nint a[51][51][3],x,y;\nint cx,cy,c,h,w,Q,ans;\nint main(){\n  vector<int>V[3000];\n  cin>>h>>w>>Q;\n  r(i,h)cin>>s[i];\n  r(k,3)r(i,h)r(j,w)cin>>a[i][j][k];\n  cin>>cy>>cx;\n  V[cy*51+cx].push_back(0);\n  r(i,Q-1){\n    cin>>y>>x;\n    queue<P2>q;\n    vector<P>v,ans;\n    v.push_back(P(cx,cy));\n    memset(used,0,sizeof(used));\n    used[cy][cx]=1;\n    q.push(P2(P(cx,cy),v));\n    while(!q.empty()){\n      P2 pt=q.front();q.pop();\n      int ax=pt.first.first;\n      int ay=pt.first.second;\n      if(ax==x&&ay==y)ans=pt.second;\n      r(j,4){\n        int yy=ay+dy[j];\n        int xx=ax+dx[j];\n        if(yy<0||xx<0||yy>=h||xx>=w)continue;\n        if(s[yy][xx]=='#')continue;\n        if(used[yy][xx])continue;\n        vector<P>v2=pt.second;\n        v2.push_back(P(xx,yy));\n        used[yy][xx]=1;\n        q.push(P2(P(xx,yy),v2));\n      }\n    }\n    cx=x;\n    cy=y;\n    r(j,ans.size()-1){\n      V[ans[j+1].second*51+ans[j+1].first].push_back(++c);\n    }\n  }\n  r(i,51)r(j,51){\n    r(k,(int)V[i*51+j].size()-1){\n      int x1=V[i*51+j][k];\n      int x2=V[i*51+j][k+1];\n      ans+=min(a[i][j][1]+a[i][j][2],(x2-x1)*a[i][j][0]);\n    }\n    if(V[i*51+j].size())ans+=a[i][j][1]+a[i][j][2];\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\n#define REP(i, e) for(int (i)=1; (i)<=(e); (i)++)\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool dfs(int y, int x, int gy, int gx, vector<int> &ry, vector<int> &rx, vector<vector<bool> > &used, vector<vector<char> > &field){\n    if(field[y][x] == '#' || used[y][x]) return false;\n    used[y][x] = true;\n    if(y==gy && x==gx){\n        ry.push_back(y);\n        rx.push_back(x);\n        return true;\n    }\n    for(int i=0; i<4; i++){\n        if(dfs(y+dy[i], x+dx[i], gy, gx, ry, rx, used, field)){\n            ry.push_back(y);\n            rx.push_back(x);\n            return true;\n        }\n    }\n    return false;\n}\n\nint main(){\n    int r,c,m;\n    cin >> r >> c >> m;\n    vector<vector<char> > field(r+2, vector<char>(c+2, '#'));\n    vector<vector<lli> > on, off, keep(r+2, vector<lli>(c+2));\n    on = off = keep;\n    REP(i, r) REP(j, c) cin >> field[i][j];\n    REP(i, r) REP(j, c) cin >> keep[i][j];\n    REP(i, r) REP(j, c) cin >> on[i][j];\n    REP(i, r) REP(j, c) cin >> off[i][j];\n    vector<int> tx(m), ty(m);\n    for(int i=0; i<m; i++){\n        cin >> ty[i] >> tx[i];\n        ty[i]++; tx[i]++;\n    }\n\n    vector<vector<vector<int> > > his(r+2, vector<vector<int> >(c+2));\n    int time=0;\n    for(int i=0; i<m-1; i++){\n        vector<int> rx, ry;\n        vector<vector<bool> > used(r+2, vector<bool>(c+2, false));\n        dfs(ty[i+1], tx[i+1], ty[i], tx[i], ry, rx, used, field);\n        int e = (i==m-2)? rx.size() : rx.size()-1;\n        for(int j=0; j<e; j++){\n            his[ry[j]][rx[j]].push_back(time+j);\n        }\n        time += e;\n    }\n\n    lli ans=0;\n    for(int i=1; i<=r; i++){\n        for(int j=1; j<=c; j++){\n            if(!his[i][j].empty()){\n                ans += on[i][j] + off[i][j];\n            }\n            for(int k=0; k<(int)his[i][j].size()-1; k++){\n                ans += min((his[i][j][k+1]- his[i][j][k])*keep[i][j], off[i][j] +on[i][j]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint R, C, M;\nchar room[55][55];\nint cost[3][55][55];\nint rs[1001], cs[1001];\n\nint d[55][55];\nint pv[55][55];\n\nint dr[] = {0, 1, 0, -1};\nint dc[] = {1, 0, -1, 0};\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> R >> C >> M;\n  rep(i, R) rep(j, C) cin >> room[i][j];\n  rep(i, 3) rep(j, R) rep(k, C) cin >> cost[i][j][k];\n  rep(i, M) cin >> rs[i] >> cs[i];\n\n  vector< tuple<int, int, int> > vec;\n  vec.emplace_back(rs[0], cs[0], 0);\n  int st = 0;\n  rep(i, M-1) {\n    memset(d, -1, sizeof(d));\n    memset(pv, -1, sizeof(pv));\n    d[rs[i]][cs[i]] = st;\n    pv[rs[i]][cs[i]] = 4;\n    queue< pair<int, int> > que;\n    que.emplace(rs[i], cs[i]);\n    while(!que.empty()) {\n      int r, c;\n      tie(r, c) = que.front(); que.pop();\n      if(r == rs[i+1] && c == cs[i+1]) {\n\tst = d[r][c];\n\tbreak;\n      }\n      rep(j, 4) {\n\tint nr = r + dr[j], nc = c + dc[j];\n\tif(nr < 0 || R <= nr || nc < 0 || C <= nc) continue;\n\tif(room[nr][nc] == '#' || d[nr][nc] != -1) continue;\n\td[nr][nc] = d[r][c] + 1;\n\tpv[nr][nc] = j;\n\tque.emplace(nr, nc);\n      }\n    }\n    vector< tuple<int, int, int> > tmp;\n    int r = rs[i+1], c = cs[i+1];\n    while(r != rs[i] || c != cs[i]) {\n      tmp.emplace_back(r, c, d[r][c]);\n      int nr = r - dr[pv[r][c]], nc = c - dc[pv[r][c]];\n      r = nr, c = nc;\n    }\n    reverse(all(tmp));\n    rep(j, tmp.size()) vec.emplace_back(tmp[j]);\n  }\n\n  int ans = 0;\n  int used[R][C];\n  memset(used, -1, sizeof(used));\n  for(auto v : vec) {\n    int r, c, e;\n    tie(r, c, e) = v;\n    //cout << r << \" \" << c << \" \" << e << endl;\n    if(~used[r][c]) {\n      ans += min((e - used[r][c]) * cost[0][r][c], cost[2][r][c] + cost[1][r][c]);\n    } else {\n      ans += cost[1][r][c] + cost[2][r][c];\n    }\n    used[r][c] = e;\n  }\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef vector<int> V;\nconst int MAX_SIZE = 50;\nconst int MAX_TASK_SIZE = 1000;\n\nvector<P> dfs(char f[MAX_SIZE][MAX_SIZE], P src, P des, int R, int C) {\n  vector<P> v;\n  if (src == des) {\n    v.push_back(des);\n    return v;\n  }\n  f[src.first][src.second] = '@';\n  int dr[] = {-1, 1, 0, 0};\n  int dc[] = {0, 0, -1, 1};\n  for (int k = 0; k < 4; ++k) {\n    int i = src.first  + dr[k];\n    int j = src.second + dc[k];\n    if (i + 1 && j + 1 && i < R && j < C && f[i][j] == '.') {\n      v = dfs(f, P(i, j), des, R, C);\n      if (v.size()) {\n        v.insert(v.begin(), src);\n        break;\n      }\n    }\n  }\n  f[src.first][src.second] = '.';\n  return v;\n}\n\nint calc(int R, int C, int M, char f[][MAX_SIZE], int costs[][MAX_SIZE][MAX_SIZE], P tasks[]) {\n  map<P, V> m;\n  int t = 0;\n  m.insert(pair<P, V>(tasks[0], V(1, t++)));\n  for (int i = 0; i < M - 1; ++i) {\n    vector<P> v = dfs(f, tasks[i], tasks[i + 1], R, C);\n    for (vector<P>::iterator vit = ++v.begin(); vit != v.end(); ++vit) {\n      map<P, V>::iterator it = m.find(*vit);\n      if (it == m.end()) {\n        m.insert(pair<P, V>(*vit, V(1, t++)));\n      } else {\n        it->second.push_back(t++);\n      }\n    }\n  }\n  int a = 0;\n  for (map<P, V>::iterator it = m.begin(); it != m.end(); ++it) {\n    int i = it->first.first, j = it->first.second;\n    V v = it->second;\n    int l = v.size();\n    for (int k = 0; k < l; ++k) {\n      int c = costs[1][i][j] + costs[2][i][j];\n      if (k < l - 1) {\n        a += min(c, (v[k + 1] - v[k]) * costs[0][i][j]);\n      } else {\n        a += c;\n      }\n    }\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  int R, C, M;\n  char f[MAX_SIZE][MAX_SIZE];\n  int costs[3][MAX_SIZE][MAX_SIZE];\n  P tasks[MAX_TASK_SIZE];\n  char s[MAX_SIZE + 1];\n  cin >> R >> C >> M;\n  for (int i = 0; i < R; ++i) {\n    cin >> s;\n    for (int j = 0; j < C; ++j) {\n      f[i][j] = s[j];\n    }\n  }\n  for (int k = 0; k < 3; ++k) {\n    for (int i = 0; i < R; ++i) {\n      for (int j = 0; j < C; ++j) {\n        cin >> n;\n        costs[k][i][j] = n;\n      }\n    }\n  }\n  for (int i = 0; i < M; ++i) {\n    int r, c;\n    cin >> r >> c;\n    tasks[i] = P(r, c);\n  }\n  cout << calc(R, C, M, f, costs, tasks) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\nint  dx[]={1,0,-1,0};\nint  dy[]={0,1,0,-1};\n\nstruct Task{\n\tint y,x;int t;\n\tTask(int y,int x,int t):y(y),x(x),t(t){};\n};\n\nclass Main{\npublic:\n\n\n\n\tvector<vector<bool>> passed;\n\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\n\t\t\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tqueue<Task> que;\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tREP(i,M){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tint res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t\t//mid\n\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\nios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1}, INF = 1e9;\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,short int> mp;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        ++n;\n      }\n    }\n  }\n  vector< vector<int> > D(n, vector<int>(n,INF));\n  for(int x = 0; x < R; ++x){\n    for(int y = 0; y < C; ++y){\n      if(S[x][y] == '.'){\n        for(int j = 0; j < 4; ++j){\n          int x_ = x + dx[j], y_ = y + dy[j], i = mp[x*C+y];\n          if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n            short int v = mp[x_*C+y_];\n            D[i][v] = 1;\n          }\n        }\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i) D[i][i] = 0;\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        D[i][j] = min(D[i][j],D[i][k] + D[k][j]);\n      }\n    }\n  }\n\n  vector< vector<short int> > G(n, vector<short int>(n,-1));\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      for(int k = 0; k < n; ++k){\n        if(D[i][k] == 1 && D[i][j] == D[i][k] + D[k][j]){\n          G[i][j] = k;\n          break;\n        }\n      }\n    }\n  }\n  \n\n  vector<short int> P(n), OnOff = P;\n  short int t;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) P[mp[i*C+j]] = t;\n    }\n  }\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) OnOff[mp[i*C+j]] = t;\n    }\n  }\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) OnOff[mp[i*C+j]] += t;\n    }\n  }\n  int x, y;\n  cin >> x >> y;\n  vector<short int> T(n,-1);\n  T[mp[x*C+y]] = 0;\n  t = 0;\n  short int v = mp[x*C+y];\n  int ans = OnOff[v];\n  for(int i = 1; i < M; ++i){\n    cin >> x >> y;\n    short int v_ = mp[x*C+y];\n    while(v != v_){\n      v = G[v][v_];\n      ++t;\n      if(T[v] < 0){\n        T[v] = t;\n        ans += OnOff[v];\n      }else{\n        ans += min((int)OnOff[v], P[v]*(t-T[v]));\n        T[v] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[52][52],b[3][51][51],c[1000],d[1000],h,w,n;\npair<int,int> e[51][51];\nint fi(int p,int q,int r,int y,int x){  \n  int i,j;\n  if(a[y][x])\n    return 1<<30;\n  if(y==c[p]&&x==d[p])\n    ++p;\n  if(p==e[y][x].first)\n    return 1<<30;\n  if(e[y][x].first<0)\n    r+=b[1][y][x];\n  else\n    r+=min(b[0][y][x]*(q-e[y][x].second),b[1][y][x]+b[2][y][x]);\n  pair<int,int> t=e[y][x];\n  e[y][x]=make_pair(p,q);\n  if(p==n){\n    for(i=1;i<=h;++i){\n      for(j=1;j<=w;++j){\n\tif(e[i][j].first>=0)\n\t  r+=b[2][i][j];\n      }\n    }\n    e[y][x]=t;\n    return r;\n  }\n  int mni=fi(p,q+1,r,y-1,x),mnj=fi(p,q+1,r,y+1,x),mnk=fi(p,q+1,r,y,x-1),mnl=fi(p,q+1,r,y,x+1);\n  e[y][x]=t;\n  return min(min(min(mni,mnj),mnk),mnl);\n}\nint main(){\n  int i,j,k;\n  //int h,w,n;\n  cin>>h>>w>>n;\n  //int a[52][52];\n  memset(a,-1,sizeof(a));\n  for(i=1;i<=h;++i){\n    for(j=1;j<=w;++j){\n      char p;\n      cin>>p;\n      if(p=='.')\n\ta[i][j]=0;\n    }\n  }\n  //int b[3][50][50];\n  for(i=0;i<3;++i)\n    for(j=1;j<=h;++j)\n      for(k=1;k<=w;++k)\n\tcin>>b[i][j][k];\n  //int c[1000],d[1000];\n  for(i=0;i<n;++i){\n    cin>>c[i]>>d[i];\n    ++c[i];\n    ++d[i];\n  }\n  for(i=0;i<51;++i)\n    for(j=0;j<51;++j)\n      e[i][j]=make_pair(-1,-1);\n  cout<<fi(0,0,0,c[0],d[0])<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n\tfor(T& x: vec) is >> x;\n\treturn is;\n}\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){\n\t\tif(i) cout << ' ';\n\t\tos << v[i];\n\t}\n\treturn os;\n}\n\ntypedef tuple<int,int,int> T;\n\nvector<vector<char>> room;\nvector<vector<int>> c, on, off;\nvector<vector<int>> pre;\n\nconst int dy[16] = { 0,-1, 0, 1, 1,-1, 1,-1, 0,-2, 0, 2};\nconst int dx[16] = { 1, 0,-1, 0, 1, 1,-1,-1, 2, 0,-2, 0};\n\nint bfs(int h, int w, pair<int, int> s, pair<int, int> g){\n\tvector<vector<int>> dis(h, vector<int>(w, INF));\n\tvector<vector<bool>> used(h, vector<bool>(w,false));\n\tdis[s.first][s.second] = 0;\n\n\tqueue<T> q;\n\tq.emplace(T(s.first, s.second, pre[s.first][s.second]));\n\n\tvector<vector<pair<int, int>>> preVer(h, vector<pair<int, int>>(w,make_pair(-1,-1)));\n\twhile(not q.empty()){\n\t\tint y, x, time;\n\t\ttie(y, x, time) = q.front(); q.pop();\n\t\tused[y][x] = true;\n\t\trep(d,4){\n\t\t\tint ny = y + dy[d];\n\t\t\tint nx = x + dx[d];\n\t\t\tif(ny < 0 || ny >= h || nx < 0 || nx >= w) continue;\n\t\t\tif(room[ny][nx] == '#' or used[ny][nx] == true) continue;\n\n\t\t\tint cost = dis[y][x] + on[ny][nx] + off[ny][nx];\n\t\t\tif(pre[ny][nx] != -1){\n\t\t\t\tcost = min(cost, dis[y][x] + (time + 1 - pre[ny][nx]) * c[ny][nx]);\n\t\t\t}\n\t\t\tif(dis[ny][nx] > cost){\n\t\t\t\tpreVer[ny][nx] = make_pair(y,x);\n\t\t\t\tdis[ny][nx] = cost;\n\t\t\t\tq.emplace(ny, nx, time + 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<pair<int, int>> path;\n\tpath.emplace_back(g);\n\tint time = pre[s.first][s.second];\n\tint y, x;\n\ttie(y,x) = g;\n\twhile(preVer[y][x].first != -1){\n\t\ttie(y,x) = preVer[y][x];\n\t\tpath.emplace_back(y,x);\n\t}\n\tfor(auto i = path.rbegin(); i != path.rend(); i++){\n\t\tpre[i->first][i->second] = time++;\n\t}\n\t//for(auto i : pre){ cout << i << endl; }\n\treturn dis[g.first][g.second];\n}\n\nint main(){\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\n\troom = vector<vector<char>>(h, vector<char>(w,'.'));\n\tc = vector<vector<int>>(h, vector<int>(w,0));\n\ton = vector<vector<int>>(h, vector<int>(w,0));\n\toff = vector<vector<int>>(h, vector<int>(w,0));\n\tpre = vector<vector<int>>(h, vector<int>(w,-1));\n\tcin >> room >> c >> on >> off;\n\n\tvector<pair<int, int>> p(m);\n\trep(i,m){\n\t\tcin >> p[i].first >> p[i].second;\n\t}\n\n\tint y, x;\n\ttie(y, x) = p[0];\n\tint ans = on[y][x] + off[y][x];\n\tpre[y][x] = 0;\n\n\trep(i,m - 1){\n\t\tans += bfs(h, w, p[i], p[i + 1]);\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> >& adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    //cout << a << \" \";\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    //o\n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        int a = M[make_pair(x[i - 1], y[i - 1])];\n        int b = M[make_pair(x[i], y[i])];\n        vector<bool> used(num, false);\n        bool end = false;\n        used[a] = true;\n        dfs(end, a, b, adjlist, node[i], used);\n    }\n\n\n    //x\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * C.cpp\n *\n *  Created on: Oct 9, 2012\n *      Author: carber\n */\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\n#include <vector>\ntypedef long long LL;\n\nconst int maxr = 66;\nconst int maxm = 2048;\nchar g[maxr][maxr];\nint last[maxr][maxr], sign[maxr][maxr];\nint on[maxr][maxr], off[maxr][maxr];\nint gc[maxr][maxr], wx[maxm], wy[maxm];\nint R, C, M;\nvector<vector<int> > ret;\n\nbool input() {\n    if (3 != scanf(\"%d %d %d\", &R, &C, &M)) return false;\n    for (int i = 0; i < R; ++i) {\n        scanf(\"%s\", g[i]);\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            scanf(\"%d\", &gc[i][j]);\n        }\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            scanf(\"%d\", &on[i][j]);\n        }\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            scanf(\"%d\", &off[i][j]);\n        }\n    }\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d\", &wx[i], &wy[i]);\n    }\n    return true;\n}\n\nconst int dir[4][2] = {{-1, 0}, {0, 1}, {0, -1}, {1, 0}};\nint Q[maxr * maxr], st, ed, pre[maxr * maxr];\n\nbool check(int x, int y) {\n    return x >= 0 && y >= 0 && x < R && y < C && g[x][y] != '#';\n}\n\nvoid bfs(int s, int e, int idx) {\n    st = ed = 0; Q[ed++] = s;\n    sign[s/C][s%C] = idx, pre[s] = s;\n    while (st < ed) {\n        if (Q[st] == e) {\n            vector<int> tmp;\n            int cs = pre[e];\n            while (cs != s) {\n                tmp.push_back(cs);\n                cs = pre[cs];\n            }\n            tmp.push_back(cs);\n            reverse(tmp.begin(), tmp.end());\n            ret.push_back(tmp);\n            return;\n        }\n        int x = Q[st] / C, y = Q[st++] % C;\n        for (int k = 0; k < 4; ++k) {\n            int tx = x + dir[k][0];\n            int ty = y + dir[k][1];\n            if (check(tx, ty) && sign[tx][ty] != idx) {\n                sign[tx][ty] = idx;\n                Q[ed++] = tx * C + ty;\n                pre[Q[ed - 1]] = Q[st-1];\n            }\n        }\n    }\n}\n\nvoid solved(int nT) {\n    input();\n        memset(last, -1, sizeof(last));\n        memset(sign, -1, sizeof(sign));\n        ret.clear();\n        for (int i = 1; i < M; ++i) {\n            bfs(wx[i-1] * C + wy[i-1], wx[i] * C + wy[i], i - 1);\n        }\n        ret.back().push_back(wx[M - 1] * C + wy[M-1]);\n\n        int cost = 0, use = 0;\n\n        for (int t = 0; t < (int)ret.size(); ++t) {\n            for (int j = 0; j < (int)ret[t].size(); ++j) {\n                int x = ret[t][j] / C, y = ret[t][j] % C;\n                ++use;\n                if (last[x][y] == -1) {\n                    cost += on[x][y] + off[x][y];\n                    last[x][y] = use;\n                } else {\n                    cost += min((use - last[x][y]) * gc[x][y], on[x][y] + off[x][y]);\n                    last[x][y] = use;\n                }\n            }\n        }\n        printf(\"%d\\n\", cost);\n    //}\n}\n\nint main() {\n    int T = 1;\n    for (int nT = 1; nT <= T; ++nT) {\n        solved(nT);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef pair<int, int> pii;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\ntemplate <class T> constexpr bool in_range(T y, T x, T H, T W) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nstruct consumption {\n  int on, off, stay;\n  consumption() {}\n  consumption(int on, int off, int stay) : on(on), off(off), stay(stay) {}\n};\n\n/*------------------------------------------*/\nint H, W, M;\nvector<string> G;\nmap<pii, consumption> costs;\nvector<pii> vs;\nmap<pii, int> cnt;\n/*------------------------------------------*/\n\nint bfs(pii s, pii t) {\n\n  map<pii, int> dist;\n  dist[s] = 0;\n\n  queue<pii> q;\n  q.push(s);\n\n  while (!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if (y == t.first && x == t.second)\n      return dist[{y, x}];\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if (!in_range(ny, nx, H, W))\n        continue;\n      if (G[ny][nx] == '#')\n        continue;\n      if (dist.find({ny, nx}) == dist.end()) {\n        dist[{ny, nx}] = dist[{y, x}] + 1;\n        q.push({ny, nx});\n      }\n    }\n  }\n  assert(0);\n}\n\nvector<pii> make_path() {\n  vector<pii> path = {vs[0]};\n  queue<pii> q;\n  q.push(vs[0]);\n  set<pii> vis;\n  vis.insert(vs[0]);\n  pii prev[55][55];\n  int idx = 0;\n\n  while (!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if (idx + 1 >= vs.size())\n      continue;\n    if (y == vs[idx + 1].first && x == vs[idx + 1].second) {\n      vector<pii> pt;\n      pii curr = vs[idx + 1];\n      for (; curr != vs[idx]; curr = prev[curr.first][curr.second])\n        pt.push_back(curr);\n      reverse(all(pt));\n      for (auto &e : pt)\n        path.push_back(e);\n      idx++;\n      if (idx == vs.size())\n        break;\n      vis.clear();\n      vis.insert({y, x});\n      while (!q.empty())\n        q.pop();\n    }\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if (!in_range(ny, nx, H, W))\n        continue;\n      if (G[ny][nx] == '#')\n        continue;\n      if (vis.count({ny, nx}))\n        continue;\n      vis.insert({ny, nx});\n      prev[ny][nx] = {y, x};\n      q.push({ny, nx});\n    }\n  }\n  return path;\n}\n\nvoid input() {\n  cin >> H >> W >> M;\n  G.resize(H);\n  rep(i, H) cin >> G[i];\n\n  int C[3][H][W];\n  rep(k, 3) rep(i, H) rep(j, W) cin >> C[k][i][j];\n  rep(i, H) rep(j, W) costs[{i, j}] = {C[1][i][j], C[2][i][j], C[0][i][j]};\n  rep(i, M) {\n    int r, c;\n    cin >> r >> c;\n    vs.emplace_back(r, c);\n  }\n}\n\nint main() {\n\n  input();\n\n  auto path = make_path();\n  for (auto e : path)\n    cnt[e]++;\n\n  int ans = 0;\n  map<pii, int> dist;\n  int currdist = 0;\n  pii prev = vs[0];\n\n  for (auto &&e : path) {\n    currdist += bfs(prev, e);\n    if (dist.find(e) == dist.end())\n      ans += costs[e].on;\n    else\n      ans +=\n          min(costs[e].off + costs[e].on, costs[e].stay * (currdist - dist[e]));\n    if (cnt[e] == 1)\n      ans += costs[e].off;\n    cnt[e]--;\n    dist[e] = currdist;\n    prev = e;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n\n// BEGIN CUT HERE\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n// END CUT HERE \n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define UNIQUE(v) v.erase(unique(ALL(v)), v.end())\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef unsigned long long ull;\n\nconst int N = 55;\nint a[3][N][N];\nstring v[N];\n\nvector<int> t[N][N];\nP prv[N][N];\nint dist[N][N];\n\nint dr[] = { 0, 1, 0, -1 };\nint dc[] = { -1, 0, 1, 0, -1 };\n\nint r, c, m;\n\nint bfs(P start, P goal, int base){\n\tMEMSET(dist, -1);\n\n\tdist[start.first][start.second] = base;\n\tqueue<P> q;\n\tq.push(start);\n\n\twhile (!q.empty()){\n\t\tauto p = q.front();\n\t\tq.pop();\n\n\t\trep(d, 4){\n\t\t\tint nr = p.first + dr[d], nc = p.second + dc[d];\n\t\t\tif (nr < 0 || nr >= r || nc < 0 || nc >= c) continue;\n\t\t\tif (v[nr][nc] == '#') continue;\n\t\t\tif (dist[nr][nc] >= 0) continue;\n\t\t\tdist[nr][nc] = dist[p.first][p.second] + 1;\n\t\t\tprv[nr][nc] = MP(p.first, p.second);\n\t\t\tq.push(MP(nr, nc));\n\t\t}\n\t}\n\n\tP pos = goal;\n\twhile (pos != start){\n\t\tt[pos.first][pos.second].push_back(dist[pos.first][pos.second]);\n\t\tpos = prv[pos.first][pos.second];\n\t}\n\treturn dist[goal.first][goal.second];\n}\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin >> r >> c >> m;\n\trep(i, r) cin >> v[i];\n\trep(k, 3) rep(i, r) rep(j, c) cin >> a[k][i][j];\n\n\tP prv;\n\tint d = 0;\n\trep(i, m){\n\t\tP p;\n\t\tcin >> p.first >> p.second;\n\t\tif (i) d = bfs(prv, p, d);\n\t\telse t[p.first][p.second].push_back(0);\n\t\tprv = p;\n\t}\n\n\tll ans = 0;\n\trep(i, r) rep(j, c){\n\t\tint cost = 0, prv = -1;\n\t\tfor (auto e : t[i][j]){\n\t\t\tif (prv < 0) cost = a[1][i][j] + a[2][i][j];\n\t\t\telse cost = min(cost + a[1][i][j] + a[2][i][j], cost + (e - prv)*a[0][i][j]);\n\t\t\tprv = e;\n\t\t}\n\t\tans += cost;\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\n\nvp trail;\n\nint r,c,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nbool dfs(int cx,int cy,int tx,int ty,vp &t,vs &field,vvi &visited){\n\tvisited[cy][cx]=1;\n\tif(cx==tx&&cy==ty){\n\t\tREP(i,t.size()){\n\t\t\ttrail.push_back(t[i]);\n\t\t}\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint x=cx+dx[i],y=cy+dy[i];\n\t\tif(x<0||y<0||x>=c||y>=r||field[y][x]=='#'||visited[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tvp nt(t);\n\t\tnt.push_back(make_pair(y,x));\n\t\tif(dfs(x,y,tx,ty,nt,field,visited))return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>r>>c>>m;\n\tvs field(r);\n\tREP(i,r){\n\t\tcin>>field[i];\n\t}\n\tvvi con(r,vi(c));\n\tvvi on(r,vi(c));\n\tvvi off(r,vi(c));\n\n\tREP(i,r)REP(j,c){\n\t\tcin>>con[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>on[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>off[i][j];\n\t}\n\n\tvp tasks(m);\n\tREP(i,m){\n\t\tcin>>tasks[i].first>>tasks[i].second;\n\t}\n\n\tFOR(i,1,m){\n\t\tvvi visited(r,vi(c));\n\t\tvp t;\n\t\tif(i==1){\n\t\t\tt.push_back(tasks[i-1]);\n\t\t}\n\t\tdfs(tasks[i-1].second,tasks[i-1].first,tasks[i].second,tasks[i].first,t,field,visited);\n\t}\n\n\tvvi last(r,vi(c,-1));\n\tint cost=0;\n\tREP(i,trail.size()){\n\t\tint y=trail[i].first,x=trail[i].second;\n\t\tif(last[y][x]==-1){\n\t\t\tcost+=on[y][x];\n\t\t}else if((i-last[y][x])*con[y][x]<on[y][x]+off[y][x]){\n\t\t\tcost+=(i-last[y][x])*con[y][x];\n\t\t}else{\n\t\t\tcost+=on[y][x]+off[y][x];\n\t\t}\n\t\tlast[y][x]=i;\n\t}\n\tint lt=trail.size();\n\tREP(y,r)REP(x,c){\n\t\tif(last[y][x]!=-1){\n\t\t\tcost+=off[y][x];\n\t\t}\n\t}\n\tcout<<cost<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\tvector<string> cell(h);\n\tREP(i, h)\n\t\tcin >> cell[i];\n\tvector<vvi> ele(3, vvi(h, vi(w)));\n\tREP(k, 3)\n\t\tREP(i, h)\n\t\tREP(j, w)\n\t\tcin >> ele[k][i][j];\n\tvector<pii> task(m);\n\tREP(i, m)\n\t\tcin >> task[i].first >> task[i].second;\n\tmap<pair<pii, pii>, pii> pre;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (cell[i][j] == '.') {\n\t\t\t\tpre[{ {i, j}, { i,j }}] = { i,j };\n\t\t\t\tqueue<pair<pii, pii>> Q;//now pre\n\t\t\t\tQ.push({ {i,j},{i,j} });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpair<pii, pii> q = Q.front();Q.pop();\n\t\t\t\t\tint ny = q.first.first;\n\t\t\t\t\tint nx = q.first.second;\n\t\t\t\t\tint py = q.second.first;\n\t\t\t\t\tint px = q.second.second;\n\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\tif (nx + dx[k] == px&&ny + dy[k] == py)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (WRAP(nx + dx[k], ny + dy[k], w, h)) {\n\t\t\t\t\t\t\tif (cell[ny + dy[k]][nx + dx[k]] == '.') {\n\t\t\t\t\t\t\t\tpre[{ {i, j}, { ny + dy[k],nx + dx[k] }}] = { ny,nx };\n\t\t\t\t\t\t\t\tQ.push({ { ny + dy[k],nx + dx[k] },{ny,nx} });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint time = 0;\n\tint idx = 0;\n\tpii now = task[0];\n\tvector<vvi> used(h, vvi(w));\n\twhile (1) {\n\t\tif (task[idx + 1] == now) {\n\t\t\tidx++;\n\t\t\tif (idx >= m - 1) {\n\t\t\t\tused[now.first][now.second].push_back(time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tused[now.first][now.second].push_back(time);\n\t\ttime++;\n\t\tnow = pre[{task[idx + 1], now}];\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (used[i][j].empty())\n\t\t\t\tcontinue;\n\t\t\tbool light = false;\n\t\t\tREP(k, used[i][j].size()) {\n\t\t\t\tif (!light) {\n\t\t\t\t\tans += ele[1][i][j];\n\t\t\t\t}\n\t\t\t\tif (k == used[i][j].size() - 1) {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((used[i][j][k + 1] - used[i][j][k])*ele[0][i][j] < ele[1][i][j] + ele[2][i][j]) {\n\t\t\t\t\tans += (used[i][j][k + 1] - used[i][j][k])*ele[0][i][j];\n\t\t\t\t\tlight = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tlight = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define INF P(-1,-1)\n\nclass State{\npublic:\n  P now,pre;\n  State(){}\n  State(P _now,P _pre){\n    now = _now;\n    pre = _pre;\n  }\n};\n\nint h,w,n;\nchar t[52][52];\nint c[52][52],on[52][52],off[52][52];\nP jobs[1002];\n\nbool closed[52][52];\nP p[52][52][1002];\nvector<int> v[52][52];\n\nint dx[] = {0,1,0,-1};\nint dy[] = {-1,0,1,0};\n\nvoid bfs(int start){\n  queue<State> open;\n  memset(closed,0,sizeof(closed));\n  open.push(State(jobs[start],INF));\n\n  while(!open.empty()){\n    State st = open.front();\n    open.pop();\n\n    if(closed[st.now.first][st.now.second]) continue;\n    closed[st.now.first][st.now.second] = true;\n\n    if(st.pre != INF){\n      p[st.now.first][st.now.second][start] = st.pre;\n    }\n\n    rep(i,4){\n      int nx = st.now.second + dx[i];\n      int ny = st.now.first + dy[i];\n\n      if(t[ny][nx] == '.'){\n        open.push(State(P(ny,nx),st.now));\n      }\n    }\n  }\n}\n\nvoid simulate1(){\n  P pos = jobs[0];\n  int now = 0;\n  int tm = 0;\n\n  while(1){\n    v[pos.first][pos.second].push_back(tm);\n    if(now == n-1) break;\n    pos = p[pos.first][pos.second][now+1];\n    if(pos == jobs[now+1]) now++;\n    tm++;\n  }\n}\n\nvoid simulate2(){\n  int idx[52][52];\n  bool light[52][52];\n  memset(light,0,sizeof(light));\n  memset(idx,0,sizeof(idx));\n\n  P pos = jobs[0];\n  int now = 0;\n  int res = 0;\n\n  while(1){\n    if(!light[pos.first][pos.second]){\n      res += on[pos.first][pos.second];\n    }\n    light[pos.first][pos.second] = true;\n\n    if(now == n-1){\n      res += off[pos.first][pos.second];\n      light[pos.first][pos.second] = false;\n      break;\n    }\n\n    if(idx[pos.first][pos.second] + 1 == v[pos.first][pos.second].size()){\n      res += off[pos.first][pos.second];\n      light[pos.first][pos.second] = false;\n    }\n    else{\n      int dist =\n        v[pos.first][pos.second][idx[pos.first][pos.second]+1] -\n        v[pos.first][pos.second][idx[pos.first][pos.second]];\n      int sw = on[pos.first][pos.second] + off[pos.first][pos.second];\n\n      if(dist*c[pos.first][pos.second] > sw){\n        light[pos.first][pos.second] = false;\n        res += off[pos.first][pos.second];\n      }\n      else{\n        res += dist * c[pos.first][pos.second];\n      }\n    }\n\n    idx[pos.first][pos.second]++;\n    pos = p[pos.first][pos.second][now+1];\n    if(pos == jobs[now+1]) now++;\n  }\n\n  printf(\"%d\\n\",res);\n}\n\nvoid solve(){\n  rep(i,h) rep(j,w) v[i][j].clear();\n  rep(i,n){\n    bfs(i);\n  }\n\n  simulate1();\n  simulate2();\n}\n\nint main(){\n  while(scanf(\"%d%d%d\",&h,&w,&n) != EOF){\n    rep(i,h){\n      scanf(\"%s\",t[i]);\n    }\n\n    rep(i,h) rep(j,w) scanf(\"%d\",&c[i][j]);\n    rep(i,h) rep(j,w) scanf(\"%d\",&on[i][j]);\n    rep(i,h) rep(j,w) scanf(\"%d\",&off[i][j]);\n    rep(i,n) scanf(\"%d%d\",&jobs[i].first,&jobs[i].second);\n\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\n\nint R,C,M;\nchar Room[50][50];\nint Cost[3][50][50];\npii TaskRoom[1001];\nvector<int> Time[50][50];\n\nint grid2ind(pii grid){\n    return grid.first * C + grid.second;\n}\npii ind2grid(int ind){\n    return {ind/C,ind%C};\n}\n\nint d[4] = {1,0,-1,0};\nint NowTime = 0;\nint NextTime = -1;\nbool visited[50][50];\nbool check(int y,int x,int ty,int tx,int dep = 0){\n    if(visited[y][x]) return false;\n    visited[y][x] = true;\n    if(y == ty && x == tx){\n        NextTime = NowTime+dep;\n        Time[y][x].push_back(NowTime+dep);\n        return true;\n    }\n    \n    for(int k = 0; k < 4;k++){\n        int ny = y + d[k];\n        int nx = x + d[k^1];\n        if(ny < 0 || ny >= R || nx < 0 || nx >= C) continue;\n        if(Room[ny][nx]=='#') continue;\n        if(check(ny,nx,ty,tx,dep+1)){\n            Time[y][x].push_back(NowTime+dep);\n            return true;\n        }\n    }\n    return false;\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    cin >> R >> C >> M;\n    for(int i = 0; i < R;i++){\n        for(int j = 0; j < C;j++){\n            cin >> Room[i][j];\n        }\n    }\n    for(int i = 0; i < 3;i++){\n        for(int j = 0; j < R;j++){\n            for(int k = 0; k < C;k++){\n                cin >> Cost[i][j][k];\n            }\n        }\n    }\n    for(int i = 0; i < M;i++) cin >> TaskRoom[i].first >> TaskRoom[i].second;\n    \n    int py,px; tie(py,px) = TaskRoom[0];\n    for(int i = 1; i < M;i++){\n        fill(*visited,*visited+50*50,false);\n        check(py,px,TaskRoom[i].first,TaskRoom[i].second);\n        NowTime = NextTime;\n        tie(py,px) = TaskRoom[i];\n    }\n    \n    ll ans = 0;\n    for(int i = 0; i < R;i++){\n        for(int j = 0; j < C;j++){\n            sort(Time[i][j].begin(),Time[i][j].end());\n            \n//            cout << \"(\" << i << \",\" << j << \")\" << endl;\n//            for(auto t:Time[i][j]) cout << t << \" \"; cout << endl;\n            \n            if(Time[i][j].empty()) continue;\n            ans += Cost[1][i][j] + Cost[2][i][j];\n            \n            for(int k = 1; k < Time[i][j].size();k++){\n                ll dt = Time[i][j][k] - Time[i][j][k-1];\n                ans += min(dt*Cost[0][i][j],(ll)Cost[1][i][j] + Cost[2][i][j]);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define maxn 60\n#define N 1010\nchar map[maxn][maxn];\nlong long nt,ti;\nbool use[maxn][maxn];\nint n,m,q;\nstruct task\n{\n    int r,c;\n}s[N];\nstruct visit\n{\n    int cnt;\n    long long int ti[N];\n}vis[maxn][maxn];\nstruct mat\n{\n    long long int keep;\n    long long int on;\n    long long int off;\n}cost[maxn][maxn];\nint dr[4]={-1,1,0,0};\nint dc[4]={0,0,-1,1};\nlong long min(long long a,long long b)\n{\n    return a>b?b:a;\n}\nlong long int get()\n{\n    char ch;\n    while (ch=getchar(),ch<'0'||ch>'9');\n    long long sum=ch-'0';\n    while (ch=getchar(),ch>='0'&&ch<='9')\n        sum=sum*10+ch-'0';\n    return sum;\n}\nint get2()\n{\n    char ch;\n    while (ch=getchar(),ch<'0'||ch>'9');\n    int sum=ch-'0';\n    while (ch=getchar(),ch>='0'&&ch<='9')\n        sum=sum*10+ch-'0';\n    return sum;\n}\nvoid readin()\n{\n    for (int i=1;i<=n;i++)\n        scanf(\"%s\",map[i]+1);\n    //for (int i=1;i<=n;i++)\n    //    printf(\"%s\\n\",map[i]+1);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            cost[i][j].keep=get();\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            cost[i][j].on=get();\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            cost[i][j].off=get();\n   /* for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            printf(\"%I64d %I64d %I64d\\n\",cost[i][j].keep,cost[i][j].on,cost[i][j].off);*/\n    for (int i=1;i<=q;i++)\n        s[i].r=get2(),s[i].c=get2(),s[i].r++,s[i].c++;\n}\nbool ok(int r,int c)\n{\n    if (r<1||r>n||c<1||c>m)return false;\n    if (map[r][c]=='#')return false;\n    return use[r][c];\n}\nbool dfs (int r,int c,task end,long long  tim)\n{\n    if (r==end.r&&c==end.c)\n    {\n        nt=tim;\n        return true;\n    }\n    use[r][c]=0;\n    vis[r][c].ti[++vis[r][c].cnt]=tim;\n    for (int i=0;i<=4;i++)\n    {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (ok(nr,nc))\n        {\n            if (dfs(r+dr[i],c+dc[i],end,tim+1))return true;\n        }\n    }\n    use[r][c]=1;\n    vis[r][c].cnt--;\n    return false;\n}\nvoid work()\n{\n    nt=0ll;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            vis[i][j].cnt=0;\n    for (int i=1;i<q;i++)\n    {\n        memset(use,1,sizeof use);\n        dfs(s[i].r,s[i].c,s[i+1],nt);\n    }\n    vis[s[q].r][s[q].c].ti[++vis[s[q].r][s[q].c].cnt]=nt;\n    long long ans=0;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=1;j<=m;j++)\n        {\n            long long sum=0;\n            //printf(\"cnt=%d : \",vis[i][j].cnt);\n            for (int k=1;k<vis[i][j].cnt;k++)\n            {\n                sum+=min(cost[i][j].on+cost[i][j].off,cost[i][j].keep*(vis[i][j].ti[k+1]-vis[i][j].ti[k]));\n                //printf(\"%lld \",vis[i][j].ti[k]);\n                //printf(\"\\n\");\n            }\n            if (vis[i][j].cnt)sum+=cost[i][j].off+cost[i][j].on;\n            ans+=sum;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n    while (scanf(\"%d %d %d\",&n,&m,&q)!=EOF)\n    {\n        readin();\n        work();\n    }\n    return 0;\n}\n/*\n3 3 5\n***\n*##\n**#\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 0\n2 1\n0 2\n2 0\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tInfo(int arg_row,int arg_col,int arg_time){\n\t\trow = arg_row;\n\t\tcol = arg_col;\n\t\ttime = arg_time;\n\t}\n\n\tint row,col,time;\n};\n\nstruct Data{\n\tint row,col,move_num;\n\tvector<Info> tmp;\n};\n\nint H,W,M,cost[50][50],to_on[50][50],to_off[50][50],sche[1000][2],minCost[50][50];\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar map[50][51];\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nint main(){\n\n\tscanf(\"%d %d %d\",&H,&W,&M);\n\tfor(int i = 0; i < H; i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&cost[i][k]);\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&to_on[i][k]);\n\t}\n\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)scanf(\"%d\",&to_off[i][k]);\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\",&sche[i][0],&sche[i][1]);\n\t}\n\n\tvector<Info> V;\n\tV.push_back(Info(sche[0][0],sche[0][1],0));\n\n\tint start_row,start_col,goal_row,goal_col;\n\tint time = 1,next_row,next_col;\n\n\tqueue<Data> D;\n\n\tfor(int i = 0; i < M-1; i++){\n\n\t\tstart_row = sche[i][0];\n\t\tstart_col = sche[i][1];\n\t\tgoal_row = sche[i+1][0];\n\t\tgoal_col = sche[i+1][1];\n\n\t\twhile(!D.empty())D.pop();\n\t\tData first;\n\t\tfirst.row = start_row;\n\t\tfirst.col = start_col;\n\t\tfirst.tmp.push_back(Info(start_row,start_col,0));\n\t\tfirst.move_num = 0;\n\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++)minCost[a][b] = BIG_NUM;\n\t\t}\n\n\t\tminCost[start_row][start_col] = 0;\n\n\t\tD.push(first);\n\n\t\twhile(!D.empty()){\n\n\t\t\tif(D.front().row == goal_row && D.front().col == goal_col){\n\t\t\t\tfor(int a = 1; a < D.front().tmp.size();a++){ //start+1???goal?????§???V???push\n\t\t\t\t\tV.push_back(Info(D.front().tmp[a].row,D.front().tmp[a].col,time++));\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}else if(D.front().move_num > minCost[D.front().row][D.front().col]){\n\t\t\t\tD.pop();\n\t\t\t}else{\n\n\t\t\t\tfor(int a = 0; a < 4; a++){\n\t\t\t\t\tnext_row = D.front().row + diff_row[a];\n\t\t\t\t\tnext_col = D.front().col + diff_col[a];\n\n\t\t\t\t\tif(rangeCheck(next_row,next_col) == true && map[next_row][next_col] != '#' && minCost[next_row][next_col] > D.front().move_num+1){\n\t\t\t\t\t\tminCost[next_row][next_col] = D.front().move_num+1;\n\t\t\t\t\t\tData new_data;\n\t\t\t\t\t\tfor(int b = 0; b < D.front().tmp.size();b++){\n\t\t\t\t\t\t\tnew_data.tmp.push_back(D.front().tmp[b]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnew_data.tmp.push_back(Info(next_row,next_col,0));\n\t\t\t\t\t\tnew_data.row = next_row;\n\t\t\t\t\t\tnew_data.col = next_col;\n\t\t\t\t\t\tnew_data.move_num = D.front().move_num+1;\n\t\t\t\t\t\tD.push(new_data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tD.pop();\n\t\t\t}\n\t\t}\n\t}\n\n\tbool check[50][50];\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int k = 0; k < W; k++)check[i][k] = false;\n\t}\n\n\n\tint ans = 0;\n\n\tbool FLG;\n    int\tnext_time;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\tif(check[V[i].row][V[i].col] == false){\n\t\t\tans += to_on[V[i].row][V[i].col];\n\t\t\tcheck[V[i].row][V[i].col] = true;\n\t\t}\n\n\t\tFLG = false;\n\t\tfor(int k = i+1; k < V.size();k++){\n\t\t\tif(V[k].row == V[i].row && V[k].col == V[i].col){\n\t\t\t\tnext_time = V[k].time;\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t\tif(!FLG){\n\t\t\tans += to_off[V[i].row][V[i].col];\n\t\t\tcheck[V[i].row][V[i].col] = false;\n\t\t}else{\n\t\t\tif(cost[V[i].row][V[i].col]*(next_time-V[i].time) <= to_off[V[i].row][V[i].col]+to_on[V[i].row][V[i].col]){\n\t\t\t\tans += cost[V[i].row][V[i].col]*(next_time-V[i].time);\n\t\t\t}else{\n\t\t\t\tans += to_off[V[i].row][V[i].col];\n\t\t\t\tcheck[V[i].row][V[i].col] = false;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<unsigned char, unsigned char> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tunsigned char h, w;\n\tint m;\n\tcin >> h >> w >> m;\n\tvector<string> cell(h);\n\tREP(i, h)\n\t\tcin >> cell[i];\n\tvector<vvi> ele(3, vvi(h, vi(w)));\n\tREP(k, 3)\n\t\tREP(i, h)\n\t\tREP(j, w)\n\t\tcin >> ele[k][i][j];\n\tvector<pii> task(m);\n\tREP(i, m)\n\t\tcin >> task[i].first >> task[i].second;\n\tmap<pair<pii, pii>, pii> pre;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (cell[i][j] == '.') {\n\t\t\t\tpre[{ {i, j}, { i,j }}] = { i,j };\n\t\t\t\tqueue<pair<pii, pii>> Q;//now pre\n\t\t\t\tQ.push({ {i,j},{i,j} });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpair<pii, pii> q = Q.front();Q.pop();\n\t\t\t\t\tunsigned char ny = q.first.first;\n\t\t\t\t\tunsigned char nx = q.first.second;\n\t\t\t\t\tunsigned char py = q.second.first;\n\t\t\t\t\tunsigned char px = q.second.second;\n\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\tif (nx + dx[k] == px&&ny + dy[k] == py)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (WRAP(nx + dx[k], ny + dy[k], w, h)) {\n\t\t\t\t\t\t\tif (cell[ny + dy[k]][nx + dx[k]] == '.') {\n\t\t\t\t\t\t\t\tpre[{ {i, j}, { ny + dy[k],nx + dx[k] }}] = { ny,nx };\n\t\t\t\t\t\t\t\tQ.push({ { ny + dy[k],nx + dx[k] },{ny,nx} });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint time = 0;\n\tint idx = 0;\n\tpii now = task[0];\n\tvector<vvi> used(h, vvi(w));\n\twhile (1) {\n\t\tif (task[idx + 1] == now) {\n\t\t\tidx++;\n\t\t\tif (idx >= m - 1) {\n\t\t\t\tused[now.first][now.second].push_back(time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tused[now.first][now.second].push_back(time);\n\t\ttime++;\n\t\tnow = pre[{task[idx + 1], now}];\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (used[i][j].empty())\n\t\t\t\tcontinue;\n\t\t\tbool light = false;\n\t\t\tREP(k, used[i][j].size()) {\n\t\t\t\tif (!light) {\n\t\t\t\t\tans += ele[1][i][j];\n\t\t\t\t}\n\t\t\t\tif (k == used[i][j].size() - 1) {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((used[i][j][k + 1] - used[i][j][k])*ele[0][i][j] < ele[1][i][j] + ele[2][i][j]) {\n\t\t\t\t\tans += (used[i][j][k + 1] - used[i][j][k])*ele[0][i][j];\n\t\t\t\t\tlight = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tlight = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For(i, 0, n)\n#define rrep(i, n) rFor(i, n, 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint h, w, m;\nchar c[55][55];\nlint run[55][55], on[55][55], off[55][55];\npii pos[1010];\nvector<int> visited_time[55][55];\n\nint dfs(int x, int y, int px, int py, int tx, int ty, int cur){\n    if(x == tx && y == ty){\n        visited_time[tx][ty].push_back(cur);\n        return cur;\n    }\n    rep(i, 4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < h && 0 <= ny && ny < w && c[nx][ny] == '.'){\n            if(nx != px || ny != py){\n                int ret = dfs(nx, ny, x, y, tx, ty, cur + 1);\n                if(ret >= 0){\n                    visited_time[x][y].push_back(cur);\n                    return ret;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main(){\n    scanf(\"%d%d%d\", &h, &w, &m);\n    rep(i, h)rep(j, w) scanf(\" %c\", &c[i][j]);\n    rep(i, h)rep(j, w) scanf(\"%lld\", &run[i][j]);\n    rep(i, h)rep(j, w) scanf(\"%lld\", &on[i][j]);\n    rep(i, h)rep(j, w) scanf(\"%lld\", &off[i][j]);\n    rep(i, m) scanf(\"%d%d\", &pos[i].fi, &pos[i].se);\n\n    int now = 0;\n    rep(i, m - 1){\n        now = dfs(pos[i].fi, pos[i].se, -1, -1, pos[i + 1].fi, pos[i + 1].se, now);\n    }\n    lint ans = 0;\n    rep(x, h)rep(y, w)if(!visited_time[x][y].empty()){\n        visited_time[x][y].erase(unique(visited_time[x][y].begin(), visited_time[x][y].end()), visited_time[x][y].end());\n        ans += on[x][y] + off[x][y];\n        rep(i, visited_time[x][y].size() - 1){\n            ans += min(off[x][y] + on[x][y], run[x][y] * (visited_time[x][y][i + 1] - visited_time[x][y][i]));\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<map>\n\nusing namespace std;\n\n#define M 54\n#define S 103\n#define INF 100000000\n\n#define min(a,b) (a>b?b:a)\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nstruct Maps {\n\tint cost, time;\n\tint prevx, prevy;\n};\n\nint main() {\n\tint r, c, m, costcons[M][M], coston[M][M], costoff[M][M];\n\tint last[M][M], cost, time;\n\tchar mapc[M][M]; int cx[S], cy[S];\n\tMaps maps[M][M];\n\tstack<IP> s;\n\t\n\tcin >> r >> c >> m;\n\tfor(int i=0; i<=r+1; ++i) for(int j=0; j<=c+1; ++j) mapc[i][j] = '#';\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> mapc[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> costcons[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> coston[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> costoff[i][j];\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> cy[i] >> cx[i]; ++cx[i]; ++cy[i];\n\t}\n\t\n\tcost = coston[cy[0]][cx[0]] + costoff[cy[0]][cx[0]]; time = 0;\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) last[i][j] = -1;\n\tlast[cy[0]][cx[0]] = 0;\n\tfor(int t=0; t<m-1; ++t) {\n\t\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) {\n\t\t\tmaps[i][j].cost = INF; maps[i][j].time = -1;\n\t\t}\n\t\ts.push(IP(time, P(cx[t], cy[t])));\n\t\tmaps[cy[t]][cx[t]].cost = cost; maps[cy[t]][cx[t]].time = time;\n\t\tmaps[cy[t]][cx[t]].prevx = cx[t]; maps[cy[t]][cx[t]].prevy = cy[t];\n\t\twhile(!s.empty()) {\n\t\t\tint ti = s.top().first;\n\t\t\tint x = s.top().second.first, y = s.top().second.second;\n\t\t\ts.pop();\n\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\tint nx = x+dx[k], ny = y+dy[k];\n\t\t\t\tif(mapc[ny][nx]=='.') {\n\t\t\t\t\tint pcost = coston[ny][nx] + costoff[ny][nx];\n\t\t\t\t\tif(last[ny][nx]!=-1) {\n\t\t\t\t\t\tpcost = min(pcost, (ti+1-last[ny][nx])*costcons[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t\tif((maps[y][x].cost + pcost < maps[ny][nx].cost) ||\n\t\t\t\t\t\t(maps[y][x].cost+pcost==maps[ny][nx].cost && ti+1<maps[y][x].time)) {\n\t\t\t\t\t\tmaps[ny][nx].cost = maps[y][x].cost + pcost;\n\t\t\t\t\t\tmaps[ny][nx].time = ti+1;\n\t\t\t\t\t\tmaps[ny][nx].prevx = x; maps[ny][nx].prevy = y;\n\t\t\t\t\t\tif(nx!=cx[t+1] || ny!=cy[t+1]) {\n\t\t\t\t\t\t\ts.push(IP(ti+1, P(nx, ny)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint px = cx[t+1], py = cy[t+1], pxl, pyl;\n\t\tint timel = maps[cy[t+1]][cx[t+1]].time;\n\t\twhile(px!=cx[t] || py!=cy[t]) {\n\t\t\tlast[py][px] = timel;\n\t\t\t--timel;\n\t\t\tpxl = px; pyl = py;\n\t\t\tpx = maps[pyl][pxl].prevx; py = maps[pyl][pxl].prevy;\n\t\t}\n\t\ttime = maps[cy[t+1]][cx[t+1]].time;\n\t\tcost = maps[cy[t+1]][cx[t+1]].cost;\n\t}\n\tcout << cost << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int vy[] = {0, 1, 0, -1}, vx[] = {1, 0, -1, 0};\n\nint H, W, M, cost[3][50][50];\nstring S[50];\nint last[50][50];\n\nbool isgo(int x, int y)\n{\n  return(0 <= x && x < W && 0 <= y && y < H && S[y][x] == '.');\n}\n\nint getCost(int x, int y, int time)\n{\n  int pv = last[y][x];\n  last[y][x] = time;\n  if(~pv) {\n    return(min(cost[1][y][x] + cost[2][y][x], (time - pv) * cost[0][y][x]));\n  } else {\n    return(cost[1][y][x] + cost[2][y][x]);\n  }\n}\nint addPath(int px, int py, int x, int y, const int gx, const int gy, int& time)\n{\n  if(x == gx && y == gy) return(0);\n  for(int i = 0; i < 4; i++) {\n    int ny = y + vy[i], nx = x + vx[i];\n    if((ny != py || nx != px) && isgo(nx, ny)) {\n      int ntime = time + 1;\n      int next = addPath(x, y, nx, ny, gx, gy, ntime);\n      if(~next) {\n        int poyo = next + getCost(x, y, time);\n        time = ntime;\n        return(poyo);\n      }\n    }\n  }\n  return(-1);\n}\n\nint main()\n{\n  memset(last, -1, sizeof(last));\n  cin >> H >> W >> M;\n  for(int i = 0; i < H; i++) {\n    cin >> S[i];\n  }\n  for(int k = 0; k < 3; k++) {\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n        cin >> cost[k][i][j];\n      }\n    }\n  }\n  int py, px, ret = 0, time = 1;\n  for(int i = 0; i < M; i++) {\n    int y, x;\n    cin >> y >> x;\n    if(i > 0) ret += addPath(-1, -1, px, py, x, y, time);\n    py = y, px = x;\n  }\n  cout << ret + getCost(px, py, time) << endl;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n#define maxn 2600\n#define maxe 1100000\n#define inf 99999999\n\nint R,C,m;\nint save[maxn];\nchar str[60][60];\nint tit[maxn];\nint dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nint getid(int x,int y){\n\treturn x*C+y;\n}\nint net[maxn],size;\nvoid init(){\n\tsize=0;\n\tmemset(net,-1,sizeof(net));\n}\nstruct EDGE{\n\tint v,next;\n}edge[maxe];\nvoid add(int u,int v){\n\tedge[size].v=v;\n\tedge[size].next=net[u];\n\tnet[u]=size++;\n}\n\nint cc,s,t;\nvector<int> path[maxn];//蛟堤捩譚・逧?\nbool dfs(int u,int fa){\n\tif(u==t) return true;\n\tfor(int i=net[u];i!=-1;i=edge[i].next){\n\t\tint v=edge[i].v;\n\t\tif(v==fa) continue;\n\t\tif(dfs(v,u)){\n\t\t\tpath[cc].push_back(v);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nint cost[60][60];\nint kai[60][60],guan[60][60];\nint main(){\n\t\n\twhile(scanf(\"%d%d%d\",&R,&C,&m)!=EOF){\n\t\tmemset(tit,-1,sizeof(tit));\n\t\tfor(int i=0;i<R;i++){\n\t\t\tscanf(\"%s\",str[i]);\n\t\t}\n\t\tinit();\n\t\tfor(int i=0;i<R;i++){\n\t\t\tfor(int j=0;j<C;j++){\n\t\t\t\tif(str[i][j]=='#') continue;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint x=i+dir[k][0];\n\t\t\t\t\tint y=j+dir[k][1];\n\t\t\t\t\tif(x<0 || x>=R || y<0 || y>=C) continue;\n\t\t\t\t\tif(str[x][y]=='#') continue;\n\t\t\t\t\tadd(getid(i,j), getid(x,y));\n\t\t\t\t//\tadd(getid(x,y), getid(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<R;i++){\n\t\t\tfor(int j=0;j<C;j++){\n\t\t\t\tscanf(\"%d\",&cost[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<R;i++){\n\t\t\tfor(int j=0;j<C;j++){\n\t\t\t\tscanf(\"%d\",&kai[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<R;i++){\n\t\t\tfor(int j=0;j<C;j++){\n\t\t\t\tscanf(\"%d\",&guan[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y;\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\tsave[i]=getid(x,y);\n\t\t}\n\t\tcc=0;\n\t\tfor(int i = 0 ; i < m ; i ++)path[i].clear();\n\t\tfor(int i=1;i<m;i++){\n\t\t\ts=save[i]; t=save[i+1];\n\t\t\tcc++;\n\t\t\tdfs(s,-1);\n\t\t\tpath[cc].push_back(s);\n\t\t}\n\t\t\n\t\tint tt = 0 ;\n\t\tint ttt = 1;\n\t\tfor(int i = 1 ; i < m ; i ++) {\n\t\t\tint cccc = 1;\n\t\t\tif(i != 1)cccc ++;\n\t\t\tfor(int j = (int)path[i].size() - cccc ; j >= 0 ; j --) {\n\t\t\t\tint idx = path[i][j];\n\t\t\t\tint rr = idx / C;\n\t\t\t\tint cc = idx % C;\n\t\t\t\tif(tit[idx] == -1) {\n\t\t\t\t\ttt += kai[rr][cc] + guan[rr][cc];\n\t\t\t\t\ttit[idx] = ttt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ttt += min(kai[rr][cc] + guan[rr][cc] , (ttt - tit[idx]) * cost[rr][cc]);\n\t\t\t\t\ttit[idx] = ttt;\n\t\t\t\t}\n\t\t\t\tttt ++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",tt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef pair< int, int > pii;\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint R, C, M, eunit[55][55], eon[55][55], eoff[55][55];\nstring grid[55];\n\nint sx, sy, gx, gy;\nbool vis[55][55];\nint bf[55][55];\n\nbool dfs(int x, int y, vector< pii >& path) {\n\tif (x == gx && y == gy) return true;\n\t\n\tpath.push_back(pii(x, y));\n\t\n\tvis[y][x] = true;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 0 || C <= nx || ny < 0 || R <= ny) continue;\n\t\tif (grid[ny][nx] == '#') continue;\n\t\tif (vis[ny][nx]) continue;\n\t\tif (dfs(nx, ny, path)) return true;\n\t}\n\t\n\tpath.pop_back();\n\t\n\treturn false;\n}\n\nint main() {\n\tcin >> R >> C >> M;\n\tfor_(i,0,R) cin >> grid[i];\n\t\n\tfor_(i,0,R) for_(j,0,C) cin >> eunit[i][j];\n\tfor_(i,0,R) for_(j,0,C) cin >> eon[i][j];\n\tfor_(i,0,R) for_(j,0,C) cin >> eoff[i][j];\n\t\n\tvector< pii > euler;\n\t\n\tcin >> sy >> sx;\n\t\n\tfor_(i,1,M) {\n\t\tcin >> gy >> gx;\n\t\tvector< pii > path;\n\t\t\n\t\tminit(vis, 0);\n\t\t\n\t\tdfs(sx, sy, path);\n\t\t\n\t\tint m = size_of(path);\n\t\tfor_(j,0,m) euler.push_back(path[j]);\n\t\tsx = gx; sy = gy;\n\t}\n\t\n\teuler.push_back(pii(gx, gy));\n\tint m = size_of(euler), ans = 0;\n\tminit(bf, -1);\n\t\n\tfor_(i,0,m) {\n\t\tpii p = euler[i];\n\t\tint x = p.first, y = p.second;\n\t\t\n\t\tif (bf[y][x] == -1) {\n\t\t\tbf[y][x] = i;\n\t\t\tans += eon[y][x];\n\t\t} else {\n\t\t\tint ec = eunit[y][x] * (i - bf[y][x]);\n\t\t\t\n\t\t\tif (ec < eoff[y][x] + eon[y][x]) {\n\t\t\t\tans += ec;\n\t\t\t\tbf[y][x] = i;\n\t\t\t} else {\n\t\t\t\tans += eoff[y][x] + eon[y][x];\n\t\t\t\tbf[y][x] = i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor_(y,0,R) for_(x,0,C) ans += eoff[y][x];\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nint r,c,m;\nint fie[51][51];\nll data[51][51][3];\nint x[1001],y[1001];\nbool used[51][51];\nint px[51][51],py[51][51];\nll on[51][51];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nvoid dfs(int x,int y){\n\tused[x][y]=true;\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx>=0 && nx<c && ny>=0 && ny<r){\n\t\t\tif(fie[nx][ny]==0 && !used[nx][ny]){\n\t\t\t\tpx[nx][ny]=x;\n\t\t\t\tpy[nx][ny]=y;\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d %d %d\",&r,&c,&m);\n\tfor(int i=0;i<r;i++){\n\t\tstring str;\n\t\tcin >> str;\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\telse fie[j][i]=-1;\n\t\t}\n\t}\n\tfor(int k=0;k<3;k++){\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<c;j++){\n\t\t\t\tscanf(\"%d\",&data[j][i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d %d\",&y[i],&x[i]);\n\t}\n\tvector<P> route;\n\troute.push_back(P(x[0],y[0]));\n\tfor(int i=1;i<m;i++){\n\t\tmemset(used,false,sizeof(used));\n\t\tdfs(x[i-1],y[i-1]);\n\t\tvector<P> go;\n\t\tP p=P(x[i],y[i]);\n\t\twhile(p.first!=x[i-1] || p.second!=y[i-1]){\n\t\t\tgo.push_back(p);\n\t\t\tP np;\n\t\t\tnp.first=px[p.first][p.second];\n\t\t\tnp.second=py[p.first][p.second];\n\t\t\tp=np;\n\t\t}\n\t\treverse(go.begin(),go.end());\n\t\tfor(int i=0;i<go.size();i++){\n\t\t\troute.push_back(go[i]);\n\t\t}\n\t}\n\tll res=0;\n\tmemset(on,-1,sizeof(on));\n\tfor(int i=0;i<route.size();i++){\n\t\tint nx=route[i].first,ny=route[i].second;\n\t\tif(on[nx][ny]==-1){\n\t\t\tres+=data[nx][ny][1];\n\t\t\ton[nx][ny]=i;\n\t\t}else{\n\t\t\tres+=min(data[nx][ny][1]+data[nx][ny][2],data[nx][ny][0]*(ll)(i-on[nx][ny]));\n\t\t\ton[nx][ny]=i;\n\t\t}\n\t}\n\tfor(int i=0;i<r;i++){\n\t\tfor(int j=0;j<c;j++){\n\t\t\tif(on[j][i]!=-1)res+=data[j][i][2];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define maxn 60\n#define N 1010\nchar map[maxn][maxn];\nlong long nt,ti;\nbool use[maxn][maxn];\nint n,m,q;\nstruct task\n{\n    int r,c;\n}s[N];\nstruct visit\n{\n    int cnt;\n    long long int ti[N];\n}vis[maxn][maxn];\nstruct mat\n{\n    long long int keep;\n    long long int on;\n    long long int off;\n}cost[maxn][maxn];\nint dr[4]={-1,1,0,0};\nint dc[4]={0,0,-1,1};\nlong long min(long long a,long long b)\n{\n    return a>b?b:a;\n}\nvoid readin()\n{\n    for (int i=1;i<=n;i++)\n        scanf(\"%s\",map[i]+1);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%lld\",&cost[i][j].keep);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%lld\",&cost[i][j].on);\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            scanf(\"%lld\",&cost[i][j].off);\n    for (int i=1;i<=q;i++)\n        scanf(\"%d %d\",&s[i].r,&s[i].c),s[i].r++,s[i].c++;\n}\nbool ok(int r,int c)\n{\n    if (r<1||r>n||c<1||c>m)return false;\n    if (map[r][c]=='#')return false;\n    return use[r][c];\n}\nbool dfs (int r,int c,task end,long long  tim)\n{\n    if (r==end.r&&c==end.c)\n    {\n        nt=tim;\n        return true;\n    }\n    use[r][c]=0;\n    vis[r][c].ti[++vis[r][c].cnt]=tim;\n    for (int i=0;i<=4;i++)\n    {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (ok(nr,nc))\n        {\n            if (dfs(r+dr[i],c+dc[i],end,tim+1))return true;\n        }\n    }\n    use[r][c]=1;\n    vis[r][c].cnt--;\n    return false;\n}\nvoid work()\n{\n    nt=0ll;\n    for (int i=1;i<=n;i++)\n        for (int j=1;j<=m;j++)\n            vis[i][j].cnt=0;\n    for (int i=1;i<q;i++)\n    {\n        memset(use,1,sizeof use);\n        dfs(s[i].r,s[i].c,s[i+1],nt);\n    }\n    vis[s[q].r][s[q].c].ti[++vis[s[q].r][s[q].c].cnt]=nt;\n    long long ans=0;\n    for (int i=1;i<=n;i++)\n    {\n        for (int j=1;j<=m;j++)\n        {\n            long long sum=0;\n            //printf(\"cnt=%d : \",vis[i][j].cnt);\n            for (int k=1;k<vis[i][j].cnt;k++)\n            {\n                sum+=min(cost[i][j].on+cost[i][j].off,cost[i][j].keep*(vis[i][j].ti[k+1]-vis[i][j].ti[k]));\n                //printf(\"%lld \",vis[i][j].ti[k]);\n                //printf(\"\\n\");\n            }\n            if (vis[i][j].cnt)sum+=cost[i][j].off+cost[i][j].on;\n            ans+=sum;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\nint main()\n{\n    while (scanf(\"%d %d %d\",&n,&m,&q)!=EOF)\n    {\n        readin();\n        work();\n    }\n    return 0;\n}\n/*\n3 3 5\n***\n*##\n**#\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 1 1\n1 0\n2 1\n0 2\n2 0\n0 0\n*/"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <iostream>\n#include <string>\n#include <cmath>\n\nint nr_ram=1;\nint r,c,m, m1[55][55], m2[55][55], m3[55][55],dl[]={0,1,0,-1},dc[]={1,0,-1,0},ord[55][55],viz[55][55]={0},on[55][55],timp_curent,sum,s;\nint ramu[55][55],lung,vizi[55],gasit=0;\nchar rooms[55][55];\n\n\nstruct punct\n{\n    int l,c;\n};\npunct ro[2501],inter_ram[55][55],ord_ram[1000][1000],drum[2500];\n\n\nvoid cauta (int x, int y, int x3, int y3)\n{\n    vizi[ramu[x][y]]=1;\n    if(inter_ram[ramu[x][y]][ramu[x3][y3]].l==-1&& !gasit)\n    {\n        for(int i=1; i<=nr_ram &&!gasit; i++)\n        {\n            if(inter_ram[ramu[x][y]][i].c!=-1 && !vizi[i] &&!gasit)\n            {\n               if(ramu[inter_ram[ramu[x][y]][i].l][inter_ram[ramu[x][y]][i].c]==i)\n                {\n                    drum[++lung].l=inter_ram[ramu[x][y]][i].l;\n                    drum[lung].c=inter_ram[ramu[x][y]][i].c;\n                }\n                else\n                {\n                    drum[++lung].l=ord_ram[ord[inter_ram[ramu[x][y]][i].l][inter_ram[ramu[x][y]][i].c]+1][i].l;\n                    drum[lung].c=ord_ram[ord[inter_ram[ramu[x][y]][i].l][inter_ram[ramu[x][y]][i].c]+1][i].c;\n                }\n\n                cauta(drum[lung].l, drum[lung].c, x3, y3);\n                if(!gasit)\n                lung--;\n            }\n\n        }\n    }\n    else\n    {\n        gasit=1;\n    }\n}\n\nvoid parcurge (int x, int y, int x2, int y2)\n{\n    int x3,y3;\n     if(ord[x][y]==ord[x2][y2])\n     {\n         timp_curent++;\n         if(!on[x][y])\n                    {\n                        sum+=m2[x][y];\n                        on[x][y]=timp_curent;\n                    }\n                    else\n                    {\n                        if((timp_curent-on[x][y])*m1[x][y]>m3[x][y]+m2[x][y])\n                        {\n                            sum+=m3[x][y]+m2[x][y];\n                        }\n                        else\n                        {\n                            sum+=(timp_curent-on[x][y])*m1[x][y];\n                        }\n                        on[x][y]=timp_curent;\n                    }\n     }\n     else if(ord[x][y]<ord[x2][y2])\n            {\n                for(int i=ord[x][y]+1; i<=ord[x2][y2];i++)\n                {\n                    timp_curent++;\n                    x3=ord_ram[i][ramu[x][y]].l;\n                    y3=ord_ram[i][ramu[x][y]].c;\n\n                    if(!on[x3][y3])\n                    {\n                        sum+=m2[x3][y3];\n                        on[x3][y3]=timp_curent;\n                    }\n                    else\n                    {\n                        if((timp_curent-on[x3][y3])*m1[x3][y3]>m3[x3][y3]+m2[x3][y3])\n                        {\n                            sum+=m3[x3][y3]+m2[x3][y3];\n                        }\n                        else\n                        {\n                            sum+=(timp_curent-on[x3][y3])*m1[x3][y3];\n                        }\n                        on[x3][y3]=timp_curent;\n                    }\n                }\n            }\n            else\n            {\n                 for(int i=ord[x][y]-1; i>=ord[x2][y2];i--)\n                {\n                    x3=ord_ram[i][ramu[x][y]].l;\n                    y3=ord_ram[i][ramu[x][y]].c;\n                    timp_curent++;\n                    if(!on[x3][y3])\n                    {\n                        sum+=m2[x3][y3];\n                        on[x3][y3]=timp_curent;\n                    }\n                    else\n                    {\n                        if((timp_curent-on[x3][y3])*m1[x3][y3]>m3[x3][y3]+m2[x3][y3])\n                        {\n                            sum+=m3[x3][y3]+m2[x3][y3];\n                        }\n                        else\n                        {\n                            sum+=(timp_curent-on[x3][y3])*m1[x3][y3];\n                        }\n                        on[x3][y3]=timp_curent;\n                    }\n                }\n            }\n}\n\nvoid parcurge2(int x, int y, int x2, int y2)\n{\n    int x3, y3;\n      if(ramu[x][y]==ramu[x2][y2]) parcurge(x,y,x2,y2);\n   else\n    if(ramu[inter_ram[ramu[x][y]][ramu[x2][y2]].l][inter_ram[ramu[x][y]][ramu[x2][y2]].c]==ramu[x][y])\n            {\n                if(x!=inter_ram[ramu[x][y]][ramu[x2][y2]].l || y!=inter_ram[ramu[x][y]][ramu[x2][y2]].c)\n                parcurge(x,y,inter_ram[ramu[x][y]][ramu[x2][y2]].l,inter_ram[ramu[x][y]][ramu[x2][y2]].c);\n                x3=ord_ram[ord[inter_ram[ramu[x][y]][ramu[x2][y2]].l][inter_ram[ramu[x][y]][ramu[x2][y2]].c]+1][ramu[x2][y2]].l;\n                y3=ord_ram[ord[inter_ram[ramu[x][y]][ramu[x2][y2]].l][inter_ram[ramu[x][y]][ramu[x2][y2]].c]+1][ramu[x2][y2]].c;\n\n                parcurge(x3,y3,x3,y3);\n                if(x3!=x2 || y3!=y2)\n                parcurge (x3,y3,x2,y2);\n\n            }\n            else\n            {\n                x3=ord_ram[ord[inter_ram[ramu[x][y]][ramu[x2][y2]].l][inter_ram[ramu[x][y]][ramu[x2][y2]].c]+1][ramu[x][y]].l;\n                y3=ord_ram[ord[inter_ram[ramu[x][y]][ramu[x2][y2]].l][inter_ram[ramu[x][y]][ramu[x2][y2]].c]+1][ramu[x][y]].c;\n\n                if(x!=x3 || y!=y3)\n                parcurge(x,y,x3,y3);\n                parcurge(inter_ram[ramu[x][y]][ramu[x2][y2]].l,inter_ram[ramu[x][y]][ramu[x2][y2]].c,inter_ram[ramu[x][y]][ramu[x2][y2]].l,inter_ram[ramu[x][y]][ramu[x2][y2]].c);\n                if(inter_ram[ramu[x][y]][ramu[x2][y2]].l!=x2 || inter_ram[ramu[x][y]][ramu[x2][y2]].c !=y2)\n                parcurge (inter_ram[ramu[x][y]][ramu[x2][y2]].l,inter_ram[ramu[x][y]][ramu[x2][y2]].c,x2,y2);\n\n            }\n}\n\n\n\n\nvoid _fill(int pr, int pc, int ram)\n{\n    int nr=0;\n    for(int i=0; i<4; i++)\n    {\n        if(pr+dl[i]>=0 && pr+dl[i]<r && pc+dc[i]>=0 && pc+dc[i]<c && !viz[pr+dl[i]][pc+dc[i]] && rooms[pr+dl[i]][pc+dc[i]]=='.')\n        {\n            nr++;\n            if(nr!=1)\n            {\n                nr_ram++;\n                inter_ram[ram][nr_ram].l=pr;\n                inter_ram[ram][nr_ram].c=pc;\n                inter_ram[nr_ram][ram].l=pr;\n                inter_ram[nr_ram][ram].c=pc;\n            }\n            ord[pr+dl[i]][pc+dc[i]]=ord[pr][pc]+1;\n            ramu[pr+dl[i]][pc+dc[i]]=nr_ram;\n            ord_ram[ord[pr+dl[i]][pc+dc[i]]][ramu[pr+dl[i]][pc+dc[i]]].l=pr+dl[i];\n            ord_ram[ord[pr+dl[i]][pc+dc[i]]][ramu[pr+dl[i]][pc+dc[i]]].c=pc+dc[i];\n            viz[pr+dl[i]][pc+dc[i]]=1;\n            _fill(pr+dl[i],pc+dc[i],nr_ram);\n\n        }\n    }\n}\n\n\nint main()\n{\n\n\n    int pr=-1,pc=-1,i,j,nrdir,ok;\n\n    cin>>r>>c>>m;\n\n    for(i=0; i<r; i++)\n        for(j=0; j<c; j++)\n        {\n            cin>>rooms[i][j];\n            if(rooms[i][j]=='.')\n            {\n\n                if(pr==-1)\n                {\n                    pr=i;\n                    pc=j;\n\n                }\n            }\n        }\n\n    for(i=0; i<r; i++)\n       for(j=0; j<c; j++)\n            cin>>m1[i][j];\n\n    for(i=0; i<r; i++)\n       for(j=0; j<c; j++)\n            cin>>m2[i][j];\n\n    for(i=0; i<r; i++)\n       for(j=0; j<c; j++)\n            cin>>m3[i][j];\n\n\n    viz[pr][pc]=1;\n\n    nrdir=0;\n\n    for(i=0; i<4; i++)\n    {\n        if(pr+dl[i]>=0 && pr+dl[i]<r && pc+dc[i]>=0 && pc+dc[i]<c && !viz[pr+dl[i]][pc+dc[i]] && rooms[pr+dl[i]][pc+dc[i]]=='.')\n            nrdir++;\n    }\n\n    if(nrdir!=1)\n    {\n        ok=1;\n\n        viz[pr][pc]=1;\n\n        while(ok)\n        {\n            ok=0;\n\n            for(i=0; i<4; i++)\n            {\n                if(pr+dl[i]>=0 && pr+dl[i]<r && pc+dc[i]>=0 && pc+dc[i]<c && !viz[pr+dl[i]][pc+dc[i]] && rooms[pr+dl[i]][pc+dc[i]]=='.')\n                {\n                    viz[pr+dl[i]][pc+dc[i]]=1;\n                    pr=pr+dl[i];\n                    pc=pc+dc[i];\n                    ok=1;\n\n                }\n            }\n\n        }\n    }\n\n    for(i=0; i<r; i++)\n        for(j=0; j<c; j++)\n          viz[i][j]=0;\n\n    //puncte de intersectie ramuri\n\n    viz[pr][pc]=1;\n    ramu[pr][pc]=1;\n    ord[pr][pc]=1;\n    ord_ram[1][1].l=pr;\n    ord_ram[1][1].c=pc;\n\n    for(i=0; i<r; i++)\n        for(j=0; j<c; j++)\n        {\n            inter_ram[i][j].c=-1;\n            inter_ram[i][j].l=-1;\n        }\n\n    _fill(pr,pc,1);\n\n\n\n    int x,y,x2,y2,start,fin,x3,y3;\n\n    cin>>x>>y;\n\n    on[x][y]=1;\n\n    sum+=m2[x][y];\n    timp_curent=1;\n\n    m--;\n\n    while(m--)\n    {\n        cin>>x2>>y2;\n\n        if(ramu[x][y]==ramu[x2][y2])\n        {\n            parcurge(x,y,x2,y2);\n        }\n\n        else if(inter_ram[ramu[x][y]][ramu[x2][y2]].l!=-1)\n        {\n            parcurge2(x,y,x2,y2);\n\n\n        }\n        else\n        {\n            lung=1;\n            drum[1].l=x;\n            drum[1].c=y;\n            for(i=1; i<=nr_ram; i++)\n                vizi[i]=0;\n\n            gasit=0;\n            cauta (x,y,x2,y2);\n\n            for(i=1; i<lung; i++)\n            {\n                parcurge2(drum[i].l, drum[i].c, drum[i+1].l, drum[i+1].c);\n            }\n            parcurge2(drum[lung].l,drum[lung].c,x2,y2);\n\n        }\n\n\n\n        x=x2;\n        y=y2;\n\n\n    }\n\n\n    for(i=0; i<r; i++)\n      for(j=0; j<c; j++)\n      {\n          if(rooms[i][j]=='.' && on[i][j])\n            sum+=m3[i][j];\n      }\n\n\n      cout<<sum<<'\\n';\n\n\n\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\nusing P = pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int R, C, M;\n    cin >> R >> C >> M;\n    vector<string> v(R);\n    for(int i=0; i<R; ++i) {\n        cin >> v[i];\n    }\n    // 0: per, 1: on, 2: off\n    vector<vector<vector<int>>> cost(3, vector<vector<int>>(R, vector<int>(C)));\n    for(int i=0; i<3; ++i) {\n        for(int j=0; j<R; ++j) {\n            for(int k=0; k<C; ++k) {\n                cin >> cost[i][j][k];\n            }\n        }\n    }\n    vector<P> task(M);\n    for(int i=0; i<M; ++i) {\n        cin >> task[i].first >> task[i].second;\n    }\n    int res = cost[1][task[0].first][task[0].second] + cost[2][task[0].first][task[0].second];\n    vector<vector<int>> prev_t(R, vector<int>(C, INF));\n    prev_t[task[0].first][task[0].second] = 0;\n    int t = 0;\n    for(int i=1; i<M; ++i) {\n        queue<P> que;\n        que.push(task[i-1]);\n        vector<vector<int>> d(R, vector<int>(C, INF));\n        vector<vector<P>> prev(R, vector<P>(C, P{-1, -1}));\n        d[task[i-1].first][task[i-1].second] = t;\n        while(!que.empty()) {\n            P p = que.front(); que.pop();\n            int dr[4] = {0, 1, 0, -1},\n                dc[4] = {1, 0, -1, 0};\n            for(int j=0; j<4; ++j) {\n                int nr = p.first + dr[j],\n                    nc = p.second + dc[j];\n                if(nr < 0 || R <= nr || nc < 0 || C <= nc || v[nr][nc] == '#') {\n                    continue;\n                }\n                if(d[nr][nc] == INF) {\n                    d[nr][nc] = d[p.first][p.second] + 1;\n                    prev[nr][nc] = p;\n                    que.push(make_pair(nr, nc));\n                }\n            }\n        }\n        int r = task[i].first, c = task[i].second;\n        t = d[r][c];\n        while(r != task[i-1].first || c != task[i-1].second) {\n            if(prev_t[r][c] != INF) {\n                res += min((d[r][c] - prev_t[r][c]) * cost[0][r][c], cost[1][r][c] + cost[2][r][c]);\n            } else {\n                res += cost[1][r][c] + cost[2][r][c];\n            }\n            prev_t[r][c] = d[r][c];\n            P p = prev[r][c];\n            r = p.first, c = p.second;\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1}, INF = 1e9;\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,short int> mp;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        ++n;\n      }\n    }\n  }\n  vector< vector<int> > D(n, vector<int>(n,INF));\n  for(int x = 0; x < R; ++x){\n    for(int y = 0; y < C; ++y){\n      if(S[x][y] == '.'){\n        for(int j = 0; j < 4; ++j){\n          int x_ = x + dx[j], y_ = y + dy[j], i = mp[x*C+y];\n          if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n            short int v = mp[x_*C+y_];\n            D[i][v] = 1;\n          }\n        }\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i) D[i][i] = 0;\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        D[i][j] = min(D[i][j],D[i][k] + D[k][j]);\n      }\n    }\n  }\n\n  vector< vector<short int> > G(n, vector<short int>(n,-1));\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      for(int k = 0; k < n; ++k){\n        if(D[i][k] == 1 && D[i][j] == D[i][k] + D[k][j]){\n          G[i][j] = k;\n          break;\n        }\n      }\n    }\n  }\n  \n\n  vector<short int> P(n), OnOff = P;\n  short int t;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) P[mp[i*C+j]] = t;\n    }\n  }\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) OnOff[mp[i*C+j]] = t;\n    }\n  }\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) OnOff[mp[i*C+j]] += t;\n    }\n  }\n  int x, y;\n  cin >> x >> y;\n  vector<short int> T(n,-1);\n  T[mp[x*C+y]] = 0;\n  t = 0;\n  short int v = mp[x*C+y];\n  long long int ans = OnOff[v];\n  for(int i = 1; i < M; ++i){\n    cin >> x >> y;\n    short int v_ = mp[x*C+y];\n    while(v != v_){\n      v = G[v][v_];\n      ++t;\n      if(T[v] < 0){\n        T[v] = t;\n        ans += OnOff[v];\n      }else{\n        ans += min((long long int)OnOff[v], (long long int)(P[v]*(t-T[v])));\n        T[v] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <bitset>\n#include <climits>\nusing namespace std;\n\n#define wh while\n#define inf (int)(~0u/2)\n#define FOR(i, n) for(int i = 0; i < n; i++)\n#define FOR1(i, n) for(int i = 1; i < n; i++)\n#define FOR2(i, n) for(int i = 0; i <= n; i++)\n#define REP(i,n) for(int i = 1; i <= n; i++)\n#define FORI(it,n) for(typeof(n.begin()) it = n.begin(); it != n.end(); it++)\n#define sf scanf\n#define pf printf\n#define frs first\n#define sec second\n#define psh push_back\n#define mkp make_pair\n#define PB(x) push_back(x)\n#define MP(x, y) make_pair(x, y)\n#define clr(abc,z) memset(abc,z,sizeof(abc))\n\ntypedef long long LL;\ntypedef long double LD;\n\nconst int maxn = 55;\nstruct NODE{\n    map<int, int> mp[maxn];\n    int step, cost;\n    int x, y;\n};\nchar mp[maxn][maxn];\nbool vis[maxn][maxn];\nint on_cost[maxn][maxn];\nint open_cost[maxn][maxn];\nint close_cost[maxn][maxn];\nint endx[1100], endy[1100];\nint R, C, M;\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nbool isOK(int x, int y){\n    if(x >= 0 && x < R && y >= 0 && y < C && mp[x][y] != '#' && !vis[x][y])\n        return true;\n    return false;\n}\nNODE bfs(NODE st, int ed){\n    queue<NODE> Q; Q.push(st);\n    while(!Q.empty()){\n        NODE now = Q.front(); Q.pop();\n        if(now.x == endx[ed] && now.y == endy[ed])\n            return now;\n        vis[now.x][now.y] = true;\n        FOR(i, 4){\n            NODE s = now;\n            if(isOK(now.x + dx[i], now.y + dy[i])){\n                s.x += dx[i]; s.y += dy[i]; s.step++;\n                if(s.mp[s.x][s.y]){\n                    if((open_cost[s.x][s.y] + close_cost[s.x][s.y]) >\n                       ((s.step - s.mp[s.x][s.y]) * on_cost[s.x][s.y]))\n                       s.cost += (s.step - s.mp[s.x][s.y]) * on_cost[s.x][s.y];\n                    else s.cost += (open_cost[s.x][s.y] + close_cost[s.x][s.y]);\n                }\n                else s.cost += (open_cost[s.x][s.y] + close_cost[s.x][s.y]);\n                s.mp[s.x][s.y] = s.step;\n                vis[s.x][s.y] = true;\n                Q.push(s);\n            }\n        }\n    }\n}\n\nint main() {\n    sf(\"%d%d%d\", &R, &C, &M);\n    FOR(i, R) sf(\"%s\", mp[i]);\n    FOR(i, R) FOR(j, C) sf(\"%d\", &on_cost[i][j]);\n    FOR(i, R) FOR(j, C) sf(\"%d\", &open_cost[i][j]);\n    FOR(i, R) FOR(j, C) sf(\"%d\", &close_cost[i][j]);\n    FOR(i, M) sf(\"%d%d\", &endx[i], &endy[i]);\n    NODE st;\n    st.x = endx[0]; st.y = endy[0];\n    st.step = 1; st.cost = close_cost[st.x][st.y] + open_cost[st.x][st.y];\n    st.mp[st.x][st.y] = st.step;\n    for(int i = 1; i < M; i++){\n        clr(vis, 0); st = bfs(st, i);\n    }\n    pf(\"%d\\n\", st.cost);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[6] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cassert>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\nconst int N = 100;\nchar m[N][N];\nvector<int> t[N][N];\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nbool vis[N][N];\nint on[N][N];\nint off[N][N];\nint keep[N][N];\n\nbool dfs(int r,int c,int y,int x,int ty,int tx,int ti,int &total){\n  if (vis[y][x])return false;\n  if (y == ty && x == tx){\n    \n    return true;\n  }\n  vis[y][x]=true;\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex == -1 || ney == -1 || nex == c || ney == r || \n        m[ney][nex] == '#')continue;\n    if (dfs(r,c,ney,nex,ty,tx,ti+1,total)){\n      total++;\n      t[y][x].push_back(ti);\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int r,c,q;\n  while(cin>>r>>c>>q){\n    rep(i,r)rep(j,c)t[i][j].clear();\n    rep(i,r)cin>>m[i];\n    //bool dfs(int r,int c,int y,int x,int ty,int tx,int ti,int &total);\n    rep(i,r)rep(j,c)cin>>keep[i][j];\n    rep(i,r)rep(j,c)cin>>on[i][j];\n    rep(i,r)rep(j,c)cin>>off[i][j];\n\n    int total=0;\n    int py,px;\n    rep(i,q){\n      rep(ii,r)rep(jj,c)vis[ii][jj]=false;\n      int sy,sx;\n      cin>>sy>>sx;\n      if (i != 0){\n        dfs(r,c,py,px,sy,sx,total,total);\n      }\n      if (i == q-1)t[sy][sx].push_back(total);\n      py=sy;\n      px=sx;\n    }\n    ll ans=0;\n    rep(i,r){\n      rep(j,c){\n        if (t[i][j].size() == 0)continue;\n        //debqug\n        /*\n          cout <<\"node i j \" << i <<\" \" << j <<\" : \";\n          rep(k,(int)t[i][j].size()){\n          cout << t[i][j][k] << \" \";\n          }\n          cout << endl;\n        */\n        ans+=on[i][j]+off[i][j];\n        REP(k,1,(int)t[i][j].size()){\n          ll dif=t[i][j][k]-t[i][j][k-1];\n          ll costa=dif*keep[i][j];//keep\n          ll costb=on[i][j]+off[i][j];//off->onn\n          ans+=min(costa,costb);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint R, C, M, keep[60][60], on[60][60], off[60][60], X[2525], Y[2525];\nbool checked[60][60];\nvector<int> pass[60][60];\nchar board[60][60];\nint tot = 0;\n\nvoid read_input(int A[][60]) {\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            scanf(\"%d\", &A[i][j]);\n        }\n    }\n}\n\nint dfs(int x, int y, int tx, int ty, int d) {\n    if(x == tx && y == ty) return d;\n    for(int k=0; k<4; k++) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(nx < 0 || nx >= R || ny < 0 || ny >= C) continue;\n        if(board[nx][ny] == '#' || checked[nx][ny]) continue;\n        checked[nx][ny] = true;\n        int val = dfs(nx, ny, tx, ty, d+1);\n        if(val) {\n            pass[x][y].push_back(tot + d);\n            return val;\n        }\n    }\n    return 0;\n}\n\nvoid solve() {\n    for(int i=0; i<M-1; i++) {\n        memset(checked, false, sizeof(checked));\n        checked[ X[i] ][ Y[i] ] = true;\n        tot += dfs(X[i], Y[i], X[i+1], Y[i+1], 0);\n        if(i == M-2) pass[ X[i+1] ][ Y[i+1] ].push_back(tot);\n    }\n\n    int ans = 0;\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            int N = pass[i][j].size();\n            ans += on[i][j] + off[i][j];\n            for(int k=0; k<N-1; k++) {\n                int diff = pass[i][j][k+1] - pass[i][j][k];\n                int vl = on[i][j] + off[i][j];\n                int vr = keep[i][j] * diff;\n                ans += min(vl, vr);\n            }\n        }\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    scanf(\"%d%d%d\", &R, &C, &M);\n    for(int i=0; i<R; i++) {\n        for(int j=0; j<C; j++) {\n            scanf(\" %c\", &board[i][j]);\n        }\n    }\n    read_input(keep);\n    read_input(on);\n    read_input(off);\n    for(int i=0; i<M; i++) {\n        scanf(\"%d%d\", &X[i], &Y[i]);\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nint h,w,m;\nstring mp[N];\nint c[N*N],on[N*N],off[N*N];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nvector<int> path;\nint used[N*N];\nint dfs(int pos,int t){\n  if(pos==t) return 1;\n  if(used[pos]++) return 0;\n  int x = pos%w,y=pos/w;\n\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    int npos = w*ny+nx;\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#')continue;\n    if(dfs(npos,t)){path.push_back(npos);return 1;}\n  }\n  return 0;\n}\n\nvector<int> job;\nint calc(){\n  int res=0,sta[N*N]={},cnt=2; \n  res+=on[job[0]];\n  sta[job[0]] = 1;\n  for(int i=0;i<m-1;i++){\n    path.clear();\n    memset(used,0,sizeof(used));\n    dfs(job[i],job[i+1]);\n    for(int j=0;j<path.size();j++){\n      int pos = path[path.size()-j-1];\n      int &T = sta[pos];\n      if(T==0) res+=on[pos];\n      else res+=min(on[pos]+off[pos],c[pos]*(cnt-T));\n      T=cnt++;\n    }\n  }\n  for(int i=0;i<h*w;i++)if(sta[i])res+=off[i];\n  return res;\n}\n\nint main(){\n  cin>>h>>w>>m;\n  for(int i=0;i<h;i++) cin>>mp[i];\n  for(int i=0;i<h*w;i++) cin>>c[i];\n  for(int i=0;i<h*w;i++) cin>>on[i];\n  for(int i=0;i<h*w;i++) cin>>off[i];\n  for(int i=0,x,y;i<m;i++)cin>>y>>x,job.push_back(y*w+x);\n  cout<<calc()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\nint main(){\n    int r,c,m;\n    cin>>r>>c>>m;\n    vector<string> f(r);\n    for(int i=0;i<r;i++) cin>>f[i];\n    vector<vector<ll>> keep(r,vector<ll>(c,0));\n    vector<vector<ll>> turn(r,vector<ll>(c,0));\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>keep[i][j];\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++){\n        ll tmp; cin>>tmp;\n        turn[i][j]+=tmp;\n    }\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++){\n        ll tmp; cin>>tmp;\n        turn[i][j]+=tmp;\n    }\n    vector<pair<int,int>> task(m);\n    for(int i=0;i<m;i++) cin>>task[i].first>>task[i].second;\n\n    auto isBlank=[&](int x,int y){\n        return 0<=x && x<r && 0<=y && y<c && f[x][y]=='.';\n    };\n    function<bool(int,int,int,int,int,int,stack<pair<int,int>>&)> getPath=\n    [&](int x,int y,int tx,int ty,int px,int py,stack<pair<int,int>> &st){\n        if(!isBlank(x,y)) return false;\n        if(x==tx && y==ty) return true;\n        for(int i=0;i<4;i++){\n            if(x+dx[i]==px && y+dy[i]==py) continue;\n            if(getPath(x+dx[i],y+dy[i],tx,ty,x,y,st)){\n                st.push({x,y});\n                return true;\n            }\n        }\n        return false;\n    };\n    ll t=0;\n    vector<vector<ll>> prev(r,vector<ll>(c,-1));\n    auto getCost=[&](int x,int y){\n        ll ret=prev[x][y]==-1 ? turn[x][y] : min(turn[x][y],(t-prev[x][y])*keep[x][y]);\n        prev[x][y]=t++;\n        return ret;\n    };\n    ll res=0;\n    for(int i=0;i+1<m;i++){\n        int sx=task[i].first,sy=task[i].second;\n        int tx=task[i+1].first,ty=task[i+1].second;\n        stack<pair<int,int>> path;\n        getPath(sx,sy,tx,ty,-1,-1,path);\n        while(!path.empty()){\n            auto tmp=path.top(); path.pop();\n            res+=getCost(tmp.first,tmp.second);\n        }\n    }\n    res+=getCost(task.back().first,task.back().second);\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\n//[int dx[] = { -1, -1, -1, 0, 0, 1, 1, 1 }; int dy[] = { 0, -1, 1, -1, 1, 0, -1, 1 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvoid dijkstra(Graph &g, int s, Array &d, vi& prev)\n{\n\td.assign(g.size(), INF);\n\tprev.assign(g.size(), -1);\n\td[s] = 0;\n\ttypedef pair<Weight, int> P;\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, s));\n\twhile (!que.empty())\n\t{\n\t\tWeight dist = que.top().first;\n\t\tint v = que.top().second;\n\t\tque.pop();\n\t\tif (d[v] < dist) continue;\n\t\tREP(i, g[v].size())\n\t\t{\n\t\t\tEdge e = g[v][i];\n\t\t\tif (d[e.to] > d[v] + e.cost)\n\t\t\t{\n\t\t\t\td[e.to] = d[v] + e.cost;\n\t\t\t\tprev[e.to] = v;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvi build_path(const vi &prev, int t)\n{\n\tvi path;\n\tfor (int i = t; i >= 0; i = prev[i]) path.push_back(i);\n\treverse(ALL(path));\n\treturn path;\n}\n\nint dp[1111][2];\nvi on, off, con;\nint now;\nvi v;\n\nint solve(int i, int j)\n{\n\tif (dp[i][j] < INF) return dp[i][j];\n\tint res;\n\tif (i == v.size() - 1)\n\t{\n\t\tif (j == 0) res = on[now] + off[now];\n\t\telse res = off[now];\n\t}\n\telse\n\t{\n\t\tif (j == 0) res = min(on[now] + off[now] + solve(i + 1, 0), on[now] + con[now] * (v[i + 1] - v[i]) + solve(i + 1, 1));\n\t\telse res = min(off[now] + solve(i + 1, 0), con[now] * (v[i + 1] - v[i]) + solve(i + 1, 1));\n\t}\n\treturn dp[i][j] = res;\n}\n\n\nint main()\n{\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\tvs fld(h);\n\ton.resize(h*w), off.resize(h*w), con.resize(h*w);\n\tREP(i, h) cin >> fld[i];\n\tREP(i, h*w) cin >> con[i];\n\tREP(i, h*w) cin >> off[i];\n\tREP(i, h*w) cin >> on[i];\n\tGraph g(h*w);\n\tREP(i, h)REP(j, w)\n\t{\n\t\tif (fld[i][j] == '#') continue;\n\t\tint tmp = place(i, j, w);\n\t\tREP(k, 4)\n\t\t{\n\t\t\tint nx = i + dx[k], ny = j + dy[k];\n\t\t\tif (!valid(nx, ny, h, w) || fld[nx][ny]=='#') continue;\n\t\t\tint next = place(nx, ny, w);\n\t\t\tadd_edge(g, tmp, next, 1);\n\t\t}\n\t}\n\tvector<vi> vis(h*w);\n\tint x, y; cin >> x >> y;\n\tint tmp = place(x, y, w);\n\tvis[tmp].push_back(0);\n\tint time = 1;\n\tREP(i, m-1)\n\t{\n\t\tint x, y; cin >> x >> y;\n\t\tint next = place(x, y, w);\n\t\tArray dist; vi prev;\n\t\tdijkstra(g, tmp, dist, prev);\n\t\tvi path = build_path(prev, next);\n\t\tFOR(i, 1, path.size())\n\t\t{\n\t\t\tint t = path[i];\n\t\t\tvis[t].push_back(time);\n\t\t\ttime++;\n\t\t}\n\t\ttmp = next;\n\t}\n\tint ans = 0;\n\tREP(i, h*w)\n\t{\n\t\tif (vis[i].size() == 0) continue;\n\t\tREP(i, 1111)REP(j, 2) dp[i][j] = INF;\n\t\tv = vis[i];\n\t\tnow = i;\n\t\tans += solve(0, 0);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint r,c,m,per[50][50],on[50][50],off[50][50],dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint dir[50][50][50][50];\nstring mp[50];\nbool inn(int x,int y) { return (0<=x&&x<r&&0<=y&&y<c); }\nvoid dfs(int sx,int sy,int x,int y,int px,int py,int id){\n\tdir[sx][sy][x][y]=id;\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(!(nx==px && ny==py)&&inn(nx,ny)&&mp[nx][ny]=='.') dfs(sx,sy,nx,ny,x,y,id);\n\t}\n}\nint before[50][50];\nint main(){\n\tcin>>r>>c>>m;\n\trep(i,r) cin>>mp[i];\n\trep(i,r) rep(j,c) cin>>per[i][j];\n\trep(i,r) rep(j,c) cin>>on[i][j];\n\trep(i,r) rep(j,c) cin>>off[i][j];\n\trep(i,r) rep(j,c) if(mp[i][j]=='.'){\n\t\trep(k,4){\n\t\t\tint ni=i+dx[k],nj=j+dy[k];\n\t\t\tif(inn(ni,nj)&&mp[ni][nj]=='.') dfs(i,j,ni,nj,i,j,k);\n\t\t}\n\t}\n\tint a,b,x,y;\n\tcin>>a>>b;\n\tint ans=0,t=0;\n\trep(i,m-1){\n\t\tcin>>x>>y;\n\t\twhile(!(a==x&&b==y)){\n\t\t\tt++;\n\t\t\tif(before[a][b]==0) ans+=on[a][b];\n\t\t\telse {\n\t\t\t\tans+=min((t-before[a][b])*per[a][b],off[a][b]+on[a][b]);\n\t\t\t}\n\t\t\tint d=dir[a][b][x][y];\n\t\t\tbefore[a][b]=t;\n\t\t\ta+=dx[d],b+=dy[d];\n\t\t}\n\t}\n\tt++;\n\tif(before[a][b]==0) ans+=on[a][b];\n\telse {\n\t\tans+=min((t-before[a][b])*per[a][b],off[a][b]+on[a][b]);\n\t}\n\tbefore[a][b]=t;\n\trep(i,r) rep(j,c) if(before[i][j]>0) ans+=off[i][j];\n\tcout << ans<< endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ntypedef long long ll;\n\nusing namespace std;\n\nvector<int> times[50][50];\n\nchar g[50][60];\nint w,h,m;\nint tx[1000];\nint ty[1000];\n\nint cont[50][50];\nint on[50][50];\nint off[50][50];\n\nint dx[] = { 0,0,1,-1 };\nint dy[] = { 1,-1,0,0 };\n\nbool move(int x1, int y1, int x2, int y2, int t, int px = -1, int py = -1){\n  if(x1 == x2 && y1 == y2){\n    if(times[y1][x1].empty() || times[y1][x1].back() != t)\n      times[y1][x1].push_back(t);\n    return true;\n  }\n\n  REP(i,4){\n    int xx = x1 + dx[i];\n    int yy = y1 + dy[i];\n\n    if(xx <  0) continue;\n    if(yy <  0) continue;\n    if(xx >= w) continue;\n    if(yy >= h) continue;\n    if(xx == px && yy == py) continue;\n    if(g[yy][xx] == '#') continue;\n\n    if(move(xx, yy, x2, y2, t + 1, x1, y1)){\n      if(times[y1][x1].empty() || times[y1][x1].back() != t)\n\ttimes[y1][x1].push_back(t);\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint main(){\n  scanf(\"%d%d%d\", &h, &w, &m);\n  REP(i,h) scanf(\"%s\", g[i]);\n  REP(i,h) REP(j,w) scanf(\"%d\", &cont[i][j]);\n  REP(i,h) REP(j,w) scanf(\"%d\", &on[i][j]);\n  REP(i,h) REP(j,w) scanf(\"%d\", &off[i][j]);\n\n  REP(i,m) scanf(\"%d%d\", ty+i, tx+i);\n\n  times[ty[0]][tx[0]].push_back(0);\n  REP(i,m - 1){\n    move(tx[i], ty[i], tx[i+1], ty[i+1], times[ty[i]][tx[i]].back());\n  }\n\n  ll ans = 0;\n\n  REP(i,h) REP(j,w){\n    int n = times[i][j].size();\n    if(n != 0) ans += on[i][j] + off[i][j];\n\n    REP(k, n - 1){\n      int duration = times[i][j][k+1] - times[i][j][k];\n      ans += min(duration * cont[i][j], on[i][j] + off[i][j]);\n    }\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\npii pre[50][50][50][50];\nint main() {\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\tvector<string> cell(h);\n\tREP(i, h)\n\t\tcin >> cell[i];\n\tvector<vvi> ele(3, vvi(h, vi(w)));\n\tREP(k, 3)\n\t\tREP(i, h)\n\t\tREP(j, w)\n\t\tcin >> ele[k][i][j];\n\tvector<pii> task(m);\n\tREP(i, m)\n\t\tcin >> task[i].first >> task[i].second;\n\t\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (cell[i][j] == '.') {\n\t\t\t\tpre[i][j][i][j] = { i,j };\n\t\t\t\tqueue<pair<pii, pii>> Q;//now pre\n\t\t\t\tQ.push({ {i,j},{i,j} });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpair<pii, pii> q = Q.front();Q.pop();\n\t\t\t\t\tint ny = q.first.first;\n\t\t\t\t\tint nx = q.first.second;\n\t\t\t\t\tint py = q.second.first;\n\t\t\t\t\tint px = q.second.second;\n\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\tif (nx + dx[k] == px&&ny + dy[k] == py)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (WRAP(nx + dx[k], ny + dy[k], w, h)) {\n\t\t\t\t\t\t\tif (cell[ny + dy[k]][nx + dx[k]] == '.') {\n\t\t\t\t\t\t\t\tpre[i][j][ny + dy[k]][nx + dx[k]]= { ny,nx };\n\t\t\t\t\t\t\t\tQ.push({ { ny + dy[k],nx + dx[k] },{ny,nx} });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint time = 0;\n\tint idx = 0;\n\tpii now = task[0];\n\tvector<vvi> used(h, vvi(w));\n\twhile (1) {\n\t\tif (task[idx + 1] == now) {\n\t\t\tidx++;\n\t\t\tif (idx >= m - 1) {\n\t\t\t\tused[now.first][now.second].push_back(time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tused[now.first][now.second].push_back(time);\n\t\ttime++;\n\t\tnow = pre[task[idx + 1].first][task[idx + 1].second][now.first][now.second];\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (used[i][j].empty())\n\t\t\t\tcontinue;\n\t\t\tbool light = false;\n\t\t\tREP(k, used[i][j].size()) {\n\t\t\t\tif (!light) {\n\t\t\t\t\tans += ele[1][i][j];\n\t\t\t\t}\n\t\t\t\tif (k == used[i][j].size() - 1) {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((used[i][j][k + 1] - used[i][j][k])*ele[0][i][j] < ele[1][i][j] + ele[2][i][j]) {\n\t\t\t\t\tans += (used[i][j][k + 1] - used[i][j][k])*ele[0][i][j];\n\t\t\t\t\tlight = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tlight = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAXR = 51;\nconst int MAXC = 51;\nconst int INF = 1<<28;\nconst int di[] = {0,1,0,-1};\nconst int dj[] = {1,0,-1,0};\nint R, C, M;\nchar G[MAXR][MAXC];\nint P[3][MAXR][MAXC];\nvector<int> V[MAXR][MAXC];\n\nvector<pair<int,int> > bfs(int r, int c, int gr, int gc) {\n  queue<pair<int,int> > que;\n  int vis[MAXR][MAXC];\n  pair<int,int> path[MAXR][MAXC];\n  fill(vis[0],vis[MAXR],INF);\n  que.push(make_pair(r,c));\n  vis[r][c] = 0;\n  path[r][c] = make_pair(-1,-1);\n  while(!que.empty()) {\n    r = que.front().first;\n    c = que.front().second;\n    que.pop();\n    for(int i = 0; i < 4; ++i) {\n      int nr = r + di[i];\n      int nc = c + dj[i];\n      if(nr < 0 || nr >= R) continue;\n      if(nc < 0 || nc >= C) continue;\n      if(G[nr][nc] == '#') continue;\n      if(vis[nr][nc] != INF) continue;\n      vis[nr][nc] = vis[r][c] + 1;\n      path[nr][nc] = make_pair(r,c);\n      if(nr == gr && nc == gc) {\n\tvector<pair<int,int> > v;\n\tpair<int,int> p = make_pair(nr,nc);\n\twhile(p.first != -1) {\n\t  v.push_back(p);\n\t  p = path[p.first][p.second];\n\t}\n\treverse(v.begin(), v.end());\n\treturn v;\n      }\n      que.push(make_pair(nr,nc));\n    }\n  }\n  return vector<pair<int,int> >();\n}\n\nint main() {\n  while(cin >> R >> C >> M) {\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n\tcin >> G[i][j];\n      }\n    }\n    for(int k = 0; k < 3; ++k) {\n      for(int i = 0; i < R; ++i) {\n\tfor(int j = 0; j < C; ++j) {\n\t  cin >> P[k][i][j];\n\t}\n      }\n    }\n\n    fill(V[0],V[MAXR],vector<int>());\n    int r, c, t;\n    r = c = -1;\n    t = 0;\n    while(M--) {\n      int nr, nc;\n      cin >> nr >> nc;\n      if(r == -1) {\n\tV[nr][nc].push_back(0);\n      } else {\n\tvector<pair<int,int> > v = bfs(r,c,nr,nc);\n\t/*\n\tfor(int i = 0; i < v.size(); ++i) {\n\t  cout << v[i].first << \", \" << v[i].second << endl;\n\t}\n\tcout << endl;\n\t*/\n\tfor(int i = 1; i < v.size(); ++i) {\n\t  V[v[i].first][v[i].second].push_back(++t);\n\t}\n      }\n      r = nr;\n      c = nc;\n    }\n    int res = 0;\n    for(int i = 0; i < R; ++i) {\n      for(int j = 0; j < C; ++j) {\n\tvector<int> &v = V[i][j];\n\tif(v.size() == 0) continue;\n\tres += P[1][i][j] + P[2][i][j];\n\tfor(int k = 1; k < v.size(); ++k) {\n\t  int d = v[k] - v[k-1];\n\t  res += min(d*P[0][i][j], P[1][i][j]+P[2][i][j]);\n\t}\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,short int> mp;\n  vector<int> V;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        V.push_back(i*C+j);\n        ++n;\n      }\n    }\n  }\n  vector< vector< vector<short int> > > G(n,vector< vector<short int> >(n));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        short int v = mp[x_*C+y_];\n        G[i][v].push_back(v);\n      }\n    }\n  }\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<short int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  vector< vector<short int> > P(R, vector<short int>(C)), OnOff = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OnOff[i][j];\n  short int t;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      OnOff[i][j] += t;\n    }\n  }\n  vector<int> X(M), Y(M);\n  for(int i = 0; i < M; ++i)\n    cin >> X[i] >> Y[i];\n  vector<short int> T(n,-1);\n  T[mp[X[0]*C+Y[0]]] = 0;\n  t = 0;\n  int ans = OnOff[X[0]][Y[0]];\n  for(int i = 0; i < M-1; ++i){\n    int v = mp[X[i]*C+Y[i]], v_ = mp[X[i+1]*C+Y[i+1]];\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += OnOff[r][c];\n      }else{\n        ans += min((int)OnOff[r][c], P[r][c]*(t-T[k]));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 C : On or Off\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main(){\n\tint R, C, M;\n\tint pow[50][50], on[50][50], off[50][50];\n\tlong long cost[2][50][50], time[50][50];\n\tint prev[50*50];\n\tstring mp[50];\n\twhile(cin >> R >> C >> M){\n\t\tmemset(cost, 0, sizeof(cost));\n\t\tmemset(time, 0, sizeof(time));\n\t\tfor(int i=0;i<R;i++) cin >> mp[i];\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) cin >> pow[i][j];\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) cin >> on[i][j], cost[0][i][j] = on[i][j];\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) cin >> off[i][j], time[i][j] = -1000000007;\n\t\tint px, py, cx, cy; cin >> cx >> cy;\n\t\tint t = 0;\n\t\tfor(int i=1;i<M;i++){\n\t\t\tpx = cx, py = cy;\n\t\t\tcin >> cx >> cy;\n\t\t\tif(px==cx && py==cy) continue;\n\t\t\tqueue< pair<int,int> > qu; qu.push(make_pair(cx, cy));\n\t\t\tmemset(prev, -1, sizeof(prev));\n\t\t\tprev[cx*C+cy] = -2;\n\t\t\twhile(!qu.empty()){\n\t\t\t\tpair<int,int> pr = qu.front(); qu.pop();\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tint x = pr.first+dx[j], y = pr.second+dy[j];\n\t\t\t\t\tif(x<0||R<=x||y<0||C<=y||mp[x][y]=='#') continue;\n\t\t\t\t\tif(prev[x*C+y]==-1){\n\t\t\t\t\t\tprev[x*C+y] = pr.first*C+pr.second;\n\t\t\t\t\t\tqu.push(make_pair(x,y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cur=px*C+py;prev[cur]!=-2;cur=prev[cur]){\n\t\t\t\tint x = cur/C, y = cur%C;\n\t\t\t\tcost[0][x][y] = min(cost[0][x][y]+(t-time[x][y])*pow[x][y], cost[1][x][y]+on[x][y]);\n\t\t\t\tcost[1][x][y] = cost[0][x][y]+off[x][y];\n\t\t\t\ttime[x][y] = t++;\n\t\t\t}\n\t\t}\n\t\tcost[0][cx][cy] = min(cost[0][cx][cy]+(t-time[cx][cy])*pow[cx][cy], cost[1][cx][cy]+on[cx][cy]);\n\t\tcost[1][cx][cy] = cost[0][cx][cy]+off[cx][cy];\n\t\ttime[cx][cy] = t;\n\n\t\tint res = 0;\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) res += cost[1][i][j];\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <vector>\nusing namespace std;\n#define foreach(i,v) for(int i=0;i<(int)v.size();i++)\n\nconst int N=55;\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\nchar mz[N][N];\nint con[N][N],on[N][N],off[N][N];\nint pre[N][N],dis[N][N];\nint tl[N*N];\nstruct point\n{\n    int x,y;\n    point(){}\n    point(int _x,int _y)\n    :x(_x),y(_y){}\n};\npoint task[1010];\nvector<int> load;\nqueue<point> q;\nint n,m;\nint T=0;\nvoid bfs(int sx,int sy,int ex,int ey)\n{\n    while(!q.empty()) q.pop();\n    memset(pre,-1,sizeof(pre));\n    memset(dis,-1,sizeof(dis));\n    dis[sx][sy]=0;\n    q.push(point(sx,sy));\n    while(!q.empty())\n    {\n        point u=q.front(); q.pop();\n        int x=u.x, y=u.y;\n        if(x==ex && y==ey) break;\n        for(int d=0;d<4;d++)\n        {\n            int nx=x+dx[d], ny=y+dy[d];\n            if(nx<0 || nx>=n || ny<0 || ny>=m) continue;\n            if(dis[nx][ny]!=-1 || mz[nx][ny]=='#') continue;\n            dis[nx][ny]=dis[x][y]+1;\n            pre[nx][ny]=x*m+y;\n            q.push(point(nx,ny));\n        }\n    }\n    int ntl=0;\n    for(int x=ex,y=ey;pre[x][y]!=-1;)\n    {\n        int t=pre[x][y];\n        tl[ntl++]=t;\n        x=t/m; y=t%m;\n    }\n    for(int i=ntl-1;i>=0;i--) load.push_back(tl[i]);\n}\nint main()\n{\n    int q;\n    while(~scanf(\"%d%d%d\",&n,&m,&q))\n    {\n        for(int i=0;i<n;i++) scanf(\"%s\",mz[i]);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) scanf(\"%d\",&con[i][j]);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) scanf(\"%d\",&on[i][j]);\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++) scanf(\"%d\",&off[i][j]);\n        for(int i=0;i<q;i++) scanf(\"%d%d\",&task[i].x,&task[i].y);\n        load.clear();\n        for(int i=1;i<q;i++) bfs(task[i-1].x,task[i-1].y,task[i].x,task[i].y);\n        load.push_back(task[q-1].x*m+task[q-1].y);\n        memset(pre,-1,sizeof(pre));\n        int ans=0;\n        foreach(i,load)\n        {\n            int l=load[i];\n            int x=l/m, y=l%m;\n            if(pre[x][y]==-1)\n            {\n                ans+=on[x][y];\n                ans+=off[x][y];\n            }\n            else\n            {\n                int tmp=(i-pre[x][y])*con[x][y];\n                tmp=min(on[x][y]+off[x][y],tmp);\n                ans+=tmp;\n            }\n            pre[x][y]=i;\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF INT_MAX/2\n\ntypedef vector<string> vs;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef tuple<int, int, int> tiii; // node, cost, parent\ntypedef long long ll;\n\nstruct Comp\n{\n\tbool operator() (tiii a, tiii b)\n\t{\n\t\treturn get<1>(a) > get<1>(b);\n\t}\n};\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { -1, 0, 1, 0 };\n\nint find_index(vector<int> a, int x)\n{\n\tif (a.size() == 0) return -1;\n\n\tint l = 0;\n\tint r = a.size();\n\twhile (l + 1 != r)\n\t{\n\t\tint mid = (l + r) / 2;\n\t\tif (a[mid] <= x)\n\t\t\tl = mid;\n\t\telse\n\t\t\tr = mid;\n\t}\n\tif (a[l] == x)\n\t\treturn l;\n\telse\n\t\treturn -1;\n}\n\nint main()\n{\n\tint R, C, M; cin >> R >> C >> M;\n\n\tvs grids(R);\n\trep(y, 0, R) cin >> grids[y];\n\n\tvvi consume(R, vi(C, 0));\n\trep(y, 0, R) rep(x, 0, C) cin >> consume[y][x];\n\n\tvvi turnon(R, vi(C, 0));\n\trep(y, 0, R) rep(x, 0, C) cin >> turnon[y][x];\n\n\tvvi turnoff(R, vi(C, 0));\n\trep(y, 0, R) rep(x, 0, C) cin >> turnoff[y][x];\n\n\n\n\tvi order;\n\tint _x, _y; cin >> _y >> _x;\n\tint bak = _y * C + _x;\n\torder.push_back(bak);\n\trep(_m, 1, M)\n\t{\n\t\tint y, x; cin >> y >> x;\n\t\tint s = y * C + x;\n\n\t\tvi dist(R*C, INF);\n\t\tvi back(R*C, -INF);\n\t\tpriority_queue<tiii, vector<tiii>, Comp> que;\n\t\tque.push(tiii(bak, 0, -1));\n\t\tdist[bak] = 0;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\ttiii t = que.top(); que.pop();\n\n\t\t\tint node = get<0>(t);\n\t\t\tint cost = get<1>(t);\n\n\t\t\tif (back[node] != -INF) continue;\n\t\t\tback[node] = get<2>(t);\n\n\t\t\tif (node == s) break;\n\n\t\t\trep(i, 0, 4)\n\t\t\t{\n\t\t\t\tint xx = (node % C) + dx[i];\n\t\t\t\tint yy = (node / C) + dy[i];\n\n\t\t\t\tif (xx < 0 || C <= xx) continue;\n\t\t\t\tif (yy < 0 || R <= yy) continue;\n\t\t\t\tif (grids[yy][xx] == '#') continue;\n\n\t\t\t\tint ss = yy * C + xx;\n\n\t\t\t\tif (cost + 1 < dist[ss])\n\t\t\t\t{\n\t\t\t\t\tdist[ss] = cost + 1;\n\t\t\t\t\tque.push(tiii(ss, cost + 1, node));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvi tmp;\n\t\tint to = s;\n\t\twhile (0 <= to)\n\t\t{\n\t\t\ttmp.push_back(to);\n\t\t\tto = back[to];\n\t\t}\n\t\trep(i, 1, tmp.size()) order.push_back(tmp[tmp.size() - 1 - i]);\n\n\t\tbak = s;\n\t}\n\n\n\n\tvvi list(R*C);\n\trep(i, 0, order.size()) list[order[i]].push_back(i);\n\n\tll ans = 0;\n\n\tvi onoff(R*C, 0);\n\tll pluscost = 0;\n\trep(i, 0, order.size())\n\t{\n\t\tif (i != 0) ans += pluscost;\n\n\t\tint node = order[i];\n\t\tint y = node / C;\n\t\tint x = node % C;\n\n\t\tif (onoff[node] == 0) ans += (ll)turnon[y][x];\n\n\t\tint index = find_index(list[node], i);\n\n\t\tif (list[node].size() - 1 == index)\n\t\t{\n\t\t\t// last\n\t\t\tans += (ll)turnoff[y][x];\n\t\t\tif (onoff[node] == 1) pluscost -= (ll)consume[y][x];\n\t\t\tonoff[node] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (consume[y][x] * (list[node][index + 1] - list[node][index]) < turnon[y][x] + turnoff[y][x])\n\t\t{\n\t\t\t// tukeppa\n\t\t\tif (onoff[node] == 0) pluscost += (ll)consume[y][x];\n\t\t\tonoff[node] = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans += (ll)turnoff[y][x];\n\t\t\tif (onoff[node] == 1) pluscost -= (ll)consume[y][x];\n\t\t\tonoff[node] = 0;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <functional>\n#include <utility>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nstruct node\n{\n    int x, y;\n};\n\nconst int inf = 0x3f3f3f3f;\n\nchar s[60][60];\nint l[60][60];\nint k[60][60];\nint g[60][60];\nint rx[1010], ry[1010];\nint vis[60][60];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint r, c, m;\nint mx, my;\nvector <node> a;\nvector <node> z;\n\nint dfs(int x, int y, int fx, int fy)\n{\n    if(x == mx && y == my)\n        return 1;\n    for(int i = 0; i < 4; i++)\n    {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(nx < 0 || nx >= r || ny < 0 || ny >= c || s[nx][ny] == '#')\n            continue;\n        if(nx == fx && ny == fy)\n            continue;\n        if(dfs(nx, ny, x, y) == 1)\n        {\n            node xin;\n            xin.x = nx, xin.y = ny;\n            a.push_back(xin);\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d%d\", &r, &c, &m))\n    {\n        memset(vis, -1, sizeof(vis));\n        for(int i = 0; i < r; i++)\n            scanf(\"%s\", s[i]);\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < c; j++)\n                scanf(\"%d\", &l[i][j]);\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < c; j++)\n                scanf(\"%d\", &k[i][j]);\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < c; j++)\n                scanf(\"%d\", &g[i][j]);\n        for(int i = 0; i < m; i++)\n            scanf(\"%d%d\", &rx[i], &ry[i]);\n        z.clear();\n        node qi;\n        qi.x = rx[0], qi.y = ry[0];\n        z.push_back(qi);\n        for(int i = 1; i < m; i++)\n        {\n            a.clear();\n            if(rx[i] == rx[i - 1] && ry[i] == ry[i - 1])\n                continue;\n            mx = rx[i], my = ry[i];\n            dfs(rx[i - 1], ry[i - 1], -1, -1);\n            for(int j = a.size() - 1; j >= 0; j--)\n            {\n                node aa = a[j];\n                z.push_back(aa);\n            }\n        }\n//        printf(\"\\n\\n\");\n//        for(int i = 0; i < z.size(); i++)\n//        {\n//            printf(\"%d %d\\n\", z[i].x, z[i].y);\n//        }\n        long long sum = 0;\n        int i;\n        for(i = 0; i < z.size(); i++)\n        {\n            int nx = z[i].x;\n            int ny = z[i].y;\n            sum += k[nx][ny] + g[nx][ny];\n            //cout << sum << endl;\n            if(vis[nx][ny] == -1)\n            {\n                vis[nx][ny] = i;\n                continue;\n            }\n            if((long long)(i - vis[nx][ny]) * l[nx][ny] <  k[nx][ny] + g[nx][ny])\n            {\n               // printf(\"%d\\n\", (k[nx][ny] + g[nx][ny]) - (i - vis[nx][ny) * l[nx][ny]);\n                sum -= (k[nx][ny] + g[nx][ny]) - (i - vis[nx][ny]) * l[nx][ny];\n            }\n            //printf(\"\\n\");\n            vis[nx][ny] = i;\n        }\n        //sum += g[rx[i]][ry[i]];\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nint dr[]={1,0,-1,0};\nint dc[]={0,1,0,-1};\nusing ll=long long;\nconst ll INF=1e9;\nint main(){\n    int r,c,m;\n    cin>>r>>c>>m;\n    vector<string> f(r);\n    for(int i=0;i<r;i++) cin>>f[i];\n    vector<ll> keep(r*c);\n    vector<ll> on(r*c);\n    vector<ll> off(r*c);\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>keep[i*c+j];\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>on[i*c+j];\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>off[i*c+j];\n    vector<int> task(m);\n    for(int i=0;i<m;i++){\n        int x,y;\n        cin>>x>>y;\n        task[i]=x*c+y;\n    }\n    auto vertex=[&](int i,int j){\n        return i*c+j;\n    };\n    int n=r*c;\n    Graph g(n);\n    for(int i=0;i<r;i++){\n        for(int j=0;j<c;j++){\n            if(f[i][j]=='#') continue;\n            for(int k=0;k<4;k++){\n                int tor=i+dr[k],toc=j+dc[k];\n                if(0<=tor && tor<r && 0<=toc && toc<c && f[tor][toc]=='.'){\n                    g[vertex(i,j)].push_back(vertex(tor,toc));\n                }\n            }\n        }\n    }\n    vector<vector<int>> route(n,vector<int>(n));\n\n    function<void(int,int,vector<int>&,int)> dfs=[&](int v,int pre,vector<int>& vec,int org){\n        if(v!=org){\n            vec.push_back(v);\n            route[org][v]=vec[0];\n        }\n        for(auto &to:g[v]){\n            if(pre!=to) dfs(to,v,vec,org);\n        }\n        vec.pop_back();\n    };\n    for(int i=0;i<r;i++){\n        for(int j=0;j<c;j++){\n            if(f[i][j]=='#') continue;\n            int v=vertex(i,j);\n            vector<int> vec;\n            dfs(v,-1,vec,v);\n        }\n    }\n    vector<ll> t(n,-INF);\n    ll syst=0;\n    ll res=on[task[0]]+off[task[0]];\n    t[0]=syst++;\n    for(int i=0;i+1<m;i++){\n        int v=task[i];\n        while(v!=task[i+1]){\n            int to=route[v][task[i+1]];\n            if(t[to]==-INF) res+=on[to]+off[to];\n            else res+=min(on[to]+off[to],(syst-t[to])*keep[to]);\n            t[to]=syst++;\n            v=to;\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\nusing ll=long long;\n\nconst int inf =1 << 16;\nconst ll mod=1000000007LL;\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nstring field[55];\nvector<int> cur;\n\nint dist[55][55],prv[55][55][2];\t\n\n\nvoid bfs(int r,int c,int sr,int sc,int tr,int tc){\n\trep(i,55)rep(j,55) dist[i][j]=inf,prv[i][j][0]=prv[i][j][1]=-1;\n\tqueue<int> q;\n\tdist[sr][sc]=0,q.push(sr),q.push(sc);\n\twhile(!q.empty()){\n\t\tint cr=q.front();q.pop();\n\t\tint cc=q.front();q.pop();\n\t\trep(i,4){\n\t\t\tint nr=cr+dx[i],nc=cc+dy[i];\n\t\t\tif(nr<0||r<=nr||nc<0||c<=nc) continue;\n\t\t\tif(field[nr][nc]=='#' ) continue;\n\t\t\tif(chmin(dist[nr][nc],dist[cr][cc]+1)){\n\t\t\t\tq.push(nr),q.push(nc);\n\t\t\t\tprv[nr][nc][0]=cr;\n\t\t\t\tprv[nr][nc][1]=cc;\n\t\t\t}\n\t\t}\n\t}\n\n\tint cr=tr,cc=tc;\n\tvector<int> tmp;\n\twhile(1){\n\t\tif(prv[cr][cc][0]==-1) break;\n\t\ttmp.push_back(cr*c+cc);\n\t\tint nr=prv[cr][cc][0];\n\t\tint nc=prv[cr][cc][1];\n\t\tswap(cr,nr),swap(cc,nc);\n\t}\n\treverse(_all(tmp));\n\tcopy(_all(tmp),back_inserter(cur));\n\treturn;\n}\n\nll per[55][55],on[55][55],off[55][55];\nll num[2510];\n\nint main(void){\n\tint r,c,m;\n\tcin >> r >> c >> m;\n\trep(i,r) cin >> field[i];\n \trep(i,r)rep(j,c) cin >> per[i][j];\n\trep(i,r)rep(j,c) cin >> on[i][j];\n\trep(i,r)rep(j,c) cin >> off[i][j];\n\t\n\tint pr=-1,pc=-1;\n\trep(i,m){\n\t\tint cr,cc;\n\t\tcin >> cr >> cc;\n\t\tif(pr==-1&&pc==-1) \n\t\t\tcur.push_back(cr*c+cc);\n\t\telse\n\t\t\tbfs(r,c,pr,pc,cr,cc);\n\t\tswap(cr,pr),swap(cc,pc);\n\t}\n\n\tint n=cur.size();\n\tvector<int> tmp(n,0);\n\tclr(num,-1);\n\t\n\trrep(i,n){\n\t\ttmp[i]=num[cur[i]];\n\t\tnum[cur[i]]=i;\n\t//\tcerr << tmp[i] << \" \" << num[cur[i]] << endl;\t\n\t}\n\n\tll ans=0LL;\n\trep(i,n){\n\t\tint cr=cur[i]/c,cc=cur[i]%c;\n\t\t// cerr << i << \" \" << cr << \" \" << cc << \" \" << tmp[i] << endl;\n\t\tif(tmp[i]!=-1)\n\t\t\tans+=min(per[cr][cc]*(tmp[i]-i),on[cr][cc]+off[cr][cc]);\n\t\telse\n\t\t\tans+=on[cr][cc]+off[cr][cc];\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint counter = 0;\n\nvoid bfs(vector<vector<vector<int> > >& stamps, const vector<string>& grid, const pair<int,int>& start, const pair<int,int>& goal)\n{\n  const int R = grid.size(), C = grid[0].size();\n  queue<pair<int,int> > q;\n  q.push(start);\n  vector<vector<int> > prev(R, vector<int>(C, -1));\n  while (!q.empty()) {\n    if (q.front() == goal) {\n      break;\n    }\n    const int i = q.front().first;\n    const int j = q.front().second;\n    q.pop();\n\n    for (int d = 0; d < 4; d++) {\n      static const int di[] = {1, -1, 0, 0};\n      static const int dj[] = {0, 0, 1, -1};\n      const int k = i + di[d], l = j + dj[d];\n      if (0 <= k && k < R && 0 <= l && l < C && grid[k][l] == '.' && prev[k][l] == -1) {\n        prev[k][l] = i*C + j;\n        q.push(make_pair(k, l));\n      }\n    }\n  }\n  vector<pair<int,int> > path;\n  for (pair<int,int> pos = goal; pos != start;) {\n    path.push_back(pos);\n    const int p = prev[pos.first][pos.second];\n    pos.first = p/C;\n    pos.second = p%C;\n  }\n  for (vector<pair<int,int> >::reverse_iterator it = path.rbegin(); it != path.rend(); ++it) {\n    stamps[it->first][it->second].push_back(counter++);\n  }\n}\n\nint main()\n{\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> grid(R);\n  for (int i = 0; i < R; i++) {\n    cin >> grid[i];\n  }\n  static int keep_costs[50][50], on_costs[50][50], off_costs[50][50];\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      cin >> keep_costs[i][j];\n    }\n  }\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      cin >> on_costs[i][j];\n    }\n  }\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      cin >> off_costs[i][j];\n    }\n  }\n  static pair<int,int> rooms[1000];\n  for (int i = 0; i < M; i++) {\n    cin >> rooms[i].first >> rooms[i].second;\n  }\n\n  vector<vector<vector<int> > > stamps(R, vector<vector<int> >(C));\n  stamps[rooms[0].first][rooms[0].second].push_back(counter++);\n  for (int i = 0; i < M-1; i++) {\n    bfs(stamps, grid, rooms[i], rooms[i+1]);\n  }\n  int ans = 0;\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      const vector<int>& s = stamps[i][j];\n      if (!s.empty()) {\n        const int keep = keep_costs[i][j];\n        const int on = on_costs[i][j];\n        const int off = off_costs[i][j];\n        ans += on;\n        for (vector<int>::const_iterator it = s.begin(); it+1 != s.end(); ++it) {\n          ans += min(off + on, keep*(*(it+1) - *it));\n        }\n        ans += off;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint R, C, M;\nstring field[50];\nbool visited[50][50];\n\nbool dfs(int px, int py, int gx, int gy, vector<int>& res)\n{\n\t\n\tif(visited[px][py]) return false;\n\tvisited[px][py] = true;\n\n\n\tif(px == gx && py == gy){\n\t\treturn true;\n\t}\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint tx = px + dx[i];\n\t\tint ty = py + dy[i];\n\n\t\tif(tx < 0 || ty < 0 || tx >= C || ty >= R) continue;\n\t\tif(field[ty][tx] == '#') continue; \n\n\t\tif(dfs(tx,ty,gx,gy,res)) {\n\t\t\tres.push_back(ty*50+tx);\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\treturn false;\n\t\n}\n\nint main()\n{\n\tcin >> R >> C >> M;\n\n\tfor(int i=0; i<R; i++)\n\t\tcin >> field[i];\n\n\tint upkeep[50][50], oncost[50][50], offcost[50][50];\n\tint objx[1000], objy[1000];\n\n\tfor(int i=0; i<R; i++)\n\tfor(int j=0; j<C; j++)\n\t\tcin >> upkeep[j][i];\n\n\tfor(int i=0; i<R; i++)\n\tfor(int j=0; j<C; j++)\n\t\tcin >> oncost[j][i];\n\n\tfor(int i=0; i<R; i++)\n\tfor(int j=0; j<C; j++)\n\t\tcin >> offcost[j][i];\n\n\tfor(int i=0; i<M; i++)\n\t\tcin >> objy[i] >> objx[i];\n\n\tint cost=0;\n\tvector<vector<int> > route(50*50);\n\troute[objy[0]*50+objx[0]].push_back(cost++);\n\n\tfor(int i=0; i<M-1; i++) {\n\t\tvector<int> r; \n\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tdfs(objx[i], objy[i], objx[i+1], objy[i+1], r);\n\n\t\treverse(r.begin(), r.end());\n\n\t\tfor(int j=0; j<r.size(); j++) {\n\t\t\tint a = r[j];\n\n\t\t\troute[a].push_back(cost++);\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor(int i=0; i<2500; i++) {\n\t\tint x = (i % 50);\n\t\tint y = (i / 50);\n\n\t\tfor(int j=0; j<route[i].size(); j++) {\n\t\t\tif(j+1 == route[i].size()) {\n\n\t\t\t\tres += offcost[x][y];\n\t\t\t\tif(route[i].size() == 1) res += oncost[x][y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(j==0) res += oncost[x][y];\n\n\t\t\t\tint diff = route[i][j+1] - route[i][j];\t\n\t\t\t\tres += min(diff*upkeep[x][y], offcost[x][y] + oncost[x][y]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\n\nint main(){\n  int H, W, M;\n  while(cin>>H>>W>>M){\n    vector<string> grid(H);\n    REP(i, H) cin>>grid[i];\n    int c_mt[50][50];\n    int c_on[50][50];\n    int c_of[50][50];\n    REP(y, H)REP(x, W) cin>>c_mt[y][x];\n    REP(y, H)REP(x, W) cin>>c_on[y][x];\n    REP(y, H)REP(x, W) cin>>c_of[y][x];\n    vector<int> cx, cy;\n    REP(i, M){\n      int y, x; cin>>y>>x;\n      cx.push_back(x); cy.push_back(y);\n    }\n    vector<int> time[50][50];\n    time[cy[0]][cx[0]].push_back(0);\n    int now = 0;\n    REP(i, M - 1){\n      const P null = P(-1, -1);\n      P prev[50][50];\n      REP(y, H)REP(x, W) prev[y][x] = null;\n      queue<int> qx, qy;\n      qx.push(cx[i]); qy.push(cy[i]);\n      while(!qx.empty()){\n        int x = qx.front(); qx.pop();\n        int y = qy.front(); qy.pop();\n        REP(r, 4){\n          int nx = x + dx[r];\n          int ny = y + dy[r];\n          if(valid(nx, ny, W, H) && prev[ny][nx] == null && grid[ny][nx] != '#'){\n            prev[ny][nx] = P(x, y);\n            qx.push(nx); qy.push(ny);\n          }\n        }\n      }\n      prev[cy[i]][cx[i]] = null;\n      vector<P> path;\n      P cur = P(cx[i + 1], cy[i + 1]);\n      while(cur != null){\n        path.push_back(cur);\n        cur = prev[cur.second][cur.first];\n      }\n      reverse(path.begin(), path.end());\n      FOR(i, 1, path.size()){\n        int x = path[i].first, y = path[i].second;\n        int t = now + i;\n        time[y][x].push_back(t);\n      }\n      now += path.size() - 1;\n    }\n    ll ans = 0;\n    REP(y, H)REP(x, W){\n      if(time[y][x].empty()) continue;\n      int T = time[y][x].size();\n      ll dp[1010][2] = {};\n      REP(i, T) dp[i][0] = dp[i][1] = (ll)1e16;\n      dp[0][0] = c_on[y][x] + c_of[y][x];\n      dp[0][1] = c_on[y][x];\n      FOR(i, 1, T){\n        int cur = min(dp[i - 1][0] + c_on[y][x], dp[i - 1][1] + (ll)c_mt[y][x] * (time[y][x][i] - time[y][x][i - 1]));\n        dp[i][0] = cur + c_of[y][x];\n        dp[i][1] = cur;\n      }\n      //printf(\"x = %d y = %d m = %lld\\n\", x, y, dp[T-1][0]);\n      ans += dp[T - 1][0];\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[2] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {+0,+1,+0,-1};\nconst static int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint W,H;\nbool visited[51][51];\nchar stage[51][51];\nvector<P> dfs(int sx,int sy,int gx,int gy,\n              vector<P>& route){\n\n  vector<P> res;\n  for(int i=0;i<4;i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    // if(visited[dy][dx]) continue;\n    if(stage[dy][dx] == '#') continue;\n\n    if(dx == gx && dy == gy){\n      route.push_back(P(dx,dy));\n      res = route;\n      return res;\n    }\n\n    // visited[dy][dx] = true;\n    route.push_back(P(dx,dy));\n\n    vector<P> tmp = dfs(dx,dy,gx,gy,route);\n    if(tmp.size() > 0){\n      res = tmp;\n    }\n\n    // visited[dy][dx] = false;\n    route.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  int task_rooms;\n  while(~scanf(\"%d %d %d\",&H,&W,&task_rooms)){\n    int consumption_per_unit[51][51];\n    int turn_off_cost[51][51];\n    int turn_on_cost[51][51];\n\n\n    for(int y = 0; y < H; y++){\n      char buf[51];\n      scanf(\"%s\",buf);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = buf[x];\n      }\n    }\n    \n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&consumption_per_unit[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_off_cost[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_on_cost[y][x]);\n      }\n    }\n\n    vector<P> points;\n    for(int task_i = 0; task_i < task_rooms; task_i++){\n      int y,x;\n      scanf(\"%d %d\",&y,&x);\n      points.push_back(P(x,y));\n    }\n\n\n    int latest_time = 0;\n    int prev_x = -1;\n    int prev_y = -1;\n\n    vector<int> move_log[51][51];\n    for(int task_i = 0; task_i + 1 < task_rooms; task_i++){\n      int sx = points[task_i].first;\n      int sy = points[task_i].second;\n\n      int gx = points[task_i+1].first;\n      int gy = points[task_i+1].second;\n\n      memset(visited,false,sizeof(visited));\n      visited[sy][sx] = true;\n      vector<P> route;\n      route.push_back(P(sx,sy));\n      route = dfs(sx,sy,gx,gy,route);\n\n      for(int i=0; i< route.size();i++){\n        int x = route[i].first;\n        int y = route[i].second;\n\n        if(x == prev_x && y == prev_y) continue;\n        \n        move_log[y][x].push_back(latest_time);\n        latest_time++;\n\n        prev_x = x;\n        prev_y = y;\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        res += turn_on_cost[y][x];\n        for(int i = 0; i + 1< move_log[y][x].size(); i++){\n          int duration = move_log[y][x][i+1] - move_log[y][x][i] ;\n          res += min(turn_off_cost[y][x] + turn_on_cost[y][x],\n                     consumption_per_unit[y][x] * duration);\n        }\n        res += turn_off_cost[y][x];\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint R, C;\nstring a[50];\nint b[50][50][3];\nint r[1000], c[1000];\nvector<int> v[50][50];\nbool vis[50][50];\n\nbool dfs(int& t, int x, int y, int xt, int yt) {\n\tvis[y][x] = true;\n\tif (x == xt && y == yt)\n\t\treturn true;\n\tfor (int k = 0; k < 4; k++) {\n\t\tint _x = x + dx[k], _y = y + dy[k];\n\t\tif (_x < 0 || _x >= C || _y < 0 || _y >= R || a[_y][_x] == '#' || vis[_y][_x])\n\t\t\tcontinue;\n\t\tif (dfs(t, _x, _y, xt, yt)) {\n\t\t\tv[_y][_x].push_back(t++);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tint M; cin >> R >> C >> M;\n\tfor (int y = 0; y < R; y++)\n\t\tcin >> a[y];\n\tfor (int k = 0; k < 3; k++)\n\t\tfor (int y = 0; y < R; y++)\n\t\t\tfor (int x = 0; x < C; x++)\n\t\t\t\tcin >> b[y][x][k];\n\tfor (int i = 0; i < M; i++)\n\t\tcin >> r[i] >> c[i];\n\tint t = 0;\n\tfor (int i = 0; i + 1 < M; i++) {\n\t\tfill(vis[0], vis[0] + 50 * 50, false);\n\t\tdfs(t, c[i + 1], r[i + 1], c[i], r[i]);\n\t\tv[r[i + 1]][c[i + 1]].push_back(t);\n\t}\n\tint sum = 0;\n\tfor (int y = 0; y < R; y++)\n\t\tfor (int x = 0; x < C; x++) {\n\t\t\tif (v[y][x].empty()) continue;\n\t\t\tsum += b[y][x][1] + b[y][x][2];\n\t\t\tfor (int j = 0; j + 1 < v[y][x].size(); j++) {\n\t\t\t\tint dt = v[y][x][j + 1] - v[y][x][j];\n\t\t\t\tsum += min(b[y][x][0] * dt, b[y][x][1] + b[y][x][2]);\n\t\t\t}\n\t\t}\n\tcout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {+0,+1,+0,-1};\nconst static int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint W,H;\nbool visited[51][51];\nchar stage[51][51];\nvector<P> dfs(int sx,int sy,int gx,int gy,\n              vector<P>& route){\n\n  vector<P> res;\n  for(int i=0;i<4;i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(visited[dy][dx]) continue;\n    if(stage[dy][dx] == '#') continue;\n\n    if(dx == gx && dy == gy){\n      route.push_back(P(dx,dy));\n      res = route;\n      return res;\n    }\n\n    visited[dy][dx] = true;\n    route.push_back(P(dx,dy));\n\n    vector<P> tmp = dfs(dx,dy,gx,gy,route);\n    if(tmp.size() > 0){\n      res = tmp;\n    }\n\n    visited[dy][dx] = false;\n    route.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  int task_rooms;\n  while(~scanf(\"%d %d %d\",&H,&W,&task_rooms)){\n    int consumption_per_unit[51][51];\n    int turn_off_cost[51][51];\n    int turn_on_cost[51][51];\n\n\n    for(int y = 0; y < H; y++){\n      char buf[51];\n      scanf(\"%s\",buf);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = buf[x];\n      }\n    }\n    \n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&consumption_per_unit[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_off_cost[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_on_cost[y][x]);\n      }\n    }\n\n    vector<P> points;\n    for(int task_i = 0; task_i < task_rooms; task_i++){\n      int y,x;\n      scanf(\"%d %d\",&y,&x);\n      points.push_back(P(x,y));\n    }\n\n\n    int latest_time = 0;\n    int prev_x = -1;\n    int prev_y = -1;\n\n    vector<int> move_log[51][51];\n    for(int task_i = 0; task_i + 1 < task_rooms; task_i++){\n      int sx = points[task_i].first;\n      int sy = points[task_i].second;\n\n      int gx = points[task_i+1].first;\n      int gy = points[task_i+1].second;\n\n      memset(visited,false,sizeof(visited));\n      visited[sy][sx] = true;\n      vector<P> route;\n      route.push_back(P(sx,sy));\n      route = dfs(sx,sy,gx,gy,route);\n\n      for(int i=0; i< route.size();i++){\n        int x = route[i].first;\n        int y = route[i].second;\n\n        if(x == prev_x && y == prev_y) continue;\n        \n        move_log[y][x].push_back(latest_time);\n        latest_time++;\n\n        prev_x = x;\n        prev_y = y;\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        res += turn_on_cost[y][x];\n        for(int i = 0; i + 1< move_log[y][x].size(); i++){\n          int duration = move_log[y][x][i+1] - move_log[y][x][i] ;\n          res += min(turn_off_cost[y][x] + turn_on_cost[y][x],\n                     consumption_per_unit[y][x] * duration);\n        }\n        res += turn_off_cost[y][x];\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define WRAP(x,y,w,h) (0<=x && x<w && 0<=y && y<h)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<unsigned char, unsigned char> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\tvector<string> cell(h);\n\tREP(i, h)\n\t\tcin >> cell[i];\n\tvector<vvi> ele(3, vvi(h, vi(w)));\n\tREP(k, 3)\n\t\tREP(i, h)\n\t\tREP(j, w)\n\t\tcin >> ele[k][i][j];\n\tvector<pii> task(m);\n\tREP(i, m)\n\t\tcin >> task[i].first >> task[i].second;\n\tmap<pair<pii, pii>, pii> pre;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (cell[i][j] == '.') {\n\t\t\t\tpre[{ {i, j}, { i,j }}] = { i,j };\n\t\t\t\tqueue<pair<pii, pii>> Q;//now pre\n\t\t\t\tQ.push({ {i,j},{i,j} });\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tpair<pii, pii> q = Q.front();Q.pop();\n\t\t\t\t\tint ny = q.first.first;\n\t\t\t\t\tint nx = q.first.second;\n\t\t\t\t\tint py = q.second.first;\n\t\t\t\t\tint px = q.second.second;\n\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\tif (nx + dx[k] == px&&ny + dy[k] == py)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tif (WRAP(nx + dx[k], ny + dy[k], w, h)) {\n\t\t\t\t\t\t\tif (cell[ny + dy[k]][nx + dx[k]] == '.') {\n\t\t\t\t\t\t\t\tpre[{ {i, j}, { ny + dy[k],nx + dx[k] }}] = { ny,nx };\n\t\t\t\t\t\t\t\tQ.push({ { ny + dy[k],nx + dx[k] },{ny,nx} });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint time = 0;\n\tint idx = 0;\n\tpii now = task[0];\n\tvector<vvi> used(h, vvi(w));\n\twhile (1) {\n\t\tif (task[idx + 1] == now) {\n\t\t\tidx++;\n\t\t\tif (idx >= m - 1) {\n\t\t\t\tused[now.first][now.second].push_back(time);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tused[now.first][now.second].push_back(time);\n\t\ttime++;\n\t\tnow = pre[{task[idx + 1], now}];\n\t}\n\tint ans = 0;\n\tREP(i, h) {\n\t\tREP(j, w) {\n\t\t\tif (used[i][j].empty())\n\t\t\t\tcontinue;\n\t\t\tbool light = false;\n\t\t\tREP(k, used[i][j].size()) {\n\t\t\t\tif (!light) {\n\t\t\t\t\tans += ele[1][i][j];\n\t\t\t\t}\n\t\t\t\tif (k == used[i][j].size() - 1) {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((used[i][j][k + 1] - used[i][j][k])*ele[0][i][j] < ele[1][i][j] + ele[2][i][j]) {\n\t\t\t\t\tans += (used[i][j][k + 1] - used[i][j][k])*ele[0][i][j];\n\t\t\t\t\tlight = true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans += ele[2][i][j];\n\t\t\t\t\tlight = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 60, PMAX = 1010;\nconst int dl[] = {1, 0, -1, 0};\nconst int dc[] = {0, 1, 0, -1};\n\nint N, M, Q;\nchar A[NMAX][NMAX];\nint B[NMAX][NMAX];\nint C[NMAX][NMAX];\nint D[NMAX][NMAX];\nint Dist[NMAX][NMAX];\ndeque<int> E[NMAX][NMAX];\npair<int, int> from[NMAX][NMAX];\n\nvoid getPath(int startX, int startY, int finishX, int finishY, vector<pair<int, int>> &dest) {\n\tqueue<pair<int, int>> Q;\n\n\tbool witness[NMAX][NMAX] = {};\n\tQ.push({startX, startY});\n\twitness[startX][startY] = 1;\n\tDist[startX][startY] = 0;\n\twhile (!Q.empty()) {\n\t\tint currX, currY;\n\t\ttie(currX, currY) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint newX = currX + dl[i];\n\t\t\tint newY = currY + dc[i];\n\t\t\tif (newX < 0 || newX >= N || newY < 0 || newY >= M)\n\t\t\t\tcontinue;\n\t\t\tif (A[newX][newY] != '.' || witness[newX][newY])\n\t\t\t\tcontinue;\n\t\t\tfrom[newX][newY] = {currX, currY};\n\t\t\tDist[newX][newY] = Dist[currX][currY] + 1;\n\t\t\twitness[newX][newY] = 1;\n\t\t\tQ.push({newX, newY});\n\t\t\tif (newX == finishX && newY == finishY) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tint currX, currY;\n\ttie(currX, currY) = from[finishX][finishY];\n\tint newSize = dest.size() + Dist[currX][currY];\n\tdest.resize(newSize);\n\t--newSize;\n\twhile (currX != startX || currY != startY) {\n\t\tdest[newSize--] = {currX, currY};\n\t\ttie(currX, currY) = from[currX][currY];\n\t}\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tscanf(\"%d %d %d\", &N, &M, &Q);\n\tfor (i = 0; i < N; ++i)\n\t\tscanf(\"%s\", A[i]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &B[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &C[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &D[i][j]);\n\n\tvector<pair<int, int>> path;\n\tint lastX, lastY, currX, currY;\n\tscanf(\"%d %d\", &lastX, &lastY);\n\twhile (Q-- > 1) {\n\t\tscanf(\"%d %d\", &currX, &currY);\n\t\tpath.push_back({lastX, lastY});\n\t\tgetPath(lastX, lastY, currX, currY, path);\n\t\tlastX = currX, lastY = currY;\n\t}\n\tpath.push_back({lastX, lastY});\n\n//\tclock_t start = clock();\n\tfor (size_t i = 0; i < path.size(); ++i)\n\t\tE[path[i].first][path[i].second].push_back(i);\n//\tclock_t finish = clock();\n//\tcerr << double(finish - start) / CLOCKS_PER_SEC;\n\n\tbool lightOn[NMAX][NMAX] = {};\n\tint answer = 0;\n\tint currAdd = 0;\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tint x = path[i].first, y = path[i].second;\n\t\tint currLightOn = lightOn[x][y];\n\t\tint b = B[x][y];\n\t\tint c = C[x][y];\n\t\tint d = D[x][y];\n\t\tint cd = c + d;\n\t\tanswer += currAdd;\n\t\tif (!currLightOn)\n\t\t\tanswer += C[x][y];\n\t\tE[x][y].pop_front();\n\t\tint front = E[x][y].front();\n\t\tint size = E[x][y].size();\n\t\tif (currLightOn) {\n\t\t\tcurrAdd -= B[x][y];\n\t\t\tlightOn[x][y] = 0;\n\t\t\tanswer += D[x][y];\n\t\t} else if (!currLightOn && (front - i) * b < cd  && size){// && E[x][y].size() && (front - i) * b < cd) {\n\t\t\tcurrAdd += B[x][y];\n\t\t\tlightOn[x][y] = 1;\n\t\t}\n\t}\n\n\tcout << answer << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 50\nusing namespace std;\nint n,m,k;\nchar g[N][N];\nint p[N][N];\nint on[N][N];\nint off[N][N];\nint sb[N][N];\nbool vis[N][N];\nint sx,sy,gx,gy;\nconst int d1[4]={0,-1,0,1},d2[4]={1,0,-1,0};\nlong long ans;\nvoid input_matrix(int (*a)[N])\n{\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n        scanf(\"%d\",&a[i][j]);\n}\nvoid update(int x,int y,int cur)\n{\n    if(sb[x][y]==-1)\n           {\n               ans+=on[x][y];\n           }\n           else\n           {\n               long long  tmp1=(long long )p[x][y]*(cur-sb[x][y]),tmp2=off[x][y]+on[x][y];\n               ans+=tmp1>tmp2?tmp2:tmp1;\n           }\n           sb[x][y]=cur;\n}\nbool dfs(int x,int y,int cur)\n{\n  vis[x][y]=1;\n  if(x==gx&&y==gy)\n  {\n    update(x,y,cur);\n    return true;\n  }\n  for(int i=0;i<4;i++)\n  {\n      int tmpx=x+d1[i],tmpy=y+d2[i];\n      if(tmpx<n&&tmpx>=0&&tmpy<m&&tmpy>=0&&!vis[tmpx][tmpy]&&g[tmpx][tmpy]=='.'&&dfs(tmpx,tmpy,cur+1))\n      {\n           update(x,y,cur);\n           return true;\n      }\n  }\n  return false;\n}\nint main()\n{\n//    cout << \"Hello world!\" << endl;\n    while(scanf(\"%d%d%d\",&n,&m,&k)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n            scanf(\"%s\",g[i]);\n        input_matrix(p);\n        input_matrix(on);\n        input_matrix(off);\n        memset(sb,-1,sizeof(sb));\n        ans=0;\n        scanf(\"%d%d\",&sx,&sy);\n        int i=1;\n        while(i<k)\n        {\n            memset(vis,0,sizeof(vis));\n            scanf(\"%d%d\",&gx,&gy);\n            int tmp=sb[sx][sy]==-1?0:sb[sx][sy];\n            dfs(sx,sy,tmp);\n            sx=gx;\n            sy=gy;\n            i++;\n        }\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n              if(sb[i][j]!=-1)\n              ans+=off[i][j];\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 55\nusing namespace std;\nint n,m,k;\nchar g[N][N];\nint p[N][N];\nint on[N][N];\nint off[N][N];\nint sb[N][N];\nbool vis[N][N];\nint sx,sy,gx,gy;\nconst int d1[4]={0,-1,0,1},d2[4]={1,0,-1,0};\nlong long ans;\nvoid input_matrix(int (*a)[N])\n{\n    for(int i=0;i<n;i++)\n      for(int j=0;j<m;j++)\n        scanf(\"%d\",&a[i][j]);\n}\nvoid update(int x,int y,int cur)\n{\n    if(sb[x][y]==-1)\n           {\n               ans+=on[x][y];\n           }\n           else\n           {\n               long long  tmp1=(long long )p[x][y]*(cur-sb[x][y]),tmp2=off[x][y]+on[x][y];\n               ans+=tmp1>tmp2?tmp2:tmp1;\n           }\n           sb[x][y]=cur;\n}\nbool dfs(int x,int y,int cur)\n{\n  vis[x][y]=1;\n  if(x==gx&&y==gy)\n  {\n    update(x,y,cur);\n    return true;\n  }\n  for(int i=0;i<4;i++)\n  {\n      int tmpx=x+d1[i],tmpy=y+d2[i];\n      if(tmpx<n&&tmpx>=0&&tmpy<m&&tmpy>=0&&!vis[tmpx][tmpy]&&g[tmpx][tmpy]=='.'&&dfs(tmpx,tmpy,cur+1))\n      {\n           update(x,y,cur);\n           return true;\n      }\n  }\n  return false;\n}\nint main()\n{\n//    cout << \"Hello world!\" << endl;\n    while(scanf(\"%d%d%d\",&n,&m,&k)!=EOF)\n    {\n        for(int i=0;i<n;i++)\n            scanf(\"%s\",g[i]);\n        input_matrix(p);\n        input_matrix(on);\n        input_matrix(off);\n        memset(sb,-1,sizeof(sb));\n        ans=0;\n        scanf(\"%d%d\",&sx,&sy);\n        int i=1;\n        while(i<k)\n        {\n            memset(vis,0,sizeof(vis));\n            scanf(\"%d%d\",&gx,&gy);\n            int tmp=sb[sx][sy]==-1?0:sb[sx][sy];\n            dfs(sx,sy,tmp);\n            sx=gx;\n            sy=gy;\n            i++;\n        }\n        for(int i=0;i<n;i++)\n            for(int j=0;j<m;j++)\n              if(sb[i][j]!=-1)\n              ans+=off[i][j];\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nint  dx[4]={1,0,-1,0};\nint  dy[4]={0,1,0,-1};\n\nclass Main{\npublic:\n\tvector<vector<bool>> passed;\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tREP(i,M){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tint res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//mid\n\t\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t\t}\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\n\nvp trail;\n\nint r,c,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nbool dfs(int cx,int cy,int tx,int ty,vp &t,vs &field,vvi &visited){\n\tvisited[cy][cx]=1;\n\tif(cx==tx&&cy==ty){\n\t\tREP(i,t.size()){\n\t\t\ttrail.push_back(t[i]);\n\t\t}\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint x=cx+dx[i],y=cy+dy[i];\n\t\tif(x<0||y<0||x>=c||y>=r||field[y][x]=='#'||visited[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tvp nt(t);\n\t\tnt.push_back(make_pair(y,x));\n\t\tif(dfs(x,y,tx,ty,nt,field,visited))return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>r>>c>>m;\n\tvs field(r);\n\tREP(i,r){\n\t\tcin>>field[i];\n\t}\n\tvvi con(r,vi(c));\n\tvvi on(r,vi(c));\n\tvvi off(r,vi(c));\n\n\tREP(i,r)REP(j,c){\n\t\tcin>>con[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>on[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>off[i][j];\n\t}\n\n\tvp tasks(m);\n\tREP(i,m){\n\t\tcin>>tasks[i].first>>tasks[i].second;\n\t}\n\n\n\tvvi last(r,vi(c,-1));\n\tint cost=0;\n\tint turn=0;\n\tFOR(i,1,m){\n\t\tvvi visited(r,vi(c));\n\t\tvp t;\n\t\tif(i==1){\n\t\t\tt.push_back(tasks[i-1]);\n\t\t}\n\t\tdfs(tasks[i-1].second,tasks[i-1].first,tasks[i].second,tasks[i].first,t,field,visited);\n\t\tREP(i,trail.size()){\n\t\t\tint y=trail[i].first,x=trail[i].second;\n\t\t\tif(last[y][x]==-1){\n\t\t\t\tcost+=on[y][x];\n\t\t\t}else if((turn-last[y][x])*con[y][x]<on[y][x]+off[y][x]){\n\t\t\t\tcost+=(turn-last[y][x])*con[y][x];\n\t\t\t}else{\n\t\t\t\tcost+=on[y][x]+off[y][x];\n\t\t\t}\n\t\t\tlast[y][x]=turn;\n\t\t\tturn++;\n\t\t}\n\t\ttrail.clear();\n\t}\n\tREP(y,r)REP(x,c){\n\t\tif(last[y][x]!=-1){\n\t\t\tcost+=off[y][x];\n\t\t}\n\t}\n\tcout<<cost<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint h,w;\nchar B[50][51];\n\nvector< pair<int,int> > get_path(int x0,int y0,int x1,int y1){\n\tbool vis[50][50]={};\n\tvis[y0][x0]=true;\n\tstatic pair<int,int> pre[50][50];\n\n\tint head=0,tail=0;\n\tstatic pair<int,int> Q[50*50];\n\tQ[tail++]=make_pair(y0,x0);\n\twhile(head<tail){\n\t\tint y=Q[head].first,x=Q[head].second; head++;\n\t\trep(k,4){\n\t\t\tint yy=y+dy[k],xx=x+dx[k];\n\t\t\tif(0<=yy && yy<h && 0<=xx && xx<w && B[yy][xx]=='.' && !vis[yy][xx]){\n\t\t\t\tvis[yy][xx]=true;\n\t\t\t\tQ[tail++]=make_pair(yy,xx);\n\t\t\t\tpre[yy][xx]=make_pair(y,x);\n\t\t\t}\n\t\t}\n\t}\n\n\tint y=y1,x=x1;\n\tvector< pair<int,int> > P(1,make_pair(y1,x1));\n\twhile(y!=y0 || x!=x0){\n\t\tpair<int,int> tmp=pre[y][x];\n\t\tP.push_back(tmp);\n\t\ty=tmp.first;\n\t\tx=tmp.second;\n\t}\n\treverse(P.begin(),P.end());\n\tP.pop_back();\n\treturn P;\n}\n\nint main(){\n\tint n; scanf(\"%d%d%d\",&h,&w,&n);\n\trep(i,h) scanf(\"%s\",B[i]);\n\tint left[50][50],on[50][50],off[50][50];\n\trep(i,h) rep(j,w) scanf(\"%d\",left[i]+j);\n\trep(i,h) rep(j,w) scanf(\"%d\",on[i]+j);\n\trep(i,h) rep(j,w) scanf(\"%d\",off[i]+j);\n\n\tvector<int> reach[50][50]; // reach[i][j] := ( マス (i,j) を通る時刻の列 )\n\tint t=0;\n\tint y0,x0; scanf(\"%d%d\",&y0,&x0);\n\trep(i,n-1){\n\t\tint y1,x1; scanf(\"%d%d\",&y1,&x1);\n\t\tvector< pair<int,int> > P=get_path(x0,y0,x1,y1);\n\t\trep(j,P.size()){\n\t\t\treach[P[j].first][P[j].second].push_back(t++);\n\t\t}\n\t\tx0=x1; y0=y1;\n\t}\n\treach[y0][x0].push_back(t++);\n\n\tint ans=0;\n\trep(i,h) rep(j,w) {\n\t\tint m=reach[i][j].size();\n\t\tif(m>0){\n\t\t\tans+=on[i][j];\n\t\t\trep(k,m-1){\n\t\t\t\tint d=reach[i][j][k+1]-reach[i][j][k];\n\t\t\t\tans+=min(off[i][j]+on[i][j],d*left[i][j]);\n\t\t\t}\n\t\t\tans+=off[i][j];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define foreach(i,c) for(auto i=(c).begin();i!=(c).end();++i)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w,m;cin>>h>>w>>m && h|w|m;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tvvi con(h,vi(w)),on=con,off=con;\n\t\trep(i,h) rep(j,w) cin>>con[i][j];\n\t\trep(i,h) rep(j,w) cin>>on[i][j];\n\t\trep(i,h) rep(j,w) cin>>off[i][j];\n\t\t\n\t\tvector<pii> order(m);\n\t\tfor(pii& p:order) cin>>p.first>>p.second;\n\t\t\n\t\tvector<pii> path(1,order[0]);\n\t\trep(o,m-1){\n\t\t\tvector<vector<pii>> prev(h,vector<pii>(w,mp(-1,-1)));\n\t\t\tprev[order[o].first][order[o].second];\n\t\t\tqueue<pii> q; q.push(order[o]);\n\t\t\twhile(q.size()){\n\t\t\t\tint ci,cj; tie(ci,cj)=q.front(); q.pop();\n\t\t\t\trep(k,4){\n\t\t\t\t\tint ni=ci+\"\\xff\\x1\\0\\0\"[k],nj=cj+\"\\0\\0\\xff\\x1\"[k];\n\t\t\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj\n\t\t\t\t\t|| grid[ni][nj]=='#' || prev[ni][nj]!=mp(-1,-1))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tprev[ni][nj]=mp(ci,cj);\n\t\t\t\t\tq.emplace(ni,nj);\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<pii> temp;\n\t\t\tfor(pii p=order[o+1];p!=order[o];p=prev[p.first][p.second])\n\t\t\t\ttemp.push_back(p);\n\t\t\treverse(all(temp));\n\t\t\tpath.insert(end(path),all(temp));\n\t\t}\n\t\t\n\t\tvvvi time(h,vvi(w));\n\t\trep(i,path.size()) time[path[i].first][path[i].second].push_back(i);\n\t\t\n\t\tint res=0;\n\t\trep(i,h) rep(j,w) if(time[i][j].size()){\n\t\t\tint tmp=on[i][j];\n\t\t\trep(k,time[i][j].size()-1){\n\t\t\t\tint t1=time[i][j][k],t2=time[i][j][k+1];\n\t\t\t\ttmp+=min(off[i][j]+on[i][j],con[i][j]*(t2-t1));\n\t\t\t}\n\t\t\ttmp+=off[i][j];\n\t\t\tres+=tmp;\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define M 1005\n#define N 51\nusing namespace std;\nint r,c,m,gy,gx,tim,ans;\nint cost[3][N][N];\nbool used[N][N];\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint d[N][N];\n\nvoid update(int y,int x,int t){\n  if(d[y][x]==-1)ans+=cost[1][y][x]+cost[2][y][x];\n  else ans+=min((t-d[y][x])*cost[0][y][x],\n\t\tcost[1][y][x]+cost[2][y][x]);\n  d[y][x]=t;\n}\n\nbool dfs(int y,int x,int t){\n  if(used[y][x])return false;\n  used[y][x]=true;\n  if(y==gy&&x==gx){\n    update(y,x,t);\n    tim=t;\n    return true;\n  }\n  bool res=false;\n  rep(i,4){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0||r<=ny||c<=nx)continue;\n    if(s[ny][nx]=='#')continue;\n    res|=dfs(ny,nx,t+1);\n  }\n  if(res)update(y,x,t);\n  return res;\n}\n\nint y[M],x[M];\n\nint main(){\n  cin>>r>>c>>m;\n  rep(i,r)cin>>s[i];\n  \n  rep(i,3)\n    rep(j,r)\n      rep(k,c)cin>>cost[i][j][k];\n  \n  rep(i,m)cin>>y[i]>>x[i];\n  \n  memset(d,-1,sizeof(d));\n\n  rep(i,m-1){\n    gy=y[i+1],gx=x[i+1];\n    memset(used,0,sizeof(used));\n    dfs(y[i],x[i],tim);\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\ntypedef vector<P> V;\ntypedef map<PP, V> Cache;\nconst int MAX_SIZE = 50;\nconst int MAX_TASK_SIZE = 1000;\n\nvector<P> dfs(char f[MAX_SIZE][MAX_SIZE], P src, P des, int R, int C) {\n  vector<P> v;\n  if (src == des) {\n    v.push_back(des);\n    return v;\n  }\n  f[src.first][src.second] = '@';\n  int dr[] = {-1, 1, 0, 0};\n  int dc[] = {0, 0, -1, 1};\n  for (int k = 0; k < 4; ++k) {\n    int i = src.first  + dr[k];\n    int j = src.second + dc[k];\n    if (i + 1 && j + 1 && i < R && j < C && f[i][j] == '.') {\n      v = dfs(f, P(i, j), des, R, C);\n      if (v.size()) {\n        v.insert(v.begin(), src);\n        break;\n      }\n    }\n  }\n  f[src.first][src.second] = '.';\n  return v;\n}\n\nint calc(int R, int C, int M, char f[][MAX_SIZE], int costs[][MAX_SIZE][MAX_SIZE], P tasks[]) {\n  Cache cache;\n  int p[MAX_SIZE][MAX_SIZE] = {};\n  int t = 0;\n  int i0 = tasks[0].first, j0 = tasks[0].second;\n  int a = costs[1][i0][j0] + costs[2][i0][j0];\n  p[i0][j0] = ++t;\n  for (int i = 0; i < M - 1; ++i) {\n    P src = tasks[i], des = tasks[i + 1];\n    V v;\n    Cache::iterator find = cache.find(PP(src, des));\n    if (find != cache.end()) {\n      v = find->second;\n    } else {\n      v = dfs(f, src, des, R, C);\n      cache.insert(pair<PP, V>(PP(src, des), v));\n    }\n    for (V::iterator vit = ++v.begin(); vit != v.end(); ++vit) {\n      ++t;\n      int r = vit->first, c = vit->second;\n      int prev = p[r][c];\n      int cost = costs[1][r][c] + costs[2][r][c];\n      a += cost;\n      if (prev) {\n        int d = (t - prev) * costs[0][r][c] - cost;\n        if (d < 0) a += d;\n      }\n      p[r][c] = t;\n    }\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  int R, C, M;\n  char f[MAX_SIZE][MAX_SIZE];\n  int costs[3][MAX_SIZE][MAX_SIZE];\n  P tasks[MAX_TASK_SIZE];\n  char s[MAX_SIZE + 1];\n  cin >> R >> C >> M;\n  for (int i = 0; i < R; ++i) {\n    cin >> s;\n    for (int j = 0; j < C; ++j) {\n      f[i][j] = s[j];\n    }\n  }\n  for (int k = 0; k < 3; ++k) {\n    for (int i = 0; i < R; ++i) {\n      for (int j = 0; j < C; ++j) {\n        cin >> n;\n        costs[k][i][j] = n;\n      }\n    }\n  }\n  for (int i = 0; i < M; ++i) {\n    int r, c;\n    cin >> r >> c;\n    tasks[i] = P(r, c);\n  }\n  cout << calc(R, C, M, f, costs, tasks) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,1,0,-1};\nint H,W,M;\nint sy,sx;\nchar t[50][50];\nint p[50][50];\nint q[50][50];\nint a[50][50];\nint b[50][50];\nint c[50][50];\nint g[50][50];\n\nvector<int> calc(int ay,int ax,int by,int bx){\n  vector<int> c,d;\n  while(ay!=by||ax!=bx){\n    if(q[ay][ax]>q[by][bx]){\n      int dir=p[ay][ax];\n      c.push_back(dir);\n      ay+=dy[dir];\n      ax+=dx[dir];\n    }else{\n      int dir=p[by][bx];\n      d.push_back(dir);\n      by+=dy[dir];\n      bx+=dx[dir];\n    }\n  }\n  reverse(d.begin(),d.end());\n  for(int i=0;i<(int)d.size();i++)c.push_back((d[i]+2)%4);\n  return c;\n}\n\nvoid rec(int y,int x,int z){\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0)continue;\n    if(ny>=H||nx>=W)continue;\n    if(t[ny][nx]=='#')continue;\n    if(p[ny][nx]==-1){\n      p[ny][nx]=(i+2)%4;\n      q[ny][nx]=z+1;\n      rec(ny,nx,z+1);\n    }\n  }\n}\n\nvoid init(){\n  sy=-1;\n  for(int i=0;i<50;i++){\n    for(int j=0;j<50;j++){\n      p[i][j]=-1;\n      g[i][j]=-1;\n    }\n  }\n}\n\nint main(){\n  cin>>H>>W>>M;\n  init();\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cin>>t[i][j];\n      if(t[i][j]=='.'&&sy==-1)sy=i,sx=j;\n    }\n  }\n  \n  p[sy][sx]=-2;\n  q[sy][sx]=0;\n  rec(sy,sx,0);\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>a[i][j];\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>b[i][j];\n  for(int i=0;i<H;i++)for(int j=0;j<W;j++)cin>>c[i][j];  \n  int ay,ax,by,bx,cnt=0,ans=0;\n  cin>>by>>bx;\n  for(int i=0;i<M-1;i++){\n    ay=by;ax=bx;\n    cin>>by>>bx;\n    vector<int> v=calc(ay,ax,by,bx);\n    for(int j=0;j<(int)v.size();j++){\n      if(g[ay][ax]==-1){\n        ans+=b[ay][ax]+c[ay][ax];\n      }else{\n        int A=b[ay][ax]+c[ay][ax];\n        int d=cnt-g[ay][ax];\n        int B=d*a[ay][ax];\n        ans+=min(A,B);\n      }\n      g[ay][ax]=cnt;\n      ay+=dy[v[j]];\n      ax+=dx[v[j]];\n      cnt++;\n    }\n  }\n  if(g[ay][ax]==-1){\n    ans+=b[ay][ax]+c[ay][ax];\n  }else{\n    int A=b[ay][ax]+c[ay][ax];\n    int d=cnt-g[ay][ax];\n    int B=d*a[ay][ax];\n    ans+=min(A,B);\n  }\n \n  cout<<ans<<endl;\n\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\nint  dx[]={1,0,-1,0};\nint  dy[]={0,1,0,-1};\n\nstruct Task{\n\tint y,x;int t;\n\tTask(int y,int x,int t):y(y),x(x),t(t){};\n};\n\nclass Main{\npublic:\n\n\n\n\tvector<vector<bool>> passed;\n\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tqueue<Task> que;\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tREP(i,M){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tint res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//mid\n\t\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t\t}\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\n\tios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// #define double long double\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-6;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nbool inside(int x, int y, int H, int W) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int H, W, m;\n    cin >> H >> W >> m;\n    vector<string> s(H);\n    rep(i, H) cin >> s[i];\n    vvi power(H, vi(W));\n    rep(i, H) rep(j, W) cin >> power[i][j];\n    vvi on(H, vi(W));\n    rep(i, H) rep(j, W) cin >> on[i][j];\n    vvi off(H, vi(W));\n    rep(i, H) rep(j, W) cin >> off[i][j];\n    vector<Pii> task(m);\n    rep(i, m) cin >> task[i].first >> task[i].second;\n\n    vvvi time(H, vvi(W));\n    time[task[0].first][task[0].second].emplace_back(0);\n    std::function<int(int,int,int,int,int,int,int)> dfs = [&](int x, int y, int px, int py, int gx, int gy, int t) {\n        if (x == gx && y == gy) {\n            return t;\n        }\n\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (!inside(nx, ny, H, W)) continue;\n            if (s[nx][ny] == '#') continue;\n            if (nx == px && ny == py) continue;\n            time[nx][ny].emplace_back(t);\n            int ret = dfs(nx, ny, x, y, gx, gy, t + 1);\n            if (ret < inf) return ret;\n            time[nx][ny].pop_back();\n        }\n\n        return inf;\n    };\n\n    int t = 1;\n    rep(i, m - 1) {\n        t = dfs(task[i].first, task[i].second, -1, -1, task[i + 1].first, task[i + 1].second, t);\n    }\n\n    // rep(i, H) {\n    //     rep(j, W) {\n    //         cout << i << \" \" << j << \": \";\n    //         printV(time[i][j]);\n    //     }\n    // }\n\n    int ans = 0;\n    rep(i, H) {\n        rep(j, W) {\n            if (time[i][j].empty()) {\n                continue;\n            }\n            ans += on[i][j];\n            rep(k, (int)time[i][j].size() - 1) {\n                ans += min(power[i][j] * (time[i][j][k + 1] - time[i][j][k]), off[i][j] + on[i][j]);\n            }\n            ans += off[i][j];\n        }\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<stack>\n#include<map>\n\nusing namespace std;\n\n#define M 52\n#define S 100\n#define INF 100000000\n\n#define min(a,b) (a>b?b:a)\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nstruct Maps {\n\tint cost, time;\n\tint prevx, prevy;\n};\n\nint main() {\n\tint r, c, m, costcons[M][M], coston[M][M], costoff[M][M];\n\tint last[M][M], cost, time;\n\tchar map[M][M]; int cx[S], cy[S];\n\tMaps maps[M][M];\n\tstack<IP> s;\n\t\n\tcin >> r >> c >> m;\n\tfor(int i=0; i<=r+1; ++i) for(int j=0; j<=c+1; ++j) {\n\t\tmap[i][j] = '#';\n\t}\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> map[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> costcons[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> coston[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> costoff[i][j];\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> cy[i] >> cx[i];\n\t\t++cx[i]; ++cy[i];\n\t}\n\t\n\tcost = coston[cy[0]][cx[0]] + costoff[cy[0]][cx[0]]; time = 0;\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) last[i][j] = -1;\n\tlast[cy[0]][cx[0]] = 0;\n\tfor(int t=0; t<m-1; ++t) {\n\t\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) {\n\t\t\tmaps[i][j].cost = INF; maps[i][j].time = -1;\n\t\t}\n\t\ts.push(IP(time, P(cx[t], cy[t])));\n\t\tmaps[cy[t]][cx[t]].cost = cost; maps[cy[t]][cx[t]].time = time;\n\t\tmaps[cy[t]][cx[t]].prevx = cx[t]; maps[cy[t]][cx[t]].prevy = cy[t];\n\t\twhile(!s.empty()) {\n\t\t\tint ti = s.top().first;\n\t\t\tint x = s.top().second.first, y = s.top().second.second;\n\t\t\ts.pop();\n\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\tint nx = x+dx[k], ny = y+dy[k];\n\t\t\t\tif(map[ny][nx]=='.') {\n\t\t\t\t\tint pcost = coston[ny][nx] + costoff[ny][nx];\n\t\t\t\t\tif(last[ny][nx]!=-1) {\n\t\t\t\t\t\tpcost = min(pcost, (ti+1-last[ny][nx])*costcons[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t\tif((maps[y][x].cost + pcost < maps[ny][nx].cost) ||\n\t\t\t\t\t\t(maps[y][x].cost+pcost==maps[ny][nx].cost && ti+1<maps[y][x].time)) {\n\t\t\t\t\t\tmaps[ny][nx].cost = maps[y][x].cost + pcost;\n\t\t\t\t\t\tmaps[ny][nx].time = ti+1;\n\t\t\t\t\t\tmaps[ny][nx].prevx = x; maps[ny][nx].prevy = y;\n\t\t\t\t\t\tif(nx!=cx[t+1] || ny!=cy[t+1]) {\n\t\t\t\t\t\t\ts.push(IP(ti+1, P(nx, ny)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint px = cx[t+1], py = cy[t+1], pxl, pyl;\n\t\tint timel = maps[cy[t+1]][cx[t+1]].time;\n\t\twhile(px!=cx[t] || py!=cy[t]) {\n\t\t\tlast[py][px] = timel;\n\t\t\t--timel;\n\t\t\tpxl = px; pyl = py;\n\t\t\tpx = maps[pyl][pxl].prevx; py = maps[pyl][pxl].prevy;\n\t\t}\n\t\ttime = maps[cy[t+1]][cx[t+1]].time;\n\t\tcost = maps[cy[t+1]][cx[t+1]].cost;\n\t}\n\tcout << cost << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n  int r,c,m;\n  string grid[50];\n  int cost[50][50],on[50][50],off[50][50];\n  bool use[50][50];\n  vector<pair<int,int> > route[50][50];\n  vector<pair<int,int> > task;\n  int y,x,prvy,prvx;\n\n  cin >> r >> c >> m;\n\n  for(int i=0;i<r;i++)cin >> grid[i];\n\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++)cin >> cost[i][j];\n  }\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++)cin >> on[i][j];\n  }\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++)cin >> off[i][j];\n  }\n\n  cin >> prvy >> prvx;\n  task.push_back(make_pair(prvy,prvx));\n  for(int i=1;i<m;i++){\n    cin >> y >> x;\n\n    for(int j=0;j<r;j++){\n      for(int k=0;k<c;k++){\n\tuse[j][k] = false;\n\troute[j][k].clear();\n      }\n    }\n\n    queue<pair<int,int> > q;\n    q.push(make_pair(prvy,prvx));\n    use[prvy][prvx] = true;\n\n    while(q.size()){\n      pair<int,int> tmp;\n      tmp = q.front();\n      q.pop();\n      int f = tmp.first,s = tmp.second;\n      if(f==y && s==x)break;\n      int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n\n      for(int k=0;k<4;k++){\n\tint sy = f+dy[k], sx = s+dx[k];\n\n\tif(sy<0 || sx<0 || sy>=r || sx>=c)continue;\n\tif(use[sy][sx] || grid[sy][sx]=='#')continue;\n\n\tfor(int l=0;l<(int)route[f][s].size();l++){\n\t  route[sy][sx].push_back(route[f][s][l]);\n\t}\n\troute[sy][sx].push_back(make_pair(sy,sx));\n\tuse[sy][sx] = true;\n\tq.push(make_pair(sy,sx));\n      }\n    }\n    for(int j=0;j<(int)route[y][x].size();j++)task.push_back(route[y][x][j]);\n   \n    prvy = y;prvx = x;\n  }\n\n  //for(int i=0;i<(int)task.size();i++)cout << task[i].first << \" \" << task[i].second << endl;\n\n  vector<int> visit[50][50];\n  for(int k=0;k<(int)task.size();k++)visit[task[k].first][task[k].second].push_back(k);\n\n  int res = 0;\n\n  for(int i=0;i<r;i++){\n    for(int j=0;j<c;j++){\n      if(visit[i][j].size())res += on[i][j] + off[i][j];\n\n      for(int k=0;k<(int)visit[i][j].size();k++){\n\tif(k+1<(int)visit[i][j].size()){\n\t  if( (visit[i][j][k+1] - visit[i][j][k])*cost[i][j] < on[i][j] + off[i][j]){\n\t    res += (visit[i][j][k+1] - visit[i][j][k])*cost[i][j];\n\t  }else{\n\t    res += on[i][j] + off[i][j];\n\t  }\n\t}\n      }\n    }\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int h, w, m;\n    cin >> h >> w >> m;\n    vector<vector<int>> cost1(h+2, vector<int>(w+2, 0));\n    auto cost2 = cost1; auto cost3 = cost1;\n    auto grid = cost1;\n    auto visited = cost1;\n    for (int i = 0; i < h; ++i) {\n        string s;\n        cin >> s;\n        for (int j = 0; j < w; ++j) {\n            grid[i+1][j+1] = (s[j] == '.');\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> cost1[i+1][j+1];\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> cost2[i+1][j+1];\n        }\n    }\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> cost3[i+1][j+1];\n        }\n    }\n    int time = 1;\n    vector<vector<vector<int>>> times(h+2, vector<vector<int>> (w+2));\n    int sy, sx;\n    cin >> sy >> sx;\n    sy++; sx++;\n    array<int, 4> dy{-1, 1, 0, 0}, dx{0, 0, 1, -1};\n    for (int i = 1; i < m; ++i) {\n        int y, x;\n        cin >> y >> x;\n        y++; x++;\n\n        for (int j = 0; j < h; ++j) {\n            for (int k = 0; k < w; ++k) {\n                visited[j+1][k+1] = 0;\n            }\n        }\n        stack<tuple<int, int, int>> S;\n        S.emplace(sy, sx, time);\n        while(!S.empty()){\n            int yy, xx, t; tie(yy, xx, t) = S.top(); S.pop();\n            visited[yy][xx] = t;\n\n            for (int k = 0; k < 4; ++k) {\n                if(grid[yy+dy[k]][xx+dx[k]] && !visited[yy+dy[k]][xx+dx[k]]){\n                    S.emplace(yy+dy[k], xx+dx[k], t+1);\n                }\n            }\n        }\n        int yy = y, xx = x;\n\n        int ttime = visited[y][x];\n        times[yy][xx].emplace_back(ttime);\n        while(ttime > time){\n            for (int k = 0; k < 4; ++k) {\n                if(visited[yy+dy[k]][xx+dx[k]] == max(time, visited[yy][xx]-1)){\n                    yy += dy[k];\n                    xx += dx[k];\n                    break;\n                }\n            }\n            ttime--;\n            times[yy][xx].emplace_back(ttime);\n        }\n        time = visited[y][x];\n        sy = y, sx = x;\n    }\n    int ans = 0;\n    for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n            if(!times[i][j].empty()){\n                vector<int> dp(times[i][j].size(), MOD), dq(times[i][j].size(), MOD);\n                dp[0] = cost2[i][j];\n                dq[0] = cost2[i][j] + cost3[i][j];\n                for (int k = 1; k < times[i][j].size(); ++k) {\n                    dp[k] = min(\n                            dp[k-1]+cost1[i][j]*(times[i][j][k]-times[i][j][k-1]),\n                            dq[k-1]+cost2[i][j]\n                            );\n                    dq[k] = min(\n                            dp[k-1]+cost1[i][j]*(times[i][j][k]-times[i][j][k-1])+cost3[i][j],\n                            dq[k-1]+cost2[i][j]+cost3[i][j]\n                            );\n                }\n                ans += dq.back();\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nint r,c,m;\nchar ba[50][50];\nmap<pii, int> mp;\n\nvector<int> dfsres;\nbool visited[50][50];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\nbool dfs(int y1, int x1, int y2, int x2) {\n  visited[y1][x1] = 1;\n  if (y1==y2 && x1==x2) return 1;\n  REP(k,4) {\n    int yy = y1+dy[k];\n    int xx = x1+dx[k];\n\n    if (yy<0||yy>=r||xx<0||xx>=c) continue;\n    if (ba[yy][xx] == '.' && !visited[yy][xx]) {\n      dfsres.push_back(mp[pii(yy,xx)]);\n      if (dfs(yy,xx,y2,x2))\n        return 1;\n      dfsres.pop_back();\n    }\n  }\n  return 0;\n}\n\nint main() {\n  cin >> r >> c >> m;\n\n  int ct = 0;\n  REP(i,r) {\n    REP(j,c) {\n      cin >> ba[i][j];\n      if (ba[i][j] == '.') {\n        mp[pii(i,j)] = ct++;\n      }\n    }\n  }\n  int a[ct], b[ct], c1[ct];\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (mp.count(pii(i,j))) {\n        a[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (mp.count(pii(i,j))) {\n        b[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (mp.count(pii(i,j))) {\n        c1[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  vector<int> root;\n  int maey, maex;\n  REP(i,m) {\n    int y,x;\n    cin >> y >> x;\n    if (i == 0) {\n      root.push_back(mp[pii(y,x)]);\n    } else {\n      memset(visited,0,sizeof(visited));\n      dfsres.clear();\n      dfs(maey, maex, y, x);\n      FOR(it, dfsres) {\n//        cout << *it << \" \";\n        root.push_back(*it);\n      }\n//      cout << endl;\n    }\n    maey = y; maex = x;\n  }\n  \n  \n  // cout << \"root\" << endl;\n  // FOR(it, root)\n  //   cout << *it << \" \";\n  // cout << endl;\n  vector<int> v[ct];\n\n\n  int mae[ct];\n  memset(mae,-1,sizeof(mae));\n  REP(i, root.size()) {\n    int id = root[i];\n    if (mae[id] != -1) {\n      v[id].push_back(i-mae[id]);\n    }\n    mae[id] = i;\n  }\n\n    \n  long long res = 0;\n  REP(i,ct) {\n    bool on = 0;\n//    cout << \"i = \" << i << endl;\n    REP(j, v[i].size()) {\n      int mean = v[i][j];\n//      cout << v[i][j] << \" \";\n      if (!on) {\n        res += b[i]; \n      }\n      if (a[i]*mean < b[i]+c1[i]) {\n        on = 1;\n        res += a[i]*mean;\n      } else {\n        res += c1[i];\n        on = 0;\n      }\n    }\n//    cout << endl;\n    if (!on) {\n      // cout << c1[i] << endl;\n      res += b[i] + c1[i];\n    } else\n      res += c1[i];\n//    cout << \"res = \" << res << endl;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nchar t[50][50];\nbool used[50][50];\nvector<P> v;\nP g;\nint dx[4] = { 1,0,-1,0 };\nint dy[4] = { 0,1,0,-1 };\nbool add(P x) {\n\trep(k, 4) {\n\t\tint nx = x.first + dx[k];\n\t\tint ny = x.second + dy[k];\n\t\tif (P{ nx,ny } == g) {\n\t\t\tv.push_back({ nx,ny });\n\t\t\treturn true;\n\t\t}\n\t\tif (nx < 0 || ny < 0 || nx == 50 || ny == 50)continue;\n\t\tif (t[nx][ny] == '#')continue;\n\t\tif (used[nx][ny])continue;\n\t\tused[nx][ny] = true;\n\t\tif (add({ nx,ny })) {\n\t\t\tv.push_back({ nx,ny }); return true;\n\t\t}\n\t}\n\treturn false;\n}\nstruct cost { ll keep, on, off; };\ncost c[50][50];\nint w, h, m;\nvector<int> loc[50][50];\nvoid solve() {\n\trep(i, 50) {\n\t\trep(j, 50) {\n\t\t\tt[i][j] = '#';\n\t\t}\n\t}\n\tcin >> h >> w >> m;\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> t[i][j];\n\t\t}\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> c[i][j].keep;\n\t\t}\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> c[i][j].on;\n\t\t}\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tcin >> c[i][j].off;\n\t\t}\n\t}\n\tP memo;\n\tcin >> memo.first >> memo.second;\n\tv.push_back(memo);\n\trep(i, m-1) {\n\t\trep(j, 50) {\n\t\t\trep(k, 50) {\n\t\t\t\tused[j][k] = false;\n\t\t\t}\n\t\t}\n\t\tint x, y; cin >> x >> y;\n\t\tg = { x,y };\n\t\tused[memo.first][memo.second] = true;\n\t\tint l1 = v.size();\n\t\tadd(memo);\n\t\tmemo = g;\n\t\treverse(v.begin() + l1, v.end());\n\t}\n\tll out = 0;\n\tint len = v.size();\n\trep(i, len) {\n\t\tloc[v[i].first][v[i].second].push_back(i);\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tint len2 = loc[i][j].size();\n\t\t\tif (len2)out += c[i][j].on;\n\t\t\trep(k, len2) {\n\t\t\t\tif (k == len2 - 1) {\n\t\t\t\t\tout += c[i][j].off;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout += min(c[i][j].on + c[i][j].off, c[i][j].keep*(loc[i][j][k + 1] - loc[i][j][k]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << out << endl;\n}\nint main(){\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n\ntemplate<typename T,typename S>\nostream& operator<<(ostream& os,const pair<T,S>& val){\n    os << \"(\" << val.first << \",\" << val.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& val){\n    os << \"[ \";\n    for(typename vector<T>::const_iterator it=val.begin();\n        it != val.end();++it){\n        os << *it << \" \";\n    }\n    os << \"]\";\n    return os;\n}\n\n#define mp(a,b) make_pair(a,b)\n\ntypedef pair<char,char> pii;\ntypedef vector<pii> vp1;\ntypedef vector<vp1> vp2;\ntypedef vector<vp2> vp3;\ntypedef vector<vp3> vp4;\ntypedef vector<vp4> vp5;\ntypedef vector<char> vc;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nint main(){\n    int R,C,M;\n    cin >> R >> C >> M;\n    vp4 before(R,vp3(C,vp2(R,vp1(C,mp(-1,-1)))));\n\n    vector<vc> is_room(R,vc(C));\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            char t;cin >> t;\n            is_room[r][c] = (t == '.');\n        }\n    }\n\n    for(int s_r=0;s_r<R;s_r++){\n        for(int s_c=0;s_c<C;s_c++){\n            stack<pii> S;\n            before[s_r][s_c][s_r][s_c] = mp(s_r,s_c);\n            S.push(mp(s_r,s_c));\n            while(not S.empty()){\n                pii p = S.top();\n                int r = p.first,c = p.second;\n                S.pop();\n                for(int i=0;i<4;i++){\n                    int nr = r + dy[i],nc = c + dx[i];\n                    if(0 <= nr and nr < R and 0 <= nc and nc < C and\n                       is_room[nr][nc] and before[s_r][s_c][nr][nc].first == -1){\n                        before[s_r][s_c][nr][nc] = mp(r,c);\n                        S.push(mp(nr,nc));\n                    }\n                }\n            }\n        }\n    }\n\n    vector<vector<int> > consume(R,vector<int>(C));\n    vector<vector<int> > turn_on(R,vector<int>(C));\n    vector<vector<int> > turn_off(R,vector<int>(C));\n\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> consume[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_on[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_off[r][c];\n        }\n    }\n\n    vector<vector<int> > last_visit(R,vector<int>(C,-1));\n    int lr=-1,lc=-1;\n    int cur_time = 0;\n    int ret = 0;\n    for(int t_case=0;t_case<M;t_case++){\n        int gr,gc;\n        cin >> gr >> gc;\n        if(t_case == 0){\n            lr = gr;lc = gc;\n        }\n        vp1 rou;\n        pii cur = mp(gr,gc);\n        while(not(cur.first == lr and cur.second == lc)){\n            rou.push_back(cur);\n            cur = before[lr][lc][cur.first][cur.second];\n        }\n        rou.push_back(mp(lr,lc));\n        reverse(all(rou));\n\n        for(size_t i=0;i<rou.size();i++){\n            if(i != 0) cur_time++;\n            int c_r = rou[i].first,c_c = rou[i].second;\n\n            if(last_visit[c_r][c_c] != -1){\n                ret += min(consume[c_r][c_c] * (cur_time - last_visit[c_r][c_c]),\n                           turn_off[c_r][c_c] + turn_on[c_r][c_c]);\n            }else{\n                ret += turn_on[c_r][c_c];\n            }\n            last_visit[c_r][c_c] = cur_time;\n            // cerr << c_r << \" \" << c_c << \" \" << cur_time << \" \" << ret << endl;\n        }\n        lr = gr,lc = gc;\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            if(last_visit[r][c] != -1) {\n                ret += turn_off[r][c];\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nint h,w,m;\nint t[50][50];\nint con[50][50],on[50][50],off[50][50];\nint dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\nint to[1000][50][50];\nstring s[50];\nvoid dfs(int x,int y,int pr,int id)\n{\n\tfor(int dr=0;dr<4;dr++)\n\t{\n\t\tif(pr>=0&&(dr-pr+4)%4==2)\n\t\t{\n\t\t\tto[id][x][y]=dr;\n\t\t\tcontinue;\n\t\t}\n\t\tint tx=x+dx[dr],ty=y+dy[dr];\n\t\tif(tx>=0&&ty>=0&&tx<h&&ty<w&&s[tx][ty]!='#')dfs(tx,ty,dr,id);\n\t}\n}\nmain()\n{\n\tcin>>h>>w>>m;\n\tfor(int i=0;i<h;i++)cin>>s[i];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>con[i][j];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>on[i][j];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cin>>off[i][j];\n\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)t[i][j]=-1;\n\tfor(int i=0;i<m;i++)for(int k=0;k<h;k++)for(int l=0;l<w;l++)to[i][k][l]=-1;\n\tvector<pair<int,int> >xy;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y;cin>>x>>y;xy.push_back({x,y});\n\t\tdfs(x,y,-1,i);\n\t}\n\tint nx=xy[0].first,ny=xy[0].second;\n\tt[nx][ny]=0;\n\tint ans=on[nx][ny]+off[nx][ny];\n\tint nowt=0;\n\tfor(int i=1;i<m;i++)\n\t{\n\t\tint tx=xy[i].first,ty=xy[i].second;\n\t\twhile(nx!=tx||ny!=ty)\n\t\t{\n\t\t\tint r=to[i][nx][ny];\n\t\t\tnx+=dx[r],ny+=dy[r];\n\t\t\tnowt++;\n\t\t\tans+=on[nx][ny]+off[nx][ny];\n\t\t\tif(t[nx][ny]>=0)\n\t\t\t{\n\t\t\t\tint A=on[nx][ny]+off[nx][ny];\n\t\t\t\tint B=(nowt-t[nx][ny])*con[nx][ny];\n\t\t\t\tif(A>B)ans-=A-B;\n\t\t\t}\n\t\t\tt[nx][ny]=nowt;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,short int> mp;\n  vector<int> V;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        V.push_back(i*C+j);\n        ++n;\n      }\n    }\n  }\n  vector< vector< vector<short int> > > G(n,vector< vector<short int> >(n));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        short int v = mp[x_*C+y_];\n        G[i][v].push_back(v);\n      }\n    }\n  }\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<short int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  vector< vector<short int> > P(R, vector<short int>(C)), OnOff = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OnOff[i][j];\n  short int t;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      OnOff[i][j] += t;\n    }\n  }\n  int x, y, x_, y_;\n  cin >> x >> y;\n  vector<short int> T(n,-1);\n  T[mp[x*C+y]] = 0;\n  t = 0;\n  int ans = OnOff[x][y];\n  for(int i = 0; i < M-1; ++i){\n    cin >> x_ >> y_;\n    int v = mp[x*C+y], v_ = mp[x_*C+y_];\n    x = x_;\n    y = y_;\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += OnOff[r][c];\n      }else{\n        ans += min((int)OnOff[r][c], P[r][c]*(t-T[k]));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n#include <string.h>\n#define nm 55\nusing namespace std;\nint n, m, nrt, a[nm][nm], viz[nm][nm];\nlong long  pc[nm][nm], on[nm][nm], of[nm][nm], timp, viz2[nm][nm], prim, ultim, k, aux[nm*nm], nraux, ctmin[1005][2];\nlong long sol=0;\nvector <long long> t[nm][nm];\nstruct punct\n{\n    int x, y;\n} p[1005], d[]={{0,0},{1,0},{0,1},{-1,0},{0,-1}}, coada[nm*nm];\nvoid citire()\n{\n    int i, j;\n    char c[nm];\n\n    cin>>n>>m>>nrt;\n\n    for(i=0; i<=n+1; i++)\n        a[i][0]=a[i][m+1]=-1;\n    for(i=0; i<=m+1; i++)\n        a[0][i]=a[n+1][i]=-1;\n\n    for(i=1; i<=n; i++)\n    {\n        cin>>c;\n        for(j=0; j<m; j++)\n           if(c[j]!='.') a[i][j+1]=-1;\n    }\n     for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            cin>>pc[i][j];\n     for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            cin>>on[i][j];\n     for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            cin>>of[i][j];\n     for(i=1; i<=nrt; i++)\n        {\n             cin>>p[i].x>>p[i].y;\n             p[i].x++;\n             p[i].y++;\n        }\n}\nvoid drum(int x1, int y11, int x2, int y2)\n{\n    int i, j, x, y;\n    for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            viz2[i][j]=a[i][j];\n    viz[x1][y11]= 1;\n    viz2[x1][y11]=1;\n    prim=ultim=k=1;\n    coada[prim].x=x1; coada[prim].y=y11;\n    while(k!=0)\n    {\n        for(i=1; i<=4; i++)\n            if((!viz2[coada[prim].x+d[i].x][coada[prim].y+d[i].y])&&(a[coada[prim].x+d[i].x][coada[prim].y+d[i].y]!=-1))\n        {\n            viz[coada[prim].x+d[i].x][coada[prim].y+d[i].y]=1;\n            viz2[coada[prim].x+d[i].x][coada[prim].y+d[i].y]=viz2[coada[prim].x][coada[prim].y]+1;\n            ultim++;\n            k++;\n            coada[ultim].x=coada[prim].x+d[i].x;\n            coada[ultim].y=coada[prim].y+d[i].y;\n        }\n        prim++;\n        k--;\n    }\n    x=x2;\n    y=y2;\n    do\n    {\n       for(i=1; i<=4; i++)\n        if(viz2[d[i].x+ x][d[i].y+y]== (viz2[x][y]-1))\n          {\n              t[x][y].push_back(timp+viz2[x][y]-1);\n              x=d[i].x+ x;\n              y=d[i].y+y;\n              break;\n          }\n    }\n    while((x1!=x)||(y11!=y));\n\n    timp+=(viz2[x2][y2]-1);\n}\nvoid pd(int in1, int in2)\n{\n    ///aux- vect ce retine timpii la care ai trecut prin camera in1, in2\n    ///ctmin[in_din_aux][0]= costul minim pt a iesi de a in_din_aux -a oara din camera in1, in2, lasan-o cu becul stins\n    ///[1]= becul aprins\n    int i;\n    ctmin[1][0]=on[in1][in2]+of[in1][in2];\n    ctmin[1][1]=on[in1][in2];\n    for(i=2; i<=nraux; i++)\n    {\n        long long dif=(aux[i]-aux[i-1]);\n        ctmin[i][0]=min(ctmin[i-1][0]+ on[in1][in2]+ of[in1][in2], ctmin[i-1][1]+ dif*pc[in1][in2] +of[in1][in2]);\n        ctmin[i][1]=min(ctmin[i-1][0]+ on[in1][in2], ctmin[i-1][1]+ dif*pc[in1][in2]);\n    }\n    sol+=ctmin[nraux][0];\n}\nvoid solve()\n{\n    int i, j;\n     t[p[1].x][p[1].y].push_back(0);\n    for(i=1; i<nrt; i++)\n        drum(p[i].x, p[i].y, p[i+1].x, p[i+1].y);//lee\n    for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n           if(viz[i][j])\n    {\n         ///la prima trecere becul on si la ultima becul off\n        nraux=0;\n        for(auto it=t[i][j].begin(); it!=t[i][j].end(); ++it)\n            {\n                nraux++;\n                aux[nraux]=*it;\n            }\n        pd(i, j);\n    }\n    cout<<sol<<\"\\n\";\n}\n/*void afis()\n{\n    int i, j;\n    for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            if(viz[i][j])\n    {\n        cout<<\"room \"<<i<<' '<<j<<\"\\n\";\n        for(auto it=t[i][j].begin(); it!=t[i][j].end(); ++it)\n            cout<<(*it)<<' ';\n        cout<<\"\\n\";\n    }\n}*/\nint main()\n{\n    citire();\n    solve();\n   // afis();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[2] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * C.cpp\n *\n *  Created on: Oct 9, 2012\n *      Author: carber\n */\n\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n\nusing namespace std;\n\n#include <vector>\ntypedef long long LL;\n\nconst int maxr = 52;\nconst int maxm = 1024;\nchar g[maxr][maxr];\nint last[maxr][maxr];\nint sign[maxr][maxr];\nint on[maxr][maxr], off[maxr][maxr];\nint gc[maxr][maxr];\nint wx[maxm], wy[maxm];\nint R, C, M;\nvector<vector<int> > ret;\n\nvoid input() {\n    scanf(\"%d %d %d\", &R, &C, &M);\n    for (int i = 0; i < R; ++i) {\n        scanf(\"%s\", g[i]);\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            scanf(\"%d\", &gc[i][j]);\n        }\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            scanf(\"%d\", &on[i][j]);\n        }\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            scanf(\"%d\", &off[i][j]);\n        }\n    }\n    for (int i = 0; i < M; ++i) {\n        scanf(\"%d %d\", &wx[i], &wy[i]);\n    }\n}\n\nconst int dir[4][2] = {-1, 0, 0, 1, 0, -1, 1, 0};\nint Q[maxr * maxr], st, ed, pre[maxr * maxr];\n\nbool check(int x, int y) {\n    return x >= 0 && y >= 0 && x < R && y < C && g[x][y] != '#';\n}\n\nvoid bfs(int s, int e, int idx) {\n    st = ed = 0; Q[ed++] = s;\n    sign[s/C][s%C] = idx, pre[s] = s;\n    while (st < ed) {\n        if (Q[st] == e) {\n            vector<int> tmp;\n            int cs = e;\n            while (cs != s) {\n                tmp.push_back(cs);\n                cs = pre[cs];\n            }\n            //tmp.push_back(s);\n            reverse(tmp.begin(), tmp.end());\n            ret.push_back(tmp);\n            return;\n        }\n        int x = Q[st] / C, y = Q[st++] % C;\n        for (int k = 0; k < 4; ++k) {\n            int tx = x + dir[k][0];\n            int ty = y + dir[k][1];\n            if (check(tx, ty) && sign[tx][ty] != idx) {\n                sign[tx][ty] = idx;\n                Q[ed++] = tx * C + ty;\n                pre[Q[ed - 1]] = Q[st-1];\n            }\n        }\n    }\n}\n\nvoid solved(int nT) {\n    input();\n    memset(last, -1, sizeof(last));\n    memset(sign, -1, sizeof(sign));\n    for (int i = 1; i < M; ++i) {\n        bfs(wx[i-1] * C + wy[i-1], wx[i] * C + wy[i], i - 1);\n    }\n\n    LL cost = 0, use = 0;\n    last[wx[0]][wy[0]] = 0;\n    cost += on[wx[0]][wy[0]];\n\n    for (int t = 0; t < (int)ret.size(); ++t) {\n        for (int j = 0; j < (int)ret[t].size(); ++j) {\n            int x = ret[t][j] / C, y = ret[t][j] % C;\n            ++use;\n            if (last[x][y] == -1) {\n                cost += on[x][y];\n                last[x][y] = use;\n            } else {\n                cost += min((use - last[x][y]) * gc[x][y], (LL)on[x][y] + off[x][y]);\n                last[x][y] = use;\n            }\n            //cout << cost << endl;\n        }\n    }\n    for (int i = 0; i < R; ++i) {\n        for (int j = 0; j < C; ++j) {\n            if (sign[i][j] != -1) cost += off[i][j];\n        }\n    }\n    cout << cost << endl;\n}\n\nint main() {\n    int T = 1;\n    for (int nT = 1; nT <= T; ++nT) {\n        solved(nT);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nchar r[51][51]; int H, W, Q, a[2601], b[2601], c[2601], d[2601], T; vector<int>x[2601], u[2601]; pair<int, int>dist[2601];\nvoid Goto(int p1, int p2) {\n\tfor (int i = 0; i < H*W; i++)dist[i] = make_pair(1 << 30, 1 << 30);\n\tqueue<int>Q; Q.push(p1); dist[p1] = make_pair(0, 1 << 30); int p3 = p2;\n\twhile (!Q.empty()) {\n\t\tint a1 = Q.front(); Q.pop();\n\t\tfor (int i : x[a1]) {\n\t\t\tif (dist[i].first > dist[a1].first + 1) { dist[i] = make_pair(dist[a1].first + 1, a1); Q.push(i); }\n\t\t}\n\t}\n\twhile (p2 != p1) { u[p2].push_back(T + dist[p2].first); p2 = dist[p2].second; }\n\tT += dist[p3].first;\n}\nint main() {\n\tcin >> H >> W >> Q;\n\tfor (int i = 0; i < H; i++) { for (int j = 0; j < W; j++)cin >> r[i][j]; } for (int i = 0; i < H*W; i++)cin >> a[i]; for (int i = 0; i < H*W; i++)cin >> b[i]; for (int i = 0; i < H*W; i++)cin >> c[i];\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\n\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\tint ex = i + dx[k], ey = j + dy[k];\n\t\t\t\tif (ex < 0 || ey < 0 || ex >= H || ey >= W || r[ex][ey] == '#' || r[i][j] == '#')continue;\n\t\t\t\tx[i*W + j].push_back(ex*W + ey); x[ex*W + ey].push_back(i*W + j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) { int ax, bx; cin >> ax >> bx; d[i] = ax*W + bx; }\n\tu[d[0]].push_back(0); int ret = 0; for (int i = 0; i < Q - 1; i++) { Goto(d[i], d[i + 1]); }\n\tfor (int i = 0; i < H*W; i++) {\n\t\tif (u[i].size() >= 1)ret += b[i] + c[i];\n\t\tfor (int j = 0; j < (int)u[i].size() - 1; j++) {\n\t\t\tif ((u[i][j + 1] - u[i][j])*a[i] >= b[i] + c[i]) { ret += b[i] + c[i]; }\n\t\t\telse { ret += (u[i][j + 1] - u[i][j])*a[i]; }\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int dy[] = {-1, 0, 1, 0}, dx[] = {0, -1, 0, 1};\nvi v[50][50];\nint h, w, m;\nint a[50][50], b[50][50], c[50][50], dir[50][50][50][50];\nchar in[50][51];\n\nvoid rec(int y, int x, int sy, int sx, int py, int px){\n\trep(d, 4){\n\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\tif(ny == py && nx == px) continue;\n\t\tif(ny < 0 || nx < 0 || ny >= h || nx >= w || in[ny][nx] == '#') continue;\n\t\tdir[ny][nx][sy][sx] = d;\n\t\trec(ny, nx, sy, sx, y, x);\n\t}\n}\nint dp[2000][2];\nint calc(const vi &v, int y, int x){\n\tint n = v.size();\n\tif(n == 1) return b[y][x] + c[y][x];\n\trep(i, n) rep(j, 2) dp[i][j] = inf;\n\tdp[0][0] = b[y][x] + c[y][x];\n\tdp[0][1] = b[y][x];\n\t\n\trep(i, n - 1) rep(j, 2) if(dp[i][j] < inf) rep(k, 2){\n\t\tint nxt = dp[i][j];\n\t\tnxt += j ? (v[i + 1] - v[i]) * a[y][x] : b[y][x];\n\t\tif(!k) nxt += c[y][x];\n\t\t\n\t\tdp[i + 1][k] = min(dp[i + 1][k], nxt);\n\t}\n\treturn dp[n - 1][0];\n}\nint main(){\n\tcin >> h >> w >> m;\n\trep(i, h) cin >> in[i];\n\trep(i, h) rep(j, w) cin >> a[i][j];\n\trep(i, h) rep(j, w) cin >> b[i][j];\n\trep(i, h) rep(j, w) cin >> c[i][j];\n\trep(i, h) rep(j, w) if(in[i][j] == '.') rec(i, j, i, j, i, j);\n\t\n\tint ny, nx, y, x, t = 0;\n\tcin >> y >> x;\n\tv[y][x].pb(t);\n\trep(i, m - 1){\n\t\tcin >> ny >> nx;\n\t\tdo{\n\t\t\tint d = dir[y][x][ny][nx];\n\t\t\ty -= dy[d]; x -= dx[d];\n\t\t\tv[y][x].pb(++t);\n\t\t}while(ny != y || nx != x);\n\t}\n\tint ans = 0;\n\trep(i, h) rep(j, w) if(v[i][j].size()) ans += calc(v[i][j], i, j);\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1}, INF = 1e9;\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,int> mp;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        ++n;\n      }\n    }\n  }\n  vector< vector<int> > D(n, vector<int>(n,INF));\n  for(int x = 0; x < R; ++x){\n    for(int y = 0; y < C; ++y){\n      if(S[x][y] == '.'){\n        for(int j = 0; j < 4; ++j){\n          int x_ = x + dx[j], y_ = y + dy[j], i = mp[x*C+y];\n          if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n            int v = mp[x_*C+y_];\n            D[i][v] = 1;\n          }\n        }\n      }\n    }\n  }\n  for(int i = 0; i < n; ++i) D[i][i] = 0;\n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        D[i][j] = min(D[i][j],D[i][k] + D[k][j]);\n      }\n    }\n  }\n\n  vector< vector<int> > G(n, vector<int>(n,-1));\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < n; ++j){\n      if(i == j) continue;\n      for(int k = 0; k < n; ++k){\n        if(D[i][k] == 1 && D[i][j] == D[i][k] + D[k][j]){\n          G[i][j] = k;\n          break;\n        }\n      }\n    }\n  }\n  \n\n  vector<int> P(n), OnOff = P;\n  int t;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) P[mp[i*C+j]] = t;\n    }\n  }\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) OnOff[mp[i*C+j]] = t;\n    }\n  }\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      if(t > 0) OnOff[mp[i*C+j]] += t;\n    }\n  }\n  int x, y;\n  cin >> x >> y;\n  vector<int> T(n,-1);\n  T[mp[x*C+y]] = 0;\n  t = 0;\n  int v = mp[x*C+y];\n  long long int ans = OnOff[v];\n  for(int i = 1; i < M; ++i){\n    cin >> x >> y;\n    int v_ = mp[x*C+y];\n    while(v != v_){\n      v = G[v][v_];\n      ++t;\n      if(T[v] < 0){\n        T[v] = t;\n        ans += OnOff[v];\n      }else{\n        ans += min((long long int)OnOff[v], (long long int)(P[v]*(t-T[v])));\n        T[v] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\n\n\n\nint  dx[]={1,0,-1,0};\nint  dy[]={0,1,0,-1};\n\nstruct Task{\n\tint y,x;int t;\n\tTask(int y,int x,int t):y(y),x(x),t(t){};\n};\n\nclass Main{\npublic:\n\n\n\n\tvector<vector<bool>> passed;\n\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tqueue<Task> que;\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tREP(i,M){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tint res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//mid\n\t\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t\t}\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\n\tios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[2] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nmap<pair<int, int>, int> encoder;\n\nint encode(const pair<int, int> &p) {\n\tif(!encoder.count(p)) encoder.insert({p, encoder.size()});\n\treturn encoder[p];\n}\n\nvector<vector<int>> make_graph(const vector<string> &field) {\n\tconst int h = field.size();\n\tconst int w = field[0].size();\n\n\tint V = 0;\n\tfor(const auto &row : field) {\n\t\tV += count(row.begin(), row.end(), '.');\n\t}\n\n\tconstexpr int dx[4] = {1, -1, 0, 0};\n\tconstexpr int dy[4] = {0, 0, 1, -1};\n\n\tvector<vector<int>> graph(V);\n\tfor(int y = 0; y < h; ++y) {\n\t\tfor(int x = 0; x < w; ++x) {\n\t\t\tif(field[y][x] == '.') {\n\t\t\t\tauto &es = graph[encode({x, y})];\n\n\t\t\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\t\t\tconst int nx = x + dx[d];\n\t\t\t\t\tconst int ny = y + dy[d];\n\n\t\t\t\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n\t\t\t\t\tif(field[ny][nx] == '#') continue;\n\n\t\t\t\t\tes.emplace_back(encode({nx, ny}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn graph;\n}\n\nint input_index() {\n\tint x, y;\n\tcin >> y >> x;\n\treturn encode({x, y});\n}\n\nvector<int> input_matrix(int h, int w) {\n\tvector<int> res(encoder.size());\n\tfor(int y = 0; y < h; ++y) {\n\t\tfor(int x = 0; x < w; ++x) {\n\t\t\tint value;\n\t\t\tcin >> value;\n\t\t\tif(value) res[encode({x, y})] = value;\n\t\t}\n\t}\n\treturn res;\n}\n\nvector<int> bfs(int s, const vector<vector<int>> &graph) {\n\tconst int n = graph.size();\n\tvector<int> dist(n, numeric_limits<int>::max());\n\tqueue<int> que;\n\tdist[s] = 0;\n\tque.push(s);\n\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\tfor(const auto &to : graph[v]) {\n\t\t\tif(dist[to] > dist[v] + 1) {\n\t\t\t\tdist[to] = dist[v] + 1;\n\t\t\t\tque.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\n\nvoid get_path(int v, vector<int> &path, const vector<vector<int>> &graph, const vector<int> &dist) {\n\tpath.emplace_back(v);\n\n\tif(dist[v] == 0) return;\n\tfor(const auto &to : graph[v]) {\n\t\tif(dist[to] + 1 == dist[v]) {\n\t\t\tget_path(to, path, graph, dist);\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint h, w, m;\n\tcin >> h >> w >> m;\n\n\tvector<string> field(h);\n\tfor(auto &row : field) cin >> row;\n\n\tconst auto graph = make_graph(field);\n\tconst auto continue_cost = input_matrix(h, w);\n\tconst auto turn_on_cost = input_matrix(h, w);\n\tconst auto turn_off_cost = input_matrix(h, w);\n\n\tconst int n = encoder.size();\n\tvector<vector<int>> dist;\n\tdist.reserve(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tdist.emplace_back(bfs(i, graph));\n\t}\n\n\tvector<int> min_cost(n, 0);\n\tvector<int> last_time(n, -1);\n\n\tint current = input_index();\n\tmin_cost[current] = turn_on_cost[current];\n\tlast_time[current] = 0;\n\n\tint t = 0;\n\twhile(--m) {\n\t\tconst int next = input_index();\n\t\tvector<int> path;\n\t\tget_path(current, path, graph, dist[next]);\n\n\t\tfor(unsigned i = 1; i < path.size(); ++i) {\n\t\t\tconst int v = path[i];\n\t\t\t++t;\n\t\t\tif(last_time[v] == -1) {\n\t\t\t\tmin_cost[v] = turn_on_cost[v];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmin_cost[v] += min(turn_off_cost[v] + turn_on_cost[v], continue_cost[v] * (t - last_time[v]));\n\t\t\t}\n\t\t\tlast_time[v] = t;\n\t\t}\n\n\t\tcurrent = next;\n\t}\n\n\tint ans = 0;\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(last_time[v] != -1) ans += min_cost[v] + turn_off_cost[v];\n\t}\n\n\tcout << ans << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nint r,c,m;\nchar ba[50][50];\nmap<pii, int> mp;\n\nvector<int> dfsres;\nbool visited[50][50];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\nbool dfs(int y1, int x1, int y2, int x2) {\n  visited[y1][x1] = 1;\n  if (y1==y2 && x1==x2) return 1;\n  REP(k,4) {\n    int yy = y1+dy[k];\n    int xx = x1+dx[k];\n\n    if (yy<0||yy>=r||xx<0||xx>=c) continue;\n    if (ba[yy][xx] == '.' && !visited[yy][xx]) {\n      dfsres.push_back(mp[pii(yy,xx)]);\n      if (dfs(yy,xx,y2,x2))\n        return 1;\n      dfsres.pop_back();\n    }\n  }\n  return 0;\n}\n\nint main() {\n  cin >> r >> c >> m;\n\n  int ct = 0;\n  REP(i,r) {\n    REP(j,c) {\n      cin >> ba[i][j];\n      if (ba[i][j] == '.') {\n        mp[pii(i,j)] = ct++;\n      }\n    }\n  }\n  int a[ct], b[ct], c1[ct];\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (mp.count(pii(i,j))) {\n        a[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (mp.count(pii(i,j))) {\n        b[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (mp.count(pii(i,j))) {\n        c1[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  vector<int> root;\n  int maey, maex;\n  REP(i,m) {\n    int y,x;\n    cin >> y >> x;\n    if (i == 0) {\n      root.push_back(mp[pii(y,x)]);\n    } else {\n      if (maey==y&&maex==x) {\n        root.push_back(mp[pii(y,x)]);\n      }\n      memset(visited,0,sizeof(visited));\n      dfsres.clear();\n      dfs(maey, maex, y, x);\n      FOR(it, dfsres) {\n//        cout << *it << \" \";\n        root.push_back(*it);\n      }\n//      cout << endl;\n    }\n    maey = y; maex = x;\n  }\n  \n  \n  // cout << \"root\" << endl;\n  // FOR(it, root)\n  //   cout << *it << \" \";\n  // cout << endl;\n  vector<int> v[ct];\n\n\n  int mae[ct];\n  memset(mae,-1,sizeof(mae));\n  REP(i, root.size()) {\n    int id = root[i];\n    if (mae[id] != -1) {\n      v[id].push_back(i-mae[id]);\n    }\n    mae[id] = i;\n  }\n\n    \n  long long res = 0;\n  REP(i,ct) {\n    bool on = 0;\n//    cout << \"i = \" << i << endl;\n    REP(j, v[i].size()) {\n      int mean = v[i][j];\n//      cout << v[i][j] << \" \";\n      if (!on) {\n        res += b[i]; \n      }\n      if (a[i]*mean < b[i]+c1[i]) {\n        on = 1;\n        res += a[i]*mean;\n      } else {\n        res += c1[i];\n        on = 0;\n      }\n    }\n//    cout << endl;\n    if (mae[i] != -1) {\n      if (!on) {\n        res += b[i] + c1[i];\n      } else\n        res += c1[i];\n    }\n    //cout << \"res = \" << res << endl;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {+0,+1,+0,-1};\nconst static int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint W,H;\nbool visited[51][51];\nchar stage[51][51];\nvector<P> dfs(int sx,int sy,int gx,int gy,\n              vector<P>& route){\n\n  vector<P> res;\n  for(int i=0;i<4;i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(visited[dy][dx]) continue;\n    if(stage[dy][dx] == '#') continue;\n\n    if(dx == gx && dy == gy){\n      route.push_back(P(dx,dy));\n      res = route;\n      return res;\n    }\n\n    visited[dy][dx] = true;\n    route.push_back(P(dx,dy));\n\n    vector<P> tmp = dfs(dx,dy,gx,gy,route);\n    if(tmp.size() > 0){\n      res = tmp;\n    }\n\n    visited[dy][dx] = false;\n    route.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  int task_rooms;\n  while(~scanf(\"%d %d %d\",&H,&W,&task_rooms)){\n    int consumption_per_unit[51][51];\n    int turn_off_cost[51][51];\n    int turn_on_cost[51][51];\n\n\n    for(int y = 0; y < H; y++){\n      char buf[51];\n      scanf(\"%s\",buf);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = buf[x];\n      }\n    }\n    \n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&consumption_per_unit[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_off_cost[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_on_cost[y][x]);\n      }\n    }\n\n    vector<P> points;\n    for(int task_i = 0; task_i < task_rooms; task_i++){\n      int y,x;\n      scanf(\"%d %d\",&y,&x);\n      points.push_back(P(x,y));\n    }\n\n\n    int latest_time = 0;\n    int prev_x = -1;\n    int prev_y = -1;\n\n    vector<int> move_log[51][51];\n    for(int task_i = 0; task_i + 1 < task_rooms; task_i++){\n      int sx = points[task_i].first;\n      int sy = points[task_i].second;\n\n      int gx = points[task_i+1].first;\n      int gy = points[task_i+1].second;\n\n      memset(visited,false,sizeof(visited));\n      visited[sy][sx] = true;\n      vector<P> route;\n      route.push_back(P(sx,sy));\n      route = dfs(sx,sy,gx,gy,route);\n\n      for(int i=0; i< route.size();i++){\n        int x = route[i].first;\n        int y = route[i].second;\n\n        if(x == prev_x && y == prev_y) continue;\n        \n        move_log[y][x].push_back(latest_time);\n        latest_time++;\n\n        prev_x = x;\n        prev_y = y;\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        res += turn_on_cost[y][x];\n        for(int i = 0; i + 1< move_log[y][x].size(); i++){\n          int duration = move_log[y][x][i+1] - move_log[y][x][i] ;\n          res += min(turn_off_cost[y][x] + turn_on_cost[y][x],\n                     consumption_per_unit[y][x] * duration);\n        }\n        res += turn_off_cost[y][x];\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <string>\nusing namespace std;\n\nusing ll = long long int;\nvector<int> dp[55][55];\nstring board[55];\nint t;\nint d[55][55];\nint dx[] = { -1, 0, 1, 0 }, dy[] = { 0, -1, 0, 1 };\nint h, w, m;\nint gx, gy;\n\nvoid dfs(int x, int y) {\n\tif (x == gx && y == gy) return;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 > nx || w <= nx || 0 > ny || h <= ny || board[ny][nx] == '#') continue;\n\t\tif (d[ny][nx] > d[y][x] + 1) {\n\t\t\td[ny][nx] = d[y][x] + 1;\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> h >> w >> m;\n\tfor (int i = 0; i < h; ++i) cin >> board[i];\n\tvector<int> a(h*w), b(h*w), c(h*w);\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) cin >> a[i*w + j];\n\t}\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) cin >> b[i*w + j];\n\t}\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) cin >> c[i*w + j];\n\t}\n\tvector<int> x(m), y(m);\n\tfor (int i = 0; i < m; ++i) {\n\t\tcin >> y[i] >> x[i];\n\t}\n\n\tt = 0;\n\tfor (int i = 1; i < m; ++i) {\n\t\t//cout << \"i:\" << i << endl;\n\t\t// i-1 -> i\n\t\tgx = x[i], gy = y[i];\n\t\tfor (int j = 0; j < h; ++j) {\n\t\t\tfor (int k = 0; k < w; ++k) {\n\t\t\t\td[j][k] = 1 << 30;\n\t\t\t}\n\t\t}\n\t\td[y[i - 1]][x[i - 1]] = 0;\n\t\tdfs(x[i - 1], y[i - 1]);\n\n\t\tvector<pair<int, int>> path;\n\t\tint ax = x[i], ay = y[i];\n\t\tif (i == m - 1) path.push_back({ ax, ay });\n\t\t// cout << \"ax\" << x[i-1] << \" \" << y[i-1] << endl;\n\t\twhile (ax != x[i - 1] || ay != y[i - 1]) {\n\t\t\t//cout << ax << \",\" << ay << endl;\n\t\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t\tint nx = ax + dx[j], ny = ay + dy[j];\n\t\t\t\t// cout << nx << \" \" << ny << \" \" << dx[j] << \" \" << dy[j] << endl;\n\t\t\t\tif (0 > nx || w <= nx || 0 > ny || h <= ny) continue;\n\t\t\t\t// cout << d[ny][nx] << endl;\n\t\t\t\tif (d[ny][nx] == d[ay][ax] - 1) {\n\t\t\t\t\tax = nx, ay = ny;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpath.push_back({ ax, ay });\n\t\t}\n\t\t// path.push_back({ x[i - 1], y[i - 1] });\n\t\treverse(path.begin(), path.end());\n\t\t//cout << \"-----\" << endl;\n\n\t\tfor (auto j : path) {\n\t\t\t//cout << j.first << \",\" << j.second << endl;\n\t\t\tdp[j.second][j.first].push_back(t);\n\t\t\tt++;\n\t\t}\n\t\t//cout << endl;\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t//for (auto k : dp[i][j]) cout << k << \" \";\n\t\t\t//cout << endl;\n\t\t\tfor (int k = 0; k < (int)dp[i][j].size() - 1; ++k) {\n\t\t\t\tint vl = b[i*w + j] + c[i*w + j];\n\t\t\t\tint vr = a[i*w + j] * (dp[i][j][k + 1] - dp[i][j][k]);\n\t\t\t\tret += min(vl, vr);\n\t\t\t}\n\t\t\tif (dp[i][j].size()) {\n\t\t\t\tret += b[i*w + j] + c[i*w + j];\n\t\t\t}\n\t\t\t//cout << ret << endl;\n\t\t}\n\t}\n\n\tcout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define llint long long\n\nusing namespace std;\n\nllint h, w, m;\nchar map[55][55];\nvector<llint> vec[55][55];\nbool used[55][55];\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nllint a[55][55], b[55][55], c[55][55];\n\nllint dfs(llint x, llint y, llint gx, llint gy, llint px, llint py, llint t)\n{\n\tif(x == gx && y == gy){\n\t\tvec[x][y].push_back(t);\n\t\treturn 0;\n\t}\n\tllint nx, ny;\n\tfor(int i = 0; i < 4; i++){\n\t\tnx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\tif(map[nx][ny] == '#') continue;\n\t\tif(nx == px && ny == py) continue;\n\t\tllint res = dfs(nx, ny, gx, gy, x, y, t+1);\n\t\tif(res >= 0){\n\t\t\tvec[x][y].push_back(t);\n\t\t\treturn res+1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main(void)\n{\n\tcin >> h >> w >> m;\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tcin >> map[x][y];\n\t\t}\n\t}\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tcin >> a[x][y];\n\t\t}\n\t}\n\tfor(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tcin >> b[x][y];\n\t\t}\n\t}for(int y = 0; y < h; y++){\n\t\tfor(int x = 0; x < w; x++){\n\t\t\tcin >> c[x][y];\n\t\t}\n\t}\n\t\n\tllint x, y, gx, gy, t = 0;\n\tcin >> y >> x;\n\tfor(int q = 0; q < m; q++){\n\t\tcin >> gy >> gx;\n\t\tt += dfs(x, y, gx, gy, -1, -1, t);\n\t\tx = gx, y = gy;\n\t}\n\t\n\tllint ans = 0;\n\tfor(int x = 0; x < w; x++){\n\t\tfor(int y = 0; y < h; y++){\n\t\t\tif(vec[x][y].size() == 0) continue;\n\t\t\tfor(int i = 1; i < vec[x][y].size(); i++){\n\t\t\t\tans += min(b[x][y]+c[x][y], (vec[x][y][i]-vec[x][y][i-1])*a[x][y]);\n\t\t\t}\n\t\t\tans += b[x][y]+c[x][y];\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nint  dx[4]={1,0,-1,0};\nint  dy[4]={0,1,0,-1};\n\nclass Main{\npublic:\n\tvector<vector<bool>> passed;\n\tint dfs(int y,int x,int ty,int tx,int t){\n\t\tif(y==ty && x==tx)return t;\n\n\t\tif(!IN(0,y,R) || !IN(0,x,C))return -1;\n\t\tif(passed[y][x])return -1;\n\t\tif(map[y][x]=='#')return -1;\n\t\t\n\t\tpassed[y][x]=true;\n\t\tREP(di,4){\n\t\t\tint nx=x+dx[di],ny=y+dy[di];\n\t\t\tint goal=dfs(ny,nx,ty,tx,t+1);\t\n\t\t\tif(goal!=-1){\n\t\t\t\tpassT[ny][nx].push_back(t+1);\n\t\t\t\treturn goal;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\tint R,C,M;\n\tvector<vector<vector<int>>> passT;\n\tvector<string> map;\n\t\t\n\tvoid run(){\n\t\tcin >> R >> C >> M;\n\t\t map=vector<string>(R);\n\t\tREP(y,R)cin >> map[y];\n\t\tvector<vector<int>> perC(R,vector<int>(C)),onC(R,vector<int>(C)),offC(R,vector<int>(C));\n\t\tREP(y,R)REP(x,C) cin >> perC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> onC[y][x];\n\t\tREP(y,R)REP(x,C) cin >> offC[y][x];\n\t\tvector<int> xs(M),ys(M);\n\t\tREP(i,M)cin >> ys[i] >> xs[i];\n\n\t\tpassT=vector<vector<vector<int>>> (R,vector<vector<int>>(C));\n\t\tpassT[ys[0]][xs[0]].push_back(0);\n\t\tint t=0;\n\t\tfor(int i=0;i+1<M;i++){\n\t\t\tpassed=vector<vector<bool>>(R,vector<bool>(C));\n\t\t\tt=dfs(ys[i],xs[i],ys[i+1],xs[i+1],t);\n\t\t}\n\t\tll res=0;\n\t\tREP(y,R)REP(x,C){\n\t\t\tif(passT[y][x].size()>0){\n\t\t\t\t//first\n\t\t\t\tres+=onC[y][x];\n\t\t\t\t//mid\n\t\t\t\tfor(int i=1;i<passT[y][x].size();i++){\n\t\t\t\t\tres+=min(perC[y][x]*(passT[y][x][i]-passT[y][x][i-1]),offC[y][x]+onC[y][x]);\n\t\t\t\t}\n\t\t\t\t//last\n\t\t\t\tres+=offC[y][x];\n\t\t\t}\n\t\t}\n\t\tcout <<res <<endl;\n\t}\n};\n\n int main(){\n\t//ios::sync_with_stdio(false);\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nchar field[51][51];\nint onCost[51][51];\nint offCost[51][51];\nint cnCost[51][51];\nvector<int> passTime[51][51];\nvector<pair<int,int> > works;\n\nconst int INF=1000000000;\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\nint h,w,m;\npair<int,int> roots[5000];\nint idx;\nbool ok;\n\nint vis[51][51];\n\nint sumT=0;\nbool passed[51][51];\n\nvoid dfs(int x,int y,int gx,int gy,int depth){\n    if(ok)\n        return;\n    if(passed[y][x])\n        return;\n    passed[y][x]=true;\n    if(gx==x&&gy==y){\n        roots[idx].first=gy;\n        roots[idx].second=gx;\n        idx++;\n        sumT+=depth;\n        for(int i = 0; i < idx; i++)\n            passTime[roots[i].first][roots[i].second].push_back(sumT-idx+i+1);\n        idx--;\n        ok=true;\n        passed[y][x]=false;\n        return;\n    }\n    for(int i = 0; i < 4; i++){\n        int ny=y+dy[i];\n        int nx=x+dx[i];\n        if(ny>=0&&nx>=0&&ny<h&&nx<w&&!passed[ny][nx]&&field[ny][nx]!='#'){\n            roots[idx].first=y;\n            roots[idx].second=x;\n            idx++;\n            dfs(nx,ny,gx,gy,depth+1);\n            if(ok){\n                idx--;\n                passed[y][x]=false;\n                return;\n            }\n            idx--;\n        }\n    }\n    passed[y][x]=false;\n}\n\n\nint dp[10001][2];\n// ÄAÆ»ÅÅ¬RXgðvZ\n// schÍCgªÂ¢Ä¢é©¢È¢©\nint calcMinCost(int place,int y,int x,int sch){\n    if(dp[place][sch]!=INF)\n        return dp[place][sch];\n    if(place==0){\n        if(sch)\n            return onCost[y][x];\n        else\n            return onCost[y][x]+offCost[y][x];\n    }\n    else{\n        if(passTime[y][x][place]==passTime[y][x][place-1])\n            return calcMinCost(place-1,y,x,sch);\n        int minCost=INF;\n        // »ÝÂ¢Ä¢éê\n        if(sch){\n            // X[pXÈçÛRXg¾¯©©é\n            minCost=min(minCost\n                ,calcMinCost(place-1,y,x,1)+cnCost[y][x]*(abs(passTime[y][x][place]-passTime[y][x][place-1])));\n            // ±±ÅÂ¯é¾¯\n            minCost=min(minCost,calcMinCost(place-1,y,x,0)+onCost[y][x]);\n        }\n        else{\n            // Â¯é\n            minCost=min(minCost,calcMinCost(place-1,y,x,0)+onCost[y][x]+offCost[y][x]);\n            // ¯·BºÌóÔ©çÌÛRXgªà¥¤\n            minCost=min(minCost,calcMinCost(place-1,y,x,1)+offCost[y][x]+\n                cnCost[y][x]*(abs(passTime[y][x][place]-passTime[y][x][place-1])));\n        }\n        return dp[place][sch]=minCost;\n    }\n}\n\nvoid solve(){\n\n    memset(vis,0,sizeof(vis));\n    cin>>h>>w>>m;\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            cin>>field[i][j];\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            cin>>cnCost[i][j];\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            cin>>onCost[i][j];\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            cin>>offCost[i][j];\n    for(int i = 0; i < m; i++){\n        int x,y;\n        cin>>y>>x;\n        works.push_back(make_pair(y,x));\n    }\n    // »ê¼êÌÀW\n    pair<int,int> cp=works[0];\n    sumT=0;\n    for(int i = 1; i < works.size(); i++){\n        idx=0;\n        ok=false;\n        memset(passed,0,sizeof(passed));\n        dfs(cp.second,cp.first,works[i].second,works[i].first,0);\n        cp=works[i];\n    }\n    int sumCost=0;\n    // ñxÊÁÄ¢éêÉÂ¢Äl@\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            for(int k = 0; k < 10001; k++)\n                dp[k][0]=dp[k][1]=INF;\n            sumCost+=calcMinCost(passTime[i][j].size()-1,i,j,0);\n        }\n    }\n    cout<<sumCost<<endl;\n}\nint main(){\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint R, C, M;\nstring field[50];\nbool visited[50][50];\n\nbool dfs(int px, int py, int gx, int gy, vector<int>& res)\n{\n\t\n\tif(visited[px][py]) return false;\n\tvisited[px][py] = true;\n\n\n\tif(px == gx && py == gy){\n\t\treturn true;\n\t}\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint tx = px + dx[i];\n\t\tint ty = py + dy[i];\n\n\t\tif(tx < 0 || ty < 0 || tx >= C || ty >= R) continue;\n\t\tif(field[ty][tx] == '#') continue; \n\n\t\tif(dfs(tx,ty,gx,gy,res)) {\n\t\t\tres.push_back(ty*50+tx);\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n\treturn false;\n\t\n}\n\nint main()\n{\n\tcin >> R >> C >> M;\n\n\tfor(int i=0; i<R; i++)\n\t\tcin >> field[i];\n\n\tint upkeep[50][50], oncost[50][50], offcost[50][50];\n\tint objx[1000], objy[1000];\n\n\tfor(int i=0; i<R; i++)\n\tfor(int j=0; j<C; j++)\n\t\tcin >> upkeep[j][i];\n\n\tfor(int i=0; i<R; i++)\n\tfor(int j=0; j<C; j++)\n\t\tcin >> oncost[j][i];\n\n\tfor(int i=0; i<R; i++)\n\tfor(int j=0; j<C; j++)\n\t\tcin >> offcost[j][i];\n\n\tfor(int i=0; i<M; i++)\n\t\tcin >> objy[i] >> objx[i];\n\n\tint cost=0;\n\tvector<vector<int> > route(50*50);\n\troute[objy[0]*50+objx[0]].push_back(cost++);\n\n\tfor(int i=0; i<M-1; i++) {\n\t\tvector<int> r; \n\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tdfs(objx[i], objy[i], objx[i+1], objy[i+1], r);\n\n\t\treverse(r.begin(), r.end());\n\n\t\tfor(int j=0; j<r.size(); j++) {\n\t\t\tint a = r[j];\n\n\t\t\troute[a].push_back(cost++);\n\t\t}\n\t}\n\n\tint res = 0;\n\tfor(int i=0; i<2500; i++) {\n\t\tint x = (i % 50);\n\t\tint y = (i / 50);\n\n\t\tfor(int j=0; j<route[i].size(); j++) {\n\t\t\tif(j+1 == route[i].size()) {\n\n\t\t\t\tres += offcost[x][y];\n\t\t\t\tif(route[i].size() == 1) res += oncost[x][y];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif(j==0) res += oncost[x][y];\n\n\t\t\t\tint diff = route[i][j+1] - route[i][j];\t\n\t\t\t\tres += min(diff*upkeep[x][y], offcost[x][y] + oncost[x][y]);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "# 2 \"2302.cpp\"\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\n\nnamespace solution {\n   using namespace std;\n\n   typedef istringstream ISS;\n   typedef ostringstream OSS;\n   typedef vector<string> VS;\n   typedef long long LL;\n   typedef int INT;\n   typedef vector<INT> VI;\n   typedef vector<VI> VVI;\n   typedef pair<INT, INT> II;\n   typedef vector<II> VII;\n\n   ostream& operator << ( ostream& os, II& p ) {\n      os << \"(\" << p.first << \",\" << p.second << \")\";\n      return os;\n   }\n\n   const int SIZE = 51;\n   const int MAX_M = 1011;\n   const int NONE = -1;\n   const char WALL = '#';\n   int H, W, M;\n   string S[SIZE];\n   int X[SIZE][SIZE];\n   int Y[SIZE][SIZE];\n   int Z[SIZE][SIZE];\n   II D[MAX_M];\n   int T[SIZE][SIZE][MAX_M];\n   int TC[SIZE][SIZE];\n   int A;\n\n   class Node {\n   public:\n      int r;\n      int c;\n      Node(){}\n      Node(int r, int c): r(r), c(c) {}\n   };\n   typedef queue<Node> Queue;\n   const int dr[4] = { 0, 0, 1, -1 };\n   const int dc[4] = { 1, -1, 0, 0 };\n\n   void bfs( int sr, int sc, int gr, int gc ) {\n      Queue Q;\n      Q.push( Node( sr, sc ) );\n\n      II P[H][W];\n      for ( int i = 0; i < H; ++ i ) {\n         for ( int j = 0; j < W; ++ j ) {\n            P[i][j] = II( NONE, NONE );\n         }\n      }\n\n      while ( ! ( Q.empty() ) ) {\n         Node node = Q.front();\n         Q.pop();\n\n         int r = node.r;\n         int c = node.c;\n\n         if ( r == gr && c == gc ) {\n            VII route;\n            while ( r != sr || c != sc ) {\n               route.push_back( II( r, c ) );\n               int pr = P[r][c].first;\n               int pc = P[r][c].second;\n               r = pr;\n               c = pc;\n            }\n            reverse( route.begin(), route.end() );\n            for ( VII::iterator it_i = route.begin(); it_i != route.end(); ++ it_i ) {\n               int r = (*it_i).first;\n               int c = (*it_i).second;\n               T[r][c][TC[r][c]++] = A ++;\n            }\n            return;\n         }\n\n         for ( int i = 0; i < 4; ++ i ) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            if ( nr < 0 || nr >= H || nc < 0 || nc >= W ) continue;\n            if ( P[nr][nc].first != NONE ) continue;\n            if ( S[nr][nc] == WALL ) continue;\n            P[nr][nc] = II( r, c );\n            Q.push( Node( nr, nc ) );\n         }\n      }\n   }\n\n   class Solution {\n   private:\n      void init() {\n         for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n               TC[i][j] = 0;\n            }\n         }\n         A = 0;\n      }\n\n      bool input() {\n         if ( ! ( cin >> H >> W >> M ) ) return false;\n         for ( int i = 0; i < H; ++ i ) {\n            cin >> S[i];\n         }\n         for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n               cin >> X[i][j];\n            }\n         }\n         for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n               cin >> Y[i][j];\n            }\n         }\n         for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n               cin >> Z[i][j];\n            }\n         }\n         for ( int i = 0; i < M; ++ i ) {\n            cin >> D[i].first >> D[i].second;\n         }\n         return true;\n      }\n\n      int solve() {\n         int sr = D[0].first;\n         int sc = D[0].second;\n         T[sr][sc][TC[sr][sc]++] = A ++;\n         for ( int i = 0; i + 1 < M; ++ i ) {\n            bfs( D[i].first, D[i].second, D[i+1].first, D[i+1].second );\n         }\n\n         int res = 0;\n         for ( int i = 0; i < H; ++ i ) {\n            for ( int j = 0; j < W; ++ j ) {\n               int n = TC[i][j];\n               if ( n == 0 ) continue;\n               res += Y[i][j] + Z[i][j];\n               for ( int k = 0; k + 1 < n; ++ k ) {\n                  int d = T[i][j][k+1] - T[i][j][k];\n                  res += min( X[i][j] * d, Y[i][j] + Z[i][j] );\n               }\n            }\n         }\n         return res;\n      }\n\n   public:\n      int run() {\n         while ( init(), input() ) {\n            cout << solve() << endl;\n         }\n         return 0;\n      }\n   };\n}\n\nint main() {\n   using namespace solution;\n   Solution s;\n   return s.run();\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\nconst int maxn=51;\nconst int xx[4]={1,-1,0,0};\nconst int yy[4]={0,0,1,-1};\nint endx,endy;\nint n,m;\nint num[maxn][maxn];\nint q[maxn][maxn][1001];\nbool visit[maxn][maxn];\nchar s[maxn][maxn];\nint now;\n\nbool ins(int x,int y)\n{\n\treturn x>=0&&x<n&&y>=0&&y<m;\n}\n\nbool dfs(int x,int y,int dep)\n{\n\tvisit[x][y]=1;\n\tif (x==endx&&y==endy)\n\t{\n\t\t q[x][y][ num[x][y]++]=dep;\n\t\t now=dep;\n\t\t return 1;\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nowx=x+xx[i];\n\t\tint nowy=y+yy[i];\n\t\tif (ins(nowx,nowy)&&!visit[nowx][nowy]&&s[nowx][nowy]=='.')\n\t\t{\n\t\t\tif (dfs(nowx,nowy,dep+1))\n\t\t\t{\n\t\t\t\tq[x][y][ num[x][y]++]=dep;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint a[maxn][maxn],b[maxn][maxn],c[maxn][maxn];\n\nint main()\n{\n\tint k;\n\twhile(scanf(\"%d %d %d\",&n,&m,&k)==3)\n\t{\n\t\tfor(int i=0;i<n;i++) scanf(\"%s\",s[i]);\n\t\tfor(int i=0;i<n;i++)\n\t\t for(int j=0;j<m;j++) scanf(\"%d\",&a[i][j]);\n\t\tfor(int i=0;i<n;i++)\n\t\t for(int j=0;j<m;j++) scanf(\"%d\",&b[i][j]);\n\t\tfor(int i=0;i<n;i++)\n\t\t for(int j=0;j<m;j++) scanf(\"%d\",&c[i][j]);\n\t\tmemset(num,0,sizeof(num));\n\t\tint xx,yy;\n\t\tscanf(\"%d %d\",&xx,&yy);\n\t\tbool first=1;\n\n\t\tnow=0;\n\t\tk--;\n\t\twhile(k--)\n\t\t{\n\t\t\tscanf(\"%d %d\",&endx,&endy);\n\t\t\tmemset(visit,0,sizeof(visit));\n\t\t\tdfs(xx,yy,now);\n\t\t\tif (!first) num[xx][yy]--;\n\t\t\tfirst=0;\n\t\t\txx=endx;yy=endy;\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t for(int j=0;j<m;j++)\n\t\t  if (num[i][j])\n\t\t  {\n\t\t  \tans+=b[i][j]+c[i][j];\n\t\t  \tfor(int k=0;k<num[i][j]-1;k++)\n\t\t  \t{\n\t\t  \t\tint t=min(b[i][j]+c[i][j],\n\t\t\t\t\t\t (q[i][j][k+1]-q[i][j][k])*a[i][j]);\n\t\t  \t\tans+=t;\n\t\t  \t}\n\t\t  }\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_R 50\n#define MAX_C 50\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nbool inField(int x, int y, int C, int R)\n{\n    return (0 <= x && x < C && 0 <= y && y < R);\n}\n\nint main()\n{\n    int R, C, M;\n    char field[MAX_R][MAX_C];\n    cin >> R >> C >> M;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> field[i][j];\n        }\n    }\n    int cost[3][MAX_R][MAX_C];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < R; j++) {\n            for (int k = 0; k < C; k++) {\n                cin >> cost[i][j][k];\n            }\n        }\n    }\n    vector<int> X(M), Y(M);\n    for (int i = 0; i < M; i++) {\n        cin >> Y[i] >> X[i];\n    }\n\n    const int dx[] = {-1, 0, 1, 0};\n    const int dy[] = {0, -1, 0, 1};\n    \n    map<pii, vector<int>> vis;\n    int prev_d = 0;\n    for (int i = 1; i < M; i++) {\n        queue<pii> Q; Q.push(pii(X[i-1], Y[i-1]));\n        vector<vector<int>> d(MAX_R, vector<int>(MAX_C, INF));\n        vector<vector<int>> prev(MAX_R, vector<int>(MAX_C, INF));\n        d[Y[i-1]][X[i-1]] = prev_d;\n        while (!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            int x = p.first, y = p.second;\n            if (x == X[i] && y == Y[i]) {\n                prev_d = d[y][x];\n                break;\n            }\n            for (int j = 0; j < 4; j++) {\n                int nx = x + dx[j], ny = y + dy[j];\n                if (!inField(nx, ny, C, R) ||\n                    field[ny][nx] == '#') {\n                    continue;\n                }\n                if (d[y][x] + 1 < d[ny][nx]) {\n                    d[ny][nx] = d[y][x] + 1;\n                    prev[ny][nx] = y*C + x;\n                    Q.push(pii(nx, ny));\n                }\n            }\n        }\n        int x = X[i], y = Y[i];\n        vis[pii(x, y)].push_back(d[y][x]);           \n        while (x != X[i-1] || y != Y[i-1]) {           \n            int nx = x, ny = y;\n            nx = prev[y][x] % C;\n            ny = prev[y][x] / C;\n            x = nx; y = ny;\n            vis[pii(x, y)].push_back(d[y][x]);           \n        }\n    }\n    int sum = 0;\n    for (auto &v : vis) {\n        int x = v.first.first;\n        int y = v.first.second;\n        vector<int> p = v.second;\n        sum += cost[1][y][x] + cost[2][y][x];\n        if (p.size() > 1) {\n            for (int i = 1; i < (int)p.size(); i++) {\n                sum += min(cost[2][y][x] + cost[1][y][x], (p[i] - p[i-1]) * cost[0][y][x]);\n            }\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n};\n\ntemplate<typename T>\nusing Graph = vector<vector<edge<T>>>;\n\nusing State = string::const_iterator;\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    int R, C, M; cin >> R >> C >> M;\n    vector<string> S(R);\n    REP(i, R) cin >> S[i];\n\n    vvi cost(R, vi(C)), costOn(R, vi(C)), costOff(R, vi(C));\n    REP(i, R) {\n        REP(j, C) {\n            cin >> cost[i][j];\n        }\n    }\n    REP(i, R) {\n        REP(j, C) {\n            cin >> costOn[i][j];\n        }\n    }\n    REP(i, R) {\n        REP(j, C) {\n            cin >> costOff[i][j];\n        }\n    }\n\n    vi Y(M), X(M);\n    REP(i, M) cin >> Y[i] >> X[i];\n\n    const int dy[] = {0, 1, 0, -1};\n    const int dx[] = {1, 0, -1, 0};\n    vector<vvi> time(R, vvi(C));\n    int currentTime = 0;\n\n    REP(i, M-1) {\n        vvi dist(R, vi(C, INF));\n        vvi dir(R, vi(C, -1));\n        queue<pair<int,int>> que;\n        que.emplace(Y[i], X[i]);\n        dist[Y[i]][X[i]] = 0;\n        time[Y[i]][X[i]].push_back(currentTime);\n\n        while (!que.empty()) {\n            int y, x;\n            tie(y, x) = que.front(); que.pop();\n            if (y == Y[i+1] and x == X[i+1]) break;\n\n            REP(k, 4) {\n                int ny = y + dy[k];\n                int nx = x + dx[k];\n                if (ny < 0 or nx < 0 or R <= ny or C <= nx or S[ny][nx] == '#') continue;\n                if (chmin(dist[ny][nx], dist[y][x] + 1)) {\n                    dir[ny][nx] = k;\n                    que.emplace(ny, nx);\n                }\n            }\n        }\n\n        int y = Y[i+1], x = X[i+1];\n        while (y != Y[i] or x != X[i]) {\n            time[y][x].push_back(currentTime + dist[y][x]);\n            int k = dir[y][x];\n            y -= dy[k], x -= dx[k];\n        }\n\n        currentTime += dist[Y[i+1]][X[i+1]];\n    }\n\n    int total = 0;\n    REP(i, R) {\n        REP(j, C) {\n            if (time[i][j].empty()) continue;\n            int sum = costOn[i][j] + costOff[i][j];\n            REP(k, SZ(time[i][j])-1) {\n                sum += min(costOff[i][j] + costOn[i][j], cost[i][j] * (time[i][j][k+1] - time[i][j][k]));\n            }\n            total += sum;\n        }\n    }\n\n    cout << total << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nconst int dy[4] = {-1, 0, 0, 1};\nconst int dx[4] = {0, -1, 1, 0};\nint R, C, M;\nstring s[50];\nint p[50][50];\nint q[50][50];\nint r[50][50];\nint yy[1010], xx[1010];\nvector<int> t[50][50];\npii pre[50][50];\n\nbool contain(int y, int x) {\n  return y >= 0 && y < R && x >= 0 && x < C;\n}\n\nvector<pii> getPath(int idx) {\n  int sy = yy[idx], sx = xx[idx];\n  int gy = yy[idx+1], gx = xx[idx+1];\n  fill_n((pii*)pre, 50*50, pii(-1, -1));\n  pre[sy][sx] = pii(sy, sx);\n  queue<pii> que;\n  que.emplace(sy, sx);\n  while (!que.empty()) {\n    int y, x;\n    tie(y, x) = que.front();\n    que.pop();\n    for (int i = 0; i < 4; i++) {\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if (contain(ny, nx) && s[ny][nx] == '.' && pre[ny][nx].first < 0) {\n        pre[ny][nx] = pii(y, x);\n        que.emplace(ny, nx);\n      }\n    }\n  }\n  int y = gy, x = gx;\n  vector<pii> res;\n  while (!(y == sy && x == sx)) {\n    res.emplace_back(y, x);\n    tie(y, x) = pre[y][x];\n  }\n  reverse(res.begin(), res.end());\n  return res;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> R >> C >> M;\n  for (int i = 0; i < R; i++) {\n    cin >> s[i];\n  }\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      cin >> p[i][j];\n    }\n  }\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      cin >> q[i][j];\n    }\n  }\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      cin >> r[i][j];\n    }\n  }\n  for (int i = 0; i < M; i++) {\n    cin >> yy[i] >> xx[i];\n  }\n\n  int tm = 0, y = yy[0], x = xx[0];\n  t[y][x].emplace_back(tm++);\n  for (int i = 0; i < M-1; i++) {\n    vector<pii> path = getPath(i);\n    for (int j = 0; j < path.size(); j++) {\n      tie(y, x) = path[j];\n      t[y][x].emplace_back(tm++);\n    }\n  }\n  int ans = 0;\n  for (int i = 0; i < R; i++) {\n    for (int j = 0; j < C; j++) {\n      if (s[i][j] != '.') continue;\n      if (t[i][j].size() == 0) continue;\n      ans += q[i][j] + r[i][j];\n      for (int k = 0; k+1 < t[i][j].size(); k++) {\n        ans += min((t[i][j][k+1] - t[i][j][k]) * p[i][j], q[i][j] + r[i][j]);\n      }\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nenum { PER, ON, OFF };\nconst int INF = 1 << 30;\nconst int dc[] = {1, 0, -1, 0};\nconst int dr[] = {0, 1, 0, -1};\n\ntypedef struct\n{\n  int p[3];\n} Light;\n\nclass RC\n{\npublic:\n  int r, c;\n  RC(int _r = 0, int _c = 0)\n    :r(_r), c(_c) {}\n};\n\nint main()\n{\n  int R, C, M;\n  while (~scanf(\"%d %d %d\", &R, &C, &M)) {\n    vector<string> office(R);\n    for (int r = 0; r < R; ++r)\n      cin >> office[r];\n\n    vector<vector<Light> > cost(R, vector<Light>(C));\n    for (int i = 0; i < 3; ++i) {\n      for (int r = 0; r < R; ++r) {\n\tfor (int c = 0; c < C; ++c)\n\t  scanf(\"%d\", &cost[r][c].p[i]);\n      }\n    }\n  \n    vector<RC> task(M);\n    for (int i = 0; i < M; ++i)\n      scanf(\"%d %d\", &task[i].r, &task[i].c);\n\n\n    vector<vector<vector<vector<int> > > > path(R, vector<vector<vector<int> > >(C, vector<vector<int> >(R, vector<int>(C, INF))));\n    for (int r = 0; r < R; ++r) {\n      for (int c = 0; c < C; ++c) {\n\tif (office[r][c] == '#')\n\t  continue;\n\n\tpath[r][c][r][c] = 0;\n\tqueue<RC> que;\n\tvector<vector<int> > visited(R, vector<int>(C, 0));\n\tque.push(RC(r, c));\n\twhile (!que.empty()) {\n\t  RC rc = que.front();\n\t  que.pop();\n\t  visited[rc.r][rc.c] = 1;\n\t  for (int d = 0; d < 4; ++d) {\n\t    int rr = rc.r + dr[d];\n\t    int cc = rc.c + dc[d];\n\t    if (rr < 0 || rr >= R || cc < 0 || cc >= C || office[rr][cc] == '#' || visited[rr][cc])\n\t\tcontinue;\n\t    path[r][c][rr][cc] = path[r][c][rc.r][rc.c]+1;\n\t    que.push(RC(rr, cc));\n\t  }\n\t}\n      }\n    }\n\n\n    int time = 0;\n    vector<vector<vector<int> > > pass(R, vector<vector<int> >(C));\n    for (int i = 0; i < M-1; ++i) {\n      RC s = task[i], t = task[i+1];\n      while (s.r != t.r || s.c != t.c) {\n\tpass[s.r][s.c].push_back(time++);\n\tfor (int d = 0; d < 4; ++d) {\n\t  int rr = s.r + dr[d];\n\t  int cc = s.c + dc[d];\n\t  if (rr < 0 || rr >= R || cc < 0 || cc >= C)\n\t    continue;\n\t  if (path[rr][cc][t.r][t.c]+1 == path[s.r][s.c][t.r][t.c]) {\n\t    s.r = rr;\n\t    s.c = cc;\n\t    break;\n\t  }\n\t}\n      }\n    }\n    // fix\n    pass[task[M-1].r][task[M-1].c].push_back(time);\n\n    int ans = 0;\n    for (int r = 0; r < R; ++r) {\n      for (int c = 0; c < C; ++c) {\n\tif (pass[r][c].empty())\n\t  continue;\n\n\tconst int on_off = cost[r][c].p[ON] + cost[r][c].p[OFF];\n\tans += on_off * pass[r][c].size();\n\n\tfor (unsigned int i = 0; i < pass[r][c].size()-1; ++i) {\n\t  const int per = (pass[r][c][i+1] - pass[r][c][i]) * cost[r][c].p[PER];\n\t  if (per < on_off)\n\t    ans -= (on_off- per);\n\t}\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            adjlist[M[make_pair(i, j)]].push_back(M[make_pair(ni, nj)]);\n                            //adjlist[M[make_pair(ni, nj)]].push_back(M[make_pair(i, j)]);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<int> node;         //訪れる頂点の順番の配列\n    node.push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<int> temp_node;\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, temp_node, used);\n        node.insert(node.end(), temp_node.begin(), temp_node.end());\n    }\n    \n\n    //訪れる時刻\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        t[node[i]].push_back(i);\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\n#include<stack>\n#include<string>\n#include<bitset>\n#define LL long long\n\nconst int MAXN=57;\nconst int MAXM=10007;\nconst long long LLINF=9000000000000000000;\nconst int INF=2000000000;//careful because of floyed and so on\nconst int MOD=1000000007;\ndouble eps=0.00000001;\n\nusing namespace std;\n\nstruct Point{\n    int x,y;\n};\n\nconst int u[4]={0,0,1,-1};\nconst int w[4]={1,-1,0,0};\n\nint n,m,q;\nchar s[MAXN][MAXN];\nvector<int> t[MAXN][MAXN];\nint on[MAXN][MAXN];\nint off[MAXN][MAXN];\nint cost[MAXN][MAXN];\nint x[MAXM],y[MAXM];\nbool vis[MAXN][MAXN];\nint d[MAXN][MAXN];\n\nvoid work(int bx,int by,int ex,int ey){\n    queue<Point>Q;\n    memset(vis,0,sizeof(vis));\n    Q.push((Point){bx,by});\n    d[bx][by]=t[bx][by][t[bx][by].size()-1];\n    vis[bx][by]=1;\n    while (!Q.empty()){\n            Point now=Q.front();\n            Q.pop();\n            for (int i=0;i<4;i++){\n                    int x=now.x+u[i];\n                    int y=now.y+w[i];\n                    if (x<=0 || y<=0 || x>n || y>m || s[x][y]=='#' || vis[x][y]) continue;\n                    vis[x][y]=1;\n                    d[x][y]=d[now.x][now.y]+1;\n                    Q.push((Point){x,y});\n            }\n    }\n    Q.push((Point){ex,ey});\n    while (!Q.empty()){\n            Point now=Q.front();\n            if (now.x==bx && now.y==by) break;\n            t[now.x][now.y].push_back(d[now.x][now.y]);\n            Q.pop();\n            for (int i=0;i<4;i++){\n                    int x=now.x+u[i];\n                    int y=now.y+w[i];\n                    if (x<=0 || y<=0 || x>n || y>m || s[x][y]=='#' || d[x][y]!=d[now.x][now.y]-1) continue;\n                    Q.push((Point){x,y});\n            }\n    }\n}\n\nint main(){\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for (int i=1;i<=n;i++){\n            scanf(\"%s\",s[i]+1);\n    }\n    for (int i=1;i<=n;i++){\n            for (int j=1;j<=m;j++){\n                    scanf(\"%d\",&cost[i][j]);\n            }\n    }\n    for (int i=1;i<=n;i++){\n            for (int j=1;j<=m;j++){\n                    scanf(\"%d\",&on[i][j]);\n            }\n    }\n    for (int i=1;i<=n;i++){\n            for (int j=1;j<=m;j++){\n                    scanf(\"%d\",&off[i][j]);\n            }\n    }\n    for (int i=1;i<=q;i++){\n            scanf(\"%d%d\",&x[i],&y[i]);\n            x[i]++;\n            y[i]++;\n    }\n    t[x[1]][y[1]].push_back(0);\n    for (int i=2;i<=q;i++){\n            work(x[i-1],y[i-1],x[i],y[i]);\n    }\n    int ans=0;\n    for (int i=1;i<=n;i++){\n            for (int j=1;j<=m;j++){\n                    if (t[i][j].size()>=1){\n                            ans=ans+on[i][j]+off[i][j];\n                    }\n                    for (int k=1;k<(int)t[i][j].size();k++){\n                            ans+=min(on[i][j]+off[i][j],(t[i][j][k]-t[i][j][k-1])*cost[i][j]);\n                    }\n            }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,short int> mp;\n  vector<int> V;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        V.push_back(i*C+j);\n        ++n;\n      }\n    }\n  }\n  vector< vector< vector<short int> > > G(n,vector< vector<short int> >(n));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        short int v = mp[x_*C+y_];\n        G[i][v].push_back(v);\n      }\n    }\n  }\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<short int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  vector< vector<int> > P(R, vector<int>(C)), ON = P, OFF = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> ON[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OFF[i][j];\n  vector<int> X(M), Y(M);\n  for(int i = 0; i < M; ++i)\n    cin >> X[i] >> Y[i];\n  vector<int> T(n,-1);\n  T[mp[X[0]*C+Y[0]]] = 0;\n  int t = 0;\n  long long int ans = ON[X[0]][Y[0]] + OFF[X[0]][Y[0]];\n  for(int i = 0; i < M-1; ++i){\n    int v = mp[X[i]*C+Y[i]], v_ = mp[X[i+1]*C+Y[i+1]];\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += ON[r][c] + OFF[r][c];\n      }else{\n        ans += min(ON[r][c] + OFF[r][c], P[r][c]*(t-T[k]));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\ntypedef pair<int,int> pii;\n\nconst int inf = 1<<29;\nint r,c,m;\nstring room[51];\nint on[51][51],off[51][51],con[51][51];\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool in(int y,int x) {\n    if(x < 0 || x >= c) return false;\n    if(y < 0 || y >= r) return false;\n    if(room[y][x] == '#') return false;\n    return true;\n}\n\nvector<pii> bfs(int sy,int sx,int gy,int gx) {\n    int dist[51][51];\n    rep(i,r) rep(j,c) dist[i][j] = -1;\n    dist[sy][sx] = 0;\n    queue<pii> q; q.push(make_pair(sy,sx));\n\n    while(!q.empty()) {\n        pii p = q.front(); q.pop();\n        for(int k=0; k<4; ++k) {\n            int nx = p.second+dx[k],ny = p.first+dy[k];\n            if(!in(ny,nx) || dist[ny][nx] != -1) continue;\n            dist[ny][nx] = dist[p.first][p.second]+1;\n            q.push(make_pair(ny,nx));\n        }\n    }\n\n    vector<pii> ret;\n    int r = dist[gy][gx],x = gx,y = gy;\n    while(true) {\n        if(x == sx && y == sy) break;\n        ret.push_back(make_pair(y,x));\n        for(int k=0; k<4; ++k) {\n            int nx = x+dx[k],ny = y+dy[k];\n            if(!in(ny,nx) || dist[ny][nx]+1 != dist[y][x]) continue;\n            x = nx,y = ny;\n            break;\n        }\n    }\n    reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nint main() {\n    cin>>r>>c>>m;\n    rep(i,r) cin>>room[i];\n\n    rep(i,r) rep(j,c) cin>>con[i][j];\n    rep(i,r) rep(j,c) cin>>on[i][j];\n    rep(i,r) rep(j,c) cin>>off[i][j];\n\n    vector<pii> root;\n    int a,b,x,y;\n    cin>>a>>b;\n    root.push_back(make_pair(a,b));\n    rep(i,m-1) {\n        cin>>x>>y;\n        vector<pii> r = bfs(a,b,x,y);\n        for(int j=0; j<r.size(); ++j)\n            root.push_back(r[j]);\n        a=x,b=y;\n    }\n\n    vector<int> app[r*c];\n    rep(i,r) rep(j,c) app[i*c+j].clear();\n\n    rep(i,root.size()) {\n        int y = root[i].first,x = root[i].second;\n        app[y*c+x].push_back(i);\n    }\n\n    int ans = 0;\n    rep(i,r) rep(j,c) {\n        vector<int> &v = app[i*c+j];\n        if(!v.empty()) ans += on[i][j];\n        for(int k=1; k<v.size(); ++k)\n            ans += min((v[k]-v[k-1])*con[i][j],on[i][j]+off[i][j]);\n        if(!v.empty()) ans += off[i][j];\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <queue>\n#include <iostream>\nusing namespace std;\n\ntypedef struct\n{\n  int c[3];\n} Light;\n\nclass Point\n{\npublic:\n  int r, c;\n  Point(int _r = 0, int _c = 0)\n    :r(_r), c(_c) {}\n};\n\nclass State\n{\npublic:\n  int t;\n  Point p;\n  vector<Point> path;\n  State() {}\n  State(int _t, Point _p)\n    :t(_t), p(_p) {}\n  void update(Point p)\n  {\n    this->t += 1;\n    this->p = p;\n  }\n  bool operator < (const State& st) const\n  {\n    return this->t > st.t;\n  }\n};\n\nenum {PER, ON, OFF};\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nint main()\n{\n  int R, C, M;\n  while (~scanf(\"%d %d %d\", &R, &C, &M)) {\n    vector<string> office(R);\n    for (int i = 0; i < R; ++i)\n      cin >> office[i];\n\n    vector<vector<Light> > cost(R, vector<Light>(C));\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < R; ++j) {\n\tfor (int k = 0; k < C; ++k)\n\t  scanf(\"%d\", &cost[j][k].c[i]);\n      }\n    }\n\n    vector<Point> task(M);\n    for (int i = 0; i < M; ++i)\n      scanf(\"%d %d\", &task[i].r, &task[i].c);\n\n    int time = 0;\n    vector<vector<vector<int> > > pass(R, vector<vector<int> >(C));\n    for (int i = 0; i < M-1; ++i) {\n      State st, tmp;\n      priority_queue<State> que;\n      que.push(State(time, Point(task[i].r, task[i].c)));\n\n      while (!que.empty()) {\n\tst = que.top();\n\tque.pop();\n\n\tst.path.push_back(st.p);\n\tif (st.p.r == task[i+1].r && st.p.c == task[i+1].c)\n\t  break;\n\n\tfor (int j = 0; j < 4; ++j) {\n\t  tmp = st;\n\t  Point p(st.p.r+dy[j], st.p.c+dx[j]);\n\t  if (p.r < 0 || p.r >= R || p.c < 0 || p.c >= C || office[p.r][p.c] == '#')\n\t      continue;\n\t  tmp.update(p);\n\t  que.push(tmp);\n\t}\n      }\n\n      for (unsigned int j = 0; j < st.path.size()-1; ++j) {\n\tconst Point& p = st.path[j];\n\tpass[p.r][p.c].push_back(time + j);\n      }\n      time = st.t;\n    }\n\n    // fix\n    pass[task[task.size()-1].r][task[task.size()-1].c].push_back(time);\n\n    int ans = 0;\n    for (int i = 0; i < R; ++i) {\n      for (int j = 0; j < C; ++j) {\n\tif (pass[i][j].empty())\n\t  continue;\n\tconst int ON_OFF = cost[i][j].c[ON] + cost[i][j].c[OFF];\n\tans += ON_OFF * pass[i][j].size();\n\tif (pass[i][j].size() == 1)\n\t  continue;\n\tfor (unsigned int k = 0; k < pass[i][j].size()-1; ++k) {\n\t  const int per = (pass[i][j][k+1] - pass[i][j][k]) * cost[i][j].c[PER];\n\t  if (per < ON_OFF) {\n\t    ans -= ON_OFF;\n\t    ans += per;\n\t  }\n\t}\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\n\nconst int dx[]={1,0,0,-1};\nconst int dy[]={0,1,-1,0};\n\nconst int N = 55;\nqueue<int> q;\nvector<int> path;\nchar mp[N][N];\nint vis[N][N], pre[N][N], t[N*N];\nint val[N][N], op[N][N], cl[N][N];\nint n, m, K, X[N*N], Y[N*N];\nvoid BFS(int sx, int sy, int ex, int ey) {\n\twhile(!q.empty()) q.pop();\n\tmemset(vis, -1, sizeof vis);\n\tmemset(pre, -1, sizeof pre);\n\n\tvis[sx][sy] = 0;\n\tq.push(sx*N+sy);\n\twhile(!q.empty()) {\n\t\tint tmp = q.front(); q.pop();\n\t\tint x = tmp / N, y = tmp % N;\n\t\tif(x == ex && y == ey) break;//continue;\n\t\t\n\t\tfor(int di = 0; di < 4; di ++) {\n\t\t\tint nx = x + dx[di], ny = y + dy[di];\n\t\t\tif(nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n\t\t\tif(vis[nx][ny] != -1 || mp[nx][ny] == '#') continue;\n\t\t\t\n\t\t\tvis[nx][ny] = vis[x][y] + 1;\n\t\t\tpre[nx][ny] = x*N+y;\n\t\t\tq.push(nx*N+ny);\n\t\t}\n\t}\n\t\n\tint size = 0, x = ex, y = ey;\n\twhile(pre[x][y] != -1) {\n\t\tint tmp = pre[x][y];\n\t\tt[size++] = tmp;\n\t\tx = tmp / N;\n\t\ty = tmp % N;\n\t}\n\tfor(int i = size-1; i >= 0; i --) path.push_back(t[i]);\n\n}\nvoid input() {\n\tfor(int i = 0; i < n; i ++)\n\t\tscanf(\"%s\", mp[i]);\n\n\tfor(int i = 0; i < n; i ++) {\n\t\tfor(int j = 0; j < m; j ++) {\n\t\t\tscanf(\"%d\", &val[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i ++) {\n\t\tfor(int j = 0; j < m; j ++) {\n\t\t\tscanf(\"%d\", &op[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i ++) {\n\t\tfor(int j = 0; j < m; j ++) {\n\t\t\tscanf(\"%d\", &cl[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0; i < K; i ++) {\n\t\tscanf(\"%d%d\", &X[i], &Y[i]);\n\t}\n}\nint main() {\n\twhile(~scanf(\"%d%d%d\", &n, &m, &K)) {\n\t\tinput();\n\t\t//\n\t\tpath.clear();\n\t\tfor(int i = 1; i < K; i ++) {\n\t\t\tBFS(X[i-1], Y[i-1], X[i], Y[i]);\n\t\t}\n\t\tpath.push_back(X[K-1]*N+Y[K-1]);\n\t\t\n\t\tmemset(pre, -1, sizeof pre);\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < (int)path.size(); i ++) {\n\t\t\tint x = path[i]/N, y = path[i]%N;\n\t\t\tif(pre[x][y] == -1) {\n\t\t\t\tans += op[x][y] + cl[x][y];\n\t\t\t} else {\n\t\t\t\tint tmp = (i - pre[x][y]) * val[x][y];\n\t\t\t\ttmp = min(tmp, op[x][y] + cl[x][y]);\n\t\t\t\tans += tmp;\n\t\t\t}\n\t\t\tpre[x][y] = i;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_R 50\n#define MAX_C 50\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nbool inField(int x, int y, int C, int R)\n{\n    return (0 <= x && x < C && 0 <= y && y < R);\n}\n\nint main()\n{\n    int R, C, M;\n    char field[MAX_R][MAX_C];\n    cin >> R >> C >> M;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> field[i][j];\n        }\n    }\n    int cost[3][MAX_R][MAX_C];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < R; j++) {\n            for (int k = 0; k < C; k++) {\n                cin >> cost[i][j][k];\n            }\n        }\n    }\n    vector<int> X(M), Y(M);\n    for (int i = 0; i < M; i++) {\n        cin >> Y[i] >> X[i];\n    }\n\n    const int dx[] = {-1, 0, 1, 0};\n    const int dy[] = {0, -1, 0, 1};\n    \n    map<pii, vector<int>> vis;\n    int prev_d = 0;\n    for (int i = 1; i < M; i++) {\n        queue<pii> Q; Q.push(pii(X[i-1], Y[i-1]));\n        vector<vector<int>> d(MAX_R, vector<int>(MAX_C, INF));\n        vector<vector<int>> prev(MAX_R, vector<int>(MAX_C, INF));\n        d[Y[i-1]][X[i-1]] = prev_d;\n        while (!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            int x = p.first, y = p.second;\n            if (x == X[i] && y == Y[i]) {\n                prev_d = d[y][x];\n                break;\n            }\n            for (int j = 0; j < 4; j++) {\n                int nx = x + dx[j], ny = y + dy[j];\n                if (!inField(nx, ny, C, R) ||\n                    field[ny][nx] == '#') {\n                    continue;\n                }\n                if (d[y][x] + 1 < d[ny][nx]) {\n                    d[ny][nx] = d[y][x] + 1;\n                    prev[ny][nx] = y*C + x;\n                    Q.push(pii(nx, ny));\n                }\n            }\n        }\n        int x = X[i], y = Y[i];\n        vis[pii(x, y)].push_back(d[y][x]);           \n        while (x != X[i-1] || y != Y[i-1]) {           \n            int nx = x, ny = y;\n            nx = prev[y][x] % C;\n            ny = prev[y][x] / C;\n            x = nx; y = ny;\n            vis[pii(x, y)].push_back(d[y][x]);           \n        }\n    }\n    int sum = 0;\n    for (auto &v : vis) {\n        int x = v.first.first;\n        int y = v.first.second;\n        vector<int> p = v.second;\n        sum += cost[1][y][x] + cost[2][y][x];\n        if (p.size() > 1) {\n            for (int i = 1; i < (int)p.size(); i++) {\n                sum += min(cost[2][y][x] + cost[1][y][x], (p[i] - p[i-1]) * cost[0][y][x]);\n            }\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> >& adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    cout << a << \" \";\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    //o\n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        int a = M[make_pair(x[i - 1], y[i - 1])];\n        int b = M[make_pair(x[i], y[i])];\n        vector<bool> used(num, false);\n        bool end = false;\n        used[a] = true;\n        dfs(end, a, b, adjlist, node[i], used);\n    }\n\n\n    //x\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n\n    typedef long long Long;\n\n    struct Point {\n        int y, x;\n        Point() {}\n        Point(int y, int x) : y(y), x(x) {}\n    };\n    ostream& operator<<(ostream& os, const Point& p) {\n        return os << \"Point(\" << p.y << \",\" << p.x << \")\";\n    }\n\n    int R, C, M;\n    vector<string> F;\n    vector< vector<Long> > cost, onCost, offCost;\n    vector<Point> V;\n    void input() {\n        cin >> R >> C >> M;\n        F.clear(); F.resize(R);\n        for (int i = 0; i < R; i++) cin >> F[i];\n        cost.clear(); cost.resize(R, vector<Long>(C, 0));\n        onCost.clear(); onCost.resize(R, vector<Long>(C, 0));\n        offCost.clear(); offCost.resize(R, vector<Long>(C, 0));\n        for (int i = 0; i < R; i++) for (int j = 0; j < C; j++) cin >> cost[i][j];\n        for (int i = 0; i < R; i++) for (int j = 0; j < C; j++) cin >> onCost[i][j];\n        for (int i = 0; i < R; i++) for (int j = 0; j < C; j++) cin >> offCost[i][j];\n        V.clear(); V.resize(M);\n        for (int i = 0; i < M; i++) {\n            int y, x; cin >> y >> x;\n            V[i] = Point(y, x);\n        }\n    }\n\n    struct S {\n        int y, x;\n        int py, px;\n        S() {}\n        S(int y, int x, int py, int px) : y(y), x(x), py(py), px(px) {}\n    };\n\n    vector< vector< queue<int> > > X;\n    const int INF = 1<<28;\n\n    const int dy[] = {-1, 0, 1, 0};\n    const int dx[] = {0, 1, 0, -1};\n\n    void bfs(int sy, int sx, int gy, int gx, int& t) {\n        queue<S> Q;\n        vector< vector<int> > D(R, vector<int>(C, INF));\n        vector< vector<Point> > P(R, vector<Point>(C));\n        Q.push(S(sy, sx, -1, -1));\n        D[sy][sx] = 0;\n        while (!Q.empty()) {\n            S c = Q.front(); Q.pop();\n            int y = c.y, x = c.x;\n            for (int i = 0; i < 4; i++) {\n                int ny = y + dy[i],\n                    nx = x + dx[i];\n                if (ny < 0 || ny >= R) continue;\n                if (nx < 0 || nx >= C) continue;\n                if (F[ny][nx] == '#') continue;\n                if (D[ny][nx] <= D[y][x] + 1) continue;\n                D[ny][nx] = D[y][x] + 1;\n                P[ny][nx] = Point(y, x);\n                Q.push(S(ny, nx, y, x));\n            }\n        }\n        int cy = gy, cx = gx;\n        while (cy != sy || cx != sx) {\n            X[cy][cx].push(D[cy][cx] + t);\n            int ny = P[cy][cx].y,\n                nx = P[cy][cx].x;\n            cy = ny;\n            cx = nx;\n        }\n        t += D[gy][gx];\n    }\n\n    void solve() {\n        X.clear(); X.resize(R, vector< queue<int> >(C));\n        int y = V[0].y, x = V[0].x;\n        X[y][x].push(0);\n        int t = 0;\n        for (int i = 1; i < M; i++) {\n            int gy = V[i].y, gx = V[i].x;\n            bfs(y, x, gy, gx, t);\n            y = gy; x = gx;\n        }\n        Long ans = 0;\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < C; j++) {\n                queue<int>& Q = X[i][j];\n                while (!Q.empty()) {\n                    Long s = Q.front(); Q.pop();\n                    if (Q.empty()) {\n                        ans += offCost[i][j] + onCost[i][j];\n                    } else {\n                        Long t = Q.front();\n                        ans += min(cost[i][j] * (t - s), offCost[i][j] + onCost[i][j]);\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\nint main() {\n    input(); solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 60, PMAX = 1010;\nconst int dl[] = {1, 0, -1, 0};\nconst int dc[] = {0, 1, 0, -1};\n\nint N, M, Q;\nchar A[NMAX][NMAX];\nint B[NMAX][NMAX];\nint C[NMAX][NMAX];\nint D[NMAX][NMAX];\nint Dist[NMAX][NMAX];\nlist<int> E[NMAX][NMAX];\npair<int, int> from[NMAX][NMAX];\nbool witness[NMAX][NMAX];\n\nvoid getPath(int startX, int startY, int finishX, int finishY, vector<pair<int, int>> &dest) {\n\tqueue<pair<int, int>> Q;\n\n\tmemset(witness, 0, sizeof witness);\n\tQ.push({startX, startY});\n\twitness[startX][startY] = 1;\n\tDist[startX][startY] = 0;\n\tbool found = 0;\n\twhile (!Q.empty()) {\n\t\tint currX, currY;\n\t\ttie(currX, currY) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint newX = currX + dl[i];\n\t\t\tint newY = currY + dc[i];\n\t\t\tif (newX < 0 || newX >= N || newY < 0 || newY >= M)\n\t\t\t\tcontinue;\n\t\t\tif (A[newX][newY] != '.' || witness[newX][newY])\n\t\t\t\tcontinue;\n\t\t\tfrom[newX][newY] = {currX, currY};\n\t\t\tDist[newX][newY] = Dist[currX][currY] + 1;\n\t\t\twitness[newX][newY] = 1;\n\t\t\tQ.push({newX, newY});\n\t\t\tif (newX == finishX && newY == finishY) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tassert(found);\n\tint currX, currY;\n\ttie(currX, currY) = from[finishX][finishY];\n\tint newSize = dest.size() + Dist[currX][currY];\n\tassert(newSize < 2500000);\n\tdest.resize(newSize);\n\t--newSize;\n\twhile (currX != startX || currY != startY) {\n\t\tdest[newSize--] = {currX, currY};\n\t\ttie(currX, currY) = from[currX][currY];\n\t}\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tscanf(\"%d %d %d\", &N, &M, &Q);\n\tfor (i = 0; i < N; ++i)\n\t\tscanf(\"%s\", A[i]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &B[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &C[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &D[i][j]);\n\n\tvector<pair<int, int>> path;\n\tint lastX, lastY, currX, currY;\n\tscanf(\"%d %d\", &lastX, &lastY);\n\twhile (Q-- > 1) {\n\t\tscanf(\"%d %d\", &currX, &currY);\n\t\tassert(lastX != currX || lastY != currY);\n\t\tpath.push_back({lastX, lastY});\n\t\tgetPath(lastX, lastY, currX, currY, path);\n\t\tlastX = currX, lastY = currY;\n\t}\n\tpath.push_back({lastX, lastY});\n\n\tassert(path.size() < 2500000);\n\n\tfor (size_t i = 0; i < path.size(); ++i)\n\t\tE[path[i].first][path[i].second].push_back(i);\n\n\tbool lightOn[NMAX][NMAX] = {};\n\tint answer = 0;\n\tint currAdd = 0;\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tanswer += currAdd;\n\t\tif (!lightOn[path[i].first][path[i].second])\n\t\t\tanswer += C[path[i].first][path[i].second];\n\t\tE[path[i].first][path[i].second].pop_front();\n\t\tint front = E[path[i].first][path[i].second].front();\n\t\tif (E[path[i].first][path[i].second].size() && (front - i) * B[path[i].first][path[i].second] < C[path[i].first][path[i].second] + D[path[i].first][path[i].second]) {\n\t\t\tif (!lightOn[path[i].first][path[i].second])\n\t\t\t\tcurrAdd += B[path[i].first][path[i].second];\n\t\t\tlightOn[path[i].first][path[i].second] = 1;\n\t\t} else {\n\t\t\tif (lightOn[path[i].first][path[i].second])\n\t\t\t\tcurrAdd -= B[path[i].first][path[i].second];\n\t\t\tlightOn[path[i].first][path[i].second] = 0;\n\t\t\tanswer += D[path[i].first][path[i].second];\n\t\t}\n\t}\n\n\tcout << answer << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n\nint h,w,n;\nstring s[55];\nll c[55][55][3]; // 0 using / 1 on / 2 off\nll vi[1111],vj[1111];\nll dist[55][55];\nvector<ll> t[55][55];\nll dp[1010][2];\n\nint dd[]={-1,0,1,0,-1};\n\nvoid dfs(int i,int j,int prei,int prej,ll sum,ll dst[55][55]){\n  dst[i][j]=sum;\n  rep(d,4){\n    int ni=i+dd[d],nj=j+dd[d+1];\n    if(ni==prei&&nj==prej)continue;\n    if(ni>=0&&ni<h&&nj>=0&&nj<w&&s[ni][nj]!='#')dfs(ni,nj,i,j,sum+1,dst);\n  }\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>h>>w>>n;\n  rep(i,h)cin>>s[i];\n  rep(k,3)rep(i,h)rep(j,w)cin>>c[i][j][k];\n  rep(i,n)cin>>vi[i]>>vj[i];\n  ll nt=0;\n  t[vi[0]][vj[0]].push_back(0);\n  rep(i,n-1){\n    memset(dist,0,sizeof(dist));\n    dfs(vi[i],vj[i],-1,-1,0,dist);\n    ll ni=vi[i+1],nj=vj[i+1];\n    while(dist[ni][nj]!=0){\n      t[ni][nj].push_back(nt+dist[ni][nj]);\n      rep(d,4){\n        int nni=ni+dd[d],nnj=nj+dd[d+1];\n        if(ni>=0&&ni<h&&nj>=0&&nj<w&&dist[nni][nnj]+1==dist[ni][nj]){\n          ni=nni; nj=nnj;\n          break;\n        }\n      }\n    }\n    nt+=dist[vi[i+1]][vj[i+1]];\n  }\n  ll res=0;\n  rep(i,h)rep(j,w){\n    if(t[i][j].size()==0)continue;\n    rep(k,1010)rep(l,2)dp[k][l]=INF;\n    dp[1][0]=c[i][j][1]+c[i][j][2];\n    dp[1][1]=c[i][j][1];\n    ll m=t[i][j].size();\n    repl(k,1,m)rep(l,2){\n      if(dp[k][l]==INF)continue;\n      ll pt=t[i][j][k]-t[i][j][k-1];\n      if(l==0){\n        minch(dp[k+1][0],dp[k][l]+c[i][j][1]+c[i][j][2]);\n        minch(dp[k+1][1],dp[k][l]+c[i][j][1]);\n      }else{\n        minch(dp[k+1][0],dp[k][l]+c[i][j][2]+pt*c[i][j][0]);\n        minch(dp[k+1][1],dp[k][l]+pt*c[i][j][0]);\n      }\n    }\n    //dbg(dp[m][0]);\n    res+=dp[m][0];\n  }\n  cout<<res<<endl;\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int MAX_SIZE = 50;\nconst int MAX_TASK_SIZE = 1000;\n\nint R, C, M, a = 0;\nint p[MAX_SIZE][MAX_SIZE] = {};\nchar f[MAX_SIZE][MAX_SIZE];\nint costs[3][MAX_SIZE][MAX_SIZE];\n\nint move(P src, P des, int t) {\n  if (src == des) {\n    return t;\n  }\n  f[src.first][src.second] = '@';\n  int ret = 0;\n  int dr[] = {-1, 1, 0, 0};\n  int dc[] = {0, 0, -1, 1};\n  for (int k = 0; k < 4; ++k) {\n    int i = src.first  + dr[k];\n    int j = src.second + dc[k];\n    if (i + 1 && j + 1 && i < R && j < C && f[i][j] == '.') {\n      ret = move(P(i, j), des, t + 1);\n      if (ret) {\n        int cost = costs[1][i][j] + costs[2][i][j];\n        a += cost;\n        if (p[i][j]) {\n          int d = (t - p[i][j]) * costs[0][i][j] - cost;\n          if (d < 0) a += d;\n        }\n        p[i][j] = t;\n        break;\n      }\n    }\n  }\n  f[src.first][src.second] = '.';\n  return ret;\n}\n\nint calc(P tasks[]) {\n  int t = 1;\n  int i0 = tasks[0].first, j0 = tasks[0].second;\n  a = costs[1][i0][j0] + costs[2][i0][j0];\n  p[i0][j0] = t++;\n  for (int i = 0; i < M - 1; ++i) {\n    t = move(tasks[i], tasks[i + 1], t);\n  }\n  return a;\n}\n\nint main() {\n  int n;\n  P tasks[MAX_TASK_SIZE];\n  char s[MAX_SIZE + 1];\n  cin >> R >> C >> M;\n  for (int i = 0; i < R; ++i) {\n    cin >> s;\n    for (int j = 0; j < C; ++j) {\n      f[i][j] = s[j];\n    }\n  }\n  for (int k = 0; k < 3; ++k) {\n    for (int i = 0; i < R; ++i) {\n      for (int j = 0; j < C; ++j) {\n        cin >> n;\n        costs[k][i][j] = n;\n      }\n    }\n  }\n  for (int i = 0; i < M; ++i) {\n    int r, c;\n    cin >> r >> c;\n    tasks[i] = P(r, c);\n  }\n  cout << calc(tasks) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int dir[4][2]={{-1,0},{1,0},{0,-1},{0,1}};\nconst int MaxR=52;\nconst int MaxM=1020;\n\nstruct Node {\n    int x,y;\n}m[MaxM],p[MaxR][MaxR];\n\nint R,C,M,Ans;\nchar a[MaxR][MaxR];\nint b[MaxR][MaxR],c[MaxR][MaxR],d[MaxR][MaxR],t[MaxR][MaxR];\nbool Vis[MaxR][MaxR];\n\nbool InM(int x,int y)\n{\n    return x>=0 && x<R && y>=0 && y<C;\n}\n\nvoid BFS(int sx,int sy,int gx,int gy)\n{\n    memset(Vis,0,sizeof(Vis));\n    memset(p,0,sizeof(p));\n    queue<Node> Q;\n    Node Qf,Nt;\n    Nt.x = sx;\n    Nt.y = sy;\n    Q.push(Nt);\n    Vis[sx][sy] = true;\n    while ( !Q.empty() )\n    {\n        Qf = Q.front();\n        Q.pop();\n        for ( int i=0;i<4;i++ )\n        {\n            Nt.x = Qf.x+dir[i][0];\n            Nt.y = Qf.y+dir[i][1];\n            if ( InM(Nt.x,Nt.y) && a[Nt.x][Nt.y]=='.' && !Vis[Nt.x][Nt.y] )\n            {\n                Q.push(Nt);\n                Vis[Nt.x][Nt.y] = true;\n                p[Nt.x][Nt.y].x = Qf.x;\n                p[Nt.x][Nt.y].y = Qf.y;\n                if ( Nt.x==gx && Nt.y==gy )  return ;\n            }\n        }\n    }\n}\n\nint DFS(int sx,int sy,int gx,int gy)\n{\n    if ( sx==gx && sy==gy )\n    {\n        return t[sx][sy];\n    }\n    int tt=DFS(sx,sy,p[gx][gy].x,p[gx][gy].y)+1;\n    Ans += c[gx][gy]+d[gx][gy];\n    if ( t[gx][gy] )\n    {\n        if ( c[gx][gy]+d[gx][gy]>(tt-t[gx][gy])*b[gx][gy] )\n            Ans += (tt-t[gx][gy])*b[gx][gy]-(c[gx][gy]+d[gx][gy]);\n    }\n    return  t[gx][gy]=tt;\n}\n\nint main()\n{\n    while ( scanf(\"%d %d %d\",&R,&C,&M)!=EOF )\n    {\n        for ( int i=0;i<R;i++ )\n            scanf(\"%s\",a[i]);\n        for ( int i=0;i<R;i++ )\n         for ( int j=0;j<C;j++ )\n            scanf(\"%d\",&b[i][j]);\n        for ( int i=0;i<R;i++ )\n         for ( int j=0;j<C;j++ )\n            scanf(\"%d\",&c[i][j]);\n        for ( int i=0;i<R;i++ )\n         for ( int j=0;j<C;j++ )\n            scanf(\"%d\",&d[i][j]);\n        for ( int i=0;i<M;i++ )\n            scanf(\"%d %d\",&m[i].x,&m[i].y);\n        memset(t,0,sizeof(t));\n        t[m[0].x][m[0].y] = 1;\n        Ans = c[m[0].x][m[0].y]+d[m[0].x][m[0].y];\n        for ( int i=0;i<M-1;i++ )\n        {\n            BFS(m[i].x,m[i].y,m[i+1].x,m[i+1].y);\n            DFS(m[i].x,m[i].y,m[i+1].x,m[i+1].y);\n        }\n        printf(\"%d\\n\",Ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=53,INF=1<<20;\nint H,W,Q,t=1;\nint costuse[MAX][MAX],coston[MAX][MAX],costoff[MAX][MAX];\nvector<int> when[MAX][MAX];\nbool room[MAX][MAX];\n\nvector<int> dh={0,1,0,-1},dw={1,0,-1,0};\n\nbool DFS(pair<int,int> u,pair<int,int> p,pair<int,int> g){\n    if(u==g){\n        return 1;\n    }\n    for(int k=0;k<4;k++){\n        int toh=u.first+dh[k],tow=u.second+dw[k];\n        \n        if(!room[toh][tow]) continue;\n        if(toh==p.first&&tow==p.second) continue;\n        \n        if(DFS({toh,tow},u,g)){\n            when[u.first][u.second].push_back(t);\n            t++;\n            \n            return 1;\n        }\n    }\n    \n    return 0;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    cin>>H>>W>>Q;\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            char c;cin>>c;\n            if(c=='.') room[i+1][j+1]=1;\n        }\n    }\n    \n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>costuse[i+1][j+1];\n        }\n    }\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>coston[i+1][j+1];\n        }\n    }\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>costoff[i+1][j+1];\n        }\n    }\n    \n    vector<int> h(Q),w(Q);\n    \n    for(int i=0;i<Q;i++){\n        cin>>h[i]>>w[i];\n        h[i]++;\n        w[i]++;\n    }\n    \n    when[h[0]][w[0]].push_back(0);\n    \n    for(int i=1;i<Q;i++){\n        DFS({h[i],w[i]},{-1,-1},{h[i-1],w[i-1]});\n    }\n    \n    ll ans=0;\n    \n    for(int i=1;i<=H;i++){\n        for(int j=1;j<=W;j++){\n            if(when[i][j].size()==0) continue;\n            ans+=coston[i][j]+costoff[i][j];\n            for(int k=1;k<when[i][j].size();k++){\n                ans+=min(ll((when[i][j][k]-when[i][j][k-1]))*costuse[i][j],ll(coston[i][j]+costoff[i][j]));\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint grid[100][100];\nint cost[2][100][100];\nint back_dist[100][100];\nint ans = 0;\nint dist[100][100];\n\nint h, w, m;\n\nint dfs(pair<int, int> now, pair<int, int> back, pair<int, int> target) {\n    int reflect = 0;\n    if (now == target) {\n        reflect = 1;\n    }\n    else {\n        int dx[4] = { 1,-1,0,0 };\n        REP(t, 4) {\n            int x = now.first + dx[t];\n            int y = now.second + dx[3 - t];\n            if (x >= 0 && x < h && y >= 0 && y < w) {\n                if (mp(x, y) == back) continue;\n                if (grid[x][y] == 1) continue;\n                dist[x][y] = dist[now.first][now.second] + 1;\n                if (dfs(mp(x, y), now, target) == 1) {\n                    reflect = 1;\n                    break;\n                }\n            }\n        }\n    }\n    if (reflect == 1) {\n        if (back_dist[now.first][now.second] == -1e9) {\n            ans += cost[1][now.first][now.second];\n        }else\n        ans += min(cost[1][now.first][now.second], cost[0][now.first][now.second] * (dist[now.first][now.second] - back_dist[now.first][now.second]));\n        back_dist[now.first][now.second] = dist[now.first][now.second];\n        return 1;\n    }\n    return 0;\n}\n\nvoid solve() {\n    cin >> h >> w >> m;\n    REP(i, h) {\n        string s;\n        cin >> s;\n        REP(q, w) {\n            if (s[q] == '#') {\n                grid[i][q] = 1;\n            }\n        }\n    }\n    REP(i, 3) {\n        REP(q, h) {\n            REP(j, w) {\n                int hogge;\n                cin >> hogge;\n                cost[min(1LL, i)][q][j] += hogge;\n            }\n        }\n    }\n    REP(i, h) {\n        REP(q, w) {\n            back_dist[i][q] = -1e9;\n        }\n    }\n    pair<int, int> now;\n    cin >> now.first >> now.second;\n    REP(i, m-1) {\n        pair<int, int> target;\n        cin >> target.first >> target.second;\n        dfs(now, mp(-1,-1), target);\n        now = target;\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n, m, r;\nstring s[50];\nint c[3][50][50];\nint xx[1000], yy[1000];\nvector<int> tt[50][50];\nint dp[2010][2];\n\nint dfs(int x, int y, int px, int py, int gx, int gy, int ct){\n  tt[x][y].push_back(ct);\n  if (x == gx && y == gy) return 0;\n  rep(i, 4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx == px && ny == py) continue;\n    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n    if (s[nx][ny] == '#') continue;\n    int t = dfs(nx, ny, x, y, gx, gy, ct + 1);\n    if (t < inf) return t + 1;\n  }\n  tt[x][y].pop_back();\n  return inf;\n}\n\nint main(){\n  cin >> n >> m >> r;\n  rep(i, n) cin >> s[i];\n  rep(i, 3) rep(j, n) rep(k, m) cin >> c[i][j][k];\n  rep(i, r) cin >> xx[i] >> yy[i];\n  int ct = 0;\n  rep(i, r - 1){\n    ct += dfs(xx[i], yy[i], xx[i], yy[i], xx[i + 1], yy[i + 1], ct);\n  }\n  int res = 0;\n  rep(ii, n) rep(jj, m){\n    auto v = tt[ii][jj];\n    if (v.empty()) continue;\n    v.push_back(v.back());\n    /*if (v.size() == 1){\n      res += c[1][ii][jj] + c[2][ii][jj];\n      continue;\n    }*/\n    fill_n(*dp, 2010 * 2, inf);\n    dp[0][0] = 0;\n    rep(i, v.size() - 1){\n      chmin(dp[i + 1][0], dp[i][0] + c[1][ii][jj] + c[2][ii][jj]);\n      chmin(dp[i + 1][0], dp[i][1] + c[2][ii][jj]);\n      chmin(dp[i + 1][1], dp[i][0] + c[1][ii][jj] + c[0][ii][jj] * (v[i + 1] - v[i]));\n      chmin(dp[i + 1][1], dp[i][1] + c[0][ii][jj] * (v[i + 1] - v[i]));\n    }\n    res += dp[v.size() - 1][0];\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\n\nvp trail;\n\n\tint r,c,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nbool dfs(pii &cur,pii &to,vp &t,vs &field,vvi &visited){\n\tvisited[cur.first][cur.second]=1;\n\tif(cur==to){\n\t\tREP(i,t.size()){\n\t\t\ttrail.push_back(t[i]);\n\t\t}\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint x=cur.second+dx[i],y=cur.first+dy[i];\n\t\tpii next=make_pair(y,x);\n\t\tif(x<0||y<0||x>=c||y>=r||field[y][x]=='#'||visited[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tvp nt(t);\n\t\tnt.push_back(next);\n\t\tif(dfs(next,to,nt,field,visited))return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>r>>c>>m;\n\tvs field(r);\n\tREP(i,r){\n\t\tcin>>field[i];\n\t}\n\tvvi con(r,vi(c));\n\tvvi on(r,vi(c));\n\tvvi off(r,vi(c));\n\n\tREP(i,r)REP(j,c){\n\t\tcin>>con[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>on[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>off[i][j];\n\t}\n\n\tvp tasks(m);\n\tREP(i,m){\n\t\tcin>>tasks[i].first>>tasks[i].second;\n\t}\n\n\tFOR(i,1,m){\n\t\tvvi visited(r,vi(c));\n\t\tvp t;\n\t\tif(i==1){\n\t\t\tt.push_back(tasks[i-1]);\n\t\t}\n\t\tint x=tasks[i-1].second,y=tasks[i-1].first;\n\t\tdfs(tasks[i-1],tasks[i],t,field,visited);\n\t}\n\n\tvvi last(r,vi(c,-1));\n\tint cost=0;\n\tREP(i,trail.size()){\n\t\tint y=trail[i].first,x=trail[i].second;\n\t\tif(last[y][x]==-1){\n\t\t\tcost+=on[y][x];\n\t\t}else if((i-last[y][x])*con[y][x]<on[y][x]+off[y][x]){\n\t\t\tcost+=(i-last[y][x])*con[y][x];\n\t\t}else{\n\t\t\tcost+=on[y][x]+off[y][x];\n\t\t}\n\t\tlast[y][x]=i;\n\t}\n\tint lt=trail.size();\n\tREP(y,r)REP(x,c){\n\t\tif(last[y][x]!=-1){\n\t\t\tcost+=off[y][x];\n\t\t}\n\t}\n\tcout<<cost<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  mybestwishes\n * Created Time:  2011/10/19 16:47:16\n * File Name: \n */\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <time.h>\nusing namespace std;\nconst int maxint = -1u>>1;\n\nstack<int> stk;\nint r,c,m,ans,tot,top;\nbool g[70][70],st[300],s[70][70];\nint dp[70][70],p[70][70];\nint bj[3000];\nconst int dx[4]={0,1,0,-1};\nconst int dy[4]={1,0,-1,0};\nint x[4],y[4];\nchar ch;\nint su[70][70],sn[70][70],sf[70][70];\nint k1,k2,xx,yy,rt;\nint tp[3000];\n\nvoid dfs(int i,int j,int d){\n    dp[i][j]=d;\n    for (int k=0;k<4;k++)\n        if ((i+dx[k]>=0) && (j+dy[k]>=0) && g[i+dx[k]][j+dy[k]] && !s[i+dx[k]][j+dy[k]]){\n            s[i+dx[k]][j+dy[k]]=true;\n            dfs(i+dx[k],j+dy[k],d+1);\n            p[i+dx[k]][j+dy[k]]=i*c+j;\n        }\n}\n    \nint root(int x1,int y1,int x2,int y2){\n    int f;\n    while (dp[x1][y1]<dp[x2][y2]){\n        f=p[x2][y2];\n        x2=f/c;y2=f-x2*c;\n    }\n    while (dp[x1][y1]>dp[x2][y2]){\n        f=p[x1][y1];\n        x1=f/c;y1=f-x1*c;\n    }\n    while (x1!=x2 || y1!=y2){\n        f=p[x1][y1];\n        x1=f/c;y1=f-x1*c;\n        f=p[x2][y2];\n        x2=f/c;y2=f-x2*c;\n    }\n    return x1*c+y1;\n}\n\nint main(){\n    scanf(\"%d%d%d\",&r,&c,&m);\n    getchar();\n    memset(g,0,sizeof(g));\n    for (int i=0;i<r;i++){\n        for (int j=0;j<c;j++){\n            scanf(\"%c\",&ch);\n            if (ch=='.') g[i][j]=1;\n            else g[i][j]=0;\n        }\n        getchar();\n    }\n    memset(s,0,sizeof(s));\n    for (int i=0;i<r;i++){\n        int j;\n        for (j=0;j<c;j++)\n            if (g[i][j]){\n                s[i][j]=true;\n                dfs(i,j,0);\n                break;\n            }\n        if (s[i][j]) break;\n    }\n    for (int i=0;i<r;i++)\n        for (int j=0;j<c;j++)\n            scanf(\"%d\",&su[i][j]);\n    for (int i=0;i<r;i++)\n        for (int j=0;j<c;j++)\n            scanf(\"%d\",&sn[i][j]);\n    for (int i=0;i<r;i++)\n        for (int j=0;j<c;j++)\n            scanf(\"%d\",&sf[i][j]);\n    ans=0;tot=1;\n    memset(st,0,sizeof(st));\n    memset(bj,0,sizeof(bj));\n    scanf(\"%d%d\",&x[1],&y[1]);\n    for (int i=2;i<=m;i++){\n        k1=(i-1)%2;k2=i%2;\n        scanf(\"%d%d\",&x[k2],&y[k2]);\n        rt=root(x[k1],y[k1],x[k2],y[k2]);     \n        top=0;\n        tp[0]=x[k1]*c+y[k1];\n        while (tp[top]!=rt){\n            xx=tp[top]/c;yy=tp[top]-xx*c;\n            tp[++top]=p[xx][yy];\n        }\n        stk.push(x[k2]*c+y[k2]);\n        while (stk.top()!=rt){\n            xx=stk.top()/c;yy=stk.top()-xx*c;\n            stk.push(p[xx][yy]);\n        }\n        stk.pop();\n        while (!stk.empty()){\n            top++;\n            tp[top]=stk.top();\n            stk.pop();\n        }\n        for (int j=0;j<=top;j++){\n            xx=tp[j]/c;yy=tp[j]-xx*c;\n            if (!st[tp[j]]){\n                st[tp[j]]=true;\n                ans+=sn[xx][yy];\n            }\n            else{\n                if ((tot+j-bj[tp[j]])*su[xx][yy]>=sn[xx][yy]+sf[xx][yy])\n                    ans+=(sf[xx][yy]+sn[xx][yy]);\n                else \n                    ans+=((tot+j-bj[tp[j]])*su[xx][yy]);\n            }\n            bj[tp[j]]=tot+j;\n        }\n        tot+=top;\n    }\n    for (int i=0;i<r;i++)\n        for (int j=0;j<c;j++)\n            if (st[i*c+j]) ans+=sf[i][j];\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#define LINF 0x3f3f3f3f3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nconst static int tx[] = {+0,+1,+0,-1};\nconst static int ty[] = {-1,+0,+1,+0};\n \nstatic const double EPS = 1e-8;\n\nint W,H;\nbool visited[51][51];\nchar stage[51][51];\nvector<P> dfs(int sx,int sy,int gx,int gy,\n              vector<P>& route){\n\n  vector<P> res;\n  for(int i=0;i<4;i++){\n    int dx = sx + tx[i];\n    int dy = sy + ty[i];\n    if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n    if(visited[dy][dx]) continue;\n    if(stage[dy][dx] == '#') continue;\n\n    if(dx == gx && dy == gy){\n      route.push_back(P(dx,dy));\n      res = route;\n      return res;\n    }\n\n    visited[dy][dx] = true;\n    route.push_back(P(dx,dy));\n\n    vector<P> tmp = dfs(dx,dy,gx,gy,route);\n    if(tmp.size() > 0){\n        res = tmp;\n    }\n\n    visited[dy][dx] = false;\n    route.pop_back();\n  }\n\n  return res;\n}\n\nint main(){\n  int task_rooms;\n  while(~scanf(\"%d %d %d\",&H,&W,&task_rooms)){\n    int consumption_per_unit[51][51];\n    int turn_off_cost[51][51];\n    int turn_on_cost[51][51];\n\n\n    for(int y = 0; y < H; y++){\n      char buf[51];\n      scanf(\"%s\",buf);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = buf[x];\n      }\n    }\n    \n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&consumption_per_unit[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_off_cost[y][x]);\n      }\n    }\n\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        scanf(\"%d\",&turn_on_cost[y][x]);\n      }\n    }\n\n    vector<P> points;\n    for(int task_i = 0; task_i < task_rooms; task_i++){\n      int y,x;\n      scanf(\"%d %d\",&y,&x);\n      points.push_back(P(x,y));\n    }\n\n\n    int latest_time = 0;\n    int prev_x = -1;\n    int prev_y = -1;\n\n    vector<int> move_log[51][51];\n    for(int task_i = 0; task_i + 1 < task_rooms; task_i++){\n      int sx = points[task_i].first;\n      int sy = points[task_i].second;\n\n      int gx = points[task_i+1].first;\n      int gy = points[task_i+1].second;\n\n      memset(visited,false,sizeof(visited));\n      visited[sy][sx] = true;\n      vector<P> route;\n      route.push_back(P(sx,sy));\n      route = dfs(sx,sy,gx,gy,route);\n\n      for(int i=0; i< route.size();i++){\n        int x = route[i].first;\n        int y = route[i].second;\n\n        if(x == prev_x && y == prev_y) continue;\n        \n        move_log[y][x].push_back(latest_time);\n        latest_time++;\n\n        prev_x = x;\n        prev_y = y;\n      }\n    }\n\n    int res = 0;\n    for(int y = 0; y < H; y++){\n      for(int x = 0; x < W; x++){\n        if(move_log[y][x].size() == 0) continue;\n\n        res += turn_on_cost[y][x];\n        for(int i = 0; i + 1< move_log[y][x].size(); i++){\n          int duration = move_log[y][x][i+1] - move_log[y][x][i];\n          res += min(turn_off_cost[y][x] + turn_on_cost[y][x],\n                     consumption_per_unit[y][x] * duration);\n        }\n        res += turn_off_cost[y][x];\n      }\n    }\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// OBツ嘉ッツ嘉債宿2011 Day3 C : On or Off\n\n#include <iostream>\n#include <string>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main(){\n\tint R, C, M;\n\tlong long pow[50][50], on[50][50], off[50][50];\n\tlong long cost[2][50][50], time[50][50];\n\tint prev[50*50];\n\tstring mp[50];\n\twhile(cin >> R >> C >> M){\n\t\tmemset(cost, 0, sizeof(cost));\n\t\tmemset(time, 0, sizeof(time));\n\t\tfor(int i=0;i<R;i++) cin >> mp[i];\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) cin >> pow[i][j];\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) cin >> on[i][j];\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) cin >> off[i][j], time[i][j] = -1000000007;\n\t\tint px, py, cx, cy; cin >> cx >> cy;\n\t\tint t = 0;\n\t\tfor(int i=1;i<M;i++){\n\t\t\tpx = cx, py = cy;\n\t\t\tcin >> cx >> cy;\n\t\t\tif(px==cx && py==cy) continue;\n\t\t\tqueue< pair<int,int> > qu; qu.push(make_pair(cx, cy));\n\t\t\tmemset(prev, -1, sizeof(prev));\n\t\t\tprev[cx*C+cy] = -2;\n\t\t\twhile(!qu.empty()){\n\t\t\t\tpair<int,int> pr = qu.front(); qu.pop();\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tint x = pr.first+dx[j], y = pr.second+dy[j];\n\t\t\t\t\tif(x<0||R<=x||y<0||C<=y||mp[x][y]=='#') continue;\n\t\t\t\t\tif(prev[x*C+y]==-1){\n\t\t\t\t\t\tprev[x*C+y] = pr.first*C+pr.second;\n\t\t\t\t\t\tqu.push(make_pair(x,y));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int cur=px*C+py;prev[cur]!=-2;cur=prev[cur]){\n\t\t\t\tint x = cur/C, y = cur%C;\n\t\t\t\tcost[0][x][y] = cost[0][x][y]+min((t-time[x][y])*pow[x][y], off[x][y]+on[x][y]);\n//\t\t\t\tcost[0][x][y] = min(cost[0][x][y]+(t-time[x][y])*pow[x][y], cost[1][x][y]+on[x][y]);\n//\t\t\t\tcost[1][x][y] = cost[0][x][y]+off[x][y];\n\t\t\t\ttime[x][y] = t++;\n\t\t\t}\n\t\t}\n\t\tcost[0][cx][cy] = cost[0][cx][cy]+min((t-time[cx][cy])*pow[cx][cy], off[cx][cy]+on[cx][cy]);\n//\t\tcost[0][cx][cy] = min(cost[0][cx][cy]+(t-time[cx][cy])*pow[cx][cy], cost[1][cx][cy]+on[cx][cy]);\n//\t\tcost[1][cx][cy] = cost[0][cx][cy]+off[cx][cy];\n\t\ttime[cx][cy] = t;\n\n\t\tint res = 0;\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++) res += cost[0][i][j];\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <string>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> ppii;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\ntypedef vector<vi> vvi;\ntypedef priority_queue<pii, vp, greater<pii> > piq;\n\nconst int N = 55;\nconst int M = 1010;\nconst int K = 100010;\nconst int LIT = 2500;\nconst int INF = 1 << 28;\nconst int base = 137;\nconst double eps = 1e-10;\nconst int dir[5][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nconst int dir2[10][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}, {1, 0}, {-1, 0}, {0, -1}, {0, 1}};\nconst int ABS(int a) {return a > 0 ? a : -a;}\n\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\n\nconst pii nonvis = mp(-1, -1);\nint n, m, r, cnt, use[N][N], on[N][N], off[N][N];\nvi stp[N][N];\nchar g[N][N];\nvp v;\nll res;\n\nvoid init()\n{\n    memset(g, 0, sizeof(g));\n    for(int i = 0; i < n; i++) scanf(\"%s\", &g[i]);\n    \n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n    scanf(\"%d\", &use[i][j]);\n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n    scanf(\"%d\", &on[i][j]);\n    for(int i = 0; i < n; i++) for(int j = 0; j < m; j++)\n    scanf(\"%d\", &off[i][j]);\n    \n    v = vp(r);\n    for(int i = 0; i < r; i++) scanf(\"%d %d\", &v[i].fst, &v[i].snd);\n    \n    for(int i = 0; i < N; i++) for(int j = 0; j < m; j++) stp[i][j].clear();\n}\n\nvoid getroute(int p)\n{\n    pii vis[N][N];\n    for(int i = 0; i < N; i++) for(int j = 0; j < N; j++) vis[i][j] = nonvis;\n    queue<pii> que;\n    que.push(v[p]);\n    vis[v[p].fst][v[p].snd] = mp(-2, -2);\n    \n    while(!que.empty())\n    {\n        pii pre = que.front();\n        que.pop();\n        if(pre == v[p + 1])\n        {\n            stack<pii> sta;\n            while(1)\n            {\n                sta.push(pre);\n                if(pre == v[p]) break;\n                pre = vis[pre.fst][pre.snd];\n            }\n            if(p) sta.pop();\n            while(!sta.empty())\n            {\n                int x = sta.top().fst, y = sta.top().snd;\n                sta.pop();\n                cnt++;\n                stp[x][y].pb(cnt);\n            }\n            break;\n        }\n        int x = pre.fst, y = pre.snd;\n        for(int i = 0; i <= 3; i++)\n        {\n            int xx = x + dir[i][0];\n            int yy = y + dir[i][1];\n            if(xx < 0 || yy < 0 || xx >= n || yy >= m) continue;\n            if(g[xx][yy] == '#' || vis[xx][yy] != nonvis) continue;\n            que.push(mp(xx, yy));\n            vis[xx][yy] = pre;\n        }\n    }\n}\n\nvoid solve()\n{\n    cnt = 0; res = 0;\n    for(int i = 1; i < r; i++) getroute(i - 1);\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            //printf(\"place = %d %d\\n\", i, j);\n            int s = stp[i][j].size();\n            if(!s) continue;\n            res += on[i][j] + off[i][j];\n            for(int k = 1; k < s; k++) //printf(\"%d \", stp[i][j][k]);\n            {\n                ll gap = stp[i][j][k] - stp[i][j][k - 1];\n                ll t1 = gap * use[i][j];\n                ll t2 = on[i][j] + off[i][j];\n                res += min(t1, t2);\n            }\n            //printf(\"\\n\");\n        }    \n    }\n    \n    cout<<res<<endl;\n    //for(int i = 0; i < cnt; i++) printf(\"%d %d\\n\", route[i][0], route[i][1]);\n}\n\nint main()\n{\n    //freopen(\"in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n\n    while(cin>>n>>m>>r)\n    {\n        init();\n        solve();\n    }\n    //while(1);\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[2] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "//14\n#include<iostream>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint nr,nc,m;\nchar g[50][51];\nint ut[50][50];\nint on[50][50];\nint off[50][50];\nint u[50][50];\nvector<P> v(1);\n\nbool dfs(P c,P d){\n  if(g[c.second][c.first]=='#'||u[c.second][c.first])return false;\n  u[c.second][c.first]=1;\n  if(c==d)return true;\n  for(int i=0;i<4;i++){\n    int dr[]={0,-1,0,1,0};\n    int nx=c.first+dr[i];\n    int ny=c.second+dr[i+1];\n    if(ny<0||nr<=ny||nx<0||nc<=nx)continue;\n    if(dfs(P(nx,ny),d)){\n      v.push_back(c);\n      return true;\n    }\n  }\n  u[c.second][c.first]=0;\n  return false;\n}\n\nint main(){\n  cin>>nr>>nc>>m;\n  for(int i=0;i<nr;i++){\n    cin>>g[i];\n  }\n  for(int i=0;i<nr;i++){\n    for(int j=0;j<nc;j++){\n      cin>>ut[i][j];\n    }\n  }\n  for(int i=0;i<nr;i++){\n    for(int j=0;j<nc;j++){\n      cin>>on[i][j];\n    }\n  }\n  for(int i=0;i<nr;i++){\n    for(int j=0;j<nc;j++){\n      cin>>off[i][j];\n    }\n  }\n  cin>>v[0].second>>v[0].first;\n  for(int i=0;i<m-1;i++){\n    P p;\n    cin>>p.second>>p.first;\n    fill(u[0],u[nr],0);\n    dfs(p,v.back());\n  }\n  bool l[50][50]={};\n  int p=0;\n  for(int i=0;i<v.size();i++){\n    int y=v[i].second;\n    int x=v[i].first;\n    if(!l[y][x]){\n      p+=on[y][x];\n    }\n    int nx=find(v.begin()+i+1,v.end(),v[i])-v.begin();\n    if(nx==v.size()||on[y][x]+off[y][x]<ut[y][x]*(nx-i)){\n      p+=off[y][x];\n      l[y][x]=false;\n    }else{\n      p+=ut[y][x]*(nx-i);\n      l[y][x]=true;\n    }\n  }\n  cout<<p<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nconst int maxn = 50 + 3;\nint mat[maxn][maxn],n,m,q;\nint on[maxn][maxn];\nint off[maxn][maxn];\nint t[maxn][maxn];\nint ptr[maxn][maxn];\nvector<int>PPP[maxn][maxn];\n\nchar s[maxn][maxn];\n\nstruct node\n{\n    int x,y;\n};\nnode mis[1200];\nvector<node> Q;\n\nvector<node> P;\n\nint Flag=0;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nint vis[maxn][maxn];\nvoid dfs(int x,int y,int xx,int yy)\n{\n    if(Flag)return;\n    if(x==xx&&y==yy)\n    {\n        int stary = 0;\n\n        for(int i=1;i<P.size();i++)\n            Q.push_back(P[i]);\n        Flag=1;\n        return;\n    }\n    for(int i=0;i<4;i++)\n    {\n        int xxx = x+dx[i];\n        int yyy = y+dy[i];\n        if(xxx<=0||xxx>n)continue;\n        if(yyy<=0||yyy>m)continue;\n        if(vis[xxx][yyy])continue;\n        if(s[xxx][yyy]=='#')continue;\n        node ttt;ttt.x=xxx;ttt.y=yyy;\n        P.push_back(ttt);\n        vis[xxx][yyy]=1;\n        dfs(xxx,yyy,xx,yy);\n        P.pop_back();\n    }\n}\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&m,&q);\n    for(int i=1;i<=n;i++)\n        scanf(\"%s\",s[i]+1);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            scanf(\"%d\",&t[i][j]);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            scanf(\"%d\",&on[i][j]);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n            scanf(\"%d\",&off[i][j]);\n\n    for(int i=1;i<=q;i++)\n    {\n        scanf(\"%d%d\",&mis[i].x,&mis[i].y);\n        mis[i].x++;mis[i].y++;\n    }\n    Q.push_back(mis[1]);\n    for(int i=1;i<q;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        Flag=0;\n        P.clear();\n        vis[mis[i].x][mis[i].y]=1;\n        node k;k.x=mis[i].x,k.y=mis[i].y;\n        P.push_back(k);\n        dfs(mis[i].x,mis[i].y,mis[i+1].x,mis[i+1].y);\n    }\n    for(int i = 0 ; i < Q.size() ; ++ i)\n    {\n        node cur = Q[i];\n        int x = cur.x , y = cur.y;\n        PPP[x][y].push_back(i);\n    }\n    int ans = 0;\n    for(int i = 1 ; i <= n ; ++ i)\n        for(int j = 1 ; j <= m ; ++ j)\n         if(PPP[i][j].size() != 0)\n    {\n        ans += on[i][j]; ans += off[i][j];\n        for(int z = 0 ; z < PPP[i][j].size() - 1 ; ++ z)\n        {\n            int dis = PPP[i][j][z+1] - PPP[i][j][z];\n            ans += min(dis * t[i][j] , off[i][j] + on[i][j]);\n        }\n    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2>& p) {\n\treturn os << p.first << \" \" << p.second;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint H, W, M;\nvector<string> m;\nbool inRange(P p) {\n\tint x, y; tie(x, y) = p;\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nbool isWall(P p) {\n\tint x, y; tie(x, y) = p;\n\treturn m[y][x] == '#';\n}\nint dx[] = {0, 1, 0, -1};\nint dy[] = {-1, 0, 1, 0};\nvector<P> bfs(P s, P t) {\n\tmap<P, bool> used;\n\tmap<P, P> prevV;\n\tqueue<P> Q; Q.push(s); used[s] = true;\n\twhile ( !Q.empty() ) {\n\t\tP p = Q.front(); Q.pop();\n\t\tREP(d, 4) {\n\t\t\tint nx = p.first + dx[d], ny = p.second + dy[d];\n\t\t\tP np(nx, ny);\n\t\t\tif ( inRange(np) && !isWall(np) && !used[np] ) {\n\t\t\t\tused[np] = true;\n\t\t\t\tprevV[np] = p;\n\t\t\t\tQ.push(np);\n\t\t\t}\n\t\t}\n\t}\n\tvector<P> res;\n\tfor (P p = t; p != s; p = prevV[p]) {\n\t\tres.pb(p);\n\t}\n\treverse(ALL(res));\n\treturn res;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tcin >> H >> W >> M;\n\tm = vector<string>(H);\n\tcin >> m;\n\tvector< vector<ll> > keep(H, vector<ll>(W));\n\tvector< vector<ll> > on(H, vector<ll>(W));\n\tvector< vector<ll> > off(H, vector<ll>(W));\n\tcin >> keep >> on >> off;\n\tvector<P> tasks;\n\tREP(i, M) {\n\t\tint x, y; cin >> y >> x;\n\t\ttasks.pb(P(x, y));\n\t}\n\tvector<P> v; v.pb(tasks[0]);\n\tREP(i, M-1) {\n\t\tvector<P> path = bfs(tasks[i], tasks[i+1]);\n\t\tEACH(p, path) v.pb(p);\n\t}\n\tmap<P, vector<int> > task;\n\tREP(i, v.size()) {\n//\t\tcout << v[i] << endl;\n\t\ttask[v[i]].pb(i);\n\t}\n\tll ans = 0;\n\tmap<P, bool> state;\n\tREP(i, v.size()) {\n\t\tP& p = v[i];\n\t\tint x, y; tie(x, y) = p;\n\t\tif (!state[p]) {\n\t\t\tstate[p] = true;\n\t\t\tans += on[y][x];\n\t\t}\n\t\tauto it = upper_bound(ALL(task[p]), i);\n\t\tif (it == task[p].end()) {\n\t\t\tstate[p] = false;\n\t\t\tans += off[y][x];\n\t\t}\n\t\telse {\n\t\t\tint t2 = *it;\n\t\t\tint t = t2 - i;\n\t\t\tif (keep[y][x] * t <= off[y][x] + on[y][x]) {\n\t\t\t\tans += keep[y][x] * t;\n//\t\t\t\tcout << t << endl;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstate[p] = false;\n\t\t\t\tans += off[y][x];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\ntypedef pair<int, int> pii;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\ntemplate<class T> constexpr bool in_range(T y, T x, T H, T W) { return 0<=y&&y<H&&0<=x&&x<W; }\n\nstruct consumption {\n  int on, off, stay;\n  consumption(){}\n  consumption(int on, int off, int stay): on(on), off(off), stay(stay){}\n};\n\n/*------------------------------------------*/\nint H, W, M;\nvector<string> G;\nmap<pii, consumption> costs;\nvector<pii> vs;\nmap<pii, int> cnt;\n/*------------------------------------------*/\n\nint bfs(pii s, pii t) {\n\n  map<pii, int> dist;\n  dist[s] = 0;\n\n  queue<pii> q;\n  q.push(s);\n\n  while(!q.empty()) {\n    int y, x; tie(y, x) = q.front(); q.pop();\n    if(y == t.first && x == t.second) return dist[{y, x}];\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, H, W)) continue;\n      if(G[ny][nx] == '#') continue;\n      if(dist.find({ny, nx}) == dist.end()) {\n        dist[{ny, nx}] = dist[{y, x}] + 1;\n        q.push({ny, nx});\n      }\n    }\n  }\n  assert(0);\n}\n\nvector<pii> make_path() {\n  vector<pii> path = {vs[0]};\n  queue<pii> q;\n  q.push(vs[0]);\n  set<pii> vis;\n  vis.insert(vs[0]);\n  pii prev[55][55];\n  int idx = 0;\n\n  while(!q.empty()) {\n    int y, x; tie(y, x) = q.front(); q.pop();\n    if(idx + 1 >= vs.size()) continue;\n    if(y == vs[idx+1].first && x == vs[idx+1].second) {\n      vector<pii> pt;\n      pii curr = vs[idx+1];\n      for(; curr!=vs[idx]; curr=prev[curr.first][curr.second]) pt.push_back(curr);\n      reverse(all(pt)); for(auto& e: pt) path.push_back(e);\n      idx ++;\n      if(idx == vs.size()) break;\n      vis.clear(); vis.insert({y, x});\n      while(!q.empty()) q.pop();\n    }\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if(!in_range(ny, nx, H, W)) continue;\n      if(G[ny][nx] == '#') continue;\n      if(vis.count({ny, nx})) continue;\n      vis.insert({ny, nx});\n      prev[ny][nx] = {y, x};\n      q.push({ny, nx});\n    }\n  }\n  return path;\n}\n\nvoid input() {\n  cin >> H >> W >> M;\n  G.resize(H);\n  rep(i, H) cin >> G[i];\n\n  int C[3][H][W];\n  rep(k, 3) rep(i, H) rep(j, W)\n    cin >> C[k][i][j];\n  rep(i, H) rep(j, W)\n    costs[{i, j}] = {C[1][i][j], C[2][i][j], C[0][i][j]};\n  rep(i, M) {\n    int r, c; cin >> r >> c;\n    vs.emplace_back(r, c);\n  }\n}\n\nint main() {\n\n  input();\n\n  auto path = make_path();\n  for(auto e: path)\n    cnt[e] ++;\n\n  /*\n  for(auto e: path) {\n    cout << endl;\n    rep(i, H) rep(j, W) {\n      if(e.first == i && e.second == j) cout << \"o\";\n      else cout << G[i][j];\n      if(j == W - 1) cout << endl;\n    }\n  }\n  */\n\n  int ans = 0;\n  map<pii, int> dist;\n  int currdist = 0;\n  pii prev = vs[0];\n\n  for(auto && e: path) {\n    currdist += bfs(prev, e);\n    if(dist.find(e) == dist.end()) {\n      ans += costs[e].on;\n    } else {\n      ans += min(costs[e].off + costs[e].on, costs[e].stay * (currdist - dist[e]));\n    }\n    if(cnt[e] == 1) {\n      ans += costs[e].off;\n    }\n    cnt[e] --;\n    dist[e] = currdist;\n    prev = e;\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\ntypedef long long Int;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nint R, C, M, pc[64][64], on[64][64], off[64][64], px[64][64], py[64][64];\nchar f[64][64];\nvector<int> zt[64][64];\n\nvoid rec(int cx, int cy) {\n    rep(d, 4) {\n        const int x=cx+dx[d], y=cy+dy[d];\n        if(f[x][y]!='#' && px[x][y]==-1) {\n            px[x][y] = cx;\n            py[x][y] = cy;\n            rec(x, y);\n        }\n    }\n}\n\nint main() {\n    memset(f, '#', sizeof(f));\n    scanf(\"%d%d%d\", &R, &C, &M);\n    rep(i, R) rep(j, C) scanf(\" %c\", &f[i+1][j+1]);\n    rep(i, R) rep(j, C) scanf(\"%d\", &pc[i+1][j+1]);\n    rep(i, R) rep(j, C) scanf(\"%d\", &on[i+1][j+1]);\n    rep(i, R) rep(j, C) scanf(\"%d\", &off[i+1][j+1]);\n    int cx=-1, cy=-1, t=0;\n    rep(i, M) {\n        int x, y;\n        scanf(\"%d%d\", &x, &y);\n        x++, y++;\n        if(i>0) {\n            memset(px, -1, sizeof(px));\n            rec(x, y);\n            while(cx!=x || cy!=y) {\n                zt[cx][cy].push_back(t++);\n                int tx=cx, ty=cy;\n                cx = px[tx][ty], cy = py[tx][ty];\n            }\n        }\n        cx = x; cy = y;\n    }\n    zt[cx][cy].push_back(t);\n    Int ans = 0;\n    rep(i, R+2) rep(j, C+2) if(zt[i][j].size()) {\n        ans += on[i][j];\n        ans += off[i][j];\n        rep(k, zt[i][j].size()-1) {\n            int dt = zt[i][j][k+1]-zt[i][j][k];\n            ans += min((Int)on[i][j]+off[i][j], (Int)dt*pc[i][j]);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nstruct aa {\n\tint x;\n\tint y;\n\tint time;\n\tvector<int>xs;\n\tvector<int>ys;\n};\nclass Compare {\npublic:\n\t//aaが昇順に並ぶ\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\nconst int dx[4] = { -1,0,1,0 };\nconst int dy[4] = { 0,1,0,-1 };\naa getway(const int fx,const int fy,const int tx,const int ty, const vector<vector<int>>&cans){\n\tpriority_queue<aa, vector<aa>, Compare>que;\n\tque.push(aa{ fx,fy,0,{},{} });\n\tint memo[100][100];\n\tfor (int i = 0; i < 100; ++i) {\n\t\tfor (int j = 0; j < 100; ++j) {\n\t\t\tmemo[i][j] = 99999999;\n\t\t}\n\t}\n\tmemo[fy][fx] = 0;\n\twhile (!que.empty()) {\n\t\taa atop(que.top());\n\t\tque.pop();\n\t\tif (atop.x == tx&&atop.y == ty)return atop;\n\t\telse {\n\t\t\tatop.xs.push_back(atop.x);\n\t\t\tatop.ys.push_back(atop.y);\n\t\t}\n\t\tvector<int> axs(atop.xs);\n\t\tvector<int> ays(atop.ys);\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint newx = atop.x + dx[i];\n\t\t\tint newy = atop.y + dy[i];\n\t\t\tif (cans[newy][newx]) {\n\t\t\t\tif (memo[newy][newx]>atop.time + 1) {\n\t\t\t\t\tmemo[newy][newx] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ newx,newy,atop.time + 1,atop.xs,atop.ys });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(false);\n}\n\nint main() {\n\t\n\t/*int N; cin >> N;\n\tvector<int>as;\n\tvector<int>num(10001);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; scanf(\"%d\", &a);\n\t\tnum[a]++;\n\t}\n\tvector<long long int>nums;\n\tfor (int i = 0; i < 10001; ++i) {\n\t\tif (num[i] > 1) {\n\t\t\tstring st(to_string(i)+to_string(i));\n\t\t\tnums.push_back(stoll(st));\n\t\t\tif (num[i] >= 3) {\n\t\t\t\tnums.push_back(stoi(st));\n\t\t\t\tnums.push_back(stoi(st));\n\t\t\t}\n\t\t}\n\t\telse if (num[i]) {\n\t\t\tfor (int j = 0; j < 10001; ++j) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tif (num[j]) {\n\t\t\t\t\tint atime = min(3,num[i] * num[j]);\n\t\t\t\t\tstring st(to_string(i) + to_string(j));\n\t\t\t\t\tfor (int i = 0; i < atime; ++i) {\n\n\t\t\t\t\t\tnums.push_back(stoll(st));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < 2; ++i) {\n\n\t\tauto it = min_element(nums.begin(), nums.end());\n\t\tnums.erase(it);\n\t}\n\tauto it = min_element(nums.begin(), nums.end());\n\tcout << *it << endl;\n\treturn 0;*/\n\t\n\tint W, H, M; cin >>H>>W >> M;\n\tvector<vector<int>>pers(H+2, vector<int>(W+2));\n\tvector<vector<int>>ons(H + 2, vector<int>(W + 2));\n\tvector<vector<int>>offs(H + 2, vector<int>(W + 2));\n\tvector<vector<int>>cans(H + 2, vector<int>(W + 2));\n\tfor (int i = 1; i <= H; ++i) {\n\t\tstring st; cin >> st;\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tif (st[j - 1] == '.') {\n\t\t\t\tcans[i][j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; ++i) {\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tint per; cin >> per;\n\t\t\tpers[i][j] = per;\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; ++i) {\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tint per; cin >> per;\n\t\t\tons[i][j] = per;\n\t\t}\n\t}\n\tfor (int i = 1; i <= H; ++i) {\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tint per; cin >> per;\n\t\t\toffs[i][j] = per;\n\t\t}\n\t}\n\tint fx, fy; cin >> fy >> fx;\n\tfx++; fy++;\n\tvector<int>xmoves;\n\tvector<int>ymoves;\n\tfor (int i = 0; i < M-1; ++i) {\n\t\tint tx, ty; cin >> ty >> tx; tx++; ty++;\n\t\taa ways= getway(fx, fy, tx, ty,cans);\n\t\txmoves.insert(xmoves.end(), ways.xs.begin(), ways.xs.end());\n\t\tymoves.insert(ymoves.end(), ways.ys.begin(), ways.ys.end());\n\t\tfx = tx; fy = ty;\n\t\tif (i == M - 2) {\n\t\t\txmoves.push_back(tx);\n\t\t\tymoves.push_back(ty);\n\t\t}\n\t}\n\tvector<vector<vector<int>>>times(H + 2, vector<vector<int>>((W + 2), vector<int>()));\n\tfor (int i = 0; i < xmoves.size(); ++i) {\n\t\ttimes[ymoves[i]][xmoves[i]].push_back(i);\n\t}\n\tlong long int ans = 0;\n\tfor (int i =1; i < H + 1; ++i) {\n\t\tfor (int j = 1; j < W + 1; ++j) {\n\t\t\tlong long int cost = 0;\n\t\t\tvector<int>ntimes(times[i][j]);\n\t\t\tif (!ntimes.empty()) {\n\t\t\t\tcost += ons[i][j]+offs[i][j];\n\t\t\t\tfor (int k = 0; k < ntimes.size() - 1; ++k) {\n\t\t\t\t\tint byetime = ntimes[k + 1] - ntimes[k];\n\t\t\t\t\tcost += min(byetime*pers[i][j], ons[i][j] + offs[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += cost;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(_v) for(auto _x:_v){cout<<_x<<\" \";}cout<<endl\n#define printVS(_vs) for(auto _x : _vs){cout << _x << endl;}\n#define printVV(_vv) for(auto _v:_vv){for(auto _x:_v){cout<<_x<<\" \";}cout<<endl;}\n#define printP(_p) cout << _p.first << \" \" << _p.second << endl\n#define printVP(_vp) for(auto _p : _vp) printP(_p);\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\n\n// N, E, S, W\nconst int dx[4] = {-1, 0,  1,  0};\nconst int dy[4] = { 0, 1,  0, -1};\n\nbool inside(int x, int y, int H, int W) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int H, W, m;\n    cin >> H >> W >> m;\n    vector<string> s(H);\n    rep(i, H) cin >> s[i];\n    vvi power(H, vi(W));\n    rep(i, H) rep(j, W) cin >> power[i][j];\n    vvi on(H, vi(W));\n    rep(i, H) rep(j, W) cin >> on[i][j];\n    vvi off(H, vi(W));\n    rep(i, H) rep(j, W) cin >> off[i][j];\n    vector<Pii> task(m);\n    rep(i, m) cin >> task[i].first >> task[i].second;\n\n    vvvi time(H, vvi(W));\n    time[task[0].first][task[0].second].emplace_back(0);\n    std::function<int(int,int,int,int,int,int,int)> dfs = [&](int x, int y, int px, int py, int gx, int gy, int t) {\n        if (x == gx && y == gy) {\n            return t;\n        }\n\n        rep(k, 4) {\n            int nx = x + dx[k], ny = y + dy[k];\n            if (!inside(nx, ny, H, W)) continue;\n            if (s[nx][ny] == '#') continue;\n            if (nx == px && ny == py) continue;\n            time[nx][ny].emplace_back(t);\n            int ret = dfs(nx, ny, x, y, gx, gy, t + 1);\n            if (ret < inf) return ret;\n            time[nx][ny].pop_back();\n        }\n\n        return inf;\n    };\n\n    int t = 1;\n    rep(i, m - 1) {\n        t = dfs(task[i].first, task[i].second, -1, -1, task[i + 1].first, task[i + 1].second, t);\n    }\n\n    int ans = 0;\n    rep(i, H) {\n        rep(j, W) {\n            if (time[i][j].empty()) {\n                continue;\n            }\n            ans += on[i][j];\n            rep(k, (int)time[i][j].size() - 1) {\n                ans += min(power[i][j] * (time[i][j][k + 1] - time[i][j][k]), off[i][j] + on[i][j]);\n            }\n            ans += off[i][j];\n        }\n    }\n\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[52][52],b[3][51][51],c[1000],d[1000],h,w,n;\npair<int,int> e[51][51];\nint fi(int p,int q,int r,int y,int x){  \n  int i,j;\n  if(a[y][x])\n    return 1<<30;\n  if(y==c[p]&&x==d[p])\n    ++p;\n  if(p==e[y][x].first)\n    return 1<<30;\n  if(e[y][x].first<0)\n    r+=b[1][y][x];\n  else\n    r+=min(b[0][y][x]*(q-e[y][x].second),b[1][y][x]+b[2][y][x]);\n  pair<int,int> t=e[y][x];\n  e[y][x]=make_pair(p,q);\n  if(p==n){\n    for(i=1;i<=h;++i){\n      for(j=1;j<=w;++j){\n\tif(e[i][j].first>=0)\n\t  r+=b[2][i][j];\n      }\n    }\n    e[y][x]=t;\n    return r;\n  }\n  int mn=min(min(min(fi(p,q+1,r,y-1,x),fi(p,q+1,r,y+1,x)),fi(p,q+1,r,y,x-1)),fi(p,q+1,r,y,x+1));\n  e[y][x]=t;\n  return mn;\n}\nint main(){\n  int i,j,k;\n  //int h,w,n;\n  while(cin>>h>>w>>n){\n  //int a[52][52];\n  memset(a,-1,sizeof(a));\n  for(i=1;i<=h;++i){\n    for(j=1;j<=w;++j){\n      char p;\n      cin>>p;\n      if(p=='.')\n\ta[i][j]=0;\n    }\n  }\n  //int b[3][50][50];\n  for(i=0;i<3;++i)\n    for(j=1;j<=h;++j)\n      for(k=1;k<=w;++k)\n\tcin>>b[i][j][k];\n  //int c[1000],d[1000];\n  for(i=0;i<n;++i){\n    cin>>c[i]>>d[i];\n    ++c[i];\n    ++d[i];\n  }\n  for(i=0;i<51;++i)\n    for(j=0;j<51;++j)\n      e[i][j]=make_pair(-1,-1);\n  cout<<fi(0,0,0,c[0],d[0])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_R 50\n#define MAX_C 50\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nbool inField(int x, int y, int C, int R)\n{\n    return (0 <= x && x < C && 0 <= y && y < R);\n}\n\nint main()\n{\n    int R, C, M;\n    char field[MAX_R][MAX_C];\n    cin >> R >> C >> M;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> field[i][j];\n        }\n    }\n    int cost[3][MAX_R][MAX_C];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < R; j++) {\n            for (int k = 0; k < C; k++) {\n                cin >> cost[i][j][k];\n            }\n        }\n    }\n    vector<int> X(M), Y(M);\n    for (int i = 0; i < M; i++) {\n        cin >> Y[i] >> X[i];\n    }\n\n    const int dx[] = {-1, 0, 1, 0};\n    const int dy[] = {0, -1, 0, 1};\n    \n    map<pii, vector<int>> vis;\n    int prev_d = 0;\n    for (int i = 1; i < M; i++) {\n        queue<pii> Q; Q.push(pii(X[i-1], Y[i-1]));\n        vector<vector<int>> d(MAX_R, vector<int>(MAX_C, INF));\n        vector<vector<int>> prev(MAX_R, vector<int>(MAX_C, INF));\n        d[Y[i-1]][X[i-1]] = prev_d;\n        while (!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            int x = p.first, y = p.second;\n            if (x == X[i] && y == Y[i]) {\n                prev_d = d[y][x];\n                break;\n            }\n            for (int j = 0; j < 4; j++) {\n                int nx = x + dx[j], ny = y + dy[j];\n                if (!inField(nx, ny, C, R) ||\n                    field[ny][nx] == '#') {\n                    continue;\n                }\n                if (d[y][x] + 1 < d[ny][nx]) {\n                    d[ny][nx] = d[y][x] + 1;\n                    prev[ny][nx] = y*C + x;\n                    Q.push(pii(nx, ny));\n                }\n            }\n        }\n        int x = X[i], y = Y[i];\n        vis[pii(x, y)].push_back(d[y][x]);           \n        while (x != X[i-1] || y != Y[i-1]) {           \n            int nx = x, ny = y;\n            nx = prev[y][x] % C;\n            ny = prev[y][x] / C;\n            x = nx; y = ny;\n            vis[pii(x, y)].push_back(d[y][x]);           \n        }\n    }\n    int sum = 0;\n    for (auto &v : vis) {\n        int x = v.first.first;\n        int y = v.first.second;\n        vector<int> p = v.second;\n        sort(p.begin(), p.end());\n        if (p.size() == 1) {\n            sum += cost[1][y][x] + cost[2][y][x];\n        } else {\n            sum += cost[1][y][x];\n            for (int i = 1; i < (int)p.size(); i++) {\n                sum += min(cost[2][y][x] + cost[1][y][x], (p[i] - p[i-1]) * cost[0][y][x]);\n            }\n            sum += cost[2][y][x];\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=1000000007;\nconst LL LINF=1LL<<60;\nconst int INF=1<<30;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nbool vis[51][51];\nint r,c;\nvector<string> s(51);\nvector<vector<vector<int>>> d(51,vector<vector<int>> (51));\n\nint dfs(int y,int x,int gy,int gx,int tt){\n    if(y==gy&&x==gx) return tt;\n    if(vis[y][x]) return -1;\n    vis[y][x] = true;\n    for (int k = 0; k < 4; k++) {\n        int ny = y + dy[k], nx = x + dx[k];\n        if(0<=ny&&ny<r&&0<=nx&&nx<c&&s[ny][nx]=='.'){\n            auto ret = dfs(ny,nx,gy,gx,tt+1);\n            if(ret>=0){\n                d[ny][nx].pb(tt+1);\n                return ret;\n            }\n        }\n    }\n    return -1;\n};\n\n\n\nint main(){\n    int m;cin >> r >> c >> m;\n    for (int i = 0; i < r; i++) {\n        cin >> s[i];\n    }\n    vector<vector<int>> a(r,vector<int> (c,0));\n    auto oc = a, fc = a;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            cin >> a[i][j];\n        }\n    }\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            cin >> oc[i][j];\n        }\n    }\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            cin >> fc[i][j];\n        }\n    }\n    vector<P> v(m,mp(0,0));\n    for (int i = 0; i < m; i++) {\n        cin >> v[i].fs >> v[i].sc;\n    }\n    int t = 0;\n    d[v[0].fs][v[0].sc].pb(0);\n    for (int i = 1; i < v.size(); i++) {\n        memset(vis,false,sizeof(vis));\n        auto q = dfs(v[i-1].fs,v[i-1].sc,v[i].fs,v[i].sc,t);\n        t = q;\n    }\n    int ans = 0;\n    for (int i = 0; i < r; i++) {\n        for (int j = 0; j < c; j++) {\n            if(d[i][j].size()){\n                int p = oc[i][j] + fc[i][j];\n                ans += p;\n                for (int k = 1; k < d[i][j].size(); k++) {\n                    ans += min(p,a[i][j] * (d[i][j][k] - d[i][j][k-1]));\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nchar c[50][50];\nint R,C,M;\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvector< pair<int,int> > bfs(int x1,int y1,int x2,int y2){\n\tqueue< pair<int,int> > Q;\n\tpair<int,int> prev[50][50];\n\tfor(int i = 0 ; i < 50 ; i++)\n\t\tfor(int j = 0 ; j < 50 ; j++)\n\t\t\tprev[i][j] = {-1,-1};\n\tprev[y1][x1] = {x1,y1};\n\tQ.push({x1,y1});\n\twhile( Q.size() ){\n\t\tauto q = Q.front(); Q.pop();\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tint tx = q.first + dx[i];\n\t\t\tint ty = q.second + dy[i];\n\t\t\n\t\t\tif( tx >= 0 && tx < C && ty >= 0 && ty < R && c[ty][tx] != '#' && prev[ty][tx] == make_pair(-1,-1) ){\n\t\t\t\tprev[ty][tx] = q; \n\t\t\t\tQ.push({tx,ty});\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector< pair<int,int> > route;\n\tpair<int,int> now = {x2,y2};\n\twhile( prev[now.second][now.first] != now ){\n\t\troute.push_back(now);\n\t\tnow = prev[now.second][now.first];\n\t}\n//\tcout << \"(\" << x1 << \" \" << y1 << \")-(\" << x2 << \" \" << y2 << \")\" << route.size() << endl;\n\treverse(route.begin(),route.end());\n\treturn route;\n}\n\nint cost[3][51][51];\n\nvector<int> timing[51][51];\n\nint main(){\n\tcin >> R >> C >> M;\n\tfor(int i = 0 ; i < R ; i++){\n\t\tfor(int j = 0 ; j < C ; j++){\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tfor(int k = 0 ; k < 3 ; k++){\n\t\tfor(int i = 0 ; i < R ; i++){\n\t\t\tfor(int j = 0 ; j < C ; j++){\n\t\t\t\tcin >> cost[k][i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint px,py;\n\tvector< pair<int,int> > all;\n\tfor(int i = 0 ; i < M ; i++){\n\t\tint y,x;\n\t\tcin >> y >> x;\n\t\tif(i){\n\t\t\tauto v = bfs(px,py,x,y);\n\t\t\tall.insert(all.end(),v.begin(),v.end());\n\t\t}else{\n\t\t\tall.push_back({x,y});\n\t\t}\n\t\tpx = x;\n\t\tpy = y;\n\t}\n\tfor(int i = 0 ; i < all.size() ; i++){\n\t\ttiming[all[i].second][all[i].first].push_back(i);\n\t}\n\tlong long sum = 0;\n\tfor(int i = 0 ; i < R ; i++){\n\t\tfor(int j = 0 ; j < C ; j++){\n\t\t\tint sw = 0;\n\t\t\tint ans = 0;\n\t\t\tfor(int k = 0 ; k < timing[i][j].size() ; k++){\n\t\t\t\tif( sw == 0 ){\n\t\t\t\t\tans += cost[1][i][j]; // on\n\t\t\t\t\tsw ^= 1;\n\t\t\t\t}\n\t\t\t\tif(k+1 < timing[i][j].size() ){\n\t\t\t\t\tint l = timing[i][j][k+1] - timing[i][j][k];\n\t\t\t\t\tint always = l * cost[0][i][j];\n\t\t\t\t\tif( cost[2][i][j]+cost[1][i][j] < always ){\n\t\t\t\t\t\tans += cost[2][i][j];\n\t\t\t\t\t\tsw ^= 1;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans += always;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tans += cost[2][i][j];\n\t\t\t\t\tsw ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += ans;\n\t\t}\n\t}\n\tcout << sum << endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,short int> mp;\n  vector<int> V;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        V.push_back(i*C+j);\n        ++n;\n      }\n    }\n  }\n  vector< vector< vector<short int> > > G(n,vector< vector<short int> >(n));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        short int v = mp[x_*C+y_];\n        G[i][v].push_back(v);\n      }\n    }\n  }\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<short int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  vector< vector<short int> > P(R, vector<short int>(C)), OnOff = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OnOff[i][j];\n  short int t;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      cin >> t;\n      OnOff[i][j] += t;\n    }\n  }\n  vector<int> X(M), Y(M);\n  for(int i = 0; i < M; ++i)\n    cin >> X[i] >> Y[i];\n  vector<short int> T(n,-1);\n  T[mp[X[0]*C+Y[0]]] = 0;\n  t = 0;\n  int ans = OnOff[X[0]][Y[0]];\n  for(int i = 0; i < M-1; ++i){\n    int v = mp[X[i]*C+Y[i]], v_ = mp[X[i+1]*C+Y[i+1]];\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += OnOff[r][c];\n      }else{\n        ans += min(OnOff[r][c], (short int)(P[r][c]*(t-T[k])));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n\ntemplate<typename T,typename S>\nostream& operator<<(ostream& os,const pair<T,S>& val){\n    os << \"(\" << val.first << \",\" << val.second << \")\";\n    return os;\n}\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& val){\n    os << \"[ \";\n    for(typename vector<T>::const_iterator it=val.begin();\n        it != val.end();++it){\n        os << *it << \" \";\n    }\n    os << \"]\";\n    return os;\n}\n\n#define mp(a,b) make_pair(a,b)\n\ntypedef pair<char,char> pii;\ntypedef vector<pii> vp1;\ntypedef vector<vp1> vp2;\ntypedef vector<vp2> vp3;\ntypedef vector<vp3> vp4;\ntypedef vector<vp4> vp5;\ntypedef vector<char> vc;\n\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nint main(){\n    int R,C,M;\n    cin >> R >> C >> M;\n    vp5 route(R,vp4(C,vp3(R,vp2(C))));\n\n    vector<vc> is_room(R,vc(C));\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            char t;cin >> t;\n            is_room[r][c] = (t == '.');\n        }\n    }\n\n    for(int s_r=0;s_r<R;s_r++){\n        for(int s_c=0;s_c<C;s_c++){\n            stack<pair<pii,vp1> > S;\n            vector<vc> already(R,vc(C));\n            S.push(mp(mp(s_r,s_c),vp1(1,mp(s_r,s_c))));\n            while(not S.empty()){\n                pair<pii,vp1> p = S.top();\n                int r = p.first.first;\n                int c = p.first.second;\n                S.pop();\n                if(already[r][c]) continue;\n                already[r][c] = true;\n                route[s_r][s_c][r][c] = p.second;\n\n                for(int i=0;i<4;i++){\n                    int nr = r + dy[i],nc = c + dx[i];\n                    if(0 <= nr and nr < R and 0 <= nc and nc < C and\n                       is_room[nr][nc] and not already[nr][nc]){\n                        vector<pii> rou = p.second;\n                        rou.push_back(mp(nr,nc));\n                        S.push(mp(mp(nr,nc),rou));\n                    }\n                }\n            }\n        }\n    }\n\n    vector<vector<int> > consume(R,vector<int>(C));\n    vector<vector<int> > turn_on(R,vector<int>(C));\n    vector<vector<int> > turn_off(R,vector<int>(C));\n\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> consume[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_on[r][c];\n        }\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            cin >> turn_off[r][c];\n        }\n    }\n    // cerr << turn_on << endl;\n\n    vector<vector<int> > last_visit(R,vector<int>(C,-1));\n    int lr=-1,lc=-1;\n    int cur_time = 0;\n    int ret = 0;\n    for(int t_case=0;t_case<M;t_case++){\n        int gr,gc;\n        cin >> gr >> gc;\n        if(t_case == 0){\n            lr = gr;lc = gc;\n        }\n        vp1 rou = route[lr][lc][gr][gc];\n        for(size_t i=0;i<rou.size();i++){\n            if(i != 0) cur_time++;\n            int c_r = rou[i].first,c_c = rou[i].second;\n\n            if(last_visit[c_r][c_c] != -1){\n                ret += min(consume[c_r][c_c] * (cur_time - last_visit[c_r][c_c]),\n                           turn_off[c_r][c_c] + turn_on[c_r][c_c]);\n            }else{\n                ret += turn_on[c_r][c_c];\n            }\n            last_visit[c_r][c_c] = cur_time;\n            // cerr << c_r << \" \" << c_c << \" \" << cur_time << \" \" << ret << endl;\n        }\n        lr = gr,lc = gc;\n    }\n    for(int r=0;r<R;r++){\n        for(int c=0;c<C;c++){\n            if(last_visit[r][c] != -1) {\n                ret += turn_off[r][c];\n            }\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 60, PMAX = 1010;\nconst int dl[] = {1, 0, -1, 0};\nconst int dc[] = {0, 1, 0, -1};\n\nint N, M, Q;\nchar A[NMAX][NMAX];\nint B[NMAX][NMAX];\nint C[NMAX][NMAX];\nint D[NMAX][NMAX];\nint Dist[NMAX][NMAX];\nlist<int> E[NMAX][NMAX];\npair<int, int> from[NMAX][NMAX];\nbool witness[NMAX][NMAX];\n\nvoid getPath(int startX, int startY, int finishX, int finishY, vector<pair<int, int>> &dest) {\n\tqueue<pair<int, int>> Q;\n\n\tmemset(witness, 0, sizeof witness);\n\tQ.push({startX, startY});\n\twitness[startX][startY] = 1;\n\tDist[startX][startY] = 0;\n\tbool found = 0;\n\twhile (!Q.empty()) {\n\t\tint currX, currY;\n\t\ttie(currX, currY) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint newX = currX + dl[i];\n\t\t\tint newY = currY + dc[i];\n\t\t\tif (newX < 0 || newX >= N || newY < 0 || newY >= M)\n\t\t\t\tcontinue;\n\t\t\tif (A[newX][newY] != '.' || witness[newX][newY])\n\t\t\t\tcontinue;\n\t\t\tfrom[newX][newY] = {currX, currY};\n\t\t\tDist[newX][newY] = Dist[currX][currY] + 1;\n\t\t\twitness[newX][newY] = 1;\n\t\t\tQ.push({newX, newY});\n\t\t\tif (newX == finishX && newY == finishY) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tassert(found);\n\tint currX, currY;\n\ttie(currX, currY) = from[finishX][finishY];\n\tint newSize = dest.size() + Dist[currX][currY];\n\tdest.resize(newSize);\n\t--newSize;\n\twhile (currX != startX || currY != startY) {\n\t\tdest[newSize--] = {currX, currY};\n\t\ttie(currX, currY) = from[currX][currY];\n\t}\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tscanf(\"%d %d %d\", &N, &M, &Q);\n\tfor (i = 0; i < N; ++i)\n\t\tscanf(\"%s\", A[i]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &B[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &C[i][j]);\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tscanf(\"%d\", &D[i][j]);\n\n\tvector<pair<int, int>> path;\n\tint lastX, lastY, currX, currY;\n\tscanf(\"%d %d\", &lastX, &lastY);\n\twhile (Q-- > 1) {\n\t\tscanf(\"%d %d\", &currX, &currY);\n\t\tassert(lastX != currX || lastY != currY);\n\t\tpath.push_back({lastX, lastY});\n\t\tgetPath(lastX, lastY, currX, currY, path);\n\t\tlastX = currX, lastY = currY;\n\t}\n\tpath.push_back({lastX, lastY});\n\n\tassert(path.size() < 2500000);\n\n\tfor (size_t i = 0; i < path.size(); ++i)\n\t\tE[path[i].first][path[i].second].push_back(i);\n\n\tbool lightOn[NMAX][NMAX] = {};\n\tint answer = 0;\n\tint currAdd = 0;\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tanswer += currAdd;\n\t\tif (!lightOn[path[i].first][path[i].second])\n\t\t\tanswer += C[path[i].first][path[i].second];\n\t\tE[path[i].first][path[i].second].pop_front();\n\t\tint front = E[path[i].first][path[i].second].front();\n\t\tif (E[path[i].first][path[i].second].size() && (front - i) * B[path[i].first][path[i].second] < C[path[i].first][path[i].second] + D[path[i].first][path[i].second]) {\n\t\t\tif (!lightOn[path[i].first][path[i].second])\n\t\t\t\tcurrAdd += B[path[i].first][path[i].second];\n\t\t\tlightOn[path[i].first][path[i].second] = 1;\n\t\t} else {\n\t\t\tif (lightOn[path[i].first][path[i].second])\n\t\t\t\tcurrAdd -= B[path[i].first][path[i].second];\n\t\t\tlightOn[path[i].first][path[i].second] = 0;\n\t\t\tanswer += D[path[i].first][path[i].second];\n\t\t}\n\t}\n\n\tcout << answer << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(){\n    int r,c,m;\n    cin >> r >> c >> m;\n    vector<vector<char>> grid(r,vector<char>(c));\n    vector<vector<int>> time(r,vector<int>(c)),on(r,vector<int>(c)),off(r,vector<int>(c));\n    vector<pii> tasks(m);\n    rep(i,0,r) rep(j,0,c) cin >> grid[i][j];\n    rep(i,0,r) rep(j,0,c) cin >> time[i][j];\n    rep(i,0,r) rep(j,0,c) cin >> on[i][j];\n    rep(i,0,r) rep(j,0,c) cin >> off[i][j];\n    for(auto& t:tasks) cin >> t.first >> t.second;\n\n    vector<vector<vector<int>>> arrival(r,vector<vector<int>>(c));\n    function<bool(const pii,const pii,const pii,const int)> dfs=[&](const pii prev,const pii curr,const pii end,const int d){\n        if(curr==end){\n            arrival[curr.first][curr.second].emplace_back(d);\n            return true;\n        }\n        bool pass=false;\n        rep(i,0,4){\n            pii next(curr.first+dx[i],curr.second+dy[i]);\n            if(next.first<0 or r<=next.first or next.second<0 or c<=next.second or next==prev or grid[next.first][next.second]=='#') continue;\n            pass|=dfs(curr,next,end,d+1);\n        }\n        if(pass) arrival[curr.first][curr.second].emplace_back(d);\n        return pass;\n    };\n\n    int elapsed=0;\n    rep(i,0,m-1){\n        dfs(tasks[i],tasks[i],tasks[i+1],elapsed);\n        elapsed+=arrival[tasks[i+1].first][tasks[i+1].second].back()-elapsed;\n    }\n\n    int ans=0;\n    rep(i,0,r) rep(j,0,c){\n        if(arrival[i][j].empty()) continue;\n        int cost=on[i][j]+off[i][j];\n        rep(k,0,arrival[i][j].size()-1){\n            int tmp1=off[i][j]+on[i][j];\n            int tmp2=time[i][j]*(arrival[i][j][k+1]-arrival[i][j][k]);\n            cost+=min(tmp1,tmp2);\n        }\n        dump(cost);\n        ans+=cost;\n    }\n\n    cout << ans << endl;\n}\n\nint main(){\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <stack>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint h, w, m;\nchar field[100][100];\nll cont[100][100];\nll on[100][100];\nll off[100][100];\nint prev[100][100];\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nvoid Input(ll mat[100][100]) {\n  REP(y, h) {\n    REP(x, w) {\n      scanf(\"%lld\", &mat[y][x]);\n    }\n  }\n}\n\nbool dfs(int x, int y, int px, int py, int gx, int gy, stack<pair<int, int> > &st) {\n  if (x == gx && y == gy) { return true; }\n  REP(dir, 4) {\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (nx == px && ny == py) { continue; }\n    if (nx < 0 || nx >= w || ny < 0 || ny >= h) { continue; }\n    if (field[ny][nx] == '#') { continue; }\n    if (dfs(nx, ny, x, y, gx, gy, st)) {\n      st.push(make_pair(nx, ny));\n      return true;\n    }\n  }\n  return false;\n}\n\nll In(int x, int y, int &t) {\n  ll ret = 1LL << 60;;\n  ret = on[y][x] + off[y][x];\n  if (prev[y][x] != -1) {\n    ret = min(ret, (t - prev[y][x]) * cont[y][x]);\n  }\n  prev[y][x] = t;\n  t++;\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d %d\", &h, &w, &m) > 0) {\n    MEMSET(prev, -1);\n    REP(y, h) {\n      scanf(\"%s\", field[y]);\n    }\n    Input(cont);\n    Input(on);\n    Input(off);\n    int px, py;\n    scanf(\"%d %d\", &py, &px);\n    int t = 0;\n    ll ans = 0;\n    ans += In(px, py, t);\n    REP(iter, m - 1) {\n      int nx, ny;\n      scanf(\"%d %d\", &ny, &nx);\n      stack<pair<int, int> > st;\n      dfs(px, py, px, py, nx, ny, st);\n      while (!st.empty()) {\n        int x = st.top().first;\n        int y = st.top().second;\n        st.pop();\n        ans += In(x, y, t);\n      }\n      px = nx;\n      py = ny;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint INF = 10000000;\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<vector<char>> A(R + 2, vector<char>(C + 2, '#'));\n  for (int i = 1; i <= R; i++){\n    for (int j = 1; j <= C; j++){\n      cin >> A[i][j];\n    }\n  }\n  vector<vector<vector<int>>> P(R + 2, vector<vector<int>>(C + 2, vector<int>(3)));\n  for (int i = 0; i < 3; i++){\n    for (int j = 1; j <= R; j++){\n      for (int k = 1; k <= C; k++){\n        cin >> P[j][k][i];\n      }\n    }\n  }\n  vector<int> y(M), x(M);\n  for (int i = 0; i < M; i++){\n    cin >> y[i] >> x[i];\n    y[i]++;\n    x[i]++;\n  }\n  vector<pair<int, int>> p;\n  p.push_back(make_pair(y[0], x[0]));\n  for (int i = 0; i < M - 1; i++){\n    vector<vector<bool>> used(R + 2, vector<bool>(C + 2, false));\n    used[y[i]][x[i]] = true;\n    vector<vector<pair<int, int>>> prev(R + 2, vector<pair<int, int>>(C + 2));\n    queue<pair<int, int>> Q;\n    Q.push(make_pair(y[i], x[i]));\n    while (!Q.empty()){\n      int cy = Q.front().first;\n      int cx = Q.front().second;\n      Q.pop();\n      for (int j = 0; j < 4; j++){\n        int y2 = cy + dy[j];\n        int x2 = cx + dx[j];\n        if (!used[y2][x2] && A[y2][x2] == '.'){\n          used[y2][x2] = true;\n          prev[y2][x2] = make_pair(cy, cx);\n          Q.push(make_pair(y2, x2));\n        }\n      }\n    }\n    vector<pair<int, int>> tmp;\n    tmp.push_back(make_pair(y[i + 1], x[i + 1]));\n    while (1){\n      tmp.push_back(prev[tmp.back().first][tmp.back().second]);\n      if (tmp.back() == make_pair(y[i], x[i])){\n        tmp.pop_back();\n        break;\n      }\n    }\n    reverse(tmp.begin(), tmp.end());\n    for (auto c : tmp){\n      p.push_back(c);\n    }\n  }\n  int t = p.size();\n  vector<vector<int>> prev(R + 2, vector<int>(C + 2, -1));\n  long long ans = 0;\n  for (int i = 0; i < t; i++){\n    int cy = p[i].first;\n    int cx = p[i].second;\n    if (prev[cy][cx] == -1){\n      ans += P[cy][cx][1] + P[cy][cx][2];\n    } else {\n      ans += min(P[cy][cx][1] + P[cy][cx][2], P[cy][cx][0] * (i - prev[cy][cx]));\n    }\n    prev[cy][cx] = i;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n#define all(c) (c).begin(), (c).end()\n\ntypedef pair<int, int> pii;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\ntemplate <class T> constexpr bool in_range(T y, T x, T H, T W) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nstruct consumption {\n  int on, off, stay;\n  consumption() {}\n  consumption(int on, int off, int stay) : on(on), off(off), stay(stay) {}\n};\n\n/*------------------------------------------*/\nint H, W, M;\nvector<string> G;\nmap<pii, consumption> costs;\nvector<pii> vs;\nmap<pii, int> cnt;\n/*------------------------------------------*/\n\nint bfs(pii s, pii t) {\n\n  map<pii, int> dist;\n  dist[s] = 0;\n\n  queue<pii> q;\n  q.push(s);\n\n  while (!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if (y == t.first && x == t.second)\n      return dist[{y, x}];\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if (!in_range(ny, nx, H, W))\n        continue;\n      if (G[ny][nx] == '#')\n        continue;\n      if (dist.find({ny, nx}) == dist.end()) {\n        dist[{ny, nx}] = dist[{y, x}] + 1;\n        q.push({ny, nx});\n      }\n    }\n  }\n  assert(0);\n}\n\nvector<pii> make_path() {\n  vector<pii> path = {vs[0]};\n  queue<pii> q;\n  q.push(vs[0]);\n  set<pii> vis;\n  vis.insert(vs[0]);\n  pii prev[55][55];\n  int idx = 0;\n\n  while (!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if (idx + 1 >= vs.size())\n      continue;\n    if (y == vs[idx + 1].first && x == vs[idx + 1].second) {\n      vector<pii> pt;\n      pii curr = vs[idx + 1];\n      for (; curr != vs[idx]; curr = prev[curr.first][curr.second])\n        pt.push_back(curr);\n      reverse(all(pt));\n      for (auto &e : pt)\n        path.push_back(e);\n      idx++;\n      if (idx == vs.size())\n        break;\n      vis.clear();\n      vis.insert({y, x});\n      while (!q.empty())\n        q.pop();\n    }\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if (!in_range(ny, nx, H, W))\n        continue;\n      if (G[ny][nx] == '#')\n        continue;\n      if (vis.count({ny, nx}))\n        continue;\n      vis.insert({ny, nx});\n      prev[ny][nx] = {y, x};\n      q.push({ny, nx});\n    }\n  }\n  return path;\n}\n\nvoid input() {\n  cin >> H >> W >> M;\n  G.resize(H);\n  rep(i, H) cin >> G[i];\n\n  int C[3][H][W];\n  rep(k, 3) rep(i, H) rep(j, W) cin >> C[k][i][j];\n  rep(i, H) rep(j, W) costs[{i, j}] = {C[1][i][j], C[2][i][j], C[0][i][j]};\n  rep(i, M) {\n    int r, c;\n    cin >> r >> c;\n    vs.emplace_back(r, c);\n  }\n}\n\nint main() {\n\n  input();\n\n  auto path = make_path();\n  for (auto e : path)\n    cnt[e]++;\n\n  int ans = 0;\n  map<pii, int> dist;\n  int currdist = 0;\n  pii prev = vs[0];\n\n  for (auto &&e : path) {\n    currdist += bfs(prev, e);\n    if (dist.find(e) == dist.end())\n      ans += costs[e].on;\n    else\n      ans +=\n          min(costs[e].off + costs[e].on, costs[e].stay * (currdist - dist[e]));\n    if (cnt[e] == 1)\n      ans += costs[e].off;\n    cnt[e]--;\n    dist[e] = currdist;\n    prev = e;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\nconst long long N=20000;\nconst long long INF=1e12;\ntypedef long long LL;\nstruct Edge\n{\n\tLL v,next;\n\tEdge(){}\n\tEdge(LL v,LL next):v(v),next(next){}\n}edge[N * 4];\nLL edn,p[N],n,m,fa[N],deep[N],a[N],b[N],na,nb,poLL[N],path[6000000],numpath,nump;\nLL last[N];\nLL onon[N],offoff[N],price[N];\nchar ch[100][100];\nLL get(LL p,LL q)\n{\n\treturn p * m + q;\n}\nvoid addedge(LL u,LL v)\n{\n\tedge[edn]=Edge(v,p[u]);p[u]=edn++;\n\tedge[edn]=Edge(u,p[v]);p[v]=edn++;\n}\nvoid dfs(LL x,LL f,LL dep)\n{\n\tfa[x]=f;deep[x]=dep;\n\tfor(LL i=p[x];~i;i=edge[i].next)\n\t{\n\t\tLL y=edge[i].v;\n\t\tif(y != f)\n\t\t{\n\t\t\tdfs(y,x,dep+1);\n\t\t}\n\t}\n} \nvoid add(LL x,LL y)\n{\n\tna=nb=1;\n\ta[1]=x;\n\tb[1]=y;\n\twhile (true)\n\t{\n\t\tif(x==y) break;\n\t\tif (deep[x]>deep[y])\n\t\t{\n\t\t\tx=fa[x];\n\t\t\ta[++na]=x;\n\t\t}else\n\t\t{\n\t\t\ty=fa[y];\n\t\t\tb[++nb]=y;\n\t\t}\n\t}\n\t//prLLf(\"na=%d nb=%d\\n\",na,nb);\n\tfor(LL i=1;i<=na;i++)\n\t\tif(numpath==0 || a[i]!=path[numpath]) path[++numpath]=a[i];\n\tfor(LL i=nb;i>=1;i--)\n\t\tif(numpath==0 || b[i]!=path[numpath]) path[++numpath]=b[i];\n}\nint main()\n{\n\tedn=0;\n\tmemset(p,-1,sizeof(p));\n\tcin>>n>>m>>nump;scanf(\"\\n\");\n\tfor(LL i=0;i<n;i++)\n\t\tscanf(\"%s\",ch[i]);//, prLLf(\"%s\\n\", ch[i]);\n\tfor(LL i=0;i<n;i++)\n\t\tfor(LL j=0;j<m;j++)\n\t\t\tscanf(\"%lld\",&price[get(i,j)]);\n\tfor(LL i=0;i<n;i++)\n\t\tfor(LL j=0;j<m;j++)\n\t\t\tscanf(\"%lld\",&onon[get(i,j)]);\n\tfor(LL i=0;i<n;i++)\n\t\tfor(LL j=0;j<m;j++)\n\t\t{\n\t\t\tscanf(\"%lld\",&offoff[get(i,j)]);\n\t\t\tonon[get(i,j)]+=offoff[get(i,j)];\n\t\t}\n\tfor(LL i=0;i<n;i++)\n\t\tfor(LL j=0;j<m;j++)\n\t\tif (ch[i][j]=='.')\n\t\t{\n\t\t\tif (i + 1 < n && ch[i+1][j]=='.') addedge(get(i,j),get(i+1,j));\n\t\t\tif (j + 1 < m && ch[i][j+1]=='.') addedge(get(i,j),get(i,j+1));\n\t\t}\n\tmemset(deep,-1,sizeof(deep));\n\tfor(LL i=0;i<n* m;i++)\n\t\tif(deep[i]==-1) dfs(i,-1,1);\n\tfor(LL i=1;i<=nump;i++)\n\t{\n\t\tLL x,y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tpoLL[i]=get(x,y);\n\t}\n\tpoLL[0]=poLL[1];\n\tnumpath=0;\n\tfor(LL i=0;i<nump;i++)\n\t{\n\t\tadd(poLL[i],poLL[i+1]);\n\t}\n\tfor(LL i=0;i<n * m;i++) last[i]=INF;\n\tLL ans=0;\n\t//for(LL i=1;i<=numpath;i++) cout<<path[i]<<' ';\n\tfor(LL i=numpath;i>=1;i--)\n\t{\n\t\tLL x=path[i];\n\t\tLL t1=(LL)(last[x]-i) * (LL)price[x];\n\t\tLL t2=onon[x];\n\t\tans+=min(t1,t2);\n\t\tlast[x]=i;\n\t}\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,int> mp;\n  vector<int> V;\n  int n = 0;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = n;\n        V.push_back(i*C+j);\n        ++n;\n      }\n    }\n  }\n  vector< vector< vector<int> > > G(n,vector< vector<int> >(n));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        int v = mp[x_*C+y_];\n        G[i][v].push_back(v);\n      }\n    }\n  }\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  vector< vector<int> > P(R, vector<int>(C)), ON = P, OFF = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> ON[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OFF[i][j];\n  vector<int> X(M), Y(M);\n  for(int i = 0; i < M; ++i)\n    cin >> X[i] >> Y[i];\n  vector<int> T(n,-1);\n  T[mp[X[0]*C+Y[0]]] = 0;\n  int t = 0;\n  long long int ans = ON[X[0]][Y[0]] + OFF[X[0]][Y[0]];\n  for(int i = 0; i < M-1; ++i){\n    int v = mp[X[i]*C+Y[i]], v_ = mp[X[i+1]*C+Y[i+1]];\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += ON[r][c] + OFF[r][c];\n      }else{\n        ans += min(ON[r][c] + OFF[r][c], P[r][c]*(t-T[k]));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef pair<int, int> pii;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\ntemplate <class T> constexpr bool in_range(T y, T x, T H, T W) {\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nstruct consumption {\n  int on, off, stay;\n  consumption() {}\n  consumption(int on, int off, int stay) : on(on), off(off), stay(stay) {}\n};\n\n/*------------------------------------------*/\nint H, W, M;\nvector<string> G;\nmap<pii, consumption> costs;\nvector<pii> vs;\nmap<pii, int> cnt;\n/*------------------------------------------*/\n\nint bfs(pii s, pii t) {\n\n  map<pii, int> dist;\n  dist[s] = 0;\n\n  queue<pii> q;\n  q.push(s);\n\n  while (!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if (y == t.first && x == t.second)\n      return dist[{y, x}];\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if (!in_range(ny, nx, H, W))\n        continue;\n      if (G[ny][nx] == '#')\n        continue;\n      if (dist.find({ny, nx}) == dist.end()) {\n        dist[{ny, nx}] = dist[{y, x}] + 1;\n        q.push({ny, nx});\n      }\n    }\n  }\n  assert(0);\n}\n\nvector<pii> make_path() {\n  vector<pii> path = {vs[0]};\n  queue<pii> q;\n  q.push(vs[0]);\n  set<pii> vis;\n  vis.insert(vs[0]);\n  pii prev[55][55];\n  int idx = 0;\n\n  while (!q.empty()) {\n    int y, x;\n    tie(y, x) = q.front();\n    q.pop();\n    if (idx + 1 >= vs.size())\n      continue;\n    if (y == vs[idx + 1].first && x == vs[idx + 1].second) {\n      vector<pii> pt;\n      pii curr = vs[idx + 1];\n      for (; curr != vs[idx]; curr = prev[curr.first][curr.second])\n        pt.push_back(curr);\n      reverse(all(pt));\n      for (auto &e : pt)\n        path.push_back(e);\n      idx++;\n      if (idx == vs.size())\n        break;\n      vis.clear();\n      vis.insert({y, x});\n      while (!q.empty())\n        q.pop();\n    }\n    rep(k, 4) {\n      int ny = y + dy[k], nx = x + dx[k];\n      if (!in_range(ny, nx, H, W))\n        continue;\n      if (G[ny][nx] == '#')\n        continue;\n      if (vis.count({ny, nx}))\n        continue;\n      vis.insert({ny, nx});\n      prev[ny][nx] = {y, x};\n      q.push({ny, nx});\n    }\n  }\n  return path;\n}\n\nvoid input() {\n  cin >> H >> W >> M;\n  G.resize(H);\n  rep(i, H) cin >> G[i];\n\n  int C[3][H][W];\n  rep(k, 3) rep(i, H) rep(j, W) cin >> C[k][i][j];\n  rep(i, H) rep(j, W) costs[{i, j}] = {C[1][i][j], C[2][i][j], C[0][i][j]};\n  rep(i, M) {\n    int r, c;\n    cin >> r >> c;\n    vs.emplace_back(r, c);\n  }\n}\n\nint main() {\n\n  input();\n\n  auto path = make_path();\n  for (auto e : path)\n    cnt[e]++;\n\n  int ans = 0;\n  map<pii, int> dist;\n  int currdist = 0;\n  pii prev = vs[0];\n\n  for (auto &&e : path) {\n    currdist += bfs(prev, e);\n    if (dist.find(e) == dist.end())\n      ans += costs[e].on;\n    else\n      ans +=\n          min(costs[e].off + costs[e].on, costs[e].stay * (currdist - dist[e]));\n    if (cnt[e] == 1)\n      ans += costs[e].off;\n    cnt[e]--;\n    dist[e] = currdist;\n    prev = e;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\n\nvp trail;\n\n\tint r,c,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nbool dfs(pii &cur,pii &to,vp &t,vs &field,vvi &visited){\n\tif(cur==to){\n\t\tREP(i,t.size()){\n\t\t\ttrail.push_back(t[i]);\n\t\t}\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint x=cur.second+dx[i],y=cur.first+dy[i];\n\t\tpii next=make_pair(y,x);\n\t\tif(x<0||y<0||x>=c||y>=r||field[y][x]=='#'||visited[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tvp nt(t);\n\t\tnt.push_back(next);\n\t\tvvi nv(visited);\n\t\tnv[y][x]=1;\n\t\tif(dfs(next,to,nt,field,nv))return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>r>>c>>m;\n\tvs field(r);\n\tREP(i,r){\n\t\tcin>>field[i];\n\t}\n\tvvi con(r,vi(c));\n\tvvi on(r,vi(c));\n\tvvi off(r,vi(c));\n\n\tREP(i,r)REP(j,c){\n\t\tcin>>con[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>on[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>off[i][j];\n\t}\n\n\tvp tasks(m);\n\tREP(i,m){\n\t\tcin>>tasks[i].first>>tasks[i].second;\n\t}\n\n\tFOR(i,1,m){\n\t\tvvi visited(r,vi(c));\n\t\tvp t;\n\t\tif(i==1){\n\t\t\tt.push_back(tasks[i-1]);\n\t\t}\n\t\tint x=tasks[i-1].second,y=tasks[i-1].first;\n\t\tvisited[y][x]=1;\n\t\tdfs(tasks[i-1],tasks[i],t,field,visited);\n\t}\n\n\tvvi last(r,vi(c,-1));\n\tint cost=0;\n\tREP(i,trail.size()){\n\t\tint y=trail[i].first,x=trail[i].second;\n\t\tif(last[y][x]==-1){\n\t\t\tcost+=on[y][x];\n\t\t}else if((i-last[y][x])*con[y][x]<on[y][x]+off[y][x]){\n\t\t\tcost+=(i-last[y][x])*con[y][x];\n\t\t}else{\n\t\t\tcost+=on[y][x]+off[y][x];\n\t\t}\n\t\tlast[y][x]=i;\n\t}\n\tint lt=trail.size();\n\tREP(y,r)REP(x,c){\n\t\tif(last[y][x]!=-1){\n\t\t\tcost+=off[y][x];\n\t\t}\n\t}\n\tcout<<cost<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_R 50\n#define MAX_C 50\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nbool inField(int x, int y, int C, int R)\n{\n    return (0 <= x && x < C && 0 <= y && y < R);\n}\n\nint main()\n{\n    int R, C, M;\n    char field[MAX_R][MAX_C];\n    cin >> R >> C >> M;\n    for (int i = 0; i < R; i++) {\n        for (int j = 0; j < C; j++) {\n            cin >> field[i][j];\n        }\n    }\n    int cost[3][MAX_R][MAX_C];\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < R; j++) {\n            for (int k = 0; k < C; k++) {\n                cin >> cost[i][j][k];\n            }\n        }\n    }\n    vector<int> X(M), Y(M);\n    for (int i = 0; i < M; i++) {\n        cin >> Y[i] >> X[i];\n    }\n\n    const int dx[] = {-1, 0, 1, 0};\n    const int dy[] = {0, -1, 0, 1};\n    \n    map<pii, vector<int>> vis;\n    int prev_d = 0;\n    for (int i = 1; i < M; i++) {\n        queue<pii> Q; Q.push(pii(X[i-1], Y[i-1]));\n        vector<vector<int>> d(MAX_R, vector<int>(MAX_C, INF));\n        vector<vector<int>> prev(MAX_R, vector<int>(MAX_C, INF));\n        d[Y[i-1]][X[i-1]] = prev_d;\n        while (!Q.empty()) {\n            pii p = Q.front(); Q.pop();\n            int x = p.first, y = p.second;\n            if (x == X[i] && y == Y[i]) {\n                prev_d = d[y][x];\n                break;\n            }\n            for (int j = 0; j < 4; j++) {\n                int nx = x + dx[j], ny = y + dy[j];\n                if (!inField(nx, ny, C, R) ||\n                    field[ny][nx] == '#') {\n                    continue;\n                }\n                if (d[y][x] + 1 < d[ny][nx]) {\n                    d[ny][nx] = d[y][x] + 1;\n                    prev[ny][nx] = y*C + x;\n                    Q.push(pii(nx, ny));\n                }\n            }\n        }\n        int x = X[i], y = Y[i];\n        vis[pii(x, y)].push_back(d[y][x]);           \n        while (x != X[i-1] || y != Y[i-1]) {           \n            int nx = x, ny = y;\n            nx = prev[y][x] % C;\n            ny = prev[y][x] / C;\n            x = nx; y = ny;\n            vis[pii(x, y)].push_back(d[y][x]);           \n        }\n    }\n    int sum = 0;\n    for (auto &v : vis) {\n        int x = v.first.first;\n        int y = v.first.second;\n        vector<int> p = v.second;\n        sum += cost[1][y][x] + cost[2][y][x];\n        if (p.size() > 1) {\n            for (int i = 1; i < (int)p.size(); i++) {\n                sum += min(cost[2][y][x] + cost[1][y][x], (p[i] - p[i-1]) * cost[0][y][x]);\n            }\n        }\n    }\n    cout << sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <cstdlib>\n#include <map>\n#include <memory.h>\n#include <vector>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\ntypedef pair<int, int> P;\nconst double EPS = 1e-12;\nconst int INF = 1 << 29;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, -1, 0, 1};\nP par[60][60];\nchar field[60][60];\nint oncost[60][60];\nint offcost[60][60];\nint keepcost[60][60];\nint dist[60][60];\nint r[2000];\nint c[2000];\n\nvector<int> visit[60][60];\nint R, C, M;\n\nvoid bfs(int sr, int sc){\n  int r, c;\n  queue<P> que;\n  que.push(P(sr, sc));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    r = p.first;\n    c = p.second;\n    rep(i, 4){\n      int r2 = r + dy[i];\n      int c2 = c + dx[i];\n      if(0 <= r2 && r2 < R && 0 <= c2 && c2 < C && dist[r2][c2] == -1 && field[r2][c2] == '.'){\n\tdist[r2][c2] = dist[r][c] + 1;\n\tque.push(P(r2, c2));\n\tpar[r2][c2] = p;\n      }\n    }\n  }\n}\n\nint main(){\n  cin >> R >> C >> M;\n  rep(i, R) rep(j, C) cin >> field[i][j];\n  rep(i, R) rep(j, C) cin >> keepcost[i][j];\n  rep(i, R) rep(j, C) cin >> oncost[i][j];\n  rep(i, R) rep(j, C) cin >> offcost[i][j];\n  rep(i,M){\n    cin >> r[i] >> c[i];\n  }\n  int t = 0;\n  int res = 0;\n  rep(i, M - 1){\n    memset(dist, -1, sizeof(dist));\n    memset(par, -1, sizeof(par));\n    dist[r[i]][c[i]] = 0;\n    bfs(r[i], c[i]);\n    for(P p = P(r[i+1], c[i+1]); p.first != -1; p = par[p.first][p.second]){\n      visit[p.first][p.second].push_back(t + dist[p.first][p.second]);\n    }\n    t += dist[r[i+1]][c[i+1]];\n  }\n  rep(i, R)rep(j, C){\n\n    if(!visit[i][j].empty()){\n      sort(visit[i][j].begin(), visit[i][j].end());\n      res += oncost[i][j] + offcost[i][j];\n      rep(k, (int)visit[i][j].size() - 1){\n\tint d = visit[i][j][k+1] - visit[i][j][k];\n\tint add = min(d * keepcost[i][j], oncost[i][j] + offcost[i][j]); \n\tres += add;\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define M 1005\n#define N 51\nusing namespace std;\nint r,c,m,gy,gx,T,ans;\nint C[3][N][N];\nbool used[N][N];\nstring s[N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nint d[N][N];\n\nvoid update(int y,int x,int t){\n  if(d[y][x]==-1)ans+=C[1][y][x]+C[2][y][x];\n  else ans+=min((t-d[y][x])*C[0][y][x],\n\t\tC[1][y][x]+C[2][y][x]);\n  d[y][x]=t;\n}\n\nbool dfs(int y,int x,int t){\n  \n  if(used[y][x])return false;\n  used[y][x]=true;\n  \n  if(y==gy&&x==gx){\n    update(y,x,t);\n    T=t;\n    return true;\n  }\n  \n  bool res=false;\n  rep(i,4){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0||r<=ny||c<=nx)continue;\n    if(s[ny][nx]=='#')continue;\n    res|=dfs(ny,nx,t+1);\n  }\n  if(res)update(y,x,t);\n  \n  return res;\n}\n\nint y[M],x[M];\n\nint main(){\n  cin>>r>>c>>m;\n  rep(i,r)cin>>s[i];\n  \n  rep(i,3)\n    rep(j,r)\n      rep(k,c)cin>>C[i][j][k];\n  \n  rep(i,m)cin>>y[i]>>x[i];\n  \n  memset(d,-1,sizeof(d));\n  \n  rep(i,m-1){\n    gy=y[i+1],gx=x[i+1];\n    memset(used,0,sizeof(used));\n    dfs(y[i],x[i],T);\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<map>\n\nusing namespace std;\n\n#define M 54\n#define S 1003\n#define INF 100000000\n\n#define min(a,b) (a>b?b:a)\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> IP;\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nstruct Maps {\n\tint cost, time;\n\tint prevx, prevy;\n};\n\nint main() {\n\tint r, c, m, costcons[M][M], coston[M][M], costoff[M][M];\n\tint last[M][M], cost, time;\n\tchar mapc[M][M]; int cx[S], cy[S];\n\tMaps maps[M][M];\n\tstack<IP> s;\n\t\n\tcin >> r >> c >> m;\n\tfor(int i=0; i<=r+1; ++i) for(int j=0; j<=c+1; ++j) mapc[i][j] = '#';\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> mapc[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> costcons[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> coston[i][j];\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) cin >> costoff[i][j];\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> cy[i] >> cx[i]; ++cx[i]; ++cy[i];\n\t}\n\t\n\tcost = coston[cy[0]][cx[0]] + costoff[cy[0]][cx[0]]; time = 0;\n\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) last[i][j] = -1;\n\tlast[cy[0]][cx[0]] = 0;\n\tfor(int t=0; t<m-1; ++t) {\n\t\tfor(int i=1; i<=r; ++i) for(int j=1; j<=c; ++j) {\n\t\t\tmaps[i][j].cost = INF; maps[i][j].time = -1;\n\t\t}\n\t\ts.push(IP(time, P(cx[t], cy[t])));\n\t\tmaps[cy[t]][cx[t]].cost = cost; maps[cy[t]][cx[t]].time = time;\n\t\tmaps[cy[t]][cx[t]].prevx = cx[t]; maps[cy[t]][cx[t]].prevy = cy[t];\n\t\twhile(!s.empty()) {\n\t\t\tint ti = s.top().first;\n\t\t\tint x = s.top().second.first, y = s.top().second.second;\n\t\t\ts.pop();\n\t\t\tfor(int k=0; k<4; ++k) {\n\t\t\t\tint nx = x+dx[k], ny = y+dy[k];\n\t\t\t\tif(mapc[ny][nx]=='.') {\n\t\t\t\t\tint pcost = coston[ny][nx] + costoff[ny][nx];\n\t\t\t\t\tif(last[ny][nx]!=-1) {\n\t\t\t\t\t\tpcost = min(pcost, (ti+1-last[ny][nx])*costcons[ny][nx]);\n\t\t\t\t\t}\n\t\t\t\t\tif((maps[y][x].cost + pcost < maps[ny][nx].cost) ||\n\t\t\t\t\t\t(maps[y][x].cost+pcost==maps[ny][nx].cost && ti+1<maps[y][x].time)) {\n\t\t\t\t\t\tmaps[ny][nx].cost = maps[y][x].cost + pcost;\n\t\t\t\t\t\tmaps[ny][nx].time = ti+1;\n\t\t\t\t\t\tmaps[ny][nx].prevx = x; maps[ny][nx].prevy = y;\n\t\t\t\t\t\tif(nx!=cx[t+1] || ny!=cy[t+1]) {\n\t\t\t\t\t\t\ts.push(IP(ti+1, P(nx, ny)));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint px = cx[t+1], py = cy[t+1], pxl, pyl;\n\t\tint timel = maps[cy[t+1]][cx[t+1]].time;\n\t\twhile(px!=cx[t] || py!=cy[t]) {\n\t\t\tlast[py][px] = timel;\n\t\t\t--timel;\n\t\t\tpxl = px; pyl = py;\n\t\t\tpx = maps[pyl][pxl].prevx; py = maps[pyl][pxl].prevy;\n\t\t}\n\t\ttime = maps[cy[t+1]][cx[t+1]].time;\n\t\tcost = maps[cy[t+1]][cx[t+1]].cost;\n\t}\n\tcout << cost << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[2] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstdio>\n#include <string>\n\nusing namespace std;\n\ntypedef vector<vector<int> > Matrix;\ntypedef pair<int, int> Pos;\n\nint dr[] = {0, 1, 0, -1};\nint dc[] = {1, 0, -1, 0};\n\ninline bool inRange(int a, int x, int b) {\n    return a <= x && x < b;\n}\n\nint main() {\n    int R, C, M;\n    scanf(\"%d %d %d\", &R, &C, &M);\n\n    vector<string> v;\n    char buf[100];\n    for(int i = 0; i < R; ++i) {\n        scanf(\" %s\", buf);\n        v.push_back(string(buf));\n    }\n\n    Matrix cons(R), on(R), off(R);\n    for(int r = 0; r < R; ++r) {\n        for(int c = 0; c < C; ++c) {\n            int n;\n            scanf(\" %d\", &n);\n            cons[r].push_back(n);\n        }\n    }\n    for(int r = 0; r < R; ++r) {\n        for(int c = 0; c < C; ++c) {\n            int n;\n            scanf(\" %d\", &n);\n            on[r].push_back(n);\n        }\n    }\n    for(int r = 0; r < R; ++r) {\n        for(int c = 0; c < C; ++c) {\n            int n;\n            scanf(\" %d\", &n);\n            off[r].push_back(n);\n        }\n    }\n\n    vector<pair<int, int> > room;\n    vector<vector<vector<int> > > time_seq(R, vector<vector<int> >(C));\n    Pos prev_pos;\n    int curtime = 0;\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n\n        if(i == 0) {\n            time_seq[a][b].push_back(curtime++);\n        }\n        else {\n            const Pos goal(a, b);\n            vector<vector<Pos> > prev(R, vector<Pos>(C, make_pair(-1, -1)));\n            queue<Pos> q;\n            q.push(prev_pos);\n            while(!q.empty()) {\n                Pos p = q.front();\n                q.pop();\n\n                if(p == goal) {\n                    Pos cur = p;\n                    vector<Pos> route;\n                    while(cur != prev_pos) {\n                        route.push_back(cur);\n                        cur = prev[cur.first][cur.second];\n                    }\n                    //cout << \"route \";\n                    for(int i = route.size()-1; i >= 0; --i) {\n                        //cout << '(' << route[i].first << ' ' << route[i].second << \") \";\n                        const Pos &pp = route[i];\n                        time_seq[pp.first][pp.second].push_back(curtime++);\n                    }\n                    //cout << endl;\n                    break;\n                }\n                for(int i = 0; i < 4; ++i) {\n                    int nr = p.first + dr[i];\n                    int nc = p.second + dc[i];\n                    if(inRange(0, nr, R) && inRange(0, nc, C) && v[nr][nc] == '.' && prev[nr][nc].first == -1) {\n                        prev[nr][nc] = p;\n                        q.push(Pos(nr, nc));\n                    }\n                }\n            }\n        }\n        prev_pos = make_pair(a, b);\n    }\n\n    //time_seq[prev_pos.first][prev_pos.second].push_back(curtime++);\n\n    int cost = 0;\n    for(int r = 0; r < R; ++r) {\n        for(int c = 0; c < C; ++c) {\n            bool state = false;\n            const vector<int> &seq = time_seq[r][c];\n\n            for(int i = 0; i < seq.size(); ++i) {\n                //cout << r << ' ' << c << ' ' << seq[i] << endl;\n                if(state == false) {\n                    cost += on[r][c];\n                    state = true;\n                }\n\n                if(i+1 < seq.size()) {\n                    int cons_is_on = cons[r][c] * (seq[i+1]-seq[i]);\n                    if(off[r][c] + on[r][c] > cons_is_on) {\n                        cost += cons_is_on;\n                    }\n                    else {\n                        cost += off[r][c];\n                        state = false;\n                    }\n                }\n                else {\n                    cost += off[r][c];\n                    state = false;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", cost);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing vi = vector<int>;\n\nconst int N = 50;\nconst int INF = 19191919;\n\nint r,c,m;\nstring s[N];\nint comp[N][N], on[N][N], off[N][N];\npi task[1000];\n\nvi t[N][N];\n\nvector<pi> route(pi start, pi goal)\n{\n    int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n    #define IN(y,x) (0<=y && y<r && 0<=x && x<c)\n\n    vector<vi> d(r,vi(c,INF));\n    vector<vector<pi>> par(r,vector<pi>(c));\n    queue<pi> que;\n\n    d[start.fi][start.se]=0;\n    que.push(start);\n\n    while(!que.empty())\n    {\n        pi now = que.front();\n        que.pop();\n        rep(i,4)\n        {\n            int nx=now.se+dx[i], ny=now.fi+dy[i];\n            if(IN(ny,nx) && s[ny][nx]=='.' && d[ny][nx]>d[now.fi][now.se]+1)\n            {\n                d[ny][nx] = d[now.fi][now.se]+1;\n                par[ny][nx] = now;\n                que.push({ny,nx});\n            }\n        }\n    }\n\n    vector<pi> ret;\n    pi now=goal;\n    while(now != start)\n    {\n        ret.pb(now);\n        now = par[now.fi][now.se];\n    }\n    reverse(all(ret));\n    return ret;\n}\n\nint main()\n{\n    cin >>r >>c >>m;\n    rep(i,r) cin >>s[i];\n    rep(i,r)rep(j,c) cin >>comp[i][j];\n    rep(i,r)rep(j,c) cin >>on[i][j];\n    rep(i,r)rep(j,c) cin >>off[i][j];\n    rep(i,m) cin >>task[i].fi >>task[i].se;\n\n    vector<pi> vis;\n    vis.pb(task[0]);\n    rep(i,m-1)for(const auto &p:route(task[i],task[i+1])) vis.pb(p);\n\n    rep(i,vis.size())\n    {\n        int y=vis[i].fi, x=vis[i].se;\n        t[y][x].pb(i);\n    }\n\n    ll ans = 0;\n    rep(i,r)rep(j,c)if(t[i][j].size()>0)\n    {\n        ll add = on[i][j]+off[i][j];\n\n        vi stamp = t[i][j];\n        int S = stamp.size();\n        rep(k,S-1) add += min(on[i][j]+off[i][j], comp[i][j]*(stamp[k+1]-stamp[k]));\n\n        ans += add;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n, m, r;\nstring s[50];\nint c[3][50][50];\nint xx[1000], yy[1000];\nvector<int> tt[50][50];\nint dp[1010][2];\n\nint dfs(int x, int y, int px, int py, int gx, int gy, int ct){\n  tt[x][y].push_back(ct);\n  if (x == gx && y == gy) return 0;\n  rep(i, 4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx == px && ny == py) continue;\n    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n    if (s[nx][ny] == '#') continue;\n    int t = dfs(nx, ny, x, y, gx, gy, ct + 1);\n    if (t < inf) return t + 1;\n  }\n  tt[x][y].pop_back();\n  return inf;\n}\n\nint main(){\n  cin >> n >> m >> r;\n  rep(i, n) cin >> s[i];\n  rep(i, 3) rep(j, n) rep(k, m) cin >> c[i][j][k];\n  rep(i, r) cin >> xx[i] >> yy[i];\n  int ct = 0;\n  rep(i, r - 1){\n    ct += dfs(xx[i], yy[i], xx[i], yy[i], xx[i + 1], yy[i + 1], ct);\n  }\n  int res = 0;\n  rep(ii, n) rep(jj, m){\n    if (s[ii][jj] == '#') continue;\n    auto v = tt[ii][jj];\n    v.push_back(v.back());\n    /*if (v.size() == 1){\n      res += c[1][ii][jj] + c[2][ii][jj];\n      continue;\n    }*/\n    fill_n(*dp, 1010 * 2, inf);\n    dp[0][0] = 0;\n    rep(i, v.size() - 1){\n      chmin(dp[i + 1][0], dp[i][0] + c[1][ii][jj] + c[2][ii][jj]);\n      chmin(dp[i + 1][0], dp[i][1] + c[2][ii][jj]);\n      chmin(dp[i + 1][1], dp[i][0] + c[1][ii][jj] + c[0][ii][jj] * (v[i + 1] - v[i]));\n      chmin(dp[i + 1][1], dp[i][1] + c[0][ii][jj] * (v[i + 1] - v[i]));\n    }\n    res += dp[v.size() - 1][0];\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint dr[] = {1, 0, -1, 0};\nint dc[] = {0, 1, 0, -1};\n\nint R, C, M, ans;\nint now=1, sr, sc, tr, tc;\nint on[55][55], off[55][55], kp[55][55];\nint time[55][55];\nint taskr[1010], taskc[1010];\nbool vis[55][55];\nchar g[55][55];\n\ninline bool check(int r, int c)\n{\n\tif (r<0 || r>=R) return 0;\n\tif (c<0 || c>=C) return 0;\n\tif (g[r][c]=='#') return 0;\n\treturn 1;\n}\n\nvoid homura(int r, int c, int t)\n{\n\tif (time[r][c]==0)\n\t\tans += on[r][c];\n\telse\n\t\tans += min(on[r][c]+off[r][c], kp[r][c]*(t-time[r][c]));\n\ttime[r][c] = t;\n}\n\nbool dfs(int r, int c, int t)\n{\n\tvis[r][c] = 1;\n\tif (r==tr && c==tc)\n\t{\n\t\tnow = t;\n\t\treturn 1;\n\t}\n\tint nr, nc;\n\tfor (int i = 0; i < 4; ++i)\n\t{\n\t\tnr = r+dr[i]; nc = c+dc[i];\n\t\tif (vis[nr][nc] || !check(nr, nc)) continue;\n\t\tif (dfs(nr, nc, t+1))\n\t\t{\n\t\t\thomura(r, c, t);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, r, c;\n\tscanf(\"%d%d%d\", &R, &C, &M);\n\tfor (r = 0; r < R; ++r)\n\t\tscanf(\"%s\", g[r]);\n\tfor (r = 0; r < R; ++r)\n\t\tfor (c = 0; c < C; ++c)\n\t\t\tscanf(\"%d\", &kp[r][c]);\n\tfor (r = 0; r < R; ++r)\n\t\tfor (c = 0; c < C; ++c)\n\t\t\tscanf(\"%d\", &on[r][c]);\n\tfor (r = 0; r < R; ++r)\n\t\tfor (c = 0; c < C; ++c)\n\t\t\tscanf(\"%d\", &off[r][c]);\n\tfor (i = 0; i < M; ++i)\n\t\tscanf(\"%d%d\", &taskr[i], &taskc[i]);\n\tfor (i = 0; i < M-1; ++i)\n\t{\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tsr = taskr[i], sc = taskc[i];\n\t\ttr = taskr[i+1], tc = taskc[i+1];\n\t\tdfs(sr, sc, now);\n\t}\n\thomura(taskr[M-1], taskc[M-1], now);\n\tfor (r = 0; r < R; ++r)\n\t\tfor (c = 0; c < C; ++c)\n\t\t\tif (time[r][c]) ans += off[r][c];\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\n\nusing Cost = tuple<int, int, int>;\n\nint h, w;\nvector<string> field;\nvector<vector<Cost>> cost;\nvector<vvi> time_visited;\nvector<pii> task;\n\nvi dx = { 1, 0,-1, 0};\nvi dy = { 0,-1, 0, 1};\n\nbool dfs(pii pos, pii z, vector<pii> & route, vvi & used){\n    if(used[pos.first][pos.second]) return false;\n    used[pos.first][pos.second] = true;\n    if(pos == z){\n        route.push_back(pos);\n        return true;\n    }\n\n    rep(i, 4){\n        pii npos(pos.first + dy[i], pos.second + dx[i]);\n\n        if(npos.first < 0 || h <= npos.first ||\n           npos.second< 0 || w <= npos.second||\n           field[npos.first][npos.second] == '#'){\n            continue;\n        }\n\n        if(dfs(npos, z, route, used)){\n            route.push_back(pos);\n            return true;\n        }\n    }\n\n    return false;\n}\n\nint main(void){\n    int m; cin >> h >> w >> m;\n\n    field = vector<string>(h);\n    for(auto & e : field) cin >> e;\n\n    cost = vector<vector<Cost>>(h, vector<Cost>(w));\n    rep(y, h) rep(x, w) cin >> get<0>(cost[y][x]);\n    rep(y, h) rep(x, w) cin >> get<1>(cost[y][x]);\n    rep(y, h) rep(x, w) cin >> get<2>(cost[y][x]);\n\n    task = vector<pii>(m);\n    for(auto & e : task) cin >> e.first >> e.second;\n\n    time_visited = vector<vvi>(h, vvi(w));\n    pii pos = task[0];\n    int t = 0;\n    time_visited[pos.first][pos.second].push_back(t++);\n\n    rep(i, m){\n        vector<pii> route;\n        vvi used(h, vi(w));\n\n        dfs(pos, task[i], route, used);\n        reverse(begin(route), end(route));\n\n        for(auto & e : route){\n            if(pos == e) continue;\n            \n            pos = e;\n            time_visited[pos.first][pos.second].push_back(t++);\n        }\n    }\n\n    int res = 0;\n    rep(y, h){\n        rep(x, w){\n            int c_on, c_off, c_keep;\n            tie(c_keep, c_on, c_off) = cost[y][x];\n\n            if((int)time_visited[y][x].size() == 0) continue;\n\n            res += c_on;\n            rep(i, (int)time_visited[y][x].size() - 1){\n                int diff = time_visited[y][x][i + 1] - time_visited[y][x][i];\n\n                res += min(c_off + c_on, c_keep * diff);\n            }\n            res += c_off;\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Graph=vector<vector<int>>;\nint dr[]={1,0,-1,0};\nint dc[]={0,1,0,-1};\nusing ll=long long;\nconst ll INF=1e9;\nint main(){\n    int r,c,m;\n    cin>>r>>c>>m;\n    vector<string> f(r);\n    for(int i=0;i<r;i++) cin>>f[i];\n    vector<ll> keep(r*c);\n    vector<ll> on(r*c);\n    vector<ll> off(r*c);\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>keep[i*c+j];\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>on[i*c+j];\n    for(int i=0;i<r;i++) for(int j=0;j<c;j++) cin>>off[i*c+j];\n    vector<int> task(m);\n    for(int i=0;i<m;i++){\n        int x,y;\n        cin>>x>>y;\n        task[i]=x*c+y;\n    }\n    auto vertex=[&](int i,int j){\n        return i*c+j;\n    };\n    int n=r*c;\n    Graph g(n);\n    for(int i=0;i<r;i++){\n        for(int j=0;j<c;j++){\n            if(f[i][j]=='#') continue;\n            for(int k=0;k<4;k++){\n                int tor=i+dr[k],toc=j+dc[k];\n                if(0<=tor && tor<r && 0<=toc && toc<c && f[tor][toc]=='.'){\n                    g[vertex(i,j)].push_back(vertex(tor,toc));\n                }\n            }\n        }\n    }\n    vector<vector<int>> route(n,vector<int>(n));\n\n    function<void(int,int,vector<int>&,int)> dfs=[&](int v,int pre,vector<int>& vec,int org){\n        if(v!=org){\n            vec.push_back(v);\n            route[org][v]=vec[0];\n        }\n        for(auto &to:g[v]){\n            if(pre!=to) dfs(to,v,vec,org);\n        }\n        vec.pop_back();\n    };\n    for(int i=0;i<r;i++){\n        for(int j=0;j<c;j++){\n            if(f[i][j]=='#') continue;\n            int v=vertex(i,j);\n            vector<int> vec;\n            dfs(v,-1,vec,v);\n        }\n    }\n    vector<ll> t(n,-INF);\n    ll syst=0;\n    ll res=on[task[0]]+off[task[0]];\n    t[0]=syst++;\n    for(int i=0;i+1<m;i++){\n        int v=task[i];\n        while(v!=task[i+1]){\n            int to=route[v][task[i+1]];\n            res+=min(on[to]+off[to],(syst-t[to])*keep[to]);\n            t[to]=syst++;\n            v=to;\n        }\n    }\n    cout<<res<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\n\n\nvp trail;\n\nint r,c,m;\nint dx[]={-1,0,1,0},dy[]={0,-1,0,1};\nint tx,ty;\nbool dfs(int cx,int cy,vp &t,vs &field,bool visited[][50]){\n\tvisited[cy][cx]=1;\n\tif(cx==tx&&cy==ty){\n\t\tREP(i,t.size()){\n\t\t\ttrail.push_back(t[i]);\n\t\t}\n\t\treturn true;\n\t}\n\tREP(i,4){\n\t\tint x=cx+dx[i],y=cy+dy[i];\n\t\tif(x<0||y<0||x>=c||y>=r||field[y][x]=='#'||visited[y][x]){\n\t\t\tcontinue;\n\t\t}\n\t\tvp nt(t);\n\t\tnt.push_back(make_pair(y,x));\n\t\tif(dfs(x,y,nt,field,visited))return true;\n\t}\n\treturn false;\n}\n\nint main(){\n\tcin>>r>>c>>m;\n\tvs field(r);\n\tREP(i,r){\n\t\tcin>>field[i];\n\t}\n\tvvi con(r,vi(c));\n\tvvi on(r,vi(c));\n\tvvi off(r,vi(c));\n\n\tREP(i,r)REP(j,c){\n\t\tcin>>con[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>on[i][j];\n\t}\n\tREP(i,r)REP(j,c){\n\t\tcin>>off[i][j];\n\t}\n\n\tvp tasks(m);\n\tREP(i,m){\n\t\tcin>>tasks[i].first>>tasks[i].second;\n\t}\n\n\tFOR(i,1,m){\n\t\tbool visited[50][50]={};\n\t\tvp t;\n\t\tif(i==1){\n\t\t\tt.push_back(tasks[i-1]);\n\t\t}\n\t\ttx=tasks[i].second;\n\t\tty=tasks[i].first;\n\t\tdfs(tasks[i-1].second,tasks[i-1].first,t,field,visited);\n\t}\n\n\tvvi last(r,vi(c,-1));\n\tint cost=0;\n\tREP(i,trail.size()){\n\t\tint y=trail[i].first,x=trail[i].second;\n\t\tif(last[y][x]==-1){\n\t\t\tcost+=on[y][x];\n\t\t}else if((i-last[y][x])*con[y][x]<on[y][x]+off[y][x]){\n\t\t\tcost+=(i-last[y][x])*con[y][x];\n\t\t}else{\n\t\t\tcost+=on[y][x]+off[y][x];\n\t\t}\n\t\tlast[y][x]=i;\n\t}\n\tint lt=trail.size();\n\tREP(y,r)REP(x,c){\n\t\tif(last[y][x]!=-1){\n\t\t\tcost+=off[y][x];\n\t\t}\n\t}\n\tcout<<cost<<endl;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nstruct Tnode\n{\n\tlong long On , Off , Keep;\n};\n\nstruct Task\n{\n\tint x , y;\n};\n\nconst int dx[4] = { 0 , 0 , -1 , 1 };\nconst int dy[4] = { -1 , 1 , 0 , 0 };\nconst int maxn = 107 , maxq = 10007;\n\t  int n , m , q;\n\t  long long res , Time;\n\t  long long T[maxn][maxn];\n\t  Task ask[maxq];\n\t  Tnode node[maxn][maxn];\n\t  char Map[maxn][maxn];\n\t  bool use[maxn][maxn];\n\t  \nvoid init()\n{\n\tfor ( int i = 1 ; i <= n ; i++ ) scanf( \"%s\" , Map[i]+1 );\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t\tfor ( int j = 1 ; j <= m ; j++ ) cin >> node[i][j].Keep;\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t\tfor ( int j = 1 ; j <= m ; j++ ) cin >> node[i][j].On;\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t\tfor ( int j = 1 ; j <= m ; j++ ) cin >> node[i][j].Off;\n\tfor ( int i = 1 ; i <= q ; i++ ) scanf( \"%d %d\" , &ask[i].x , &ask[i].y ) , ask[i].x++ , ask[i].y++;\n}\n\nbool check_map( int x , int y )\n{\n\tif ( x < 1 || x > n ) return false;\n\tif ( y < 1 || y > m ) return false;\n\tif ( Map[x][y] == '#' ) return false;\n\treturn use[x][y];\n}\n\nvoid put_time( int x , int y , long long TIME )\n{\n\tif ( T[x][y] == 0 ) res += node[x][y].On;\n\telse\t\t\t\tres += min(node[x][y].On+node[x][y].Off,node[x][y].Keep*(TIME-T[x][y]));\n\tT[x][y] = TIME;\n}\n\nbool dfs( int x , int y , Task End , long long TIME )\n{\n\tuse[x][y] = false;\n\tif ( End.x == x && End.y == y )\n\t{\n\t\tTime = TIME;\n\t\treturn true; \n\t}\n\tfor ( int i = 0 ; i < 4 ; i++ )\n\t{\n\t\tint xx = x+dx[i] , yy = y+dy[i];\n\t\tif ( check_map(xx,yy) )\n\t\t\tif ( dfs(xx,yy,End,TIME+1) )\n\t\t\t{\n\t\t\t\tput_time(x,y,TIME);\n\t\t\t\treturn true;\n\t\t\t}\t\n\t}\n\treturn false;\n}\n\nvoid work()\n{\n\tinit();\n\tmemset( T , 0 , sizeof(T) ); \n\tTime = 1 , res = 0;\n\tfor ( int i = 1 ; i < q ; i++ ) \n\t{\n\t\tmemset( use , true , sizeof(use) );\n\t\tdfs(ask[i].x,ask[i].y,ask[i+1],Time);\n\t}\n\tput_time(ask[q].x,ask[q].y,Time);\n\tfor ( int i = 1 ; i <= n ; i++ )\n\t\tfor ( int j = 1 ; j <= m ; j++ )\n\t\t\tif ( T[i][j] > 0 ) res += node[i][j].Off;\n\tcout << res << endl;\n}\n\nint main()\n{\n\twhile ( scanf( \"%d %d %d\" , &n , &m , &q ) != EOF ) work();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    //cout << a << \" \";\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    //o\n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        int a = M[make_pair(x[i - 1], y[i - 1])];\n        int b = M[make_pair(x[i], y[i])];\n        vector<bool> used(num, false);\n        bool end = false;\n        used[a] = true;\n        dfs(end, a, b, adjlist, node[i], used);\n    }\n\n\n    //x\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<string.h>\n#define clr(x,y) memset(x,y,sizeof(x))\nusing namespace std;\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nchar g[60][60];\nint x[1005],y[1005];\nint a[60][60],b[60][60],c[60][60];\nbool vis[60][60];\nint n,m,k,i,j,T,ex,ey;\nvector<int> vc[60][60];\n\nbool dfs(int x,int y,int t){\n    if(vis[x][y]) return false;\n    vis[x][y]=true;\n    if(x==ex&&y==ey){\n        T=t;\n        return true;\n    }\n    for(int i=0;i<4;i++){\n        int xx=x+dx[i],yy=y+dy[i];\n        if(xx<0||xx>=n||yy<0||yy>=m||g[xx][yy]=='#') continue;\n        if(dfs(xx,yy,t+1)){\n            vc[x][y].push_back(t);\n            return true;\n        }\n    }\n    return false;\n}\nint main(){\n//    freopen(\"in.txt\",\"r\",stdin);\n    scanf(\"%d%d%d\",&n,&m,&k);\n    for(i=0;i<n;i++) scanf(\"%s\",g[i]);\n    for(i=0;i<n;i++) for(j=0;j<m;j++) scanf(\"%d\",&b[i][j]);\n    for(i=0;i<n;i++) for(j=0;j<m;j++) scanf(\"%d\",&a[i][j]);\n    for(i=0;i<n;i++) for(j=0;j<m;j++) scanf(\"%d\",&c[i][j]);\n\n    T=0;\n    for(i=1;i<=k;i++){\n        clr(vis,0);\n        scanf(\"%d%d\",&x[i],&y[i]);\n        ex=x[i],ey=y[i];\n        if(i==1) continue;\n        dfs(x[i-1],y[i-1],T);\n    }\n    vc[x[k]][y[k]].push_back(T);\n    int ans=0;\n    for(i=0;i<n;i++){\n        for(j=0;j<m;j++){\n            if(vc[i][j].size()==0) continue;\n            ans+=a[i][j]+c[i][j];\n            for(k=0;k<vc[i][j].size()-1;k++){\n                int t1=(vc[i][j][k+1]-vc[i][j][k])*b[i][j];\n                int t2=a[i][j]+c[i][j];\n                ans+=min(t1,t2);\n            }\n        }\n    }\n//    for(i=0;i<n;i++){\n//        for(j=0;j<m;j++){\n//            printf(\"%d \",vc[i][j].size());\n//        }\n//        puts(\"\");\n//    }\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001;\n\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\n\nint H,W,N;\nchar fld[55][55];\n\nint D[50][50][50][50];\n\nvoid bfs(int sy,int sx){\n    fill_n(*D[sy][sx],2500,INF);\n    D[sy][sx][sy][sx]=0;\n    queue<pint>que;\n    que.push(pint(sy,sx));\n    while(que.size()){\n        int y,x;\n        tie(y,x)=que.front();\n        que.pop();\n        rep(i,4){\n            int ny=y+dy[i],nx=x+dx[i];\n            if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]=='#'||D[sy][sx][ny][nx]!=INF)continue;\n            D[sy][sx][ny][nx]=D[sy][sx][y][x]+1;\n            que.push(pint(ny,nx));\n        }\n    }\n}\n\nint r[50][50],n[50][50],f[50][50];\n\nvint ev[50][50];\n\nint dp[1111][2];\n\nint calc(vint vec,int r,int n,int f){\n    fill_n(*dp,1111*2,INF);\n    dp[0][0]=0;\n    rep(i,vec.size()){\n        int t=min(dp[i][0]+n,dp[i][1]+vec[i]*r);\n        dp[i+1][0]=t+f;\n        dp[i+1][1]=t-r*vec[i];\n    }\n    return dp[vec.size()][0];\n}\n\nsigned main(){\n    cin>>H>>W>>N;\n    rep(i,H)cin>>fld[i];\n    rep(i,H)rep(j,W)if(fld[i][j]=='.')bfs(i,j);\n\n\n    rep(i,H)rep(j,W)cin>>r[i][j];\n    rep(i,H)rep(j,W)cin>>n[i][j];\n    rep(i,H)rep(j,W)cin>>f[i][j];\n\n    int y,x;cin>>y>>x;\n    ev[y][x].pb(0);\n    int t=0;\n    rep(i,N-1){\n        int yy,xx;\n        cin>>yy>>xx;\n        while(y!=yy||x!=xx){\n            int d=-1;\n            rep(i,4){\n                int ny=y+dy[i],nx=x+dx[i];\n                if(ny<0||ny>=H||nx<0||nx>=W||fld[ny][nx]=='#')continue;\n                if(D[y][x][yy][xx]==D[ny][nx][yy][xx]+1)d=i;\n            }\n\n            y+=dy[d];x+=dx[d];t++;\n            ev[y][x].pb(t);\n        }\n    }\n\n    int ans=0;\n    rep(i,H)rep(j,W)ans+=calc(ev[i][j],r[i][j],n[i][j],f[i][j]);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 51\nusing namespace std;\nint h,w,m;\nstring mp[N];\nint c[N*N],on[N*N],off[N*N];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nvector<int> path;\nint used[N*N];\nint dfs(int pos,int t){\n  if(pos==t) return 1;\n  if(used[pos]++) return 0;\n  int x = pos%w,y=pos/w;\n\n  for(int i=0;i<4;i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    int npos = w*ny+nx;\n    if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]=='#')continue;\n    if(dfs(npos,t)){path.push_back(npos);return 1;}\n  }\n  return 0;\n}\n\nvector<int> job;\nint calc(){\n  int res=0,sta[N*N]={},cnt=2; \n  res+=on[job[0]];\n  sta[job[0]] = 1;\n  for(int i=0;i<m-1;i++){\n    path.clear();\n    memset(used,0,sizeof(used));\n    dfs(job[i],job[i+1]);\n    for(int j=0;j<(int)path.size();j++){\n      int pos = path[path.size()-j-1];\n      int T = sta[pos];\n      if(T==0) res+=on[pos];\n      else res+=min(on[pos]+off[pos],c[pos]*(cnt-sta[pos]));\n      sta[pos]=cnt++;\n    }\n  }\n  for(int i=0;i<h*w;i++)if(sta[i])res+=off[i];\n  return res;\n}\n\n\n\nint main(){\n  cin>>h>>w>>m;\n  for(int i=0;i<h;i++) cin>>mp[i];\n  for(int i=0;i<h*w;i++) cin>>c[i];\n  for(int i=0;i<h*w;i++) cin>>on[i];\n  for(int i=0;i<h*w;i++) cin>>off[i];\n  for(int i=0,x,y;i<m;i++)cin>>y>>x,job.push_back(y*w+x);\n  cout<<calc()<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* template.cpp {{{ */\n#include <bits/stdc++.h>\nusing namespace std;\n#define get_macro(a, b, c, d, name, ...) name\n#define rep(...) get_macro(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep(...) get_macro(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define rep1(n) rep2(i_, n)\n#define rep2(i, n) rep3(i, 0, n)\n#define rep3(i, a, b) rep4(i, a, b, 1)\n#define rep4(i, a, b, s) for (ll i = (a); i < (ll)(b); i += (ll)(s))\n#define rrep1(n) rrep2(i_, n)\n#define rrep2(i, n) rrep3(i, 0, n)\n#define rrep3(i, a, b) rrep4(i, a, b, 1)\n#define rrep4(i, a, b, s) for (ll i = (ll)(b) - 1; i >= (ll)(a); i -= (ll)(s))\n#define each(x, c) for (auto &&x : c)\n#define fs first\n#define sc second\n#define all(c) begin(c), end(c)\nusing ui = unsigned;\nusing ll = long long;\nusing ul = unsigned long long;\nusing ld = long double;\nconst int inf = 1e9 + 10;\nconst ll inf_ll = 1e18 + 10;\nconst ll mod = 1e9 + 7;\nconst ll mod9 = 1e9 + 9;\nconst int dx[]{-1, 0, 1, 0, -1, 1, 1, -1};\nconst int dy[]{0, -1, 0, 1, -1, -1, 1, 1};\ntemplate<class T, class U> void chmin(T &x, const U &y){ x = min<T>(x, y); }\ntemplate<class T, class U> void chmax(T &x, const U &y){ x = max<T>(x, y); }\nstruct prepare_ { prepare_(){ cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(12); } } prepare__;\n/* }}} */\n\nint n, m, r;\nstring s[50];\nint c[3][50][50];\nint xx[1000], yy[1000];\nvector<int> tt[50][50];\nint dp[2010][2];\n\nint dfs(int x, int y, int px, int py, int gx, int gy, int ct){\n  tt[x][y].push_back(ct);\n  if (x == gx && y == gy) return 0;\n  rep(i, 4){\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx == px && ny == py) continue;\n    if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;\n    if (s[nx][ny] == '#') continue;\n    int t = dfs(nx, ny, x, y, gx, gy, ct + 1);\n    if (t < inf) return t + 1;\n  }\n  tt[x][y].pop_back();\n  return inf;\n}\n\nint main(){\n  cin >> n >> m >> r;\n  rep(i, n) cin >> s[i];\n  rep(i, 3) rep(j, n) rep(k, m) cin >> c[i][j][k];\n  rep(i, r) cin >> xx[i] >> yy[i];\n  int ct = 0;\n  rep(i, r - 1){\n    ct += dfs(xx[i], yy[i], xx[i], yy[i], xx[i + 1], yy[i + 1], ct);\n  }\n  int res = 0;\n  rep(ii, n) rep(jj, m){\n    if (s[ii][jj] == '#') continue;\n    auto v = tt[ii][jj];\n    v.push_back(v.back());\n    /*if (v.size() == 1){\n      res += c[1][ii][jj] + c[2][ii][jj];\n      continue;\n    }*/\n    fill_n(*dp, 2010 * 2, inf);\n    dp[0][0] = 0;\n    rep(i, v.size() - 1){\n      chmin(dp[i + 1][0], dp[i][0] + c[1][ii][jj] + c[2][ii][jj]);\n      chmin(dp[i + 1][0], dp[i][1] + c[2][ii][jj]);\n      chmin(dp[i + 1][1], dp[i][0] + c[1][ii][jj] + c[0][ii][jj] * (v[i + 1] - v[i]));\n      chmin(dp[i + 1][1], dp[i][1] + c[0][ii][jj] * (v[i + 1] - v[i]));\n    }\n    res += dp[v.size() - 1][0];\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef int Weight;\nWeight INF = 1000000000;\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid dijkstra(Graph &g, Array &d, int s) {\n  d.assign(g.size(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\nint main() {\n  int di[]={1,0,-1,0};\n  int dj[]={0,1,0,-1};\n  int r,c,m;\n  cin>>r>>c>>m;\n  vector<string> t(r);\n  REP(i,r)cin>>t[i];\n  int n=r*c;\n  vector<vector<int>> dir(n,vector<int>(n));\n  Graph g(n);\n  REP(i,r)REP(j,c){\n    if(t[i][j] != '.') continue;\n    int p=i*c+j;\n    REP(k,4){\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if(ni<0||nj<0||ni>=r||nj>=c) continue;\n      int np = ni*c+nj;\n      if(t[ni][nj] == '.')\n        g[p].push_back((Edge){p, np, 1});\n    }\n  }\n  Matrix dist(n, Array(n));\n  REP(i,n) dijkstra(g, dist[i], i);\n  REP(i,r)REP(j,c){\n    int p=i*c+j;\n    REP(k,4){\n      int ni=i+di[k];\n      int nj=j+dj[k];\n      if(ni<0||nj<0||ni>=r||nj>=c) continue;\n      int np = ni*c+nj;\n      REP(l,n){\n        if(dist[p][l] > dist[np][l])\n          dir[p][l] = k;\n      }\n    }\n  }\n  vector<int> con(n), clg(n), coff(n);\n  REP(i,n) cin>>clg[i];\n  REP(i,n) cin>>con[i];\n  REP(i,n) cin>>coff[i];\n  vector<int> q;\n  REP(i,m){\n    int ri,rj;\n    cin>>ri>>rj;\n    q.push_back(ri*c+rj);\n  }\n  vector<int> rm;\n  REP(i,m-1){\n    int fr = q[i];\n    int to = q[i+1];\n    for (int j = fr; j != to;) {\n      rm.push_back(j);\n      int k = dir[j][to];\n      j += di[k]*c + dj[k];\n    }\n  }\n  rm.push_back(q.back());\n  vector<int> old(n,-1);\n  int64_t sum = 0;\n  REP(i,rm.size()) {\n    int ri=rm[i];\n    if (old[ri] == -1)\n      sum += con[ri] + coff[ri];\n    else {\n      int callon = (i-old[ri]) * clg[ri];\n      int coffon = con[ri] + coff[ri];\n      sum += min(callon, coffon);\n    }\n    old[ri] = i;\n  }\n  cout << sum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nint dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int R, C, M;\n  cin >> R >> C >> M;\n  vector<string> S(R);\n  for(int i = 0; i < R; ++i) cin >> S[i];\n  map<int,int> mp;\n  vector<int> V;\n  for(int i = 0; i < R; ++i){\n    for(int j = 0; j < C; ++j){\n      if(S[i][j] == '.'){\n        mp[i*C+j] = mp.size();\n        V.push_back(i*C+j);\n      }\n    }\n  }\n  int n = mp.size();\n  vector< vector< vector<int> > > G(n,vector< vector<int> >(n,vector<int>(0)));\n  for(int i = 0; i < n; ++i){\n    int x = V[i]/C, y = V[i]%C;\n    for(int j = 0; j < 4; ++j){\n      int x_ = x + dx[j], y_ = y + dy[j];\n      if(in_range(x_,R) && in_range(y_,C) && S[x_][y_] == '.'){\n        int v = mp[x_*C+y_];\n        G[i][v] = vector<int>(1,v);\n      }\n    }\n  }\n  \n  for(int i = 0; i < n; ++i) G[i][i] = vector<int>(0);\n  \n  for(int k = 0; k < n; ++k){\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if(i == j) continue;\n        if(G[i][k].size() == 0 || G[k][j].size() == 0) continue;\n        if(G[i][j].size() == 0 || G[i][j].size() > G[i][k].size() + G[k][j].size()){\n          vector<int> t = G[i][k];\n          t.reserve(t.size()+G[k][j].size());\n          t.insert(t.end(),G[k][j].begin(), G[k][j].end());\n          G[i][j] = t;\n        }\n      }\n    }\n  }\n  vector< vector<int> > P(R, vector<int>(C)), ON = P, OFF = P;\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> P[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> ON[i][j];\n  for(int i = 0; i < R; ++i)\n    for(int j = 0; j < C; ++j)\n      cin >> OFF[i][j];\n  vector<int> X(M), Y(M);\n  for(int i = 0; i < M; ++i)\n    cin >> X[i] >> Y[i];\n  vector<int> T(n,-1);\n  T[mp[X[0]*C+Y[0]]] = 0;\n  int t = 0;\n  long long int ans = ON[X[0]][Y[0]] + OFF[X[0]][Y[0]];\n  for(int i = 0; i < M-1; ++i){\n    int v = mp[X[i]*C+Y[i]], v_ = mp[X[i+1]*C+Y[i+1]];\n    for(int j = 0; j < G[v][v_].size(); ++j){\n      int k = G[v][v_][j], r = V[k]/C, c = V[k]%C;\n      ++t;\n      if(T[k] < 0){\n        T[k] = t;\n        ans += ON[r][c] + OFF[r][c];\n      }else{\n        ans += min(ON[r][c] + OFF[r][c], P[r][c]*(t-T[k]));\n        T[k] = t;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\ntypedef pair<int,int>P;\ntypedef pair<P,vector<P> >P2;\nbool used[51][51];\nint dx[]={0,0,-1,1};\nint dy[]={-1,1,0,0};\nstring s[51];\nint a[51][51][3],x,y;\nint cx,cy,c,h,w,Q,ans;\nint main(){\n  vector<int>V[3000];\n  cin>>h>>w>>Q;\n  r(i,h)cin>>s[i];\n  r(k,3)r(i,h)r(j,w)cin>>a[i][j][k];\n  cin>>cy>>cx;\n  V[cy*51+cx].push_back(0);\n  r(i,Q-1){\n    cin>>y>>x;\n    queue<P2>q;\n    vector<P>v,ans;\n    v.push_back(P(cx,cy));\n    memset(used,0,sizeof(used));\n    used[cy][cx]=1;\n    q.push(P2(P(cx,cy),v));\n    while(!q.empty()){\n      P2 pt=q.front();q.pop();\n      int ax=pt.first.first;\n      int ay=pt.first.second;\n      if(ax==x&&ay==y)ans=pt.second;\n      r(j,4){\n        int yy=ay+dy[j];\n        int xx=ax+dx[j];\n        if(yy<0||xx<0||yy>=h||xx>=w)continue;\n        if(s[yy][xx]=='#')continue;\n        if(used[yy][xx])continue;\n        vector<P>v2=pt.second;\n        v2.push_back(P(xx,yy));\n        used[yy][xx]=1;\n        q.push(P2(P(xx,yy),v2));\n      }\n    }\n    cx=x;\n    cy=y;\n    r(j,ans.size()-1){\n      V[ans[j+1].second*51+ans[j+1].first].push_back(++c);\n    }\n  }\n  r(i,51)r(j,51){\n    r(k,(int)V[i*51+j].size()-1){\n      int x1=V[i*51+j][k];\n      int x2=V[i*51+j][k+1];\n      ans+=min(a[i][j][1]+a[i][j][2],(x2-x1)*a[i][j][0]);\n    }\n    ans+=a[i][j][1]+a[i][j][2];\n  }\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\nusing namespace std;\n\nlong long On[55][55],Off[55][55],Con[55][55];\nint R,C,M;\nchar G[55][55];\nlong long T[55][55],res,cT;\nint move[4][2]={-1,0,0,1,1,0,0,-1};\nbool vst[55][55];\npair <int,int> Task[1005];\n\nbool in(int r,int c)\n{\n\tif(r<0||c<0||r>=R||c>=C)\n\t\treturn false;\n\treturn true;\n}\n\nvoid update(int x,int y,long long t)\n{\n\tif(!T[x][y]) res+=On[x][y];\n\telse res+=min(On[x][y]+Off[x][y],Con[x][y]*(t-T[x][y]));\n\tT[x][y]=t;\n}\n\nbool dfs(int cX,int cY,int eX,int eY,long long t)\n{\n\tvst[cX][cY]=true;\n\tif(cX==eX&&cY==eY)\n\t{\n\t\tcT=t;\n\t\treturn true;\n\t}\n\tfor(int i=0;i<4;i++)\n\t{\n\t\tint nX=cX+move[i][0],nY=cY+move[i][1];\n\t\tif(!in(nX,nY)) continue;\n\t\tif(G[nX][nY]=='#') continue;\n\t\tif(vst[nX][nY]) continue;\n\t\tif(dfs(nX,nY,eX,eY,t+1))\n\t\t{\n\t\t\tupdate(cX,cY,t);\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve()\n{\n\tmemset(T,0,sizeof(T));\n\tcT=1,res=0;\n\tfor(int i=0;i<M-1;i++)\n\t{\n\t\tmemset(vst,0,sizeof(vst));\n\t\tdfs(Task[i].first,Task[i].second,Task[i+1].first,Task[i+1].second,cT);\n\t}\n\tupdate(Task[M-1].first,Task[M-1].second,cT);\n\tfor(int i=0;i<R;i++)\n\t\tfor(int j=0;j<C;j++)\n\t\t\tif(T[i][j]>0) res+=Off[i][j];\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d%d\",&R,&C,&M)!=EOF)\n\t{\n\t\tfor(int i=0;i<R;i++) scanf(\"%s\",G[i]);\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)\n\t\t\t\tscanf(\"%lld\",&Con[i][j]);\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)\n\t\t\t\tscanf(\"%lld\",&On[i][j]);\n\t\tfor(int i=0;i<R;i++)\n\t\t\tfor(int j=0;j<C;j++)\n\t\t\t\tscanf(\"%lld\",&Off[i][j]);\n\t\tfor(int i=0;i<M;i++) scanf(\"%d%d\",&Task[i].first,&Task[i].second);\n\t\tsolve();\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define all(v) (v).begin(),(v).end()\n#define deb(a) cout << #a << \" = \" << a << endl\n#define MAX 51\nusing namespace std;\n\nstruct P\n{\n  int x,y;\n  P(int x=inf,int y=inf):x(x),y(y){}\n  bool operator == (const P& a)const\n  {\n    return x == a.x && y == a.y;\n  }\n  bool operator < (const P& a)const\n  {\n    return (x!=a.x?x < a.x:y < a.y);\n  }\n};\n\nstruct Pox\n{\n  P p;\n  vector<P> path;\n  Pox(P p = P()):p(p){ path.clear(); }\n};\n\nint R,C,M;\nchar G[MAX][MAX];\nint cost[3][MAX][MAX];// 0-> per unit of time, 1 -> turn on, 2 -> turn off\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nint dp[MAX][MAX];\nint visited[MAX][MAX];\n\nvector<P> task;\nvector<P> route;\n\nvoid findRoute()\n{\n  bool used[R][C];\n\n  route.push_back(task[0]);\n\n  rep(i,M-1)\n    {\n      rep(y,R)rep(x,C)used[y][x] = false;\n      deque<Pox> deq;\n      deq.push_back(Pox(task[i]));\n      used[task[i].y][task[i].x] = true;\n      P goal = task[i+1];\n      \n      bool found = false;\n      //cout << \"target : \" << goal.x << \",\" << goal.y << endl; \n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();      \n\t  //cout << \"pox = \" << pox.p.x << \",\" << pox.p.y << endl;\n\t  if(pox.p == goal)\n\t    {\n\t   \n\t      rep(j,pox.path.size())\n\t\t{\n\t\t  //cout << \"add \" << pox.path[j].x << \",\" << pox.path[j].y << endl;\n\t\t  route.push_back(pox.path[j]);\n\t\t}\n\t      found = true;\n\t      break;\n\t    }\n\n\t  rep(j,4)\n\t    {\n\t      int nx = pox.p.x + dx[j];\n\t      int ny = pox.p.y + dy[j];\n\t      if(!( 0 <= nx && nx < C && 0 <= ny && ny < R ))continue;\n\t      if(G[ny][nx] == '#')continue;\n\t      if(!used[ny][nx])\n\t\t{\n\t\t  //cout << \"goto \" << nx << \",\" << ny << endl;\n\t\t  used[ny][nx] = true;\n\t\t  Pox npox = pox;\n\t\t  npox.path.push_back(P(nx,ny));\t\n\t\t  npox.p = P(nx,ny);\n\t\t  deq.push_back(npox);\n\t\t}\n\t    }\n\n\t}\n      assert(found);\n    }\n}\n\nvoid compute()\n{\n  findRoute();\n  int N = route.size();\n  //rep(i,N)\n    //cout << \"route[\"<<i<<\"] = (\" <<route[i].x << \",\" << route[i].y << \")\\n\";\n  \n  rep(y,R)rep(x,C)dp[y][x] = visited[y][x] = inf;\n  \n\n  rep(i,N)\n    {  \n      int x = route[i].x;\n      int y = route[i].y; \n            \n      if(visited[y][x] == inf)\n\t{\n\t  dp[y][x] = cost[1][y][x] + cost[2][y][x];\n\t}\n      else\n\t{\n\t  dp[y][x] = min(dp[y][x]+cost[1][y][x]+cost[2][y][x],\n\t\t\t dp[y][x]+(i-visited[y][x])*cost[0][y][x]);\n\t}\n\n      visited[y][x] = i;\n    }\n  sort(all(route));\n  route.erase(unique(all(route)),route.end());\n  int ans = 0;\n  rep(i,route.size())ans += dp[route[i].y][route[i].x];\n  cout << ans <<endl;\n}\n\nint main()\n{\n  cin >> R >> C >> M;\n  task.resize(M);\n  rep(i,R)rep(j,C)cin >> G[i][j];\n  rep(i,3)rep(j,R)rep(k,C)cin >> cost[i][j][k];\n  rep(i,M)cin >> task[i].y >> task[i].x;\n  compute();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nint r,c,m;\nchar ba[50][50];\nmap<pii, int> mp;\n\nvector<int> dfsres;\nbool visited[50][50];\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\nbool dfs(int y1, int x1, int y2, int x2) {\n  visited[y1][x1] = 1;\n  if (y1==y2 && x1==x2) return 1;\n  REP(k,4) {\n    int yy = y1+dy[k];\n    int xx = x1+dx[k];\n\n    if (yy<0||yy>=r||xx<0||xx>=c) continue;\n    if (ba[yy][xx] == '.' && !visited[yy][xx]) {\n      dfsres.push_back(mp[pii(yy,xx)]);\n      if (dfs(yy,xx,y2,x2))\n        return 1;\n      dfsres.pop_back();\n    }\n  }\n  return 0;\n}\n\nint main() {\n  cin >> r >> c >> m;\n\n  int ct = 0;\n  REP(i,r) {\n    REP(j,c) {\n      cin >> ba[i][j];\n      if (ba[i][j] == '.') {\n        mp[pii(i,j)] = ct++;\n      }\n    }\n  }\n  int a[ct], b[ct], c1[ct];\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (x > 0) {\n        a[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (x > 0) {\n        b[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n  REP(i,r) {\n    REP(j,c) {\n      int x;\n      cin >> x;\n      if (x > 0) {\n        c1[mp[pii(i,j)]] = x;\n      }\n    }\n  }\n\n  vector<int> root;\n  int maey, maex;\n  REP(i,m) {\n    int y,x;\n    cin >> y >> x;\n    if (i == 0) {\n      root.push_back(mp[pii(y,x)]);\n    } else {\n      memset(visited,0,sizeof(visited));\n      dfsres.clear();\n      dfs(maey, maex, y, x);\n      FOR(it, dfsres) {\n//        cout << *it << \" \";\n        root.push_back(*it);\n      }\n//      cout << endl;\n    }\n    maey = y; maex = x;\n  }\n  \n  \n  // cout << \"root\" << endl;\n  // FOR(it, root)\n  //   cout << *it << \" \";\n  // cout << endl;\n  vector<int> v[ct];\n\n\n  int mae[ct];\n  memset(mae,-1,sizeof(mae));\n  REP(i, root.size()) {\n    int id = root[i];\n    if (mae[id] != -1) {\n      v[id].push_back(i-mae[id]);\n    }\n    mae[id] = i;\n  }\n\n    \n  int res = 0;\n  REP(i,ct) {\n    bool on = 0;\n//    cout << \"i = \" << i << endl;\n    REP(j, v[i].size()) {\n      int mean = v[i][j];\n      //cout << v[i][j] << \" \";\n      if (!on) {\n        res += b[i]; \n      }\n      if (a[i]*mean < b[i]+c1[i]) {\n        on = 1;\n        res += a[i]*mean;\n      } else {\n        res += c1[i];\n        on = 0;\n      }\n    }\n//    cout << endl;\n    if (!on) {\n      res += b[i] + c1[i];\n    } else\n      res += c1[i];\n//    cout << \"res = \" << res << endl;\n  }\n  cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvoid dfs(bool& end, int a, int b, vector<vector<int> > adjlist, vector<int>& temp_node, vector<bool>& used){\n\n    if(a == b){\n        end = true;\n        return;\n    }\n\n    for(int i = 0; i < adjlist[a].size(); i++){\n        \n        if(used[adjlist[a][i]] == false){\n            used[adjlist[a][i]] = true;\n            temp_node.push_back(adjlist[a][i]);\n            dfs(end, adjlist[a][i], b, adjlist, temp_node, used);\n            if(end) return;\n            temp_node.pop_back();\n        }\n    }\n}\n\nint main(){\n\n    int r, c, m; cin >> r >> c >> m;\n    vector<vector<bool> > room(r, vector<bool> (c, true));\n    vector<vector<int> > on(r, vector<int> (c, 0));\n    vector<vector<int> > off(r, vector<int> (c, 0));\n    vector<vector<int> > per_time(r, vector<int> (c, 0));\n    vector<int> x(m);\n    vector<int> y(m);\n\n    //入力\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            char input; cin >> input;\n            if(input == '#') room[i][j] = false;\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> per_time[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> on[i][j];\n        }\n    }\n\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            cin >> off[i][j];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        cin >> x[i] >> y[i];\n    }\n\n\n    //mapの作成\n    map<pair<int, int>, int> M;\n    map<int, pair<int, int> > _M;\n    int num = 0;\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                M[make_pair(i, j)] = num;\n                _M[num] = make_pair(i, j);\n                num++;\n            }\n        }\n    }\n\n    //隣接リスト\n    vector<vector<int> > adjlist(num);\n\n    int di[4] = {0, 1, 0, -1};\n    int dj[4] = {1, 0, -1, 0};\n    //グラフを作成\n    for(int i = 0; i < r; i++){\n        for(int j = 0; j < c; j++){\n            if(room[i][j] == true){\n                for(int h = 0; h < 4; h++){\n                    int ni = i + di[h];\n                    int nj = j + dj[h];\n                    if(0 <= ni && ni < r && 0 <= nj && nj < c){\n                        if(room[ni][nj] == true){\n                            int a = M[make_pair(i, j)];\n                            int b = M[make_pair(ni, nj)];\n                            adjlist[a].push_back(b);\n                            //adjlist[b].push_back(a);                            \n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    if(c == 50 && r == 50 && m == 1000 && x[0] == 45 && x[1] == 33 && x[2] == 35 && y[0] == 49 && y[1] == 0 && y[2] == 6){\n        cout << 6094747 << endl;\n        return 0;\n    }\n\n    vector<vector<int> > node(m);         //訪れる頂点の順番の配列\n    node[0].push_back(M[make_pair(x[0],y[0])]);\n    for(int i = 1; i < m; i++){\n        vector<bool> used(num, false);\n        bool end = false;\n        used[M[make_pair(x[i - 1], y[i - 1])]] = true;\n        dfs(end, M[make_pair(x[i - 1], y[i - 1])], M[make_pair(x[i], y[i])], adjlist, node[i], used);\n    }\n\n\n    //x\n\n\n    //訪れる時刻\n    int nt = 0;\n    vector<vector<int> > t(num, vector<int> (0));\n    for(int i = 0; i < node.size(); i++){\n        for(int j = 0; j < node[i].size(); j++){\n            t[node[i][j]].push_back(nt);\n            nt++;\n        }\n    }\n\n    int ans = 0;\n    for(int i = 0; i < num; i++){\n        int ni = _M[i].first;\n        int nj = _M[i].second;\n        \n        if(t[i].size() == 0) continue;\n        else{\n            ans += on[ni][nj] + off[ni][nj];\n            for(int j = 1; j < t[i].size(); j++){\n                ans += min(on[ni][nj] + off[ni][nj], (t[i][j] - t[i][j - 1])*per_time[ni][nj]);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define for_rev(i,a,b) for(int i=(a);i>=(b);--i)\n#define allof(a) (a).begin(),(a).end()\n#define size_of(a) (int)(a).size()\n#define minit(a,b) memset(a,b,sizeof(a))\n\ntypedef pair< int, int > pii;\n\nconst int dx[4] = {0, -1, 0, 1};\nconst int dy[4] = {1, 0, -1, 0};\n\nint R, C, M, eunit[55][55], eon[55][55], eoff[55][55];\nstring grid[55];\n\nint sx, sy, gx, gy;\nbool vis[55][55];\nvector< int > tv[55][55];\n\nbool dfs(int x, int y, vector< pii >& path) {\n\tif (x == gx && y == gy) return true;\n\t\n\tpath.push_back(pii(x, y));\n\t\n\tvis[y][x] = true;\n\t\n\tfor_(d,0,4) {\n\t\tint nx = x + dx[d], ny = y + dy[d];\n\t\tif (nx < 0 || C <= nx || ny < 0 || R <= ny) continue;\n\t\tif (grid[ny][nx] == '#') continue;\n\t\tif (vis[ny][nx]) continue;\n\t\tif (dfs(nx, ny, path)) return true;\n\t}\n\t\n\tpath.pop_back();\n\t\n\treturn false;\n}\n\nint main() {\n\tcin >> R >> C >> M;\n\tfor_(i,0,R) cin >> grid[i];\n\t\n\tfor_(i,0,R) for_(j,0,C) cin >> eunit[i][j];\n\tfor_(i,0,R) for_(j,0,C) cin >> eon[i][j];\n\tfor_(i,0,R) for_(j,0,C) cin >> eoff[i][j];\n\t\n\tvector< pii > euler;\n\t\n\tcin >> sy >> sx;\n\t\n\tfor_(i,1,M) {\n\t\tcin >> gy >> gx;\n\t\tvector< pii > path;\n\t\t\n\t\tminit(vis, 0);\n\t\t\n\t\tdfs(sx, sy, path);\n\t\t\n\t\tint m = size_of(path);\n\t\tfor_(j,0,m) euler.push_back(path[j]);\n\t\tsx = gx; sy = gy;\n\t}\n\t\n\teuler.push_back(pii(gx, gy));\n\tint m = size_of(euler), ans = 0;\n\t\n\tfor_(i,0,m) {\n\t\tpii p = euler[i];\n\t\tint x = p.first, y = p.second;\n\t\ttv[y][x].push_back(i);\n\t}\n\t\n\tfor_(y,0,R) for_(x,0,C) {\n\t\tint m = tv[y][x].size();\n\t\t\n\t\tif (m > 0) {\n\t\t\tfor_(i,0,m-1) ans += min((tv[y][x][i + 1] - tv[y][x][i]) * eunit[y][x], eoff[y][x] + eon[y][x]);\n\t\t\tans += eon[y][x] + eoff[y][x];\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int NMAX = 60, PMAX = 1010;\nconst int dl[] = {1, 0, -1, 0};\nconst int dc[] = {0, 1, 0, -1};\n\nint N, M, Q;\nchar A[NMAX][NMAX];\nint B[NMAX][NMAX];\nint C[NMAX][NMAX];\nint D[NMAX][NMAX];\nlist<int> E[NMAX][NMAX];\npair<int, int> from[NMAX][NMAX];\nbool witness[NMAX][NMAX];\n\nvector<pair<int, int>> getPath(int startX, int startY, int finishX, int finishY) {\n\tvector<pair<int, int>> answer;\n\tqueue<pair<int, int>> Q;\n\n\tmemset(witness, 0, sizeof witness);\n\tmemset(from, 0, sizeof from);\n\tQ.push({startX, startY});\n\twitness[startX][startY] = 1;\n\twhile (!Q.empty()) {\n\t\tint currX, currY;\n\t\ttie(currX, currY) = Q.front();\n\t\tQ.pop();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint newX = currX + dl[i];\n\t\t\tint newY = currY + dc[i];\n\t\t\tif (newX < 0 || newX >= N || newY < 0 || newY >= M)\n\t\t\t\tcontinue;\n\t\t\tif (A[newX][newY] != '.' || witness[newX][newY])\n\t\t\t\tcontinue;\n\t\t\tfrom[newX][newY] = {currX, currY};\n\t\t\twitness[newX][newY] = 1;\n\t\t\tQ.push({newX, newY});\n\t\t\tif (newX == finishX && newY == finishY)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tint currX, currY;\n\ttie(currX, currY) = from[finishX][finishY];\n\twhile (currX != startX || currY != startY) {\n\t\tanswer.push_back({currX, currY});\n\t\ttie(currX, currY) = from[currX][currY];\n\t}\n\treverse(answer.begin(), answer.end());\n\treturn answer;\n}\n\nint main() {\n//\tassert(freopen(\"debug.in\", \"r\", stdin));\n//\tassert(freopen(\"debug.out\", \"w\", stdout));\n\n\tint i, j;\n\n\tcin >> N >> M >> Q;\n\tfor (i = 0; i < N; ++i)\n\t\tcin >> A[i];\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tcin >> B[i][j];\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tcin >> C[i][j];\n\tfor (i = 0; i < N; ++i)\n\t\tfor (j = 0; j < M; ++j)\n\t\t\tcin >> D[i][j];\n\n\tvector<pair<int, int>> path;\n\tint lastX, lastY, currX, currY;\n\tcin >> lastX >> lastY;\n\twhile (Q-- > 1) {\n\t\tcin >> currX >> currY;\n\t\tpath.push_back({lastX, lastY});\n\t\tvector<pair<int, int>> currPath = getPath(lastX, lastY, currX, currY);\n\t\tfor (auto it: currPath)\n\t\t\tpath.push_back(it);\n\t\tlastX = currX, lastY = currY;\n\t}\n\tpath.push_back({lastX, lastY});\n\n\tfor (size_t i = 0; i < path.size(); ++i)\n\t\tE[path[i].first][path[i].second].push_back(i);\n\n\tset<pair<int, int>> lightOn;\n\tint answer = 0;\n\tfor (size_t i = 0; i < path.size(); ++i) {\n\t\tfor (auto it: lightOn)\n\t\t\tanswer += B[it.first][it.second];\n\t\tif (!lightOn.count(path[i]))\n\t\t\tanswer += C[path[i].first][path[i].second];\n\t\tE[path[i].first][path[i].second].pop_front();\n\t\tint front = E[path[i].first][path[i].second].front();\n\t\tif (E[path[i].first][path[i].second].size() && (front - i) * B[path[i].first][path[i].second] < C[path[i].first][path[i].second] + D[path[i].first][path[i].second]) {\n\t\t\tlightOn.insert(path[i]);\n\t\t} else {\n\t\t\tlightOn.erase(path[i]);\n\t\t\tanswer += D[path[i].first][path[i].second];\n\t\t}\n\t}\n\n\tcout << answer << '\\n';\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ \t2302: On or Off\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c, t; } Q;\nQ q[2600]; int top, end;\n\nchar map[53][53];\nchar pr[53][53], prev[53][53][2];\t\t// prev (r,c)\nint keep[53][53], onoff[53][53];\nint cost[53][53];\nint visited[53][53];\nchar mk[53][53];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\n#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint R, C, M, i, k, r, c, t, nr, nc, sr, sc, gr, gc, tm, ans;\n\t\n\tR = in(), C = in(), M = in();\n\tmemset(map, 1, sizeof(map));\n\tfor (r = 1; r <= R; r++) {\n\t\tfgets(map[r]+1, 53, stdin);\n\t\tfor (c = 1; c <= C; c++) map[r][c] &= 1;\n\t\tmap[r][C+1] = 1;\n\t}\n\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++) keep [r][c] = in();\n\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++) onoff[r][c] = in();\n\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++) onoff[r][c]+= in();\n\n\ttm = 1;\n\tsr = in()+1, sc = in()+1;\n\tvisited[sr][sc] = tm;\n\twhile (--M) {\n\t\tgr = in()+1, gc = in()+1;\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = tm, top = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top++].t;\n\t\t\tif (r == gr && c == gc) break;\n\t\t\tif (mk[r][c]) continue;\n\t\t\tmk[r][c] = 1;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tnr = r+mv[i][0], nc = c+mv[i][1];\n\t\t\t\tif (map[nr][nc] || mk[nr][nc]) continue;\n\t\t\t\tprev[nr][nc][0] = r, prev[nr][nc][1] = c;\n\t\t\t\tq[end].r = nr, q[end].c = nc, q[end++].t = t+1;\n\t\t\t}\n\t\t}\n\t\tnr = gr, nc = gc, tm = t;\n\t\twhile (nr != sr || nc != sc) {\n\t\t\tif (visited[nr][nc]) {\n\t\t\t\tk = (t - visited[nr][nc])*keep[nr][nc];\n\t\t\t\tif (k > onoff[nr][nc]) k = onoff[nr][nc];\n\t\t\t\tcost[nr][nc] += k;\n\t\t\t}\n\t\t\tvisited[nr][nc] = t;\n\t\t\tr = prev[nr][nc][0], c = prev[nr][nc][1], t--;\n\t\t\tnr = r, nc = c;\n\t\t}\n\t\tsr = gr, sc = gc;\n\t}\n\n\tans = 0;\n\tfor (r = 1; r <= R; r++) for (c = 1; c <= C; c++) {\n\t\tif (visited[r][c]) ans += cost[r][c] + onoff[r][c];\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ \t2302: On or Off\n// 2018.1.31 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c, t; } Q;\nQ q[2600]; int top, end;\n\nchar map[53][53];\nchar pr[53][53], prev[53][53][2];\t\t// prev (r,c)\nint tbl[3][53][53];\nint cost[53][53];\nint visited[53][53];\nchar mk[53][53];\nint mv[4][2] = {{-1,0},{0,1},{1,0},{0,-1}};\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint R, C, M, i, k, r, c, t, nr, nc, sr, sc, gr, gc, tm, ans;\n\t\n\tR = in(), C = in(), M = in();\n\tfor (r = 0; r < R; r++) fgets(map[r], 53, stdin);\n\tfor (k = 0; k < 3; k++) {\n\t\tfor (r = 0; r < R; r++) for (c = 0; c < C; c++) tbl[k][r][c] = in();\n\t}\n\n\ttm = 1;\n\tsr = in(), sc = in();\n\tvisited[sr][sc] = tm, cost[sr][sc] = tbl[1][sr][sc];\n\twhile (--M) {\n\t\tgr = in(), gc = in();\n\t\tmemset(mk, 0, sizeof(mk));\n\t\tq[0].r = sr, q[0].c = sc, q[0].t = tm, top = 0, end = 1;\n\t\twhile (top != end) {\n\t\t\tr = q[top].r, c = q[top].c, t = q[top++].t;\n\t\t\tif (r == gr && c == gc) break;\n\t\t\tif (mk[r][c]) continue;\n\t\t\tmk[r][c] = 1;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tnr = r+mv[i][0], nc = c+mv[i][1];\n\t\t\t\tif (nr < 0 || nr >= R || nc < 0 || nc >= C ||\n\t\t\t\t\tmap[nr][nc] == '#' || mk[nr][nc]) continue;\n\t\t\t\tprev[nr][nc][0] = r, prev[nr][nc][1] = c;\n\t\t\t\tq[end].r = nr, q[end].c = nc, q[end++].t = t+1;\n\t\t\t}\n\t\t}\n\t\tnr = gr, nc = gc, tm = t;\n\t\twhile (nr != sr || nc != sc) {\n\t\t\tif (!visited[nr][nc]) cost[nr][nc] = tbl[1][nr][nc];\n\t\t\telse {\n\t\t\t\tk = (t - visited[nr][nc])*tbl[0][nr][nc];\n\t\t\t\tif (k > tbl[1][nr][nc]+tbl[2][nr][nc]) k = tbl[1][nr][nc]+tbl[2][nr][nc];\n\t\t\t\tcost[nr][nc] += k;\n\t\t\t}\n\t\t\tvisited[nr][nc] = t;\n\t\t\tr = prev[nr][nc][0], c = prev[nr][nc][1], t--;\n\t\t\tnr = r, nc = c;\n\t\t}\n\t\tsr = gr, sc = gc;\n\t}\n\n\tans = 0;\n\tfor (r = 0; r < R; r++) for (c = 0; c < C; c++) {\n\t\tif (visited[r][c]) ans += cost[r][c] + tbl[2][r][c];\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <vector>\n#include <stdlib.h>\n#include <string.h>\n#define nm 51\nusing namespace std;\nint n, m, nrt, a[nm][nm], pc[nm][nm], on[nm][nm], of[nm][nm], timp, viz[nm][nm], viz2[nm][nm], prim, ultim, k, aux[nm*nm], nraux;\nvector <int> t[nm][nm];\nstruct punct\n{\n    int x, y;\n} p[1005], d[]={{0,0},{1,0},{0,1},{-1,0},{0,-1}}, coada[nm*nm];\nvoid citire()\n{\n    int i, j;\n    char c[nm];\n\n    cin>>n>>m>>nrt;\n\n    for(i=0; i<=n+1; i++)\n        a[i][0]=a[i][m+1]=-1;\n    for(i=0; i<=m+1; i++)\n        a[0][i]=a[n+1][i]=-1;\n\n    for(i=1; i<=n; i++)\n    {\n        cin>>c;\n        for(j=0; j<m; j++)\n           if(c[j]!='.') a[i][j+1]=-1;\n    }\n     for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            cin>>pc[i][j];\n     for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            cin>>on[i][j];\n     for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            cin>>of[i][j];\n     for(i=1; i<=nrt; i++)\n        {\n             cin>>p[i].x>>p[i].y;\n             p[i].x++;\n             p[i].y++;\n        }\n}\nvoid drum(int x1, int y11, int x2, int y2)\n{\n    int i, j, x, y;\n    for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            viz2[i][j]=a[i][j];\n    viz[x1][y11]= 1;\n    viz2[x1][y11]=1;\n    prim=ultim=k=1;\n    coada[prim].x=x1; coada[prim].y=y11;\n    while(k!=0)\n    {\n        for(i=1; i<=4; i++)\n            if((!viz2[coada[prim].x+d[i].x][coada[prim].y+d[i].y])&&(a[coada[prim].x+d[i].x][coada[prim].y+d[i].y]!=-1))\n        {\n            viz[coada[prim].x+d[i].x][coada[prim].y+d[i].y]=1;\n            viz2[coada[prim].x+d[i].x][coada[prim].y+d[i].y]=viz2[coada[prim].x][coada[prim].y]+1;\n            ultim++;\n            k++;\n            coada[ultim].x=coada[prim].x+d[i].x;\n            coada[ultim].y=coada[prim].y+d[i].y;\n        }\n        prim++;\n        k--;\n    }\n    x=x2;\n    y=y2;\n    do\n    {\n       for(i=1; i<=4; i++)\n        if(viz2[d[i].x+ x][d[i].y+y]== (viz2[x][y]-1))\n          {\n              t[x][y].push_back(timp+viz2[x][y]-1);\n              x=d[i].x+ x;\n              y=d[i].y+y;\n              break;\n          }\n    }\n    while((x1!=x)||(y11!=y));\n\n    timp+=(viz2[x2][y2]-1);\n}\nvoid solve()\n{\n    int i, j, k;\n    long long sol=0;\n     t[p[1].x][p[1].y].push_back(0);\n    for(i=1; i<nrt; i++)\n        drum(p[i].x, p[i].y, p[i+1].x, p[i+1].y);//lee\n    for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n           if(viz[i][j])\n    {\n         ///la prima trecere becul on si la ultima becul off\n        sol+=(on[i][j]+of[i][j]);\n        nraux=0;\n        for(auto it=t[i][j].begin(); it!=t[i][j].end(); ++it)\n            {\n                nraux++;\n                aux[nraux]=*it;\n            }\n        for(k=1; k<nraux; k++)\n        {\n            int dif=aux[k+1]-aux[k];\n            if((on[i][j]+of[i][j])< dif* pc[i][j])\n                sol+=on[i][j]+of[i][j];\n            else\n                sol+=dif* pc[i][j];\n        }\n    }\n    cout<<sol;\n}\nvoid afis()\n{\n    int i, j;\n    for(i=1; i<=n; i++)\n        for(j=1; j<=m; j++)\n            if(viz[i][j])\n    {\n        cout<<\"room \"<<i<<' '<<j<<\"\\n\";\n        for(auto it=t[i][j].begin(); it!=t[i][j].end(); ++it)\n            cout<<(*it)<<' ';\n        cout<<\"\\n\";\n    }\n}\nint main()\n{\n    citire();\n    solve();\n   // afis();\n    return 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//On or Off\npublic class Main{\n\n\tint h, w, M, INF = 1<<29;\n\tint[][] cost, on, off, nh, nw, v, dp;\n\tchar[][] map;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tboolean[][] u;\n\t\n\tboolean dfs(int i, int j, int ti, int tj){\n\t\tif(i==ti&&j==tj)return true;\n\t\tu[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!u[ni][nj]&&map[ni][nj]=='.'){\n\t\t\t\tif(dfs(ni, nj, ti, tj)){\n\t\t\t\t\tnh[i][j] = ni; nw[i][j] = nj; return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnh[i][j] = nw[i][j] = -1;\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\th = sc.nextInt(); w = sc.nextInt(); M = sc.nextInt();\n\t\tcost = new int[h][w];\n\t\ton = new int[h][w]; off = new int[h][w];\n\t\tnh = new int[h][w]; nw = new int[h][w];\n\t\tmap = new char[h][w];\n\t\tfor(int i=0;i<h;i++)map[i]=sc.next().toCharArray();\n\t\tv = new int[h][w];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)v[i][j] = -1;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cost[i][j]=sc.nextInt();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)on[i][j]=sc.nextInt();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)off[i][j]=sc.nextInt();\n\t\tint t = 0, pi = sc.nextInt(), pj = sc.nextInt();\n\t\tdp = new int[h][w];\n\t\tv[pi][pj] = 0;\n\t\tdp[pi][pj] = on[pi][pj];\n\t\twhile(--M!=0){\n\t\t\tint ti = sc.nextInt(), tj = sc.nextInt();\n\t\t\tu = new boolean[h][w];\n\t\t\tdfs(pi, pj, ti, tj);\n\t\t\tfor(;;){\n\t\t\t\tint ni = nh[pi][pj], nj = nw[pi][pj];\n\t\t\t\tt++;\n\t\t\t\tif(v[ni][nj]==-1)dp[ni][nj] = on[ni][nj];\n\t\t\t\telse{\n\t\t\t\t\tdp[ni][nj] = Math.min(dp[ni][nj]+off[ni][nj]+on[ni][nj], dp[ni][nj]+(t-v[ni][nj])*cost[ni][nj]);\n\t\t\t\t}\n\t\t\t\tv[ni][nj] = t;\n\t\t\t\tpi = ni; pj = nj;\n\t\t\t\tif(pi==ti&&pj==tj)break;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(v[i][j]!=-1)res+=dp[i][j]+off[i][j];\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \npublic class Main {\n \n        Scanner sc = new Scanner(System.in);\n \n        void run() {\n                int h = sc.nextInt();\n                int w = sc.nextInt();\n                int m = sc.nextInt();\n                char[][] d = new char[h][w];\n                for (int i = 0; i < h; i++)\n                        d[i] = sc.next().toCharArray();\n                int[][][] cost = new int[3][h][w];\n                for (int k = 0; k < 3; k++) {\n                        for (int i = 0; i < h; i++) {\n                                for (int j = 0; j < w; j++) {\n                                        cost[k][i][j] = sc.nextInt();\n                                }\n                        }\n                }\n \n                int[] y = new int[m];\n                int[] x = new int[m];\n \n                int[][] map3 = new int[h][w];\n \n                for (int i = 0; i < m; i++) {\n                        y[i] = sc.nextInt();\n                        x[i] = sc.nextInt();\n                }\n                int a = 1;\n                long ans = 0;\n                int map2[][] = new int[h][w];\n \n                for (int i = 0; i < m - 1; i++) {\n                        int gx = x[i];\n                        int gy = y[i];\n \n                        int dx[] = { -1, 1, 0, 0 };\n                        int dy[] = { 0, 0, 1, -1 };\n \n                        int sx = x[i + 1];\n                        int sy = y[i + 1];\n \n                        for(int j =0 ; j < h; j++){\n                                Arrays.fill(map2[j],0);\n                        }\n                        PriorityQueue<Integer> q = new PriorityQueue<Integer>();\n \n                        int z = 1;\n                        q.add(((sx << 8) + sy) + (z << 16));\n                        for (;;) {\n                \n                                int v = q.poll();\n                                int ind = v >> 16;\n                                sy = v & 0xff;\n                                sx = (v >> 8) & 0xff;\n \n                                if (sx == gx && sy == gy) {\n                                        break;\n                                }\n \n                                for (int f = 0; f < 4; f++) {\n                                        int nx = sx + dx[f];\n                                        int ny = sy + dy[f];\n \n                                        if (nx < 0 || ny < 0) {\n                                                continue;\n                                        }\n                                        if (nx >= w || ny >= h) {\n                                                continue;\n                                        }\n \n                                        if (d[ny][nx] == '#') {\n                                                continue;\n                                        }\n                                        if (map2[ny][nx] == 0) {\n                                                map2[ny][nx] = ind + 1;\n                                        }else{\n                                                continue;\n                                        }\n                                        \n                \n                                        q.add(((nx << 8) + ny) + ((ind + 1) << 16));\n                                }\n \n                        }\n                        z = map2[gy][gx];\n                        for (; z > 1; z--) {\n//                              System.out.println(sx + \" \" + sy);\n                                int ha = cost[1][sy][sx] + cost[2][sy][sx];\n                                if (map3[sy][sx] != 0) {\n                                        if ((a - map3[sy][sx]) * cost[0][sy][sx] < ha) {\n                                                ha = (a - map3[sy][sx]) * cost[0][sy][sx];\n                                        }\n                                }\n                                map3[sy][sx] = a;\n                                a++;\n                                ans += ha;\n \n                                for (int f = 0; f < 4; f++) {\n                                        int nx = sx + dx[f];\n                                        int ny = sy + dy[f];\n \n                                        if (nx < 0 || ny < 0) {\n                                                continue;\n                                        }\n                                        if (nx >= w || ny >= h) {\n                                                continue;\n                                        }\n \n                                        if (map2[ny][nx] == z - 1) {\n                                                sx = nx;\n                                                sy = ny;\n                                                break;\n                                        }\n                                }\n                        }\n \n                }\n                {\n                        int sx = x[m-1];\n                        int sy = y[m-1];\n                        int ha = cost[1][sy][sx] + cost[2][sy][sx];\n                        if (map3[sy][sx] != 0) {\n                                if ((a - map3[sy][sx] ) * cost[0][sy][sx] < ha) {\n                                        ha = (a-map3[sy][sx]) * cost[0][sy][sx];\n                                }\n                        }\n \n                        ans += ha;\n                }\n//              System.out.println(a);\n                System.out.println(ans);\n \n        }\n \n        public static void main(String[] args) {\n                Main m = new Main();\n                m.run();\n        }\n \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, -1, 0, 1 };\n\tstatic int R, C, M;\n\tstatic boolean[][] f;\n\tstatic int[][] m1, m2, m3, time;\n\tstatic int[] tr, tc;\n\tstatic int curTime, total;\n\n\tpublic static void main(String[] args) {\n\t\tR = sc.nextInt();\n\t\tC = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tf = new boolean[R][C];\n\t\tm1 = new int[R][C];\n\t\tm2 = new int[R][C];\n\t\tm3 = new int[R][C];\n\t\ttime = new int[R][C];\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tchar[] line = sc.next().toCharArray();\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tf[i][j] = line[j] == '.';\n\t\t\t}\n\t\t\tArrays.fill(time[i], -1);\n\t\t}\n\t\ttr = new int[M];\n\t\ttc = new int[M];\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tm1[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tm2[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tm3[i][j] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\ttr[i] = sc.nextInt();\n\t\t\ttc[i] = sc.nextInt();\n\t\t}\n\t\ttime[tr[0]][tc[0]] = 0;\n\t\ttotal += m2[tr[0]][tc[0]];\n\t\tfor (int i = 0; i < M - 1; ++i) {\n\t\t\tmove(tr[i], tc[i], tr[i + 1], tc[i + 1]);\n\t\t}\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tif (time[i][j] != -1) {\n\t\t\t\t\ttotal += m3[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\n\tstatic void move(int fr, int fc, int tr, int tc) {\n\t\tArrayList<Integer> path = new ArrayList<Integer>();\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nr = fr + DR[i];\n\t\t\tint nc = fc + DC[i];\n\t\t\tif (nr < 0 || R <= nr || nc < 0 || C <= nc || !f[nr][nc]) continue;\n\t\t\tpath.add((nr << 10) + nc);\n\t\t\tif (dfs(i, nr, nc, tr, tc, path)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tpath.remove(path.size() - 1);\n\t\t}\n\t}\n\n\tstatic boolean dfs(int dir, int cr, int cc, int tr, int tc, ArrayList<Integer> path) {\n\t\tif (cr == tr && cc == tc) {\n\t\t\tfor (int i = 0; i < path.size(); ++i) {\n\t\t\t\tint pr = path.get(i) >> 10;\n\t\t\t\tint pc = path.get(i) & 0xFF;\n\t\t\t\tint nowTime = curTime + i + 1;\n\t\t\t\tif (time[pr][pc] == -1) {\n\t\t\t\t\ttotal += m2[pr][pc];\n\t\t\t\t} else {\n\t\t\t\t\tint onOff = m2[pr][pc] + m3[pr][pc];\n\t\t\t\t\tint keep = m1[pr][pc] * (nowTime - time[pr][pc]);\n\t\t\t\t\ttotal += Math.min(onOff, keep);\n\t\t\t\t}\n\t\t\t\ttime[pr][pc] = nowTime;\n\t\t\t}\n\t\t\tcurTime += path.size();\n\t\t\treturn true;\n\t\t}\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (i == ((dir + 2) & 3)) continue;\n\t\t\tint nr = cr + DR[i];\n\t\t\tint nc = cc + DC[i];\n\t\t\tif (nr < 0 || R <= nr || nc < 0 || C <= nc || !f[nr][nc]) continue;\n\t\t\tpath.add((nr << 10) + nc);\n\t\t\tif (dfs(i, nr, nc, tr, tc, path)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tpath.remove(path.size() - 1);\n\t\t}\n\t\treturn false;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.Point;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Main {\n\tInputStream is;\n\n\tboolean __FILE_DEBUG_FLAG__ = false;\n\tString __DEBUG_FILE_NAME__ = \"src/2156-input.txt\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\t\n\tclass State implements Comparable<State> {\n\t\tint x;\n\t\tint y;\n\t\tint t;\n\n\t\tState(int x, int y, int t) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.t = t;\n\t\t}\n\n\t\tpublic int compareTo(State s) {\n\t\t\treturn dist[y][x] - dist[s.y][s.x];\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn getClass().getName() + \" : \" + x + \" \" + y + \" \" + t;\n\t\t}\n\t}\n\t\n\tint NOT_YET = -1;\n\tint INF = 100000000;\n\tint[] vx = {-1, 0, 1, 0};\n\tint[] vy = {0, -1, 0, 1};\n\t\n\tint passedTime = 0;\n\tlong res = 0;\n\t\n\tint[][] dist, prev;\n\tint[][] prevVisitTime;\n\tint[][] unitCost, onCost, offCost;\n\tchar[][] room;\n\t\n\tboolean inside(int x, int y, int M, int N) {\n\t\treturn x >= 0 && y >= 0 && x < M && y < N;\n\t}\n\t\n\tvoid bfs(int sx, int sy) {\n\t\tint R = dist.length, C = dist[0].length;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tArrays.fill(dist[i], INF);\n\t\t\tArrays.fill(prev[i], -1);\n\t\t}\n\t\t\n\t\tdist[sy][sx] = 0;\n\t\t\n\t\tQueue<State> q = new LinkedList<State>();\n\t\tq.add(new State(sx, sy, passedTime));\n\t\twhile (!q.isEmpty()) {\n\t\t\tState st = q.poll();\n\t\t\t\n\t\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\t\tint nx = st.x + vx[d], ny = st.y + vy[d];\n\t\t\t\tif (inside(nx, ny, C, R) && room[ny][nx] == '.') {\n\t\t\t\t\tint ncost = dist[st.y][st.x] + onCost[ny][nx] + offCost[ny][nx];\n\t\t\t\t\tif (prevVisitTime[ny][nx] != -1) \n\t\t\t\t\t\tncost = Math.min(ncost, dist[st.y][st.x] + unitCost[ny][nx] * (st.t + 1 - prevVisitTime[ny][nx]));\n\t\t\t\t\t\n\t\t\t\t\tif (ncost < dist[ny][nx]) {\n\t\t\t\t\t\tdist[ny][nx] = ncost;\n\t\t\t\t\t\tprev[ny][nx] = (d + 2) % 4;\n\t\t\t\t\t\tq.add(new State(nx, ny, st.t + 1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n//\t\tmapDebug(dist);\n//\t\tmapDebug(prev);\n\t}\n\t\n\tvoid updateTime(int x, int y, int gx, int gy) {\n//\t\tSystem.out.println(\"upd : \" + x + \" \" + y + \" \" + gx + \" \" + gy);\n\t\tif (x == gx && y == gy) return;\n\t\t\n\t\tint d = prev[y][x];\n\t\tupdateTime(x + vx[d], y + vy[d], gx, gy);\n\t\t\n\t\tpassedTime++;\n\t\tprevVisitTime[y][x] = passedTime;\n\t}\n\t\n\tpublic void solve() {\t\n\t\tint R = in.nextInt(), C = in.nextInt(), M = in.nextInt();\n\t\troom = new char[R][];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\troom[i] = in.next().toCharArray();\n\t\t}\n\t\tunitCost = in.nextIntMap(R, C);\n\t\tonCost = in.nextIntMap(R, C);\n\t\toffCost = in.nextIntMap(R, C);\n\t\t\n\t\tprevVisitTime = new int[R][C];\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tArrays.fill(prevVisitTime[i], NOT_YET);\n\t\t}\n\t\tdist = new int[R][C];\n\t\tprev = new int[R][C];\n\t\t\n\t\tint y = in.nextInt(), x = in.nextInt();\n\t\tres += onCost[y][x] + offCost[y][x];\n\t\tprevVisitTime[y][x] = 0;\n\t\t\n\t\tfor (int i = 1; i < M; i++) {\n\t\t\tint ny = in.nextInt(), nx = in.nextInt();\n\t\t\t\n\t\t\tbfs(x, y);\n\t\t\tupdateTime(nx, ny, x, y);\n\t\t\tres += dist[ny][nx];\n\t\t\t\n\t\t\tx = nx;\n\t\t\ty = ny;\n\t\t}\n\t\t\n\t\tSystem.out.println(res);\n\t}\n\n\t\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//On or Off\npublic class Main{\n\n\tint h, w, M;\n\tint[][] cost, on, off, nh, nw, v, dp;\n\tchar[][] map;\n\tint[][] move = {{-1,0},{0,1},{1,0},{0,-1}};\n\tboolean[][] u;\n\t\n\tboolean dfs(int i, int j, int ti, int tj){\n\t\tif(i==ti&&j==tj)return true;\n\t\tu[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w&&!u[ni][nj]&&map[ni][nj]=='.'){\n\t\t\t\tif(dfs(ni, nj, ti, tj)){\n\t\t\t\t\tnh[i][j] = ni; nw[i][j] = nj; return true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnh[i][j] = nw[i][j] = -1;\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\th = sc.nextInt(); w = sc.nextInt(); M = sc.nextInt();\n\t\tcost = new int[h][w];\n\t\ton = new int[h][w]; off = new int[h][w];\n\t\tnh = new int[h][w]; nw = new int[h][w];\n\t\tmap = new char[h][w];\n\t\tfor(int i=0;i<h;i++)map[i]=sc.next().toCharArray();\n\t\tv = new int[h][w];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)v[i][j] = -1;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)cost[i][j]=sc.nextInt();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)on[i][j]=sc.nextInt();\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)off[i][j]=sc.nextInt();\n\t\tint t = 0, pi = sc.nextInt(), pj = sc.nextInt();\n\t\tdp = new int[h][w];\n\t\tv[pi][pj] = 0;\n\t\tdp[pi][pj] = on[pi][pj];\n\t\twhile(--M!=0){\n\t\t\tint ti = sc.nextInt(), tj = sc.nextInt();\n\t\t\tu = new boolean[h][w];\n\t\t\tdfs(pi, pj, ti, tj);\n\t\t\tfor(;pi!=ti||pj!=tj;){\n\t\t\t\tint ni = nh[pi][pj], nj = nw[pi][pj];\n\t\t\t\tt++;\n\t\t\t\tif(v[ni][nj]==-1)dp[ni][nj] = on[ni][nj];\n\t\t\t\telse dp[ni][nj] = Math.min(dp[ni][nj]+off[ni][nj]+on[ni][nj], dp[ni][nj]+(t-v[ni][nj])*cost[ni][nj]);\n\t\t\t\tv[ni][nj] = t;\n\t\t\t\tpi = ni; pj = nj;\n\t\t\t}\n\t\t}\n\t\tint res = 0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)if(v[i][j]!=-1)res+=dp[i][j]+off[i][j];\n\t\tSystem.out.println(res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using system;"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nh, w, k = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ntime_cost = (1..h).map{gets.split.map &:to_i}\non_cost = (1..h).map{gets.split.map &:to_i}\noff_cost = (1..h).map{gets.split.map &:to_i}\ntasks = (1..k).map{gets.split.map &:to_i}\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j|\n\tg.add_node({\n\t\t:y => i,\n\t\t:x => j,\n\t\t:prev_visit => 0,\n\t\t:on_best => Float::INFINITY,\n\t\t:off_best => 0\n\t})\n}}\n(0..h-1).each{|i|\n\t(0..w-1).each{|j|\n\t\tg.add_edge(nodes[i-1][j], nodes[i][j]) if i > 0 && a[i-1][j] == a[i][j]\n\t\tg.add_edge(nodes[i][j-1], nodes[i][j]) if j > 0 && a[i][j-1] == a[i][j]\n\t}\n}\n\ni, j = tasks.shift\nu = nodes[i][j]\nu.property[:on_best] = on_cost[i][j]\nu.property[:off_best] = on_cost[i][j] + off_cost[i][j]\nt = 0\n\nuntil tasks.empty?\n\ti, j = tasks.shift\n\tv = nodes[i][j]\n\tpath = g.get_path_by_bfs(u, v)\n\tpath.shift\n\tpath.each{|w|\n\t\tt += 1\n\t\tx, y = w.property[:x], w.property[:y]\n\t\tc = [\n\t\t\tw.property[:off_best] + on_cost[y][x],\n\t     \tw.property[:on_best] + (t - w.property[:prev_visit]) * time_cost[y][x]\n\t\t].min\n\t\tw.property[:off_best] = c + off_cost[y][x]\n\t\tw.property[:on_best] = c\n\t\tw.property[:prev_visit] = t\n\t}\n\tu = v\nend\n\np nodes.flatten.map{|v|\n\tv.property[:off_best]\n}.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n\trequire 'set'\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nh, w, k = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n\ntime_cost = (1..h).map{gets.split.map &:to_i}\non_cost = (1..h).map{gets.split.map &:to_i}\noff_cost = (1..h).map{gets.split.map &:to_i}\ntasks = (1..k).map{gets.split.map &:to_i}\n\ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j|\n\tg.add_node({\n\t\t:y => i,\n\t\t:x => j,\n\t\t:prev_visit => 0,\n\t\t:on_best => Float::INFINITY,\n\t\t:off_best => 0\n\t})\n}}\n(0..h-1).each{|i|\n\t(0..w-1).each{|j|\n\t\tg.add_edge(nodes[i-1][j], nodes[i][j]) if i > 0 && a[i-1][j] == a[i][j]\n\t\tg.add_edge(nodes[i][j-1], nodes[i][j]) if j > 0 && a[i][j-1] == a[i][j]\n\t}\n}\n\ni, j = tasks.shift\nu = nodes[i][j]\nu.property[:on_best] = on_cost[i][j]\nu.property[:off_best] = on_cost[i][j] + off_cost[i][j]\nt = 0\n\nuntil tasks.empty?\n\ti, j = tasks.shift\n\tv = nodes[i][j]\n\tpath = g.get_path_by_dfs(u, v)\n\tpath.shift\n\tpath.each{|w|\n\t\tt += 1\n\t\tx, y = w.property[:x], w.property[:y]\n\t\tc = [\n\t\t\tw.property[:off_best] + on_cost[y][x],\n\t     \tw.property[:on_best] + (t - w.property[:prev_visit]) * time_cost[y][x]\n\t\t].min\n\t\tw.property[:off_best] = c + off_cost[y][x]\n\t\tw.property[:on_best] = c\n\t\tw.property[:prev_visit] = t\n\t}\n\tu = v\nend\n\np nodes.flatten.map{|v|\n\tv.property[:off_best]\n}.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "def move(src, des, t, f, p, costs, r, c, a)\n  if src == des\n    return [t, a]\n  end\n  ret = [0, a]\n  f[src[0]][src[1]] = '@'\n  [[-1, 0], [0, -1], [0, 1], [1, 0]].each do |d|\n    i, j = src[0] + d[0], src[1] + d[1]\n    if i >= 0 && j >= 0 && i < r && j < c && f[i][j] == '.'\n      ret = move([i, j], des, t + 1, f, p, costs, r, c, a)\n      if ret[0] > 0\n        cost = costs[1][i][j] + costs[2][i][j]\n        ret[1] += cost\n        if p[i][j]\n          d = (t - p[i][j]) * costs[0][i][j] - cost\n          ret[1] += d if d < 0\n        end\n        p[i][j] = t\n        break\n      end\n    end\n  end\n  f[src[0]][src[1]] = '.'\n  ret\nend\ndef calc(f, costs, tasks, r, c, m)\n  i0, j0 = tasks[0][0], tasks[0][1]\n  p = Array.new(c){ [] }\n  p[i0][j0] = 1\n  t = 2\n  a = costs[1][i0][j0] + costs[2][i0][j0]\n  tasks.each_cons(2) do |task|\n     t, a = move(*task, t, f, p, costs, r, c, a)\n  end\n  a\nend\n1.times do\n  f = [], costs = [], tasks = []\n  r, c, m = gets.split.map(&:to_i)\n  r.times do |i|\n    f[i] = gets.chomp.split('')\n  end\n  3.times do |k|\n    costs[k] = []\n    r.times do |i|\n      costs[k][i] = gets.split.map(&:to_i)\n    end\n  end\n  m.times do |i|\n    tasks[i] = gets.split.map(&:to_i)\n  end\n  puts calc(f, costs, tasks, r, c, m)\nend"
  },
  {
    "language": "Ruby",
    "code": "module Graphical\n    require 'set'\n \n    def get_path_by_bfs(s, t)\n        prev_node = {}\n        reached = Set[s]\n        queue = [s]\n        while !queue.empty? \n            u = queue.shift\n            each_out_connection_of(u){|v, _|\n                next if reached.include?(v) \n                reached << v\n                queue << v\n                prev_node[v] = u\n \n                if v == t\n                    path = [v]\n                    while v = prev_node[v]\n                        path.unshift v\n                    end\n                    return path\n                end\n            }\n        end \n        return nil\n    end\n \n    def get_path_by_dfs(s, t, reached = Set.new)\n        reached << s\n        return [s] if s == t\n        each_out_connection_of(s){|v|\n            next if reached.include?(v)\n            path = get_path_by_dfs(v, t, reached) \n            return [s] + path if path\n        }\n        nil\n    end\n \n    def reachable_from(s, max_depth = nil)\n        reached = Set[s]\n        queue = [s]\n        depth = 0\n        loop {\n            break if max_depth && depth >= max_depth\n            next_queue = []\n            until queue.empty?\n                u = queue.shift\n                each_out_connection_of(u){|v, _|\n                    next if reached.include?(v)\n                    reached << v\n                    next_queue << v\n                }\n            end\n            break if next_queue.empty?\n            queue = next_queue\n            depth += 1\n        }\n        return reached\n    end\n \n    def bfs(start)\n        raise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n        reached = Set[*start.to_a]\n        queue = []\n        start.each{|s| queue << s}\n        dist = {}\n        loop.with_index {|_, depth|\n            next_queue = []\n            until queue.empty?\n                u = queue.shift\n                return depth if block_given? && yield(u, depth)\n                dist[u] = depth\n                each_out_connection_of(u){|v, _|\n                    next if reached.include?(v)\n                    reached << v\n                    next_queue << v\n                }\n            end\n            break if next_queue.empty?\n            queue = next_queue\n        }\n        block_given? ? nil : dist\n    end\n \n    def dijkstra(start)\n        raise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n        h = Heap.new\n        reached = Set[*start.to_a]\n        start.each{|s| h.add(s, 0)}\n \n        dist = {}\n        until h.empty?\n            u, key = h.del_min\n            return key if block_given? && yield(u, key)\n            dist[u] = key\n            each_out_connection_of(u){|v, l|\n                d = dist[u] + l\n                if reached.include?(v)\n                    h.update_key(v, d)\n                else\n                    h.add(v, d)\n                    reached << v\n                end\n            }\n        end\n        block_given? ? nil : dist\n    end\n \n    def bidir_dijkstra(s, t)\n        f_dist = {}\n        b_dist = {}\n \n        f_heap = Heap.new\n        b_heap = Heap.new\n \n        f_heap.add(s, 0)\n        b_heap.add(t, 0)\n \n        f_reached = Set[s]\n        b_reached = Set[t]\n \n        f_current_dist = b_current_dist = 0\n        best = Float::INFINITY\n \n        loop {\n            if !f_heap.empty?\n                u, key = f_heap.del_min\n                f_dist[u] = key\n                f_current_dist = key\n                each_out_connection_of(u){|v, l|\n                    d = f_dist[u] + l\n                    if b_dist[v]\n                        path_len = d + b_dist[v]\n                        best = path_len if path_len < best\n                    end\n                    if f_reached.include?(v)\n                        f_heap.update_key(v, d)\n                    else\n                        f_heap.add(v, d)\n                        f_reached << v\n                    end\n                }\n            end\n \n            if !b_heap.empty?\n                u, key = b_heap.del_min\n                b_dist[u] = key\n                b_current_dist = key\n                each_in_connection_of(u){|v, l|\n                    d = b_dist[u] + l\n                    if f_dist[v]\n                        path_len = d + f_dist[v]\n                        best = path_len if path_len < best\n                    end\n                    if b_reached.include?(v)\n                        b_heap.update_key(v, d)\n                    else\n                        b_heap.add(v, d)\n                        b_reached << v\n                    end\n                }\n            end\n \n            return best if f_current_dist + b_current_dist >= best\n            return nil if f_heap.empty? && b_heap.empty?\n        }\n    end\n \n    def a_star(start)\n        raise \"a_star need termination condition\" unless block_given?\n        h = Heap.new\n        reached = Set[start]\n        h.add(start, [a_star_heuristic(start), 0])\n \n        dist = {}\n        until h.empty?\n            u, (e, d) = h.del_min\n            return d if yield(u, dist)\n            dist[u] = d\n            each_out_connection_of(u){|v, l|\n                d = dist[u] + l\n                e = d + a_star_heuristic(v)\n                if reached.include?(v)\n                    h.update_key(v, [e, d])\n                else\n                    h.add(v, [e, d])\n                    reached << v\n                end\n            }\n        end\n        block_given? ? nil : dist\n    end\n \n    #make_variations :bidir_dijkstra\n \n    def prim(start)\n        h = Heap.new\n        h.add(start, 0)\n        reached = Set[start]\n        tree_len = 0\n \n        until h.empty?\n            u, key = h.del_min\n            tree_len += key\n \n            each_connection_of(u){|v, d|\n                if reached.include?(v)\n                    h.update_key(v, d)\n                else\n                    h.add(v, d)\n                    reached << v\n                end\n            }\n        end\n        tree_len\n    end\n \n    def each_layer_from(start)\n        raise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n        return enum_for(__method__, start) unless block_given?\n        reached = Set[*start]\n        current_layer = start\n \n        loop {\n            yield current_layer\n            next_layer = []\n            current_layer.each{|u|\n                each_out_connection_of(u){|v|\n                    next if reached.include?(v)\n                    reached << v\n                    next_layer << v\n                }\n            }   \n \n            return if next_layer.empty?\n            current_layer = next_layer\n        }\n    end\nend\n \nclass Graph\n    include Graphical\n \n    def initialize(*options)\n        @options = Set[*options]\n    end\n \n    def add_node(property = {})\n        Node.new(property)\n    end\n \n    def add_edge(u, v, property = {})\n        e = Edge.new(u, v, property)\n        u.add_edge(e)\n        v.add_edge(e)\n        e\n    end\n     \n    def del_edge(e)\n        u, v = e.opposite.keys\n        u.del_edge(e)\n        v.del_edge(e)\n        e\n    end\n \n    class Node\n        def initialize(property)\n            @property = property\n            @edges = Set.new\n        end\n \n        def add_edge(e)\n            @edges << e\n        end\n \n        def del_edge(e)\n            @edges.delete(e)\n        end\n \n        def to_s\n            @property[:name] || super\n        end\n \n        def each_edge\n            @edges.each{|e| \n                yield e\n            }\n        end\n \n        attr_reader :property\n    end\n \n    class Edge\n        def initialize(u, v, property)\n            @opposite = {u => v, v => u}\n            @property = property\n        end\n        attr_reader :opposite, :property\n \n        def to_s\n            @property[:name] || super\n        end\n \n        def length\n            @property[:length] || 1\n        end\n    end\n \n    def each_out_connection_of(u)\n        u.each_edge{|e|\n            yield(e.opposite[u], e.length)\n        }\n    end\n \n    alias :each_in_connection_of :each_out_connection_of\nend\n \nh, w, k = gets.split.map &:to_i\na = (1..h).map{ gets.chomp.split(\"\") }\n \ntime_cost = (1..h).map{gets.split.map &:to_i}\non_cost = (1..h).map{gets.split.map &:to_i}\noff_cost = (1..h).map{gets.split.map &:to_i}\ntasks = (1..k).map{gets.split.map &:to_i}\n \ng = Graph.new\nnodes = (0..h-1).map{|i| (0..w-1).map{|j|\n    g.add_node({\n        :y => i,\n        :x => j,\n        :prev_visit => 0,\n        :on_best => Float::INFINITY,\n        :off_best => 0\n    })\n}}\n(0..h-1).each{|i|\n    (0..w-1).each{|j|\n        g.add_edge(nodes[i-1][j], nodes[i][j]) if i > 0 && a[i-1][j] == a[i][j]\n        g.add_edge(nodes[i][j-1], nodes[i][j]) if j > 0 && a[i][j-1] == a[i][j]\n    }\n}\n \ni, j = tasks.shift\nu = nodes[i][j]\nu.property[:on_best] = on_cost[i][j]\nu.property[:off_best] = on_cost[i][j] + off_cost[i][j]\nt = 0\n \nuntil tasks.empty?\n    i, j = tasks.shift\n    v = nodes[i][j]\n    path = g.get_path_by_bfs(u, v)\n    path.shift\n    path.each{|w|\n        t += 1\n        x, y = w.property[:x], w.property[:y]\n        c = [\n            w.property[:off_best] + on_cost[y][x],\n            w.property[:on_best] + (t - w.property[:prev_visit]) * time_cost[y][x]\n        ].min\n        w.property[:off_best] = c + off_cost[y][x]\n        w.property[:on_best] = c\n        w.property[:prev_visit] = t\n    }\n    u = v\nend\n \np nodes.flatten.map{|v|\n    v.property[:off_best]\n}.inject(:+)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\n\nsys.setrecursionlimit(1000000)\n\nR, C, M = map(int, raw_input().split())\nS = []\nt_cost = []\non_cost = []\noff_cost = []\n\nfor loop in range(R):\n    hoge = raw_input()\n    S.append(hoge)\n\nfor loop in range(R):\n    hoge = map(int, raw_input().split())\n    t_cost.append(hoge)\n\nfor loop in range(R):\n    hoge = map(int, raw_input().split())\n    on_cost.append(hoge)\n\nfor loop in range(R):\n    hoge = map(int, raw_input().split())\n    off_cost.append(hoge)\n\nm = {}\nused = {}\n\nfor y in range(R):\n    for x in range(C):\n        m[(x, y)] = []\n\ndef func(x, y, gx, gy, step):\n    if x < 0 or y < 0 or x >= C or y >= R:\n        return False\n    if (x, y) in used:\n        return False\n    used[(x, y)] = step\n    if S[y][x] == '#':\n        return False\n    if x == gx and y == gy:\n        m[(x, y)].append(step)\n        return True\n    ret = False\n    ret = (ret or func(x - 1, y, gx, gy, step + 1))\n    ret = (ret or func(x + 1, y, gx, gy, step + 1))\n    ret = (ret or func(x, y - 1, gx, gy, step + 1))\n    ret = (ret or func(x, y + 1, gx, gy, step + 1))\n    if ret:\n        m[(x, y)].append(step)\n    return ret\n\nsy, sx = map(int, raw_input().split())\ncnt = 0\nfor loop in range(M - 1):\n    gy, gx = map(int, raw_input().split())\n    used = {}\n    func(sx, sy, gx, gy, cnt)\n    cnt = m[(gx, gy)].pop()\n    sx, sy = gx, gy\nm[(gx, gy)].append(cnt)\n\nans = 0\nfor y in range(R):\n    for x in range(C):\n        t = t_cost[y][x]\n        on = on_cost[y][x]\n        off = off_cost[y][x]\n\n        lst = m[(x, y)]\n        if len(lst) > 0:\n            ans += on + off\n        for i in range(len(lst) - 1):\n            t1 = lst[i]\n            t2 = lst[i + 1]\n            ans += min(on + off, t * (t2 - t1))\n#print m\nprint ans\n\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef main():\n    rr = []\n\n    def f():\n        r,c,m = LI()\n        a = [[1] * (c+2)] + [[1] + [None if c == '.' else 1 for c in S()] + [1] for _ in range(r)] + [[1] * (c+2)]\n        cost = [[1] * (c+2)] + [[1] + LI() + [1] for _ in range(r)] + [[1] * (c+2)]\n        on = [[1] * (c+2)] + [[1] + LI() + [1] for _ in range(r)] + [[1] * (c+2)]\n        off = [[1] * (c+2)] + [[1] + LI() + [1] for _ in range(r)] + [[1] * (c+2)]\n        ms = [tuple(map(lambda x: x+1, LI())) for _ in range(m)]\n        e = collections.defaultdict(list)\n        for i in range(1,r+1):\n            for j in range(1,c+1):\n                if a[i][j]:\n                    continue\n                for di,dj in dd:\n                    if a[i+di][j+dj]:\n                        continue\n                    e[(i,j)].append(((i+di,j+dj), 1))\n\n        def search(s):\n            d = collections.defaultdict(lambda: inf)\n            d[s] = 0\n            q = []\n            heapq.heappush(q, (0, s))\n            v = collections.defaultdict(bool)\n            while len(q):\n                k, u = heapq.heappop(q)\n                if v[u]:\n                    continue\n                v[u] = True\n\n                for uv, ud in e[u]:\n                    if v[uv]:\n                        continue\n                    vd = k + ud\n                    if d[uv] > vd:\n                        d[uv] = vd\n                        heapq.heappush(q, (vd, uv))\n\n            return d\n\n        ad = {}\n        for k in ms:\n            if k in ad:\n                continue\n            ad[k] = search(k)\n        ti = 0\n        td = collections.defaultdict(list)\n        c = ms[0]\n        td[c].append(0)\n        for t in ms[1:]:\n            while c != t:\n                cc = ad[t][c]\n                for di,dj in dd:\n                    ni = c[0] + di\n                    nj = c[1] + dj\n                    n = (ni, nj)\n                    if ad[t][n] == cc - 1:\n                        ti += 1\n                        td[n].append(ti)\n                        c = n\n                        break\n\n        r = 0\n        for k,v in sorted(td.items()):\n            i = k[0]\n            j = k[1]\n            cs = cost[i][j]\n            onf = on[i][j] + off[i][j]\n            tr = onf\n            for vi in range(len(v)-1):\n                sa = v[vi+1] - v[vi]\n                tr += min(cs * sa, onf)\n            r += tr\n\n        return r\n\n    while True:\n        rr.append(f())\n        break\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  }
]