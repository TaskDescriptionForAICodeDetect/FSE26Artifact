[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 100005\n\ntypedef struct Node {\n    int value;\n    int children_count;\n    int children[MAX_NODES];\n} Node;\n\nNode tree[MAX_NODES];\nint leaf_count = 0;\nint min_evals = 0, max_evals = 0;\n\nint is_leaf(int node) {\n    return tree[node].children_count == 0;\n}\n\nvoid min_max_leaf_evals(int node, int is_max_player) {\n    if (is_leaf(node)) {\n        min_evals++;\n        max_evals++;\n        return;\n    }\n\n    if (is_max_player) {\n        int max_val = INT_MIN;\n        for (int i = 0; i < tree[node].children_count; i++) {\n            min_max_leaf_evals(tree[node].children[i], 0);\n            max_val = (max_val > tree[tree[node].children[i]].value) ? \n                       max_val : tree[tree[node].children[i]].value;\n        }\n        tree[node].value = max_val;\n    } else {\n        int min_val = INT_MAX;\n        for (int i = 0; i < tree[node].children_count; i++) {\n            max_evals++;\n            min_max_leaf_evals(tree[node].children[i], 1);\n            min_val = (min_val < tree[tree[node].children[i]].value) ? \n                       min_val : tree[tree[node].children[i]].value;\n        }\n        tree[node].value = -min_val;\n    }\n}\n\nint main() {\n    int n, root;\n    scanf(\"%d %d\", &n, &root);\n\n    for (int i = 1; i <= n; i++) {\n        int children;\n        scanf(\"%d\", &children);\n        tree[i].children_count = children;\n\n        for (int j = 0; j < children; j++) {\n            int child;\n            scanf(\"%d\", &child);\n            tree[i].children[j] = child;\n        }\n    }\n\n    min_evals = 0;\n    max_evals = 0;\n    min_max_leaf_evals(root, 1);\n\n    printf(\"%d %d\\n\", min_evals, max_evals);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct Node {\n    int value;\n    int is_leaf;\n    int child_count;\n    struct Node** children;\n    int min_eval;\n    int max_eval;\n} Node;\n\nNode* create_node(int value, int is_leaf) {\n    Node* node = (Node*)malloc(sizeof(Node));\n    node->value = value;\n    node->is_leaf = is_leaf;\n    node->child_count = 0;\n    node->children = NULL;\n    node->min_eval = 0;\n    node->max_eval = 0;\n    return node;\n}\n\nvoid add_child(Node* parent, Node* child) {\n    parent->children = (Node**)realloc(parent->children, (parent->child_count + 1) * sizeof(Node*));\n    parent->children[parent->child_count++] = child;\n}\n\nvoid compute_min_max(Node* node) {\n    if (node->is_leaf) {\n        node->min_eval = 1;\n        node->max_eval = 1;\n        return;\n    }\n\n    int total_min = 0;\n    int total_max = 0;\n    int child_min = INT_MAX;\n    int child_max = INT_MIN;\n\n    for (int i = 0; i < node->child_count; ++i) {\n        compute_min_max(node->children[i]);\n        total_min += node->children[i]->min_eval;\n        total_max += node->children[i]->max_eval;\n        if (node->children[i]->min_eval < child_min) {\n            child_min = node->children[i]->min_eval;\n        }\n        if (node->children[i]->max_eval > child_max) {\n            child_max = node->children[i]->max_eval;\n        }\n    }\n\n    if (node->value == -1) {\n        node->min_eval = child_min;\n        node->max_eval = child_max;\n    } else {\n        node->min_eval = total_min;\n        node->max_eval = total_max;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Node** nodes = (Node**)malloc(n * sizeof(Node*));\n    for (int i = 0; i < n; ++i) {\n        int value, is_leaf;\n        scanf(\"%d %d\", &value, &is_leaf);\n        nodes[i] = create_node(value, is_leaf);\n    }\n\n    for (int i = 1; i < n; ++i) {\n        int parent;\n        scanf(\"%d\", &parent);\n        add_child(nodes[parent], nodes[i]);\n    }\n\n    compute_min_max(nodes[0]);\n    printf(\"%d %d\\n\", nodes[0]->min_eval, nodes[0]->max_eval);\n\n    for (int i = 0; i < n; ++i) {\n        free(nodes[i]->children);\n        free(nodes[i]);\n    }\n    free(nodes);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:50:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Node {\n    int min_eval, max_eval;\n    bool is_leaf;\n};\n\nvoid dfs(int u, const vector<vector<int>>& tree, vector<Node>& nodes) {\n    if (tree[u].empty()) {\n        nodes[u].min_eval = 1;\n        nodes[u].max_eval = 1;\n        nodes[u].is_leaf = true;\n        return;\n    }\n    \n    nodes[u].is_leaf = false;\n    int sum_min = 0, sum_max = 0;\n    int child_min = 1e9, child_max = 0;\n    \n    for (int v : tree[u]) {\n        dfs(v, tree, nodes);\n        sum_min += nodes[v].min_eval;\n        sum_max += nodes[v].max_eval;\n        child_min = min(child_min, nodes[v].min_eval);\n        child_max = max(child_max, nodes[v].max_eval);\n    }\n    \n    if (u == 0 || nodes[u].is_leaf) {\n        nodes[u].min_eval = sum_min;\n        nodes[u].max_eval = sum_max;\n    } else {\n        nodes[u].min_eval = child_min;\n        nodes[u].max_eval = child_max;\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> tree(n);\n    for (int i = 0; i < n; ++i) {\n        int p;\n        cin >> p;\n        if (p != -1) {\n            tree[p].push_back(i);\n        }\n    }\n    \n    vector<Node> nodes(n);\n    dfs(0, tree, nodes);\n    \n    cout << nodes[0].min_eval << \" \" << nodes[0].max_eval << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:51:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GameTreeEvaluator {\n    static class Node {\n        List<Node> children = new ArrayList<>();\n        boolean isLeaf = true;\n        int minEval;\n        int maxEval;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        Node[] nodes = new Node[n];\n        for (int i = 0; i < n; i++) {\n            nodes[i] = new Node();\n        }\n        for (int i = 1; i < n; i++) {\n            int parent = scanner.nextInt() - 1;\n            nodes[parent].children.add(nodes[i]);\n            nodes[parent].isLeaf = false;\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            Node node = nodes[i];\n            if (node.isLeaf) {\n                node.minEval = 1;\n                node.maxEval = 1;\n            } else {\n                int minSum = 0;\n                int maxSum = 0;\n                int minChildMin = Integer.MAX_VALUE;\n                int maxChildMax = 0;\n\n                for (Node child : node.children) {\n                    minSum += child.minEval;\n                    maxSum += child.maxEval;\n                    if (child.minEval < minChildMin) {\n                        minChildMin = child.minEval;\n                    }\n                    if (child.maxEval > maxChildMax) {\n                        maxChildMax = child.maxEval;\n                    }\n                }\n\n                node.minEval = minChildMin;\n                node.maxEval = maxSum;\n            }\n        }\n\n        System.out.println(nodes[0].minEval + \" \" + nodes[0].maxEval);\n    }\n}",
    "timestamp": "2025-08-05 21:51:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class GameTreeEvaluation {\n    static class Node {\n        int value;\n        List<Node> children;\n        \n        Node() {\n            children = new ArrayList<>();\n        }\n    }\n    \n    static int minLeafEvaluations(Node root) {\n        return minLeafDFS(root, true).evaluations;\n    }\n    \n    static int maxLeafEvaluations(Node root) {\n        return maxLeafDFS(root, true).evaluations;\n    }\n    \n    static Result minLeafDFS(Node node, boolean isRoot) {\n        if (node.children.isEmpty()) {\n            return new Result(node.value, 1);\n        }\n        \n        int minEvaluations = Integer.MAX_VALUE;\n        int nodeValue = Integer.MIN_VALUE;\n        \n        for (Node child : node.children) {\n            Result childResult = minLeafDFS(child, false);\n            nodeValue = Math.max(nodeValue, -childResult.value);\n            minEvaluations = Math.min(minEvaluations, childResult.evaluations);\n        }\n        \n        node.value = nodeValue;\n        return new Result(nodeValue, isRoot ? minEvaluations : minEvaluations + 1);\n    }\n    \n    static Result maxLeafDFS(Node node, boolean isRoot) {\n        if (node.children.isEmpty()) {\n            return new Result(node.value, 1);\n        }\n        \n        int maxEvaluations = 0;\n        int nodeValue = Integer.MIN_VALUE;\n        \n        for (Node child : node.children) {\n            Result childResult = maxLeafDFS(child, false);\n            nodeValue = Math.max(nodeValue, -childResult.value);\n            maxEvaluations += childResult.evaluations;\n        }\n        \n        node.value = nodeValue;\n        return new Result(nodeValue, isRoot ? maxEvaluations : maxEvaluations + 1);\n    }\n    \n    static class Result {\n        int value;\n        int evaluations;\n        \n        Result(int value, int evaluations) {\n            this.value = value;\n            this.evaluations = evaluations;\n        }\n    }\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        int n = Integer.parseInt(br.readLine());\n        Node[] nodes = new Node[n];\n        \n        for (int i = 0; i < n; i++) {\n            nodes[i] = new Node();\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            StringTokenizer st = new StringTokenizer(br.readLine());\n            int parent = Integer.parseInt(st.nextToken()) - 1;\n            int child = Integer.parseInt(st.nextToken()) - 1;\n            nodes[parent].children.add(nodes[child]);\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (nodes[i].children.isEmpty()) {\n                nodes[i].value = Integer.parseInt(br.readLine());\n            }\n        }\n        \n        Node root = nodes[0];\n        \n        int minEval = minLeafEvaluations(root);\n        int maxEval = maxLeafEvaluations(root);\n        \n        System.out.println(minEval + \" \" + maxEval);\n    }\n}",
    "timestamp": "2025-08-05 21:52:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nclass GameTree {\nprivate:\n    int n;\n    vector<int> values;\n    vector<vector<int>> children;\n    \n    pair<int, int> dfs(int node, bool isMaximizing) {\n        if (children[node].empty()) {\n            return {1, 1};  // Leaf node always requires 1 evaluation\n        }\n        \n        int minEval = 0, maxEval = 0;\n        \n        if (isMaximizing) {\n            int maxVal = INT_MIN;\n            int minLeafEval = INT_MAX;\n            int maxLeafEval = 0;\n            \n            for (int child : children[node]) {\n                auto [minChildEval, maxChildEval] = dfs(child, false);\n                minLeafEval = min(minLeafEval, minChildEval);\n                maxLeafEval = max(maxLeafEval, maxChildEval);\n                maxVal = max(maxVal, values[child]);\n            }\n            \n            values[node] = maxVal * -1;\n            minEval = minLeafEval;\n            maxEval = maxLeafEval;\n        } else {\n            int minVal = INT_MAX;\n            int minLeafEval = INT_MAX;\n            int maxLeafEval = 0;\n            \n            for (int child : children[node]) {\n                auto [minChildEval, maxChildEval] = dfs(child, true);\n                minLeafEval = min(minLeafEval, minChildEval);\n                maxLeafEval = max(maxLeafEval, maxChildEval);\n                minVal = min(minVal, values[child]);\n            }\n            \n            values[node] = minVal * -1;\n            minEval = minLeafEval;\n            maxEval = maxLeafEval;\n        }\n        \n        return {minEval, maxEval};\n    }\n    \npublic:\n    GameTree(int vertices) : n(vertices), values(vertices), children(vertices) {}\n    \n    void addValue(int node, int val) {\n        values[node] = val;\n    }\n    \n    void addChild(int parent, int child) {\n        children[parent].push_back(child);\n    }\n    \n    pair<int, int> calculateEvaluations(int root) {\n        return dfs(root, true);\n    }\n};\n\nint main() {\n    int n, root;\n    cin >> n >> root;\n    \n    GameTree gameTree(n);\n    \n    for (int i = 0; i < n; i++) {\n        int val;\n        cin >> val;\n        gameTree.addValue(i, val);\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        int parent, child;\n        cin >> parent >> child;\n        gameTree.addChild(parent, child);\n    }\n    \n    auto [minEval, maxEval] = gameTree.calculateEvaluations(root);\n    \n    cout << minEval << \" \" << maxEval << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:52:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def dfs(node, children, is_maximizing, visited_min, visited_max):\n    if not children[node]:  # leaf node\n        return 1, 1\n\n    min_evals = float('inf')\n    max_evals = 0\n\n    for child in children[node]:\n        child_min, child_max = dfs(child, children, not is_maximizing, visited_min, visited_max)\n\n        if is_maximizing:\n            min_evals = min(min_evals, child_min)\n            max_evals = max(max_evals, child_max)\n        else:\n            max_evals += child_max\n            min_evals += child_min\n\n    visited_min[node] = min_evals\n    visited_max[node] = max_evals\n    return min_evals, max_evals\n\ndef calc_evaluations(n, edges):\n    children = [[] for _ in range(n)]\n    is_leaf = [True] * n\n\n    for u, v in edges:\n        children[u].append(v)\n        is_leaf[v] = False\n\n    root = is_leaf.index(False)\n\n    visited_min = [0] * n\n    visited_max = [0] * n\n\n    min_evals, max_evals = dfs(root, children, True, visited_min, visited_max)\n    return min_evals, max_evals\n\nn = int(input())\nedges = [tuple(map(int, input().split())) for _ in range(n - 1)]\nmin_evals, max_evals = calc_evaluations(n, edges)\nprint(min_evals, max_evals)",
    "timestamp": "2025-08-13 07:46:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GameTreeEvaluation {\n\n    static class Node {\n        int id;\n        int evaluation;\n        List<Node> children;\n        \n        Node(int id, int evaluation) {\n            this.id = id;\n            this.evaluation = evaluation;\n            this.children = new ArrayList<>();\n        }\n        \n        void addChild(Node child) {\n            children.add(child);\n        }\n    }\n\n    static int minEvalCount, maxEvalCount;\n\n    // DFS function with optimization for minimum evaluations\n    static int dfsMin(Node node) {\n        if (node.children.isEmpty()) { // Leaf node\n            minEvalCount++;\n            return node.evaluation;\n        }\n        \n        int maxChildEval = Integer.MIN_VALUE;\n        for (Node child : node.children) {\n            maxChildEval = Math.max(maxChildEval, dfsMin(child));\n        }\n        return -1 * maxChildEval;\n    }\n    \n    // DFS function with optimization for maximum evaluations\n    static int dfsMax(Node node) {\n        if (node.children.isEmpty()) { // Leaf node\n            maxEvalCount++;\n            return node.evaluation;\n        }\n        \n        int maxChildEval = Integer.MIN_VALUE;\n        for (Node child : node.children) {\n            maxChildEval = Math.max(maxChildEval, dfsMax(child));\n        }\n        return -1 * maxChildEval;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        // Read number of vertices\n        int n = scanner.nextInt();\n        \n        // Create nodes\n        Map<Integer, Node> nodes = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            int id = scanner.nextInt();\n            int evaluation = scanner.nextInt();\n            nodes.put(id, new Node(id, evaluation));\n        }\n        \n        // Read tree structure\n        for (int i = 0; i < n - 1; i++) {\n            int parent = scanner.nextInt();\n            int child = scanner.nextInt();\n            nodes.get(parent).addChild(nodes.get(child));\n        }\n        \n        // Assume the root has id 0\n        Node root = nodes.get(0);\n        \n        // Calculate minimum and maximum evaluations\n        minEvalCount = 0;\n        maxEvalCount = 0;\n        dfsMin(root);\n        maxEvalCount = minEvalCount; // Reset maxEvalCount for new calculation\n        dfsMax(root);\n        \n        // Output results\n        System.out.println(minEvalCount + \" \" + maxEvalCount);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 07:47:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 1000\n\ntypedef struct Node {\n    int isLeaf;\n    int evalValue;\n    int childCount;\n    int children[MAX_NODES];\n} Node;\n\nNode tree[MAX_NODES];\nint leafCount[MAX_NODES];\nint n;\n\nvoid dfs(int node) {\n    if (tree[node].isLeaf) {\n        leafCount[node] = 1;\n        return;\n    }\n    \n    int sum = 0;\n    for (int i = 0; i < tree[node].childCount; i++) {\n        int child = tree[node].children[i];\n        if (leafCount[child] == -1) {\n            dfs(child);\n        }\n        sum += leafCount[child];\n    }\n    \n    leafCount[node] = sum;\n}\n\nint findMinMaxEval(int node, int findMin) {\n    if (tree[node].isLeaf) {\n        return 1;\n    }\n    \n    int edgeEval[MAX_NODES];\n    for (int i = 0; i < tree[node].childCount; i++) {\n        int child = tree[node].children[i];\n        edgeEval[i] = leafCount[child];\n    }\n    \n    if (findMin) {\n        int sum = 0, max_eval = INT_MIN;\n        \n        for (int i = 0; i < tree[node].childCount; i++) {\n            int eval = edgeEval[i];\n            max_eval = (eval > max_eval) ? eval : max_eval;\n            sum += eval;\n        }\n        return sum - max_eval + 1;\n        \n    } else {\n        int sum = 0;\n        for (int i = 0; i < tree[node].childCount; i++) {\n            sum += edgeEval[i];\n        }\n        return sum;\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        leafCount[i] = -1;\n        int evalValue;\n        scanf(\"%d\", &tree[i].isLeaf);\n        if (!tree[i].isLeaf) {\n            scanf(\"%d\", &tree[i].childCount);\n            for (int j = 0; j < tree[i].childCount; j++) {\n                scanf(\"%d\", &tree[i].children[j]);\n            }\n        }\n    }\n\n    dfs(0);\n\n    int minEval = findMinMaxEval(0, 1);\n    int maxEval = findMinMaxEval(0, 0);\n    \n    printf(\"%d %d\\n\", minEval, maxEval);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 07:47:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_game_tree_evaluations(n, values, tree):\n    def min_max_evaluations(node, is_max_player):\n        if not tree[node]:  # Leaf node\n            return 1, 1\n        \n        min_evals, max_evals = 0, 0\n        best_value = float('-inf') if is_max_player else float('inf')\n        \n        child_min_evals = []\n        child_max_evals = []\n        \n        for child in tree[node]:\n            child_min, child_max = min_max_evaluations(child, not is_max_player)\n            child_min_evals.append(child_min)\n            child_max_evals.append(child_max)\n            \n            if is_max_player:\n                child_value = values[child]\n                if child_value > best_value:\n                    best_value = child_value\n            else:\n                child_value = values[child]\n                if child_value < best_value:\n                    best_value = child_value\n        \n        if is_max_player:\n            # Minimum evaluations: stop after finding first max child\n            min_evals = min(child_min_evals)\n            # Maximum evaluations: evaluate all children\n            max_evals = sum(child_max_evals)\n        else:\n            # Minimum evaluations: stop after finding first min child\n            min_evals = min(child_min_evals)\n            # Maximum evaluations: evaluate all children\n            max_evals = sum(child_max_evals)\n        \n        return min_evals, max_evals\n\n    # Start from root node (0) as max player\n    min_evaluations, max_evaluations = min_max_evaluations(0, True)\n    return min_evaluations, max_evaluations\n\n# Input parsing\nn = int(input())\nvalues = list(map(int, input().split()))\ntree = [[] for _ in range(n)]\n\n# Build tree structure\nfor _ in range(n - 1):\n    parent, child = map(int, input().split())\n    tree[parent].append(child)\n\n# Solve and output\nmin_evals, max_evals = solve_game_tree_evaluations(n, values, tree)\nprint(min_evals, max_evals)",
    "timestamp": "2025-08-13 07:47:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    n = int(sys.stdin.readline())\n    parent = list(map(int, sys.stdin.readline().split()))\n    is_leaf = [True] * n\n    for p in parent[1:]:\n        is_leaf[p] = False\n    \n    # Build the tree\n    tree = [[] for _ in range(n)]\n    for i in range(1, n):\n        tree[parent[i]].append(i)\n    \n    # We'll process nodes in post-order\n    post_order = []\n    stack = [(0, False)]\n    while stack:\n        node, visited = stack.pop()\n        if visited:\n            post_order.append(node)\n        else:\n            stack.append((node, True))\n            for child in reversed(tree[node]):\n                stack.append((child, False))\n    \n    min_eval = [0] * n\n    max_eval = [0] * n\n    leaf_count = [0] * n\n    \n    for node in post_order:\n        if is_leaf[node]:\n            min_eval[node] = 1\n            max_eval[node] = 1\n            leaf_count[node] = 1\n        else:\n            children = tree[node]\n            if not children:\n                continue\n            # For min_eval: sort children by min_eval (ascending for min, descending for max)\n            # For max_eval: sort children by max_eval (descending for min, ascending for max)\n            # The current node's min and max depend on the order of processing children\n            # For min_eval: we want to process children with smallest min_eval first (to minimize the total)\n            # For max_eval: we want to process children with largest max_eval first (to maximize the total)\n            # The actual evaluation count is the sum of all but the last child, plus the last child's count\n            # For min_eval: sum all min_eval except the largest, then add the largest\n            # For max_eval: sum all max_eval except the smallest, then add the smallest\n            min_children = []\n            max_children = []\n            total_leaves = 0\n            for child in children:\n                min_children.append(min_eval[child])\n                max_children.append(max_eval[child])\n                total_leaves += leaf_count[child]\n            \n            # Calculate min_eval[node]\n            if len(min_children) == 1:\n                min_eval[node] = min_children[0]\n            else:\n                min_children_sorted = sorted(min_children)\n                min_eval[node] = sum(min_children_sorted[:-1]) + 1\n            \n            # Calculate max_eval[node]\n            if len(max_children) == 1:\n                max_eval[node] = max_children[0]\n            else:\n                max_children_sorted = sorted(max_children, reverse=True)\n                max_eval[node] = sum(max_children_sorted[:-1]) + 1\n            \n            leaf_count[node] = total_leaves\n    \n    print(min_eval[0], max_eval[0])\n\nsolve()",
    "timestamp": "2025-08-13 07:47:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n    int value;\n    vector<int> children;\n};\n\nvoid dfs(int node, vector<Node>& tree, int& min_eval, int& max_eval, vector<bool>& visited) {\n    visited[node] = true;\n    if (tree[node].children.empty()) {\n        min_eval++;\n        max_eval++;\n        return;\n    }\n    \n    vector<int> child_explored;\n    for (int child : tree[node].children) {\n        if (!visited[child]) {\n            int min_child = 0, max_child = 0;\n            dfs(child, tree, min_child, max_child, visited);\n            child_explored.push_back(min_child);\n        }\n    }\n    \n    // Calculate the minimum evaluations by visiting the best child first\n    sort(child_explored.begin(), child_explored.end());\n    min_eval += child_explored.front();\n    \n    // Calculate the maximum evaluations by visiting the worst child first\n    if (!child_explored.empty()) {\n        sort(child_explored.rbegin(), child_explored.rend());\n        max_eval += child_explored.front();\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Node> tree(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> tree[i].value;\n    }\n    \n    for (int i = 0; i < n - 1; ++i) {\n        int parent, child;\n        cin >> parent >> child;\n        tree[parent].children.push_back(child);\n    }\n    \n    int min_eval = 0, max_eval = 0;\n    vector<bool> visited(n, false);\n    for (int i = 0; i < n; ++i) {\n        if (!visited[i]) {\n            dfs(i, tree, min_eval, max_eval, visited);\n        }\n    }\n    \n    cout << min_eval << \" \" << max_eval << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:40:48"
  }
]