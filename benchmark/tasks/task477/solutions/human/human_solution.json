[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Node {\n\tint value;\n\tvector<int>edges;\n\tNode() :value(0), edges() {\n\n\t}\n};\nstruct aa {\n\tint value;\n\tint amin;\n\tint amax;\n};\nmap<int, int>mp;\n\naa memo[100][202][202];\naa getans(const int now,const vector<Node>&ns,const int alp,const int bet) {\n\tif (memo[now][mp[alp]][mp[bet]].amax != -1)return memo[now][mp[alp]][mp[bet]];\n\telse {\n\t\tNode no(ns[now]);\n\t\tif (no.edges.empty())return memo[now][mp[alp]][mp[bet]]=aa{ ns[now].value,1,1 };\n\t\telse {\n\t\t\tint realvalue = -1e9;\n\t\t\t{\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[i], ns, -nbet, -nalp);\n\t\t\t\t\trealvalue = max(realvalue, -ans.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\taa ret{ realvalue,1e9,-1e9 };\n\t\t\tvector<int>perms(no.edges.size());\n\t\t\tiota(perms.begin(), perms.end(), 0);\n\t\t\tdo {\n\t\t\t\tint amintime = 0;\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tint amaxtime = 0;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[perms[i]], ns, -nbet, -nalp);\n\t\t\t\t\tamintime += ans.amin;\n\t\t\t\t\tamaxtime += ans.amax;\n\t\t\t\t\tif (-ans.value >= nbet) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (-ans.value > nalp) {\n\t\t\t\t\t\tnalp = -ans.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.amin = min(ret.amin, amintime);\n\t\t\t\tret.amax = max(ret.amax, amaxtime);\n\t\t\t} while (next_permutation(perms.begin(), perms.end()));\n\t\t\treturn memo[now][mp[alp]][mp[bet]]=ret;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < 100; ++i) {\n\t\tfor (int j = 0; j < 202; ++j) {\n\t\t\tfor (int k = 0; k < 202; ++k) {\n\t\t\t\tmemo[i][j][k] = aa{ -1,-1,-1 };\n\t\t\t}\n\t\t}\n\t}\n\tvector<Node>nodes(N);\n\tvector<int>nums;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\tnodes[i].value = a;\n\t\tnums.emplace_back(a);\n\t\tnums.emplace_back(-a);\n\t}\n\tnums.emplace_back(int(1e9));\n\tnums.emplace_back(int(-1e9));\n\tsort(nums.begin(), nums.end());\n\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tmp[nums[i]] = i;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tnodes[i].edges.push_back(a);\n\t\t}\n\t}\n\taa ans=getans(0, nodes, -1e9, 1e9);\n\tcout << ans.amin <<\" \"<< ans.amax<< endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109]; vector<int> G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, alpha, beta}] = 1;\n\t\tdp2[{pos, alpha, beta}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = 999999999, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, -beta2, -alpha2}];\n\t\t\tcnt_max += dp2[{chl, -beta2, -alpha2}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, alpha, beta}] = ret1;\n\tdp2[{pos, alpha, beta}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -999999999, 999999999);\n\tcout << dp1[{0, -999999999, 999999999}] << ' ' << dp2[{0, -999999999, 999999999}] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109]; vector<int> q, G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nint ptr(int x) {\n\treturn lower_bound(q.begin(), q.end(), x) - q.begin();\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, ptr(alpha), ptr(beta)}] = 1;\n\t\tdp2[{pos, ptr(alpha), ptr(beta)}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = n, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, ptr(-beta2), ptr(-alpha2)}];\n\t\t\tcnt_max += dp2[{chl, ptr(-beta2), ptr(-alpha2)}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, ptr(alpha), ptr(beta)}] = ret1;\n\tdp2[{pos, ptr(alpha), ptr(beta)}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tvector<int> q(2 * n);\n\tfor (int i = 0; i < n; i++) q[i] = p[i], q[n + i] = -p[i];\n\tq.push_back(-10001);\n\tq.push_back(10001);\n\tsort(q.begin(), q.end());\n\tq.erase(unique(q.begin(), q.end()), q.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -10001, 10001);\n\tcout << dp1[{0, -10001, 10001}] << ' ' << dp2[{0, -10001, 10001}] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nconst Int inf = 1LL<<55;\n\nInt n;\nInt p[111];\nvector<Int> graph[111];\n\nmap<Int, Int> mp;\n\nusing Pi = pair<Int, Int>;\n\nPi val[111][222][222];\nInt dp_min[111][222][222];\nInt dp_max[111][222][222];\nbool visited[111][222][222];\n\nPi dfs(Int v, Int a, Int b) {\n  if(visited[v][mp[a]][mp[b]]) return val[v][mp[a]][mp[b]];\n  visited[v][mp[a]][mp[b]] = true;  \n  if(graph[v].empty()) {\n    dp_min[v][mp[a]][mp[b]] = 1;\n    dp_max[v][mp[a]][mp[b]] = 1;\n    val[v][mp[a]][mp[b]] = Pi(p[v], p[v]);\n    //cout<<v<<\" \"<<val[v][mp[a]][mp[b]].first<<\" \"<<val[v][mp[a]][mp[b]].second<<endl;\n    return val[v][mp[a]][mp[b]];\n  }\n  val[v][mp[a]][mp[b]] = Pi(-inf, inf);\n  dp_min[v][mp[a]][mp[b]] = inf;\n  dp_max[v][mp[a]][mp[b]] = -inf;  \n  do {\n    Pi a_tmp = Pi(a, a), b_tmp = Pi(b, b);\n    Int mn = 0, mx = 0;\n    bool f_mn = true, f_mx = true;\n    for(Int u : graph[v]) {\n      if(f_mn) {\n\tInt x = -dfs(u, -b_tmp.first, -a_tmp.first).first;\n\tmn += dp_min[u][mp[-b_tmp.first]][mp[-a_tmp.first]];\n\tif(x >= b_tmp.first) {\n\t  a_tmp.first = x;\n\t  f_mn = false;\n\t} else if(x > a_tmp.first) {\n\t  a_tmp.first = x;\n\t}\n      }\n      if(f_mx) {\n\tInt x = -dfs(u, -b_tmp.second, -a_tmp.second).second;\n\tmx += dp_max[u][mp[-b_tmp.second]][mp[-a_tmp.second]];\t\n\tif(x >= b_tmp.second) {\n\t  a_tmp.second = x;\n\t  f_mx = false;\n\t} else if(x > a_tmp.second) {\n\t  a_tmp.second = x;\n\t}\n      }\n    }\n    if(dp_min[v][mp[a]][mp[b]] >= mn) {\n      dp_min[v][mp[a]][mp[b]] = mn;\n      val[v][mp[a]][mp[b]].first = max(val[v][mp[a]][mp[b]].first, a_tmp.first);\n    }\n    if(dp_max[v][mp[a]][mp[b]] <= mx) {\n      dp_max[v][mp[a]][mp[b]] = mx;\n      val[v][mp[a]][mp[b]].second = min(val[v][mp[a]][mp[b]].second, a_tmp.second);\n    }\n  }while(next_permutation(graph[v].begin(), graph[v].end()));\n  //cout<<v<<\" \"<<val[v][mp[a]][mp[b]].first << \" \" << val[v][mp[a]][mp[b]].second << endl;\n  //assert(val[v][mp[a]][mp[b]].first == val[v][mp[a]][mp[b]].second); \n  return val[v][mp[a]][mp[b]];\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  cin >> n;\n  for(Int i = 0; i < n; ++i) cin >> p[i];\n  for(Int i = 0; i < n; ++i) {\n    Int k; cin >> k;\n    for(Int j = 0; j < k; ++j) {\n      Int t; cin >> t; --t;\n      graph[i].push_back(t);\n    }\n    sort(graph[i].begin(), graph[i].end());\n  }\n  vector<Int> vec;\n  vec.push_back(-inf);\n  vec.push_back(inf);\n  for(Int i = 0; i < n; ++i) {\n    vec.push_back(p[i]);\n    vec.push_back(-p[i]);\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n  for(Int i = 0; i < n; ++i) {\n    mp[p[i]] = lower_bound(vec.begin(), vec.end(), p[i])-vec.begin();\n    mp[-p[i]] = lower_bound(vec.begin(), vec.end(), -p[i])-vec.begin();\n  }\n  memset(visited, false, sizeof(visited));\n  dfs(0, -inf, inf);\n  cout << dp_min[0][mp[-inf]][mp[inf]] << \" \" << dp_max[0][mp[-inf]][mp[inf]] << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Node {\n\tint value;\n\tvector<int>edges;\n\tNode() :value(0), edges() {\n\n\t}\n};\nstruct aa {\n\tint value;\n\tint amin;\n\tint amax;\n};\nmap<int, int>mp;\n\naa memo[100][202][202];\naa getans(const int now,const vector<Node>&ns,const int alp,const int bet) {\n\tif (memo[now][mp[alp]][mp[bet]].amax != -1)return memo[now][mp[alp]][mp[bet]];\n\telse {\n\t\tNode no(ns[now]);\n\t\tif (no.edges.empty())return memo[now][mp[alp]][mp[bet]]=aa{ ns[now].value,1,1 };\n\t\telse {\n\t\t\tint realvalue = -1e9;\n\t\t\t{\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[i], ns, -nbet, -nalp);\n\t\t\t\t\trealvalue = max(realvalue, -ans.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\taa ret{ realvalue,1e9,-1e9 };\n\t\t\tvector<int>perms(no.edges.size());\n\t\t\tiota(perms.begin(), perms.end(), 0);\n\t\t\tdo {\n\t\t\t\tint amintime = 0;\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tint amaxtime = 0;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[perms[i]], ns, -nbet, -nalp);\n\t\t\t\t\tamintime += ans.amin;\n\t\t\t\t\tamaxtime += ans.amax;\n\t\t\t\t\tif (-ans.value >= nbet) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (-ans.value > nalp) {\n\t\t\t\t\t\tnalp = -ans.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.amin = min(ret.amin, amintime);\n\t\t\t\tret.amax = max(ret.amax, amaxtime);\n\t\t\t} while (next_permutation(perms.begin(), perms.end()));\n\t\t\treturn memo[now][mp[alp]][mp[bet]]=ret;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < 100; ++i) {\n\t\tfor (int j = 0; j < 202; ++j) {\n\t\t\tfor (int k = 0; k < 202; ++k) {\n\t\t\t\tmemo[i][j][k] = aa{ -1,-1,-1 };\n\t\t\t}\n\t\t}\n\t}\n\tvector<Node>nodes(N);\n\tvector<int>nums;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\tnodes[i].value = a;\n\t\tnums.emplace_back(a);\n\t\tnums.emplace_back(-a);\n\t}\n\tnums.emplace_back(int(1e9));\n\tnums.emplace_back(int(-1e9));\n\tsort(nums.begin(), nums.end());\n\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tmp[nums[i]] = i;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tnodes[i].edges.push_back(a);\n\t\t}\n\t}\n\taa ans=getans(0, nodes, int(-1e9), int(1e9));\n\tcout << ans.amin <<\" \"<< ans.amax<< endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109]; vector<int> G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, alpha, beta}] = 1;\n\t\tdp2[{pos, alpha, beta}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = 999999999, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, -beta2, -alpha2}];\n\t\t\tcnt_max += dp2[{chl, -beta2, -alpha2}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, alpha, beta}] = ret1;\n\tdp2[{pos, alpha, beta}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tvector<int> q;\n\tfor (int i = 0; i < n; i++) cin >> p[i], q.push_back(p[i]);\n\tsort(q.begin(), q.end());\n\tq.erase(unique(q.begin(), q.end()), q.end());\n\tfor (int i = 0; i < n; i++) p[i] = lower_bound(q.begin(), q.end(), p[i]) - q.begin() + 1;\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, 0, q.size() + 1);\n\tcout << dp1[{0, 0, (int)q.size() + 1}] << ' ' << dp2[{0, 0, (int)q.size() + 1}] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nconst int inf = 1e9;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n    auto val = table(args...);\n    return std::vector<decltype(val)>(n, std::move(val));\n}\n\nint main() {\n    int n; cin >> n;\n    vector<int> p(n), vs = {-inf, inf};\n    for(auto& x : p) {\n        cin >> x;\n        vs.push_back(x);\n        vs.push_back(-x);\n    }\n    sort(begin(vs), end(vs));\n    vs.erase(unique(begin(vs), end(vs)), end(vs));\n    auto get_idx = [&] (int val) -> int {\n        return lower_bound(begin(vs), end(vs), val) - begin(vs);\n    };\n    vector<vector<int>> g(n);\n    for(int i = 0; i < n; ++i) {\n        int k; cin >> k;\n        g[i].resize(k);\n        for(auto& c : g[i]) {\n            cin >> c;\n            c--;\n        }\n    }\n\n    auto max_dp = table(n, vs.size(), vs.size(), make_pair(-inf, 0));\n    auto min_dp = table(n, vs.size(), vs.size(), make_pair(inf, 0));\n    function<pii(int, int, int, bool)> dfs = [&] (int v, int alpha, int beta, bool is_min) {\n        if(g[v].empty()) return make_pair(1, p[v]); // leaf\n\n        auto& res = (is_min ? min_dp[v][alpha][beta] : max_dp[v][alpha][beta]);\n        if(abs(res.first) != inf) return res;\n\n        sort(begin(g[v]), end(g[v]));\n        do {\n            int talpha = alpha;\n            pii cur = make_pair(0, -inf);\n            for(auto const ch : g[v]) {\n                auto val = dfs(ch, get_idx(-vs[beta]), get_idx(-vs[talpha]), is_min);\n                val.second = -val.second;\n                cur.first += val.first;\n                if(val.second >= vs[beta]) {\n                    cur.second = val.second;\n                    break;\n                }\n                if(val.second > vs[talpha]) {\n                    talpha = get_idx(val.second);\n                }\n            }\n            if(cur.second == -inf) { // not occured val.second >= beta\n                cur.second = vs[talpha];\n            }\n            if(is_min) res = min(res, cur);\n            else       res = max(res, cur);\n        } while(next_permutation(begin(g[v]), end(g[v])));\n\n        return res;\n    };\n\n    cout << dfs(0, 0, vs.size() - 1, true).first << \" \" << dfs(0, 0, vs.size() - 1, false).first << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nvector<int>g[210];\nint p[210];\nint z[210];\nint v[110][210][210];\nint val[110][210][210];\nint sz=0;\nint dp[2][110][210][210];\nint con[31000];\nint A=15000;\nint calc(int at,int l,int r,int dep){\n\tif(v[at][l][r])return val[at][l][r];\n\tif(g[at].size()==0){\n\t\tdp[0][at][l][r]=dp[1][at][l][r]=1;\n\t\treturn val[at][l][r]=p[at]*dep;\n\t}\n\tint perm[10];\n\tfor(int i=0;i<g[at].size();i++){\n\t\tperm[i]=i;\n\t}\n\tint len=g[at].size();\n\tint best=z[0];\n\tfor(int i=0;i<len;i++){\n\t\tbest=max(best,-calc(g[at][i],0,sz-1,dep));\n\t}\n\tval[at][l][r]=best;\n\tint r1=9999999;\n\tint r2=0;\n\tdo{\n\t\tint t1=0;\n\t\tint t2=0;\n\t\tint va=z[l];\n\t\tint vb=z[r];\n\t\tfor(int i=0;i<len;i++){\n\t\t\tint tmp=-calc(g[at][perm[i]],con[A-vb],con[A-va],dep);\n\t\t\tt1+=dp[0][g[at][perm[i]]][con[A-vb]][con[A-va]];\n\t\t\tt2+=dp[1][g[at][perm[i]]][con[A-vb]][con[A-va]];\n\t\t\tif(tmp>va){\n\t\t\t\tva=tmp;\n\t\t\t}\n\t\t\tif(va>=vb)break;\n\t\t}\n\t\tr1=min(r1,t1);\n\t\tr2=max(r2,t2);\n\t}while(next_permutation(perm,perm+len));\n\tdp[0][at][l][r]=r1;\n\tdp[1][at][l][r]=r2;\n\tv[at][l][r]=1;\n\treturn val[at][l][r];\n}\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%d\",p+i);\n\tfor(int i=0;i<a;i++){\n\t\tint b;scanf(\"%d\",&b);\n\t\tfor(int j=0;j<b;j++){\n\t\t\tint c;scanf(\"%d\",&c);c--;\n\t\t\tg[i].push_back(c);\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tz[sz++]=p[i];\n\t\tz[sz++]=-p[i];\n\t}\n\tz[sz++]=11111;\n\tz[sz++]=-11111;\n\tstd::sort(z,z+sz);\n\tfor(int i=0;i<sz;i++){\n\t\tcon[z[i]+A]=i;\n\t}\n\tfor(int i=0;i<a;i++)for(int j=0;j<sz;j++)for(int k=0;k<sz;k++){\n\t\tdp[0][i][j][k]=dp[1][i][j][k]=-1;\n\t}\n\tcalc(0,0,sz-1,1);\n\t//for(int i=0;i<a;i++)printf(\"%d\\n\",val[i][0][sz-1]);\n\tprintf(\"%d %d\\n\",dp[0][0][0][sz-1],dp[1][0][0][sz-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Node {\n\tint value;\n\tvector<int>edges;\n\tNode() :value(0), edges() {\n\n\t}\n};\nstruct aa {\n\tint value;\n\tint amin;\n\tint amax;\n};\nmap<int, int>mp;\n\naa memo[100][202][202];\naa getans(const int now,const vector<Node>&ns,const int alp,const int bet) {\n\tif (memo[now][mp[alp]][mp[bet]].amax != -1)return memo[now][mp[alp]][mp[bet]];\n\telse {\n\t\tNode no(ns[now]);\n\t\tif (no.edges.empty())return memo[now][mp[alp]][mp[bet]]=aa{ ns[now].value,1,1 };\n\t\telse {\n\t\t\tint realvalue = -1e9;\n\t\t\t{\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[i], ns, -nbet, -nalp);\n\t\t\t\t\trealvalue = max(realvalue, -ans.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\taa ret{ realvalue,1e9,-1e9 };\n\t\t\tvector<int>perms(no.edges.size());\n\t\t\tiota(perms.begin(), perms.end(), 0);\n\t\t\tdo {\n\t\t\t\tint amintime = 0;\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tint amaxtime = 0;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[perms[i]], ns, -nbet, -nalp);\n\t\t\t\t\tamintime += ans.amin;\n\t\t\t\t\tamaxtime += ans.amax;\n\t\t\t\t\tif (-ans.value >= nbet) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (-ans.value > nalp) {\n\t\t\t\t\t\tnalp = -ans.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.amin = min(ret.amin, amintime);\n\t\t\t\tret.amax = max(ret.amax, amaxtime);\n\t\t\t} while (next_permutation(perms.begin(), perms.end()));\n\t\t\treturn memo[now][mp[alp]][mp[bet]]=ret;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < 100; ++i) {\n\t\tfor (int j = 0; j < 202; ++j) {\n\t\t\tfor (int k = 0; k < 202; ++k) {\n\t\t\t\tmemo[i][j][k] = aa{ -1,-1,-1 };\n\t\t\t}\n\t\t}\n\t}\n\tvector<Node>nodes(N);\n\tvector<int>nums;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\tnodes[i].value = a;\n\t\tnums.emplace_back(a);\n\t\tnums.emplace_back(-a);\n\t}\n\tnums.emplace_back(int(1e9));\n\tnums.emplace_back(int(-1e9));\n\tsort(nums.begin(), nums.end());\n\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tmp[nums[i]] = i;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tnodes[i].edges.push_back(a);\n\t\t}\n\t}\n\taa ans=getans(0, nodes, int(-1e9), int(1e9));\n\tcout << ans.amin <<\" \"<< ans.amax<< endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nconst Int inf = 1LL<<55;\n\nInt n;\nInt p[111];\nvector<Int> graph[111];\n\nmap<Int, Int> mp;\n\nusing Pi = pair<Int, Int>;\n\nPi val[111][222][222];\nInt dp_min[111][222][222];\nInt dp_max[111][222][222];\nbool visited[111][222][222];\n\nPi dfs(Int v, Int a, Int b) {\n  if(visited[v][mp[a]][mp[b]]) return val[v][mp[a]][mp[b]];\n  visited[v][mp[a]][mp[b]] = true;  \n  if(graph[v].empty()) {\n    dp_min[v][mp[a]][mp[b]] = 1;\n    dp_max[v][mp[a]][mp[b]] = 1;\n    val[v][mp[a]][mp[b]] = Pi(p[v], p[v]);\n    //cout<<v<<\" \"<<val[v][mp[a]][mp[b]].first<<\" \"<<val[v][mp[a]][mp[b]].second<<endl;\n    return val[v][mp[a]][mp[b]];\n  }\n  val[v][mp[a]][mp[b]] = Pi(-inf, inf);\n  dp_min[v][mp[a]][mp[b]] = inf;\n  dp_max[v][mp[a]][mp[b]] = -inf;  \n  do {\n    Pi a_tmp = Pi(a, a), b_tmp = Pi(b, b);\n    Int mn = 0, mx = 0;\n    bool f_mn = true, f_mx = true;\n    for(Int u : graph[v]) {\n      if(f_mn) {\n\tInt x = -dfs(u, -b_tmp.first, -a_tmp.first).first;\n\tmn += dp_min[u][mp[-b_tmp.first]][mp[-a_tmp.first]];\n\tif(x >= b_tmp.first) {\n\t  a_tmp.first = x;\n\t  f_mn = false;\n\t} else if(x > a_tmp.first) {\n\t  a_tmp.first = x;\n\t}\n      }\n      if(f_mx) {\n\tInt x = -dfs(u, -b_tmp.second, -a_tmp.second).second;\n\tmx += dp_max[u][mp[-b_tmp.second]][mp[-a_tmp.second]];\t\n\tif(x >= b_tmp.second) {\n\t  a_tmp.second = x;\n\t  f_mx = false;\n\t} else if(x > a_tmp.second) {\n\t  a_tmp.second = x;\n\t}\n      }\n    }\n    if(dp_min[v][mp[a]][mp[b]] >= mn) {\n      dp_min[v][mp[a]][mp[b]] = mn;\n      val[v][mp[a]][mp[b]].first = max(val[v][mp[a]][mp[b]].first, a_tmp.first);\n    }\n    if(dp_max[v][mp[a]][mp[b]] <= mx) {\n      dp_max[v][mp[a]][mp[b]] = mx;\n      val[v][mp[a]][mp[b]].second = min(val[v][mp[a]][mp[b]].second, a_tmp.second);\n    }\n  }while(next_permutation(graph[v].begin(), graph[v].end()));\n  //cout<<v<<\" \"<<val[v][mp[a]][mp[b]].first << \" \" << val[v][mp[a]][mp[b]].second << endl;\n  //assert(val[v][mp[a]][mp[b]].first == val[v][mp[a]][mp[b]].second); \n  return val[v][mp[a]][mp[b]];\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  cin >> n;\n  for(Int i = 0; i < n; ++i) cin >> p[i];\n  for(Int i = 0; i < n; ++i) {\n    Int k; cin >> k;\n    for(Int j = 0; j < k; ++j) {\n      Int t; cin >> t; --t;\n      graph[i].push_back(t);\n    }\n    sort(graph[i].begin(), graph[i].end());\n  }\n  vector<Int> vec;\n  vec.push_back(-inf);\n  vec.push_back(inf);\n  for(Int i = 0; i < n; ++i) {\n    vec.push_back(p[i]);\n    vec.push_back(-p[i]);\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n  for(Int i = 0; i < n; ++i) {\n    mp[p[i]] = lower_bound(vec.begin(), vec.end(), p[i])-vec.begin();\n    mp[-p[i]] = lower_bound(vec.begin(), vec.end(), -p[i])-vec.begin();\n  }\n  memset(visited, false, sizeof(visited));\n  dfs(0, -inf, inf);\n  cout << dp_min[0][mp[-inf]][mp[inf]] << \" \" << dp_max[0][mp[-inf]][mp[inf]] << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109], dp1[109][209][209], dp2[109][209][209], ptr[20009]; vector<int> q, G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = 1;\n\t\tdp2[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = n, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[chl][ptr[-beta2 + 10001]][ptr[-alpha2 + 10001]];\n\t\t\tcnt_max += dp2[chl][ptr[-beta2 + 10001]][ptr[-alpha2 + 10001]];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = ret1;\n\tdp2[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tq.resize(2 * n);\n\tfor (int i = 0; i < n; i++) q[i] = p[i], q[n + i] = -p[i];\n\tq.push_back(-10001);\n\tq.push_back(10001);\n\tsort(q.begin(), q.end());\n\tq.erase(unique(q.begin(), q.end()), q.end());\n\tfor (int i = 0; i < q.size(); i++) ptr[q[i] + 10001] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -10001, 10001);\n\tcout << dp1[0][0][q.size() - 1] << ' ' << dp2[0][0][q.size() - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=(int)(a)-1;i>=(int)(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \n// #define DEBUG\n \n#ifdef DEBUG\n    #define dump(...) fprintf(stderr, __VA_ARGS__)\n#else\n    #define dump(...)\n#endif\n \ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n \nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vll=vector<ll>;\n \nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int inf =1 << 30;\nconst ll mod=1000000007LL;\nconst int dx[4]={1,0,-1,0};\nconst int dy[4]={0,1,0,-1};\n \n \nll extgcd(ll a,ll b,ll& x,ll& y){x=1,y=0;ll g=a;if(b!=0) g=extgcd(b,a%b,y,x),y-=a/b*x;return g;}\nll ADD(const ll &a, const ll &b,const ll &mod) { return (a+b)%mod;}\nll SUB(const ll &a, const ll &b,const ll &mod) { return (a-b+mod)%mod;}\nll MUL(const ll &a, const ll &b,const ll &mod) { return (1LL*a*b)%mod;}\nll DIV(const ll &a, const ll &b,const ll &mod) {ll x,y; extgcd(b,mod,x,y);return MUL(a,(x+mod)%mod,mod);}\n \nrandom_device rd;\nmt19937 mt(rd());\nuniform_int_distribution<int> dice(1,6);\nuniform_real_distribution<double> score(0.0,10.0);\n\nint n, m;\nvi eval;\nvector<vi> G;\nvector<vector<vi>> min_num, max_num, memo;\nvi scores;\nmap<int, int> s2i;\n\nint negamax(int v, int alpha, int beta){\n    int& mi  = min_num[v][s2i[alpha]][s2i[beta]];\n    int& ma  = max_num[v][s2i[alpha]][s2i[beta]];\n    int& ret = memo   [v][s2i[alpha]][s2i[beta]];\n    if(ma != -1){\n        return ret;\n    }\n\n    int nc = G[v].size();\n\n    // leaf\n    if(nc == 0){\n        mi = 1;\n        ma = 1;\n        return ret = eval[v];\n    }\n\n    // internal\n    vi perm(nc); rep(i, nc) perm[i] = i;\n    do {\n        int alpha_org = alpha;\n        int beta_org  = beta;\n        \n        int curmi = 0, curma = 0;\n        rep(i, nc){\n            int nv = G[v][perm[i]];\n            int val = -negamax(nv, -beta, -alpha);\n            curmi += min_num[nv][s2i[-beta]][s2i[-alpha]];\n            curma += max_num[nv][s2i[-beta]][s2i[-alpha]];\n\n            if(val >= beta){\n                ret = val;\n                break;\n            }\n            chmax(alpha, val);\n            ret = alpha;\n        }\n        chmin(mi, curmi);\n        chmax(ma, curma);\n\n        alpha = alpha_org;\n        beta  = beta_org;\n    } while(next_permutation(_all(perm)));\n\n    return ret;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    eval = vi(n); for(auto& e : eval) cin >> e;\n    G = vector<vi>(n);\n    scores = {-inf, inf};\n    rep(v, n){\n        int k; cin >> k;\n        rep(loop, k){\n            int u; cin >> u; u--;\n            G[v].emplace_back(u);\n        }\n        if(k == 0){\n            scores.emplace_back(eval[v]);\n            scores.emplace_back(-eval[v]);\n        }\n    }\n    sort(_all(scores));\n    scores.erase(unique(_all(scores)), end(scores));\n    m = scores.size();\n    rep(i, m) s2i[scores[i]] = i;\n\n    min_num = vector<vector<vi>>(n, vector<vi>(m, vi(m, inf)));\n    max_num = vector<vector<vi>>(n, vector<vi>(m, vi(m, -1)));\n    memo    = vector<vector<vi>>(n, vector<vi>(m, vi(m, -inf)));\n\n    negamax(0, -inf, inf);\n    cout << min_num[0][0][m-1] << \" \" << max_num[0][0][m-1] << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109]; vector<int> G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, alpha, beta}] = 1;\n\t\tdp2[{pos, alpha, beta}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = n, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, -beta2, -alpha2}];\n\t\t\tcnt_max += dp2[{chl, -beta2, -alpha2}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, alpha, beta}] = ret1;\n\tdp2[{pos, alpha, beta}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -10001, 10001);\n\tcout << dp1[{0, -10001, 10001}] << ' ' << dp2[{0, -10001, 10001}] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109], dp1[109][209][209], dp2[109][209][209]; vector<int> q, G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nint ptr(int x) {\n\treturn lower_bound(q.begin(), q.end(), x) - q.begin();\n}\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[pos][ptr(alpha)][ptr(beta)] = 1;\n\t\tdp2[pos][ptr(alpha)][ptr(beta)] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = n, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[chl][ptr(-beta2)][ptr(-alpha2)];\n\t\t\tcnt_max += dp2[chl][ptr(-beta2)][ptr(-alpha2)];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[pos][ptr(alpha)][ptr(beta)] = ret1;\n\tdp2[pos][ptr(alpha)][ptr(beta)] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tq.resize(2 * n);\n\tfor (int i = 0; i < n; i++) q[i] = p[i], q[n + i] = -p[i];\n\tq.push_back(-10001);\n\tq.push_back(10001);\n\tsort(q.begin(), q.end());\n\tq.erase(unique(q.begin(), q.end()), q.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -10001, 10001);\n\tcout << dp1[0][0][q.size() - 1] << ' ' << dp2[0][0][q.size() - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nconst Int inf = 1LL<<55;\n\nInt n;\nInt p[101];\nvector<Int> graph[101];\n\nunordered_map<Int, Int> mp;\n\nusing Pi = pair<Int, Int>;\n\nPi val[101][202][202];\nInt dp_min[101][202][202];\nInt dp_max[101][202][202];\nbool visited[101][202][202];\n\nPi dfs(Int v, Int a, Int b) {\n  if(visited[v][mp[a]][mp[b]]) return val[v][mp[a]][mp[b]];\n  visited[v][mp[a]][mp[b]] = true;  \n  if(graph[v].empty()) {\n    dp_min[v][mp[a]][mp[b]] = 1;\n    dp_max[v][mp[a]][mp[b]] = 1;\n    val[v][mp[a]][mp[b]] = Pi(p[v], p[v]);\n    return val[v][mp[a]][mp[b]];\n  }\n  val[v][mp[a]][mp[b]] = Pi(-inf, inf);\n  dp_min[v][mp[a]][mp[b]] = inf;\n  dp_max[v][mp[a]][mp[b]] = -inf;  \n  do {\n    Pi a_tmp = Pi(a, a), b_tmp = Pi(b, b);\n    Int mn = 0, mx = 0;\n    bool f_mn = true, f_mx = true;\n    for(Int u : graph[v]) {\n      if(f_mn) {\n\tInt x = -dfs(u, -b_tmp.first, -a_tmp.first).first;\n\t//cout<<u<<\" \"<<x<<endl;\n\tmn += dp_min[u][mp[-b_tmp.first]][mp[-a_tmp.first]];\n\tif(x >= b_tmp.first) {\n\t  a_tmp.first = x;\n\t  f_mn = false;\n\t} else if(x > a_tmp.first) {\n\t  a_tmp.first = x;\n\t}\n      }\n      if(f_mx) {\n\tInt x = -dfs(u, -b_tmp.second, -a_tmp.second).second;\n\t//cout<<u<<\" \"<<x<<endl;\t\n\tmx += dp_max[u][mp[-b_tmp.second]][mp[-a_tmp.second]];\t\n\tif(x >= b_tmp.second) {\n\t  a_tmp.second = x;\n\t  f_mx = false;\n\t} else if(x > a_tmp.second) {\n\t  a_tmp.second = x;\n\t}\n      }\n    }\n    if(dp_min[v][mp[a]][mp[b]] >= mn) {\n      dp_min[v][mp[a]][mp[b]] = mn;\n      val[v][mp[a]][mp[b]].first = max(val[v][mp[a]][mp[b]].first, a_tmp.first);\n    }\n    if(dp_max[v][mp[a]][mp[b]] <= mx) {\n      dp_max[v][mp[a]][mp[b]] = mx;\n      val[v][mp[a]][mp[b]].second = min(val[v][mp[b]][mp[b]].second, a_tmp.second);\n    }\n  }while(next_permutation(graph[v].begin(), graph[v].end()));\n  //cout<<val[v][mp[a]][mp[b]].first << \" \" << val[v][mp[a]][mp[b]].second << endl;\n  return val[v][mp[a]][mp[b]];\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  cin >> n;\n  for(Int i = 0; i < n; ++i) cin >> p[i];\n  for(Int i = 0; i < n; ++i) {\n    Int k; cin >> k;\n    for(Int j = 0; j < k; ++j) {\n      Int t; cin >> t; --t;\n      graph[i].push_back(t);\n    }\n    sort(graph[i].begin(), graph[i].end());\n  }\n  vector<Int> vec;\n  vec.push_back(-inf);\n  vec.push_back(inf);\n  for(Int i = 0; i < n; ++i) {\n    vec.push_back(p[i]);\n    vec.push_back(-p[i]);\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n  for(Int i = 0; i < n; ++i) {\n    mp[p[i]] = lower_bound(vec.begin(), vec.end(), p[i])-vec.begin();\n    mp[-p[i]] = lower_bound(vec.begin(), vec.end(), -p[i])-vec.begin();\n  }\n  memset(visited, false, sizeof(visited));\n  dfs(0, -inf, inf);\n  cout << dp_min[0][mp[-inf]][mp[inf]] << \" \" << dp_max[0][mp[-inf]][mp[inf]] << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109], dp1[109][209][209], dp2[109][209][209], ptr[20009]; bool vis[109][209][209]; vector<int> q, G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = 1;\n\t\tdp2[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = 1;\n\t\treturn;\n\t}\n\tif (vis[pos][ptr[alpha + 10001]][ptr[beta + 10001]]) return;\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = n, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[chl][ptr[-beta2 + 10001]][ptr[-alpha2 + 10001]];\n\t\t\tcnt_max += dp2[chl][ptr[-beta2 + 10001]][ptr[-alpha2 + 10001]];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tvis[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = true;\n\tdp1[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = ret1;\n\tdp2[pos][ptr[alpha + 10001]][ptr[beta + 10001]] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tq.resize(2 * n);\n\tfor (int i = 0; i < n; i++) q[i] = p[i], q[n + i] = -p[i];\n\tq.push_back(-10001);\n\tq.push_back(10001);\n\tsort(q.begin(), q.end());\n\tq.erase(unique(q.begin(), q.end()), q.end());\n\tfor (int i = 0; i < q.size(); i++) ptr[q[i] + 10001] = i;\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -10001, 10001);\n\tcout << dp1[0][0][q.size() - 1] << ' ' << dp2[0][0][q.size() - 1] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint n, p[109]; vector<int> G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, alpha, beta}] = 1;\n\t\tdp2[{pos, alpha, beta}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = 999999999, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, -beta2, -alpha2}];\n\t\t\tcnt_max += dp2[{chl, -beta2, -alpha2}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, alpha, beta}] = ret1;\n\tdp2[{pos, alpha, beta}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -999999999, 999999999);\n\tcout << dp1[{0, -999999999, 999999999}] << ' ' << dp2[{0, -999999999, 999999999}];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109]; vector<int> q, G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nint ptr(int x) {\n\treturn lower_bound(q.begin(), q.end(), x) - q.begin();\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, ptr(alpha), ptr(beta)}] = 1;\n\t\tdp2[{pos, ptr(alpha), ptr(beta)}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = n, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, ptr(-beta2), ptr(-alpha2)}];\n\t\t\tcnt_max += dp2[{chl, ptr(-beta2), ptr(-alpha2)}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, ptr(alpha), ptr(beta)}] = ret1;\n\tdp2[{pos, ptr(alpha), ptr(beta)}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tq.resize(2 * n);\n\tfor (int i = 0; i < n; i++) q[i] = p[i], q[n + i] = -p[i];\n\tq.push_back(-10001);\n\tq.push_back(10001);\n\tsort(q.begin(), q.end());\n\tq.erase(unique(q.begin(), q.end()), q.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -10001, 10001);\n\tcout << dp1[{0, 0, (int)q.size() - 1}] << ' ' << dp2[{0, 0, (int)q.size() - 1}] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=998244353 ;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//結局、メモ化すれば大丈夫\nvector<vector<int>>ko;\nvector<int>p;\nmap<tuple<int,int,int>,tuple<int,int,int>>memo;\ntuple<int,int,int> solve(int ter,int A,int B){\n\tif(ko[ter].size()==0){return mt(p[ter],1,1);}\n\tif(memo.count(mt(ter,A,B))){return memo[mt(ter,A,B)];}\n\tSO(ko[ter]);\n\tint syo=mod,dai=0;\n\tint ret=-mod;\n\tdo{\n\t\tint nA=A;\n\t\tint gs=0,gd=0;\n\t\tfor(auto it:ko[ter]){\n\t\t\tint val,ss,sd;\n\t\t\ttie(val,ss,sd)=solve(it,-B,-nA);\n\t\t\tgs+=ss;gd+=sd;val*=-1;\n\t\t\tif(val>=B){nA=val;break;}\n\t\t\tmaxeq(nA,val);\n\t\t}\n\t\t//if(ret!=nA&&ret!=-mod&&nA<B){cerr<<\"bag\"<<ret<<\" \"<<ter<<endl;}\n\t\tret=nA;\n\t\tmineq(syo,gs);\n\t\tmaxeq(dai,gd);\n\t}while(next_permutation(ko[ter].begin(),ko[ter].end()));\n\tmemo[mt(ter,A,B)]=mt(ret,syo,dai);\n\treturn mt(ret,syo,dai);\n}\nint main(void){\n\tint n,i,j;cin>>n;\n\tp.res(n);\n\tko.res(n);\n\tfor(i=0;i<n;i++){cin>>p[i];}\n\tfor(i=0;i<n;i++){\n\t\tint d;cin>>d;\n\t\twhile(d--){\n\t\t\tint c;cin>>c;c--;\n\t\t\tko[i].pub(c);\n\t\t}\n\t}\n\tint ret,syo,dai;\n\ttie(ret,syo,dai)=solve(0,-10001,10001);\n\tcout<<syo<<\" \"<<dai<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, p[109]; vector<int> G[109];\nvoid calc_evaluation(int pos) {\n\tif (G[pos].size() == 0) return;\n\tp[pos] = -999999999;\n\tfor (int i : G[pos]) {\n\t\tcalc_evaluation(i);\n\t\tp[pos] = max(p[pos], -p[i]);\n\t}\n}\nmap<vector<int>, int> dp1, dp2;\nvoid solve(int pos, int alpha, int beta) {\n\tif (G[pos].size() == 0) {\n\t\tdp1[{pos, alpha, beta}] = 1;\n\t\tdp2[{pos, alpha, beta}] = 1;\n\t\treturn;\n\t}\n\tvector<int> perm(G[pos].size());\n\tfor (int i = 0; i < perm.size(); i++) perm[i] = i;\n\tint ret1 = 999999999, ret2 = 0;\n\tdo {\n\t\tint alpha2 = alpha, beta2 = beta, cnt_min = 0, cnt_max = 0;\n\t\tfor (int i = 0; i < perm.size(); i++) {\n\t\t\tint chl = G[pos][perm[i]];\n\t\t\tint val = -p[chl];\n\t\t\tsolve(chl, -beta2, -alpha2);\n\t\t\tcnt_min += dp1[{chl, -beta2, -alpha2}];\n\t\t\tcnt_max += dp2[{chl, -beta2, -alpha2}];\n\t\t\tif (val >= beta2) break;\n\t\t\talpha2 = max(val, alpha2);\n\t\t}\n\t\tret1 = min(ret1, cnt_min);\n\t\tret2 = max(ret2, cnt_max);\n\t} while (next_permutation(perm.begin(), perm.end()));\n\tdp1[{pos, alpha, beta}] = ret1;\n\tdp2[{pos, alpha, beta}] = ret2;\n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) cin >> p[i];\n\tfor (int i = 0; i < n; i++) {\n\t\tint c, x; cin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> x; x--;\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tcalc_evaluation(0);\n\tsolve(0, -999999999, 999999999);\n\tcout << dp1[{0, -999999999, 999999999}] << ' ' << dp2[{0, -999999999, 999999999}];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nconst Int inf = 1LL<<55;\n\nInt n;\nInt p[111];\nvector<Int> graph[111];\n\nunordered_map<Int, Int> mp;\n\nusing Pi = pair<Int, Int>;\n\nPi val[111][222][222];\nInt dp_min[111][222][222];\nInt dp_max[111][222][222];\nbool visited[111][222][222];\n\nPi dfs(Int v, Int a, Int b) {\n  if(visited[v][mp[a]][mp[b]]) return val[v][mp[a]][mp[b]];\n  visited[v][mp[a]][mp[b]] = true;  \n  if(graph[v].empty()) {\n    dp_min[v][mp[a]][mp[b]] = 1;\n    dp_max[v][mp[a]][mp[b]] = 1;\n    val[v][mp[a]][mp[b]] = Pi(p[v], p[v]);\n    //cout<<v<<\" \"<<val[v][mp[a]][mp[b]].first<<\" \"<<val[v][mp[a]][mp[b]].second<<endl;\n    return val[v][mp[a]][mp[b]];\n  }\n  val[v][mp[a]][mp[b]] = Pi(-inf, inf);\n  dp_min[v][mp[a]][mp[b]] = inf;\n  dp_max[v][mp[a]][mp[b]] = -inf;  \n  do {\n    Pi a_tmp = Pi(a, a), b_tmp = Pi(b, b);\n    Int mn = 0, mx = 0;\n    bool f_mn = true, f_mx = true;\n    for(Int u : graph[v]) {\n      if(f_mn) {\n\tInt x = -dfs(u, -b_tmp.first, -a_tmp.first).first;\n\tmn += dp_min[u][mp[-b_tmp.first]][mp[-a_tmp.first]];\n\tif(x >= b_tmp.first) {\n\t  a_tmp.first = x;\n\t  f_mn = false;\n\t} else if(x > a_tmp.first) {\n\t  a_tmp.first = x;\n\t}\n      }\n      if(f_mx) {\n\tInt x = -dfs(u, -b_tmp.second, -a_tmp.second).second;\n\tmx += dp_max[u][mp[-b_tmp.second]][mp[-a_tmp.second]];\t\n\tif(x >= b_tmp.second) {\n\t  a_tmp.second = x;\n\t  f_mx = false;\n\t} else if(x > a_tmp.second) {\n\t  a_tmp.second = x;\n\t}\n      }\n    }\n    if(dp_min[v][mp[a]][mp[b]] >= mn) {\n      dp_min[v][mp[a]][mp[b]] = mn;\n      val[v][mp[a]][mp[b]].first = max(val[v][mp[a]][mp[b]].first, a_tmp.first);\n    }\n    if(dp_max[v][mp[a]][mp[b]] <= mx) {\n      dp_max[v][mp[a]][mp[b]] = mx;\n      val[v][mp[a]][mp[b]].second = min(val[v][mp[a]][mp[b]].second, a_tmp.second);\n    }\n  }while(next_permutation(graph[v].begin(), graph[v].end()));\n  //cout<<v<<\" \"<<val[v][mp[a]][mp[b]].first << \" \" << val[v][mp[a]][mp[b]].second << endl;\n  return val[v][mp[a]][mp[b]];\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  cin >> n;\n  for(Int i = 0; i < n; ++i) cin >> p[i];\n  for(Int i = 0; i < n; ++i) {\n    Int k; cin >> k;\n    for(Int j = 0; j < k; ++j) {\n      Int t; cin >> t; --t;\n      graph[i].push_back(t);\n    }\n    sort(graph[i].begin(), graph[i].end());\n  }\n  vector<Int> vec;\n  vec.push_back(-inf);\n  vec.push_back(inf);\n  for(Int i = 0; i < n; ++i) {\n    vec.push_back(p[i]);\n    vec.push_back(-p[i]);\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n  for(Int i = 0; i < n; ++i) {\n    mp[p[i]] = lower_bound(vec.begin(), vec.end(), p[i])-vec.begin();\n    mp[-p[i]] = lower_bound(vec.begin(), vec.end(), -p[i])-vec.begin();\n  }\n  memset(visited, false, sizeof(visited));\n  dfs(0, -inf, inf);\n  cout << dp_min[0][mp[-inf]][mp[inf]] << \" \" << dp_max[0][mp[-inf]][mp[inf]] << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nconst Int inf = 1LL<<55;\n\nInt n;\nInt p[101];\nvector<Int> graph[101];\n\nunordered_map<Int, Int> mp;\n\nusing Pi = pair<Int, Int>;\n\nPi val[101][202][202];\nInt dp_min[101][202][202];\nInt dp_max[101][202][202];\nbool visited[101][202][202];\n\nPi dfs(Int v, Int a, Int b) {\n  if(graph[v].empty()) {\n    dp_min[v][mp[a]][mp[b]] = 1;\n    dp_max[v][mp[a]][mp[b]] = 1;    \n    return Pi(p[v], p[v]);\n  }\n  if(visited[v][mp[a]][mp[b]]) return val[v][mp[a]][mp[b]];\n  visited[v][mp[a]][mp[b]] = true;\n  val[v][mp[a]][mp[b]] = Pi(-inf, inf);  \n  dp_min[v][mp[a]][mp[b]] = inf;\n  dp_max[v][mp[a]][mp[b]] = -inf;  \n  do {\n    Pi a_tmp = Pi(a, a), b_tmp = Pi(b, b);\n    Int mn = 0, mx = 0;\n    bool f_mn = true, f_mx = true;\n    for(Int u : graph[v]) {\n      if(f_mn) {\n\tInt x = -dfs(u, -b_tmp.first, -a_tmp.first).first;\n\tmn += dp_min[u][mp[-b_tmp.first]][mp[-a_tmp.first]];\n\tif(x >= b_tmp.first) {\n\t  a_tmp.first = x;\n\t  f_mn = false;\n\t} else if(x > a_tmp.first) {\n\t  a_tmp.first = x;\n\t}\n      }\n      if(f_mx) {\n\tInt x = -dfs(u, -b_tmp.second, -a_tmp.second).second;\n\tmx += dp_max[u][mp[-b_tmp.second]][mp[-a_tmp.second]];\t\n\tif(x >= b_tmp.second) {\n\t  a_tmp.second = x;\n\t  f_mx = false;\n\t} else if(x > a_tmp.second) {\n\t  a_tmp.second = x;\n\t}\n      }\n    }\n    if(dp_min[v][mp[a]][mp[b]] >= mn) {\n      dp_min[v][mp[a]][mp[b]] = mn;\n      val[v][mp[a]][mp[b]].first = max(val[v][mp[a]][mp[b]].first, a_tmp.first);\n    }\n    if(dp_max[v][mp[a]][mp[b]] <= mx) {\n      dp_max[v][mp[a]][mp[b]] = mx;\n      val[v][mp[a]][mp[b]].second = min(val[v][mp[b]][mp[b]].second, a_tmp.second);\n    }\n  }while(next_permutation(graph[v].begin(), graph[v].end()));\n  return val[v][mp[a]][mp[b]];\n}\n\nsigned main(){  \n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  cin >> n;\n  for(Int i = 0; i < n; ++i) cin >> p[i];\n  for(Int i = 0; i < n; ++i) {\n    Int k; cin >> k;\n    for(Int j = 0; j < k; ++j) {\n      Int t; cin >> t; --t;\n      graph[i].push_back(t);\n    }\n    sort(graph[i].begin(), graph[i].end());\n  }\n  vector<Int> vec;\n  vec.push_back(-inf);\n  vec.push_back(inf);\n  for(Int i = 0; i < n; ++i) {\n    vec.push_back(p[i]);\n    vec.push_back(-p[i]);\n  }\n  sort(vec.begin(), vec.end());\n  vec.erase(unique(vec.begin(), vec.end()), vec.end());\n  for(Int i = 0; i < n; ++i) {\n    mp[p[i]] = lower_bound(vec.begin(), vec.end(), p[i])-vec.begin();\n    mp[-p[i]] = lower_bound(vec.begin(), vec.end(), -p[i])-vec.begin();\n  }\n  memset(visited, false, sizeof(visited));\n  dfs(0, -inf, inf);\n  cout << dp_min[0][mp[-inf]][mp[inf]] << \" \" << dp_max[0][mp[-inf]][mp[inf]] << endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct Node {\n\tint value;\n\tvector<int>edges;\n\tNode() :value(0), edges() {\n\n\t}\n};\nstruct aa {\n\tint value;\n\tint amin;\n\tint amax;\n};\nmap<int, int>mp;\n\naa memo[100][202][202];\naa getans(const int now,const vector<Node>&ns,const int alp,const int bet) {\n\tif (memo[now][mp[alp]][mp[bet]].amax != -1)return memo[now][mp[alp]][mp[bet]];\n\telse {\n\t\tNode no(ns[now]);\n\t\tif (no.edges.empty())return memo[now][mp[alp]][mp[bet]]=aa{ ns[now].value,1,1 };\n\t\telse {\n\t\t\tint realvalue = -1e9;\n\t\t\t{\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[i], ns, -nbet, -nalp);\n\t\t\t\t\trealvalue = max(realvalue, -ans.value);\n\t\t\t\t}\n\t\t\t}\n\t\t\taa ret{ realvalue,int(1e9),int(-1e9) };\n\t\t\tvector<int>perms(no.edges.size());\n\t\t\tiota(perms.begin(), perms.end(), 0);\n\t\t\tdo {\n\t\t\t\tint amintime = 0;\n\t\t\t\tint nalp = alp;\n\t\t\t\tint nbet = bet;\n\t\t\t\tint amaxtime = 0;\n\t\t\t\tfor (int i = 0; i < no.edges.size(); ++i) {\n\t\t\t\t\taa ans = getans(no.edges[perms[i]], ns, -nbet, -nalp);\n\t\t\t\t\tamintime += ans.amin;\n\t\t\t\t\tamaxtime += ans.amax;\n\t\t\t\t\tif (-ans.value >= nbet) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (-ans.value > nalp) {\n\t\t\t\t\t\tnalp = -ans.value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.amin = min(ret.amin, amintime);\n\t\t\t\tret.amax = max(ret.amax, amaxtime);\n\t\t\t} while (next_permutation(perms.begin(), perms.end()));\n\t\t\treturn memo[now][mp[alp]][mp[bet]]=ret;\n\t\t}\n\t}\n}\n\nint main() {\n\tint N; cin >> N;\n\tfor (int i = 0; i < 100; ++i) {\n\t\tfor (int j = 0; j < 202; ++j) {\n\t\t\tfor (int k = 0; k < 202; ++k) {\n\t\t\t\tmemo[i][j][k] = aa{ -1,-1,-1 };\n\t\t\t}\n\t\t}\n\t}\n\tvector<Node>nodes(N);\n\tvector<int>nums;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint a; cin >> a;\n\t\tnodes[i].value = a;\n\t\tnums.emplace_back(a);\n\t\tnums.emplace_back(-a);\n\t}\n\tnums.emplace_back(int(1e9));\n\tnums.emplace_back(int(-1e9));\n\tsort(nums.begin(), nums.end());\n\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\tfor (int i = 0; i < nums.size(); ++i) {\n\t\tmp[nums[i]] = i;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; ++j) {\n\t\t\tint a; cin >> a; a--;\n\t\t\tnodes[i].edges.push_back(a);\n\t\t}\n\t}\n\taa ans=getans(0, nodes, int(-1e9), int(1e9));\n\tcout << ans.amin <<\" \"<< ans.amax<< endl; \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nusing P = pair<pi,int>;\n\nconst int N = 111;\nconst int INF = 191919;\n\nint n;\nint p[N];\nvector<int> ch[N];\n\nmap<pi,P> dp[N];\nP dfs(int v, int a, int b){\n    if(dp[v].count({a,b})) return dp[v][{a,b}];\n\n    if(ch[v].size() == 0){\n        return {{1,1},p[v]};\n    }\n\n    int sz = ch[v].size();\n    int res = -INF;\n    int mn = N, mx = 0;\n\n    do{\n        int ta=a, tb=b;\n        int tmn = 0, tmx = 0;\n        rep(i,sz){\n            P val = dfs(ch[v][i], -tb, -ta);\n            int vv = -val.se;\n            tmn += val.fi.fi;\n            tmx += val.fi.se;\n            if(vv >= tb){\n                ta = vv;\n                break;\n            }\n            if(vv > ta){\n                ta = vv;\n            }\n        }\n\n        res = max(res,ta);\n        mn = min(mn, tmn);\n        mx = max(mx, tmx);\n\n    }while(next_permutation(all(ch[v])));\n\n    // printf(\" %d %d %d  ->   [%d,%d],  val = %d\\n\",v,a,b,mn,mx,res);\n\n    P ret = {{mn,mx}, res};\n    dp[v][{a,b}] = ret;\n    return ret;\n}\n\nint main(){\n    cin >>n;\n    rep(i,n) cin >>p[i];\n    rep(i,n){\n        int k;\n        cin >>k;\n        while(k--){\n            int t;\n            cin >>t;\n            --t;\n            ch[i].pb(t);\n        }\n        sort(all(ch[i]));\n    }\n\n    pi ans = dfs(0,-INF,INF).fi;\n    cout << ans.fi << \" \" << ans.se << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nenum Type{\n\tMIN,\n\tMAX,\n};\n\nint V;\nint table[6][120][5];\nint num_pattern[6],calc_array[6];\nint value[NUM],num_child[NUM],child[NUM][5];\nint map_index;\nint dp[2][NUM][2*NUM][2*NUM];\nmap<int,int> MAP;\nbool check[6],visited[NUM][2*NUM][2*NUM];\n\n\nvoid makeTable(int max_num,int index){\n\n\tif(index == max_num){\n\n\t\tfor(int i = 0; i < max_num; i++){\n\t\t\ttable[max_num][num_pattern[max_num]][i] = calc_array[i]-1;\n\t\t}\n\t\tnum_pattern[max_num]++;\n\n\t\treturn;\n\t}\n\n\tfor(int next_num = 1; next_num <= max_num; next_num++){\n\n\t\tif(check[next_num])continue;\n\t\tcheck[next_num] = true;\n\t\tcalc_array[index] = next_num;\n\t\tmakeTable(max_num,index+1);\n\t\tcheck[next_num] = false;\n\t}\n}\n\nvoid registMAP(int num){\n\n\tauto at = MAP.find(num);\n\n\tif(at == MAP.end()){\n\t\tMAP[num] = map_index++;\n\t}\n\n\tat = MAP.find(-num);\n\n\tif(at == MAP.end()){\n\t\tMAP[-num] = map_index++;\n\t}\n}\n\nvoid dfs(int node_id){\n\n\tif(num_child[node_id] == 0){\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < num_child[node_id]; i++){\n\t\tdfs(child[node_id][i]);\n\t}\n\tvalue[node_id] = -BIG_NUM;\n\n\tfor(int i = 0; i < num_child[node_id]; i++){\n\t\tvalue[node_id] = max(value[node_id],-value[child[node_id][i]]);\n\t}\n}\n\nvoid recursive(int node_id,int A,int B){\n\n\tif(visited[node_id][MAP[A]][MAP[B]])return;\n\n\tvisited[node_id][MAP[A]][MAP[B]] = true;\n\n\tif(num_child[node_id] == 0){\n\t\tdp[MIN][node_id][MAP[A]][MAP[B]] = 1;\n\t\tdp[MAX][node_id][MAP[A]][MAP[B]] = 1;\n\t\treturn;\n\t}\n\n\tint tmp_A,tmp_B,tmp_child;\n\tint minimum = BIG_NUM,maximum = -BIG_NUM;\n\tint tmp_min,tmp_max,val;\n\n\tfor(int i = 0; i < num_pattern[num_child[node_id]]; i++){\n\n\t\ttmp_min = 0;\n\t\ttmp_max = 0;\n\t\ttmp_A = A;\n\t\ttmp_B = B;\n\n\t\tfor(int k = 0; k < num_child[node_id]; k++){\n\n\t\t\ttmp_child = child[node_id][table[num_child[node_id]][i][k]];\n\t\t\trecursive(tmp_child,-tmp_B,-tmp_A);\n\n\t\t\tval = -value[tmp_child];\n\n\t\t\ttmp_min += dp[MIN][tmp_child][MAP[-tmp_B]][MAP[-tmp_A]];\n\t\t\ttmp_max += dp[MAX][tmp_child][MAP[-tmp_B]][MAP[-tmp_A]];\n\n\t\t\tif(val >= tmp_B){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(val > tmp_A){\n\t\t\t\ttmp_A = val;\n\t\t\t}\n\t\t}\n\t\tminimum = min(minimum,tmp_min);\n\t\tmaximum = max(maximum,tmp_max);\n\t}\n\tdp[MIN][node_id][MAP[A]][MAP[B]] = minimum;\n\tdp[MAX][node_id][MAP[A]][MAP[B]] = maximum;\n\n}\n\nint main(){\n\n\tfor(int i = 1; i <= 5; i++){\n\t\tnum_pattern[i] = 0;\n\t}\n\n\tfor(int max_num = 1; max_num <= 5; max_num++){\n\n\t\tfor(int i = 1; i <= max_num; i++){\n\t\t\tcheck[i] = false;\n\t\t}\n\t\tfor(int first_num = 1; first_num <= max_num; first_num++){\n\t\t\tcheck[first_num] = true;\n\t\t\tcalc_array[0] = first_num;\n\t\t\tmakeTable(max_num,1);\n\t\t\tcheck[first_num] = false;\n\t\t}\n\t}\n\n\tscanf(\"%d\",&V);\n\n\tregistMAP(BIG_NUM);\n\n\tfor(int i = 0; i < V; i++){\n\t\tscanf(\"%d\",&value[i]);\n\t\tregistMAP(value[i]);\n\t}\n\n\tint tmp;\n\tfor(int i = 0; i < V; i++){\n\n\t\tscanf(\"%d\",&num_child[i]);\n\n\t\tfor(int k = 0; k < num_child[i]; k++){\n\t\t\tscanf(\"%d\",&tmp);\n\t\t\ttmp--;\n\t\t\tchild[i][k] = tmp;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < V; i++){\n\t\tfor(int k = 0; k < map_index; k++){\n\t\t\tfor(int p = 0; p < map_index; p++){\n\n\t\t\t\tvisited[i][k][p] = false;\n\n\t\t\t\tdp[MIN][i][k][p] = BIG_NUM;\n\t\t\t\tdp[MAX][i][k][p] = -BIG_NUM;\n\t\t\t}\n\t\t}\n\t}\n\n\tdfs(0);\n\trecursive(0,-BIG_NUM,BIG_NUM);\n\n\tprintf(\"%d %d\\n\",dp[MIN][0][MAP[-BIG_NUM]][MAP[BIG_NUM]],dp[MAX][0][MAP[-BIG_NUM]][MAP[BIG_NUM]]);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nP dp_min[105][205][205];\nP dp_max[105][205][205];\nbool used[105][205][205];\nvector<int> val;\nvector<int> G[105];\nint p[205];\n\nstruct data{\n\tint a,b,cnt,st;\n\tdata(){}\n\tdata(int aa,int bb,int cc,int ss){\n\t\ta=aa;\n\t\tb=bb;\n\t\tcnt=cc;\n\t\tst=ss;\n\t}\n};\n\nvoid solve(int v,int l,int r){\n\tif(used[v][l][r])return;\n\t//printf(\"%d %d %d\\n\",v,l,r);\n\tused[v][l][r]=true;\n\tif(G[v].size()==0){\n\t\tint pos=lower_bound(val.begin(),val.end(),p[v])-val.begin();\n\t\tdp_min[v][l][r]=P(1,pos);\n\t\tdp_max[v][l][r]=P(1,pos);\n\t\t//printf(\"%d %d\\n\",v,val[pos]);\n\t\treturn;\n\t}\n\tint ord[5];\n\tfor(int i=0;i<G[v].size();i++){\n\t\tord[i]=i;\n\t}\n\tdp_min[v][l][r]=P(114514,114514);\n\tdo{\n\t\tqueue<data> que;\n\t\tque.push(data(l,r,0,0));\n\t\twhile(que.size()){\n\t\t\tdata d=que.front();\n\t\t\tque.pop();\n\t\t\tif(d.st==G[v].size()){\n\t\t\t\tdp_min[v][l][r]=min(dp_min[v][l][r],P(d.cnt,d.a));\n\t\t\t\tdp_max[v][l][r]=max(dp_max[v][l][r],P(d.cnt,d.a));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nv=G[v][ord[d.st]];\n\t\t\tint ra=lower_bound(val.begin(),val.end(),-val[d.a])-val.begin();\n\t\t\tint rb=lower_bound(val.begin(),val.end(),-val[d.b])-val.begin();\n\t\t\tsolve(nv,rb,ra);\n\t\t\tint rpos=lower_bound(val.begin(),val.end(),-val[dp_min[nv][rb][ra].second])-val.begin();\n\t\t\tif(rpos>=d.b){\n\t\t\t\tdp_min[v][l][r]=min(dp_min[v][l][r],P(d.cnt+dp_min[nv][rb][ra].first,rpos));\n\t\t\t\tdp_max[v][l][r]=max(dp_max[v][l][r],P(d.cnt+dp_min[nv][rb][ra].first,rpos));\t\n\t\t\t}else{\n\t\t\t\tque.push(data(max(d.a,rpos),d.b,d.cnt+dp_min[nv][rb][ra].first,d.st+1));\n\t\t\t}\n\t\t\trpos=lower_bound(val.begin(),val.end(),-val[dp_max[nv][rb][ra].second])-val.begin();\n\t\t\tif(rpos>=d.b){\n\t\t\t\tdp_min[v][l][r]=min(dp_min[v][l][r],P(d.cnt+dp_max[nv][rb][ra].first,rpos));\n\t\t\t\tdp_max[v][l][r]=max(dp_max[v][l][r],P(d.cnt+dp_max[nv][rb][ra].first,rpos));\t\n\t\t\t}else{\n\t\t\t\tque.push(data(max(d.a,rpos),d.b,d.cnt+dp_max[nv][rb][ra].first,d.st+1));\n\t\t\t}\n\t\t}\n\t}while(next_permutation(ord,ord+G[v].size()));\n\t//printf(\"%d %d %d (%d,%d) (%d,%d)\\n\",v,l,r,dp_min[v][l][r].first,val[dp_min[v][l][r].second],dp_max[v][l][r].first,val[dp_max[v][l][r].second]);\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&p[i]);\n\t\tval.push_back(p[i]);\n\t\tval.push_back(-p[i]);\n\t}\n\tval.push_back(114514);\n\tval.push_back(-114514);\n\tsort(val.begin(),val.end());\n\tval.erase(unique(val.begin(),val.end()),val.end());\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint a;\n\t\t\tscanf(\"%d\",&a);\n\t\t\ta--;\n\t\t\tG[i].push_back(a);\n\t\t}\n\t}\n\tsolve(0,0,val.size()-1);\n\tprintf(\"%d %d\\n\",dp_min[0][0][val.size()-1].first,dp_max[0][0][val.size()-1].first);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nvector<T> compress(vector<T> v){\n  sort(v.begin(),v.end());\n  v.erase(unique(v.begin(),v.end()),v.end());\n  return v;\n}\n\ntemplate<typename T>\nmap<T, Int> dict(const vector<T> &v){\n  map<T, Int> res;\n  for(Int i=0;i<(Int)v.size();i++)\n    res[v[i]]=i;\n  return res;\n}\n\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> x(n);\n  for(Int i=0;i<n;i++) cin>>x[i];\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    Int k;\n    cin>>k;\n    while(k--){\n      Int t;\n      cin>>t;\n      t--;\n      G[i].emplace_back(t);\n    }\n  }\n  vector<Int> vx;\n  for(Int i=0;i<n;i++){\n    vx.emplace_back(-x[i]);\n    vx.emplace_back(+x[i]);\n  }\n  vx.emplace_back(-2e5);\n  vx.emplace_back(+2e5);\n  vx=compress(vx);\n  auto mx=dict(vx);\n\n  auto val=make_v<Int>(n,mx.size(),mx.size());\n  auto dp1=make_v<Int>(n,mx.size(),mx.size());\n  auto dp2=make_v<Int>(n,mx.size(),mx.size());\n  fill_v(dp1,-1);\n  fill_v(dp2,-1);\n  function<Int(Int, Int, Int)> dfs=\n    [&](Int v,Int a,Int b)->Int{\n      Int &res=val[v][a][b];\n      Int &t1=dp1[v][a][b],&t2=dp2[v][a][b];\n      if(~t1) return res;\n      if(G[v].empty()){\n        t1=t2=1;\n        return val[v][a][b]=x[v];\n      }\n      t1=n+1;t2=-1;\n      sort(G[v].begin(),G[v].end());\n      do{\n        Int c=a,d=b,s1=0,s2=0,flg=0;\n        for(Int u:G[v]){\n          Int w=mx[-dfs(u,mx[-vx[d]],mx[-vx[c]])];\n          s1+=dp1[u][mx[-vx[d]]][mx[-vx[c]]];\n          s2+=dp2[u][mx[-vx[d]]][mx[-vx[c]]];\n          if(w>=d){\n            res=vx[w];\n            flg=1;\n            break;\n          }else if(w>c){\n            c=w;\n          }\n        }\n        chmin(t1,s1);\n        chmax(t2,s2);\n        if(!flg) res=vx[c];       \n      }while(next_permutation(G[v].begin(),G[v].end()));\n      return res;\n    };  \n  dfs(0,0,mx.size()-1);\n  cout<<dp1[0][0][mx.size()-1]<<\" \"<<dp2[0][0][mx.size()-1]<<endl;  \n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N = int(readline())\n    *P, = map(int, readline().split())\n    G = []\n    prt = [0]*N\n    for i in range(N):\n        k, *t = map(int, readline().split())\n        G.append([e-1 for e in t])\n        for e in t:\n            prt[e-1] = i\n    *D, = map(len, G)\n    A = [0]*N\n    deg = D[:]\n    que = deque()\n    for v in range(N):\n        if deg[v] == 0:\n            A[v] = P[v]\n            que.append(v)\n    while que:\n        v = que.popleft()\n        p = prt[v]\n        deg[p] -= 1\n        if deg[p] == 0:\n            A[p] = max(-A[w] for w in G[p])\n            que.append(p)\n\n    for v in range(N):\n        if D[v] == 0:\n            A[v] = P[v]\n        else:\n            A[v] = max(-A[w] for w in G[v])\n\n    memo = {}\n    def dfs(v, state, c, a, b):\n        key = (v, state, a, b)\n        if key in memo:\n            return memo[key]\n        if c == D[v]:\n            if c == 0:\n                return 1, 1\n            return 0, 0\n        c0 = N+1; c1 = 0\n        Gv = G[v]\n        for k in range(D[v]):\n            if state & (1 << k):\n                continue\n            w = Gv[k]\n            s0, s1 = dfs(w, 0, 0, -b, -a)\n            val = -A[w]\n            if val >= b:\n                c0 = min(c0, s0); c1 = max(c1, s1)\n                continue\n            t0, t1 = dfs(v, state | (1 << k), c+1, max(a, val), b)\n            c0 = min(c0, s0+t0)\n            c1 = max(c1, s1+t1)\n        memo[key] = c0, c1\n        return c0, c1\n    INF = 10**9\n    r0, r1 = dfs(0, 0, 0, -INF, INF)\n    write(\"%d %d\\n\" % (r0, r1))\nsolve()\n"
  }
]