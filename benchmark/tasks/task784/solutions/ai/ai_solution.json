[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n\nint hammingDistance(int a, int b) {\n    int xor = a ^ b;\n    int count = 0;\n    while (xor) {\n        count += xor & 1;\n        xor >>= 1;\n    }\n    return count;\n}\n\nbool solve(int N, int A, int B, int* result) {\n    int size = 1 << N;\n    bool* used = calloc(size, sizeof(bool));\n    \n    result[0] = A;\n    used[A] = true;\n    \n    for (int i = 1; i < size; i++) {\n        bool found = false;\n        for (int j = 0; j < size; j++) {\n            if (!used[j] && hammingDistance(result[i-1], j) == 1) {\n                result[i] = j;\n                used[j] = true;\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found) {\n            free(used);\n            return false;\n        }\n    }\n    \n    if (result[size-1] != B) {\n        free(used);\n        return false;\n    }\n    \n    free(used);\n    return true;\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n    \n    int* result = malloc((1 << N) * sizeof(int));\n    \n    if (solve(N, A, B, result)) {\n        printf(\"YES\\n\");\n        for (int i = 0; i < (1 << N); i++) {\n            printf(\"%d \", result[i]);\n        }\n        printf(\"\\n\");\n    } else {\n        printf(\"NO\\n\");\n    }\n    \n    free(result);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:53:47"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count_bits(int x) {\n    int count = 0;\n    while (x) {\n        count += x & 1;\n        x >>= 1;\n    }\n    return count;\n}\n\nint is_possible(int N, int A, int B) {\n    return (count_bits(A ^ B) % 2 == 1);\n}\n\nvoid gray_code(int N, int *arr, int start) {\n    for (int i = 0; i < (1 << N); ++i) {\n        arr[i] = start ^ (i ^ (i >> 1));\n    }\n}\n\nvoid reverse(int *arr, int size) {\n    for (int i = 0; i < size / 2; ++i) {\n        int temp = arr[i];\n        arr[i] = arr[size - 1 - i];\n        arr[size - 1 - i] = temp;\n    }\n}\n\nint find_index(int *arr, int size, int value) {\n    for (int i = 0; i < size; ++i) {\n        if (arr[i] == value) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nvoid rotate(int *arr, int size, int k) {\n    reverse(arr, k);\n    reverse(arr + k, size - k);\n    reverse(arr, size);\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    if (!is_possible(N, A, B)) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    int size = 1 << N;\n    int *perm = (int *)malloc(size * sizeof(int));\n    gray_code(N, perm, 0);\n\n    int a_pos = find_index(perm, size, A);\n    rotate(perm, size, a_pos);\n\n    if (perm[size - 1] != B) {\n        int b_pos = find_index(perm, size, B);\n        reverse(perm + 1, b_pos);\n    }\n\n    printf(\"YES\\n\");\n    for (int i = 0; i < size; ++i) {\n        printf(\"%d \", perm[i]);\n    }\n    printf(\"\\n\");\n\n    free(perm);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:54:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> gray_code(int n) {\n    vector<int> res;\n    for (int i = 0; i < (1 << n); ++i) {\n        res.push_back(i ^ (i >> 1));\n    }\n    return res;\n}\n\nbool is_possible(int a, int b, int n) {\n    int diff = a ^ b;\n    return (diff & (diff - 1)) == 0;\n}\n\nvoid solve() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    int size = 1 << N;\n    \n    if (!is_possible(A, B, N)) {\n        cout << \"NO\" << endl;\n        return;\n    }\n    \n    vector<int> gray = gray_code(N);\n    int a_pos = -1, b_pos = -1;\n    for (int i = 0; i < size; ++i) {\n        if (gray[i] == A) a_pos = i;\n        if (gray[i] == B) b_pos = i;\n    }\n    \n    if (a_pos == -1 || b_pos == -1) {\n        cout << \"NO\" << endl;\n        return;\n    }\n    \n    vector<int> permutation;\n    for (int i = 0; i < size; ++i) {\n        permutation.push_back(gray[(a_pos + i) % size]);\n    }\n    \n    if (permutation.back() != B) {\n        reverse(permutation.begin() + 1, permutation.end());\n    }\n    \n    if (permutation.back() != B) {\n        cout << \"NO\" << endl;\n        return;\n    }\n    \n    cout << \"YES\" << endl;\n    for (int i = 0; i < size; ++i) {\n        if (i > 0) cout << \" \";\n        cout << permutation[i];\n    }\n    cout << endl;\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:54:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GrayCodePermutation {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        sc.close();\n\n        int size = 1 << N;\n        if (Integer.bitCount(A ^ B) % 2 == 0) {\n            System.out.println(\"NO\");\n            return;\n        }\n\n        List<Integer> grayCode = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            grayCode.add(i ^ (i >> 1));\n        }\n\n        int indexA = -1;\n        int indexB = -1;\n        for (int i = 0; i < size; i++) {\n            if (grayCode.get(i) == A) {\n                indexA = i;\n            }\n            if (grayCode.get(i) == B) {\n                indexB = i;\n            }\n        }\n\n        List<Integer> permutation = new ArrayList<>();\n        for (int i = 0; i < size; i++) {\n            int pos = (indexA + i) % size;\n            permutation.add(grayCode.get(pos));\n        }\n\n        if (permutation.get(size - 1) != B) {\n            List<Integer> reversed = new ArrayList<>();\n            for (int i = 0; i < size; i++) {\n                int pos = (indexA - i + size) % size;\n                reversed.add(grayCode.get(pos));\n            }\n            permutation = reversed;\n        }\n\n        if (permutation.get(size - 1) != B) {\n            System.out.println(\"NO\");\n            return;\n        }\n\n        System.out.println(\"YES\");\n        for (int num : permutation) {\n            System.out.print(num + \" \");\n        }\n        System.out.println();\n    }\n}",
    "timestamp": "2025-08-05 22:55:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        scanner.close();\n\n        List<Integer> permutation = findPermutation(N, A, B);\n        \n        if (permutation == null) {\n            System.out.println(\"NO\");\n        } else {\n            System.out.println(\"YES\");\n            for (int num : permutation) {\n                System.out.print(num + \" \");\n            }\n        }\n    }\n\n    private static List<Integer> findPermutation(int N, int A, int B) {\n        int total = 1 << N;\n        \n        if (A == B && total == 1) {\n            return Arrays.asList(A);\n        }\n\n        boolean[] used = new boolean[total];\n        List<Integer> path = new ArrayList<>();\n        path.add(A);\n        used[A] = true;\n\n        if (backtrack(N, A, B, used, path)) {\n            return path;\n        }\n        \n        return null;\n    }\n\n    private static boolean backtrack(int N, int current, int target, boolean[] used, List<Integer> path) {\n        if (path.size() == (1 << N)) {\n            return current == target;\n        }\n\n        for (int i = 0; i < used.length; i++) {\n            if (!used[i] && Integer.bitCount(current ^ i) == 1) {\n                path.add(i);\n                used[i] = true;\n\n                if (backtrack(N, i, target, used, path)) {\n                    return true;\n                }\n\n                path.remove(path.size() - 1);\n                used[i] = false;\n            }\n        }\n\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 22:55:26"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n\nusing namespace std;\n\nbool isOneBitDifferent(int a, int b) {\n    return __builtin_popcount(a ^ b) == 1;\n}\n\nbool findHamiltonianPath(int N, int A, int B, vector<int>& path) {\n    int total = (1 << N);\n    path.clear();\n    path.push_back(A);\n    vector<bool> used(total, false);\n    used[A] = true;\n\n    function<bool(int)> backtrack = [&](int current) {\n        if (path.size() == total) {\n            return current == B;\n        }\n\n        for (int next = 0; next < total; next++) {\n            if (!used[next] && isOneBitDifferent(current, next)) {\n                path.push_back(next);\n                used[next] = true;\n\n                if (backtrack(next)) {\n                    return true;\n                }\n\n                path.pop_back();\n                used[next] = false;\n            }\n        }\n        return false;\n    };\n\n    return backtrack(A);\n}\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n\n    vector<int> path;\n    if (findHamiltonianPath(N, A, B, path)) {\n        cout << \"YES\" << endl;\n        for (int p : path) {\n            cout << p << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"NO\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:55:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def gray_code_sequence(n):\n    if n == 0:\n        return [0]\n    prev_sequence = gray_code_sequence(n - 1)\n    return prev_sequence + [(1 << (n - 1)) | x for x in reversed(prev_sequence)]\n\ndef find_permutation(N, A, B):\n    gc_sequence = gray_code_sequence(N)\n    idx_a = gc_sequence.index(A)\n    idx_b = gc_sequence.index(B)\n    \n    if (idx_b - idx_a) % 2 == 0:\n        return 'NO'\n    \n    if idx_a < idx_b:\n        result = gc_sequence[idx_a:] + gc_sequence[:idx_a]\n    else:\n        result = gc_sequence[idx_a:] + gc_sequence[:idx_b][::-1]\n    \n    return 'YES', result\n\ndef main():\n    N, A, B = map(int, input().split())\n    res = find_permutation(N, A, B)\n    if res == 'NO':\n        print(res)\n    else:\n        print(res[0])\n        print(' '.join(map(str, res[1])))\n\nmain()",
    "timestamp": "2025-08-13 12:56:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GrayCodePermutation {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        \n        if (canExist(N, A, B)) {\n            System.out.println(\"YES\");\n            generateAndPrintPermutation(N, A, B);\n        } else {\n            System.out.println(\"NO\");\n        }\n        \n        sc.close();\n    }\n    \n    private static boolean canExist(int N, int A, int B) {\n        return Integer.bitCount(A ^ B) % 2 == 1;\n    }\n    \n    private static void generateAndPrintPermutation(int N, int A, int B) {\n        List<Integer> perm = new ArrayList<>();\n        int size = 1 << N;\n        \n        for (int i = 0; i < size; i++) {\n            perm.add(A ^ i ^ (i >> 1));\n        }\n        \n        if (perm.get(size - 1) != B) {\n            // Reverse last segment to get B at the end\n            for (int i = 0; i < size; i++) {\n                perm.set(i, perm.get(i) ^ A ^ B);\n            }\n        }\n        \n        for (int i = 0; i < size; i++) {\n            System.out.print(perm.get(i) + (i == size - 1 ? \"\\n\" : \" \"));\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:56:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint gray_code(int n) {\n    return n ^ (n >> 1);\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    int size = 1 << N;\n    int diff = A ^ B;\n    int hamming_weight = __builtin_popcount(diff);\n\n    if (hamming_weight % 2 == 0) {\n        printf(\"NO\\n\");\n        return 0;\n    }\n\n    printf(\"YES\\n\");\n\n    int start = 0;\n    while (gray_code(start) != A) start++;\n\n    int perm[size];\n    for (int i = 0; i < size; i++) {\n        perm[i] = gray_code((start + i) % size);\n    }\n\n    if (perm[size - 1] != B) {\n        int swap_index = size - 1;\n        for (int i = 0; i < size - 1; i++) {\n            if (perm[i] == B) {\n                swap_index = i;\n                break;\n            }\n        }\n        int temp = perm[size - 1];\n        perm[size - 1] = perm[swap_index];\n        perm[swap_index] = temp;\n    }\n\n    for (int i = 0; i < size; i++) {\n        printf(\"%d \", perm[i]);\n    }\n\n    printf(\"\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-13 12:56:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function grayCode(n) {\n    const result = [];\n    for (let i = 0; i < (1 << n); i++) {\n        result.push(i ^ (i >> 1));\n    }\n    return result;\n}\n\nfunction solve(N, A, B) {\n    const graySequence = grayCode(N);\n    const startA = graySequence.indexOf(A);\n    const startB = graySequence.indexOf(B);\n\n    if ((startA === -1) || (startB === -1)) {\n        console.log('NO');\n        return;\n    }\n    \n    let permut;\n    if ((Math.abs(startA - startB) + 1) === (1 << N)) {\n        permut = startA < startB ? graySequence.slice(startA).concat(graySequence.slice(0, startA)) : graySequence.slice(startA).reverse().concat(graySequence.slice(0, startA).reverse());\n    } else {\n        console.log('NO');\n        return;\n    }\n\n    console.log('YES');\n    console.log(permut.join(' '));\n}\n\n// Example usage:\n// solve(2, 0, 3); // Output: YES, 0 1 3 2",
    "timestamp": "2025-08-13 12:56:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A, B):\n    if A == B and bin(A).count('1') % 2 == bin(B).count('1') % 2:\n        return [A]\n\n    if bin(A).count('1') % 2 != bin(B).count('1') % 2:\n        return None\n\n    def hamming_distance(x, y):\n        return bin(x ^ y).count('1')\n\n    def backtrack(current, visited, path):\n        if len(path) == 2**N and path[-1] == B:\n            return path\n\n        for j in range(2**N):\n            if j not in visited and hamming_distance(current, j) == 1:\n                visited.add(j)\n                result = backtrack(j, visited, path + [j])\n                if result:\n                    return result\n                visited.remove(j)\n\n        return None\n\n    visited = {A}\n    result = backtrack(A, visited, [A])\n\n    return result\n\ndef main():\n    N, A, B = map(int, input().split())\n    result = solve(N, A, B)\n\n    if result is None:\n        print('NO')\n    else:\n        print('YES')\n        print(' '.join(map(str, result)))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:56:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, A, B) {\n    const totalElements = 1 << N;\n    \n    // Check if A and B have same bit count\n    if (bitCount(A) % 2 !== bitCount(B) % 2) return 'NO';\n    \n    const used = new Array(totalElements).fill(false);\n    const path = new Array(totalElements);\n    \n    path[0] = A;\n    used[A] = true;\n    \n    if (backtrack(N, A, B, 1, path, used)) {\n        return 'YES\\n' + path.join(' ');\n    }\n    \n    return 'NO';\n}\n\nfunction backtrack(N, current, target, index, path, used) {\n    if (index === (1 << N)) {\n        return current === target;\n    }\n    \n    for (let next = 0; next < (1 << N); next++) {\n        if (!used[next] && differByOneBit(current, next)) {\n            path[index] = next;\n            used[next] = true;\n            \n            if (backtrack(N, next, target, index + 1, path, used)) {\n                return true;\n            }\n            \n            used[next] = false;\n        }\n    }\n    \n    return false;\n}\n\nfunction differByOneBit(a, b) {\n    return bitCount(a ^ b) === 1;\n}\n\nfunction bitCount(n) {\n    let count = 0;\n    while (n) {\n        count += n & 1;\n        n >>= 1;\n    }\n    return count;\n}\n\n// Example usage\nfunction main() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split(' ').map(Number);\n    const [N, A, B] = input;\n    console.log(solve(N, A, B));\n}\n\nmain();",
    "timestamp": "2025-08-13 12:56:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N, A, B = map(int, sys.stdin.readline().split())\n    total = 1 << N\n    xor = A ^ B\n    if bin(xor).count('1') % 2 == 0:\n        print(\"NO\")\n        return\n    \n    # Generate Gray code\n    gray = [i ^ (i >> 1) for i in range(total)]\n    \n    # Find the position of A and B in the Gray code\n    pos_A = gray.index(A)\n    pos_B = gray.index(B)\n    \n    # The Gray code is cyclic with a single bit change between consecutive elements\n    # We can rotate the Gray code to start at A and end at B\n    # Since the XOR has odd number of bits, it's possible to find such a rotation\n    # The idea is to split the Gray code into two parts and reverse the second part\n    \n    # Split at the position where the transition from A to B happens\n    # We need to find a split point such that the sequence starts with A and ends with B\n    # The standard Gray code starts with 0 and ends with 1 << (N-1)\n    # So we need to adjust it to start with A and end with B\n    \n    # The approach is to find a path from A to B in the Gray code cycle\n    # and then construct the permutation accordingly\n    \n    # We can use the fact that the Gray code is a Hamiltonian cycle in the hypercube\n    # So we can find a path from A to B with all elements visited once\n    \n    # The following is a way to construct the desired permutation\n    # by finding the path from A to B in the Gray code cycle\n    \n    # The key observation is that the Gray code is symmetric and can be reversed\n    # So we can find the path from A to B by splitting the Gray code at some point\n    \n    # Find the index where the Gray code has A and B adjacent with a single bit change\n    # But since the Gray code is a cycle, we can rotate it to make A and B consecutive\n    \n    # However, a simpler approach is to use the fact that the Gray code can be split\n    # into two parts where the first part is the path from A to some point,\n    # and the second part is the path from that point to B\n    \n    # But implementing this directly is tricky, so here's a practical approach:\n    \n    # We can generate the Gray code and then find a rotation that starts with A and ends with B\n    # Since the total number of bits changed between A and B is odd, such a rotation exists\n    \n    # Find the position of A in the Gray code\n    # Then the position of B is pos_A + k, where k is odd (since the XOR has odd bits)\n    # So we can split the Gray code into two parts at pos_A and pos_B\n    \n    # The desired permutation is [gray[pos_A], gray[pos_A+1], ..., gray[total-1], gray[0], ..., gray[pos_A-1]]\n    # But we need to ensure that the last element is B\n    \n    # So we need to find a rotation where the sequence starts with A and ends with B\n    \n    # The following code constructs the permutation by finding the rotation\n    \n    # The idea is to split the Gray code into two parts and reverse the second part\n    # if necessary to make the last element B\n    \n    # Find the index of B in the Gray code\n    # Then the permutation is the Gray code rotated to start at A and then\n    # the part after A is adjusted to reach B\n    \n    # The standard Gray code is a cycle where consecutive elements differ by one bit\n    # So we can rotate the cycle to start at A and then find the path to B\n    \n    # The following is a way to construct the permutation\n    \n    # The permutation is constructed by taking the Gray code from A to B\n    # Since the XOR has odd bits, the path length is odd, and we can cover all elements\n    \n    # The permutation is the Gray code sequence starting at A, wrapping around, and ending at B\n    \n    # Construct the permutation\n    permutation = []\n    for i in range(total):\n        permutation.append(gray[(pos_A + i) % total])\n        if gray[(pos_A + i) % total] == B:\n            break\n    \n    # Check if all elements are covered\n    if len(permutation) != total:\n        # If not, we need to include the remaining elements\n        remaining = []\n        for i in range(total):\n            if gray[i] not in permutation:\n                remaining.append(gray[i])\n        # The remaining elements must form a path from B back to A with one bit changes\n        # But since the initial condition is satisfied, this should not happen\n        pass\n    \n    # Verify the permutation\n    if permutation[0] == A and permutation[-1] == B:\n        valid = True\n        for i in range(len(permutation) - 1):\n            if bin(permutation[i] ^ permutation[i+1]).count('1') != 1:\n                valid = False\n                break\n        if valid:\n            print(\"YES\")\n            print(' '.join(map(str, permutation)))\n            return\n    \n    # If the above approach didn't work, try another method\n    # Another approach is to construct the path using recursive construction\n    # of Gray codes, but it's more complex\n    \n    # As a fallback, we can try to construct the permutation by finding a Hamiltonian path\n    # from A to B in the hypercube graph\n    \n    # The hypercube graph has vertices as all N-bit numbers, edges between numbers differing by one bit\n    # We need to find a Hamiltonian path from A to B\n    \n    # The following is a recursive approach to find such a path\n    \n    def hamiltonian_path(n, start, end, path, visited):\n        if start == end:\n            return path + [end]\n        for i in range(n):\n            neighbor = start ^ (1 << i)\n            if neighbor not in visited:\n                visited.add(neighbor)\n                result = hamiltonian_path(n, neighbor, end, path + [start], visited)\n                if result is not None:\n                    return result\n                visited.remove(neighbor)\n        return None\n    \n    visited = set()\n    visited.add(A)\n    path = hamiltonian_path(N, A, B, [], visited)\n    if path is not None and len(path) == total:\n        print(\"YES\")\n        print(' '.join(map(str, path)))\n        return\n    \n    print(\"NO\")\n\nsolve()",
    "timestamp": "2025-08-13 12:57:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const fs = require('fs');\nconst input = fs.readFileSync(0, 'utf-8').trim().split('\\n');\nconst [N, A, B] = input[0].split(' ').map(Number);\n\nfunction solve() {\n    const size = 1 << N;\n    if ((A ^ B) === (size - 1)) {\n        const gray = [];\n        for (let i = 0; i < size; i++) {\n            gray.push(i ^ (i >> 1));\n        }\n        const indexA = gray.indexOf(A);\n        const indexB = gray.indexOf(B);\n        if (indexA !== -1 && indexB !== -1) {\n            const firstPart = gray.slice(0, indexA + 1);\n            const secondPart = gray.slice(indexA + 1);\n            const modifiedGray = secondPart.concat(firstPart);\n            const reversed = modifiedGray.slice().reverse();\n            const finalIndex = reversed.indexOf(B);\n            if (finalIndex !== -1) {\n                const result = reversed.slice(finalIndex).concat(reversed.slice(0, finalIndex));\n                console.log('YES');\n                console.log(result.join(' '));\n                return;\n            }\n        }\n        console.log('NO');\n        return;\n    }\n\n    const visited = new Array(size).fill(false);\n    const path = [];\n    path.push(A);\n    visited[A] = true;\n\n    function dfs(current) {\n        if (path.length === size) {\n            if (current === B) {\n                console.log('YES');\n                console.log(path.join(' '));\n                process.exit(0);\n            }\n            return;\n        }\n\n        for (let i = 0; i < N; i++) {\n            const next = current ^ (1 << i);\n            if (!visited[next]) {\n                visited[next] = true;\n                path.push(next);\n                dfs(next);\n                path.pop();\n                visited[next] = false;\n            }\n        }\n    }\n\n    dfs(A);\n    console.log('NO');\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:57:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n// Function to generate the reflected Gray code sequence for n bits\nvector<int> generateGrayCode(int n) {\n    vector<int> result(1 << n);\n    for (int i = 0; i < (1 << n); ++i) {\n        result[i] = i ^ (i >> 1);\n    }\n    return result;\n}\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n\n    // Check if A and B differ by an odd number of bits, if not, no such permutation exists\n    if (__builtin_popcount(A ^ B) % 2 == 0) {\n        cout << \"NO\" << endl;\n        return 0;\n    }\n\n    cout << \"YES\" << endl;\n\n    vector<int> grayCode = generateGrayCode(N);\n    vector<int> permutation(1 << N);\n\n    int aIndex = -1, bIndex = -1;\n    for (int i = 0; i < (1 << N); ++i) {\n        if (grayCode[i] == A) aIndex = i;\n        if (grayCode[i] == B) bIndex = i;\n    }\n\n    // Reorder the Gray code sequence to start from A and end at B\n    if (aIndex <= bIndex) {\n        int idx = 0;\n        for (int i = aIndex; i <= bIndex; ++i) {\n            permutation[idx++] = grayCode[i];\n        }\n        for (int i = bIndex + 1; i < (1 << N); ++i) {\n            permutation[idx++] = grayCode[i];\n        }\n        for (int i = 0; i < aIndex; ++i) {\n            permutation[idx++] = grayCode[i];\n        }\n    } else {\n        int idx = 0;\n        for (int i = aIndex; i < (1 << N); ++i) {\n            permutation[idx++] = grayCode[i];\n        }\n        for (int i = 0; i < bIndex; ++i) {\n            permutation[idx++] = grayCode[i];\n        }\n        for (int i = bIndex; i < aIndex; ++i) {\n            permutation[idx++] = grayCode[i];\n        }\n    }\n\n    for (int i = 0; i < (1 << N); ++i) {\n        if (i > 0) cout << \" \";\n        cout << permutation[i];\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:37:19"
  }
]