[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    \n    int A[MAX_N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    int dp[MAX_N];\n    memset(dp, 0, sizeof(dp));\n    dp[0] = 1;\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = K; j >= A[i]; j--) {\n            dp[j] |= dp[j - A[i]];\n        }\n    }\n    \n    int minEaten = 0;\n    if (dp[K]) {\n        for (int i = 0; i < N; i++) {\n            int temp[MAX_N];\n            memcpy(temp, dp, sizeof(dp));\n            \n            for (int j = K; j >= A[i]; j--) {\n                temp[j] &= !temp[j - A[i]];\n            }\n            \n            int cannotMake = 1;\n            for (int j = 0; j <= K; j++) {\n                if (temp[j]) {\n                    cannotMake = 0;\n                    break;\n                }\n            }\n            \n            if (cannotMake) {\n                minEaten = 1;\n                break;\n            }\n        }\n        \n        if (minEaten == 0) {\n            minEaten = 2;\n        }\n    }\n    \n    printf(\"%d\\n\", minEaten);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:36"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N, K;\n    scanf(\"%d %d\", &N, &K);\n    int *A = (int *)malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize DP array\n    int *dp = (int *)calloc(K + 1, sizeof(int));\n    dp[0] = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = K; j >= A[i]; j--) {\n            if (dp[j - A[i]]) {\n                dp[j] = 1;\n            }\n        }\n    }\n\n    if (!dp[K]) {\n        printf(\"0\\n\");\n        free(A);\n        free(dp);\n        return 0;\n    }\n\n    // Find the minimal number of cards to remove\n    int min_remove = N;\n    for (int i = 0; i < N; i++) {\n        int *temp_dp = (int *)calloc(K + 1, sizeof(int));\n        temp_dp[0] = 1;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            for (int l = K; l >= A[j]; l--) {\n                if (temp_dp[l - A[j]]) {\n                    temp_dp[l] = 1;\n                }\n            }\n        }\n        if (!temp_dp[K]) {\n            min_remove = 1;\n            free(temp_dp);\n            break;\n        }\n        free(temp_dp);\n    }\n\n    if (min_remove == 1) {\n        printf(\"1\\n\");\n    } else {\n        // Check if removing two cards is enough\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int *temp_dp = (int *)calloc(K + 1, sizeof(int));\n                temp_dp[0] = 1;\n                for (int l = 0; l < N; l++) {\n                    if (l == i || l == j) continue;\n                    for (int m = K; m >= A[l]; m--) {\n                        if (temp_dp[m - A[l]]) {\n                            temp_dp[m] = 1;\n                        }\n                    }\n                }\n                if (!temp_dp[K]) {\n                    min_remove = 2;\n                    free(temp_dp);\n                    goto end;\n                }\n                free(temp_dp);\n            }\n        }\n    }\n\nend:\n    printf(\"%d\\n\", min_remove);\n    free(A);\n    free(dp);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:01"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n    \n    sort(A.begin(), A.end());\n    \n    vector<vector<bool>> dp(N + 1, vector<bool>(K + 1, false));\n    dp[0][0] = true;\n    \n    for (int i = 1; i <= N; ++i) {\n        for (int j = 0; j <= K; ++j) {\n            dp[i][j] = dp[i - 1][j];\n            if (j >= A[i - 1]) {\n                dp[i][j] = dp[i][j] || dp[i - 1][j - A[i - 1]];\n            }\n        }\n    }\n    \n    if (!dp[N][K]) {\n        cout << 0 << endl;\n        return 0;\n    }\n    \n    int left = 0, right = N;\n    int answer = N;\n    \n    while (left <= right) {\n        int mid = (left + right) / 2;\n        vector<vector<bool>> temp_dp(mid + 1, vector<bool>(K + 1, false));\n        temp_dp[0][0] = true;\n        \n        for (int i = 1; i <= mid; ++i) {\n            for (int j = 0; j <= K; ++j) {\n                temp_dp[i][j] = temp_dp[i - 1][j];\n                if (j >= A[i - 1]) {\n                    temp_dp[i][j] = temp_dp[i][j] || temp_dp[i - 1][j - A[i - 1]];\n                }\n            }\n        }\n        \n        bool canReachK = temp_dp[mid][K];\n        \n        if (!canReachK) {\n            answer = mid;\n            right = mid - 1;\n        } else {\n            left = mid + 1;\n        }\n    }\n    \n    cout << N - answer << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int K = scanner.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n\n        boolean[] dp = new boolean[K + 1];\n        dp[0] = true;\n        for (int num : A) {\n            for (int j = K; j >= num; j--) {\n                if (dp[j - num]) {\n                    dp[j] = true;\n                }\n            }\n        }\n\n        if (!dp[K]) {\n            System.out.println(0);\n            return;\n        }\n\n        int minCards = N;\n        for (int i = 0; i < N; i++) {\n            boolean[] tempDp = new boolean[K + 1];\n            tempDp[0] = true;\n            for (int j = 0; j < N; j++) {\n                if (i == j) continue;\n                int num = A[j];\n                for (int l = K; l >= num; l--) {\n                    if (tempDp[l - num]) {\n                        tempDp[l] = true;\n                    }\n                }\n            }\n            if (!tempDp[K]) {\n                minCards = 1;\n                break;\n            }\n        }\n\n        if (minCards == 1) {\n            System.out.println(1);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:09:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CardsSnacks {\n    public static int minCardsToEat(int[] cards, int K) {\n        int n = cards.length;\n        Set<Integer> possibleSums = new HashSet<>();\n        possibleSums.add(0);\n\n        for (int card : cards) {\n            Set<Integer> newSums = new HashSet<>();\n            for (int sum : possibleSums) {\n                int newSum = sum + card;\n                if (newSum <= K) {\n                    newSums.add(newSum);\n                }\n            }\n            possibleSums.addAll(newSums);\n        }\n\n        if (!possibleSums.contains(K)) {\n            return 0;\n        }\n\n        for (int cardsToEat = 1; cardsToEat < n; cardsToEat++) {\n            boolean cannotMakeK = true;\n            \n            for (int mask = 0; mask < (1 << n); mask++) {\n                if (Integer.bitCount(mask) == n - cardsToEat) {\n                    Set<Integer> remainingSums = new HashSet<>();\n                    remainingSums.add(0);\n                    \n                    for (int i = 0; i < n; i++) {\n                        if ((mask & (1 << i)) != 0) {\n                            Set<Integer> newSums = new HashSet<>();\n                            for (int sum : remainingSums) {\n                                int newSum = sum + cards[i];\n                                if (newSum <= K) {\n                                    newSums.add(newSum);\n                                }\n                            }\n                            remainingSums.addAll(newSums);\n                        }\n                    }\n                    \n                    if (remainingSums.contains(K)) {\n                        cannotMakeK = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (cannotMakeK) {\n                return cardsToEat;\n            }\n        }\n        \n        return n;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int K = scanner.nextInt();\n        int[] cards = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            cards[i] = scanner.nextInt();\n        }\n        \n        System.out.println(minCardsToEat(cards, K));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 22:09:49"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int N, K;\n    cin >> N >> K;\n    \n    vector<int> A(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n    \n    vector<bool> possible(K + 1, false);\n    possible[0] = true;\n    \n    for (int x : A) {\n        for (int j = K; j >= x; j--) {\n            possible[j] |= possible[j - x];\n        }\n    }\n    \n    int ans = 0;\n    if (possible[K]) {\n        for (int x : A) {\n            vector<bool> temp = possible;\n            for (int j = K; j >= x; j--) {\n                temp[j] &= !temp[j - x];\n            }\n            \n            bool stillPossible = false;\n            for (int j = 0; j <= K; j++) {\n                if (temp[j] && j == K) {\n                    stillPossible = true;\n                    break;\n                }\n            }\n            \n            if (!stillPossible) {\n                ans++;\n            }\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:09:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_cards_to_eat(N, K, cards):\n    dp = [0] * (K + 1)\n    dp[0] = 1\n\n    for card in cards:\n        for j in range(K, card - 1, -1):\n            if dp[j - card]:\n                dp[j] = 1\n\n    if dp[K] == 0:\n        return 0\n    \n    return len(cards)\n\n# Example usage\nN = 5\nK = 11\ncards = [1, 2, 5, 6, 8]\nprint(min_cards_to_eat(N, K, cards))",
    "timestamp": "2025-08-13 09:11:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CardsSnacks {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int N = sc.nextInt();\n        int K = sc.nextInt();\n        int[] A = new int[N];\n\n        for (int i = 0; i < N; i++) {\n            A[i] = sc.nextInt();\n        }\n\n        System.out.println(minimumCardsToEat(N, K, A));\n        sc.close();\n    }\n\n    private static int minimumCardsToEat(int N, int K, int[] A) {\n        boolean[] dp = new boolean[K + 1];\n        dp[0] = true;\n\n        for (int card : A) {\n            for (int j = K; j >= card; j--) {\n                dp[j] = dp[j] || dp[j - card];\n            }\n        }\n\n        if (!dp[K]) {\n            return 0;\n        }\n\n        Arrays.sort(A);\n        int sum = 0;\n        int eaten = 0;\n\n        for (int i = N - 1; i >= 0; i--) {\n            sum += A[i];\n            eaten++;\n            if (sum > K || !canMeetK(K, A, i)) {\n                return eaten;\n            }\n        }\n\n        return eaten;\n    }\n\n    private static boolean canMeetK(int K, int[] A, int index) {\n        boolean[] dp = new boolean[K + 1];\n        dp[0] = true;\n\n        for (int i = 0; i <= index; i++) {\n            for (int j = K; j >= A[i]; j--) {\n                dp[j] = dp[j] || dp[j - A[i]];\n            }\n        }\n\n        return dp[K];\n    }\n}",
    "timestamp": "2025-08-13 09:11:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define MAX_K 10000\n\nbool dp[MAX_K + 1];\n\nint main() {\n    int n, k;\n    int A[MAX_N];\n\n    // Read input\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    // Initialize DP array\n    dp[0] = true;\n    for (int i = 1; i <= k; ++i) {\n        dp[i] = false;\n    }\n\n    // Fill the DP table\n    for (int i = 0; i < n; ++i) {\n        for (int j = k; j >= A[i]; --j) {\n            if (dp[j - A[i]]) {\n                dp[j] = true;\n            }\n        }\n    }\n\n    // Find the minimum cards to be eaten\n    int min_eaten = n;\n    for (int i = 0; i < n; ++i) {\n        if (!dp[k]) {\n            min_eaten = 0;\n            break;\n        }\n\n        for (int j = k; j >= A[i]; --j) {\n            dp[j] = dp[j] || (j >= A[i] && dp[j - A[i]]);\n        }\n\n        for (int j = 0; j <= k; ++j) {\n            if (dp[j] && j + A[i] <= k) {\n                dp[j + A[i]] = false;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", min_eaten);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:11:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A, K):\n    # Calculate the total sum of all cards\n    total_sum = sum(A)\n    \n    # If the total sum is less than K, impossible to make K\n    if total_sum < K:\n        return 0\n    \n    # Use dynamic programming to track possible sums\n    possible_sums = {0}\n    \n    for card in A:\n        # Create a copy of current possible sums\n        new_sums = possible_sums.copy()\n        \n        # Add the current card to all existing sums\n        for curr_sum in possible_sums:\n            new_sum = curr_sum + card\n            new_sums.add(new_sum)\n        \n        possible_sums = new_sums\n    \n    # If K is impossible to form, return 0\n    if K not in possible_sums:\n        return 0\n    \n    # Binary search to find minimum cards to remove\n    def can_prevent_k(cards_removed):\n        # Try to form K with remaining cards\n        current_possible_sums = {0}\n        for i, card in enumerate(A):\n            if i < cards_removed:\n                continue\n            \n            new_sums = current_possible_sums.copy()\n            for curr_sum in current_possible_sums:\n                new_sum = curr_sum + card\n                new_sums.add(new_sum)\n            \n            current_possible_sums = new_sums\n        \n        return K not in current_possible_sums\n    \n    # Binary search\n    left, right = 0, N\n    while left < right:\n        mid = (left + right) // 2\n        \n        if can_prevent_k(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\n# Read input\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\n# Print result\nprint(solve(N, A, K))",
    "timestamp": "2025-08-13 09:11:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    N, K = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    A.sort()\n    dp = [False] * (K + 1)\n    dp[0] = True\n    res = 0\n    \n    for i in range(N):\n        a = A[i]\n        # Check if 'a' is necessary for any sum <= K\n        is_necessary = False\n        for j in range(K, a - 1, -1):\n            if dp[j - a] and j <= K:\n                if j >= K - a + 1:\n                    is_necessary = True\n                    break\n        if not is_necessary:\n            res += 1\n        else:\n            for j in range(K, a - 1, -1):\n                if dp[j - a]:\n                    dp[j] = dp[j] or dp[j - a]\n    print(N - res)\n\nsolve()",
    "timestamp": "2025-08-13 09:11:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool canSumK(vector<int>& cards, int n, int k) {\n    vector<bool> dp(k + 1, false);\n    dp[0] = true;\n    for (int i = 0; i < n; ++i) {\n        for (int j = k; j >= cards[i]; --j) {\n            dp[j] = dp[j] || dp[j - cards[i]];\n        }\n    }\n    return dp[k];\n}\n\nint minCardsToEat(vector<int>& cards, int n, int k) {\n    sort(cards.rbegin(), cards.rend());\n    for (int i = 0; i < n; ++i) {\n        vector<int> remainingCards;\n        for (int j = 0; j < n; ++j) {\n            if (j != i) remainingCards.push_back(cards[j]);\n        }\n        if (!canSumK(remainingCards, n - 1, k)) {\n            return i + 1;\n        }\n    }\n    return n;\n}\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> cards(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> cards[i];\n    }\n    cout << minCardsToEat(cards, n, k) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:50:00"
  }
]