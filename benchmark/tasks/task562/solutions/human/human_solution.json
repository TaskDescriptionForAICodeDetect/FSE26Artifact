[
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst int mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-4;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>int LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>int UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tcout<<fixed<<setprecision(20);\n\t//O(6^(n/2))\n\tint i,j,n,K,bi,ans;cin>>n>>K;\n\tans=n;\n\tif(K>3e6*n){cout<<0<<endl;return 0;}\n\tint na=n/2,nb=n-na;\n\tint A[20];\n\tfor(i=0;i<n;i++){cin>>A[i];}\n\tvector<vector<int>>adp(1<<na);\n\tfor(bi=0;bi<(1<<na);bi++){\n\t\tvector<int>dp(1);\n\t\tfor(i=0;i<na;i++){\n\t\t\tif(bi&(1<<i)){\n\t\t\t\tint siz=dp.size();\n\t\t\t\tfor(j=0;j<siz;j++){dp.pub(dp[j]+A[i]);}\n\t\t\t}\n\t\t}\n\t\t\n\t\tSO(dp);\n\t\tdp.erase(unique(dp.begin(),dp.end()),dp.end());\n\t\tadp[bi]=dp;\n\t}\n\tvector<vector<int>>bdp(1<<nb);\n\tfor(bi=0;bi<(1<<nb);bi++){\n\t\tvector<int>dp(1);\n\t\tfor(i=0;i<nb;i++){\n\t\t\tif(bi&(1<<i)){\n\t\t\t\tint siz=dp.size();\n\t\t\t\tfor(j=0;j<siz;j++){dp.pub(dp[j]+A[i+na]);}\n\t\t\t}\n\t\t}\n\t\tSO(dp);\n\t\tdp.erase(unique(dp.begin(),dp.end()),dp.end());\n\t\tREV(dp);\n\t\tbdp[bi]=dp;\n\t}\n\tfor(bi=0;bi<(1<<n);bi++){\n\t\tint ku=0;\n\t\tfor(i=0;i<n;i++){if(bi&(1<<i)){ku++;}}\n\t\tku=n-ku;\n\t\tif(ku>=ans){continue;}\n\t\tint ax=bi&((1<<na)-1);\n\t\tint bx=bi>>na;\n\t\tbool can=true;\n\t\tint az=0,bz=0;\n\t\twhile(az<adp[ax].size()&&bz<bdp[bx].size()){\n\t\t\tif(adp[ax][az]+bdp[bx][bz]==K){can=false;break;}\n\t\t\tif(adp[ax][az]+bdp[bx][bz]<K){az++;}\n\t\t\telse{bz++;}\n\t\t}\n\t\tif(can){mineq(ans,ku);}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n\nconst int INF=0x3f3f3f3f;\nconst ll INFL=0x3f3f3f3f3f3f3f3f;\nconst int MOD=1000000007;\n\nint a[20];\nint dp[1<<20];\n\nint main(){\n\tint n,K;cin>>n>>K;\n\trep(i,n){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\trep(i,1<<n){\n\t\tint sum=0;\n\t\trep(j,n){\n\t\t\tif(i>>j&1)sum+=a[j];\n\t\t}\n\t\tif(sum==K)dp[i]=1;\n\t}\n\trep(i,n)rep(j,1<<n){\n\t\tif(!(j>>i&1))dp[j|1<<i]+=dp[j];\n\t}\n\tint Min=INT_MAX;\n\trep(i,1<<n){\n\t\tint x=((1<<n)-1)^(i);\n\t\tif(dp[x]==0){\n\t\t\tMin=min(Min,__builtin_popcount(i));\n\t\t}\n\t}\n\tcout<<Min<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define P pair<int,int>\n#define fi first\n#define se second\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1000000000000000000\n#define MOD 1000000007\n#define all(v) v.begin(),v.end()\n#define pb push_back\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nint kaijo[2000010];\nstruct edge{int to,cost;};\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n}\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\nbool prime(int a){\n    if(a==1)return false;\n    for(int i=2;i*i<=a;i++){\n        if(a%i==0)return false;\n    }\n    return true;\n}\nvoid init_fact(){\n    kaijo[0]=1;\n    for(int i=1;i<=2000000;i++){\n        kaijo[i]=kaijo[i-1]*i;\n        kaijo[i]%=MOD;\n    }\n}\nint modpow(int a,int b){\n    if(b==0)return 1;\n    if(b%2)return modpow(a,b-1)*a%MOD;\n    int memo=modpow(a,b/2);\n    return memo*memo%MOD;\n}\nint comb(int a,int b){\n    if(!kaijo[0])init_fact();\n    return kaijo[a]*modpow(kaijo[a-b],MOD-2)%MOD*modpow(kaijo[b],MOD-2)%MOD;\n}\nint inv(int x){\n    x=modpow(x,MOD-2);\n    return x;\n}\nbool kosa(double ax,double ay,double bx,double by,double cx,double cy,double dx,double dy){\n    double ta=(cx-dx)*(ay-cy)+(cy-dy)*(cx-ax);\n    double tb=(cx-dx)*(by-cy)+(cy-dy)*(cx-bx);\n    double tc=(ax-bx)*(cy-ay)+(ay-by)*(ax-cx);\n    double td=(ax-bx)*(dy-ay)+(ay-by)*(ax-dx);\n    return tc*td<0&&ta*tb<0;\n}\ndouble dist(double ax,double ay,double bx,double by){\n    return sqrt((bx-ax)*(bx-ax)+(ay-by)*(ay-by));\n}\nint n,k,a[21],ans;\nbool dp[(1<<20)];\nsigned main(){\n    cin>>n>>k;\n    rep(i,n)cin>>a[i];\n    for(int i=1;i<(1<<n);i++){\n        int sum=0;\n        rep(j,n)if((i>>j)&1)sum+=a[j];\n        if(sum==k)dp[i]=true;\n        rep(j,n){\n            if((i>>j)&1){\n                if(dp[i-(1<<j)])dp[i]=true;\n            }\n        }\n        if(dp[i]==false){\n            int cnt=0;\n            rep(j,n){\n                if((i>>j)&1)cnt++;\n            }\n            ans=max(ans,cnt);\n        }\n    }\n    cout<<n-ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef __cplusplus\n    cat << EOF\n#endif\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T, class U> inline bool chmax(T& lhs, const U& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T, class U> inline bool chmin(T& lhs, const U& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\nint N, K;\nint A[20];\nbitset<1 << 20> dp;\n\nint main() {\n\n    cin >> N >> K;\n    rep(i, N) cin >> A[i];\n\n    int ans = N;\n    rep(S, 1 << N) {\n        int sum = 0;\n        rep(i, N) if((1 << i) & S) sum += A[i];\n        if(sum == K || dp[S] == 1) {\n            dp[S] = 1;\n            rep(i, N) dp[S | (1 << i)] = 1;\n        } else {\n            chmin(ans, N - __builtin_popcount(S));\n        }\n    }\n\n    cout << ans << '\\n';\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma comment (linker, \"/STACK:256000000\")\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 2000000000000000000LL\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define seg_size 262144*2\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long a = 0;a < b;++a)\n#define ALL(x) (x).begin(),(x).end()\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nint bad_list[2000000];\nvoid solve() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> A;\n    REP(i, n) {\n        int a;\n        cin >> a;\n        A.push_back(a);\n    }\n    sort(ALL(A));\n    int now_itr = 0;\n    REP(i, (1 << n)) {\n        int ans = 0;\n        int now = i;\n        int q = 0;\n        for (q = 0; now != 0; q++) {\n            if (now % 2 == 1) {\n                ans += A[q];\n            }\n            now /= 2;\n        }\n        if (k == ans) {\n            bad_list[now_itr] = i;\n            now_itr++;\n        }\n    }\n    int ans = n;\n    int now_cnt = 0;\n    set<int> already_done;\n    for (int i = 0;; ++i) {\n        if (i % 100 == 0) {\n            if ((long double)clock() / (long double)CLOCKS_PER_SEC >= 0.90) {\n                break;\n            }\n        }\n        int now = 0;\n        int cnt = 0;\n        for (int q = 0; q < n; ++q) {\n            if (xor128() % 2LL == 1LL) {\n                now += (1 << q);\n            }\n            else {\n                cnt++;\n            }\n        }\n        if (ans > cnt&&already_done.find(now) == already_done.end()) {\n            already_done.insert(now);\n            now_cnt++;\n            int ok = 1;\n            REP(i, now_itr) {\n                if ((bad_list[i] & now) == bad_list[i]) {\n                    ok = 0;\n                    break;\n                }\n            }\n            if (ok == 1) {\n                ans = cnt;\n            }\n        }\n    }\n    cout << ans << endl;\n    return;\n}\n\nint main() {\n    init();\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n//#include <boost/multiprecision/cpp_int.hpp>\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n////////////////////////////\n\nint main(){fastio\n    ll n,k;cin>>n>>k;\n    ll a[n];rep(i,0,n-1)cin>>a[i];\n    ll sum[1<<n];memset(sum,0,sizeof(sum));\n    rep(i,0,(1<<n)-1){\n        rep(j,0,n-1){\n            if((i>>j)&1)sum[i]+=a[j];\n        }\n    }\n    bool f[1<<n];memset(f,false,sizeof(f));\n    rep(i,0,(1<<n)-1){\n        if(sum[i]==k)f[i]=true;\n    }\n    rep(i,0,(1<<n)-1){\n        if(f[i]){\n            rep(j,0,n-1){\n                f[i|(1<<j)]=true;\n            }\n        }\n    }\n    ll ans=0;\n    /*\n    rep(i,0,(1<<n)-1){\n        rep(j,0,n-1){\n            if((i>>j)&1)cout<<1;\n            else cout<<0;\n        }cout<<\":\"<<f[i]<<endl;\n    }*/\n    rep(i,0,(1<<n)-1){\n        if(!f[i]){\n            ll c=0;\n            rep(j,0,n-1){\n                if((i>>j)&1)c++;\n            }\n            Max(ans,c);\n        }\n    }\n    cout<<n-ans<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n,k;\n    cin >>n >>k;\n    vector<int> a(n);\n    rep(i,n) cin >>a[i];\n\n    vector<int> dp(1<<n,1);\n    rep(mask,1<<n){\n        int s = 0;\n        rep(i,n)if(mask>>i&1) s += a[i];\n        if(s == k) dp[mask] = 0;\n    }\n\n    rep(mask,1<<n)if(dp[mask] == 0){\n        rep(i,n)if(!(mask>>i&1)){\n            int nx = mask|(1<<i);\n            dp[nx] = 0;\n        }\n    }\n\n    int ans = n;\n    rep(mask,1<<n)if(dp[mask]) ans = min(ans, n-__builtin_popcount(mask));\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nbool ng[1<<20] = {};\nint popcnt[1<<20] = {};\n\nint main(){\n    int n, k;\n    cin >> n >> k;\n    int a[n], ret = n;\n    for(int i = 0; i < n; i++)  cin >> a[i];\n    for(int s = 1; s < 1<<n; s++){\n        int sum = 0;\n        for(int i = 0; i < n; i++)  if((s>>i)&1)    sum += a[i], popcnt[s]++;\n        ng[s] = sum==k;\n        for(int i = 0; i < n; i++)  if((s>>i)&1)    ng[s] |= ng[s^(1<<i)];\n        if(!ng[s])  ret = min(ret, n-popcnt[s]);\n    }\n    cout << ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nint main(){\n\tint n,k;\n\tcin>>n>>k;\n\tvector<ll> a(n);\n\trep(i,n)cin>>a[i];\n\tvector<int> ok(1<<n,1);\n\trep(i,1<<n){\n\t\tll sum=0;\n\t\trep(j,n)if((1<<j)&i)sum+=a[j];\n\t\tif(sum==k)ok[i]=0;\n\t}\n\trep(j,n)rep(i,1<<n)if((i&(1<<j))==0)ok[i|(1<<j)]&=ok[i];\n\tint ma=n;\n\trep(i,1<<n){\n\t\tif(ok[i])ma=min(ma,n-__builtin_popcount(i));\n\t}\n\tcout<<ma<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n \nint main() {\n    int N, K; cin >> N >> K;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n    vector<bool> ng(1 << N);\n    for(int bit=0; bit<(1<<N); bit++) {\n        int sum = 0;\n        for(int i=0; i<N; i++) {\n            if(bit >> i & 1) sum += A[i];\n        }\n        if(sum == K) {\n            ng[bit] = true;\n        }\n    }\n\n    for(int bit=0; bit<(1<<N); bit++) {\n        if(ng[bit] == false) continue;\n        for(int i=0; i<N; i++) {\n            ng[bit | (1 << i)] = true;\n        }\n    }\n\n    int ans = INF;\n    for(int bit=0; bit<(1<<N); bit++) {\n        if(ng[bit]) continue;\n        int c = __builtin_popcount(bit);\n        ans = min(ans, N - c);\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for (int i = 0; i < n; i++)cin >> a[i];\n\n    int ret = 0;\n    vector<bool> dp(1 << n);\n    for (int bit = 0; bit < 1 << n; bit++) {\n        int nowCount = 0, nowSum = 0;\n        bool canMake = false;\n        for (int i = 0; i < n; i++) {\n            if (bit & (1 << i)) {\n                nowCount++, nowSum += a[i];\n                if (dp[bit ^ (1 << i)])canMake = true;\n            }\n        }\n        if (canMake || nowSum == k) dp[bit] = true;\n        else ret = max(ret, nowCount);\n    }\n\n    cout << n - ret << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = 1e9+7;\n\nconst i64 INF = 1e18+7;\n\n\ntemplate <typename T = i64>\nbool chmax(T& a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T = i64>\nbool chmin(T& a, T b){\n    if(a > b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\nsigned main(){\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    int n, k;\n    cin >> n >> k;\n    vector<int> a(n);\n    for(auto& x : a)\n        cin >> x;\n    vector<int> flag(1 << n, 0);\n    for(int i = 0; i < (1 << n); ++i){\n        int sum = 0;\n        for(int j = 0; j < n; ++j)\n            if(i & (1 << j))\n                sum += a[j];\n        if(sum == k)\n            flag[i] = 1;\n    }\n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < (1 << n); ++j)\n            if(j & (1 << i))\n                flag[j] |= flag[j ^ (1 << i)];\n    int ans = n;\n    for(int i = 0; i < (1 << n); ++i)\n        if(flag[i] == 0)\n            chmin(ans, n - __builtin_popcount(i));\n    cout << ans << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nll f[1 << 20];\nll N, K;\nll A[21];\n\nll g(ll x) {\n    if(x == 0) return 0;\n    return (x & 1) + g(x / 2);\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> K;\n    for(int i = 0; i < N; i++) cin >> A[i];\n    for(int bits = 0; bits < (1 << 20); bits++) {\n        ll sum = 0;\n        for(int i = 0; i < N; i++) {\n            if(bits & (1 << i)) sum += A[i];\n        }\n        if(sum == K) f[bits]++;\n    }\n    for(int i = 0; i < N; i++) {\n        for(int j = 0; j < (1 << N); j++) {\n            if(j & (1 << i)) {\n                f[j] += f[j^(1<<i)];\n            }\n        }\n    }\n    ll ans = N;\n    for(int bits = 0; bits < (1 << N); bits++) {\n        if(f[bits]) continue;\n        chmin(ans, N - g(bits));\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[10000100];\n                int inv[10000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\n\nint dp[1<<20]={};\nsigned main(){\n\t\n\t\ncin.tie(0);\nios::sync_with_stdio(false);\n\tint n,k;\n\tcin>>n>>k;\n\tvector<int> ve(n);\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)cin>>ve[i];\n\tfor(int i=0;i<(1<<n);i++){\n\t\tint y=0;\n\t\tfor(int j=0;j<n;j++)if(i&(1<<j))y+=ve[j];\n\t\tif(y==k)dp[i]=1,cnt++;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<(1<<n);i*=2){\n\t\tfor(int j=0;j<(1<<n);j++)if((j&i)==0){\n\t\t\tdp[j|i]+=dp[j];\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<(1<<n);i++)if(dp[i]==0){\n\tans=max(ans,(int)__builtin_popcount(i));\n\t}\ncout<<n-ans<<endl;\n\treturn 0; \n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N, K; cin >> N >> K;\n    vector<int> A(N); for (auto &a : A) cin >> a;\n    vector<bool> B(1 << N);\n    int all = (1 << N) - 1;\n    for (int i = 0; i <= all; i++) {\n        int sum = 0;\n        for (int j = 0; j < N; j++) if (i & (1 << j)) {\n            sum += A[j];\n        }\n        if (sum == K) B[all ^ i] = true;\n    }\n    for (int i = all; i >= 0; i--) {\n        if (B[i]) {\n            for (int j = 0; j < N; j++) if (i & (1 << j)) {\n                B[i ^ (1 << j)] = true;\n            }\n        }\n    }\n    int ans = N;\n    for (int i = 0; i <= all; i++) {\n        if (!B[i]) {\n            ans = min(ans, __builtin_popcount(i));\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nint pop_count(int bits){\n    bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n    bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n    bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n    bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n    return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\nint main(){\n    int N, K;\n    cin >> N >> K;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n    bitset<(1<<20)> dp;\n    for(int i=0; i<(1<<N); i++){\n        int s = 0;\n        for(int k=0; k<N; k++) if(nth_bit(i, k)) s += A[k];\n        if(s == K) dp[i] = 1;\n    }\n    for(int k=0; k<N; k++) for(int i=0; i<(1<<N); i++) if(nth_bit(i, k)) dp[i] = dp[i] | dp[i-(1<<k)];\n    int ans = N;\n    for(int i=0; i<(1<<N); i++) if(!dp[i]) ans = min(ans, N - pop_count(i));\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\nint main() {\n  int N, K;\n  cin >> N >> K;\n  vector< int > A(N);\n  cin >> A;\n\n  vector< int > dame(1 << N);\n  for(int i = 0; i < (1 << N); i++) {\n    int64 X = 0;\n    for(int j = 0; j < N; j++) {\n      if((i >> j) & 1) {\n        X += A[j];\n      }\n    }\n    if(X == K) dame[i] = 1;\n  }\n\n  for(int i = 0; i < (1 << N); i++) {\n    if(dame[i]) {\n      for(int j = 0; j < N; j++) {\n        dame[i | (1 << j)] = true;\n      }\n    }\n  }\n  int ret = 0;\n  for(int i = 0; i < (1 << N); i++) {\n    if(dame[i]) continue;\n    chmax(ret, __builtin_popcount(i));\n  }\n  cout << N - ret << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint N,K,A[20];\nint S[1<<20];\nbool exs[1<<20];\nmain()\n{\n\tcin>>N>>K;\n\tfor(int i=0;i<N;i++)cin>>A[i];\n\tint ans=0;\n\tfor(int i=0;i<1<<N;i++)\n\t{\n\t\tfor(int j=0;j<N;j++)if(i>>j&1)S[i]+=A[j];\n\t\texs[i]=S[i]==K;\n\t\tfor(int j=0;j<N;j++)\n\t\t{\n\t\t\tif(i>>j&1)exs[i]|=exs[i&~(1<<j)];\n\t\t}\n\t\tif(!exs[i])ans=max(ans,__builtin_popcount(i));\n\t}\n\tcout<<N-ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <utility>\n#include <queue>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, k;\nllint a[1<<20];\n\nvoid zeta_transform(llint a[], int n)\n{\n\tint S = 1<<n;\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < S; j++){\n\t\t\tif((j&(1<<i))) a[j] += a[j^(1<<i)];\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> k;\n\tfor(int i = 0; i < n; i++) cin >> a[1<<i];\n\t\n\tzeta_transform(a, n);\n\tfor(int i = 0; i < (1<<n); i++){\n\t\tif(a[i] == k) a[i] = 1;\n\t\telse a[i] = 0;\n\t}\n\tzeta_transform(a, n);\n\t\n\tllint ans = n+1;\n\tfor(int i = 0; i < (1<<n); i++){\n\t\tif(a[i]) continue;\n\t\tllint cnt = 0;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tif(i & (1<<j)) cnt++;\n\t\t}\n\t\tans = min(ans, n-cnt);\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint dp[(1<<20)];\n\nvoid chmax(int &a,int b){\n  if(a<b) a=b;\n}\n\nint main(){\n  int N;\n  ll K;\n  cin>>N>>K;\n  vector<ll> A(N);\n  rep(i,N) cin>>A[i];\n\n  for(int i=1;i<(1<<N);i++){\n    ll res=0;\n    for(int j=0;j<N;j++){\n      if(i&(1<<j)){\n        chmax(dp[i],dp[i^(1<<j)]);\n        res+=A[j];\n      }\n    }\n\n    if(res==K) dp[i]=1;\n  }\n\n  int ans=N;\n  for(int i=1;i<(1<<N);i++){\n    if(dp[i]) continue;\n    int num=0;\n    for(int j=0;j<N;j++){\n      if(i&(1<<j)) num++;\n    }\n    ans=min(ans,N-num);\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(10);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\nusing P = pair<int,int>; using vp = vector<P>;\nconstexpr int MOD = /** 1000000007; //*/ 998244353;\n////////////////\n\n\n\nvoid solve(){\n\n  ini(N); inl(K);\n  vl a(N); in(a);\n\n  vector<int> s(1 << N , 0);\n\n  rep(b , 1 << N){\n    ll cur = 0;\n    rep(k , N){\n      if((b >> k) & 1) cur += a[k];\n    }\n    if(cur == K) s[b] = 1;\n  }\n  //rep(b , 1 << N) trc(s[b]);\n\nrep(i,N) rep(j,1<<N) if (j&(1<<i)) s[j] |= s[j^(1<<i)];\n  ll ans = N;\n  rep(i , 1 << N){\n    //trc(i , s[i]);\n    if(s[i] == 0) amin(ans , N - __builtin_popcount(i));\n  }\n  out(ans);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0;i < (int)(n);i++)\n#define RREP(i,n) for(int i = (int)n-1;i >= 0;i--)\n#define FOR(i,s,n) for(int i = s;i < (int)n;i++)\n#define RFOR(i,s,n) for(int i = (int)n-1;i >= s;i--)\n#define ALL(a) a.begin(),a.end()\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a = b;return true;}return false;}\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<class T>inline void OUT(T t){cout<<t<<\"\\n\";}\ntemplate<class T,class... Ts>inline void OUT(T t,Ts... ts){cout<<t<<\" \";OUT(ts...);}\ntemplate<typename T=int>vector<T>mv(size_t a){return vector<T>(a);}\ntemplate<typename T=int,typename... Ts>auto mv(size_t a,Ts... ts){return vector<decltype(mv<T>(ts...))>(a,mv<T>(ts...));}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value==0>::type FILL(T&t,const V&v){t=v;}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value!=0>::type FILL(T&t,const V&v){for(auto &e:t)FILL(e,v);}\nconstexpr long long INF = 1e18;\n\nint dp[1ll<<20];\nsigned main(){\n\tint N,K;\n\tcin>>N>>K;\n\tauto a = mv(N);\n\tcin>>a;\n\tREP(i,1ll<<N){\n\t\tint s = 0;\n\t\tREP(j,N){\n\t\t\tif(i&(1ll<<j))s+=a[j];\n\t\t}\n\t\tif(s==K)dp[i]=1;\n\t}\n\tREP(i,1ll<<N){\n\t\tif(dp[i]==0)continue;\n\t\tREP(j,N){\n\t\t\tif(i&(1ll<<j))continue;\n\t\t\tdp[i^(1ll<<j)]|=dp[i];\n\t\t}\n\t}\n\tint ans = N;\n\tREP(i,1ll<<N){\n\t\tif(dp[i])continue;\n\t\tint cnt = 0;\n\t\tREP(j,N){\n\t\t\tif(i&(1ll<<j))cnt++;\n\t\t}\n\t\tCHMIN(ans,N-cnt);\n\t}\n\tOUT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-6;\nconst ld pi = acos(-1.0);\ntypedef vector<vector<ll>> mat;\ntypedef vector<ll> vec;\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tvector<int> a(n);\n\trep(i, n)cin >> a[i];\n\tvector<bool> exi(1 << n, false);\n\trep(i, (1 << n)) {\n\t\tint s = 0;\n\t\trep(j, n) {\n\t\t\tif (i&(1 << j))s += a[j];\n\t\t}\n\t\tif (s == k)exi[i] = true;\n\t}\n\trep(i, (1 << n)) {\n\t\tif (!exi[i])continue;\n\t\trep(j, n) {\n\t\t\tif (i&(1 << j))continue;\n\t\t\texi[i ^ (1 << j)] = true;\n\t\t}\n\t}\n\tint ans = n;\n\trep(i, (1 << n)) {\n\t\tint tmp = 0;\n\t\trep(j, n) {\n\t\t\tif (i&(1 << j))tmp++;\n\t\t}\n\t\tif (!exi[i]) {\n\t\t\tans = min(ans, n - tmp);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(8);\n\t//init();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n\n//#define TEST\n\nint bitcount(int f) {\n\tint cnt = 0;\n\twhile (f) {\n\t\tcnt += (f & 1);\n\t\tf /= 2;\n\t}\n\treturn cnt;\n}\n\nsigned main() {\n\t// 入力の受け取り\n\tint n, k; cin >> n >> k;\n\tvector<int> a(n);\n\tfor (int i = 0; i < n; ++i) cin >> a[i];\n\t// 和をkにできるカードのとり方をbit全探索\n\tvector<bool> ok((1 << n), false);\n\tfor (int f = 0; f < (1 << n); ++f) {\n\t\t// 全部取ってちょうどkか判定する\n\t\tint total = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (f & (1 << i))\n\t\t\t\ttotal += a[i];\n\t\tif (total == k) ok[f] = true;\n\t\t// 一部取ってちょうどkか判定する\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (f & (1 << i))\n\t\t\t\tok[f] = ok[f] || ok[f ^ (1 << i)];\n\t}\n#ifdef TEST\n\tfor (int f = 0; f < (1 << n); ++f)\n\t\tif (!ok[f])\n\t\t\tcout << f << \" \";\n\tcout << endl;\n#endif\n\t// !ok[f]なfについて、n-bitcount(f)のminを求める\n\tint res = n;\n\tfor (int f = 0; f < (1 << n); ++f)\n\t\tif (!ok[f])\n\t\t\tres = min(res, n - bitcount(f));\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<endl;\n\t#else\n\tcout<<\"Possible\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<endl;\n\t#else\n\tcout<<\"Impossible\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,k;cin>>n>>k;\n\tvi a=readvi(n);\n\tint s=1<<n;\n\tvi z(s);\n\trep(bit,s){\n\t\tint c=0;\n\t\trep(i,n)if(bit&1<<i)\n\t\t\tc+=a[i];\n\t\tif(c==k)\n\t\t\tz[bit]=1;\n\t}\n\trep(i,n)rep(bit,s)if((bit&1<<i)==0)\n\t\tz[bit|1<<i]|=z[bit];\n\tint ans=0;\n\trep(bit,s)if(z[bit]==0)\n\t\tchmax(ans,popcount(bit));\n\tprint(n-ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> void fzt(vector<T>& a) {\n  int n = a.size();\n  assert(__builtin_popcount(n) == 1);\n  for (int i = 0; 1 << i < n; ++i) {\n    for (int S = 0; S < n; ++S) if (~S & 1 << i) {\n      a[S | 1 << i] += a[S];\n    }\n  }\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, k;\n  cin >> n >> k;\n  vector<int> a(n);\n  for (auto&& e : a) {\n    cin >> e;\n  }\n  vector<int> f(1 << n);\n  for (int s = 0; s < 1 << n; ++s) {\n    int sum = 0;\n    for (int i = 0; i < n; ++i) {\n      if (s >> i & 1) {\n        sum += a[i];\n      }\n    }\n    f[s] = sum == k;\n  }\n  fzt(f);\n  int res = 0;\n  for (int s = 0; s < 1 << n; ++s) {\n    if (f[s] == 0) {\n      res = max(res, __builtin_popcount(s));\n    }\n  }\n  cout << n - res << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"O3\")\n#pragma GCC optimization (\"unroll-loops\")\n#include <algorithm>\n#include <assert.h>\n#include <bitset>\n#include <cfloat>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits.h>\n#include <list>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <string.h>\n#include <time.h>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(i,n) for(int i=1;i<=n;i++)\n#define int long long\n#define ll long long\n#define eps LDBL_EPSILON\n#define mod (int)1000000007\n#define INF LLONG_MAX/10\n#define P pair<int,int>\n#define prique priority_queue\nusing namespace std;\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a % b);\n}\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\nbool isprime(int n) {\n\tif (n == 1)return false;\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0)return false;\n\t}\n\treturn true;\n}\nint mypow(int a, int b) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a;\n\tint memo = mypow(a, b >> 1);\n\treturn memo * memo;\n}\nint modpow(int a, int b, int m = mod) {\n\tif (!b)return 1;\n\tif (b & 1)return mypow(a, b - 1) * a % m;\n\tint memo = mypow(a, b / 2);\n\treturn memo * memo % m;\n}\nclass modInt {\n\tint value, modulo;\npublic:\n\tconstexpr modInt() : value(0), modulo(mod) { value = 0; }\n\ttemplate<typename T>\n\tconstexpr modInt(T value = 0, int modulo = mod) : value(value), modulo(modulo) {\n\t\tthis->value += T(modulo) * max((int)1, -value / modulo + 1);\n\t\tthis->value %= T(modulo);\n\t}\n\tinline constexpr operator int()const { return value; }\n\tinline constexpr modInt& operator+=(modInt x) {\n\t\tvalue += x.value;\n\t\tif (value >= modulo)value -= modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator++() {\n\t\tif (value == modulo - 1)value = 0;\n\t\telse value++;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator-()const {\n\t\treturn modInt(0) -= *this;\n\t}\n\tinline constexpr modInt& operator-=(modInt x) {\n\t\tvalue -= x.value;\n\t\tif (value < 0)value += modulo;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator--() {\n\t\tif (value == 0)value = modulo - 1;\n\t\telse value--;\n\t\treturn *this;\n\t}\n\tinline constexpr modInt& operator*=(modInt x) {\n\t\tvalue = value * x.value % mod;\n\t\treturn *this;\n\t}\n\tinline modInt& operator/=(modInt x) {\n\t\treturn operator*=(x.inv());\n\t}\n\tstatic modInt pow(modInt x, int y) {\n\t\tif (!y)return 1;\n\t\tif (y & 1)return pow(x, y - 1) * x;\n\t\tmodInt memo = pow(x, y / 2);\n\t\treturn memo * memo;\n\t}\n\tinline modInt inv() {\n\t\treturn pow(*this, modulo - 2);\n\t}\n\ttemplate<typename T> modInt operator+(T x) { return modInt(*this) += x; }\n\ttemplate<typename T> modInt& operator+=(T x) { return operator+=(modInt(x)); }\n\ttemplate<typename T> modInt operator-(T x) { return modInt(*this) -= x; }\n\ttemplate<typename T> modInt& operator-=(T x) { return operator-=(modInt(x)); }\n\ttemplate<typename T> modInt operator*(T x) { return modInt(*this) *= x; }\n\ttemplate<typename T> modInt& operator*=(T x) { return operator*=(modInt(x)); }\n\ttemplate<typename T> modInt operator/(T x) { return modInt(*this) /= x; }\n\ttemplate<typename T> modInt& operator/=(T x) { return operator/=(modInt(x)); }\n};\nistream& operator>>(istream& ist, modInt& x) {\n\tint a;\n\tist >> a;\n\tx = a;\n\treturn ist;\n}\nint modpow(modInt a, int b, int m = mod) {\n\tif (!b)return modInt(1);\n\tif (b & 1)return mypow(a, b - 1) * a % m;\n\tmodInt memo = mypow(a, b / 2);\n\treturn memo * memo;\n}\nclass UnionFind {\nprotected:\n\tint* par, * rank, * size;\npublic:\n\tUnionFind(unsigned int size) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tthis->size = new int[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tthis->size[i] = 1;\n\t\t}\n\t}\n\tint find(int n) {\n\t\tif (par[n] == n)return n;\n\t\treturn par[n] = find(par[n]);\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m)return;\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tsize[m] += size[n];\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tsize[n] += size[m];\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t}\n\tbool same(int n, int m) {\n\t\treturn find(n) == find(m);\n\t}\n\tint getsize(int n) {\n\t\treturn size[find(n)];\n\t}\n};\nclass PerpetualUnionFind :UnionFind {\n\tP* notparent;\n\tvector<P>* sizevec;\n\tint opcount = 0;\npublic:\n\tPerpetualUnionFind(unsigned int size) :UnionFind(size) {\n\t\tthis->sizevec = new vector<P>[size];\n\t\tnotparent = new P[size];\n\t\trep(i, size) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsizevec[i].push_back(make_pair(-1, 1));\n\t\t\tnotparent[i] = make_pair(INF, i);\n\t\t}\n\t}\n\tint find(int n, int t = INF) {\n\t\tif (opcount <= t) {\n\t\t\tif (par[n] == n)return n;\n\t\t\treturn par[n] = find(par[n]);\n\t\t}\n\t\tif (notparent[n].first <= t)return find(notparent[n].second, t);\n\t\treturn n;\n\t}\n\tvoid unite(int n, int m) {\n\t\tn = find(n);\n\t\tm = find(m);\n\t\tif (n == m) {\n\t\t\topcount++;\n\t\t\treturn;\n\t\t}\n\t\tif (rank[n] < rank[m]) {\n\t\t\tpar[n] = m;\n\t\t\tnotparent[n] = make_pair(opcount, m);\n\t\t\tsizevec[m].push_back(make_pair(opcount, sizevec[m].back().second + sizevec[n].back().second));\n\t\t}\n\t\telse {\n\t\t\tpar[m] = n;\n\t\t\tnotparent[m] = make_pair(opcount, n);\n\t\t\tsizevec[n].push_back(make_pair(opcount, sizevec[n].back().second + sizevec[m].back().second));\n\t\t\tif (rank[n] == rank[m])rank[n]++;\n\t\t}\n\t\topcount++;\n\t}\n\tbool same(int n, int m, int t = INF) {\n\t\treturn find(n, t) == find(m, t);\n\t}\n\tint getsize(int n, int t = INF) {\n\t\tn = find(n, t);\n\t\tauto ite = lower_bound(sizevec[n].begin(), sizevec[n].end(), make_pair(t, (int)0));\n\t\tif (ite == sizevec[n].end())ite--;\n\t\tif (t < (*ite).first)ite--;\n\t\treturn (*ite).second;\n\t}\n};\nclass RollingHash {\n\tstring s;\n\tint n, m;\n\tmodInt base;\n\tdeque<modInt> has;\npublic:\n\tRollingHash(string s, int m, int b) : n(s.size()), m(m), base(b, m) { init(s, m, b); }\n\tvoid init(string s, int m, int b) {\n\t\tn = s.size();\n\t\thas.resize(n);\n\t\tbase = b;\n\t\tthis->s = s;\n\t\tthis->m = m;\n\t\trep(i, n) {\n\t\t\thas[i] = (int)s[i];\n\t\t\tif (i)has[i] += base * has[i - 1] % m;\n\t\t}\n\t}\n\toperator int() const {\n\t\treturn has.back();\n\t}\n\tvoid cut(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\trep(i, a)has.pop_front();\n\t\trep(i, n - b)has.pop_back();\n\t\ts = s.substr(a, b);\n\t\tmodInt memo = mypow(mypow(base, n - b), m - 2);\n\t\trep(i, b - a)has[i] *= memo;\n\t\tn = b - a;\n\t}\n\tint query(int a, int b) {\n\t\tassert(!(a >= b || a < 0 || n < b));\n\t\treturn has[b - 1] - mypow(base, b - a) * (!a ? modInt(0) : has[a - 1]);\n\t}\n\tint operator+(RollingHash t) {\n\t\tassert(m == t.m && base == t.base);\n\t\treturn (has[n - 1] * mypow(base, t.n) % m + t.has[t.n - 1]) % m;\n\t}\n\tRollingHash& operator+=(string t) {\n\t\ts += t;\n\t\thas.resize(n + t.size());\n\t\tfor (int i = n; i < n + t.size(); i++) {\n\t\t\thas[i] = (int)t[i] * base;\n\t\t\thas[i] += base * has[i - 1];\n\t\t}\n\t\tn += t.size();\n\t\treturn *this;\n\t}\n};\ntemplate<typename T, typename U>\nclass SegTree {\n\tint n = 1;\n\tT* node = NULL;\n\tU* lazy = NULL;\n\tbool* lazyflag = NULL;\n\tT nodee;\n\tfunction<T(T, T)> nodef;\n\tfunction<U(U, U)> lazyf;\n\tfunction<T(int, T, U)> updf;\n\tvoid eval(int k, int l, int r) {\n\t\tif (lazyflag[k]) {\n\t\t\tnode[k] = updf(r - l, node[k], lazy[k]);\n\t\t\tif (r - l > 1) {\n\t\t\t\tlazyflag[2 * k + 1] = lazyflag[2 * k + 2] = true;\n\t\t\t\tlazy[2 * k + 1] = lazyf(lazy[2 * k + 1], lazy[k]);\n\t\t\t\tlazy[2 * k + 2] = lazyf(lazy[2 * k + 2], lazy[k]);\n\t\t\t}\n\t\t\tlazyflag[k] = false;\n\t\t}\n\t}\npublic:\n\tSegTree(int m, int init, T nodee, function<T(T, T)> nodef, function<U(U, U)> lazyf, function<T(int, T, U)> updf) :nodee(nodee), nodef(nodef), lazyf(lazyf), updf(updf) {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t\twhile (n < m)n *= 2;\n\t\tnode = new T[2 * n], lazy = new U[2 * n], lazyflag = new bool[2 * n];\n\t\trep(i, 2 * n) {\n\t\t\tnode[i] = init;\n\t\t\tlazyflag[i] = false;\n\t\t}\n\t}\n\t~SegTree() {\n\t\tdelete[] node;\n\t\tdelete[] lazy;\n\t}\n\tvoid update(int a, int b, U x, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tlazyflag[k] = true;\n\t\t\tlazy[k] = x;\n\t\t\teval(k, l, r);\n\t\t}\n\t\telse {\n\t\t\tupdate(a, b, x, 2 * k + 1, l, (l + r) / 2);\n\t\t\tupdate(a, b, x, 2 * k + 2, (l + r) / 2, r);\n\t\t\tnode[k] = nodef(node[2 * k + 1], node[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r == -1)r = n;\n\t\teval(k, l, r);\n\t\tif (b <= l || r <= a)return nodee;\n\t\tif (a <= l && r <= b)return node[k];\n\t\tT vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n\t\tT vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n\t\treturn nodef(vl, vr);\n\t}\n};\ntemplate<typename T>\nclass RAQRSQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRAQRSQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + range * b; }) {};\n};\ntemplate<typename T>\nclass RAQRMQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRAQRMQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return min(a, b); }, [](T a, T b) {return a + b; }, [](int range, T a, T b) {return a + b; }) {};\n};\ntemplate<typename T>\nclass RUQRSQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRSQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return a + b; }, [](T a, T b) {return b; }, [](int range, T a, T b) {return range * b; }) {};\n};\ntemplate<typename T>\nclass RUQRMQ :public SegTree<T, T> {\n\tusing base = SegTree<T, T>;\npublic:\n\tRUQRMQ(int size, const T& def = T()) :base(size, def, T(), [](T a, T b) {return min(a, b); }, [](T a, T b) {return b; }, [](int range, T a, T b) {return b; }) {};\n};\ntemplate<typename T>\nclass BIT {\n\tint n;\n\tT* bit;\npublic:\n\tBIT(int n) :n(n) {\n\t\tbit = new T[n];\n\t\tfill(bit, bit + n, T());\n\t}\n\tvoid add(int a, T x) {\n\t\twhile (a < n) {\n\t\t\tbit[a] += x;\n\t\t\ta += a & -a;\n\t\t}\n\t}\n\tT query(int a) {\n\t\tint cnt = 0;\n\t\twhile (a > 0) {\n\t\t\tcnt += bit[a];\n\t\t\ta -= a & -a;\n\t\t}\n\t\treturn cnt;\n\t}\n};\ntemplate<typename T>\nclass Matrix {\n\tint n;\n\tT zero, e;\n\tvector<vector<T>> vec;\n\tvoid letmeasure() {\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\tif (i != j)vec[i][j] = zero;\n\t\t\t\telse vec[i][j] = e;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tMatrix(int n, T zero, T e) :n(n), zero(zero), e(e) {\n\t\tvec.resize(n, vector<T>(n));\n\t}\n\tMatrix(int n, T zero, T e, vector<int> vec) :n(n), zero(zero), e(e) {\n\t\tif (vec.size() != n * n) {\n\t\t\tcerr << \"Invalid construct of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tthis->vec.resize(n, vector<T>(n));\n\t\trep(i, n) {\n\t\t\trep(j, n)this->vec[i][j] = vec[i * n + j];\n\t\t}\n\t}\n\tT& operator[](int a) {\n\t\treturn vec[a / n][a % n];\n\t}\n\tunsigned int size() { return n; }\n\tMatrix operator*(const Matrix a) {\n\t\tif (this->n != a.n) {\n\t\t\tcerr << \"Invalid multiply of matrix\" << endl;\n\t\t\texit(1);\n\t\t}\n\t\tvector<T> memo(n);\n\t\trep(i, n) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tmemo[j] += vec[i][k] * a.vec[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tvec[i] = memo;\n\t\t\tmemo.clear();\n\t\t\tmemo.resize(n);\n\t\t}\n\t\treturn *this;\n\t}\n\tstatic Matrix<T> measure(int n, T zero, T e) {\n\t\tMatrix<T> res(n, zero, e);\n\t\tres.letmeasure();\n\t\treturn res;\n\t}\n};\nclass mycomplex {\n\tdouble realvalue, imagvalue;\npublic:\n\tmycomplex() :realvalue(0), imagvalue(0) {}\n\tmycomplex(double realvalue, double imagvalue) : realvalue(realvalue), imagvalue(imagvalue) {}\n\tmycomplex(double realvalue) : realvalue(realvalue), imagvalue(0) {}\n\tmycomplex(complex<double> c) :realvalue(c.real()), imagvalue(c.imag()) {}\n\tmycomplex(const mycomplex& rhs) :realvalue(rhs.realvalue), imagvalue(rhs.imagvalue) {}\n\tdouble real()const { return this->realvalue; }\n\tdouble imag()const { return this->imagvalue; }\n\tdouble abs() { return hypot(realvalue, imagvalue); }\n\tmycomplex& operator=(const mycomplex& obj) {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = obj.realvalue;\n\t\t\tthis->imagvalue = obj.imagvalue;\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator=(mycomplex&& obj)noexcept {\n\t\tif (this != &obj) {\n\t\t\tthis->realvalue = exchange(obj.realvalue, 0);\n\t\t\tthis->imagvalue = exchange(obj.imagvalue, 0);\n\t\t}\n\t\treturn *this;\n\t}\n\tmycomplex& operator+=(const mycomplex& rhs) {\n\t\tthis->realvalue += rhs.realvalue;\n\t\tthis->imagvalue += rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator+(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs += rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator-=(const mycomplex& rhs) {\n\t\tthis->realvalue -= rhs.realvalue;\n\t\tthis->imagvalue -= rhs.imagvalue;\n\t\treturn *this;\n\t}\n\tmycomplex& operator-=(const double& rhs) {\n\t\tthis->realvalue -= rhs;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator-(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs -= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator*=(const mycomplex& rhs) {\n\t\tdouble pastreal = this->realvalue;\n\t\tthis->realvalue = this->realvalue * rhs.realvalue - this->imagvalue * rhs.imagvalue;\n\t\tthis->imagvalue = pastreal * rhs.imagvalue + rhs.realvalue * this->imagvalue;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator*(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs *= rhs;\n\t\treturn lhs;\n\t}\n\tmycomplex& operator/=(const mycomplex& rhs) {\n\t\t*this *= mycomplex(rhs.real(), -rhs.imag());\n\t\tdouble dnm = rhs.real() * rhs.real() - rhs.imag() * rhs.imag();\n\t\tthis->realvalue /= dnm;\n\t\tthis->imagvalue /= dnm;\n\t\treturn *this;\n\t}\n\tfriend mycomplex operator/(mycomplex lhs, const mycomplex& rhs) {\n\t\tlhs /= rhs;\n\t\treturn lhs;\n\t}\n};\nclass FastFourierTransform {\nprivate:\n\tstatic void dft(vector<mycomplex>& func, int inverse) {\n\t\tint sz = func.size();\n\t\tif (sz == 1)return;\n\t\tvector<mycomplex> veca, vecb;\n\t\trep(i, sz / 2) {\n\t\t\tveca.push_back(func[2 * i]);\n\t\t\tvecb.push_back(func[2 * i + 1]);\n\t\t}\n\t\tdft(veca, inverse); dft(vecb, inverse);\n\t\tmycomplex now = 1, zeta = polar(1.0, inverse * 2.0 * acos(-1) / sz);\n\t\trep(i, sz) {\n\t\t\tfunc[i] = veca[i % (sz / 2)] + now * vecb[i % (sz / 2)];\n\t\t\tnow *= zeta;\n\t\t}\n\t}\npublic:\n\ttemplate<typename T>\n\tstatic vector<double> multiply(vector<T> f, vector<T> g) {\n\t\tvector<mycomplex> nf, ng;\n\t\tint sz = 1;\n\t\twhile (sz < f.size() + g.size())sz *= 2;\n\t\tnf.resize(sz); ng.resize(sz);\n\t\trep(i, f.size()) {\n\t\t\tnf[i] = f[i];\n\t\t\tng[i] = g[i];\n\t\t}\n\t\tdft(nf, 1);\n\t\tdft(ng, 1);\n\t\trep(i, sz)nf[i] *= ng[i];\n\t\tdft(nf, -1);\n\t\tvector<double> res;\n\t\trep(i, sz)res.push_back(nf[i].real() / sz);\n\t\treturn res;\n\t}\n};\nint n, k, a[25], dp[1100000];\nsigned main() {\n\tcin >> n >> k;\n\trep(i, n)cin >> a[i];\n\trep(i, 1 << n)dp[i] = true;\n\tint ans = n;\n\trep(i, 1 << n) {\n\t\tint cnt = 0, bits = 0;\n\t\trep(j, n) {\n\t\t\tif (i & (1 << j)) {\n\t\t\t\tcnt += a[j];\n\t\t\t\tbits++;\n\t\t\t}\n\t\t}\n\t\tif (cnt == k)dp[i] = false;\n\t\tif (dp[i])ans = min(ans, n - bits);\n\t\telse {\n\t\t\trep(j, n) {\n\t\t\t\tdp[i | (1 << j)] &= dp[i];\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\nusing i8 = std::int_fast8_t;\nusing i32 = std::int_fast32_t;\nusing i64 = std::int_fast64_t;\nusing u8 = std::uint_fast8_t;\nusing u32 = std::uint_fast32_t;\nusing u64 = std::uint_fast64_t;\nusing isize = std::ptrdiff_t;\nusing usize = std::size_t;\n\nstruct rep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { ++i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\nstruct revrep {\n  struct itr {\n    usize i;\n    constexpr itr(const usize i) noexcept : i(i) {}\n    void operator++() noexcept { --i; }\n    constexpr usize operator*() const noexcept { return i; }\n    constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n  };\n  const itr f, l;\n  constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n  constexpr auto begin() const noexcept { return f; }\n  constexpr auto end() const noexcept { return l; }\n};\ntemplate <class T> auto md_vec(const usize n, const T &value) {\n  return std::vector<T>(n, value);\n}\ntemplate <class... Args> auto md_vec(const usize n, Args... args) {\n  return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n}\ntemplate <class T> constexpr T difference(const T &a, const T &b) noexcept {\n  if (a < b) {\n    return b - a;\n  } else {\n    return a - b;\n  }\n}\ntemplate <class T> void chmin(T &a, const T &b) noexcept {\n  if (b < a) {\n    a = b;\n  }\n}\ntemplate <class T> void chmax(T &a, const T &b) noexcept {\n  if (a < b) {\n    a = b;\n  }\n}\ntemplate <class F> class fix_point : private F {\npublic:\n  explicit constexpr fix_point(F &&f) : F(std::forward<F>(f)) {}\n\n  template <class... Args>\n  constexpr decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, std::forward<Args>(args)...);\n  }\n};\ntemplate <class F> constexpr decltype(auto) make_fix(F &&f) {\n  return fix_point<F>(std::forward<F>(f));\n}\ntemplate <class T> T scan() {\n  T ret;\n  std::cin >> ret;\n  return ret;\n}\n\n} // namespace n91\n#include <cstddef>\n#include <cstdint>\n\nconstexpr std::size_t popcount32(std::uint_fast32_t c) noexcept {\n#ifdef _GNUC_\n  return __builtin_popcount(c);\n#else\n  c -= c >> 1 & 0x55555555;\n  c = (c & 0x33333333) + (c >> 2 & 0x33333333);\n  c = (c + (c >> 4)) & 0x0F0F0F0F;\n  return c * 0x01010101 >> 24 & 0x3F;\n#endif\n}\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\ntemplate <class T, class Operation = std::plus<T>>\nvoid superset_zeta_transform(std::vector<T> &a,\n                             const Operation &oper = Operation()) {\n  const usize n = a.size();\n  for (usize i = 1; i < n; i *= 2) {\n    for (usize j = 0; j != n; j += 1) {\n      if ((j & i) != 0) {\n        a[j & ~i] = oper(a[j & ~i], a[j]);\n      }\n    }\n  }\n}\n\nvoid main_() {\n  /*\n  std::ios::sync_with_stdio(false);\n  std::cin.tie(nullptr);\n  //*/\n  const usize n = scan<usize>();\n  const u64 k = scan<u64>();\n  std::vector<u64> a(n);\n  for (auto &e : a) {\n    std::cin >> e;\n  }\n  std::vector<bool> b(1 << n, true);\n  for (const usize s : rep(0, 1 << n)) {\n    u64 sum = 0;\n    for (const usize i : rep(0, n)) {\n      if (s >> i & 1) {\n        sum += a[i];\n      }\n    }\n    if (sum == k) {\n      b[(1 << n) - 1 - s] = false;\n    }\n  }\n  superset_zeta_transform(b, std::logical_and<bool>());\n  usize ans = n;\n  for (const usize s : rep(0, 1 << n)) {\n    if (b[s]) {\n      chmin(ans, popcount32(s));\n    }\n  }\n  std::cout << ans << std::endl;\n}\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <unordered_map>\n#include <unordered_set>\n#include <tuple>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\n\nint bit_count(int value) {\n\treturn value == 0 ? 0 : value % 2 + bit_count(value >> 1);\n}\nint main() {\n\tint n, k; std::cin >> n >> k;\n\tstd::vector<int> cards(n); for (auto& c : cards) std::cin >> c;\n\tstd::vector<bool> can_make(1 << n, false);\n\tfor (auto i = 0; i < 1 << n; ++i) {\n\t\tif (!can_make[i]) {\n\t\t\tint sum = 0;\n\t\t\tfor (auto j = 0; j < n; ++j) if ((i & (1 << j)) != 0) {\n\t\t\t\tsum += cards[j];\n\t\t\t}\n\t\t\tcan_make[i] = sum == k;\n\t\t}\n\t\tif (can_make[i]) {\n\t\t\tfor (auto j = 0; j < n; ++j) {\n\t\t\t\tcan_make[i | (1 << j)] = can_make[i | (1 << j)] || can_make[i];\n\t\t\t}\n\t\t}\n\t}\n\tint max_bit = 0;\n\tfor (auto i = 0; i < can_make.size(); ++i) if (!can_make[i]) {\n\t\tmax_bit = std::max(max_bit, bit_count(i));\n\t}\n\tstd::cout << n - max_bit << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    vector<int> v(n);\n    for (auto &&i : v) scanf(\"%d\", &i);\n    vector<int> dp(1 << n), dp2(1 << n), cnt(1 << n);\n    int s = 0;\n    for (int i = 0; i < (1 << n); ++i) {\n        for (int j = 0; j < n; ++j) {\n            if(i & (1 << j)){\n                dp[i] = dp[i^(1 << j)] + v[j];\n                cnt[i] = cnt[i^(1 << j)]+1;\n                if(dp[i] == k) dp2[(1 << n)-i-1] = -1, s++;\n                break;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < (1 << n); ++j) {\n            if(!(j & (1 << i))) dp2[j] += dp2[j|(1 << i)];\n        }\n    }\n    int ans = 100;\n    for (int i = 0; i < (1 << n); ++i) {\n        if(dp2[i] == 0) ans = min(ans, cnt[i]);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nconst lint mod = 998244353;\n#define all(x) (x).begin(), (x).end()\n#define bitcount(n) __builtin_popcountl((lint)(n))\n#define fcout cout << fixed << setprecision(15)\n#define highest(x) (63 - __builtin_clzl(x))\ntemplate<class T> inline void YES(T condition){ if(condition) cout << \"YES\" << endl; else cout << \"NO\" << endl; }\ntemplate<class T> inline void Yes(T condition){ if(condition) cout << \"Yes\" << endl; else cout << \"No\" << endl; }\ntemplate<class T = string, class U = char>int character_count(T text, U character){ int ans = 0; for(U i: text){ ans += (i == character); } return ans; }\nlint power(lint base, lint exponent, lint module){ if(exponent % 2){ return power(base, exponent - 1, module) * base % module; }else if(exponent){ lint root_ans = power(base, exponent / 2, module); return root_ans * root_ans % module; }else{ return 1; }}\nstruct position{ int y, x; }; position mv[4] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}}; // double euclidean(position first, position second){ return sqrt((second.x - first.x) * (second.x - first.x) + (second.y - first.y) * (second.y - first.y)); }\ntemplate<class T, class U> string to_string(pair<T, U> x){ return to_string(x.first) + \",\" + to_string(x.second); } string to_string(string x){ return x; }\ntemplate<class itr> void array_output(itr start, itr goal){ string ans; for(auto i = start; i != goal; i++) ans += to_string(*i) + \" \"; if(!ans.empty()) ans.pop_back(); cout << ans << endl; }\ntemplate<class itr> void cins(itr first, itr last){ for(auto i = first; i != last; i++){ cin >> (*i); } }\ntemplate<class T> T gcd(T a, T b){ if(a && b){ return gcd(min(a, b), max(a, b) % min(a, b)); }else{ return a; }} template<class T> T lcm(T a, T b){ return a / gcd(a, b) * b; }\nstruct combination{ vector<lint> fact, inv; combination(int sz) : fact(sz + 1), inv(sz + 1){ fact[0] = 1; for(int i = 1; i <= sz; i++){ fact[i] = fact[i - 1] * i % mod; } inv[sz] = power(fact[sz], mod - 2, mod); for(int i = sz - 1; i >= 0; i--){ inv[i] = inv[i + 1] * (i + 1) % mod; } } lint C(int p, int q) const{ if(q < 0 || p < q) return 0; return (fact[p] * inv[q] % mod * inv[p - q] % mod); } };\ntemplate<class itr> bool next_sequence(itr first, itr last, int max_bound){ itr now = last; while(now != first){ now--; (*now)++; if((*now) == max_bound){ (*now) = 0; }else{ return true; } } return false; }\ntemplate<class itr, class itr2> bool next_sequence2(itr first, itr last, itr2 first2, itr2 last2){ itr now = last; itr2 now2 = last2; while(now != first){ now--, now2--; (*now)++; if((*now) == (*now2)){ (*now) = 0; }else{ return true; } } return false; }\n\nbool dp[21][1 << 20];\n\nint main(){\n    int N;\n    lint K;\n    cin >> N >> K;\n    lint A[N];\n    for(int i = 0; i < N; i++){\n        cin >> A[i];\n    }\n    bool is_K[1 << N];\n    for(int i = 0; i < (1 << N); i++){\n        lint sum = 0;\n        for(int j = 0; j < N; j++){\n            if((i >> j) & 1){\n                sum += A[j];\n            }\n        }\n        is_K[i] = (sum == K);\n    }\n    for(int i = 0; i < (1 << N); i++){\n        dp[0][i] = is_K[i];\n    }\n    for(int i = 0; i < N; i++){\n        for(int j = 0; j < (1 << N); j++){\n            if((j >> i) & 1){\n                dp[i + 1][j] = dp[i][j] || dp[i][j - (1 << i)];\n            }else{\n                dp[i + 1][j] = dp[i][j];\n            }\n        }\n    }\n    //array_output(dp[N], dp[N] + (1 << N));\n    int ans = N;\n    for(int i = 0; i < (1 << N); i++){\n        if(!dp[N][i]){\n            ans = min(ans, N - bitcount(i));\n        }\n    }\n    cout << ans << endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define SIZE 25\n\nenum Type{\n\tYES,\n\tNO,\n\tUNDEFINED,\n};\n\nint N,K;\nint POW[SIZE];\nint table[SIZE];\nType dp[1 << 21];\n\n\nType recursive(int state){\n\n\tif(dp[state] != UNDEFINED){\n\n\t\treturn dp[state];\n\t}\n\n\t//部分集合を先に計算\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tif(state & (1 << loop)){\n\n\t\t\trecursive(state-POW[loop]);\n\t\t}\n\t}\n\n\t//部分集合に少なくとも1件YESがあれば自分もYES\n\tint count = 0;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tif(state & (1 << loop)){\n\n\t\t\tif(dp[state-POW[loop]] == YES){\n\n\t\t\t\tcount++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif(count > 0){\n\n\t\treturn dp[state] = YES;\n\n\t}\n\n\t//自分を調べる\n\tint sum = 0;\n\tfor(int loop = 0; loop < N; loop++){\n\t\tif(state & (1 << loop)){\n\n\t\t\tsum += table[loop];\n\t\t}\n\t}\n\n\tif(sum == K){\n\n\t\treturn dp[state] = YES;\n\t}else{\n\n\t\treturn dp[state] = NO;\n\t}\n}\n\nint main(){\n\n\tPOW[0] = 1;\n\tfor(int i = 1; i < SIZE; i++){\n\n\t\tPOW[i] = POW[i-1]*2;\n\t}\n\n\tscanf(\"%d %d\",&N,&K);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d\",&table[i]);\n\t}\n\n\tdp[0] = NO; //1 <= Kより\n\n\tfor(int state = 1; state < POW[N]; state++){\n\n\t\tdp[state] = UNDEFINED;\n\t}\n\n\trecursive(POW[N]-1);\n\n\tint ans = BIG_NUM;\n\n\tfor(int state = 0; state < POW[N]; state++){\n\t\tif(dp[state] == YES)continue;\n\n\t\tint minus = 0;\n\t\tfor(int loop = 0; loop < N; loop++){\n\t\t\tif(state & (1 << loop)){\n\n\t\t\t\t//Do nothing\n\t\t\t}else{\n\n\t\t\t\tminus++;\n\t\t\t}\n\t\t}\n\n\t\tans = min(ans,minus);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set> \n#include<cmath>\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) lower_bound(h.begin(),h.end(),val)-h.begin()\n#define upper(h,val) upper_bound(h.begin(),h.end(),val)-h.begin()\nint max_kai = 150000;\nvel kai(max_kai, 1);\nvel inv_kai;\nint rui(int a, int n, int mod) {\n    if (n == 0) { return 1 % mod; }\n    int x = rui(a, n / 2, mod);\n    x *= x; x %= mod;\n    if (n % 2 == 1) { x *= a; x %= mod; }\n    return x;\n}\nvel pa;\nint root(int x) {\n    if (pa[x] == -1) { return x; }\n    int ans = root(pa[x]); pa[x] = ans;\n    return ans;\n}\nvoid marge(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) { pa[x] = y; }\n}\nint gcd(int x, int y) {\n    if (x < y) { return gcd(y, x); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\nlong long modinv(long long a, long long m) {\n    long long b = m, u = 1, v = 0;\n    while (b) {\n        long long t = a / b;\n        a -= t * b; swap(a, b);\n        u -= t * v; swap(u, v);\n    }\n    u %= m;\n    if (u < 0) u += m;\n    return u;\n}\nvel uni(vel x) {\n    if (x.size() == 0) { return x; }\n    sor(x);\n    int n = x.size();\n    vel ans(1, x[0]);\n    for (int j = 1; j < n; j++) {\n        if (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n    }\n    x = ans;\n    return x;\n}\nvoid pr(vel& v) {\n    int n = v.size();\n    if (n != 0) {\n        cout << v[0];\n        rep(i, n - 1) {\n            cout << \" \" << v[i + 1];\n        }\n        cout << endl;\n    }\n}\nint sol(int x, int k) {\n    if (x == 0 || k == 0) { return 0; }\n    return x + sol(x / 2, k - 1);\n}\nvel dis(vvel& way, int n, int st) {\n    vel dist(n, n + 1);\n    dist[st] = 0;\n    queue<int> q;\n    q.push(st);\n    while (!q.empty()) {\n        int x = q.front(); q.pop();\n        for (auto y : way[x]) {\n            if (dist[y] > dist[x] + 1) {\n                dist[y] = dist[x] + 1;\n                q.push(y);\n            }\n        }\n    }\n    return dist;\n}\nsigned main() {\n    int n, k; cin >> n >> k;\n    vel a(n);\n    rep(i, n) {\n        cin >> a[i];\n    }\n    int m = (1 << n);\n    veb can_use(m, true);\n    rep(i, m) {\n        int sum = 0;\n        rep(j, n) {\n            if ((i & (1 << j)) != 0) { sum += a[j]; }\n        }\n        if (sum == k) { can_use[i] = false; }\n    }\n    rep(i, n) {\n        rep(j, m) {\n            int nex = j|(1 << i);\n            can_use[nex] = can_use[nex] & can_use[j];\n        }\n    }\n    int ans = 0;\n    rep(i, m) {\n        if (can_use[i]) {\n            int sum = 0;\n            rep(j, n) {\n                if ((i & (1 << j)) != 0) { sum++; }\n            }\n            mmax(ans, sum);\n        }\n    }\n    cout << n - ans << endl;\n    return 0;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/12/29.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;\nusing mti = vector<vector<int>>;\nusing vl = vector<ll>;\nusing mtl = vector<vector<ll>>;\nusing pi = pair<int, int>;\nusing pl = pair<ll, ll>;\ntemplate<typename T>\nusing heap = priority_queue<T, vector<T>, function<bool(const T, const T)>>;\n\nint main(){\n    // CFS;\n    int n, k;\n    cin >> n >> k;\n    vi a(n);\n    rep(i, n) cin >> a[i];\n    vector<int> dp(1 << n, false);\n    rep(i, 1 << n){\n        int sum = 0;\n        rep(j, n) if(i & (1 << j)) sum += a[j];\n        if(sum == k){\n            dp[i] = true;\n        }\n    }\n    rep(i, n){\n        rep(j, 1 << n){\n            if(j & (1 << i)){\n                dp[j] |= dp[j ^ (1 << i)];\n            }\n        }\n    }\n    int ans = 0;\n    rep(i, 1 << n){\n        if(!dp[i]){\n            int tmp = 0;\n            rep(j, n) if(i & (1 << j)) tmp++;\n            ans = max(ans, tmp);\n        }\n    }\n    cout << n - ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC optimize(\"O3\")\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007LL\n#define VERYBIG 20000000000000007LL\n#define ULTRABIG 3000000000000000000LL\n\n#define MOD 1000000007LL\n#define FOD  998244353LL\n#define HOD 1000000009LL\n#define IOD  100000007LL\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n// #include <functional>\n// #include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n// using std::get;\n// using std::function;\n// using std::array;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nvoid uw (ull *l, ull *r) {\n\tif (*l == *r) return;\n\tull t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX * 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX * 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX * 5];\nsll d[N_MAX * 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\null gin[N_MAX];\n// here we go\n\nsll cnt (sll x) {\n\tif (x == 0) return 0;\n\treturn cnt(x >> 1) + (x % 2);\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tfor (i = 0; !(i >> n); i++) {\n\t\tsum = 0;\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i & (1LL << j)) sum += a[j];\n\t\t}\n\n\t\t// printf(\"%lld: %lld\\n\", i, sum);\n\t\tif (sum == k) b[i] = c[i] = 1;\n\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (c[i ^ (1LL << j)]) {\n\t\t\t\t// printf(\"%lld hurrs %lld\\n\", (i ^ (1LL << j)), i);\n\t\t\t\tc[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (!c[i]) {\n\t\t\t// printf(\"%lld: %lld!\\n\", i, cnt(i));\n\t\t\tresult = smax(result, cnt(i));\n\t\t}\n\t}\n\tresult = n - result;\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%lld\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\" %c\", &ch);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%lld%lld\", &va, &vb);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// scanf(\"%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \tc[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", t[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20190820\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<assert.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nvoid swap(int *a,int *b){int c;c=(*a);(*a)=(*b);(*b)=c;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\nvoid llswap(long long *a,long long *b){long long c;c=(*a);(*a)=(*b);(*b)=c;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nvoid dbswap(double *a,double *b){double c;c=(*a);(*a)=(*b);(*b)=c;}\nvoid chswap(char *a,char *b){char c;c=(*a);(*a)=(*b);(*b)=c;}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid shuffledget(int x[],int n){\n    int i,b[524288],p,c;\n    for(i=0;i<n;i++){\n        b[i]=i;\n    }\n    for(i=n;i>=1;i--){\n        p=rand()%i;\n        c=b[i-1];b[i-1]=b[p];b[p]=c;\n    }\n    for(i=0;i<n;i++){\n        scanf(\"%d\",&x[b[i]]);\n    }\n}\n\nint dx4[4]={1,-1,0,0};\nint dy4[4]={0,0,1,-1};\nint dx8[8]={-1,-1,-1,0,0,1,1,1};\nint dy8[8]={-1,0,1,-1,1,-1,0,1};\n\nint search(int x,int a[],int n){\n    int st=0,fi=n-1,te;\n    while(st<=fi){\n        te=(st+fi)/2;\n        if(a[te]<x){st=te+1;}else{fi=te-1;}\n    }\n    return st;\n}\n\nvoid prarr(int arr[],int n){\n  int i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%d\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\nvoid getperm(int a[],int n){\n  int i,p;\n  for(i=0;i<n;i++){\n    a[i]=i;\n  }\n  for(i=n-1;i>=1;i--){\n    p=rand()%(i+1);\n    swap(&a[p],&a[i]);\n  }\n}\n\ntypedef struct{\nint val;\nint node;\n}sd;\n\nint sdsortfnc(const void *a,const void *b){\nif(((sd*)a)->val < ((sd*)b)->val){return -1;}\nif(((sd*)a)->val > ((sd*)b)->val){return 1;}\nreturn 0;\n}\n\nvoid coordinate_comp(int a[],int n){\n  int i,c=0;\n  sd dat[524288];\n  for(i=0;i<n;i++){\n    dat[i].val=a[i];\n    dat[i].node=i;\n  }\n  qsort(dat,n,sizeof(dat[0]),sdsortfnc);\n  a[dat[0].node]=c;\n  for(i=1;i<n;i++){\n    if(dat[i-1].val!=dat[i].val){c++;}\n    a[dat[i].node]=c;\n  }\n}\n\nint main(void){\n  int i,j,n,m,k,a[32],b,c,h,w,r=0,l,t;\n  int dp[2097152]={0};\n  scanf(\"%d%d\",&n,&k);\n  for(i=0;i<n;i++){scanf(\"%d\",&a[i]);}\n  for(i=0;i<(1<<n);i++){\n    c=0;\n    for(j=0;j<n;j++){\n      if((i&(1<<j))!=0){c+=a[j];}\n    }\n    if(c==k){dp[i]=1;}\n    if(dp[i]==1){\n      for(j=0;j<n;j++){\n        dp[i|(1<<j)]=1;\n      }\n    }\n    else{\n      r=max(dsumb(i,2),r);\n    }\n  }\n  printf(\"%d\\n\",n-r);\n  return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from itertools import *\nfrom bisect import *\nfrom math import *\nfrom collections import *\nfrom heapq import *\nfrom random import *\nfrom decimal import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef MI1(): return map(int1, sys.stdin.readline().split())\ndef MF(): return map(float, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LF(): return list(map(float, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndij = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n\ndef main():\n    n,k=MI()\n    aa=LI()\n    bek=[False]*(1<<n)\n    for bit in range(1<<n):\n        if bek[bit]==False:\n            s=sum(a for i,a in enumerate(aa) if bit>>i&1)\n            if s==k:bek[bit]=True\n            else:continue\n        for j in range(n):\n            bek[bit|1<<j]=True\n    mx=0\n    for bit in range(1<<n):\n        if bek[bit]:continue\n        popcnt=bin(bit).count(\"1\")\n        if popcnt>mx:mx=popcnt\n    print(n-mx)\n\nmain()\n\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize, k: i64,\n        a: [i64; n],\n    }\n    let mut dp = vec![0; 1 << n];\n    for bits in 0..1 << n {\n        let mut sum = 0;\n        for i in 0..n {\n            if (bits & 1 << i) != 0 {\n                sum += a[i];\n            }\n        }\n        dp[bits] = if sum == k { 1 } else { 0 };\n    }\n    for i in 0..n {\n        for bits in 0..1 << n {\n            if (bits & 1 << i) != 0 {\n                continue;\n            }\n            dp[bits | 1 << i] += dp[bits];\n        }\n    }\n    let mut mi = n;\n    for bits in 0usize..1 << n {\n        let bc = n - bits.count_ones() as usize;\n        if dp[bits] == 0 {\n            mi = min(mi, bc);\n        }\n    }\n    puts!(\"{}\\n\", mi);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\n\nfn run() {\n    input! {\n        n: usize,\n        k: u32,\n        a: [u32; n],\n    }\n    let mut valid = vec![true; 1 << n];\n    for i in 0..(1 << n) {\n        let mut sum = 0;\n        for j in 0..n {\n            if (i >> j) & 1 == 1 {\n                sum += a[j];\n            }\n        }\n        if sum == k {\n            valid[i] = false;\n        }\n    }\n    for i in 1..(1 << n) {\n        for j in 0..n {\n            if (i >> j) & 1 == 1 {\n                valid[i] &= valid[i ^ (1 << j)];\n            }\n        }\n    }\n    let mut ans = n;\n    for i in 0..(1 << n) {\n        if valid[i] {\n            ans = std::cmp::min(ans, n - i.count_ones() as usize);\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[macro_export]\nmacro_rules ! chmax { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: max ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! chmin { ( $ x : expr , $ ( $ v : expr ) ,+ ) => { $ ( $ x = std :: cmp :: min ( $ x ,$ v ) ; ) + } ; }\n#[macro_export]\nmacro_rules ! max { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: max ( $ x , max ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! min { ( $ x : expr ) => ( $ x ) ; ( $ x : expr , $ ( $ xs : expr ) ,+ ) => { std :: cmp :: min ( $ x , min ! ( $ ( $ xs ) ,+ ) ) } ; }\n#[macro_export]\nmacro_rules ! dvec { ( $ t : expr ; $ len : expr ) => { vec ! [ $ t ; $ len ] } ; ( $ t : expr ; $ len : expr , $ ( $ rest : expr ) ,* ) => { vec ! [ dvec ! ( $ t ; $ ( $ rest ) ,* ) ; $ len ] } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let out = stdout();\n    let mut out = BufWriter::new(out.lock());\n    input!{\n        n:usize,k:i64,\n        a:[i64;n]\n    }\n\n    // bit = 残ったやつ\n    let mut dp = vec![false; 1<<n];\n    for bit in 0..(1<<n) {\n        let mut tot = 0;\n        for i in 0..n {\n            if bit & (1<<i) > 0 {\n                tot += a[i];\n            }\n        }\n        if tot == k {\n            dp[bit] = true;\n        }\n        for i in 0..n {\n            dp[bit | 1<<i] |= dp[bit];\n        } \n    }\n    let mut maxv = 0;\n    for bit in 0..(1<<n) {\n        if !dp[bit] {\n            chmax!(maxv, usize::count_ones(bit) as usize);\n        }\n    }\n    println!(\"{}\", n-maxv);\n}\n\n"
  }
]