[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nint n, m;\nconst int mod = 1e9 + 7;\n\nconst int maxn = 5005;\nint dp[maxn][maxn];\nint power[maxn];\nint inv[maxn];\nint sum[maxn][maxn];\n\nvoid add(int &a, int b){\n    a += b;\n    if(a >= mod)\n        a -= mod;\n}\n\nint main(){\n    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n    power[0] = 1;\n    inv[0] = 1;\n    int val = (mod + 1) / 2;\n    for(int i = 1;i < maxn;i++){\n        power[i] = power[i - 1] * 2 % mod;\n        inv[i] = 1LL * inv[i - 1] * val % mod;\n    }\n    cin >> n >> m;\n    dp[0][m] = 1; \n    sum[0][0] = 0;\n    for(int i = 1;i <= m;i++){\n        sum[0][i] = sum[0][i - 1];\n        add(sum[0][i], 1LL * dp[0][i] * power[i] % mod);\n    }\n    for(int i = 1;i <= n;i++){\n        sum[i][0] = 0;\n        for(int j = 1;j <= m;j++){\n            add(dp[i][j], 1LL * dp[i - 1][j] * (j + 1) % mod);\n            //for(int k = j + 1;k <= m;k++){\n            //    int delta = k - j;\n            //    int len = delta + 1;\n            //    add(dp[i][j], 1LL * power[len - 2] * dp[i - 1][k] % mod * j % mod);\n            //}\n            int tmp1 = (sum[i - 1][m] - sum[i - 1][j] + mod) % mod;\n            tmp1 = 1LL * tmp1 * inv[j + 1] % mod;\n            add(dp[i][j], 1LL * tmp1 * j % mod);\n            sum[i][j] = sum[i][j - 1];\n            int tmp = 1LL * dp[i][j] * power[j] % mod;\n            add(sum[i][j], tmp);\n        }\n    }\n    int ans = 0;\n    for(int i = 1;i <= m;i++){\n        add(ans, dp[n][i]);\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\nint main() {\n  ll N, M; cin >> N >> M;\n  ll p2[10000]; rep(i,10000) p2[i] = i==0 ? 1 : p2[i-1]*2%MOD;\n\n  ll dp[N][M+1] = {};\n  rep(i,N) {\n    if (i==0) rep(j,M+1) dp[i][j] = p2[j];\n    else {\n      ll now = 0;\n      repr(j,1,M+1) {\n        dp[i][j] = ( dp[i][j] + dp[i-1][j]*(j+1) ) % MOD;\n        dp[i][j] = ( dp[i][j] + now*p2[j-1] ) % MOD;\n        now = ( now + dp[i-1][j] * j % MOD * inv(p2[j]) ) % MOD;\n        // cout << i << \" \" << j << \"->\" << now << endl;\n      }\n    }\n  }\n  // rep(i,N) debug(dp[i], dp[i]+(M+1));\n\n  ll result = dp[N-1][M];\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define ld long double\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define repo(i,n) for(int i = 1; i < (int)(n); i++)\n#define pb push_back\n#define mp make_pair\n#define np next_permutation\n#define lb lower_bound\n#define ub upper_bound\n#define fi first\n#define se second\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define pi acos(-1.0)\nconst ll INF = 1LL<<61;\ntemplate<class T>bool chmax(T &a, const T &b) { \n  if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) {\n  if (b<a) { a=b; return 1; } return 0; }\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\nll lcm(ll x, ll y) { return x / gcd(x, y) * y; }\nll jou(ll N, ll P){if(P==0) return 1;\n    if(P%2==0){ll t = jou(N, P/2);return t*t % mod;\n    }return (N * jou(N, P-1)) % mod;}  //jou(n,mod-2)で逆元\n//intの最大値2147483647 ≒ 2×10^9\n//long longの最大値9223372036854775807 ≒ 9×10^18\n//'大文字'+=32;    で小文字に\n//  cout << fixed << setprecision (20);   小数点以下2０桁まで\n//実行時間制約2秒では２×10^8回くらいまで計算できる\n\n\n\nint main(){\n  ll a,b;\n  cin>>a>>b;\n  \n  ll y=jou(2,a-1);\n\n  ll q=jou(y,b);\n\n\n  cout << q*(1+2*b)%mod << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(long long i = 0; i < (long long)n; i++)\nconstexpr long long mod = 1000000007;\n\nlong long mod_pow(long long a, long long n) {\n    long long ret = 1, tmp = a;\n    while(n > 0) {\n        if(n % 2) {\n            ret *= tmp; ret %= mod;\n        }\n        tmp = tmp * tmp; tmp %= mod;\n        n /= 2;\n    }\n    return ret;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<long long>> dp(n, vector<long long>(m));\n    rep(i, n) {\n        long long sum = 0;\n        rep(j, m) {\n            if(i == 0) {\n                dp[i][j] = mod_pow(2, j + 1);\n                continue;\n            }\n            dp[i][j] = (((j + 2) * dp[i - 1][j]) % mod + sum) % mod;\n            sum *= 2; sum %= mod;\n            sum += (j + 1) * dp[i - 1][j]; sum %= mod;\n        }\n    }\n    cout << dp[n - 1][m - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=5005,mo=1e9+7;\nint n,m,i,j,f[N],a,b,mi[N],ans;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=*mi=1;i<N;++i)mi[i]=2*mi[i-1]%mo;\n\tf[m]=1;\n\tfor(i=n;i;--i){\n\t\ta=b=0;\n\t\tfor(j=m;j;--j){\n\t\t\tint of=f[j];\n\t\t\tf[j]=(1ll*(j+1)*f[j]+a)%mo;\n\t\t\ta=2ll*(a+mo-b)%mo;b=2*b%mo;\n\t\t\ta=(a+1ll*(j-1)*of)%mo;b=(b+of)%mo;\n\t\t}\n\t}\n//\tfor(i=1;i<=m;++i)ans=(ans+1ll*mi[i]*f[i])%mo;\n\tfor(i=1;i<=m;++i)ans=(ans+f[i])%mo;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__);fflush(stderr);\n#else\n\t#define eprintf(...) 42\n#endif\n\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned int;\nusing ull = unsigned long long;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\nusing pii = pair<int, int>;\nusing pli = pair<ll, int>;\nusing pll = pair<ll, ll>;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nclock_t startTime;\ndouble getCurrentTime() {\n\treturn (double)(clock() - startTime) / CLOCKS_PER_SEC;\n}\n\nconst ll MOD = (ll)1e9 + 7;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 5050;\nll dp[N];\nint n, m;\n\nint main()\n{\n\tstartTime = clock();\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 0; i <= m; i++)\n\t\tdp[i] = 1;\n\tfor (int it = 1; it <= n; it++) {\n\t\tll sum = 0;\n\t\tll lst = dp[0];\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tsum = add(sum, sum);\n\t\t\t\tsum = add(sum, mult(i - 1, lst));\n\t\t\t\tlst = dp[i];\n\t\t\t}\n\t\t\tdp[i] = add(mult(i + 1, dp[i]), sum);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", dp[m]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nlong long mod = 1000000007;\nlong long power[10009], inv[10009];\nlong long N, M;\nlong long dp[5009][5009], ru[5009][5009];\n\nvoid init() {\n\tpower[0] = 1;\n\tfor (int i = 1; i <= 10000; i++) power[i] = (2LL * power[i - 1]) % mod;\n\tfor (int i = 0; i <= 10000; i++) inv[i] = Div(1, power[i], mod);\n}\n\nint main() {\n\tinit();\n\tcin >> N >> M;\n\tdp[N][M] = 1;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tru[i][0] = 0;\n\t\tfor (int j = 1; j <= M; j++) ru[i + 1][j] = dp[i + 1][j] * power[j] % mod;\n\t\tfor (int j = 1; j <= M; j++) ru[i + 1][j] = (ru[i + 1][j] + ru[i + 1][j - 1]) % mod;\n\t\tfor (int j = 1; j <= M; j++) {\n\t\t\tlong long v1 = 1LL * (j + 1) * dp[i + 1][j];\n\t\t\tlong long v2 = ru[i + 1][M] - ru[i + 1][j];\n\t\t\tv2 *= inv[j + 1]; v2 %= mod;\n\t\t\tv2 *= (1LL * j); v2 %= mod;\n\t\t\tdp[i][j] = (v1 + v2) % mod;\n\t\t}\n\t}\n\n\tlong long Answer = 0;\n\tfor (int i = 1; i <= M; i++) Answer += dp[0][i];\n\tcout << Answer % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md=1000000007;\nint n,m,i,j;\nlong long f[5005][5005],s[5005][5005],pw2[5005],o[5005],k;\nlong long pw(long long a, int b) {\n  if (b==0) return 1LL;\n  if (b&1) return (pw(a,b-1)*a)%md;\n  long long x=pw(a,b/2);\n  return (x*x)%md;\n}\nint main() {\n  scanf(\"%d%d\",&m,&n);\n  for (pw2[0]=o[0]=i=1; i<=n; i++) {\n    f[0][i]=1;\n    pw2[i]=(pw2[i-1]*2)%md;\n    o[i]=pw(pw2[i],md-2);\n  }\n  for (i=1; i<=m; i++) {\n    for (k=1; k<=n; k++) s[i-1][k]=(s[i-1][k-1]+((f[i-1][k]*k)%md)*o[k+1])%md;\n    for (j=1; j<=n; j++) {\n      f[i][j]=(f[i-1][j]*(j+1LL))%md;\n      f[i][j]=(f[i][j]+s[i-1][j-1]*pw2[j])%md;\n    //f[i][j]=(f[i][j]+s[i-1][j-1]*pw2[j])%md;\n    //s[i][j]=(s[i][j-1]+((f[i][j]*j)%md)*o[j+1])%md;\n    //s[i][j]=(((f[i][j]*j)%md)*o[j+1])%md;\n    //printf(\"%d %d = %d\\n\",i,j,f[i][j]);\n    }\n  }\n  printf(\"%d\\n\",f[m][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool chmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool chmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\ntemplate <int mod>\nstruct ModInt\n{\n    using lint = long long;\n    static int get_mod() { return mod; }\n    static int get_primitive_root() {\n        static int primitive_root = 0;\n        if (!primitive_root) {\n            primitive_root = [&](){\n                std::set<int> fac;\n                int v = mod - 1;\n                for (lint i = 2; i * i <= v; i++) while (v % i == 0) fac.insert(i), v /= i;\n                if (v > 1) fac.insert(v);\n                for (int g = 1; g < mod; g++) {\n                    bool ok = true;\n                    for (auto i : fac) if (ModInt(g).power((mod - 1) / i) == 1) { ok = false; break; }\n                    if (ok) return g;\n                }\n                return -1;\n            }();\n        }\n        return primitive_root;\n    }\n    int val;\n    constexpr ModInt() : val(0) {}\n    constexpr ModInt &_setval(lint v) { val = (v >= mod ? v - mod : v); return *this; }\n    constexpr ModInt(lint v) { _setval(v % mod + mod); }\n    explicit operator bool() const { return val != 0; }\n    constexpr ModInt operator+(const ModInt &x) const { return ModInt()._setval((lint)val + x.val); }\n    constexpr ModInt operator-(const ModInt &x) const { return ModInt()._setval((lint)val - x.val + mod); }\n    constexpr ModInt operator*(const ModInt &x) const { return ModInt()._setval((lint)val * x.val % mod); }\n    constexpr ModInt operator/(const ModInt &x) const { return ModInt()._setval((lint)val * x.inv() % mod); }\n    constexpr ModInt operator-() const { return ModInt()._setval(mod - val); }\n    constexpr ModInt &operator+=(const ModInt &x) { return *this = *this + x; }\n    constexpr ModInt &operator-=(const ModInt &x) { return *this = *this - x; }\n    constexpr ModInt &operator*=(const ModInt &x) { return *this = *this * x; }\n    constexpr ModInt &operator/=(const ModInt &x) { return *this = *this / x; }\n    friend constexpr ModInt operator+(lint a, const ModInt &x) { return ModInt()._setval(a % mod + x.val); }\n    friend constexpr ModInt operator-(lint a, const ModInt &x) { return ModInt()._setval(a % mod - x.val + mod); }\n    friend constexpr ModInt operator*(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.val % mod); }\n    friend constexpr ModInt operator/(lint a, const ModInt &x) { return ModInt()._setval(a % mod * x.inv() % mod); }\n    constexpr bool operator==(const ModInt &x) const { return val == x.val; }\n    constexpr bool operator!=(const ModInt &x) const { return val != x.val; }\n    bool operator<(const ModInt &x) const { return val < x.val; }  // To use std::map<ModInt, T>\n    friend std::istream &operator>>(std::istream &is, ModInt &x) { lint t; is >> t; x = ModInt(t); return is; }\n    friend std::ostream &operator<<(std::ostream &os, const ModInt &x) { os << x.val;  return os; }\n    constexpr lint power(lint n) const {\n        lint ans = 1, tmp = this->val;\n        while (n) {\n            if (n & 1) ans = ans * tmp % mod;\n            tmp = tmp * tmp % mod;\n            n /= 2;\n        }\n        return ans;\n    }\n    constexpr lint inv() const { return this->power(mod - 2); }\n    constexpr ModInt operator^(lint n) const { return ModInt(this->power(n)); }\n    constexpr ModInt &operator^=(lint n) { return *this = *this ^ n; }\n\n    inline ModInt fac() const {\n        static std::vector<ModInt> facs;\n        int l0 = facs.size();\n        if (l0 > this->val) return facs[this->val];\n\n        facs.resize(this->val + 1);\n        for (int i = l0; i <= this->val; i++) facs[i] = (i == 0 ? ModInt(1) : facs[i - 1] * ModInt(i));\n        return facs[this->val];\n    }\n\n    ModInt doublefac() const {\n        lint k = (this->val + 1) / 2;\n        if (this->val & 1) return ModInt(k * 2).fac() / ModInt(2).power(k) / ModInt(k).fac();\n        else return ModInt(k).fac() * ModInt(2).power(k);\n    }\n\n    ModInt nCr(const ModInt &r) const {\n        if (this->val < r.val) return ModInt(0);\n        return this->fac() / ((*this - r).fac() * r.fac());\n    }\n\n    ModInt sqrt() const {\n        if (val == 0) return 0;\n        if (mod == 2) return val;\n        if (power((mod - 1) / 2) != 1) return 0;\n        ModInt b = 1;\n        while (b.power((mod - 1) / 2) == 1) b += 1;\n        int e = 0, m = mod - 1;\n        while (m % 2 == 0) m >>= 1, e++;\n        ModInt x = power((m - 1) / 2), y = (*this) * x * x;\n        x *= (*this);\n        ModInt z = b.power(m);\n        while (y != 1) {\n            int j = 0;\n            ModInt t = y;\n            while (t != 1) j++, t *= t;\n            z = z.power(1LL << (e - j - 1));\n            x *= z, z *= z, y *= z;\n            e = j;\n        }\n        return ModInt(std::min(x.val, mod - x.val));\n    }\n};\nusing mint = ModInt<1000000007>;\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<mint> a(M, 1);\n    vector<mint> pow2(M + N + 3, 1);\n    REP(i, pow2.size() - 1) pow2[i + 1] = pow2[i] * 2;\n    REP(_, N)\n    {\n        vector<mint> v(M + 1);\n        REP(r, M) v[r] = a[r] * (M - r) * pow2[r];\n        IREP(i, M - 1) v[i] += v[i + 1];\n        vector<mint> b(M);\n        REP(i, M) b[i] = (pow2[i + 1] * a[i] * (M - i + 1) + v[i + 1]) / pow2[i + 1];\n        a = b;\n    }\n    cout << a[0] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 5000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint DP[N][N], PS[N][N], n, m, t2[N], inv[N];\n\nint add(int a, int b){\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n\treturn a;\n}\n\nint mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\nint minu(int a, int b){\n\ta -= b;\n\tif (a < 0) a += MOD;\n\treturn a;\n}\n\nint POW(int a, int b){\n\tint res = 1;\n\twhile (b){\n\t\tif (b & 1) res = mul(res, a);\n\t\tb >>= 1;\n\t\ta = mul(a, a);\n\t}\n\treturn res;\n}\n\nvoid cPS(int i){\n\tint Now = 0;\n\tfor (int j = N - 1; j >= 0; j--){\n\t\tPS[i][j] = mul(j, mul(tav[Now++], DP[i][j]));\n\t}\n\tfor (int j = 1; j <= n; j++) PS[i][j] = add(PS[i][j], PS[i][j - 1]);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\ttav[0] = 1;\n\tfor (int i = 1; i < N; i++){\n\t\ttav[i] = mul(tav[i - 1], 2);\n\t}\n\tinv[N - 1] = POW(tav[N - 1], MOD - 2);\n\tfor (int i = N - 2; i >= 0; i--){\n\t\tinv[i] = mul(inv[i + 1], 2);\n\t}\t\n\tfor (int i = 1; i <= m; i++) DP[1][i] = tav[i];\n\tcPS(1);\n\tfor (int i = 2; i <= n; i++) for (int j = 1; j <= m; j++){\n\t\tDP[i][j] = mul(2, DP[i - 1][j]);\n\t\t\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include \"ext/pb_ds/assoc_container.hpp\"\n#include \"ext/pb_ds/tree_policy.hpp\"\n#include \"ext/rope\"\nusing namespace std;\nusing namespace chrono;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\nmt19937 rng(high_resolution_clock::now().time_since_epoch().count());\nmt19937_64 rngll(high_resolution_clock::now().time_since_epoch().count());\n#define lambdify(x) [&](auto &&...args){ return x(forward<decltype(args)>(args)...); }\ntemplate<typename T, typename U> T &ctmax(T &x, const U &y){ return x = max<T>(x, y); }\ntemplate<typename T, typename U> T &ctmin(T &x, const U &y){ return x = min<T>(x, y); }\ntemplate<typename T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n\ntemplate<typename T>\nstruct Z_p{\n\tusing Type = typename decay<decltype(T::value)>::type;\n\tconstexpr Z_p(): value(){ }\n\ttemplate<typename U> Z_p(const U &x){ value = normalize(x); }\n\ttemplate<typename U> static Type normalize(const U &x){\n\t\tType v;\n\t\tif(-mod() <= x && x < mod()) v = static_cast<Type>(x);\n\t\telse v = static_cast<Type>(x % mod());\n\t\tif(v < 0) v += mod();\n\t\treturn v;\n\t}\n\tconst Type& operator()() const{ return value; }\n\ttemplate<typename U> explicit operator U() const{ return static_cast<U>(value); }\n\tconstexpr static Type mod(){ return T::value; }\n\tZ_p &operator+=(const Z_p &otr){ if((value += otr.value) >= mod()) value -= mod(); return *this; }\n\tZ_p &operator-=(const Z_p &otr){ if((value -= otr.value) < 0) value += mod(); return *this; }\n\ttemplate<typename U> Z_p &operator+=(const U &otr){ return *this += Z_p(otr); }\n\ttemplate<typename U> Z_p &operator-=(const U &otr){ return *this -= Z_p(otr); }\n\tZ_p &operator++(){ return *this += 1; }\n\tZ_p &operator--(){ return *this -= 1; }\n\tZ_p operator++(int){ Z_p result(*this); *this += 1; return result; }\n\tZ_p operator--(int){ Z_p result(*this); *this -= 1; return result; }\n\tZ_p operator-() const{ return Z_p(-value); }\n\ttemplate<typename U = T>\n\ttypename enable_if<is_same<typename Z_p<U>::Type, int>::value, Z_p>::type& operator*=(const Z_p& rhs){\n\t\t#ifdef _WIN32\n\t\tuint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n\t\tuint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n\t\tasm(\n\t\t\t\"divl %4; \\n\\t\"\n\t\t\t: \"=a\" (d), \"=d\" (m)\n\t\t\t: \"d\" (xh), \"a\" (xl), \"r\" (mod())\n\t\t);\n\t\tvalue = m;\n\t\t#else\n\t\tvalue = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n\t\t#endif\n\t\treturn *this;\n\t}\n\ttemplate<typename U = T>\n\ttypename enable_if<is_same<typename Z_p<U>::Type, int64_t>::value, Z_p>::type& operator*=(const Z_p &rhs){\n\t\tint64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n\t\tvalue = normalize(value * rhs.value - q * mod());\n\t\treturn *this;\n\t}\n\ttemplate<typename U = T>\n\ttypename enable_if<!is_integral<typename Z_p<U>::Type>::value, Z_p>::type& operator*=(const Z_p &rhs){\n\t\tvalue = normalize(value * rhs.value);\n\t\treturn *this;\n\t}\n\tZ_p operator^(long long e) const{\n\t\tZ_p b = *this, res = 1;\n\t\tif(e < 0) b = 1 / b, e = -e;\n\t\tfor(; e; b *= b, e >>= 1) if(e & 1) res *= b;\n\t\treturn res;\n\t}\n\tZ_p &operator^=(const long long &e){ return *this = *this ^ e; }\n\tZ_p &operator/=(const Z_p &otr){\n\t\tType a = otr.value, m = mod(), u = 0, v = 1;\n\t\twhile(a){\n\t\t\tType t = m / a;\n\t\t\tm -= t * a; swap(a, m);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tassert(m == 1);\n\t\treturn *this *= u;\n\t}\n\ttemplate<typename U> friend const Z_p<U> &abs(const Z_p<U> &v){ return v; }\n\ttemplate<typename U> friend bool operator==(const Z_p<U> &lhs, const Z_p<U> &rhs);\n\ttemplate<typename U> friend bool operator<(const Z_p<U> &lhs, const Z_p<U> &rhs);\n\ttemplate<typename U> friend istream &operator>>(istream &in, Z_p<U> &number);\n\tType value;\n};\ntemplate<typename T> bool operator==(const Z_p<T> &lhs, const Z_p<T> &rhs){ return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Z_p<T>& lhs, U rhs){ return lhs == Z_p<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) == rhs; }\ntemplate<typename T> bool operator!=(const Z_p<T> &lhs, const Z_p<T> &rhs){ return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Z_p<T> &lhs, U rhs){ return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Z_p<T> &rhs){ return !(lhs == rhs); }\ntemplate<typename T> bool operator<(const Z_p<T> &lhs, const Z_p<T> &rhs){ return lhs.value < rhs.value; }\ntemplate<typename T> Z_p<T> operator+(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Z_p<T> operator+(const Z_p<T> &lhs, U rhs){ return Z_p<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Z_p<T> operator+(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) += rhs; }\ntemplate<typename T> Z_p<T> operator-(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator-(const Z_p<T>& lhs, U rhs){ return Z_p<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator-(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) -= rhs; }\ntemplate<typename T> Z_p<T> operator*(const Z_p<T> &lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator*(const Z_p<T>& lhs, U rhs){ return Z_p<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator*(U lhs, const Z_p<T> &rhs){ return Z_p<T>(lhs) *= rhs; }\ntemplate<typename T> Z_p<T> operator/(const Z_p<T> &lhs, const Z_p<T> &rhs) { return Z_p<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator/(const Z_p<T>& lhs, U rhs) { return Z_p<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Z_p<T> operator/(U lhs, const Z_p<T> &rhs) { return Z_p<T>(lhs) /= rhs; }\ntemplate<typename T> istream &operator>>(istream &in, Z_p<T> &number){\n\ttypename common_type<typename Z_p<T>::Type, int64_t>::type x;\n\tin >> x;\n\tnumber.value = Z_p<T>::normalize(x);\n\treturn in;\n}\ntemplate<typename T> ostream &operator<<(ostream &out, const Z_p<T> &number){ return out << number(); }\n\n/*\nusing ModType = int;\nstruct VarMod{ static ModType value; };\nModType VarMod::value;\nModType &mod = VarMod::value;\nusing Zp = Z_p<VarMod>;\n*/\n\nconstexpr int mod = (int)1e9 + 7;\n//constexpr int mod = 998244353;\nusing Zp = Z_p<integral_constant<decay<decltype(mod)>::type, mod>>;\n\nint main(){\n\tcin.tie(0)->sync_with_stdio(0);\n\tint n, m;\n\tcin >> n >> m;\n\tconst int mx = 50001;\n\tvector<Zp> p2(mx + 1, 1);\n\tfor(auto i = 0; i < mx; ++ i){\n\t\tp2[i + 1] = p2[i] * 2;\n\t}\n\tvector<vector<Zp>> dp(n + 1, vector<Zp>(m + 1));\n\tfor(auto j = 2; j <= m; ++ j){ // dp[1][j]\n\t\tdp[1][j] = p2[j];\n\t}\n\tfor(auto i = 2; i <= n; ++ i){\n\t\tdp[i][2] = dp[i - 1][2] * 3 + p2[i - 1];\n\t}\n\tfor(auto i = 2; i <= n; ++ i){\n\t\tfor(auto j = 3; j <= m; ++ j){\n\t\t\tdp[i][j] = (dp[i][j - 1] - j * dp[i - 1][j - 1]) * 2 + (j - 1) * dp[i - 1][j - 1] + (j + 1) * dp[i - 1][j];\n\t\t}\n\t}\n\tcout << dp[n][m];\n\treturn 0;\n}\n\n/*\n\n*/\n\n////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                    //\n//                                   Coded by Aeren                                   //\n//                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <__int128_t Mod = 0> struct modint {\n  static_assert(!(Mod < 0));\n  using mod_type =\n      typename std::conditional<bool(Mod), const int, __int128_t>::type;\n  static mod_type mod;\n  using value_type = int;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\ntemplate <__int128_t Mod> typename modint<Mod>::mod_type modint<Mod>::mod = Mod;\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  using mint = modint_runtime;\n  solver() {\n    // start here!\n    mint::mod = 1e9 + 7;\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "    #pragma GCC optimize (\"O3\")\n    #pragma GCC target (\"sse4\")\n     \n    #include <bits/stdc++.h>\n     \n    using namespace std;\n     \n    typedef long long ll;\n    typedef long double ld;\n    typedef complex<ld> cd;\n     \n    typedef pair<int, int> pi;\n    typedef pair<ll,ll> pl;\n    typedef pair<ld,ld> pd;\n     \n    typedef vector<int> vi;\n    typedef vector<ld> vd;\n    typedef vector<ll> vl;\n    typedef vector<pi> vpi;\n    typedef vector<pl> vpl;\n    typedef vector<cd> vcd;\n     \n    #define FOR(i, a, b) for (int i=a; i<(b); i++)\n    #define F0R(i, a) for (int i=0; i<(a); i++)\n    #define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n    #define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n     \n    #define sz(x) (int)(x).size()\n    #define mp make_pair\n    #define pb push_back\n    #define f first\n    #define s second\n    #define lb lower_bound\n    #define ub upper_bound\n    #define all(x) x.begin(), x.end()\n    #define ins insert\n     \n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n     \n    const int MOD = 1000000007;\n    const char nl = '\\n';\n    const int MX = 6001; //check the limits, dummy\n     \n    struct mi {\n    \tll v; explicit operator ll() const { return v; }\n    \tmi() { v = 0; }\n    \tmi(ll _v) { \n    \t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n    \t\tif (v < 0) v += MOD;\n    \t}\n    \tfriend bool operator==(const mi& a, const mi& b) { \n    \t\treturn a.v == b.v; }\n    \tfriend bool operator!=(const mi& a, const mi& b) { \n    \t\treturn !(a == b); }\n    \tfriend bool operator<(const mi& a, const mi& b) { \n    \t\treturn a.v < b.v; }\n       \n    \tmi& operator+=(const mi& m) { \n    \t\tif ((v += m.v) >= MOD) v -= MOD; \n    \t\treturn *this; }\n    \tmi& operator-=(const mi& m) { \n    \t\tif ((v -= m.v) < 0) v += MOD; \n    \t\treturn *this; }\n    \tmi& operator*=(const mi& m) { \n    \t\tv = v*m.v%MOD; return *this; }\n    \tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n    \tfriend mi pow(mi a, ll p) {\n    \t\tmi ans = 1; assert(p >= 0);\n    \t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n    \t\treturn ans;\n    \t}\n    \tfriend mi inv(const mi& a) { assert(a.v != 0); \n    \t\treturn pow(a,MOD-2); }\n    \t\t\n    \tmi operator-() const { return mi(-v); }\n    \tmi& operator++() { return *this += 1; }\n    \tmi& operator--() { return *this -= 1; }\n    \tfriend mi operator+(mi a, const mi& b) { return a += b; }\n    \tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n    \tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n    \tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n        friend ostream& operator<<(ostream& os, const mi& m) {\n            os << m.v; return os;\n        }\n        friend istream& operator>>(istream& is, mi& m) {\n            ll x; is >> x;\n            m.v = x;\n            return is;\n        }\n    };\n     \n     \n    typedef vector<mi> vmi;\n    typedef pair<mi,mi> pmi;\n    typedef vector<pmi> vpmi;\nmi cnt[MX+1][MX+1];\n    int main() {\n    \tios_base::sync_with_stdio(0); cin.tie(0);    \n    \t\n        int M, N; cin >> M >> N;\n        \n        F0R(i, N+1) {\n            F0R(j, N+1) {\n                cnt[i][j] = 0;\n            }\n            cnt[i][i] = i+1;\n            FOR(j, 1, i) {\n                mi lenVar = i - j - 1;\n                mi curCnt = i - j + 1;\n                cnt[i][j] = curCnt * pow((mi) 2, (ll) lenVar);\n            }\n        }\n     \n        mi dp[M+1][N+1];\n        F0R(i, M+1) F0R(j, N+1) dp[i][j] = 0;\n        dp[M][N] = 1;\n        \n        FORd(i, 1, M+1) {\n            mi cur = 0;\n            mi sum = 0;\n            FORd(j, 1, N+1) {\n                cur -= sum; cur *= 2; sum *= 2;\n                if (j < N) {\n                    cur -= (j+2) * dp[i][j+1];\n                    sum -= dp[i][j+1];\n                }\n                cur += (j+1) * dp[i][j];\n                sum += dp[i][j];\n                dp[i-1][j] = cur;\n            }\n        }\n     \n        mi ans = 0;\n        FOR(i, 1, N+1) ans += dp[0][i];\n        cout << ans << nl;\n    \treturn 0;\n    }\n     \n    // read the question correctly (ll vs int)\n    // template by bqi343\n     "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 5e3+10, mod = 1e9+7, inv2 = (mod+1)>>1;\nint n,m,f[N][N],inv[N],pw[N];\n\nint main(){\n\tn=read(),m=read();\n\tpw[0]=inv[0]=1;\n\tFor(i,1,max(n,m)) pw[i]=2ll*pw[i-1]%mod,inv[i]=1ll*inv[i-1]*inv2%mod;\n\tf[1][0]=1;\n\tFor(i,1,m) f[1][i]=pw[i];\n\tFor(i,2,n){\n\t\tf[i][1]=pw[i];\n\t\tint s=0;\n\t\tFor(j,2,m){\n\t\t\ts=(s+1ll*f[i-1][j-1]*(j-1)%mod*inv[j-1])%mod;\n\t\t\tf[i][j]=(1ll*f[i-1][j]*(j+1)+1ll*s*f[1][j-1])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<ll,ll>\n#define poly vector<ll>\n#define mem(a) memset((a),0,sizeof(a))\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\n#define SZ(x) ((int)(x.size()))\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\nll rnd(){\n\tull ans=0;\n\tFor(i,0,4)ans=ans<<15^rand();\n\treturn ans%((ull)1<<63);\n}\nconst int N=5005,mod=1e9+7;\nll f[N],g[N],pw[N],ppw[N];\nint main(){\n\t#ifdef Brollan\n\t\tfreopen(\"1.in\",\"r\",stdin);\n\t#endif\n\tint n=read(),m=read();\n\tf[m]=1;\n\tFor(i,pw[0]=1,m)pw[i]=pw[i-1]*2%mod;\n\tFor(i,ppw[0]=1,m)ppw[i]=ppw[i-1]*(mod+1)/2%mod;\n\tFor(i,1,n){\n\t\tll sum=0;\n\t\tRep(j,m,1){\n\t\t\tg[j]=(f[j]*(j+1)+sum*ppw[j]%mod*j)%mod;\n\n\t\t\tsum=(sum+f[j]*pw[j-1])%mod;\n\t\t\tg[j]%=mod;\n\t\t}\n\t\tswap(f,g);\n\t}\n\tll ans=0;\n\tFor(i,0,m)ans+=f[i];\n\tcout<<ans%mod<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nstruct Mint {\n\tint val;\n\tMint() { val = 0; }\n\tMint(const ll& x) {\n\t\tval = (-MOD <= x && x < MOD) ? x : x % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\ttemplate <typename U>\n\texplicit operator U() const { return (U)val; }\n\tfriend bool operator==(const Mint& a, const Mint& b) { return a.val == b.val; }\n\tfriend bool operator!=(const Mint& a, const Mint& b) { return !(a == b); }\n\tfriend bool operator<(const Mint& a, const Mint& b) { return a.val < b.val; }\n\tMint& operator+=(const Mint& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n\tMint& operator-=(const Mint& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n\tMint& operator*=(const Mint& m) { val = (ll)val * m.val % MOD; return *this; }\n\tfriend Mint modex(Mint a, ll p) {\n\t\tassert(p >= 0);\n\t\tMint ans = 1;\n\t\tfor (; p; p >>= 1, a *= a) if (p & 1) ans *= a;\n\t\treturn ans;\n\t}\n\tMint& operator/=(const Mint& m) { return *this *= modex(m, MOD - 2); }\n\tMint& operator++() { return *this += 1; }\n\tMint& operator--() { return *this -= 1; }\n\tMint operator++(int) { Mint result(*this); *this += 1; return result; }\n\tMint operator--(int) { Mint result(*this); *this -= 1; return result; }\n\tMint operator-() const { return Mint(-val); }\n\tfriend Mint operator+(Mint a, const Mint& b) { return a += b; }\n\tfriend Mint operator-(Mint a, const Mint& b) { return a -= b; }\n\tfriend Mint operator*(Mint a, const Mint& b) { return a *= b; }\n\tfriend Mint operator/(Mint a, const Mint& b) { return a /= b; }\n\tfriend ostream& operator<<(ostream& os, const Mint& x) { return os << x.val; }\n};\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tvector<Mint> dp(m + 1, 1);\n\tvector<Mint> p2(m + 1, 1), invp2(m + 1, 1);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tp2[i] = p2[i - 1] * 2;\n\t\tinvp2[i] = 1 / p2[i];\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tauto ndp = dp;\n\t\tMint cur = 0;\n\t\tfor (int c = 1; c <= m; ++c) {\n\t\t\tndp[c] = cur * p2[c - 1] + dp[c] * (c + 1);\n\t\t\tcur += dp[c] * c * invp2[c];\n\t\t}\n\t\tswap(dp, ndp);\n\t}\n\tMint ans = dp[m];\n\tprintf(\"%d\\n\", ans.val);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nconst ll mo=1000000007;\n\nll dp[5050][5050];\nll p2[5050],r2[5050];\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,M+1) dp[0][i]=1;\n\t\n\tp2[0]=r2[0]=1;\n\tFOR(i,5010) {\n\t\tp2[i+1]=p2[i]*2%mo;\n\t\tr2[i+1]=r2[i]*(mo+1)/2%mo;\n\t}\n\t\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tdp[i][0]=1;\n\t\tll sum=0;\n\t\tfor(x=1;x<=M;x++) {\n\t\t\t// 000111\n\t\t\t(dp[i][x]+=dp[i-1][x]*(x+1))%=mo;\n\t\t\tif(x>=2) (sum+=(x-1)*dp[i-1][x-1]%mo*p2[M-x])%=mo;\n\t\t\t(dp[i][x]+=sum*r2[M-x])%=mo;\n\t\t\t/*\n\t\t\t// 00111000\n\t\t\tfor(int len=2;len<=x;len++) {\n\t\t\t\t(dp[i][x]+=dp[i-1][x-(len-1)]*p2[len-2]%mo*(x-len+1))%=mo;\n\t\t\t}\n\t\t\t*/\n\t\t}\n\t}\n\tcout<<dp[N][M]<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "352"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<bitset>\n#include<functional>\n#include<numeric>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<cmath>\n#include<random>\n#include<ctime>\n#include<complex>\nusing namespace std;\ntypedef long long LL;\nmt19937 gene(233);\ntypedef complex<double> Complex;\n#define fi first\n#define se second\n#define ins insert\n#define pb push_back\ninline char GET_CHAR(){\n\tconst int maxn = 131072;\n\tstatic char buf[maxn],*p1=buf,*p2=buf;\n\treturn p1==p2&&(p2=(p1=buf)+fread(buf,1,maxn,stdin),p1==p2)?EOF:*p1++;\n}\ninline int getInt() {\n\tint res(0);\n\tchar c = getchar();\n\twhile(c < '0') c = getchar();\n\twhile(c >= '0') {\n\t\tres = res * 10 + (c - '0');\n\t\tc = getchar();\n\t}\n\treturn res;\n}\n\ninline LL fastpo(LL x, LL n, LL mod) {\n\tLL res(1);\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\tres = res * (LL)x % mod;\n\t\t}\n\t\tx = x * (LL) x % mod;\n\t\tn /= 2;\n\t}\n\treturn res;\n}\n\ninline string itoa(int x, int width = 0) {\n  string res;\n  if(x == 0) res.push_back('0');\n  while(x) {\n    res.push_back('0' + x % 10);\n    x /= 10;\n  }\n  while((int)res.size() < width) res.push_back('0');\n  reverse(res.begin(), res.end());\n  return res;\n}\nconst int mod = 1e9 + 7;\nstruct MI{\n\tLL a;\n\tMI operator + (const MI & b) {\n\t\tMI res{a + b.a};\n\t\tif(res.a >= mod) res.a -= mod;\n\t\treturn res;\n\t}\n\tMI operator - (const MI & b) {\n\t\tMI res{a - b.a};\n\t\tif(res.a <= 0) res.a += mod;\n\t\treturn res;\n\t}\n\tMI operator * (const MI & b) {\n\t\treturn MI{a * b.a % mod};\n\t}\n\tMI operator / (const MI & b) {\n\t\treturn MI{a * fastpo(b.a, mod - 2, mod) % mod};\n\t}\n\tMI(LL x) {\n\t\ta = x;\n\t}\n\tMI() {\n\t}\n};\nconst int N = 5555;\nconst int LOG = 20;\nconst int inf = 1e9 + 7;\nMI dp[N][N];\nint n, m;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(i == 1) {\n\t\t\tfor(int j = 1; j <= m; j++) {\n\t\t\t\tdp[i][j] = j == 1 ? 2 : dp[i][j - 1] * MI(2);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tdp[i][1] = MI(2) * dp[i - 1][1];\n\t\tMI tmp = 0;\n\t\tfor(int j = 2; j <= m; j++) {\n\t\t\ttmp = tmp * MI(2) + MI(j - 1) * dp[i - 1][j - 1];\n\t\t\tdp[i][j] = tmp + MI(j + 1) * dp[i - 1][j];\n\t\t}\n\t}\n\tcout << dp[n][m].a << endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 5005\nint n;\nint m;\nint dp[MAX][MAX];\nbool use[MAX][MAX];\nint im[MAX][MAX];\nlong long int inv[MAX];\nlong long int p2[MAX];\ninline int dfs(int a,int b){\n\tif(b==0)return 0;\n\tif(a==n)return 1;\n\tif(use[a][b])return dp[a][b];\n\tuse[a][b]=true;\n\taddto(dp[a][b],mul(1+b,dfs(a+1,b)));\n\t/*for(int i=1;i<=b-1;i++){\n\t\t//addto(dp[a][b],mul(b-i,mul(ppow(2,i-1),dp[a+1][b-i])));\n\t\tcerr<<\"add1 \"<<mul(b-i,ppow(2,i-1))<<\" \"<<b-i<<\" \"<<ppow(2,i-1)<<endl;\n\t}\n\tfor(int imi=2;imi<=b;imi++){\n\t\t//(b-1)*1*dfs(a+1,b-1)+(b-2)*2*dfs(a+1,b-2)+4*dfs(a+1,b-3)...dfs(a+1,1)\n\t\t//addto(dp[a][b],mul(b-imi+1,mul(ppow(2,imi-2),dfs(a+1,b-imi+1))));\n\t\t//cerr<<\"add2 \"<<mul(b-imi+1,ppow(2,imi-2))<<\" \"<<dp[a+1][b-imi+1]<<endl;\n\t}*/\n\taddto(dp[a][b],mul(im[a+1][b-1],inv[m-b+1]));\n\treturn dp[a][b];\n}\nint main(){\n\tcin>>n>>m;\n\tp2[0]=1;\n\tfor(int i=1;i<MAX;i++){\n\t\tp2[i]=mul(p2[i-1],2);\n\t}\n\tfor(int i=0;i<MAX;i++){\n\t\tinv[i]=ppow(p2[i],MOD-2);\n\t}\n\tfor(int i=n;i>=0;i--){\n\t\tfor(int j=m;j>=0;j--){\n\t\t\t//cerr<<\"ad \"<<i<<\" \"<<j<<endl;\n\t\t\tdp[i][j]=dfs(i,j);\n\t\t}\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tim[i][j]=mul(p2[m-j],mul(j,dp[i][j]));\n\t\t\taddto(im[i][j],im[i][j-1]);\n\t\t}\n\t}\n\tcout<<dfs(0,m)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 5000;\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint p2[2*N], invp2[2*N];\nint dp[N], dp2[N];\n\nvoid getDp2(){\n    dp2[0] = 0;\n    for(int r = 1; r < N; r++){\n        dp2[r] = add(dp2[r - 1], mul(r, mul(invp2[r + 1], dp[r])));\n    }\n}\nint main(){\n    p2[0] = invp2[0] = 1;\n    for(int i = 1; i < N; i++) p2[i] = add(p2[i - 1], p2[i - 1]), invp2[i] = inv(p2[i]);\n    for(int i = 0; i < N; i++) dp[i] = 1;\n    int n, m; cin >> n >> m;\n    for(int i = 1; i <= n; i++){\n        getDp2();\n        for(int j = 1; j <= m; j++){\n            dp[j]= mul(dp[j], j + 1);\n            dp[j] = add(dp[j], mul(p2[j], dp2[j - 1]));\n        }\n    }\n    cout << dp[m] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\n\nclass ModInt {\npublic:\n\tstatic unsigned MOD;\n\tModInt(): x(0) {}\n\tModInt(signed y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\tModInt(signed long long y) : x(y >= 0 ? y % MOD : MOD - (-y) % MOD) {}\n\n\n\t// Arithmetic Oprators\n\tModInt &operator+=(ModInt that) {\n\t\tif ((x += that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator-=(ModInt that) {\n\t\tif ((x += MOD - that.x) >= MOD) x -= MOD; \n\t\treturn *this;\n\t}\n\tModInt &operator*=(ModInt that) {\n\t\tx = 1LL * x * that.x % MOD;\n\t\treturn *this;\n\t}\n\tModInt &operator/=(ModInt that) {\n\t\treturn *this *= ModInt(get<1>(extgcd(that.x, int(MOD))));\n\t}\n\tModInt &operator%=(ModInt that) {\n\t\tx %= that.x;\n\t\treturn *this;\n\t}\n\n\tModInt &operator+=(const int that) { return *this += ModInt(that);}\n\tModInt &operator-=(const int that) { return *this -= ModInt(that);}\n\tModInt &operator*=(const int that) { return *this *= ModInt(that);}\n\tModInt &operator/=(const int that) { return *this /= ModInt(that);}\n\tModInt &operator%=(const int that) { return *this %= ModInt(that);}\n\n\t// Comparators\n\tbool operator <(ModInt that) { return x < that.x; }\n\tbool operator >(ModInt that) { return x > that.x; }\n\tbool operator<=(ModInt that) { return x <= that.x; }\n\tbool operator>=(ModInt that) { return x >= that.x; }\n\tbool operator!=(ModInt that) { return x != that.x; }\n\tbool operator==(ModInt that) { return x == that.x; }\n\n\t// Utilities\n\tunsigned getval() const { return x;}\n\tModInt operator+(ModInt that) const { return ModInt(*this) += that;}\n\tModInt operator-(ModInt that) const { return ModInt(*this) -= that;}\n\tModInt operator*(ModInt that) const { return ModInt(*this) *= that;}\n\tModInt operator/(ModInt that) const { return ModInt(*this) /= that;}\n\tModInt operator%(ModInt that) const { return ModInt(*this) %= that;}\n\tModInt operator+(const int that) const { return ModInt(*this) += that;}\n\tModInt operator-(const int that) const { return ModInt(*this) -= that;}\n\tModInt operator*(const int that) const { return ModInt(*this) *= that;}\n\tModInt operator/(const int that) const { return ModInt(*this) /= that;}\n\tModInt operator%(const int that) const { return ModInt(*this) %= that;}\n\tModInt operator=(const int that) { return *this = ModInt(that);}\n\tfriend istream &operator>>(istream& is, ModInt &that) {ll tmp; is >> tmp; that = ModInt(tmp);return is;}\n\tfriend ostream &operator<<(ostream& os, const ModInt &that) { return os << that.x; }\n\t\n\tModInt power(ll n) const {\n\t\tll b = 1LL, a = x;\n\t\twhile(n){\n\t\t\tif(n & 1) b = b * a % MOD;\n\t\t\ta = a * a % MOD;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ModInt(b);\n\t}\nprivate:\n\tunsigned x;\n\t\n\tinline tuple<int, int, int> extgcd(int a, int b) {\n\t\tif (b == 0) return make_tuple(a, 1, 0);\n\t\ttuple<int, int, int> ret = extgcd(b, a % b);\n\t\tswap(get<1>(ret), get<2>(ret));\n\t\tget<2>(ret) -= a / b * get<1>(ret);\n\t\treturn ret;\n\t}\n};\n\nunsigned ModInt::MOD = 1000000007;\nusing mint = ModInt;\nconst mint ZERO = mint(0);\nconst mint ONE = mint(1);\nconst mint TWO = mint(2);\n\n\nmint memo[5010][5010];\nmint dp[5010][5010];\n\nint main(void){\n\tint n, m;\n\tcin >> n >> m;\n\n\n\trep(j, 1, m + 1) dp[1][j] = TWO.power(j);\n\n\trep(i, 2, n + 1) {\n\t\tmint total = ZERO;\n\t\trep(j, 1, m + 1) {\n\t\t\tdp[i][j] += total;\n\t\t\ttotal *= TWO;\n\t\t\ttotal += dp[i - 1][j] * mint(j);\n\t\t\tdp[i][j] += mint(j + 1) * dp[i - 1][j];\n\t\t}\n\t}\n\n\tcout << dp[n][m] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 5002\nint n;\nint m;\nint dp[MAX][MAX];\nbool use[MAX][MAX];\ninline int dfs(int a,int b){\n\tif(b==0)return 0;\n\tif(a==n)return 1;\n\tif(use[a][b])return dp[a][b];\n\tuse[a][b]=true;\n\taddto(dp[a][b],mul(1+b,dfs(a+1,b)));\n\tfor(int imi=2;imi<=b;imi++){\n\t\taddto(dp[a][b],mul(b-imi+1,mul(ppow(2,imi-2),dfs(a+1,b-imi+1))));\n\t}\n\treturn dp[a][b];\n}\nint main(){\n\tcin>>n>>m;\n\tcout<<dfs(0,m)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#define PB push_back\n#define MP make_pair\n#define PII pair<int,int>\n#define FIR first\n#define SEC second\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)) { if(c=='-') f=-1; c=getchar(); }\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\n\nconst int N=5010;\nconst int mod=1e9+7;\nint n,m,f[N][N],pw[N],ipw[N];\nint s[N][N];\n// f[j][i]: total number of elements is i, range is [0,2^j)\n\nint main() {\n\trd(m),rd(n);\n\tpw[0]=1; for(int i=1;i<=n;++i) pw[i]=pw[i-1]*2ll%mod;\n\tipw[0]=1; for(int i=1;i<=n;++i) ipw[i]=ipw[i-1]*1ll*(mod+1>>1)%mod;\n\tfor(int i=0;i<=n;++i) f[0][i]=1;\n\tfor(int j=1;j<=m;++j) {\n\t\tf[j][0]=1;\n//\t\tfor(int i=1;i<=n;++i) {\n//\t\t\tf[j][i]=1ll*(i+1)*f[j-1][i]%mod;\n//\t\t\tfor(int k=2;k<=i;++k)\n//\t\t\t\tf[j][i]=(f[j][i]+1ll*f[j-1][i-k+1]*(i-k+1)%mod*pw[k-2])%mod;\n//\t\t}\n\t\t\n\t\tfor(int i=1;i<=n;++i) s[j-1][i]=(s[j-1][i-1]+1ll*f[j-1][i]*i%mod*ipw[i+1])%mod;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tf[j][i]=(1ll*(i+1)*f[j-1][i]+1ll*s[j-1][i-1]*pw[i])%mod;\n\t}\n\tprintf(\"%d\",f[m][n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\nstruct modinfo{uint mod,root;};\ntemplate<modinfo const&ref>\nstruct modular{\n\tstatic constexpr uint const &mod=ref.mod;\n\tstatic modular root(){return modular(ref.root);}\n\tuint v;\n\t//modular(initializer_list<uint>ls):v(*ls.bg){}\n\tmodular(ll vv=0){s(vv%mod+mod);}\n\tmodular& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmodular operator-()const{return modular()-*this;}\n\tmodular& operator+=(const modular&rhs){return s(v+rhs.v);}\n\tmodular&operator-=(const modular&rhs){return s(v+mod-rhs.v);}\n\tmodular&operator*=(const modular&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmodular&operator/=(const modular&rhs){return *this*=rhs.inv();}\n\tmodular operator+(const modular&rhs)const{return modular(*this)+=rhs;}\n\tmodular operator-(const modular&rhs)const{return modular(*this)-=rhs;}\n\tmodular operator*(const modular&rhs)const{return modular(*this)*=rhs;}\n\tmodular operator/(const modular&rhs)const{return modular(*this)/=rhs;}\n\tmodular pow(int n)const{\n\t\tmodular res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmodular inv()const{return pow(mod-2);}\n\t/*modular inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn modular(x);\n\t}*/\n\tfriend modular operator+(int x,const modular&y){\n\t\treturn modular(x)+y;\n\t}\n\tfriend modular operator-(int x,const modular&y){\n\t\treturn modular(x)-y;\n\t}\n\tfriend modular operator*(int x,const modular&y){\n\t\treturn modular(x)*y;\n\t}\n\tfriend modular operator/(int x,const modular&y){\n\t\treturn modular(x)/y;\n\t}\n\tfriend ostream& operator<<(ostream&os,const modular&m){\n\t\treturn os<<m.v;\n\t}\n\tfriend istream& operator>>(istream&is,modular&m){\n\t\tll x;is>>x;\n\t\tm=modular(x);\n\t\treturn is;\n\t}\n\tbool operator<(const modular&r)const{return v<r.v;}\n\tbool operator==(const modular&r)const{return v==r.v;}\n\tbool operator!=(const modular&r)const{return v!=r.v;}\n\texplicit operator bool()const{\n\t\treturn v;\n\t}\n};\n\n//extern constexpr modinfo base{998244353,3};\nextern constexpr modinfo base{1000000007,0};\n//modinfo base{1,0};\nusing mint=modular<base>;\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,m;cin>>n>>m;\n\tvc<mint> dp(m+1,1);\n\tdp[0]=0;\n\trep(_,n){\n\t\tvc<mint> nx(m+1);\n\t\trep(i,m+1)nx[i]=dp[i]*(i+1);\n\t\trep(i,m+1)dp[i]*=i;\n\t\tmint cur=0;\n\t\trep(i,m+1){\n\t\t\tnx[i]+=cur;\n\t\t\tcur*=2;\n\t\t\tcur+=dp[i];\n\t\t}\n\t\tdp=nx;\n\t}\n\tcout<<dp[m]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 5000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n, m, DP[N][N], T2[N];\n\ninline int mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\ninline int add(int a, int b){\n\ta += b;\n\tif (a >= MOD)a -= MOD;\n\treturn a;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tT2[0] = 1;\n\tfor (int i = 1; i < N; i++) T2[i] = T2[i - 1] * 2ll % MOD;\n\tfor (int i = 1; i <= m; i++) DP[1][i] = T2[i];\n\tfor (int i = 2; i <= n; i++){\n\t\tint sm = 0;\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tDP[i][j] = mul(DP[i - 1][j], j + 1);\n\t\t\tif (j > 1){\n\t\t\t\tsm = mul(sm, 2);\n\t\t\t\tsm = add(sm, DP[i - 1][j - 1]);\n\t\t\t\tDP[i][j] = add(DP[i][j], sm);\n\t\t\t}\n\t\t\tcout << i << ' ' << j << ' ' << DP[i][j] << '\\n';\n\t\t}\n\t}\n\tcout << DP[n][m];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> PP;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF 1145141919810893364\n//#define INF 810114514\n#define PI 3.141592653589\n#define setdouble setprecision\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define OREP(i,n) for(int i=1;i<=(n);++i)\n#define RREP(i,n) for(int i=(n)-1;i>=0;--i)\n#define GOODBYE do { cout << \"0\" << endl; return 0; } while (false)\n#define MM <<\" \"<<\n#define Endl endl\n#define debug false\n#define debug2 false\n\nlong long power(long long b,long long e){\n  long long r=1;\n  while(e){\n      if(e&1){\n          r=(r*b)%MOD;\n      }\n      b=(b*b)%MOD;\n      e >>=1;\n  }\n  return r;\n}\n\n\nint main(void){\n    ll N,M;\n    cin >> N >> M;\n    vector<ll> dp,dp2;\n    vector<ll> pow2;\n    pow2.push_back(1);\n    REP(i,M){\n        pow2.push_back((pow2[pow2.size()-1]*2)%MOD);\n    }\n    \n    dp=pow2;\n    dp2.resize(M+1,0);\n    ll inv2 = power(2,MOD-2);\n    \n    \n    //dp2[n][m]:=dp[n][m]*m*2^{-m}\n    \n    for(ll n=2;n<=N;n++){\n        vector<ll> temp(M+1,0);\n        \n        //dp2[n][m]=dp[n][m]*m*2^{-m}\n        ll invpow = inv2;\n        for(ll m=1;m<=M;m++){\n            dp2[m] = (((dp[m]*m)%MOD)*invpow)%MOD;\n            invpow = (invpow*inv2)%MOD;\n        }\n        \n        //tempはdp2の累積和\n        for(ll m=1;m<=M;m++){\n            if(m==1){\n                temp[m]=dp2[m];\n                temp[m]%=MOD;\n            }else{\n                temp[m]=temp[m-1]+dp2[m];\n                temp[m]%=MOD;\n            }\n        }\n        \n        //そのtempに2^mをかける\n        int pospow = 2;\n        for(ll m=1;m<=M;m++){\n            temp[m] = (temp[m]*pospow)%MOD;\n            pospow = (pospow*2)%MOD;\n        }\n        \n        //dpにm+1をかける\n        for(ll m=1;m<=M;m++){\n            dp[m] = (dp[m]*(m+1))%MOD;\n        }\n        \n        //dp[m]とtemp[m-1]を足して完了\n        for(ll m=2;m<=M;m++){\n            dp[m] += temp[m-1];\n            dp[m]%=MOD;\n        }\n        \n        /*\n        for(ll m=1;m<=M;m++){\n            cout << dp[m] << \" \";\n        }cout << endl;\n        */\n    }\n    \n    cout << dp[M] << endl;\n    \n    \n    return 0;\n}\n\n\n\n\n\n\n\n/*\n//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  struct rep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  struct revrep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) noexcept {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> void chmin(T& a, const T& b) noexcept {\n    if (b < a)\n      a = b;\n  }\n  template <class T> void chmax(T& a, const T& b) noexcept {\n    if (a < b)\n      a = b;\n  }\n  template <class F> class rec_lambda {\n    F f;\n\n  public:\n    rec_lambda(F&& f) : f(std::move(f)) {}\n    template <class... Args> auto operator()(Args&&... args) const {\n      return f(*this, std::forward<Args>(args)...);\n    }\n  };\n  template <class F> auto make_rec(F&& f) { return rec_lambda<F>(std::move(f)); }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n  constexpr char eoln = '\\n';\n  template <class T> T ceildiv(const T& l, const T& r) {\n    return l / r + (l % r != 0 ? 1 : 0);\n  }\n\n} // namespace n91\n#include <cstdint>\n\ntemplate <std::uint_fast64_t mod> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 v;\n\n  constexpr modint(const u64 x = 0) noexcept : v(x% mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint& operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint rhs) noexcept {\n    v = v * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint& operator/=(modint rhs) noexcept {\n    u64 exp = mod - 2;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        *this *= rhs;\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nnamespace n91 {\n\n  void main_() {\n    using mint = modint<1000000007>;\n    const usize n = scan<usize>();\n    const usize m = scan<usize>();\n    std::vector<mint> pow2(n + 1, 1);\n    for (const usize i : rep(0, n)) {\n      pow2[i + 1] = pow2[i] * 2;\n    }\n    std::vector<mint> dp(m + 1, 1);\n    for (const usize loop : rep(0, n)) {\n      std::vector<mint> nx(m + 1, 0);\n      mint acc = 0;\n      for (const usize i : rep(1, m + 1)) {\n        nx[i] = acc + dp[i] * (i + 1);\n        acc *= 2;\n        acc += dp[i] * i;\n      }\n      dp = std::move(nx);\n    }\n    std::cout << dp[m].v << eoln;\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int mod=1000000007;\ninline void add(int &x,int y){(x+=y)>=mod?x-=mod:0;}\ninline int pl(int x,int y){return (x+=y)>=mod?x-mod:x;}\nint n,m,dp[5050],po[5050],ipo[5050];\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tpo[0]=1;ipo[0]=1;\n\tfor(int i=1;i<=m;++i)po[i]=2*po[i-1]%mod,ipo[i]=500000004ll*ipo[i-1]%mod;\n\tfor(int i=1;i<=m;++i)dp[i]=1;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint sum=0,tmp;\n\t\tfor(int j=1;j<=m;++j)\n\t\t{\n\t\t\ttmp=dp[j];\n\t\t\tdp[j]=(1ll*dp[j]*(j+1)+1ll*sum*po[j-1])%mod;\n\t\t\tsum=(sum+1ll*tmp*j%mod*ipo[j])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\",dp[m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Modular {\nprivate:\n    static long long MOD;\n    // a * x + b * y == g; g == gcd(x, y)\n    static void extended_gcd(long long x, long long y, long long& a, long long& b, long long& g) {\n        if (x < 0) {\n            extended_gcd(-x, y, a, b, g);\n            a = -a;\n        } else if (y < 0) {\n            extended_gcd(x, -y, a, b, g);\n            b = -b;\n        } else if (x > y) {\n            extended_gcd(y, x, b, a, g);\n        } else if (x == 0) {\n            a = 0;\n            b = 1;\n            g = y;\n        } else {\n            long long a1 = -1;\n            long long b1 = -1;\n            extended_gcd(y % x, x, a1, b1, g);\n            b = a1;\n            a = b1 - a1 * (y / x);\n        }\n    }\n    static long long mod_inv(long long x, long long m) {\n        long long a = 0;\n        long long b = 0;\n        long long g = 0;\n        extended_gcd(x, m, a, b, g);\n        a = ((a % m) + m) % m;\n        return a;\n    }\npublic:\n    long long value;\n    Modular(): value(0) {}\n    explicit Modular(long long v): value(normalize(v)) {}\n    static long long normalize(long long v) {\n        v = v % MOD;\n        if (v < 0)\n            v += MOD;\n        return v;\n    }\n\n    bool operator==(const Modular& a) const {return value == a.value;}\n    bool operator<(const Modular& a) const { return value < a.value;}\n    Modular operator+=(const Modular& a) {value = normalize(value + a.value); return *this;}\n    Modular operator-=(const Modular& a) {value = normalize(value - a.value); return *this;}\n    Modular operator*=(const Modular& a) {value = normalize(value * a.value); return *this;}\n    Modular operator/=(const Modular& a) {return (*this) *= a.inv();}\n\n    Modular operator++() {value = normalize(value + 1); return *this;}\n    Modular operator--() {value = normalize(value - 1); return *this;}\n    Modular operator++(int) {Modular tmp = *this; value = normalize(value + 1); return tmp;}\n    Modular operator--(int) {Modular tmp = *this; value = normalize(value - 1); return tmp;}\n\n    template <typename T>\n    Modular operator+=(const T& a) {value = normalize(value + a); return *this;}\n    template <typename T>\n    Modular operator-=(const T& a) {value = normalize(value - a); return *this;}\n    template <typename T>\n    Modular operator*=(const T& a) {value = normalize(value * a); return *this;}\n\n    Modular inv() const {return Modular(mod_inv(value, MOD));}\n    Modular pow(long long p) const {  // this doesn't assume prime MOD\n        Modular res(1);\n        Modular sq(value);\n        while (p > 0) {\n            if (p % 2 == 1) {\n                res *= sq;\n            }\n            sq *= sq;\n            p /= 2;\n        }\n        return res;\n    }\n\n    static void set_mod(long long mod) {MOD = mod;}\n};\nlong long Modular::MOD = 0;\n\nModular operator+(const Modular& a, const Modular& b) {Modular c(a); return c += b;}\ntemplate<typename T>\nModular operator+(const Modular& a, const T& b) {return a + Modular(b);}\ntemplate<typename T>\nModular operator+(const T& a, const Modular& b) {return Modular(a) + b;}\n\nModular operator-(const Modular& a, const Modular& b) {Modular c(a); return c -= b;}\ntemplate<typename T>\nModular operator-(const Modular& a, const T& b) {return a - Modular(b);}\ntemplate<typename T>\nModular operator-(const T& a, const Modular& b) {return Modular(a) - b;}\n\nModular operator*(const Modular& a, const Modular& b) {Modular c(a); return c *= b;}\ntemplate<typename T>\nModular operator*(const Modular& a, const T& b) {return a * Modular(b);}\ntemplate<typename T>\nModular operator*(const T& a, const Modular& b) {return Modular(a) * b;}\n\nModular operator/(const Modular& a, const Modular& b) {Modular c(a); return c /= b;}\ntemplate<typename T>\nModular operator/(const Modular& a, const T& b) {return a / Modular(b);}\ntemplate<typename T>\nModular operator/(const T& a, const Modular& b) {return Modular(a) / b;}\n\nstd::ostream& operator<<(std::ostream& os, const Modular& m) {\n    return os << m.value;\n}\n\nstd::istream& operator>>(std::istream& is, Modular& m) {\n    return is >> m.value;\n}\nint main() {\n    Modular::set_mod(1000000007);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<Modular>> dp(n + 1, vector<Modular>(m + 1));\n    for (int i = 0; i <= m; ++i) {\n        dp[0][i] = Modular(1);\n        if (i == 0)\n            dp[1][i] = Modular(1);\n        else\n            dp[1][i] = 2 * dp[1][i - 1];\n    }\n    Modular two(2);\n    for (int i = 2; i <= n; ++i) {\n        for (int j = 0; j <= m; ++j) {\n            dp[i][j] = (j + 1) * dp[i - 1][j];\n            for (int p = 2; p <= j; ++p) {\n                dp[i][j] += two.pow(p - 2) * (j - p + 1) * dp[i - 1][j - p + 1];\n            }\n        }\n    }\n    cout << dp[n][m] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\n#define MOD 1000000007\n\ntemplate<int mod>\nstruct ModInt{\n\tint x;\n\tModInt():x(0){}\n\tModInt(long long y):x(y>=0?y%mod:(mod-(-y)%mod)%mod){}\n\tModInt &operator+=(const ModInt &p){\n\t\tif((x+=p.x)>=mod)x-=mod;\n\t\treturn *this;\n\t}\n\tModInt &operator-=(const ModInt &p){\n\t\tif((x+=mod-p.x)>=mod)x-=mod;\n\t\treturn *this;\n\t}\n\tModInt &operator*=(const ModInt &p){\n\t\tx=(int)(1LL*x*p.x%mod);\n\t\treturn *this;\n\t}\n\tModInt &operator/=(const ModInt &p){\n\t\t*this*=p.inverse();\n\t\treturn *this;\n\t}\n\tModInt &operator^=(long long p){\n\t\tModInt res = 1;\n\t\tfor (; p; p >>= 1) {\n\t\t\tif (p & 1) res *= *this;\n\t\t\t*this *= *this;\n\t\t}\n\t\treturn *this = res;\n\t}\n\tModInt operator-()const{return ModInt(-x);}\n\tModInt operator+(const ModInt &p)const{return ModInt(*this)+=p;}\n\tModInt operator-(const ModInt &p)const{return ModInt(*this)-=p;}\n\tModInt operator*(const ModInt &p)const{return ModInt(*this)*=p;}\n\tModInt operator/(const ModInt &p)const{return ModInt(*this)/=p;}\n\tModInt operator^(long long p)const{return ModInt(*this)^=p;}\n\tbool operator==(const ModInt &p)const{return x==p.x;}\n\tbool operator!=(const ModInt &p)const{return x!=p.x;}\n\texplicit operator int() const { return x; }\t\t\t\t\t\t   // added by QCFium\n\tModInt operator=(const int p) {x = p; return ModInt(*this);} // added by QCFium\n\tModInt inverse()const{\n\t\tint a=x,b=mod,u=1,v=0,t;\n\t\twhile(b>0){\n\t\t\tt=a/b;\n\t\t\ta-=t*b;\n\t\t\tstd::swap(a,b);\n\t\t\tu-=t*v;\n\t\t\tstd::swap(u,v);\n\t\t}\n\t\treturn ModInt(u);\n\t}\n\tfriend std::ostream &operator<<(std::ostream &os,const ModInt<mod> &p){\n\t\treturn os<<p.x;\n\t}\n\tfriend std::istream &operator>>(std::istream &is,ModInt<mod> &a){\n\t\tlong long x;\n\t\tis>>x;\n\t\ta=ModInt<mod>(x);\n\t\treturn (is);\n\t}\n};\ntypedef ModInt<MOD> mint;\n\nstruct MComb {\n\tstd::vector<mint> fact;\n\tstd::vector<mint> inv;\n\tMComb (int n) { // O(n + log(mod))\n\t\tfact = std::vector<mint>(n + 1, 1);\n\t\tfor (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * mint(i);\n\t\tinv.resize(n + 1);\n\t\tinv[n] = fact[n] ^ (MOD - 2);\n\t\tfor (int i = n; i--; ) inv[i] = inv[i + 1] * mint(i + 1);\n\t}\n\tmint ncr(int n, int r) {\n\t\treturn fact[n] * inv[r] * inv[n - r];\n\t}\n\tmint npr(int n, int r) {\n\t\treturn fact[n] * inv[n - r];\n\t}\n\tmint nhr(int n, int r) {\n\t\tassert(n + r - 1 < (int) fact.size());\n\t\treturn ncr(n + r - 1, r);\n\t}\n};\n\n\nint main() {\n\tint n = ri();\n\tint m = ri();\n\tmint dp[n + 1][m + 1];\n\t// dp[n][m] : result\n\tfor (int i = 0; i <= m; i++) dp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdp[i][0] = 1;\n\t\tmint cur = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\t// 000...111\n\t\t\tdp[i][j] += dp[i - 1][j] * (j + 1);\n\t\t\tif (j >= 2) {\n\t\t\t\tcur *= 2;\n\t\t\t\tcur += dp[i - 1][j - 1] * (j - 1);\n\t\t\t}\n\t\t\tdp[i][j] += cur;\n\t\t}\n\t}\n\tstd::cout << dp[n][m] << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint main(){\n    int N, M; cin >> N >> M;\n    vector<long long> dp(M);\n    dp[0] = 2;\n    for(int i=1;i<M;i++) dp[i] = 2 * dp[i-1] % MOD;\n    for(int i=1;i<N;i++){\n        long long add = 0;\n        for(int j=0;j<M;j++){\n            long long cur = dp[j];\n            dp[j] = (cur * (j+2) + add) % MOD;\n            add = (2 * add + cur * (j+1)) % MOD;\n        }\n    }\n    cout << dp.back() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit unsigned int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 1e9 + 7;\nusing mod_int = _m_int<MOD>;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<mod_int> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++) {\n        mod_int sum = 0;\n\n        for (int m = 0; m <= M; m++) {\n            mod_int extra = sum + m * dp[m];\n            dp[m] += extra;\n            sum += extra;\n        }\n    }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nconst int N=5005;\nint n,m;\nint Fac[N],Inv[N];\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint dp[N][N];\nint main(){\n\tn=read(),m=read();\n\tFac[0]=1;\n\tFor(i,1,m)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[m]=Pow(Fac[m],mod-2);\n\tFod(i,m,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n//\toutarr(Fac,0,m);\n//\toutarr(Inv,0,m);\n\tdp[0][1]=1;\n\tFor(i,1,n){\n\t\tFor(j,1,m){\n\t\t\tint v=dp[i-1][j];\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n//\t\t\tprintf(\"dp[%d][%d]=%d\\n\",i-1,j,v);\n\t\t\tint val=(LL)v*(j+1)%mod;\n\t\t\tAdd(dp[i][j],val);\n\t\t\tDel(dp[i][j+1],val);\n\t\t\tval=(LL)v*j*2%mod;\n\t\t\tAdd(dp[i][j+1],val);\n\t\t\tDel(dp[i][m+1],val);\n\t\t}\n\t\tFor(j,1,m)\n\t\t\tAdd(dp[i][j],dp[i][j-1]);\n\t}\n//\toutarr(dp[n],1,m);\n\tint ans=0;\n\tFor(i,1,m)\n\t\tAdd(ans,(LL)dp[n][i]*C(m-1,i-1)%mod);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<set>\n#include<vector>\nusing namespace std;\nint mod=1000000007;\nint inv=(mod+1)/2;\nint add(int x, int y)\n{\n\tint c=x+y;\n\tif(c>=mod)c-=mod;\n\treturn c;\n}\nint sub(int x, int y)\n{\n\tint c=x-y;\n\tif(c<0)c+=mod;\n\treturn c;\n}\nint mlt(int x, int y)\n{\n\tlong long c=x*1LL*y;\n\tif(c>=mod)c%=mod;\n\treturn c;\n}\nvector<int>rec(vector<int>&dp, int m)\n{\n\tvector<int>res(m+1), dpml(m+1), pref(m+1), pows(m+1), dvas(m+1);\n\tpows[0]=1;\n\tdvas[0]=1;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tpows[i] = mlt(pows[i - 1], inv);\n\t\tdvas[i] = mlt(dvas[i - 1], 2);\n\t}\n\tres[1]=add(dp[1],dp[1]);\n\tfor(int i=1; i<=m-1; i++)\n\t{\n\t\tdpml[i]=mlt(dp[i], mlt(pows[i+1], i));\n\t}\n\tpref[0]=0;\n\tfor(int i=1; i<m; i++)\n\t\tpref[i]=add(pref[i-1], dpml[i]);\n\tfor(int i=2; i<=m; i++)\n\t{\n\t\tres[i]=mlt(dp[i], i+1);\n\t//\tcout<<i<<' '<<res[i]<<endl;\n\t\tint val=pref[i-1];\n\t\tval=mlt(val, dvas[i]);\n\t\tres[i]=add(res[i], val);\n\t}\n\treturn res;\n}\nint main()\n{\n\tint n, m;\n\tcin>>n>>m;\n\tvector<int>dp(m+1);\n\tfor(int i=1; i<=m; i++)\n\t\tdp[i]=1;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tdp =rec(dp, m);\n\t\t//for(int i=1; i<=m; i++)cout<<dp[i]<<' ';\n\t//cout << endl;\n\t}\n\tcout<<dp[m]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int M=1000000007;\nconst int inv2=(M+1)/2;\nint dp[5005][5005],inv[5005],p2[5005],s[5005],n,m;\nvoid add(int &x,int y){x+=y;if (x>=M)x-=M;}\n\nint solve(int x,int y){\n\tif (x==n) return 1;\n\tif (dp[x][y]!=-1) return dp[x][y];\n\tint ret=1ll*solve(x+1,y)*(y+1)%M;\n\tfor (int k=2;k<=y;k++) add(ret,1ll*p2[k-2]*(y+1-k)%M*solve(x+1,y+1-k)%M);\n\treturn dp[x][y]=ret;\n}\nint main(){\n\tcin >> n >> m;\n\tp2[0]=1; for (int i=1;i<=5000;i++) p2[i]=p2[i-1]*2%M;\n\tinv[0]=1; for (int i=1;i<=5000;i++) inv[i]=1ll*inv[i-1]*inv2%M;\n\tfor (int i=1;i<=m;i++) dp[n][i]=1;\n\tfor (int i=n-1;i>=0;i--){\n        for (int j=1;j<=m;j++){\n            s[j]=s[j-1];\n            add(s[j],1ll*inv[j]*j%M*dp[i+1][j]%M);\n        }\n        for (int j=1;j<=m;j++){\n            dp[i][j]=1ll*(j+1)*dp[i+1][j]%M;\n            add(dp[i][j],1ll*p2[j-1]*s[j-1]%M);\n        }\n\t}\n\tcout << dp[0][m] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <__int128_t Mod = 0> struct modint {\n  static_assert(!(Mod < 0));\n  using mod_type = typename std::conditional<bool(Mod), const int, int>::type;\n  static mod_type mod;\n  using value_type = int;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\ntemplate <__int128_t Mod> typename modint<Mod>::mod_type modint<Mod>::mod = Mod;\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  using mint = modint_runtime;\n  solver() {\n    // start here!\n    mint::mod = 1e9 + 7;\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=5010,mod=1000000007;\ninline void Add(int &a,int b){a=a+b>=mod?a+b-mod:a+b;}\nint n,m,f[maxn],g[maxn],pv[maxn];\nint main()\n{\n\tcin>>n>>m;\n\tfor(int i=pv[0]=1;i<=m;i++) pv[i]=2ll*pv[i-1]%mod;\n\tf[m]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=m;j++) g[j]=0;\n\t\t/*\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tAdd(g[j],1ll*(j+1)*f[j]%mod);\n\t\t\tfor(int len=2;len<=j;len++)\n\t\t\t\tAdd(g[j-len+1],1ll*f[j]*pv[len-2]%mod*(j-len+1)%mod);\n\t\t}\n\t\t*/\n\t//\tfor(int j=1;j<=m;j++) for(int l=2;j+l-1<=m;l++) Add(g[j],1ll*f[j+l-1]*pv[l-2]%mod);\n\t\tint nowv=0;\n\t\tfor(int j=m;j;j--)\n\t\t{\n\t\t\tAdd(nowv,f[j+1]);\n\t\t\tAdd(g[j],nowv);\n\t\t\tAdd(nowv,nowv);\n\t\t}\n\t\tfor(int j=1;j<=m;j++) g[j]=1ll*g[j]*j%mod;\n\t\tfor(int j=1;j<=m;j++) Add(g[j],1ll*(j+1)*f[j]%mod);\n\t\tfor(int j=1;j<=m;j++) f[j]=g[j];\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=m;i++) Add(ans,f[i]);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define sd(x) scanf(\"%d\", &(x))\n#define pii pair<int, int>\n#define F first\n#define S second\n#define all(c) ((c).begin()), ((c).end())\n#define sz(x) ((int)(x).size())\n#define ld long double\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\", \"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"{\";\n\tfor(int i = 0;i < (int)v.size(); i++){\n\t\tif(i)os<<\", \";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\n#ifdef LOCAL\n#define cerr cout\n#else\n#endif\n\n#define TRACE\n\n#ifdef TRACE\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n\tcerr << name << \" : \" << arg1 << std::endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n\tconst char* comma = strchr(names + 1, ',');cerr.write(names, comma - names) << \" : \" << arg1<<\" | \";__f(comma+1, args...);\n}\n#else\n#define trace(...)\n#endif\nconst int N = 5005;\n\nconst int mod = 1e9 + 7;\ninline int add(int x, int y){ x += y; if(x >= mod) x -= mod; return x;}\ninline int sub(int x, int y){ x -= y; if(x < 0) x += mod; return x;}\ninline int mul(int x, int y){ return (x * 1ll * y) % mod;}\ninline int powr(int a, ll b){\n\tint x = 1 % mod;\n\twhile(b){\n\t\tif(b & 1) x = mul(x, a);\n\t\ta = mul(a, a);\n\t\tb >>= 1;\n\t}\n\treturn x;\n}\ninline int inv(int a){ return powr(a, mod - 2);}\n\nint p2[2*N], invp2[2*N];\nint dp[N], dp2[N];\n\nvoid getDp2(){\n    dp2[0] = 0;\n    for(int r = 1; r < N; r++){\n        dp2[r] = add(dp2[r - 1], mul(r, mul(invp2[r + 1], dp[r])));\n    }\n}\nint main(){\n    p2[0] = invp2[0] = 1;\n    for(int i = 1; i < N; i++) p2[i] = add(p2[i - 1], p2[i - 1]), invp2[i] = inv(p2[i]);\n    for(int i = 0; i < N; i++) dp[i] = 1;\n    int n, m; cin >> n >> m;\n    for(int i = 1; i <= n; i++){\n        getDp2();\n        for(int j = 1; j <= m; j++){\n            dp[j]= mul(dp[j], j + 1);\n            dp[j] = add(dp[j], mul(p2[j], dp2[j - 1]));\n        }\n    }\n    cout << dp[m] << endl;\n}\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int md=1000000007;\nint n,m,i,j,s[5005][5005];\nlong long f[5005][5005],pw2[5005],o[5005],cur,k;\nlong long pw(long long a, int b) {\n  if (b==0) return 1LL;\n  if (b&1) return (pw(a,b-1)*a)%md;\n  long long x=pw(a,b/2);\n  return (x*x)%md;\n}\nint main() {\n  scanf(\"%d%d\",&m,&n);\n  for (pw2[0]=o[0]=i=1; i<=n; i++) {\n    f[0][i]=1;\n    pw2[i]=(pw2[i-1]*2)%md;\n    o[i]=pw(pw2[i],md-2);\n  }\n  for (i=1; i<=m; i++) {\n    for (j=1; j<=n; j++) {\n    f[i][j]=(f[i-1][j]*(j+1LL))%md;\n    cur=0;\n    for (k=1; k<j; k++) {\n      s[i-1][k]=(((f[i-1][k]*k)%md)*o[k+1])%md;\n      cur=(cur+s[i-1][k])%md;\n    }\n    f[i][j]=(f[i][j]+cur*pw2[j])%md;\n    //f[i][j]=(f[i][j]+s[i-1][j-1]*pw2[j])%md;\n    //s[i][j]=(s[i][j-1]+((f[i][j]*j)%md)*o[j+1])%md;\n    s[i][j]=(((f[i][j]*j)%md)*o[j+1])%md;\n    //printf(\"%d %d = %d\\n\",i,j,f[i][j]);\n    }\n  }\n  printf(\"%d\\n\",f[m][n]);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N, M;\n   cin >> N >> M;\n   vector<Mint> dp(M + 1);\n   dp[M] = 1;\n   for (int b = N - 1; b >= 0; --b) {\n      vector<Mint> ndp(M + 1);\n      Mint tot = 0;\n      for (int i = M; i >= 0; --i) {\n         ndp[i] = dp[i] * (i + 1) + tot * i;\n         tot = tot + tot + dp[i]);\n      }\n      dp = move(ndp);\n   }\n   Mint ans = 0;\n   for (auto v : dp) ans += v;\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nvoid chmin(ll &a, ll b) {\n\ta = min(a, b);\n}\nvoid chmax(ll &a, ll b) {\n\ta = max(a, b);\n}\nll mod_pow(ll a, ll n, ll m = mod) {\n\ta %= m;\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * a%m;\n\t\ta = a * a%m; n >>= 1;\n\t}\n\treturn res;\n}\n\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n%mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint &a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint &a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint &a, modint b) { a.n = ((ll)a.n*b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, int n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a*a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p%a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\nconst int max_n = 1 << 18;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nmodint dp[5001][5001];\n\n\nmodint t2[5001];\nmodint invt2[5001];\nvoid solve() {\n\trep(i, 5001) {\n\t\tt2[i] = mod_pow(2, i);\n\t\tinvt2[i] = mod_pow(mod_pow(2, i),mod-2);\n\t}\n\tint n, m; cin >> n >> m;\n\tdp[0][1] = 2;\n\trep1(i, m - 1) {\n\t\tdp[0][i + 1] = dp[0][i] * (modint)2;\n\t}\n\trep(i, n-1) {\n\t\tmodint c = 0;\n\n\t\tRep1(j, 2, m) {\n\t\t\tdp[i + 1][j] += (modint)2 * dp[i+1][j-1];\n\t\t\tdp[i + 1][j] += (modint)(j-1)*dp[i][j - 1];\n\t\t}\n\t\trep1(j, m) {\n\t\t\tdp[i + 1][j] += dp[i][j] * (modint)(j + 1);\n\t\t}\n\t}\n\t/*rep(i, n - 1) {\n\t\trep1(j, m) {\n\t\t\trep1(k, j - 1) {\n\t\t\t\tdp[i + 1][j] += t2[j - k - 1] * (modint)k*dp[i][k];\n\t\t\t}\n\t\t}\n\t\trep1(j, m) {\n\t\t\tdp[i + 1][j] += dp[i][j] * (modint)(j + 1);\n\t\t}\n\t}*/\n\n\t/*rep(i, n) {\n\t\trep1(j, m) {\n\t\t\tcout << dp[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}*/\n\tcout << dp[n-1][m] << \"\\n\";\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\tinit_f();\n\t//init();\n\t//int t; cin >> t; rep(i, t)solve();\n\tsolve();\n\tstop\n\t\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize (\"O2,unroll-loops\")\n//#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef pair<ll, ll> pll;\n#define debug(x) cerr<<#x<<'='<<(x)<<endl;\n#define debugp(x) cerr<<#x<<\"= {\"<<(x.first)<<\", \"<<(x.second)<<\"}\"<<endl;\n#define debug2(x, y) cerr<<\"{\"<<#x<<\", \"<<#y<<\"} = {\"<<(x)<<\", \"<<(y)<<\"}\"<<endl;\n#define debugv(v) {cerr<<#v<<\" : \";for (auto x:v) cerr<<x<<' ';cerr<<endl;}\n#define all(x) x.begin(), x.end()\n#define pb push_back\n#define kill(x) return cout<<x<<'\\n', 0;\n\nconst int inf=1000000010;\nconst ll INF=10000000000000010LL;\nconst int mod=1000000007;\nconst int N=5010;\n\nll n, m, k, u, v, x, y, t, a, b, ans;\nll dp[N][N];\n\nint main(){\n\tios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0);\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\tdp[1][1]=2;\n\tfor (int m=2; m<N; m++) dp[1][m]=dp[1][m-1]*2%mod;\n\tfor (int n=2; n<N; n++){\n\t\tdp[n][1]=dp[n-1][1]*2%mod;\n\t\tfor (int m=2; m<N; m++){\n\t\t\tll sum=(dp[n][m-1]-dp[n-1][m-1]*m)*2%mod;\n\t\t\tdp[n][m]=(dp[n-1][m]*(m+1) + dp[n-1][m-1]*(m-1) + sum)%mod;\n\t\t}\n\t}\n\tcin>>n>>m;\n\tif (dp[n][m]<0) dp[n][m]+=mod;\n\tcout<<dp[n][m]<<\"\\n\";\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\n\nconst int mod = 1000000007;\n\nlong long b[5001];\nlong long dp[5001][5001];\n\nint main() {\n    int n, m, i, j;\n    \n    scanf(\"%d %d\", &n, &m);\n    \n    b[0] = 1;\n    for (i = 1; i <= m; i++) b[i] = b[i - 1] * 2 % mod;\n    \n    for (i = 0; i <= m; i++) dp[0][i] = 1;\n    \n    for (i = 0; i < n; i++) {\n        long long sum = 0;\n        \n        for (j = 0; j <= m; j++) {\n            dp[i + 1][j] = (dp[i][j] * (j + 1) + sum) % mod;\n            \n            sum *= 2;\n            sum += dp[i][j] * j;\n            sum %= mod;\n        }\n    }\n    \n    printf(\"%lld\\n\", dp[n][m] % mod);\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nll mod = 1000000007;\nll dp[5555][5555];\nll zdp[5555];\nll p2[5555], ip2[5555];\nint main()\n{\n\tint hei, len;\n\tscanf(\"%d%d\", &hei, &len);\n\tp2[0] = ip2[0] = 1;\n\tfor (int i = 1; i <= 5050; i++)p2[i] = p2[i - 1] * 2 % mod, ip2[i] = ip2[i - 1] * ((mod + 1) / 2) % mod;\n\tdp[0][len] = 1;\n\tfor (int i = 0; i < hei; i++)\n\t{\n\t\tfor (int j = 1; j <= len; j++)zdp[j] = dp[i][j] * p2[j] % mod;\n\t\tfor (int j = 1; j <= len; j++)zdp[j] = (zdp[j] + zdp[j - 1]) % mod;\n\t\tfor (int j = 1; j <= len; j++)dp[i + 1][j] = (zdp[len] + mod - zdp[j])*ip2[j + 1] % mod*j%mod;\n\t\tfor (int j = 1; j <= len; j++)dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * (j + 1)) % mod;\n\t\t//for (int j = 1; j <= len; j++)printf(\"%lld \", dp[i + 1][j]); printf(\"\\n\");\n\t}\n\tll r = 0;\n\tfor (int i = 1; i <= len; i++)r = (r + dp[hei][i]) % mod;\n\tprintf(\"%lld\\n\", r);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/trie_policy.hpp>\n\n#define pb push_back\n#define mp make_pair\n#define taskname \"A\"\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> ii;\ntypedef tree <int,null_type,less<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\n\nconst int maxn = 5e3 + 5;\nconst int mod = 1e9 + 7;\nint n, m;\nint f[maxn][maxn];\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    if(fopen(taskname\".INP\",\"r\")){\n\t\tfreopen(taskname\".INP\", \"r\",stdin);\n\t\tfreopen(taskname\".OUT\", \"w\",stdout);\n    }\n    cin >> n >> m;\n    for(int i = 0 ; i <= m ; ++i)f[0][i] = 1;\n    for(int i = 1 ; i <= n ; ++i){\n        for(int j = 1 ; j <= m ; ++j){\n            f[i][j] = (f[i][j - 1] * 2 + (ll)f[i - 1][j - 1] * (j - 1)) % mod;\n        }\n        for(int j = 1 ; j <= m ; ++j){\n            f[i][j] = (f[i][j] + (ll)f[i - 1][j] * (j + 1)) % mod;\n        }\n    }\n    cout << f[n][m];\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nconst int N=5005;\nint n,m;\nint Fac[N],Inv[N];\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nint dp[N][N];\nint main(){\n\tn=read(),m=read();\n\tFac[0]=1;\n\tFor(i,1,m)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[m]=Pow(Fac[m],mod-2);\n\tFod(i,m,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n\tdp[0][1]=1;\n\tFor(i,1,n){\n\t\tFor(j,1,m){\n\t\t\tint v=dp[i-1][j];\n\t\t\tif (!v)\n\t\t\t\tcontinue;\n\t\t\tint val=(LL)v*(j+1)%mod;\n\t\t\tAdd(dp[i][j],val);\n\t\t\tDel(dp[i][j+1],val);\n\t\t\tval=(LL)v*j*2%mod;\n\t\t\tAdd(dp[i][j+1],val);\n\t\t}\n\t\tFor(j,1,m)\n\t\t\tAdd(dp[i][j],dp[i][j-1]);\n\t}\n\tint ans=0;\n\tFor(i,1,m)\n\t\tAdd(ans,(LL)dp[n][i]*C(m-1,i-1)%mod);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n, m;\nconst int mod = (int)1e9 + 7;\nconst int maxN = 5005;\nint mult(int a, int b) {\n    return (1LL * a * b) % mod;\n}\n\nint pw(int a, int b) {\n    if (b == 0) return 1;\n    if (b & 1) return mult(a, pw(a, b - 1));\n    int res = pw(a, b / 2);\n    return mult(res, res);\n}\n\nint sub(int a, int b) {\n    int s = a - b;\n    if (s < 0) s += mod;\n    return s;\n}\n\nint sum(int a, int b) {\n    int s = a + b;\n    if (s >= mod) s -= mod;\n    return s;\n};\n\nint fact[maxN], invfact[maxN], inv[maxN];\n\nvoid init() {\n    inv[1] = invfact[1] = invfact[0] = fact[0] = fact[1] = 1;\n    for (int i = 2; i < maxN; i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv[i] = mult(inv[mod % i], mod - mod / i);\n        invfact[i] = mult(invfact[i - 1], inv[i]);\n    }\n}\n\nint cnk(int n, int k) {\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return mult(fact[n], mult(invfact[k], invfact[n - k]));\n}\n\nint invNumber(int a) {\n    return pw(a, mod - 2);\n}\nint pw2[maxN];\nint inv2[maxN];\nint dp[maxN][maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    init();\n    cin >> n >> m;\n    pw2[0] = 1;\n    inv2[0] = 1;\n    for (int i = 1; i <= m; i++) inv2[i] = mult(inv2[i - 1], pw(2, mod - 2));\n    for (int i = 1; i <= m; i++) pw2[i] = mult(2, pw2[i - 1]);\n    for (int i = 1; i <= m; i++) dp[0][i] = 1;\n    for (int bit = 0; bit < n; bit++) {\n        int cur_sum = 0;\n        for (int i = 1; i <= m; i++) {\n            if (i > 1) {\n                cur_sum = sum(cur_sum, mult(dp[bit][i - 1], mult(i - 1, inv2[i - 1])));\n            }\n            dp[bit + 1][i] = mult(cur_sum, pw2[i - 1]);\n            dp[bit + 1][i] = sum(dp[bit + 1][i], mult(dp[bit][i], i + 1));\n        }\n    }\n    cout << dp[n][m];\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nconstexpr int P = 1000000007, N = 5e3;\nint dp[N + 1][N + 1];\nint main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    int n, m;\n    std::cin >> n >> m;\n    for (int i = 1; i <= m; ++i)\n        dp[0][i] = 1;\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j)\n            dp[i][j] = 1ll * (j + 1) * dp[i - 1][j] % P;\n        for (int j = 1, k = 1; j <= m; ++j, k = 1ll * k * (P + 1) / 2 % P)\n            dp[i - 1][j] = (dp[i - 1][j - 1] + 1ll * dp[i - 1][j] * j % P * k) % P;\n        for (int j = 2, k = 1; j <= m; ++j, k = 2 * k % P)\n            dp[i][j] = (dp[i][j] + 1ll * k * dp[i - 1][j - 1]) % P;\n    }\n    std::cout << dp[n][m] << std::endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int inf = 2147483647;\nconst int mod = 1e9 + 7;\nconst int N = 5e3 + 1;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI LL read() {\n\tLL x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nI int pow_mod(reg a, reg k) {reg ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nint f[N][N], g[N];\n\nint main() {\n\treg n = read(), m = read();\n\tfo(i, 1, m) f[0][i] = 1;\n\tfo(i, 1, n) {\n\t\treg s = 0;\n\t\tfo(j, 1, m) f[i][j] = ((LL)f[i - 1][j] * (j + 1) + s) % mod, s = (2LL * s + (LL)f[i - 1][j] * j) % mod;\n\t} pr2(f[n][m] < 0 ? f[n][m] + mod : f[n][m]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    mmat dp(N + 1, mvec(M + 1, 0));\n    dp[0][M] = 1;\n    REP(i, N){\n        FOR(j, 1, M + 1) dp[i + 1][j] += dp[i][j] * (j + 1);\n        IFOR(j, 1, M) dp[i][j] += dp[i][j + 1] * 2;\n        FOR(j, 1, M) dp[i + 1][j] += dp[i][j + 1] * j;\n    }\n    \n    mint ans = 0;\n    REP(j, M + 1) ans += dp[N][j];\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nlong long n,m,i,j,f[5005][5005],sum;\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tf[0][m]=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(sum=0,j=m;j>=1;j--){\n\t\t\tf[i][j]=(sum*j+f[i-1][j]*(j+1))%mo;\n\t\t\tsum=(sum*2+f[i-1][j])%mo;\n\t\t}\n\tfor(i=1,sum=0;i<=m;i++)\n\t\tsum=(sum+f[n][i])%mo;\n\tprintf(\"%lld\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005,mod=1e9+7;\ntypedef long long ll;\nint n,m,dp[N][N];\nint main()\n{\n    //int p[N];p[0]=1;for(int i=1;i<N;i++) p[i]=(p[i-1]<<1)%mod;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++) dp[0][i]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=1,sum=0;j<=m;j++)\n    {\n        dp[i][j]=(dp[i][j]+(ll)dp[i-1][j]*(j+1)+sum)%mod;\n        sum=(sum*2%mod+(ll)dp[i-1][j]*j)%mod;\n        //dp[i][j]=(dp[i][j]+(ll)(dp[i][j-1]-(ll)dp[i-1][j-1]*j%mod+mod)%mod*2%mod+(ll)dp[i-1][j-1]*(j-1))%mod;\n        /*\n        for(int k=2;k<=j;k++)\n            dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k+1]*(j-k+1)%mod*p[k-2]%mod)%mod;\n        */\n    }\n    printf(\"%d\\n\",dp[n][m]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nconst int N = 5050;\n\nint dp[N][N];\n\nvoid insum(int & a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int j = 1; j <= m; ++j) {\n        dp[n - 1][j] = pw(2, j);\n    }\n\n    for (int i = n - 2; i >= 0; --i) {\n        /* no 01 */;\n        for (int j = 1; j <= m; ++j) {\n            insum(dp[i][j], (ll) dp[i + 1][j] * (j + 1) % M);\n            dp[i + 1][j] = (ll) dp[i + 1][j] * j % M;\n        }\n        /* at least one 01 */;\n        for (int j = 1; j <= m; ++j) {\n            for (int k = 1; k < j; ++k) {\n                insum(dp[i][j], (ll) dp[i + 1][k] * pw(2, j - k - 1) % M);\n            }\n        }\n    }\n    cout << dp[0][m];\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\nusing mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\nmint pow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n = n << 1;\n\t}\n\treturn ans;\n}\nsigned main() {\n\tomajinai;\n\tusing mint = modint<1000000007>;\n\tint n, m; cin >> n >> m;\n\tvvem dp(n + 1, vem(m + 1, 0));\n\tfor (int i = 1; i <= m; i++) {\n\t\tdp[1][i] = pow(2, i);\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tmint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tdp[i][j] += sum + dp[i - 1][j] * (j + 1);\n\t\t\tsum *= 2;\n\t\t\tsum += dp[i - 1][j] * j;\n\t\t}\n\t}\n\tcout << dp[n][m].value << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> p_ll;\n\ntemplate<class T>\nvoid debug(T itr1, T itr2) { auto now = itr1; while(now<itr2) { cout << *now << \" \"; now++; } cout << endl; }\n#define repr(i,from,to) for (int i=(int)from; i<(int)to; i++)\n#define all(vec) vec.begin(), vec.end()\n#define rep(i,N) repr(i,0,N)\n#define per(i,N) for (int i=(int)N-1; i>=0; i--)\n\nconst ll MOD = pow(10,9)+7;\nconst ll LLINF = pow(2,61)-1;\nconst int INF = pow(2,30)-1;\n\nvector<ll> fac;\nvoid c_fac(int x=pow(10,6)+10) { fac.resize(x,true); rep(i,x) fac[i] = i ? (fac[i-1]*i)%MOD : 1; }\nll inv(ll a, ll m=MOD) { ll b = m, x = 1, y = 0; while (b!=0) { int d = a/b; a -= b*d; swap(a,b); x -= y*d; swap(x,y); } return (x+m)%m; }\nll nck(ll n, ll k) { return fac[n]*inv(fac[k]*fac[n-k]%MOD)%MOD; }\nll gcd(ll a, ll b) { if (a<b) swap(a,b); return b==0 ? a : gcd(b, a%b); }\nll lcm(ll a, ll b) { return a/gcd(a,b)*b; }\n\n\nint main() {\n  ll N, M; cin >> N >> M;\n  ll p2[10000]; rep(i,10000) p2[i] = i==0 ? 1 : p2[i-1]*2%MOD;\n  ll inv2 = inv(2);\n  ll invp2[100000]; rep(i,10000) invp2[i] = i==0 ? 1 : invp2[i-1]*inv2%MOD;\n\n  ll dp[N][M+1] = {};\n  rep(i,N) {\n    if (i==0) rep(j,M+1) dp[i][j] = p2[j];\n    else {\n      ll now = 0;\n      repr(j,1,M+1) {\n        dp[i][j] = ( dp[i][j] + dp[i-1][j]*(j+1) ) % MOD;\n        dp[i][j] = ( dp[i][j] + now*p2[j-1] ) % MOD;\n        now = ( now + dp[i-1][j] * j % MOD * invp2[j] ) % MOD;\n        // cout << i << \" \" << j << \"->\" << now << endl;\n      }\n    }\n  }\n  // rep(i,N) debug(dp[i], dp[i]+(M+1));\n\n  ll result = dp[N-1][M];\n  cout << result << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll _v):v(normS(_v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tModInt& operator++(int){ return *this=*this+1;}\n\tModInt& operator--(int){ return *this=*this-1;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll p[]={a,1,0},q[]={b,0,1};\n\t\twhile(*q){\n\t\t\tll t=*p/ *q;\n\t\t\trep(i,3) swap(p[i]-=t*q[i],q[i]);\n\t\t}\n\t\tif(p[0]<0) rep(i,3) p[i]=-p[i];\n\t\tx=p[1],y=p[2];\n\t\treturn p[0];\n\t}\n\tModInt inv() const {\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tModInt pow(ll p) const {\n\t\tif(p<0) return inv().pow(-p);\n\t\tModInt a = 1;\n\t\tModInt x = *this;\n\t\twhile(p){\n\t\t\tif(p&1) a *= x;\n\t\t\tx *= x;\n\t\t\tp >>= 1;\n\t\t}\n\t\treturn a;\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<1000000007>;\n\nV<mint> fact,ifact;\nmint Choose(int a,int b){\n\tif(b<0 || a<b) return 0;\n\treturn fact[a] * ifact[b] * ifact[a-b];\n}\nvoid InitFact(int N){\n\tfact.resize(N);\n\tifact.resize(N);\n\tfact[0] = 1;\n\trep1(i,N-1) fact[i] = fact[i-1] * i;\n\tifact[N-1] = fact[N-1].inv();\n\tfor(int i=N-2;i>=0;i--) ifact[i] = ifact[i+1] * (i+1);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\tInitFact(100000);\n\n\tint N,M; cin >> M >> N;\n\tV<mint> dp(N+1); dp[N] = 1;\n\trep(_,M){\n\t\tV<mint> nx(N+1);\n\t\tV<mint> s(N+1);\n\t\t{\n\t\t\tmint a = mint(1)/2;\n\t\t\trep1(k,N){\n\t\t\t\ts[k] = s[k-1] + dp[k] * a;\n\t\t\t\ta *= 2;\n\t\t\t}\n\t\t}\n\t\tmint a = 1;\n\t\trep1(k,N){\n\t\t\t// rep(f,k-1){\n\t\t\t// \tnx[f+1] += dp[k] * mint(2).pow(k-f-2) * (f+1);\n\t\t\t// }\n\t\t\tnx[k] += (s[N]-s[k]) * a * k;\n\t\t\tnx[k] += dp[k] * (k+1);\n\t\t\ta /= 2;\n\t\t}\n\t\tdp = nx;\n\t\tshow(dp);\n\t}\n\tcout << accumulate(all(dp),mint(0)) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  intmax_t dist(ng - ok);\n  while (std::abs(dist) > 1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (eps < std::abs(ok - ng)) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n}  // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n#line 7 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n// template <auto mod> class modint;\ntemplate <auto &mod> class modint {\n  int val;\n\n public:\n  static constexpr modint identity() noexcept { return 1; }\n  constexpr modint() noexcept : val(0) {}\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type _val) noexcept\n      : val((_val %= mod) < 0 ? mod + _val : _val) {}\n  constexpr long long value() const noexcept { return val; }\n  constexpr modint operator++(int) noexcept {\n    modint t = *this;\n    return ++val, t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t = *this;\n    return --val, t;\n  }\n  constexpr modint &operator++() noexcept { return ++val, *this; }\n  constexpr modint &operator--() noexcept { return --val, *this; }\n  constexpr modint operator-() const noexcept { return modint(-val); }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (val += rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return val = (long long)val * rhs.val % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return *this *= inverse(rhs);\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint &rhs) const noexcept {\n    return val == rhs.val;\n  }\n  constexpr bool operator!=(const modint &rhs) const noexcept {\n    return val != rhs.val;\n  }\n  constexpr bool operator!() const noexcept { return !val; }\n  friend constexpr modint operator+(long long lhs, modint rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  friend constexpr modint operator-(long long lhs, modint rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  friend constexpr modint operator*(long long lhs, modint rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  friend constexpr modint operator/(long long lhs, modint rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  static constexpr modint inverse(const modint &rhs) noexcept {\n    assert(rhs != 0);\n    int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  static constexpr modint pow(modint rhs, long long e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.val;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    long long val;\n    rhs = {(is >> val, val)};\n    return is;\n  }\n};  // class modint\n/*\ntemplate <int &mod> class modint {\n  int val;\n\n public:\n  static constexpr modint identity() noexcept { return 1; }\n  constexpr modint() noexcept : val(0) {}\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type _val) noexcept\n      : val((_val %= mod) < 0 ? mod + _val : _val) {}\n  constexpr long long value() const noexcept { return val; }\n  constexpr modint operator++(int) noexcept {\n    modint t = *this;\n    return ++val, t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t = *this;\n    return --val, t;\n  }\n  constexpr modint &operator++() noexcept { return ++val, *this; }\n  constexpr modint &operator--() noexcept { return --val, *this; }\n  constexpr modint operator-() const noexcept { return modint(-val); }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (val += rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return val = (long long)val * rhs.val % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return *this *= inverse(rhs);\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint &rhs) const noexcept {\n    return val == rhs.val;\n  }\n  constexpr bool operator!=(const modint &rhs) const noexcept {\n    return val != rhs.val;\n  }\n  constexpr bool operator!() const noexcept { return !val; }\n  friend constexpr modint operator+(long long lhs, modint rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  friend constexpr modint operator-(long long lhs, modint rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  friend constexpr modint operator*(long long lhs, modint rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  friend constexpr modint operator/(long long lhs, modint rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  static constexpr modint inverse(const modint &rhs) noexcept {\n    assert(rhs != 0);\n    int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  static constexpr modint pow(modint rhs, long long e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.val;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    long long val;\n    rhs = {(is >> val, val)};\n    return is;\n  }\n};  // class modint\n*/\n\nstruct workspace::solver {\n  solver() {\n    static int mod = 1000000007;\n    using mint = modint<mod>;\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n      // dump(nx);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e3+10;\nconst int mod=1e9+7;\nconst int inv2=(mod+1)>>1;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nint n,m,f[N][N],bin[N],ibin[N];\n\nint main() {\n\tcin>>n>>m;\n\tbin[0]=1;for(int i=1;i<N;i++) bin[i]=(bin[i-1]<<1)%mod;\n\tibin[0]=1;for(int i=1;i<N;i++) ibin[i]=1ll*ibin[i-1]*inv2%mod;\n\tfor(int i=0;i<=n;i++) {\n\t\tint sum=0;\n\t\tfor(int j=0;j<=m;j++) {\n\t\t\tif(i==0||j==0) f[i][j]=1;\n\t\t\telse {\n\t\t\t\tf[i][j]=(1ll*f[i-1][j]*(j+1)+1ll*bin[j-1]*sum)%mod;\n\t\t\t}\n\t\t\tif(j) sum=(sum+1ll*f[i-1][j]*j%mod*ibin[j])%mod;\n\t\t}\n\t}\n\tcout<<f[n][m];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n \ntypedef long long int ll;\n\nconst int MOD = 1e9 + 7;\nconst int INV2 = MOD/2 + 1;\nconst int N = 5050;\n\nint n,m,pot[N],ipot[N];\nint dp[N][N], cum[N];\n\nvoid add(int &x, int y) {\n    x += y;\n    if (x >= MOD) x -= MOD;\n}\n \nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cin >> n >> m;\n\n    pot[0] = ipot[0] = 1;\n    forsn(n,1,N) {\n        pot[n] = 2 * pot[n-1] % MOD;\n        ipot[n] = ll(INV2) * ipot[n-1] % MOD;\n    }\n\n    for (int j = 1; j <= m; j++) dp[0][j] = 1;\n    for (int i = 1; i <= n; i++) {\n        forn(j,m+1) {\n            cum[j+1] = cum[j];\n            add(cum[j+1], (ll) ipot[j] * j % MOD * dp[i-1][j] % MOD);\n        }\n        forsn(j,1,m+1) {\n            dp[i][j] = ll(j+1)*dp[i-1][j]%MOD;\n            add(dp[i][j], (ll) pot[j-1] * cum[j] % MOD);\n        }\n    }\n    cout << dp[n][m];\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\nusing mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\nmint pow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n = n << 1;\n\t}\n\treturn ans;\n}\nsigned main() {\n\tomajinai;\n\tusing mint = modint<1000000007>;\n\tint n, m; cin >> n >> m;\n\tvvem dp(n + 1, vem(m + 1, 0));\n\tfor (int i = 1; i <= m; i++) {\n\t\tdp[1][i] = pow(2, i);\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tmint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tdp[i][j] += sum + dp[i - 1][j] * (j + 1);\n\t\t\tsum *= 2;\n\t\t\tsum += dp[i - 1][j] * j;\n\t\t}\n\t}\n\tcout << dp[n][m].value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cerr << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcerr<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 500010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = (1 << 30) - 1;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\nmt19937 rng; //use it by rng() % mod, shuffle(all(vec), rng)\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\n\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll C(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\nint N, M;\nll dp[2][5010];\nll ep[5010];\nll pow2[MAX_N], ipow2[MAX_N];\n\nvoid solve() {\n\tcin >> N >> M;\n\tpow2[0] = 1;\n\tipow2[0] = 1;\n\tll inv2 = mod_pow(2, mod - 2);\n\trep(i, 0, M + 1) {\n\t\tpow2[i + 1] = pow2[i] * 2 % mod;\n\t\tipow2[i + 1] = ipow2[i] * inv2 % mod;\n\t}\n\tint now = 0, nex = 1;\n\tdp[now][M] = 1;\n\trep(i, 0, N) {\n\t\tmemset(dp[nex], 0, sizeof(dp[nex]));\n\t\tmemset(ep, 0, sizeof(ep));\n\t\trep(j, 0, M + 1) {\n\t\t\tep[j + 1] = (ep[j] + dp[now][j] * pow2[j] % mod) % mod;\n\t\t\t// debug(j, ep[j + 1]);\n\t\t}\n\t\trep(u, 1, M) {\n\t\t\tdp[nex][u] = (mod + ep[M + 1] - ep[u + 1]) % mod * ipow2[u + 1] % mod * u % mod;\n\t\t}\n\t\trep(j, 0, M + 1) {\n\t\t\tADD(dp[nex][j], (j + 1) * dp[now][j] % mod);\n\t\t\t// debug(i, j, dp[now][j]);\n\t\t}\n\t\tswap(now, nex);\n\t}\n\tll res = 0;\n\trep(j, 1, M + 1) {\n\t\tADD(res, dp[now][j]);\n\t}\n\tcout << res << \"\\n\";\n}\n\nuint32_t rd() {\n\tuint32_t res;\n#ifdef __MINGW32__\n\tasm volatile(\"rdrand %0\" :\"=a\"(res) ::\"cc\");\n#else\n\tres = std::random_device()();\n#endif\n\treturn res;\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n    cerr << fixed;\n\tcerr.precision(6);\n\trng.seed(rd());\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n\tif(!freopen(\"in.txt\", \"rt\", stdin)) return 1;\n#endif\t\n\tsolve();\n    cerr << \"Time: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nll mpower(ll a,ll b,ll c){\n  int z;\n  if(b==0){\n    z=1;\n    z%=c;\n    return z;\n  }\n  if(b==1){\n    z=a;\n    z%=c;\n    return z;\n  }\n  else{\n    return (((mpower(a,b/2,c))*(mpower(a,b/2,c))%c)*mpower(a,b%2,c)%c);\n  }\n}\n//aのｂ乗をｃで割った余り\n\nint main(){\n  ll mod=1e9+7;\n  ll ans=1;\n  ll n,m;\n  cin>>n>>m;\n  ans=mpower(2,n,mod);\n  ans*=mpower(mpower(2,n,mod)-1,m-1,mod);\n  ans%=mod;\n  ll p=1;\n  ll q=mpower(2,n,mod)+m-1;\n  for(int i=0;i<m;i++){\n    p*=q;\n    p%=mod;\n    q--;\n  }\n  for(int i=1;i<=m;i++){\n    p*=mpower(i,mod-2,mod);\n    p%=mod;\n  }\n  cout<<(ans+p/2)%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int64_t MOD = 1e9+7;\nvoid add(int64_t& a, int64_t b){\n    a = (a+b) % MOD;\n}\nvoid mul(int64_t& a, int64_t b){\n    a = a*b % MOD;\n}\n\nint64_t power_mod(int64_t num, int64_t power){\n    int64_t prod = 1;\n    num %= MOD;\n    while(power > 0){\n        if(power&1) prod = prod * num % MOD;\n        num = num * num % MOD;\n        power >>= 1;\n    }\n    return prod;\n}\n\nint64_t extgcd(int64_t a, int64_t b, int64_t& x, int64_t& y){\n    int64_t d = a;\n    if(b != 0){\n        d = extgcd(b, a%b, y, x);\n        y -= (a/b) * x;\n    }else{\n        x = 1; y = 0;\n    }\n    return d;\n}\n\nint64_t inv_mod(int64_t a){\n    int64_t x, y;\n    extgcd(a, MOD, x, y);\n    return (MOD + x%MOD) % MOD;\n}\n\nvector<int64_t> fact, fact_inv;\n\nvoid create_mod_tables(int num){\n    fact.assign(num+1, 1);\n    fact_inv.assign(num+1, 1);\n    for(int i=1; i<=num; i++) fact[i] = fact[i-1] * i % MOD;\n    fact_inv[num] = inv_mod(fact[num]);\n    for(int i=num; i>0; i--) fact_inv[i-1] = fact_inv[i] * i % MOD;\n}\n\nint64_t comb_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD * fact_inv[k] % MOD;\n}\n\nint64_t perm_mod(int n, int k){\n    return fact[n] * fact_inv[n-k] % MOD;\n}\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n \n    static int64_t dp[5001][5001];\n    for(int j=1; j<=M; j++) dp[0][j] = 1;\n    for(int i=1; i<=N; i++){\n        int64_t now = 0;\n        for(int j=1; j<=M; j++){\n            add(dp[i][j], now);\n            mul(now, 2);\n            add(now, dp[i-1][j]*j);\n        }\n        for(int j=1; j<=M; j++) add(dp[i][j], (j+1)*dp[i-1][j]);\n    }\n    cout << dp[N][M] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nconst int N = 5050;\nconst int K = 1e18;\nconst int M = 1e9;\nconst int mod = 1e9 + 7;\nint dp[N][N], s[N][N], p[N];\nint binpow(int x, int y){\n    int res = 1;\n    while(y){\n        if (y % 2){\n            res = res * x % mod;\n        }\n        x = x * x % mod;\n        y /= 2;\n    }\n    return res;\n}\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int n, m;\n    cin >> n >> m;\n    for (int i = 0; i <= m; i++){\n        p[i] = binpow(binpow(2, i), mod - 2);;\n    }\n    for (int i = 1; i <= m; i++){\n        dp[1][i] = binpow(2, i);\n        s[1][i] = (s[1][i - 1] + i * p[i] % mod * dp[1][i]) % mod;\n    }\n    for (int i = 2; i <= n; i++){\n        for (int j = 1; j <= m; j++){\n            dp[i][j] = ((j + 1) * dp[i - 1][j] + binpow(2, j - 1) * s[i - 1][j - 1]) % mod;\n            s[i][j] = (s[i][j - 1] + j * p[j] % mod * dp[i][j]) % mod;\n        }\n    }\n    cout << dp[n][m];\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  struct rep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr rep(const usize f, const usize l) noexcept\n      : f(std::min(f, l)), l(l) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  struct revrep {\n    struct itr {\n      usize i;\n      constexpr itr(const usize i) noexcept : i(i) {}\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    const itr f, l;\n    constexpr revrep(const usize f, const usize l) noexcept\n      : f(l - 1), l(std::min(f, l) - 1) {}\n    constexpr auto begin() const noexcept { return f; }\n    constexpr auto end() const noexcept { return l; }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) noexcept {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> void chmin(T& a, const T& b) noexcept {\n    if (b < a)\n      a = b;\n  }\n  template <class T> void chmax(T& a, const T& b) noexcept {\n    if (a < b)\n      a = b;\n  }\n  template <class F> class rec_lambda {\n    F f;\n\n  public:\n    rec_lambda(F&& f) : f(std::move(f)) {}\n    template <class... Args> auto operator()(Args&&... args) const {\n      return f(*this, std::forward<Args>(args)...);\n    }\n  };\n  template <class F> auto make_rec(F&& f) { return rec_lambda<F>(std::move(f)); }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n  constexpr char eoln = '\\n';\n  template <class T> T ceildiv(const T& l, const T& r) {\n    return l / r + (l % r != 0 ? 1 : 0);\n  }\n\n} // namespace n91\n#include <cstdint>\n\ntemplate <std::uint_fast64_t mod> class modint {\n  using u64 = std::uint_fast64_t;\n\npublic:\n  u64 v;\n\n  constexpr modint(const u64 x = 0) noexcept : v(x% mod) {}\n  constexpr modint operator+(const modint rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr modint& operator+=(const modint rhs) noexcept {\n    v += rhs.v;\n    if (v >= mod)\n      v -= mod;\n    return *this;\n  }\n  constexpr modint& operator-=(const modint rhs) noexcept {\n    if (v < rhs.v)\n      v += mod;\n    v -= rhs.v;\n    return *this;\n  }\n  constexpr modint& operator*=(const modint rhs) noexcept {\n    v = v * rhs.v % mod;\n    return *this;\n  }\n  constexpr modint& operator/=(modint rhs) noexcept {\n    u64 exp = mod - 2;\n    while (exp != 0) {\n      if (exp % 2 != 0)\n        *this *= rhs;\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n};\nnamespace n91 {\n\n  void main_() {\n    /*\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n    //*/\n    using mint = modint<1000000007>;\n    const usize n = scan<usize>();\n    const usize m = scan<usize>();\n    std::vector<mint> pow2(n + 1, 1);\n    for (const usize i : rep(0, n)) {\n      pow2[i + 1] = pow2[i] * 2;\n    }\n    std::vector<mint> dp(m + 1, 1);\n    for (const usize loop : rep(0, n)) {\n      std::vector<mint> nx(m + 1, 0);\n      mint acc = 0;\n      for (const usize i : rep(1, m + 1)) {\n        nx[i] = acc + dp[i] * (i + 1);\n        acc *= 2;\n        acc += dp[i] * i;\n      }\n      dp = std::move(nx);\n    }\n    std::cout << dp[m].v << eoln;\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst ll p=1e9+7;\nll n,m,i,j,f[5010][5010],g[5010][5010];\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tfor(i=1;i<=m;i++)f[0][i]=1;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tg[i-1][j]=(g[i-1][j-1]*2%p+f[i-1][j]*j%p)%p;\n\t\t\tf[i][j]=(g[i-1][j-1]+f[i-1][j]*(j+1))%p;\n\t\t}\n\t}\n\tprintf(\"%lld\",f[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<string>\n#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<math.h>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int N=5000+100;\nconst db pi=acos(-1.0);\n#define lowbit(x) ((x)&(-x))\n#define sqr(x) (x)*(x)\n#define rep(i,a,b) for (register int i=a;i<=b;i++)\n#define per(i,a,b) for (register int i=a;i>=b;i--)\n#define go(u,i) for (register int i=head[u],v=sq[i].to;i;i=sq[i].nxt,v=sq[i].to)\n#define fir first\n#define sec second\n#define mkp make_pair\n#define pb push_back\n#define maxd 1000000007\n#define eps 1e-8\ninline int read()\n{\n    int x=0,f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\ninline ll readll()\n{\n    ll x=0;int f=1;char ch=getchar();\n    while ((ch<'0') || (ch>'9')) {if (ch=='-') f=-1;ch=getchar();}\n    while ((ch>='0') && (ch<='9')) {x=x*10+(ch-'0');ch=getchar();}\n    return x*f;\n}\n\nnamespace My_Math{\n    #define N 100000\n\n    int fac[N+100],invfac[N+100];\n\n    int add(int x,int y) {return x+y>=maxd?x+y-maxd:x+y;}\n    int dec(int x,int y) {return x<y?x-y+maxd:x-y;}\n    int mul(int x,int y) {return 1ll*x*y%maxd;}\n    ll qpow(ll x,int y)\n    {\n        ll ans=1;\n        while (y)\n        {\n            if (y&1) ans=mul(ans,x);\n            x=mul(x,x);y>>=1;\n        }\n        return ans;\n    }\n    int getinv(int x) {return qpow(x,maxd-2);}\n\n    int C(int n,int m)\n    {\n        if ((n<m) || (n<0) || (m<0)) return 0;\n        return mul(mul(fac[n],invfac[m]),invfac[n-m]);\n    }\n\n    void math_init()\n    {\n        fac[0]=invfac[0]=1;\n        rep(i,1,N) fac[i]=mul(fac[i-1],i);\n        invfac[N]=getinv(fac[N]);\n        per(i,N-1,1) invfac[i]=mul(invfac[i+1],i+1);\n    }\n    #undef N\n}\nusing namespace My_Math;\n\nint n,m,f[N][N];\n\nint main()\n{\n    n=read();m=read();\n    rep(i,1,m) f[0][i]=1;\n    rep(i,1,n)\n    {\n        int sum=0;\n        rep(j,1,m)\n        {\n            f[i][j]=add(sum,mul(j+1,f[i-1][j]));\n            sum=add(mul(sum,2),mul(f[i-1][j],j));\n        }\n    }\n    printf(\"%d\",f[n][m]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\ntemplate<typename T>inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T>inline bool chmin(T& a,T b){if(a>b){a=b;return 1;}return 0;}\n//end\n\ntemplate<unsigned mod=1000000007>struct fp {\n   unsigned v;\n   static unsigned get_mod(){return mod;}\n   unsigned inv() const{\n      int tmp,a=v,b=mod,x=1,y=0;\n      while(b)tmp=a/b,a-=tmp*b,swap(a,b),x-=tmp*y,swap(x,y);\n      if(x<0){x+=mod;} return x;\n   }\n   fp():v(0){}\n   fp(ll x):v(x>=0?x%mod:mod+(x%mod)){}\n   fp operator-()const{return fp(-v);}\n   fp pow(ll t){fp res=1,b=*this; while(t){if(t&1)res*=b;b*=b;t>>=1;} return res;}\n   fp& operator+=(const fp& x){if((v+=x.v)>=mod)v-=mod; return *this;}\n   fp& operator-=(const fp& x){if((v+=mod-x.v)>=mod)v-=mod; return *this;}\n   fp& operator*=(const fp& x){v=ll(v)*x.v%mod; return *this;}\n   fp& operator/=(const fp& x){v=ll(v)*x.inv()%mod; return *this;}\n   fp operator+(const fp& x)const{return fp(*this)+=x;}\n   fp operator-(const fp& x)const{return fp(*this)-=x;}\n   fp operator*(const fp& x)const{return fp(*this)*=x;}\n   fp operator/(const fp& x)const{return fp(*this)/=x;}\n   bool operator==(const fp& x)const{return v==x.v;}\n   bool operator!=(const fp& x)const{return v!=x.v;}\n}; using Fp=fp<>;\n\nFp dp[5010][5010];\n\nint main(){\n   int n,m; cin>>n>>m;\n   rep(i,1,m+1)dp[1][i]=Fp(2).pow(i);\n   rep(i,1,n){\n      Fp add=0;\n      rep(j,1,m+1){\n         dp[i+1][j]+=dp[i][j]*(j+1)+add;\n         add=add*2+dp[i][j]*j;\n      }\n   }\n   cout<<dp[n][m].v<<endl;\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#include<set> \n#include<math.h>\n#define pai arccos(-1);\n#define keta(n) cout << fixed << setprecision((n));\n#define ll long long;\nint main(){\n  int h1, m1, h2, m2,k;\n  cin>>h1>>m1>>h2>>m2>>k;\n  int limit = (60*h2+m2)-(60*h1+m1);\n  cout<<limit-k;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\n#define PI 3.14159265359\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nconst int mod = 1000000007;\nstruct mint {\n  ll x;\n  mint(ll x=0):x(x%mod){}\n  mint operator-() const { return mint(-x);}\n  mint& operator+=(const mint a) {\n    if ((x += a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator-=(const mint a) {\n    if ((x += mod-a.x) >= mod) x -= mod;\n    return *this;\n  }\n  mint& operator*=(const mint a) {\n    (x *= a.x) %= mod;\n    return *this;\n  }\n  mint operator+(const mint a) const {\n    mint res(*this);\n    return res+=a;\n  }\n  mint operator-(const mint a) const {\n    mint res(*this);\n    return res-=a;\n  }\n  mint operator*(const mint a) const {\n    mint res(*this);\n    return res*=a;\n  }\n  mint pow(ll t) const {\n    if (!t) return 1;\n    mint a = pow(t>>1);\n    a *= a;\n    if (t&1) a *= *this;\n    return a;\n  }\n  \n  mint inv() const {\n    return pow(mod-2);\n  }\n  mint& operator/=(const mint a) {\n    return (*this) *= a.inv();\n  }\n  mint operator/(const mint a) const {\n    mint res(*this);\n    return res/=a;\n  }\n};\n\nmint dp[5000][5000];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  mint cur = 2;\n  rep(i, m) {\n    dp[0][i] = cur;\n    cur *= 2;\n  }\n  cur = 2;\n  rep(i, n) {\n    dp[i][0] = cur;\n    cur *= 2;\n  }\n\n  for (int i=1; i<n; i++) {\n    for (int j=1; j<m; j++) {\n      dp[i][j] = dp[i][j-1] * 2 + (dp[i-1][j] - dp[i-1][j-1]) * (j + 2);\n    }\n  }\n\n  cout << dp[n-1][m-1].x << endl;\n\n  return 0;\n}\n\n/*\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 5000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n, m, DP[N][N], T2[N];\n\ninline int mul(int a, int b){\n\treturn a * 1ll * b % MOD;\n}\n\ninline int add(int a, int b){\n\ta += b;\n\tif (a >= MOD)a -= MOD;\n\treturn a;\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n >> m;\n\tT2[0] = 1;\n\tfor (int i = 1; i < N; i++) T2[i] = T2[i - 1] * 2ll % MOD;\n\tfor (int i = 1; i <= m; i++) DP[1][i] = T2[i];\n\tfor (int i = 2; i <= n; i++){\n\t\tint sm = 0;\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tDP[i][j] = mul(DP[i - 1][j], j + 1);\n\t\t\tif (j > 1){\n\t\t\t\tsm = mul(sm, 2);\n\t\t\t\tsm = add(sm, mul(j - 1, DP[i - 1][j - 1]));\n\t\t\t\tDP[i][j] = add(DP[i][j], sm);\n\t\t\t}\n//\t\t\tcout << i << ' ' << j << ' ' << DP[i][j] << '\\n';\n\t\t}\n\t}\n\tcout << DP[n][m];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define F first\n#define S second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\n//#define int ll\n\nconst int MOD = 1e9 + 7;\ninline int sum(int a, int b) {\n  a += b;\n  if (a >= MOD) {\n    a -= MOD;\n  }\n  return a;\n}\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= MOD) {\n    a -= MOD;\n  }\n}\n\ninline int mult(int a, int b) {\n  return (a * 1ll * b) % MOD; \n}\n\nconst int N = 5010;\nint dp[N][N], pw[N], kek[N];\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  pw[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    pw[i] = sum(pw[i - 1], pw[i - 1]);\n  }\n  for (int i = 0; i <= m; i++) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= n; j++) {\n      dp[i][j] = mult(dp[i][j - 1], i + 1);\n      if (i >= 2) {\n        kek[j] = sum(kek[j], kek[j]);\n        add(kek[j], mult(dp[i - 1][j - 1], i - 1));\n        add(dp[i][j], kek[j]);\n      }\n    }\n  }\n  cout << dp[m][n] << '\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> PP;\n#define MOD 1000000007\n//#define MOD 998244353\n#define INF 1145141919810893364\n//#define INF 810114514\n#define PI 3.141592653589\n#define setdouble setprecision\n#define REP(i,n) for(int i=0;i<(n);++i)\n#define OREP(i,n) for(int i=1;i<=(n);++i)\n#define RREP(i,n) for(int i=(n)-1;i>=0;--i)\n#define GOODBYE do { cout << \"0\" << endl; return 0; } while (false)\n#define MM <<\" \"<<\n#define Endl endl\n#define debug false\n#define debug2 false\n\nlong long power(long long b,long long e){\n  long long r=1;\n  while(e){\n      if(e&1){\n          r=(r*b)%MOD;\n      }\n      b=(b*b)%MOD;\n      e >>=1;\n  }\n  return r;\n}\n\n\nint main(void){\n    ll N,M;\n    cin >> N >> M;\n    vector<ll> dp,dp2;\n    vector<ll> pow2;\n    pow2.push_back(1);\n    REP(i,M){\n        pow2.push_back((pow2[pow2.size()-1]*2)%MOD);\n    }\n    \n    dp=pow2;\n    dp2.resize(M+1,0);\n    ll inv2 = power(2,MOD-2);\n    \n    \n    //dp2[n][m]:=dp[n][m]*m*2^{-m}\n    \n    for(ll n=2;n<=N;n++){\n        vector<ll> temp(M+1,0);\n        \n        //dp2[n][m]=dp[n][m]*m*2^{-m}\n        ll invpow = inv2;\n        for(ll m=1;m<=M;m++){\n            dp2[m] = (((dp[m]*m)%MOD)*invpow)%MOD;\n            invpow = (invpow*inv2)%MOD;\n        }\n        \n        //tempはdp2の累積和\n        for(ll m=1;m<=M;m++){\n            if(m==1){\n                temp[m]=dp2[m];\n                temp[m]%=MOD;\n            }else{\n                temp[m]=temp[m-1]+dp2[m];\n                temp[m]%=MOD;\n            }\n        }\n        \n        //そのtempに2^mをかける\n        int pospow = 2;\n        for(ll m=1;m<=M;m++){\n            temp[m] = (temp[m]*pospow)%MOD;\n            pospow = (pospow*2)%MOD;\n        }\n        \n        //dpにm+1をかける\n        for(ll m=1;m<=M;m++){\n            dp[m] = (dp[m]*(m+1))%MOD;\n        }\n        \n        //dp[m]とtemp[m-1]を足して完了\n        for(ll m=2;m<=M;m++){\n            dp[m] += temp[m-1];\n            dp[m]%=MOD;\n        }\n        \n        /*\n        for(ll m=1;m<=M;m++){\n            cout << dp[m] << \" \";\n        }cout << endl;\n        */\n    }\n    \n    cout << dp[M] << endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char gc() {\n//\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n}\ntemplate<class T> void rd(T &x) {\n\tx=0; int f=1,ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=gc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int mod=1e9+7;\nconst int maxn=5000+5,maxm=5000+5;\nint n,m;\nint pow2[maxm],inv2[maxm];\nint dp[maxn][maxm],sum[maxn][maxm];\nint main() {\n\trd(n),rd(m);\n\tpow2[0]=1,pow2[1]=2;\n\tinv2[0]=1,inv2[1]=(mod+1)>>1;\n\tfor(int i=2;i<=m;++i) {\n\t\tpow2[i]=(ll)pow2[i-1]*pow2[1]%mod;\n\t\tinv2[i]=(ll)inv2[i-1]*inv2[1]%mod;\n\t}\n\tfor(int i=1;i<=m;++i) {\n\t\tdp[1][i]=pow2[i];\n\t\tsum[1][i]=(sum[1][i-1]+(ll)dp[1][i]*i%mod*inv2[i])%mod;\n\t}\n\tfor(int i=2;i<=n;++i) for(int j=1;j<=m;++j) {\n\t\tdp[i][j]=((ll)dp[i-1][j]*(j+1)+(ll)sum[i-1][j-1]*pow2[j-1])%mod;\n\t\tsum[i][j]=(sum[i][j-1]+(ll)dp[i][j]*j%mod*inv2[j])%mod;\n\t}\n\tprintf(\"%d\\n\",dp[n][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit unsigned int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 1e9 + 7;\nusing mod_int = _m_int<MOD>;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<mod_int> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++) {\n        mod_int sum = 0;\n\n        for (int m = 0; m <= M; m++) {\n            mod_int product = m * dp[m];\n            dp[m] += sum + product;\n            sum = 2 * sum + product;\n        }\n    }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n, m;\nllint dp[5005][5005];\nllint beki[5005], beki2[5005], sum[5005];\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> m;\n\t\n\tbeki[0] = 1, beki2[0] = 1;\n\tfor(int i = 1; i < 5005; i++) beki[i] = beki[i-1] * 2, beki[i] %= mod;\n\tfor(int i = 1; i < 5005; i++) beki2[i] = beki2[i-1] * ((mod+1)/2) % mod, beki2[i] %= mod;\n\t\n\tdp[0][m] = 1;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 2; j <= m; j++) sum[j] = sum[j-1] + dp[i-1][j]*beki[j]%mod, sum[j] %= mod;\n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tdp[i][j] = dp[i-1][j]*(j+1)%mod;\n\t\t\tdp[i][j] += (sum[m] - sum[j] + mod) % mod * j % mod * beki2[j+1] % mod, dp[i][j] %= mod;\n\t\t}\n\t}\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= m; i++) ans += dp[n][i], ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <chrono>\n#include <random>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <iomanip>\n#define dibs reserve\n#define OVER9000 1234567890\n#define tisic 47\n#define soclose 1e-8\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\nusing uint = unsigned int;\nusing cat = long long;\nusing dbl = long double;\nconstexpr dbl pi = 3.14159265358979323846;\nusing namespace std;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, M;\n\tcin >> N >> M;\n\tcat mod = 1000000007;\n\tvector<cat> cnt(M+1, 0);\n\tfor(int i = 1; i <= M; i++) cnt[i] = 1;\n\tvector<cat> pw(M+1, 1), pw_inv(M+1, 1);\n\tfor(int i = 1; i <= M; i++) pw[i] = 2 * pw[i-1] % mod;\n\tcat inv = (mod+1)/2; // 2*inv % mod == 1\n\tfor(int i = 1; i <= M; i++) pw_inv[i] = inv * pw_inv[i-1] % mod;\n\tfor(int i = 0; i < N; i++) {\n\t\tvector<cat> cnt_nw(M+1, 0);\n\t\tcat s = 0;\n\t\tfor(int j = 1; j <= M; j++) {\n\t\t\ts += cnt[j-1] * pw_inv[j-1] % mod * (j-1);\n\t\t\tcnt_nw[j] = (s % mod * pw[j-1] + cnt[j] * (j+1)) % mod;\n\t\t}\n\t\tcnt = cnt_nw;\n\t}\n\tcout << cnt[M] << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 5005 /*rem*/\n#define mod 1000000007\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nll pw[maxn];\nll dp[maxn][maxn]; \nint main() {\n\tpw[0] = 1;\n\tfor (int i = 1; i < maxn; i++)\n\t\tpw[i] = pw[i - 1] * 2 % mod;\n\tint n, m;\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++) {\n\t\tll pl = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (i == 1) dp[i][j] = pw[j];\n\t\t\telse {\n\t\t\t\tdp[i][j] = (j + 1) * dp[i - 1][j] % mod;\n\t\t\t\tpl *= 2;\n\t\t\t\tpl += dp[i - 1][j - 1] * (j - 1);\n\t\t\t\tpl %= mod;\n\t\t\t\tdp[i][j] = (dp[i][j] + pl) % mod;\n\t\t\t//\t}\n\t\t\t\t/*\n\t\t\t\t\tdp[i][j] += dp[i - 1][j - d] * pw[d - 1] % mod * (j - d), \n\t\t\t\t\tdp[i][j] %= mod;\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\tcout << dp[n][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG(...) cerr << __VA_ARGS__ << endl;\n\n#ifndef CDEBUG\n#undef DEBUG\n#define DEBUG(...) ((void)0);\n#define NDEBUG\n#endif\n\n#define ran(i, a, b) for (auto i = (a); i < (b); i++)\n\n#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\nconst int mod = 1e9 + 7;\n#ifndef M_PI\nconst double M_PI = acos(-1.0);\n#endif\n\nconst int nmax = 5005;\nconst ll two_inv = (mod+1)/2;\n\nll two_pow[nmax];\nll l_mult[nmax];\nll arr[nmax];\nll tmp[nmax];\n\nint main() {\n  two_pow[0] = 1;\n  l_mult[0] = 1;\n  ll two_inv_pow = (mod+1)/2;\n  for(int i=1; i<nmax; ++i){\n    two_pow[i] = two_pow[i-1]*2%mod;\n    l_mult[i] = (i+1)*two_inv_pow%mod;\n    two_inv_pow *= two_inv;\n    two_inv_pow %= mod;\n  }\n  int n, m;\n  cin>>n>>m;\n  arr[m-1]=1;\n  for(int i=0; i<n; ++i){\n    ll par = 0;\n    for(int j=m-1; j>=0; --j){\n      tmp[j] = (par*l_mult[j] + arr[j]*(j+2))%mod;\n      if(j){\n        par += arr[j]*two_pow[j-1];\n        par %= mod;\n      }\n    }\n    swap(tmp, arr);\n  }\n  ll res = 0;\n  for(int j=m-1; j>=0; --j){\n    res += arr[j];\n  }\n  res %= mod;\n  cout<<res<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5005,mod=1e9+7;\ntypedef long long ll;\nint n,m,dp[N][N];\nint main()\n{\n    //int p[N];p[0]=1;for(int i=1;i<N;i++) p[i]=(p[i-1]<<1)%mod;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=m;i++) dp[0][i]=1;\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=m;j++)\n    {\n        dp[i][j]=(dp[i][j]+(ll)dp[i-1][j]*(j+1))%mod;\n        dp[i][j]=(dp[i][j]+(ll)(dp[i][j-1]-(ll)dp[i-1][j-1]*j%mod+mod)%mod*2%mod+(ll)dp[i-1][j-1]*(j-1))%mod;\n        /*\n        for(int k=2;k<=j;k++)\n            dp[i][j]=(dp[i][j]+(ll)dp[i-1][j-k+1]*(j-k+1)%mod*p[k-2]%mod)%mod;\n        */\n    }\n    printf(\"%d\\n\",dp[n][m]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma region kyopro_template\n#include <bits/stdc++.h>\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define each(x, v) for (auto &x : v)\n#define all(v) (v).begin(), (v).end()\n#define sz(v) ((int)(v).size())\n#define mem(a, val) memset(a, val, sizeof(a))\n#define ini(...)   \\\n  int __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inl(...)         \\\n  long long __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define ins(...)      \\\n  string __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define inc(...)    \\\n  char __VA_ARGS__; \\\n  in(__VA_ARGS__)\n#define in2(s, t)                           \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i]);                         \\\n  }\n#define in3(s, t, u)                        \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i]);                   \\\n  }\n#define in4(s, t, u, v)                     \\\n  for (int i = 0; i < (int)s.size(); i++) { \\\n    in(s[i], t[i], u[i], v[i]);             \\\n  }\n#define rep(i, N) for (long long i = 0; i < (long long)(N); i++)\n#define repr(i, N) for (long long i = (long long)(N)-1; i >= 0; i--)\n#define rep1(i, N) for (long long i = 1; i <= (long long)(N); i++)\n#define repr1(i, N) for (long long i = (N); (long long)(i) > 0; i--)\nusing namespace std;\nvoid solve();\nusing ll = long long;\ntemplate <class T = ll>\nusing V = vector<T>;\nusing vi = vector<int>;\nusing vl = vector<long long>;\nusing vvi = vector<vector<int>>;\nusing vd = V<double>;\nusing vs = V<string>;\nusing vvl = vector<vector<long long>>;\nusing P = pair<long long, long long>;\nusing vp = vector<P>;\nusing pii = pair<int, int>;\nusing vpi = vector<pair<int, int>>;\nconstexpr int inf = 1001001001;\nconstexpr long long infLL = (1LL << 61) - 1;\ntemplate <typename T, typename U>\ninline bool amin(T &x, U y) {\n  return (y < x) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\ninline bool amax(T &x, U y) {\n  return (x < y) ? (x = y, true) : false;\n}\ntemplate <typename T, typename U>\nll ceil(T a, U b) {\n  return (a + b - 1) / b;\n}\nconstexpr ll TEN(int n) {\n  ll ret = 1, x = 10;\n  while (n) {\n    if (n & 1) ret *= x;\n    x *= x;\n    n >>= 1;\n  }\n  return ret;\n}\n\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\ntemplate <typename T, typename U>\nistream &operator>>(istream &is, pair<T, U> &p) {\n  is >> p.first >> p.second;\n  return is;\n}\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  int s = (int)v.size();\n  for (int i = 0; i < s; i++) os << (i ? \" \" : \"\") << v[i];\n  return os;\n}\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &v) {\n  for (auto &x : v) is >> x;\n  return is;\n}\nvoid in() {}\ntemplate <typename T, class... U>\nvoid in(T &t, U &... u) {\n  cin >> t;\n  in(u...);\n}\nvoid out() { cout << \"\\n\"; }\ntemplate <typename T, class... U>\nvoid out(const T &t, const U &... u) {\n  cout << t;\n  if (sizeof...(u)) cout << \" \";\n  out(u...);\n}\ntemplate <typename T>\nvoid die(T x) {\n  out(x);\n  exit(0);\n}\n\n#ifdef NyaanDebug\n#include \"NyaanDebug.h\"\n#define trc(...)                   \\\n  do {                             \\\n    cerr << #__VA_ARGS__ << \" = \"; \\\n    dbg_out(__VA_ARGS__);          \\\n  } while (0)\n#define trca(v, N)       \\\n  do {                   \\\n    cerr << #v << \" = \"; \\\n    array_out(v, N);     \\\n  } while (0)\n#define trcc(v)                             \\\n  do {                                      \\\n    cerr << #v << \" = {\";                   \\\n    each(x, v) { cerr << \" \" << x << \",\"; } \\\n    cerr << \"}\" << endl;                    \\\n  } while (0)\n#else\n#define trc(...)\n#define trca(...)\n#define trcc(...)\nint main() { solve(); }\n#endif\n\nstruct IoSetupNya {\n  IoSetupNya() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cerr << fixed << setprecision(7);\n  }\n} iosetupnya;\n\ninline int popcnt(unsigned long long a) { return __builtin_popcountll(a); }\ninline int lsb(unsigned long long a) { return __builtin_ctzll(a); }\ninline int msb(unsigned long long a) { return 63 - __builtin_clzll(a); }\ntemplate <typename T>\ninline int getbit(T a, int i) {\n  return (a >> i) & 1;\n}\ntemplate <typename T>\ninline void setbit(T &a, int i) {\n  a |= (1LL << i);\n}\ntemplate <typename T>\ninline void delbit(T &a, int i) {\n  a &= ~(1LL << i);\n}\ntemplate <typename T>\nint lb(const vector<T> &v, const T &a) {\n  return lower_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nint ub(const vector<T> &v, const T &a) {\n  return upper_bound(begin(v), end(v), a) - begin(v);\n}\ntemplate <typename T>\nvector<T> mkrui(const vector<T> &v) {\n  vector<T> ret(v.size() + 1);\n  for (int i = 0; i < int(v.size()); i++) ret[i + 1] = ret[i] + v[i];\n  return ret;\n};\ntemplate <typename T>\nvector<T> mkuni(const vector<T> &v) {\n  vector<T> ret(v);\n  sort(ret.begin(), ret.end());\n  ret.erase(unique(ret.begin(), ret.end()), ret.end());\n  return ret;\n}\ntemplate <typename F>\nvector<int> mkord(int N, F f) {\n  vector<int> ord(N);\n  iota(begin(ord), end(ord), 0);\n  sort(begin(ord), end(ord), f);\n  return ord;\n}\ntemplate <typename T = int>\nvector<T> mkiota(int N) {\n  vector<T> ret(N);\n  iota(begin(ret), end(ret), 0);\n  return ret;\n}\n\n#pragma endregion\n\nconstexpr int MOD = 1000000007;\n\ntemplate <int mod>\nstruct ModInt {\n  int x;\n\n  ModInt() : x(0) {}\n\n  ModInt(int64_t y) : x(y >= 0 ? y % mod : (mod - (-y) % mod) % mod) {}\n\n  ModInt &operator+=(const ModInt &p) {\n    if ((x += p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator-=(const ModInt &p) {\n    if ((x += mod - p.x) >= mod) x -= mod;\n    return *this;\n  }\n\n  ModInt &operator*=(const ModInt &p) {\n    x = (int)(1LL * x * p.x % mod);\n    return *this;\n  }\n\n  ModInt &operator/=(const ModInt &p) {\n    *this *= p.inverse();\n    return *this;\n  }\n\n  ModInt operator-() const { return ModInt(-x); }\n\n  ModInt operator+(const ModInt &p) const { return ModInt(*this) += p; }\n\n  ModInt operator-(const ModInt &p) const { return ModInt(*this) -= p; }\n\n  ModInt operator*(const ModInt &p) const { return ModInt(*this) *= p; }\n\n  ModInt operator/(const ModInt &p) const { return ModInt(*this) /= p; }\n\n  bool operator==(const ModInt &p) const { return x == p.x; }\n\n  bool operator!=(const ModInt &p) const { return x != p.x; }\n\n  ModInt inverse() const {\n    int a = x, b = mod, u = 1, v = 0, t;\n    while (b > 0) {\n      t = a / b;\n      swap(a -= t * b, b);\n      swap(u -= t * v, v);\n    }\n    return ModInt(u);\n  }\n\n  ModInt pow(int64_t n) const {\n    ModInt ret(1), mul(x);\n    while (n > 0) {\n      if (n & 1) ret *= mul;\n      mul *= mul;\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  friend ostream &operator<<(ostream &os, const ModInt &p) { return os << p.x; }\n\n  friend istream &operator>>(istream &is, ModInt &a) {\n    int64_t t;\n    is >> t;\n    a = ModInt<mod>(t);\n    return (is);\n  }\n\n  static int get_mod() { return mod; }\n};\n\nusing modint = ModInt<MOD>;\nusing mint = modint;\nusing vm = vector<mint>;\n\nnamespace FastFourierTransform {\nusing real = double;\n\nstruct C {\n  real x, y;\n\n  C() : x(0), y(0) {}\n\n  C(real x, real y) : x(x), y(y) {}\n\n  inline C operator+(const C &c) const { return C(x + c.x, y + c.y); }\n\n  inline C operator-(const C &c) const { return C(x - c.x, y - c.y); }\n\n  inline C operator*(const C &c) const {\n    return C(x * c.x - y * c.y, x * c.y + y * c.x);\n  }\n\n  inline C conj() const { return C(x, -y); }\n};\n\nconst real PI = acosl(-1);\nint base = 1;\nvector<C> rts = {{0, 0}, {1, 0}};\nvector<int> rev = {0, 1};\n\nvoid ensure_base(int nbase) {\n  if (nbase <= base) return;\n  rev.resize(1 << nbase);\n  rts.resize(1 << nbase);\n  for (int i = 0; i < (1 << nbase); i++) {\n    rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n  }\n  while (base < nbase) {\n    real angle = PI * 2.0 / (1 << (base + 1));\n    for (int i = 1 << (base - 1); i < (1 << base); i++) {\n      rts[i << 1] = rts[i];\n      real angle_i = angle * (2 * i + 1 - (1 << base));\n      rts[(i << 1) + 1] = C(cos(angle_i), sin(angle_i));\n    }\n    ++base;\n  }\n}\n\nvoid fft(vector<C> &a, int n) {\n  assert((n & (n - 1)) == 0);\n  int zeros = __builtin_ctz(n);\n  ensure_base(zeros);\n  int shift = base - zeros;\n  for (int i = 0; i < n; i++) {\n    if (i < (rev[i] >> shift)) {\n      swap(a[i], a[rev[i] >> shift]);\n    }\n  }\n  for (int k = 1; k < n; k <<= 1) {\n    for (int i = 0; i < n; i += 2 * k) {\n      for (int j = 0; j < k; j++) {\n        C z = a[i + j + k] * rts[j + k];\n        a[i + j + k] = a[i + j] - z;\n        a[i + j] = a[i + j] + z;\n      }\n    }\n  }\n}\n\nvector<int64_t> multiply(const vector<int> &a, const vector<int> &b) {\n  int need = (int)a.size() + (int)b.size() - 1;\n  int nbase = 1;\n  while ((1 << nbase) < need) nbase++;\n  ensure_base(nbase);\n  int sz = 1 << nbase;\n  vector<C> fa(sz);\n  for (int i = 0; i < sz; i++) {\n    int x = (i < (int)a.size() ? a[i] : 0);\n    int y = (i < (int)b.size() ? b[i] : 0);\n    fa[i] = C(x, y);\n  }\n  fft(fa, sz);\n  C r(0, -0.25 / (sz >> 1)), s(0, 1), t(0.5, 0);\n  for (int i = 0; i <= (sz >> 1); i++) {\n    int j = (sz - i) & (sz - 1);\n    C z = (fa[j] * fa[j] - (fa[i] * fa[i]).conj()) * r;\n    fa[j] = (fa[i] * fa[i] - (fa[j] * fa[j]).conj()) * r;\n    fa[i] = z;\n  }\n  for (int i = 0; i < (sz >> 1); i++) {\n    C A0 = (fa[i] + fa[i + (sz >> 1)]) * t;\n    C A1 = (fa[i] - fa[i + (sz >> 1)]) * t * rts[(sz >> 1) + i];\n    fa[i] = A0 + A1 * s;\n  }\n  fft(fa, sz >> 1);\n  vector<int64_t> ret(need);\n  for (int i = 0; i < need; i++) {\n    ret[i] = llround(i & 1 ? fa[i >> 1].y : fa[i >> 1].x);\n  }\n  return ret;\n}\n};  // namespace FastFourierTransform\n\ntemplate <typename T>\nstruct ArbitraryModConvolution {\n  using real = FastFourierTransform::real;\n  using C = FastFourierTransform::C;\n\n  ArbitraryModConvolution() = default;\n\n  vector<T> multiply(const vector<T> &a, const vector<T> &b, int need = -1) {\n    if (need == -1) need = a.size() + b.size() - 1;\n    int nbase = 0;\n    while ((1 << nbase) < need) nbase++;\n    FastFourierTransform::ensure_base(nbase);\n    int sz = 1 << nbase;\n    vector<C> fa(sz);\n    for (int i = 0; i < (int)a.size(); i++) {\n      fa[i] = C(a[i].x & ((1 << 15) - 1), a[i].x >> 15);\n    }\n    fft(fa, sz);\n    vector<C> fb(sz);\n    if (a == b) {\n      fb = fa;\n    } else {\n      for (int i = 0; i < (int)b.size(); i++) {\n        fb[i] = C(b[i].x & ((1 << 15) - 1), b[i].x >> 15);\n      }\n      fft(fb, sz);\n    }\n    real ratio = 0.25 / sz;\n    C r2(0, -1), r3(ratio, 0), r4(0, -ratio), r5(0, 1);\n    for (int i = 0; i <= (sz >> 1); i++) {\n      int j = (sz - i) & (sz - 1);\n      C a1 = (fa[i] + fa[j].conj());\n      C a2 = (fa[i] - fa[j].conj()) * r2;\n      C b1 = (fb[i] + fb[j].conj()) * r3;\n      C b2 = (fb[i] - fb[j].conj()) * r4;\n      if (i != j) {\n        C c1 = (fa[j] + fa[i].conj());\n        C c2 = (fa[j] - fa[i].conj()) * r2;\n        C d1 = (fb[j] + fb[i].conj()) * r3;\n        C d2 = (fb[j] - fb[i].conj()) * r4;\n        fa[i] = c1 * d1 + c2 * d2 * r5;\n        fb[i] = c1 * d2 + c2 * d1;\n      }\n      fa[j] = a1 * b1 + a2 * b2 * r5;\n      fb[j] = a1 * b2 + a2 * b1;\n    }\n    fft(fa, sz);\n    fft(fb, sz);\n    vector<T> ret(need);\n    for (int i = 0; i < need; i++) {\n      int64_t aa = llround(fa[i].x);\n      int64_t bb = llround(fb[i].x);\n      int64_t cc = llround(fa[i].y);\n      aa = T(aa).x, bb = T(bb).x, cc = T(cc).x;\n      ret[i] = aa + (bb << 15) + (cc << 30);\n    }\n    return ret;\n  }\n};\n\ntemplate <int mod>\nstruct NumberTheoreticTransform {\n  int base, max_base, root;\n  vector<int> rev, rts;\n\n  NumberTheoreticTransform() : base(1), rev{0, 1}, rts{0, 1} {\n    assert(mod >= 3 && mod % 2 == 1);\n    auto tmp = mod - 1;\n    max_base = 0;\n    while (tmp % 2 == 0) tmp >>= 1, max_base++;\n    root = 2;\n    while (mod_pow(root, (mod - 1) >> 1) == 1) ++root;\n    assert(mod_pow(root, mod - 1) == 1);\n    root = mod_pow(root, (mod - 1) >> max_base);\n  }\n\n  inline int mod_pow(int x, int n) {\n    int ret = 1;\n    while (n > 0) {\n      if (n & 1) ret = mul(ret, x);\n      x = mul(x, x);\n      n >>= 1;\n    }\n    return ret;\n  }\n\n  inline int inverse(int x) { return mod_pow(x, mod - 2); }\n\n  inline unsigned add(unsigned x, unsigned y) {\n    x += y;\n    if (x >= mod) x -= mod;\n    return x;\n  }\n\n  inline unsigned mul(unsigned a, unsigned b) {\n    return 1ull * a * b % (unsigned long long)mod;\n  }\n\n  void ensure_base(int nbase) {\n    if (nbase <= base) return;\n    rev.resize(1 << nbase);\n    rts.resize(1 << nbase);\n    for (int i = 0; i < (1 << nbase); i++) {\n      rev[i] = (rev[i >> 1] >> 1) + ((i & 1) << (nbase - 1));\n    }\n    assert(nbase <= max_base);\n    while (base < nbase) {\n      int z = mod_pow(root, 1 << (max_base - 1 - base));\n      for (int i = 1 << (base - 1); i < (1 << base); i++) {\n        rts[i << 1] = rts[i];\n        rts[(i << 1) + 1] = mul(rts[i], z);\n      }\n      ++base;\n    }\n  }\n\n  void ntt(vector<int> &a) {\n    const int n = (int)a.size();\n    assert((n & (n - 1)) == 0);\n    int zeros = __builtin_ctz(n);\n    ensure_base(zeros);\n    int shift = base - zeros;\n    for (int i = 0; i < n; i++) {\n      if (i < (rev[i] >> shift)) {\n        swap(a[i], a[rev[i] >> shift]);\n      }\n    }\n    for (int k = 1; k < n; k <<= 1) {\n      for (int i = 0; i < n; i += 2 * k) {\n        for (int j = 0; j < k; j++) {\n          int z = mul(a[i + j + k], rts[j + k]);\n          a[i + j + k] = add(a[i + j], mod - z);\n          a[i + j] = add(a[i + j], z);\n        }\n      }\n    }\n  }\n\n  vector<int> multiply(vector<int> a, vector<int> b) {\n    int need = a.size() + b.size() - 1;\n    int nbase = 1;\n    while ((1 << nbase) < need) nbase++;\n    ensure_base(nbase);\n    int sz = 1 << nbase;\n    a.resize(sz, 0);\n    b.resize(sz, 0);\n    ntt(a);\n    ntt(b);\n    int inv_sz = inverse(sz);\n    for (int i = 0; i < sz; i++) {\n      a[i] = mul(a[i], mul(b[i], inv_sz));\n    }\n    reverse(a.begin() + 1, a.end());\n    ntt(a);\n    a.resize(need);\n    return a;\n  }\n\n  vector<modint> multiply_for_fps(const vector<modint> &a,\n                                  const vector<modint> &b) {\n    vector<int> A(a.size()), B(b.size());\n    for (int i = 0; i < (int)a.size(); i++) A[i] = a[i].x;\n    for (int i = 0; i < (int)b.size(); i++) B[i] = b[i].x;\n    auto C = multiply(A, B);\n    vector<modint> ret(C.size());\n    for (int i = 0; i < (int)C.size(); i++) ret[i].x = C[i];\n    return ret;\n  }\n};\n\ntemplate <typename T>\nstruct FormalPowerSeries : vector<T> {\n  using vector<T>::vector;\n  using P = FormalPowerSeries;\n\n  using MULT = function<P(P, P)>;\n\n  static MULT &get_mult() {\n    static MULT mult = nullptr;\n    return mult;\n  }\n\n  static void set_fft(MULT f) { get_mult() = f; }\n\n  void shrink() {\n    while (this->size() && this->back() == T(0)) this->pop_back();\n  }\n\n  P operator+(const P &r) const { return P(*this) += r; }\n\n  P operator+(const T &v) const { return P(*this) += v; }\n\n  P operator-(const P &r) const { return P(*this) -= r; }\n\n  P operator-(const T &v) const { return P(*this) -= v; }\n\n  P operator*(const P &r) const { return P(*this) *= r; }\n\n  P operator*(const T &v) const { return P(*this) *= v; }\n\n  P operator/(const P &r) const { return P(*this) /= r; }\n\n  P operator%(const P &r) const { return P(*this) %= r; }\n\n  P &operator+=(const P &r) {\n    if (r.size() > this->size()) this->resize(r.size());\n    for (int i = 0; i < (int)r.size(); i++) (*this)[i] += r[i];\n    return *this;\n  }\n\n  P &operator+=(const T &r) {\n    if (this->empty()) this->resize(1);\n    (*this)[0] += r;\n    return *this;\n  }\n\n  P &operator-=(const P &r) {\n    if (r.size() > this->size()) this->resize(r.size());\n    for (int i = 0; i < (int)r.size(); i++) (*this)[i] -= r[i];\n    shrink();\n    return *this;\n  }\n\n  P &operator-=(const T &r) {\n    if (this->empty()) this->resize(1);\n    (*this)[0] -= r;\n    shrink();\n    return *this;\n  }\n\n  P &operator*=(const T &v) {\n    const int n = (int)this->size();\n    for (int k = 0; k < n; k++) (*this)[k] *= v;\n    return *this;\n  }\n\n  P &operator*=(const P &r) {\n    if (this->empty() || r.empty()) {\n      this->clear();\n      return *this;\n    }\n    assert(get_mult() != nullptr);\n    return *this = get_mult()(*this, r);\n  }\n\n  P &operator%=(const P &r) { return *this -= *this / r * r; }\n\n  P operator-() const {\n    P ret(this->size());\n    for (int i = 0; i < this->size(); i++) ret[i] = -(*this)[i];\n    return ret;\n  }\n\n  P &operator/=(const P &r) {\n    if (this->size() < r.size()) {\n      this->clear();\n      return *this;\n    }\n    int n = this->size() - r.size() + 1;\n    return *this = (rev().pre(n) * r.rev().inv(n)).pre(n).rev(n);\n  }\n\n  P pre(int sz) const {\n    return P(begin(*this), begin(*this) + min((int)this->size(), sz));\n  }\n\n  P operator>>(int sz) const {\n    if (this->size() <= sz) return {};\n    P ret(*this);\n    ret.erase(ret.begin(), ret.begin() + sz);\n    return ret;\n  }\n\n  P operator<<(int sz) const {\n    P ret(*this);\n    ret.insert(ret.begin(), sz, T(0));\n    return ret;\n  }\n\n  P rev(int deg = -1) const {\n    P ret(*this);\n    if (deg != -1) ret.resize(deg, T(0));\n    reverse(begin(ret), end(ret));\n    return ret;\n  }\n\n  P diff() const {\n    const int n = (int)this->size();\n    P ret(max(0, n - 1));\n    for (int i = 1; i < n; i++) ret[i - 1] = (*this)[i] * T(i);\n    return ret;\n  }\n\n  P integral() const {\n    const int n = (int)this->size();\n    P ret(n + 1);\n    ret[0] = T(0);\n    for (int i = 0; i < n; i++) ret[i + 1] = (*this)[i] / T(i + 1);\n    return ret;\n  }\n\n  // F(0) must not be 0\n  P inv(int deg = -1) const {\n    assert(((*this)[0]) != T(0));\n    const int n = (int)this->size();\n    if (deg == -1) deg = n;\n    P ret({T(1) / (*this)[0]});\n    for (int i = 1; i < deg; i <<= 1) {\n      ret = (ret + ret - ret * ret * pre(i << 1)).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 1\n  P log(int deg = -1) const {\n    assert((*this)[0] == 1);\n    const int n = (int)this->size();\n    if (deg == -1) deg = n;\n    return (this->diff() * this->inv(deg)).pre(deg - 1).integral();\n  }\n\n  P sqrt(int deg = -1) const {\n    const int n = (int)this->size();\n    if (deg == -1) deg = n;\n\n    if ((*this)[0] == T(0)) {\n      for (int i = 1; i < n; i++) {\n        if ((*this)[i] != T(0)) {\n          if (i & 1) return {};\n          if (deg - i / 2 <= 0) break;\n          auto ret = (*this >> i).sqrt(deg - i / 2) << (i / 2);\n          if (ret.size() < deg) ret.resize(deg, T(0));\n          return ret;\n        }\n      }\n      return P(deg, 0);\n    }\n\n    P ret({T(1)});\n    T inv2 = T(1) / T(2);\n    for (int i = 1; i < deg; i <<= 1) {\n      ret = (ret + pre(i << 1) * ret.inv(i << 1)) * inv2;\n    }\n    return ret.pre(deg);\n  }\n\n  // F(0) must be 0\n  P exp(int deg = -1) const {\n    assert((*this)[0] == T(0));\n    const int n = (int)this->size();\n    if (deg == -1) deg = n;\n    P ret({T(1)});\n    for (int i = 1; i < deg; i <<= 1) {\n      ret = (ret * (pre(i << 1) + T(1) - ret.log(i << 1))).pre(i << 1);\n    }\n    return ret.pre(deg);\n  }\n\n  P pow(int64_t k, int deg = -1) const {\n    const int n = (int)this->size();\n    if (deg == -1) deg = n;\n    for (int i = 0; i < n; i++) {\n      if ((*this)[i] != T(0)) {\n        T rev = T(1) / (*this)[i];\n        P C(*this * rev);\n        P D(n - i);\n        for (int j = i; j < n; j++) D[j - i] = C[j];\n        D = (D.log() * k).exp() * (*this)[i].pow(k);\n        P E(deg);\n        if (i * k > deg) return E;\n        auto S = i * k;\n        for (int j = 0; j + S < deg && j < D.size(); j++) E[j + S] = D[j];\n        return E;\n      }\n    }\n    return *this;\n  }\n\n  T eval(T x) const {\n    T r = 0, w = 1;\n    for (auto &v : *this) {\n      r += w * v;\n      w *= x;\n    }\n    return r;\n  }\n};\n\nusing FPS = FormalPowerSeries<modint>;\n\n// fにa * x^n + bを掛ける\nvoid mul_simple(FPS &f, modint a, int n, modint b) {\n  for (int i = (int)f.size() - 1; i >= 0; i--) {\n    f[i] *= b;\n    if (i >= n) f[i] += f[i - n] * a;\n  }\n}\n\n// fからa * x^n + bを割る\nvoid div_simple(FPS &f, modint a, int n, modint b) {\n  for (int i = 0; i < (int)f.size(); i++) {\n    f[i] /= b;\n    if (i + n < (int)f.size()) f[n + i] -= f[i] * a;\n  }\n}\n\n// f / gをdeg(f)次まで求める\nFPS div_(FPS &f, FPS g) {\n  int n = f.size();\n  return (f * g.inv(n)).pre(n);\n}\n\n// solve関数内で\n//\n// FPS::set_fft(mul);\n//\n// とすること。\n\n/**\nNumberTheoreticTransform<MOD> ntt;\nauto mul = [&](const FPS::P &a, const FPS::P &b) {\n  auto ret =ntt.multiply_for_fps(a , b);\n  return FPS::P(ret.begin(), ret.end());\n};\n/*///\n\n//*/\n\n// 下記のリンクを実装(kitamasa法のモンゴメリ乗算を使わない版)\n// http://q.c.titech.ac.jp/docs/progs/polynomial_division.html\n// k項間漸化式のa_Nを求める O(k log k log N)\n// N ... 求めたい項　(0-indexed)\n// Q ... 漸化式 (1 - \\sum_i c_i x^i)の形\n// a ... 初期解 (a_0 , a_1 , ... , a_k-1)\n// x^N を fでわった剰余を求め、aと内積を取る\nmodint kitamasa(ll N, FPS &Q, FPS &a) {\n  int k = Q.size() - 1;\n  assert((int)a.size() == k);\n  FPS P = a * Q;\n  P.resize(k);\n  while (N) {\n    auto Q2 = Q;\n    for (int i = 1; i < (int)Q2.size(); i += 2) Q2[i].x = MOD - Q2[i].x;\n    auto S = P * Q2;\n    auto T = Q * Q2;\n    if (N & 1) {\n      for (int i = 1; i < (int)S.size(); i += 2) P[i >> 1].x = S[i].x;\n      for (int i = 0; i < (int)T.size(); i += 2) Q[i >> 1].x = T[i].x;\n    } else {\n      for (int i = 0; i < (int)S.size(); i += 2) P[i >> 1].x = S[i].x;\n      for (int i = 0; i < (int)T.size(); i += 2) Q[i >> 1].x = T[i].x;\n    }\n    N >>= 1;\n  }\n  return P[0];\n}\n\nvoid solve() {\n  ArbitraryModConvolution<modint> fft;\n  auto mul = [&](const FPS::P &a, const FPS::P &b) {\n    auto ret = fft.multiply(a, b);\n    return FPS::P(ret.begin(), ret.end());\n  };\n  FPS::set_fft(mul);\n  inl(N, M);\n  FPS f(M + 1);\n  f[0] = 1;\n  FPS ff{1, -1}, fff{1, -2};\n  f = div_(f, ff);\n  trc(f);\n\n  rep(i, N) {\n    mul_simple(f, -1, 1, 1);\n    f.insert(begin(f), 0);\n    f=f.diff();\n    f.resize(M + 1);\n    div_simple(f, -2, 1, 1);\n    //trc(f);\n  }\n  out(f[M]);\n}\n\n;"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cfloat>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\n\ntemplate <class T1, class T2>\nostream& operator << (ostream& out, const pair <T1, T2> p)\n{\n    out << '(' << p.first << ',' << p.second << ')';\n    return out;\n}\n\ntemplate <class T1, class T2>\nistream& operator >> (istream& in, pair<T1, T2> &p)\n{\n    in >> p.first >> p.second;\n    return in;\n}\n\ntemplate <class T>\nistream& operator >> (istream& in, vector<T> &v)\n{\n    for (T &x : v)\n        in >> x;\n    return in;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<vector<T>> &v)\n{\n    for (const vector<T> &x : v)\n        out << x << '\\n';\n    return out;\n}\n\ntemplate <class T>\nostream& operator << (ostream& out, const vector<T> &v)\n{\n    for (const T &x : v)\n        out << x << ' ';\n    return out;\n}\n\nlong long gcd (long long a, long long b)\n{\n    if (b > a)\n        swap(a, b);\n    return (b ? gcd(b, a % b) : a);\n}\n\nusing ll   = long long;\nusing pii  = pair<int, int>;\nusing pll  = pair<long long, long long>;\nusing tiii = pair<pair<int, int>, int>;\nusing vi   = vector<int>;\nusing vl   = vector<long long>;\nusing vvi  = vector<vector<int>>;\nusing vvl  = vector<vector<long long>>;\n\n#define F          first\n#define S          second\n#define First      first.first\n#define Second     first.second\n#define Third      second\n#define mp         make_pair\n#define rep(i,a,b) for (int i = (a); i < (b); i++)\n#define per(i,b,a) for (int i = (b); i > (a); i--)\n#define all(x)     x.begin(), x.end()\n#define ret(x)     return cout << x, 0;\n#define throwex    throw runtime_error (\"Found the error.\");\n\nconst int h = 1000000007;\n\nnamespace modexp\n{\n    const int mod = 1000000007;\n\n    constexpr long long p (long long x, long long y)\n    {\n        long long ans = 1;\n        while(y)\n        {\n            if(y & 1)\n                (ans *= x) %= mod;\n            (x *= x) %= mod;\n            y /= 2;\n        }\n        return ans;\n    }\n\n    constexpr long long inv (const long long x)\n    {\n        return p (x, mod - 2);\n    }\n}\nusing modexp::p;\nusing modexp::inv;\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    #ifdef ONLINE_JUDGE\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cerr.setstate(ios::failbit);\n    #endif\n\n    int n, m;\n    cin >> n >> m;\n    vvl dp(m+1, vl(n+1));\n    rep(i,0,m+1)\n        dp[i][0] = 1;\n    rep(i,1,n+1)\n        dp[0][i] = 1;\n    rep(j,1,n+1)\n    {\n        ll x = 0;\n        rep(i,1,m+1)\n        {\n            (dp[i][j] += dp[i][j-1] * (i + 1)) %= h;\n            (x *= 2) %= h;\n            (x += dp[i-1][j-1] * (i - 1)) %= h;\n            (dp[i][j] += x) %= h;\n        }\n    }\n    // cerr << dp << '\\n';\n    cout << dp.back().back();\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int M, N; cin >> M >> N;\n/*    mi cnt[N+1][N+1];\n    F0R(i, N+1) {\n        F0R(j, N+1) {\n            cnt[i][j] = 0;\n        }\n        cnt[i][i] = i+1;\n        FOR(j, 1, i) {\n            mi lenVar = i - j - 1;\n            mi curCnt = i - j + 1;\n            cnt[i][j] = curCnt * pow((mi) 2, (ll) lenVar);\n        }\n    }*/\n\n    mi dp[M+1][N+1];\n    F0R(i, M+1) F0R(j, N+1) dp[i][j] = 0;\n    dp[M][N] = 1;\n    \n    FORd(i, 1, M+1) {\n        mi cur = 0;\n        mi sum = 0;\n        FORd(j, 1, N+1) {\n            cur -= sum; cur *= 2; sum *= 2;\n            if (j < N) {\n                cur -= dp[i][j+1] * (j+2);\n                sum -= dp[i][j+1];\n            }\n            cur += (j+1) * dp[i][j];\n            sum += dp[i][j];\n            dp[i-1][j] = cur;\n        }\n    }\n\n    mi ans = 0;\n    FOR(i, 1, N+1) ans += dp[0][i];\n    cout << ans << nl;\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef pair<double, double> pdd;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\nconst int mod = 1e9 + 7;\n\nll mpow(ll x, ll n) {\n  ll res = 1;\n  while (n) {\n    if (n & 1) res = res * x % mod;\n    x = x * x % mod;\n    n /= 2;\n  }\n  return res;\n}\n\nint main() {\n  std::ios::sync_with_stdio(false); std::cin.tie(0);\n  int n, m;\n  cin >> n >> m;\n  vl d(m + 1);\n  d[m] = 1;\n  for (int t = 0; t < n; ++t) {\n    vl nd(d.size());\n    ll s = 0;\n    for (int i = m; i > 0; --i) {\n      nd[i] = (i * s + d[i] * (i + 1)) % mod;\n      s = (2 * s + d[i]) % mod;\n    }\n    d.swap(nd);\n  }\n  ll res = 0;\n  for (int i = 0; i < d.size(); ++i) res = (res + d[i]) % mod;\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n \n#include <bits/stdc++.h>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n \ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n \ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n \n#define FOR(i, a, b) for (int i=a; i<(b); i++)\n#define F0R(i, a) for (int i=0; i<(a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= a; i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n \n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n#define all(x) x.begin(), x.end()\n#define ins insert\n \nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nconst int MOD = 1000000007;\nconst char nl = '\\n';\nconst int MX = 100001; //check the limits, dummy\n \nstruct mi {\n\tll v; explicit operator ll() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n    friend ostream& operator<<(ostream& os, const mi& m) {\n        os << m.v; return os;\n    }\n    friend istream& operator>>(istream& is, mi& m) {\n        ll x; is >> x;\n        m.v = x;\n        return is;\n    }\n};\n\n\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);    \n\t\n    int M, N; cin >> M >> N;\n    mi cnt[N+1][N+1];\n    F0R(i, N+1) {\n        F0R(j, N+1) {\n            cnt[i][j] = 0;\n        }\n        cnt[i][i] = i+1;\n        FOR(j, 1, i) {\n            mi lenVar = i - j - 1;\n            mi curCnt = i - j + 1;\n            cnt[i][j] = curCnt * pow((mi) 2, (ll) lenVar);\n        }\n    }\n\n    mi dp[M+1][N+1];\n    F0R(i, M+1) F0R(j, N+1) dp[i][j] = 0;\n    dp[M][N] = 1;\n    \n    FORd(i, 1, M+1) {\n        mi cur = 0;\n        mi sum = 0;\n        FORd(j, 1, N+1) {\n            cur -= sum; cur *= 2; sum *= 2;\n            if (j < N) {\n                cur -= (j+2) * dp[i][j+1];\n                sum -= dp[i][j+1];\n            }\n            cur += (j+1) * dp[i][j];\n            sum += dp[i][j];\n            dp[i-1][j] = cur;\n        }\n    }\n\n    mi ans = 0;\n    FOR(i, 1, N+1) ans += dp[0][i];\n    cout << ans << nl;\n\treturn 0;\n}\n \n// read the question correctly (ll vs int)\n// template by bqi343\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\ntypedef long long LL;\nconst int Mod = 1000000007;\nconst int MN = 5005;\n\nint N, M, f[MN][MN];\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int j = 1; j <= M; ++j) f[0][j] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 2; j <= M; ++j)\n\t\t\tf[i][j] = (2 * f[i][j - 1] + (LL)f[i - 1][j - 1] * (j - 1)) % Mod;\n\t\tfor (int j = 1; j <= M; ++j)\n\t\t\tf[i][j] = (f[i][j] + (LL)f[i - 1][j] * (j + 1)) % Mod;\n\t}\n\tprintf(\"%d\\n\", f[N][M]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\n\n#define mp make_pair\n\ntypedef tree<\n        pair<int, int>,\n        null_type,\n        less<pair<int, int>>,\n        rb_tree_tag,\n        tree_order_statistics_node_update>\n        ordered_set;\n\n\nconst int p = 1e9 + 7;\n\n\nint mul(int a, int b) {\n    return (1LL * a * b) % p;\n}\n\nint add(int a, int b) {\n    int s = (a+b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint sub(int a, int b) {\n    int s = (a+p-b);\n    if (s>=p) s-=p;\n    return s;\n}\n\nint po(int a, int deg)\n{\n    if (deg==0) return 1;\n    if (deg%2==1) return mul(a, po(a, deg-1));\n    int t = po(a, deg/2);\n    return mul(t, t);\n}\n\nint inv(int n)\n{\n    return po(n, p-2);\n}\n\n\nmt19937 rnd(time(0));\n\nstruct DSU {\n    vector<int> sz;\n    vector<int> parent;\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n    }\n\n    int find_set(int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(int a, int b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (sz[a] < sz[b])\n                swap(a, b);\n            parent[b] = a;\n            sz[a] += sz[b];\n        }\n    }\n\n    DSU(int n) {\n        sz.resize(n);\n        parent.resize(n);\n        for (int i = 0; i < n; i++) make_set(i);\n    }\n};\n\n/*\nconst int N = 1200000;\n\nvector<int> facs(N), invfacs(N);\n\nvoid init()\n{\n    facs[0] = 1;\n    for (int i = 1; i<N; i++) facs[i] = mul(facs[i-1], i);\n    invfacs[N-1] = inv(facs[N-1]);\n    for (int i = N-2; i>=0; i--) invfacs[i] = mul(invfacs[i+1], i+1);\n}\n\nint C(int n, int k)\n{\n    if (n<k) return 0;\n    return mul(facs[n], mul(invfacs[k], invfacs[n-k]));\n}\n*/\n\n\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(nullptr);\n\n    int n, m;\n    cin>>n>>m;\n\n    int N = m;\n    vector<int> dp(N+1); //dp[len]\n\n    for (int i = 1; i<=N; i++) dp[i] = 1;\n\n    for (int i = 0; i<n; i++)\n    {\n        vector<int> dp1(N+1);\n\n        int cur = 0;\n\n        for (int j = 1; j<=N; j++)\n        {\n            dp1[j] = mul(j+1, dp[j]);\n            cur = mul(cur, 2);\n            if (j>=2)\n            {\n                cur = add(cur, mul(dp[j-1], j-1));\n            }\n            dp1[j] = add(dp1[j], cur);\n            /*for (int seg = 2; seg<=j; seg++)\n            {\n                dp1[j] = add(dp1[j], mul(mul(j - seg + 1, po(2, seg-2)), dp[j-seg+1]));\n            }*/\n        }\n        dp = dp1;\n    }\n\n    cout<<dp[m];\n\n\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int P = 1e9 + 7;\ninline int mpow(int a, int b) {\n    int ans = 1;\n    for (; b; b >>= 1, a = (ll) a * a % P)\n        if (b & 1) ans = (ll) ans * a % P;\n    return ans;\n}\nvoid upd(int &x, int y) { x = x + y - P; x += x >> 31 & P; }\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n, m;\n    cin >> n >> m;\n    vector<int> dp(m + 1, 1);\n    for (int i = 1; i <= n; ++i) {\n        vector<int> new_dp(m + 1);\n        vector<int> sum(m + 1, 0);\n        sum[0] = 0;\n        for (int j = 1; j <= m; ++j) {\n            sum[j] = ((ll) 2 * sum[j - 1] % P + (ll) j * dp[j] % P) % P;\n            new_dp[j] = (sum[j - 1] + (ll) dp[j] * (j + 1) % P) % P;\n        }\n        swap(dp, new_dp);\n    }\n    cout << dp[m] << '\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\n\nconst ll Mod = 1000000007LL;\nconst int N = 5e3 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 30;\n\nvector<int> G[N];\nll mul(ll a, ll b){\n\treturn (a*b) % Mod;\n}\nll bin_pow(ll b, ll p){\n\tll res = 1;\n\tfor(ll pw = b, j = 1; j <= p; j <<= 1, pw = mul(pw, pw))\n\t\tif(p & j)\n\t\t\tres = mul(res, pw);\n\treturn res;\n}\n\nll dp[N][N], ps[N][N];\n\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tll iv2 = bin_pow(2, Mod - 2);\n\tfor(int i = 1; i < N; i++) dp[1][i] = bin_pow(2, i);\n\tfor(int i = 2; i < N; i++){\n\t\tps[i-1][0] = 0;\n\t\tfor(int j = 1; j < N; j++) ps[i - 1][j] = (ps[i-1][j-1] + mul(dp[i-1][j], mul(j, bin_pow(iv2, j)))) % Mod; \n\t\tfor(int j = 1; j < N; j++){\n\t\t\tdp[i][j] = dp[i - 1][j] * (j + 1);\n\t\t\tdp[i][j] %= Mod;\n\t\t\tif(j > 1){\n\t\t\t\tdp[i][j] += ps[i - 1][j - 1] * bin_pow(2, j - 1);\n\t\t\t\tdp[i][j] %= Mod;\n\t\t\t}\n\t\t}\n\t}\n\tll n, m;\n\tcin >> n >> m;\n\tcout << dp[n][m] << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  intmax_t dist(ng - ok);\n  while (std::abs(dist) > 1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (eps < std::abs(ok - ng)) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n}  // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n#line 7 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\variation\\\\modint.hpp\"\ntemplate <auto &mod>  // compile-time defined modulo.\nstruct modint {\n  using value_type = int_least64_t;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (int_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator+(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator-(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator*(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator/(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};  // class modint\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  solver() {\n    constexpr static int mod = 1000000007;\n    using mint = modint<mod>;\n\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n      // dump(nx);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nnamespace Base{\n\t# define mr make_pair\n\ttypedef long long ll;\n\ttypedef double db;\n\tconst int inf = 0x3f3f3f3f, INF = 0x7fffffff;\n\tconst ll  infll = 0x3f3f3f3f3f3f3f3fll, INFll = 0x7fffffffffffffffll;\n\ttemplate<typename T> void read(T &x){\n    \tx = 0; int fh = 1; double num = 1.0; char ch = getchar();\n\t\twhile (!isdigit(ch)){ if (ch == '-') fh = -1; ch = getchar(); }\n\t\twhile (isdigit(ch)){ x = x * 10 + ch - '0'; ch = getchar(); }\n\t    if (ch == '.'){\n\t    \tch = getchar();\n\t    \twhile (isdigit(ch)){num /= 10; x = x + num * (ch - '0'); ch = getchar();}\n\t\t}\n\t\tx = x * fh;\n\t}\n\ttemplate<typename T> void chmax(T &x, T y){x = x < y ? y : x;}\n\ttemplate<typename T> void chmin(T &x, T y){x = x > y ? y : x;}\n}\nusing namespace Base;\n\nconst int N = 5010, P = 1e9 + 7;\nint mul[N], f[N][N], n, m;\nint main(){\n\tread(n); read(m);\n\tfor (int i = 0; i <= m; i++) f[0][i] = 1;\n\tfor (int i = 1; i <= n; i++){\n\t\tint tot = 0;\n\t\tfor (int j = 1; j <= m; j++){\n\t\t\tf[i][j] = (j + 1ll) * f[i - 1][j] % P;\n\t\t\ttot = (tot * 2ll + f[i - 1][j - 1] * (j - 1ll)) % P;\n\t\t\tf[i][j] = (f[i][j] + tot) % P;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[n][m]);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\nconst int N=5005,M=1000000007;\nint n,i,m,j,k;\nlong long f[N][N],a[N],ans;\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\ta[0]=1;\n\tfor(i=1;i<=max(n,m);++i)\n\t\ta[i]=a[i-1]*2%M;\n\tf[n][m]=1;\n\tfor(i=n-1;i>=0;--i)\n\t{\n\t\tfor(j=m;j>=1;--j)\n\t\t\tf[i][j]=(f[i+1][j+1]+f[i][j+1]*2)%M;\n\t\tfor(j=1;j<=m;++j)\n\t\t\tf[i][j]=(f[i][j]*j+f[i+1][j]*(j+1))%M;\n\t\t/*{\n\t\t\tf[i][j]=f[i+1][j]*(j+1)%M;\n\t\t\tfor(k=j+1;k<=m;++k)\n\t\t\t\tf[i][j]=(f[i][j]+f[i+1][k]*a[k-j-1]%M*j)%M;\n\t\t}*/\n\t}\n\tfor(i=1;i<=m;++i)\n\t\tans=(ans+f[0][i])%M;\n\tcout<<(ans%M+M)%M;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <bitset>\n#include <functional>\n#include <random>\n#define REP(_i,_a,_n) for(int _i=_a;_i<=_n;++_i)\n#define PER(_i,_a,_n) for(int _i=_n;_i>=_a;--_i)\n#define hr putchar(10)\n#define pb push_back\n#define lc (o<<1)\n#define rc (lc|1)\n#define mid ((l+r)>>1)\n#define ls lc,l,mid\n#define rs rc,mid+1,r\n#define x first\n#define y second\n#define io std::ios::sync_with_stdio(false)\n#define endl '\\n'\n#define DB(_a) ({REP(_i,1,n) cout<<_a[_i]<<',';hr;})\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int P = 1e9+7, INF = 0x3f3f3f3f;\nll gcd(ll a,ll b) {return b?gcd(b,a%b):a;}\nll qpow(ll a,ll n) {ll r=1%P;for (a%=P;n;a=a*a%P,n>>=1)if(n&1)r=r*a%P;return r;}\nll inv(ll x){return x<=1?1:inv(P%x)*(P-P/x)%P;}\ninline int rd() {int x=0;char p=getchar();while(p<'0'||p>'9')p=getchar();while(p>='0'&&p<='9')x=x*10+p-'0',p=getchar();return x;}\n//head\n\n\n\nconst int N = 5e3+10;\nint n,m,f[N][N],g[N][N],pw[N],ipw[N];\n\nint main() {\n\tpw[0] = ipw[0] = 1;\n\tREP(i,1,N-1) ipw[i]=inv(pw[i]=pw[i-1]*2ll%P);\n\tscanf(\"%d%d\", &n, &m);\n\tREP(i,1,m) {\n\t\tf[1][i] = pw[i];\n\t\tg[1][i] = (g[1][i-1]+i)%P;\n\t}\n\tREP(i,2,n) REP(j,1,m) {\n\t\tf[i][j] = ((j+1ll)*f[i-1][j]+(ll)pw[j-1]*g[i-1][j-1])%P;\n\t\tg[i][j] = (g[i][j-1]+(ll)j*ipw[j]%P*f[i][j])%P;\n\t}\n\tprintf(\"%d\\n\", f[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nconst int mod=1e9+7;\ninline int ad(int x){return x>=mod?x-mod:x;}\nint f[5010][5010];\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n=read(),m=read();\n\tfor(int i=1;i<=m;i++)f[0][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint ul=0;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tul=ad(ad(ul*2)+1LL*f[i-1][j-1]*(j-1)%mod);\n\t\t\tf[i][j]=ad(ul+1LL*f[i-1][j]*(j+1)%mod);\n\t\t}\n\t}pr2(f[n][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n#include <utils/sfinae.hpp>\ntemplate <__uint128_t Mod = 0> struct modint {\n  using mod_type = typename std::conditional<bool(Mod), const int, int>::type;\n  static mod_type mod;\n  using value_type = int;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\ntemplate <__uint128_t Mod>\ntypename modint<Mod>::mod_type modint<Mod>::mod = Mod;\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  solver() {\n    // start here!\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    dp[0] = dp[0] + 1;\n    dp[0] = dp[0] - 1;\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int P = 1e9 + 7; int dp[5003][5003] , N , M , pw[5003] , iv[5003];\n\nint main(){\n\tcin >> N >> M; for(int j = 1 ; j <= M ; ++j) dp[0][j] = 1;\n\tpw[0] = iv[0] = 1; pw[1] = 2; iv[1] = (P + 1) / 2;\n\tfor(int i = 2 ; i <= M ; ++i){pw[i] = (pw[i - 1] * 2) % P; iv[i] = 1ll * iv[i - 1] * iv[1] % P;}\n\t\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tint sum = 0;\n\t\tfor(int j = 1 ; j <= M ; ++j){\n\t\t\tdp[i][j] = (dp[i][j] + 1ll * sum * pw[j] + (j + 1ll) * dp[i - 1][j]) % P;\n\t\t\tsum = (sum + 1ll * dp[i - 1][j] * j % P * iv[j + 1]) % P;\n\t\t}\n\t}\n\tcout << dp[N][M]; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nconst int N=5005;\nconst int MOD=1000000007;\nint n,m;\nlong long dp[N][N];\nlong long sum[N][N];\nlong long Pw[N],inP[N];\nlong long ksm(long long a,long long b)\n{\n\tlong long res=1;\n\twhile(b)\n\t{\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD,b>>=1;\n\t}\n\treturn res;\n}\nvoid init(int n=5000)\n{\n\tPw[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tPw[i]=Pw[i-1]*2%MOD;\n\tinP[n]=ksm(Pw[n],MOD-2);\n\tfor(int i=n;i>=1;i--)\n\t\tinP[i-1]=inP[i]*2%MOD;\n\treturn;\n}\nint main()\n{\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int j=1;j<=m;j++)\n\t\tdp[0][j]=1,sum[0][j]=(sum[0][j-1]+dp[0][j]*j%MOD*inP[j]%MOD)%MOD;\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tdp[i][j]=dp[i-1][j]*(j+1)%MOD;\n\t\t\tdp[i][j]=(dp[i][j]+sum[i-1][j-1]*Pw[j-1]%MOD)%MOD;\n\t\t\tsum[i][j]=(sum[i][j-1]+dp[i][j]*j%MOD*inP[j]%MOD)%MOD;\n\t\t}\n\tprintf(\"%lld\",dp[n][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=5000,mod=1000000007;\n\nint add(int a,int b,int p=mod){return a+b>=p?a+b-p:a+b;}\nint sub(int a,int b,int p=mod){return a-b<0?a-b+p:a-b;}\nint mul(int a,int b,int p=mod){return (LL)a*b%p;}\nvoid sadd(int &a,int b,int p=mod){a=add(a,b,p);}\nvoid ssub(int &a,int b,int p=mod){a=sub(a,b,p);}\nvoid smul(int &a,int b,int p=mod){a=mul(a,b,p);}\n\nint n,m;\n\nvoid into(){\n  scanf(\"%d%d\",&n,&m);\n}\n\nint dp[N+9][N+9];\n\nvoid Get_dp(){\n  for (int i=1;i<=m;++i) dp[0][i]=1;\n  for (int i=1;i<=n;++i){\n\tint sum=0;\n\tfor (int j=1;j<=m;++j){\n\t  sadd(dp[i][j],mul(dp[i-1][j],j+1));\n\t  sadd(dp[i][j],sum);\n\t  sum=add(mul(sum,2),mul(dp[i-1][j],j));\n\t}\n  }\n}\n\nvoid work(){\n  Get_dp();\n}\n\nvoid outo(){\n  printf(\"%d\\n\",dp[n][m]);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\n#ifndef AT_HOME\n#define getchar() IO::myGetchar()\n#define putchar(x) IO::myPutchar(x)\n#endif\n\nnamespace IO {\n\tstatic const int IN_BUF = 1 << 23, OUT_BUF = 1 << 23;\n\n\tinline char myGetchar() {\n\t\tstatic char buf[IN_BUF], *ps = buf, *pt = buf;\n\t\tif (ps == pt) {\n\t\t\tps = buf, pt = buf + fread(buf, 1, IN_BUF, stdin);\n\t\t}\n\t\treturn ps == pt ? EOF : *ps++;\n\t}\n\n\ttemplate<typename T>\n\tinline bool read(T &x) {\n\t\tbool op = 0;\n\t\tchar ch = getchar();\n\t\tx = 0;\n\t\tfor (; !isdigit(ch) && ch != EOF; ch = getchar()) {\n\t\t\top ^= (ch == '-');\n\t\t}\n\t\tif (ch == EOF) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (; isdigit(ch); ch = getchar()) {\n\t\t\tx = x * 10 + (ch ^ '0');\n\t\t}\n\t\tif (op) {\n\t\t\tx = -x;\n\t\t}\n\t\treturn true;\n\t}\n\n\tinline int readStr(char *s) {\n\t\tint n = 0;\n\t\tchar ch = getchar();\n\t\tfor (; isspace(ch) && ch != EOF; ch = getchar())\n\t\t\t;\n\t\tfor (; !isspace(ch) && ch != EOF; ch = getchar()) {\n\t\t\ts[n++] = ch;\n\t\t}\n\t\ts[n] = '\\0';\n\t\treturn n;\n\t}\n\n\tinline void myPutchar(char x) {\n\t\tstatic char pbuf[OUT_BUF], *pp = pbuf;\n\t\tstruct _flusher {\n\t\t\t~_flusher() {\n\t\t\t\tfwrite(pbuf, 1, pp - pbuf, stdout);\n\t\t\t}\n\t\t};\n\t\tstatic _flusher outputFlusher;\n\t\tif (pp == pbuf + OUT_BUF) {\n\t\t\tfwrite(pbuf, 1, OUT_BUF, stdout);\n\t\t\tpp = pbuf;\n\t\t}\n\t\t*pp++ = x;\n\t}\n\n\ttemplate<typename T>\n\tinline void print_(T x) {\n\t\tif (x == 0) {\n\t\t\tputchar('0');\n\t\t\treturn;\n\t\t}\n\t\tstatic int num[40];\n\t\tif (x < 0) {\n\t\t\tputchar('-');\n\t\t\tx = -x;\n\t\t}\n\t\tfor (*num = 0; x; x /= 10) {\n\t\t\tnum[++*num] = x % 10;\n\t\t}\n\t\twhile (*num){\n\t\t\tputchar(num[*num] ^ '0');\n\t\t\t--*num;\n\t\t}\n\t}\n\n\ttemplate<typename T>\n\tinline void print(T x, char ch = '\\n') {\n\t\tprint_(x);\n\t\tputchar(ch);\n\t}\n\n\tinline void printStr_(const char *s, int n = -1) {\n\t\tif (n == -1) {\n\t\t\tn = strlen(s);\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tputchar(s[i]);\n\t\t}\n\t}\n\n\tinline void printStr(const char *s, int n = -1, char ch = '\\n') {\n\t\tprintStr_(s, n);\n\t\tputchar(ch);\n\t}\n}\nusing namespace IO;\n\nconst int N = 5005, P = 1000000007;\n\nint n, m;\nint f[N][N];\n\nint main() {\n\tread(n), read(m);\n\tfor (int i = 1; i <= m; ++i) {\n\t\tf[0][i] = 1;\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint s = 0;\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tf[i][j] = (1ll * (j + 1) * f[i - 1][j] + s) % P;\n\t\t\ts = (2ll * s + 1ll * j * f[i - 1][j]) % P;\n\t\t}\n\t}\n\tprint(f[n][m]);\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n// #define BEGIN_STACK_EXTEND(size) void * stack_extend_memory_ = malloc(size);void * stack_extend_origin_memory_;char * stack_extend_dummy_memory_ = (char*)alloca((1+(int)(((long long)stack_extend_memory_)&127))*16);*stack_extend_dummy_memory_ = 0;asm volatile(\"mov %%rsp, %%rbx\\nmov %%rax, %%rsp\":\"=b\"(stack_extend_origin_memory_):\"a\"((char*)stack_extend_memory_+(size)-1024));\n// #define END_STACK_EXTEND asm volatile(\"mov %%rax, %%rsp\"::\"a\"(stack_extend_origin_memory_));free(stack_extend_memory_);\n\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<unordered_map>\n#include<complex>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-11;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3100000;\nconst int UF_SIZE = 3100000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tinline long long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\tint UF[UF_SIZE];\n\tvoid init_UF(int n){\n\t\tfor(int i=0;i<n;i++)UF[i]=-1;\n\t}\n\tint FIND(int a){\n\t\tif(UF[a]<0)return a;\n\t\treturn UF[a]=FIND(UF[a]);\n\t}\n\tvoid UNION(int a,int b){\n\t\ta=FIND(a);b=FIND(b);if(a==b)return;\n\t\tif(UF[a]>UF[b])swap(a,b);\n\t\tUF[a]+=UF[b];UF[b]=a;\n\t}\n}\n// ここから編集しろ\nlong long dp[5100][5100];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tinit_C(210000);\n\tdp[0][b]=1;\n\tfor(int i=0;i<a;i++){\n\t\tlong long tmp=0;\n\t\tfor(int j=b;j>=1;j--){\n\t\t\t// printf(\"%d %d: %lld\\n\",i,j,dp[i][j]);\n\t\t\tdp[i+1][j]=(tmp*j+dp[i][j]*(j+1))%mod;\n\t\t\ttmp=tmp*2%mod;\n\t\t\ttmp=(tmp+dp[i][j])%mod;\n\t\t\t\n\t\t}\n\t}\n\tlong long ret=0;\n\tfor(int i=1;i<=b;i++){\n\t\t// printf(\"%d: %lld\\n\",i,dp[a][i]);\n\t\tret+=dp[a][i];\n\t}\n\tret%=mod;\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAuthor: QAQAutomaton\nLang: C++\nCode: F.cpp\nMail: lk@qaq-am.com\nBlog: https://www.qaq-am.com/\n*/\n#include<bits/stdc++.h>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\n#define DEBUG printf(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define Debug debug(\"Passing [%s] in LINE %d\\n\",__FUNCTION__,__LINE__)\n#define all(x) x.begin(),x.end()\n#define x first\n#define y second\nusing namespace std;\ntypedef unsigned uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef complex<double> cp;\ntypedef pair<int,int> pii;\nint inf;\nconst double eps=1e-8;\nconst double pi=acos(-1.0);\ntemplate<class T,class T2>int chkmin(T &a,T2 b){return a>b?a=b,1:0;}\ntemplate<class T,class T2>int chkmax(T &a,T2 b){return a<b?a=b,1:0;}\ntemplate<class T>T sqr(T a){return a*a;}\ntemplate<class T,class T2>T mmin(T a,T2 b){return a<b?a:b;}\ntemplate<class T,class T2>T mmax(T a,T2 b){return a>b?a:b;}\ntemplate<class T>T aabs(T a){return a<0?-a:a;}\ntemplate<class T>int dcmp(T a,T b){return a>b;}\ntemplate<int *a>int cmp_a(int x,int y){return a[x]<a[y];}\n#define min mmin\n#define max mmax\n#define abs aabs\nstruct __INIT__{\n\t__INIT__(){\n\t\tmemset(&inf,0x3f,sizeof(inf));\n\t}\n}__INIT___;\nnamespace io {\n\tconst int SIZE = (1 << 21) + 1;\n\tchar ibuf[SIZE], *iS, *iT, obuf[SIZE], *oS = obuf, *oT = oS + SIZE - 1, c, qu[55]; int f, qr;\n\t// getchar\n\t#define gc() (iS == iT ? (iT = (iS = ibuf) + fread (ibuf, 1, SIZE, stdin), (iS == iT ? EOF : *iS ++)) : *iS ++)\n\t// print the remaining part\n\tinline void flush () {\n\t\tfwrite (obuf, 1, oS - obuf, stdout);\n\t\toS = obuf;\n\t}\n\t// putchar\n\tinline void putc (char x) {\n\t\t*oS ++ = x;\n\t\tif (oS == oT) flush ();\n\t}\n\ttemplate<typename A>\n\tinline bool read (A &x) {\n\t\tfor (f = 1, c = gc(); c < '0' || c > '9'; c = gc()) if (c == '-') f = -1;else if(c==EOF)return 0;\n\t\tfor (x = 0; c <= '9' && c >= '0'; c = gc()) x = x * 10 + (c & 15); x *= f;\n\t\treturn 1;\n\t}\n\tinline bool read (char &x) {\n\t\twhile((x=gc())==' '||x=='\\n' || x=='\\r');\n\t\treturn x!=EOF;\n\t}\n\tinline bool read(char *x){\n\t\twhile((*x=gc())=='\\n' || *x==' '||*x=='\\r');\n\t\tif(*x==EOF)return 0;\n\t\twhile(!(*x=='\\n'||*x==' '||*x=='\\r'||*x==EOF))*(++x)=gc();\n\t\t*x=0;\n\t\treturn 1;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool read(A &x,B &...y){\n\t\treturn read(x)&&read(y...);\n\t}\n\ttemplate<typename A>\n\tinline bool write (A x) {\n\t\tif (!x) putc ('0'); if (x < 0) putc ('-'), x = -x;\n\t\twhile (x) qu[++ qr] = x % 10 + '0',  x /= 10;\n\t\twhile (qr) putc (qu[qr --]);\n\t\treturn 0;\n\t}\n\tinline bool write (char x) {\n\t\tputc(x);\n\t\treturn 0;\n\t}\n\tinline bool write(const char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\tinline bool write(char *x){\n\t\twhile(*x){putc(*x);++x;}\n\t\treturn 0;\n\t}\n\ttemplate<typename A,typename ...B>\n\tinline bool write(A x,B ...y){\n\t\treturn write(x)||write(y...);\n\t}\n\t//no need to call flush at the end manually!\n\tstruct Flusher_ {~Flusher_(){flush();}}io_flusher_;\n}\nusing io :: read;\nusing io :: putc;\nusing io :: write;\nconst uint p=1000000007;\nstruct Z{\n\tuint x;\n\tZ(){}\n\tZ(uint a){x=a;}\n    Z& operator++(){x=x==p-1?0:x+1;return *this;}\n    Z& operator--(){x=x?x-1:p-1;return *this;}\n};\ninline uint modp(const uint x){\n\treturn x<p?x:x-p;\n}\ninline Z operator+(const Z x1, const Z x2) { return modp(x1.x+x2.x);}\ninline Z operator-(const Z x1, const Z x2) { return modp(x1.x+p-x2.x);}\ninline Z operator-(const Z x) {return x.x?p-x.x:0;}\ninline Z operator*(const Z x1, const Z x2) { return static_cast<ull>(x1.x)*x2.x%p;}\nvoid exgcd(int a,int b,int &x,int &y){\n\tif(!b){x=1;y=0;return;}\t\n\texgcd(b,a%b,y,x);\n\ty-=(a/b)*x;\n}\ninline Z Inv(const Z x){\n\tint a,b;\n\texgcd(p,x.x,a,b);\n\treturn b<0?b+p:b;\n}\ninline Z operator/(const Z x1,const Z x2){return x1*Inv(x2);}\ninline Z &operator+=(Z &x1, const Z x2) { return x1 = x1 + x2; }\ninline Z &operator-=(Z &x1, const Z x2) { return x1 = x1 - x2; }\ninline Z &operator*=(Z &x1, const Z x2) { return x1 = x1 * x2; }\ninline Z &operator/=(Z &x1, const Z x2) { return x1 = x1 / x2; }\nZ f[5005],g[5005],pw[5005],s[5005],ipw[5005];\nsigned main(){\n#ifdef QAQAutoMaton \n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tint n,m;\t\n\tread(n,m);\n\tf[m]=1;\n\tpw[0]=1;\n\tipw[0]=1;\n\tfor(int i=1;i<=m;++i)pw[i]=pw[i-1]*2;\n\tfor(int i=1;i<=m;++i)ipw[i]=ipw[i-1]*((p+1)>>1);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=m;j;--j)s[j]=s[j+1]+f[j]*pw[j];\n\t\tfor(int j=m;j;--j){\n\t\t\tg[j]=f[j]*(j+1);\n\t\t\tg[j]+=s[j+1]*ipw[j+1]*j;\n\t\t}\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tf[j]=g[j];\n\t\t}\n\t}\n\tZ ans(0);\n\tfor(int i=1;i<=m;++i){\n\t\tans+=f[i];\t\n\t}\n\twrite(ans.x,'\\n');\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\n\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\n\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\ntemplate <class T>\nconstexpr static bool is_integral_ext_v = is_integral_ext<T>::value;\n\ntemplate <typename T, typename = void> struct multiplicable_uint {\n  using type = uint_least32_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(2 < sizeof(T))>::type> {\n  using type = uint_least64_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(4 < sizeof(T))>::type> {\n  using type = __uint128_t;\n};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\n\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      Mod != 0, typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (typename multiplicable_uint<value_type>::type)value *\n                   rhs.value % mod,\n           *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1}, p{*this};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n// #include \"atcoder/modint.hpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  // using mint = modint_runtime;\n  // using mint = atcoder::modint;\n\n  solver() {\n    // start here!\n    // mint::mod = 1e9 + 7;\n    // mint::set_mod(1e9 + 7);\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(dp, nx);\n    }\n    cout << dp[m] << \"\\n\";\n    // cout << dp[m].val() << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace/nomura2020/f/f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library/config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library/gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library/gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library/utils/binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library/utils/casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library/utils/chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library/utils/fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 3 \"Library/utils/sfinae.hpp\"\n#include <type_traits>\n\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\n\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\ntemplate <class T>\nconstexpr static bool is_integral_ext_v = is_integral_ext<T>::value;\n\ntemplate <typename T, typename = void> struct multiplicable_uint {\n  using type = uint_least32_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(2 < sizeof(T))>::type> {\n  using type = uint_least64_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(4 < sizeof(T))>::type> {\n  using type = __uint128_t;\n};\n#line 7 \"Library/utils/hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library/utils/read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library/utils/stream.hpp\"\n\n#line 6 \"Library/utils/stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace/nomura2020/f/f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library/modulus/modint.hpp\"\n\n#line 6 \"Library/modulus/modint.hpp\"\n\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      Mod != 0, typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint(bool n) noexcept : modint(int(n)) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (typename multiplicable_uint<value_type>::type)value *\n                   rhs.value % mod,\n           *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1}, p{*this};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace/nomura2020/f/f.cpp\"\n// #include \"atcoder/modint.hpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  // using mint = modint_runtime;\n  // using mint = atcoder::modint;\n\n  solver() {\n    // start here!\n    // mint::mod = 1e9 + 7;\n    // mint::set_mod(1e9 + 7);\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(dp, nx);\n    }\n    cout << dp[m] << \"\\n\";\n    // cout << dp[m].val() << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cctype>\n\n#include <algorithm>\n#include <random>\n#include <bitset>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <vector>\n#include <chrono>\n#include <iostream>\n#include <limits>\n#include <numeric>\n\n#define LOG(FMT...) fprintf(stderr, FMT)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\ntemplate <class T>\nistream& operator>>(istream& is, vector<T>& v) {\n  for (T& x : v)\n    is >> x;\n  return is;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n  if (!v.empty()) {\n    os << v.front();\n    for (int i = 1; i < v.size(); ++i)\n      os << ' ' << v[i];\n  }\n  return os;\n}\n\nconst int P = 1000000007;\n\nint norm(int x) { return x >= P ? (x - P) : x; }\n\nvoid add(int& x, int y) { if ((x += y) >= P) x -= P; }\n\nvoid sub(int& x, int y) { if ((x -= y) < 0) x += P; }\n\nvoid exGcd(int a, int b, int& x, int& y) {\n  if (!b) {\n    x = 1;\n    y = 0;\n    return;\n  }\n  exGcd(b, a % b, y, x);\n  y -= a / b * x;\n}\n\nint inv(int a) {\n  int x, y;\n  exGcd(a, P, x, y);\n  return norm(x + P);\n}\n\nconst int N = 5010;\n\nint dp[N], tmp[N];\n\nint main() {\n#ifdef ELEGIA\n  freopen(\"test.in\", \"r\", stdin);\n  int nol_cl = clock();\n#endif\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n\n  int n, m;\n  cin >> n >> m;/*\n  for (int i = 0; i <= m; ++i) dp[0][i] = 1;\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 0; j <= m; ++j) {\n      dp[i][j] = dp[i - 1][j] * (j + 1);\n      for (int k = 2; k <= j; ++k)\n        dp[i][j] += dp[i - 1][j - k + 1] * (j - k + 1) * pow(2, k - 2);\n    }\n  }*/\n  fill(dp, dp + m + 1, 1);\n  for (int rep = 0; rep < n; ++rep) {\n    for (int i = 0; i <= m; ++i)\n      tmp[i] = dp[i] * (i + 1LL) % P;\n    int sum = 0;\n    for (int i = 2; i <= m; ++i) {\n      sum = (sum * 2LL + dp[i - 1] * (i - 1LL) % P) % P;\n      add(tmp[i], sum);\n    }\n    memcpy(dp, tmp, sizeof(dp));\n  }\n  cout << dp[m] << '\\n';\n\n#ifdef ELEGIA\n  LOG(\"Time: %dms\\n\", int ((clock()\n          -nol_cl) / (double)CLOCKS_PER_SEC * 1000));\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\ntypedef long double ld;\nusing namespace std;\n#define F first\n#define S second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define SZ(x) (int)(x).size()\n//#define int ll\n\nconst int MOD = 1e9 + 7;\ninline int sum(int a, int b) {\n  a += b;\n  if (a >= MOD) {\n    a -= MOD;\n  }\n  return a;\n}\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= MOD) {\n    a -= MOD;\n  }\n}\n\ninline int mult(int a, int b) {\n  return (a * 1ll * b) % MOD; \n}\n\nconst int N = 5010;\nint dp[N][N], pw[N];\n\nsigned main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  int n, m;\n  cin >> n >> m;\n  pw[0] = 1;\n  for (int i = 1; i <= m; i++) {\n    pw[i] = sum(pw[i - 1], pw[i - 1]);\n  }\n  for (int i = 0; i <= m; i++) {\n    dp[i][0] = 1;\n    for (int j = 1; j <= n; j++) {\n      dp[i][j] = mult(dp[i][j - 1], i + 1);\n      for (int len = 2; len <= i; len++) {\n        add(dp[i][j], mult(pw[len - 2], mult(dp[i - len + 1][j - 1], i - len + 1)));\n      }\n    }\n  }\n  cout << dp[m][n] << '\\n';\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <iomanip>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <stdio.h>\n#include <time.h>\n#include <numeric>\n#include <random>\n#include <unordered_map>\n#include <unordered_set>\n#define all(a) a.begin(),a.end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define pb push_back\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\ntypedef complex<ld> com;\nconstexpr int inf = 1000000010;\nconstexpr ll INF = 1000000000000000010;\nconstexpr ld eps = 1e-12;\nconstexpr ld pi = 3.141592653589793238;\ntemplate<class T, class U> inline bool chmax(T &a, const U &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T, class U> inline bool chmin(T &a, const U &b) { if (a > b) { a = b; return true; } return false; }\n\nconstexpr ll mod = 1000000007;\nconstexpr ll modsize = 0;\nvector<ll> fac(modsize);\nvector<ll> inv(modsize);\nvector<ll> facinv(modsize);\n\nvoid modcalc() {\n\tif (modsize == 0) abort();\n\tfac[0] = 1; fac[1] = 1; inv[1] = 1;\n\tfacinv[0] = 1; facinv[1] = 1;\n\tfor (ll i = 2; i < modsize; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfacinv[i] = facinv[i - 1] * inv[i] % mod;\n\t}\n}\n\nll modinv(ll a) {\n\tif (a == 0) abort();\n\tll b = mod, u = 1, v = 0;\n\twhile (b) {\n\t\tll t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= mod;\n\tif (u < 0) u += mod;\n\treturn u;\n}\n\nll modpow(ll a, ll b) {\n\tll ans = 1;\n\ta %= mod;\n\twhile (b) {\n\t\tif (b & 1) ans = ans * a % mod;\n\t\ta = a * a % mod;\n\t\tb >>= 1;\n\t}\n\treturn ans;\n}\n\nll modcomb(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[k] % mod * facinv[n - k] % mod;\n}\n\nll modperm(ll n, ll k) {\n\tif (n < 0 || k < 0 || n < k) return 0;\n\treturn fac[n] * facinv[n - k] % mod;\n}\n\nll modhom(ll n, ll k) {\n\tif (n < 0 || k < 0 || n == 0 && k > 0) return 0;\n\tif (n == 0 && k == 0) return 1;\n\treturn fac[n + k - 1] * facinv[k] % mod * facinv[n - 1] % mod;\n}\n\nll dp[5010][5010];\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n\n\tll n, m;\n\tcin >> n >> m;\n\trep(j, m + 1) dp[1][j] = modpow(2, j);\n\trep(i, n + 1) {\n\t\tll p = 0;\n\t\trep(j, m + 1) {\n\t\t\tdp[i + 1][j] += dp[i][j] * (j + 1) % mod;\n\t\t\tif (j >= 2) {\n\t\t\t\tp *= 2;\n\t\t\t\tp += (j - 1) * dp[i][j - 1] % mod;\n\t\t\t\tp %= mod;\n\t\t\t}\n\t\t\tdp[i + 1][j] += p;\n\t\t\tdp[i + 1][j] %= mod;\n\t\t}\n\t}\n\tcout << dp[n][m] << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\nusing mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\nmint mpow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n /= 2;\n\t}\n\treturn ans;\n}\nsigned main() {\n\tomajinai;\n\tint n, m; cin >> n >> m;\n\tvvem dp(n + 1, vem(m + 1, 0));\n\tfor (int i = 1; i <= m; i++) {\n\t\tdp[1][i] = mpow(2, i);\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tmint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tdp[i][j] += sum + dp[i - 1][j] * (j + 1);\n\t\t\tsum *= 2;\n\t\t\tsum += dp[i - 1][j] * j;\n\t\t}\n\t}\n\tcout << dp[n][m].value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include <bits/stdc++.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB emplace_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(int64_t &x) { scanf(\"%lld\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const int64_t &x) { printf(\"%lld\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1<<20;\nLL mypow(LL x,LL y){\n    x%=MOD;\n    LL res=1%MOD;\n    while(y){\n        if(y&1)res=res*x%MOD;\n        y>>=1;\n        x=x*x%MOD;\n    }\n    return res;\n}\nLL inv(LL x){\n    return mypow(x,MOD-2);\n}\nLL dp[5001][5001],dp2[5001][5001];\nLL mul[5001],tmp[5001],two[5001];\nint main(){\n    int N,M;\n    R(M,N);\n    mul[0]=1;\n    two[0]=1;\n    FOR(i,1,5000){\n        mul[i]=mul[i-1]*(N+1)%MOD;\n        two[i]=two[i-1]*2%MOD;\n    }\n    dp[0][N]=1;\n    FOR(i,1,M){\n        FOR(j,1,N){\n            ADD(dp[i][j],dp[i-1][j]*(j+1));\n        }\n        for(int j=N-1;j>0;j--)ADD(dp[i-1][j],dp[i-1][j+1]*2);\n        FOR(j,1,N){\n            ADD(dp[i][j],dp[i-1][j+1]*j);\n        }\n    }\n    LL an=0;\n    FOR(i,1,N)ADD(an,dp[M][i]);\n    W(an);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\nconst int N = 5001;\n\nint sum(int a, int b) {\n\tif ((a += b) >= mod) {\n\t\ta -= mod;\n\t}\n\treturn a;\n}\n\nint n, m;\nint dp[N][N];\nint pw2[N];\nint suf_dp[N][N + 1];\n\nint main() {\n\tpw2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tpw2[i] = sum(pw2[i - 1], pw2[i - 1]);\n\t}\n\tcin >> n >> m;\n\tdp[0][m] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = m; j >= 1; j--) {\n\t\t\tdp[i][j] = sum(1LL * (j + 1) * dp[i - 1][j] % mod, 1LL * j * suf_dp[i - 1][j + 1] % mod);\n\t\t\tsuf_dp[i - 1][j] = sum(sum(suf_dp[i - 1][j + 1], suf_dp[i - 1][j + 1]), dp[i - 1][j]);\n\t\t\t/*for(int p = m; p >= j + 1; p--) {\n\t\t\t\tdp[i][j] = sum(dp[i][j], 1LL * dp[i - 1][p] * pw2[p - j - 1] % mod * j % mod);\n\t\t\t}*/\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int rem = 1; rem <= m; rem++) {\n\t\tans = sum(ans, dp[n][rem]);\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\n\n\n\ntemplate <class Mint>\nV<Mint> powTable(int n, Mint x) {\n    V<Mint> table(n + 1);\n    table[0] = Mint(1);\n    for (int i = 1; i <= n; i++) {\n        table[i] = table[i - 1] * x;\n    }\n    return table;\n}\n\ntemplate<class Mint>\nstruct Comb {\n    int max_n;\n    V<Mint> fact, ifact;\n    Comb() {}\n    Comb(int n) : max_n(n) {\n        fact = ifact = V<Mint>(n + 1);\n        fact[0] = Mint(1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;\n    }\n\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        assert(0 <= k && k <= n && n <= max_n);\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    // n個の区別出来ないボールをk個の箱に入れる入れ方\n    Mint H(int n, int k) {\n        if (n == 0 && k == 0) return Mint(1);\n        return C(n + k - 1, n);\n    }\n};\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n\nstruct DynamicModInt {\n    using M = DynamicModInt;\n\n  private:\n    static uint MD;\n    static ull iMD;\n    uint v = 0;\n\n  public:\n    static void set_mod(uint _MD) {\n        assert(2 <= _MD);\n        MD = _MD;\n        iMD = ull(-1) / _MD + 1;\n    }\n    DynamicModInt() {}\n    DynamicModInt(ll _v) { set_v(uint(_v % MD + MD)); }\n    static DynamicModInt raw(uint x) {\n      DynamicModInt m;\n      m.v = x;\n      return m;\n    }\n    uint val() const { return v; }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    /*\n    u32 fact_fast(u32 n, u32 mod) {\n      u64 imod = u64(-1) / mod + 1; // ceil((1<<64) / mod);\n      auto mul_mod = [&](u32 a, u32 b) {\n        u64 c = u64(a) * b;\n        u64 d = (__uint128_t(c) * imod) >> 64;\n        u64 e = (c - d * mod + mod);\n        //return e;\n        return (e < mod) ? e : e - mod;\n      };\n      u32 ret = 1;\n      for (int i = 1; i <= n; ++i) ret = mul_mod(ret, i);\n      return ret;\n    }\n    */\n    M operator*(const M& r) const {\n        ull c = ull(v) * r.v;\n        ull d = (__uint128_t(c) * iMD) >> 64;\n        return M().set_v(uint(c - d * MD + MD));\n    }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const {\n        pair<uint, ll> p = {MD, 0}, q = {v, 1};\n        while (q.first) {\n            uint t = p.first / q.first;\n            p.first -= t * q.first;\n            p.second -= t * q.second;\n            swap(p, q);\n        }\n        return M(p.second);\n    }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nuint DynamicModInt::MD;\null DynamicModInt::iMD;\nusing Mint = DynamicModInt;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    Mint::set_mod(TEN(9) + 7);\n    V<Mint> p2 = powTable(10000, Mint(2));\n    int n, m;\n    sc.read(n, m);\n\n    V<Mint> dp(m + 1);\n    dp[m] = Mint(1);\n\n    for (int ph = 0; ph < n; ph++) {\n        V<Mint> ndp(m + 1);\n        Mint sm = 0;\n        for (int j = m; j >= 1; j--) {\n            ndp[j] = Mint::raw(j) * sm + dp[j] * Mint::raw(j + 1);\n            sm *= Mint::raw(2);\n            sm += dp[j];\n        }\n        dp = ndp;\n/*        for (int j = 1; j <= m; j++) {\n            for (int k = 1; k < j; k++) {\n                // j -> k\n                dp[k] += dp[j] * Mint(k) * p2[j - k - 1];\n            }\n            dp[j] *= Mint(j + 1);\n        }*/\n    }\n           ;\n    Mint sm = 0;\n    for (auto x: dp) {\n        sm += x;\n    }\n    pr.writeln(sm.val());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int MOD = 1000000007;\nvoid add(int &a, const int &b) {\n\ta += b;\n\tif (a >= MOD) a -= MOD;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<int> > dp(N + 1, vector<int>(M + 1, 0));\n\tfor (int j = 0; j <= M; j++) {\n\t\tdp[0][j] = 1;\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tint cur = 0;\n\t\tfor (int j = 0; j <= M; j++) {\n\t\t\tadd(dp[i][j], cur);\n\t\t\tadd(dp[i][j], (j + 1) * dp[i - 1][j] % MOD);\n\t\t\tcur *= 2;\n\t\t\tcur += j * dp[i - 1][j];\n\t\t\tcur %= MOD;\n\t\t}\n\t}\n\tcout << dp[N][M] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int mod=1e9+7;\nconst int inv2=(mod+1)/2;\n#define N 5005\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint dp[N][N],n,m;\nint pw[N],inv[N],s[N];\nint main(){\n\tn=read(),m=read();\n\tpw[0]=inv[0]=1;\n\tfor(int i=1;i<=m;++i){\n\t\tpw[i]=(pw[i-1]<<1)%mod;\n\t\tinv[i]=1LL*inv[i-1]*inv2%mod;\n\t}\n\tfor(int i=1;i<=m;++i){\n\t\tdp[1][i]=pw[i];\n\t\ts[i]=(s[i-1]+1LL*dp[1][i]*i%mod*inv[i+1])%mod;\n\t}\n\tfor(int i=2;i<=n;++i){\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tdp[i][j]=(1LL*dp[i-1][j]*(j+1)+1LL*s[j-1]*pw[j])%mod;\n\t\t}\n\t\tfor(int j=1;j<=m;++j){\n\t\t\ts[j]=(s[j-1]+1LL*dp[i][j]*j%mod*inv[j+1])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit unsigned int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 1e9 + 7;\nusing mod_int = _m_int<MOD>;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<mod_int> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++) {\n        vector<mod_int> next_dp(M + 1, 0);\n        mod_int sum = 0;\n\n        for (int m = 0; m <= M; m++) {\n            next_dp[m] = (m + 1) * dp[m];\n\n            if (m >= 2)\n                sum = 2 * sum + (m - 1) * dp[m - 1];\n\n            next_dp[m] += sum;\n        }\n\n        dp = next_dp;\n    }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define meow(args...) fprintf(stderr, args)\ntypedef unsigned u32;\ntypedef long long s64;\ntypedef unsigned long long u64;\ntemplate<class T1, class T2> inline bool cmin(T1 &a, const T2 &b) {return b<a?(a=b, true):false;}\ntemplate<class T1, class T2> inline bool cmax(T1 &a, const T2 &b) {return a<b?(a=b, true):false;}\ntemplate<class Type> Type read() {\n\tType a;\n\tbool b;\n\tunsigned char c;\n\twhile(c=getchar()-48, (c>9)&(c!=253));\n\tfor(a=(b=c==253)?0:c; (c=getchar()-48)<=9; a=a*10+c);\n\treturn b?-a:a;\n}\nint (*rd)()=read<int>;\nconst u32 P=1e9+7;\ninline u32 &inc(u32 &a, u32 b) {return (a+=b)<P?a:(a-=P);}\ninline u32 &dec(u32 &a, u32 b) {return (a-=b)&0x80000000?(a+=P):a;}\ninline u32 sum(u32 a, u32 b) {return (a+=b)<P?a:a-P;}\ninline u32 dif(u32 a, u32 b) {return (a-=b)&0x80000000?a+P:a;}\nu64 power(u64 a, int b) {\n\tu64 ans=1;\n\tfor(; b; a=a*a%P, b/=2) if(b&1) ans=ans*a%P;\n\treturn ans;\n}\n\nconst int N=5005;\nconst u32 Half=(P+1)/2;\nint n, m;\nu32 f[N], g[N];\nint main() {\n\tn=rd();\n\tm=rd();\n\tf[m]=1;\n\tfor(int i=1; i<=n; ++i) {\n\t\tu32 cur=0;\n\t\tfor(int j=m; j>=1; --j)\n\t\t\tg[j]=cur=(cur*2+f[j+1])%P;\n\t\tfor(int j=1; j<=m; ++j)\n\t\t\tf[j]=((j+1llu)*f[j]+1llu*j*g[j])%P;\n\t}\n\tu32 ans=0;\n\tfor(int i=1; i<=m; ++i) ans=(ans+f[i])%P;\n\tprintf(\"%u\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=5005,mod=1e9+7,inv2=(mod+1)/2;\nint f[N][N],s2[N][N],pw[N],ipw[N],n,m,ans;\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1) res=(ll)res*x%mod;\n\treturn res;\n}\nint mul(int x,int y){\n\treturn (ll)x*y%mod;\n}\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\nint pw2(int x){\n\treturn x>=0?pw[x]:ipw[-x];\n}\n\nint main(){\n\tread(n),read(m);\n\tswap(n,m);\n\tpw[0]=ipw[0]=1;\n\trep(i,1,5000){\n\t\tpw[i]=mul(pw[i-1],2);\n\t\tipw[i]=mul(ipw[i-1],inv2);\n\t}\n\trep(i,1,n){\n\t\tf[0][i]=1;\n\t\ts2[0][i]=mul(i,pw2(-i));\n\t\tadd(s2[0][i],s2[0][i-1]);\n\t}\n\trep(i,1,m){\n\t\trep(j,1,n){\n\t\t\tf[i][j]=mul(j+1,f[i-1][j]);\n\t\t\tif(j>=2) add(f[i][j],mul(s2[i-1][j-1],pw2(j-1)));\n\t\t\ts2[i][j]=mul(f[i][j],mul(j,pw2(-j)));\n\t\t\tadd(s2[i][j],s2[i][j-1]);\n\t\t}\n\t}\n\tcout<<f[m][n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// IOI 2021\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define ends ' '\n#define die(x) return cout << x << endl, 0\n#define all(v) v.begin(), v.end()\n#define sz(x) (int)(x.size())\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) { cerr << ends << H; debug_out(T...); }\n#define debug(...) cerr << \"{\" << #__VA_ARGS__ << \"}:\", debug_out(__VA_ARGS__)\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n \n////////////////////////////////////////////////////////////////////\n \nconst int N = 5e3 + 5;\n\nint DP[N][N], S[N][N];\n\nint main() {\n \n\tios::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tmt19937 Rnd(time(0));\n\t\n\t// DP[i][j] = (j + 1) * DP[i - 1][j] + S[i][j];\n\t// S[i][j] = Sigma(k = 1, k < j, k * F[i - 1][j] * 2 ^ (j - k - 1));\n\t// S[i][j] = S[i][j - 1] * 2 + (j - 1) * DP[i - 1][j - 1]; \n\n\tfor (int i = 1; i < N; i++) DP[0][i] = DP[i][0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tS[i][j] = (2LL * S[i][j - 1] % MOD + 1LL * (j - 1) * DP[i - 1][j - 1] % MOD) % MOD;\n\t\t\tDP[i][j] = (1LL * (j + 1) * DP[i - 1][j] % MOD + S[i][j]) % MOD;\n\t\t}\n\t}\n\t\n\tint n, m; cin >> n >> m;\n\tcout << DP[n][m] << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n#include <bitset>\n#include <list>\n#include <cmath>\n\nauto& in = std::cin;\nauto& out = std::cout;\n#define all_range(C) std::begin(C), std::end(C)\nconst double PI = 3.141592653589793238462643383279502884197169399375105820974944;\n\ntemplate<typename Arithmetic, typename Integral>\nstd::enable_if_t< std::is_unsigned<Integral>::value, Arithmetic>\nipow(Arithmetic bace, Integral n)\n{\n\t//繰り返し二条法\n\tauto res = (Arithmetic)(1);\n\twhile (n > 0) {\n\t\tif (n & 1) res *= bace;\n\t\tbace *= bace;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nconstexpr bool is_prime(uint32_t N)\n{\n\tif (N <= 1) {\n\t\treturn false;\n\t}\n\tfor (size_t i = 2; i * i <= N; ++i)\n\t{\n\t\tif (N % i == 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\ntemplate <uint64_t MOD> class mint_base;\n//mint_base_base型用の累乗関数\ntemplate <uint64_t MOD> constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept;\n//mod計算を自動で行う整数テンプレートクラス\ntemplate <uint64_t MOD_ = 1000000007>\nclass mint_base\n{\npublic:\n\tstatic constexpr auto MOD = MOD_;\n\tstatic_assert(!(MOD <= 2), \"MOD cannot be below 2.\");\n\tstatic_assert(MOD <= (0xFFFFFFFFFFFFFFFF / 2), \"MOD is too big\");//加算してオーバーフローしない\n\tstatic_assert(MOD <= 0xFFFFFFFF, \"MOD is too big\");//乗算してオーバーフローしない\n\tconstexpr mint_base<MOD> operator+(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v += other;\n\t}\n\tconstexpr mint_base<MOD> operator-(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v -= other;\n\t}\n\tconstexpr mint_base<MOD> operator*(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v *= other;\n\t}\n\tconstexpr auto operator/(const mint_base<MOD>& other)const noexcept\n\t{\n\t\tauto v = *this;\n\t\treturn v /= other;\n\t}\n\tconstexpr mint_base<MOD>& operator+=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta += other.a;\n\t\tif (MOD <= a) { a -= MOD; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator-=(const mint_base<MOD>& other) noexcept\n\t{\n\t\tif (a >= other.a) {\n\t\t\ta -= other.a;\n\t\t}\n\t\telse {\n\t\t\ta = (a + MOD) - other.a;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator*=(const mint_base<MOD>& other) noexcept\n\t{\n#if 1\n\t\ta *= other.a;\n\t\ta %= MOD;\n#else\n\t\t//MOD <= (MAXUINT64 / 2)条件下\n\t\tuint64_t b = other.a, v = 0;\n\t\twhile (b > 0) {\n\t\t\tif (b & 1) {\n\t\t\t\tv += a;\n\t\t\t\tif (v >= MOD)v -= MOD;\n\t\t\t}\n\t\t\ta += a;\n\t\t\tif (MOD <= a)a -= MOD;\n\t\t\tb >>= 1;\n\t\t}\n\t\ta = v;\n#endif\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator/=(const mint_base<MOD>& other) noexcept\n\t{\n\t\treturn *this *= ~other;\n\t}\n\tconstexpr mint_base<MOD> operator+()const noexcept { return *this; }\n\tconstexpr mint_base<MOD> operator-()const noexcept\n\t{\n\t\treturn{ MOD - a, mod_value_tag{} };\n\t}\n\tconstexpr mint_base<MOD>& operator++() noexcept\n\t{\n\t\tif (MOD <= ++a) { a = 0; };\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD>& operator--() noexcept\n\t{\n\t\tif (a <= 0) { a = MOD; };\n\t\t--a;\n\t\treturn *this;\n\t}\n\tconstexpr mint_base<MOD> operator++(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t++* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator--(int) noexcept\n\t{\n\t\tauto tmp = *this;\n\t\t--* this;\n\t\treturn tmp;\n\t}\n\tconstexpr mint_base<MOD> operator~()const noexcept\n\t{\n\t\treturn ipow(*this, e_phi - 1);\n\t}\n\tconstexpr mint_base<MOD>& operator=(const mint_base<MOD>& other) noexcept\n\t{\n\t\ta = other.a;\n\t\treturn *this;\n\t}\n\tconstexpr explicit operator uint64_t()const noexcept\n\t{\n\t\treturn a;\n\t}\n\tconstexpr explicit operator unsigned()const noexcept\n\t{\n\t\treturn (unsigned)a;\n\t}\n\tstatic constexpr uint64_t getmod() noexcept\n\t{\n\t\treturn MOD;\n\t}\n\tconstexpr mint_base(uint64_t a_) noexcept :a(a_% MOD) {}\n\tconstexpr mint_base()noexcept : a(0) {}\n\tstruct mod_value_tag {};\n\tconstexpr mint_base(uint64_t a_, mod_value_tag) :a(a_) {}\nprivate:\n\tstatic constexpr uint64_t get_e_phi()noexcept {\n\t\t//オイラー値の導出\n\t\tuint64_t temp = MOD;\n\t\tuint64_t m_ = MOD;\n\t\tfor (uint64_t i = 2; i * i <= m_; ++i)\n\t\t{\n\t\t\tif (m_ % i == 0)\n\t\t\t{\n\t\t\t\ttemp = temp / i * (i - 1);\n\t\t\t\tfor (; m_ % i == 0; m_ /= i);\n\t\t\t}\n\t\t}\n\t\tif (m_ != 1)temp = temp / m_ * (m_ - 1);\n\t\treturn temp;\n\t}\n\tstatic constexpr uint64_t e_phi = get_e_phi();//オイラー値\n\tuint64_t a;\n};\n//mint_base型用の累乗関数\ntemplate<uint64_t MOD>constexpr mint_base<MOD> m_pow(mint_base<MOD> x, uint64_t n)noexcept\n{\n\tmint_base<MOD> res = 1;\n\twhile (n > 0)\n\t{\n\t\tif (n & 1)res *= x;\n\t\tx *= x;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//O(x)時間が必要のため、fact_set関数を推奨する。\ntemplate<uint64_t MOD>constexpr mint_base<MOD> fact(mint_base<MOD> x)noexcept\n{\n\tmint_base<MOD> res(1);\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t}\n\treturn res;\n}\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(x)時間が必要\ntemplate<uint64_t MOD>std::vector<mint_base<MOD>> fact_set(mint_base<MOD> x = mint_base<MOD>(-1))\n{\n\tmint_base<MOD> res(1);\n\tstd::vector<mint_base<MOD>> set((uint64_t)(x)+1);\n\tset[0] = 1;\n\tfor (uint64_t i = 1; i <= (uint64_t)x; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn res;\n}\n//mint_base型のstreamへの出力\ntemplate<uint64_t MOD> std::ostream& operator<<(std::ostream& os, mint_base<MOD> i)\n{\n\tos << (uint64_t)i;\n\treturn os;\n}\n//mint_base型のstreamからの入力\ntemplate<uint64_t MOD> std::istream& operator >> (std::istream& is, mint_base<MOD>& i)\n{\n\tuint64_t tmp;\n\tis >> tmp;\n\ti = tmp;\n\treturn is;\n}\ntypedef mint_base<> mint;\nnamespace mint_literal {\n\tconstexpr mint operator\"\"_mi(unsigned long long x)noexcept {\n\t\treturn mint(x);\n\t}\n}\nusing namespace mint_literal;\n//mint_baseの階乗計算\n//0からxまでの階乗を返す\n//O(N)\ntemplate<int32_t X, uint64_t MOD = mint::MOD>\n/*constexpr*/ std::array<mint_base<MOD>, X + 1> fact_set_c()\n{\n\tmint_base<MOD> res(1);\n\tstd::array<mint_base<MOD>, X + 1> set;\n\tset[0] = 1;\n\tfor (int32_t i = 1; i <= X; ++i)\n\t{\n\t\tres *= i;\n\t\tset[i] = res;\n\t}\n\treturn set;\n}\n\nint32_t N,M;\nmint pow2[50010];\n\nmint func(int n, int mmax);\nmint dp2[5010][5010];\nbool used2[5010][5010];\nmint func2(int n, int mmax)\n{\n\tif (mmax == 0) {\n\t\treturn 0_mi;\n\t}\n\tauto& memo = dp2[n][mmax];\n\tif (used2[n][mmax]) {\n\t\treturn memo;\n\t}\n\tused2[n][mmax] = true;\n\n\t//memo = func(n-1, mmax, m - 1) + 2_mi*func2(mmax - 1, m - 1);\n\n\t//memo = 0;\n\t//for (size_t i = 0; i <= mmax; i++)\n\t//{\n\t//\tmemo += pow2[mmax - i] * func(n - 1, i);\n\t//}\n\n\t//memo = 0;\n\t//for (int64_t i = mmax; i >= 1; --i)\n\t//{\n\t//\tmemo += pow2[mmax - i] * func(n - 1, i-1);\n\t//}\n\t//return memo;\n\treturn memo = func(n - 1, mmax-1) + 2_mi * func2(n, mmax - 1);\n}\n\n\nmint dp3[5010][5010];\nbool used3[5010][5010];\nmint func3(int n, int mmax)\n{\n\tif (mmax == 0) {\n\t\treturn 0_mi;\n\t}\n\tauto& memo = dp3[n][mmax];\n\tif (used3[n][mmax]) {\n\t\treturn memo;\n\t}\n\tused3[n][mmax] = true;\n\n\tmemo = 0;\n\tfor (size_t i = mmax; i >= 1; --i)\n\t{\n\t\tmemo += func(n-1, i) * func2(n, mmax-i);\n\t}\n\treturn memo;\n\t//return memo = func(n - 1, mmax) * func2(n, 0) + func3(n, mmax - 1);\n}\n\n\n\nmint dp[5010][5010];\nbool used[5010][5010];\nmint func(int n,int mmax)\n{\n\tif (mmax == 1) {\n\t\treturn pow2[n];\n\t}\n\tif (n == 1) {\n\t\treturn pow2[mmax];\n\t}\n\t//if (n == 2) {\n\t//\treturn pow2[2* mmax];\n\t//}\n\n\tauto& memo = dp[n][mmax];\n\tif (used[n][mmax]) {\n\t\treturn memo;\n\t}\n\tused[n][mmax] = true;\n\n\tmemo = 0;\n\treturn memo = 2_mi * func(n-1,mmax) +\n\t\t\t\t  2_mi * func(n - 1, 1) * func(n - 1, mmax - 1) +\n\t\tfunc3(n, mmax);\n}\n\nint main()\n{\n    using std::endl;\n    in.sync_with_stdio(false);\n    out.sync_with_stdio(false);\n    in.tie(nullptr);\n    out.tie(nullptr);\n\n\tpow2[0] = 1;\n\tfor (size_t i = 1; i < 50010; i++)\n\t{\n\t\tpow2[i] = pow2[i - 1] + pow2[i - 1];\n\t}\n\n    in >> N >> M;\n\tout << func(N, M) << endl;\n\n\n    return 0;\n}\n#endif\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\nsigned main() {\n\tomajinai;\n\tint p = p1;\n\tint n, m; cin >> n >> m;\n\tvvel dp(n + 1, vel(m + 1, 0));\n\tfor (int i = 1; i <= m; i++) {\n\t\tdp[1][i] = modpow(2, i, p);\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tdp[i][j] += sum;\n\t\t\tdp[i][j] += dp[i - 1][j] * (j + 1);\n\t\t\tdp[i][j] %= p;\n\t\t\tsum *= 2;\n\t\t\tsum += dp[i - 1][j] * j;\n\t\t\tsum %= p;\n\t\t}\n\t}\n\tcout << dp[n][m] << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 1000000007\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M;\n\nbool test(int x, int y)\n{\n\tfor (int i = N - 1; i >= 0; --i) {\n\t\tif ((x & (1 << i)) && !(y & (1 << i))) {\n\t\t\treturn ((x ^ y) & ((1 << i) - 1)) == 0;\n\t\t}\n\t}\n\treturn true;\n}\n\ni64 modpow(i64 a, i64 p)\n{\n\tif (p == 0) return 1;\n\ti64 t = modpow(a, p / 2);\n\tt = t * t % MOD;\n\tif (p & 1) t = t * a % MOD;\n\treturn t;\n}\ni64 dp[5050][5050];\ni64 inv2[5050], pows[5050];\n\ni64 solve2()\n{\n\ti64 tbl[2][5050];\n\ti64 acc[5050];\n\tint t = 0;\n\n\tfor (int i = 0; i <= M; ++i) tbl[t][i] = 1;\n\tfor (int i = 1; i <= N; ++i) {\n\t\tfor (int j = 0; j <= M; ++j) tbl[1 - t][j] = 0;\n\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\tacc[j] = tbl[t][j] * j % MOD * inv2[j + 1] % MOD;\n\t\t}\n\t\tfor (int j = 1; j <= M; ++j) ADD(acc[j], acc[j - 1]);\n\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\ttbl[1 - t][j] = (j > 0 ? acc[j - 1] : 0) * pows[j] % MOD;\n\t\t\tADD(tbl[1 - t][j], tbl[t][j] * (j + 1));\n\t\t}\n\t\tt = 1 - t;\n\t}\n\treturn tbl[t][M];\n}\n\ni64 solve()\n{\n\tfor (int i = 0; i <= N; ++i) {\n\t\tfor (int j = 0; j <= M; ++j) {\n\t\t\tif (i == 0 || j == 0) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti64 tmp = 0;\n\t\t\tADD(tmp, dp[i - 1][j] * (j + 1));\n\t\t\tfor (int d = 2; d <= j; ++d) {\n\t\t\t\tADD(tmp, dp[i - 1][j - d + 1] * (j - d + 1) % MOD * modpow(2, d - 2));\n\t\t\t}\n\t\t\tdp[i][j] = tmp;\n\t\t}\n\t}\n\treturn dp[N][M];\n}\n\nint main()\n{\n\tpows[0] = inv2[0] = 1;\n\tfor (int i = 1; i <= 5000; ++i) {\n\t\tpows[i] = pows[i - 1] * 2 % MOD;\n\t\tinv2[i] = modpow(pows[i], MOD - 2);\n\t}\n\tscanf(\"%d%d\", &N, &M);\n\n\tprintf(\"%lld\\n\", solve2()); return 0;\n\n\tfor (int x = 0; x < (1 << N); ++x) {\n\t\tfor (int y = 0; y < (1 << N); ++y) {\n\t\t\tbool isok = true;\n\t\t\tfor (int m = 0; m < (1 << N); ++m) {\n\t\t\t\tint xx = x & m, yy = y & m;\n\t\t\t\tif (xx > yy && __builtin_popcount(xx ^ yy) >= 2) isok = false;\n\t\t\t}\n\t\t\tif (isok != test(x, y)) puts(\"><\");\n//\t\t\tif (isok) printf(\"%d %d\\n\", x, y);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nconst int MOD = 1e9 + 7;\nconst int N = 5030;\n\nusing namespace std;\n\nlong long dp[N][N];\n\nint main()\n{\n  int n, m;\n  cin >> n >> m;\n  dp[1][0] = 1;\n  for (int j = 1; j <= m; j++)\n  {\n    dp[1][j] = dp[1][j - 1] * 2 % MOD;\n  }\n  for (int i = 2; i <= n; i++)\n  {\n    long long w = 0;\n    for (int j = 0; j <= m; j++)\n    {\n      dp[i][j] = (dp[i - 1][j] * (j + 1) + w) % MOD;\n      w = 2 * w % MOD;\n      w = (w + dp[i - 1][j] * j) % MOD;\n    }\n  }\n  cout << dp[n][m];\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 5002\nint n;\nint m;\nint dp[MAX][MAX];\nbool use[MAX][MAX];\nint im[MAX][MAX];\ninline int dfs(int a,int b){\n\tif(b==0)return 0;\n\tif(a==n)return 1;\n\tif(use[a][b])return dp[a][b];\n\tuse[a][b]=true;\n\taddto(dp[a][b],mul(1+b,dfs(a+1,b)));\n\t/*for(int imi=2;imi<=b;imi++){\n\t\t//(b-1)*1*dfs(a+1,b-1)+(b-2)*2*dfs(a+1,b-2)+4*dfs(a+1,b-3)...dfs(a+1,1)\n\t\taddto(dp[a][b],mul(b-imi+1,mul(ppow(2,imi-2),dfs(a+1,b-imi+1))));\n\t}*/\n\taddto(dp[a][b],mul(im[a+1][b-1],ppow(ppow(2,(m-b+1)),MOD-2)));\n\treturn dp[a][b];\n}\nlong long int dp[MAX][MAX];\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=n;i>=0;i--){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tdfs(i,j);\n\t\t}\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tim[i][j]=mul(ppow(2,m-j),dp[i][j]);\n\t\t\taddto(im[i][j],im[i][j-1]);\n\t\t}\n\t}\n\tcout<<dfs(0,m)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate<int MOD>\nstruct ModInt {\n   using Mint = ModInt;\n   int val;\n   ModInt(ll __val = 0) { fix(__val % MOD + MOD); }\n   Mint& fix(int __val) { val = __val; if (val >= MOD) val -= MOD; return *this; }\n   explicit operator int() { return val; }\n   Mint operator + (const Mint &mt) const { return Mint().fix(val + mt.val); }\n   Mint operator - (const Mint &mt) const { return Mint().fix(val - mt.val + MOD); }\n   Mint operator * (const Mint &mt) const { return Mint().fix(ll(val) * mt.val % MOD + MOD); }\n   Mint& operator += (const Mint &mt) { return *this = *this + mt; }\n   Mint& operator -= (const Mint &mt) { return *this = *this - mt; }\n   Mint& operator *= (const Mint &mt) { return *this = *this * mt; }\n   Mint pow(int y) const {\n      Mint x = *this;\n      Mint ans(1);\n      for (; y > 0; y >>= 1, x *= x) {\n         if (y & 1) ans *= x;\n      }\n      return ans;\n   }\n   Mint operator -() const { return Mint().fix(MOD - val); }\n   Mint inv() const { return pow(MOD - 2); }\n   Mint operator / (const Mint &mt) const { return *this * mt.inv(); }\n   Mint& operator /= (const Mint &mt) const { return *this / mt; }\n   friend ostream& operator<<(ostream& os, const Mint& mt) { return os << mt.val; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nint main() {\n   ios_base::sync_with_stdio(false); cin.tie(nullptr);\n   int N, M;\n   cin >> N >> M;\n   vector<Mint> dp(M + 1);\n   dp[M] = 1;\n   for (int b = N - 1; b >= 0; --b) {\n      vector<Mint> ndp(M + 1);\n      Mint tot = 0;\n      for (int i = M; i >= 0; --i) {\n         ndp[i] = dp[i] * (i + 1) + tot * i;\n         tot = tot + tot + dp[i];\n      }\n      dp = move(ndp);\n   }\n   Mint ans = 0;\n   for (auto v : dp) ans += v;\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n//////////////////////////////////////\nint main() {\n\tll N, M;\n\tcin >> N >> M;\n\n\tvvmint dp(N + 1, vmint(M, 0));\n\tdp[0][0] = 1;\n\n\trepn(i, N) {\n\t\tvmint pdp(M,0);\n\t\trepn(j, M - 1) {\n\t\t\tpdp[j] = pdp[j - 1] * 2 + dp[i - 1][j];\n\t\t}\n\t\tvmint rdp(M, 0);\n\t\tfor (ll j = 2; j < M; j++) {\n\t\t\trdp[j] = rdp[j - 1] * 2 + pdp[j - 1] + dp[i - 1][j-1];\n\t\t}\n\n\t\tdp[i][0] = 1;\n\n\t\trepn(j, M - 1) {\n\t\t\tdp[i][j] = pw(j + 2, i - 1) * pw(2, j - 1);\n\t\t\tcout << rdp[j] << endl;\n\t\t\tdp[i][j] += rdp[j];\n\t\t\tdp[i][j] += dp[i - 1][j] * 2;\n\n\t\t\tcout << i << \" \" << j << \" \" << dp[i][j] << endl;\n\t\t}\n\n\t}\n\n\tmint ans = pw(M + 1, N);\n\trepn(j, M - 1)ans += dp[N][j] * (M - j);\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define REP(i, n) for(int i = 0;i < (n);i++)\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint inf=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-10;\ntemplate <class T,class U>bool chmin(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool chmax(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nint main(void){\n\tstatic llint dp[5001]={};\n\tstatic llint ep[5001]={};\n\tint i,j,n,m;cin>>n>>m;\n\tdp[m]=1;\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=0;j<=m;j++){ep[j]=dp[j]*(j+1);}\n\t\t\tfor(j=m;j>0;j--){dp[j-1]+=dp[j]*2;dp[j-1]%=mod;ep[j-1]+=dp[j]*(j-1);}\n\t\tfor(j=0;j<=m;j++){dp[j]=ep[j]%mod;}\n\t}\n\tllint ans=0;\n\tfor(j=0;j<=m;j++){ans+=dp[j];}\n\tcout<<ans%mod<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 5050, P = 1000000007;\nint n, m, f[maxn][maxn];\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    fill(f[0] + 1, f[0] + m + 1, 1);\n    for (int i = 1; i <= n; i++) {\n        int sum = 0;\n        for (int j = 1; j <= m; j++) {\n            f[i][j] = (1LL * (j + 1) * f[i - 1][j] + sum) % P;\n            sum = (2LL * sum + 1LL * j * f[i - 1][j]) % P;\n        }\n    }\n    printf(\"%d\\n\", f[n][m]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint dp[MAXN][MAXN];\nint main() {\n\tint n, m; read(n), read(m);\n\tfor (int i = 1; i <= m; i++)\n\t\tdp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tupdate(dp[i][j], 1ll * dp[i - 1][j] * (j + 1) % P);\n\t\t\tupdate(dp[i][j], sum);\n\t\t\tsum = (2ll * sum + 1ll * dp[i - 1][j] * j) % P;\n\t\t}\n\t}\n\t\n\tcout << dp[n][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Modular {\nprivate:\n    static long long MOD;\n    // a * x + b * y == g; g == gcd(x, y)\n    static void extended_gcd(long long x, long long y, long long& a, long long& b, long long& g) {\n        if (x < 0) {\n            extended_gcd(-x, y, a, b, g);\n            a = -a;\n        } else if (y < 0) {\n            extended_gcd(x, -y, a, b, g);\n            b = -b;\n        } else if (x > y) {\n            extended_gcd(y, x, b, a, g);\n        } else if (x == 0) {\n            a = 0;\n            b = 1;\n            g = y;\n        } else {\n            long long a1 = -1;\n            long long b1 = -1;\n            extended_gcd(y % x, x, a1, b1, g);\n            b = a1;\n            a = b1 - a1 * (y / x);\n        }\n    }\n    static long long mod_inv(long long x, long long m) {\n        long long a = 0;\n        long long b = 0;\n        long long g = 0;\n        extended_gcd(x, m, a, b, g);\n        a = ((a % m) + m) % m;\n        return a;\n    }\npublic:\n    long long value;\n    Modular(): value(0) {}\n    explicit Modular(long long v): value(normalize(v)) {}\n    static long long normalize(long long v) {\n        v = v % MOD;\n        if (v < 0)\n            v += MOD;\n        return v;\n    }\n\n    bool operator==(const Modular& a) const {return value == a.value;}\n    bool operator<(const Modular& a) const { return value < a.value;}\n    Modular operator+=(const Modular& a) {value = normalize(value + a.value); return *this;}\n    Modular operator-=(const Modular& a) {value = normalize(value - a.value); return *this;}\n    Modular operator*=(const Modular& a) {value = normalize(value * a.value); return *this;}\n    Modular operator/=(const Modular& a) {return (*this) *= a.inv();}\n\n    Modular operator++() {value = normalize(value + 1); return *this;}\n    Modular operator--() {value = normalize(value - 1); return *this;}\n    Modular operator++(int) {Modular tmp = *this; value = normalize(value + 1); return tmp;}\n    Modular operator--(int) {Modular tmp = *this; value = normalize(value - 1); return tmp;}\n\n    template <typename T>\n    Modular operator+=(const T& a) {value = normalize(value + a); return *this;}\n    template <typename T>\n    Modular operator-=(const T& a) {value = normalize(value - a); return *this;}\n    template <typename T>\n    Modular operator*=(const T& a) {value = normalize(value * a); return *this;}\n\n    Modular inv() const {return Modular(mod_inv(value, MOD));}\n    Modular pow(long long p) const {  // this doesn't assume prime MOD\n        Modular res(1);\n        Modular sq(value);\n        while (p > 0) {\n            if (p % 2 == 1) {\n                res *= sq;\n            }\n            sq *= sq;\n            p /= 2;\n        }\n        return res;\n    }\n\n    static void set_mod(long long mod) {MOD = mod;}\n};\nlong long Modular::MOD = 0;\n\nModular operator+(const Modular& a, const Modular& b) {Modular c(a); return c += b;}\ntemplate<typename T>\nModular operator+(const Modular& a, const T& b) {return a + Modular(b);}\ntemplate<typename T>\nModular operator+(const T& a, const Modular& b) {return Modular(a) + b;}\n\nModular operator-(const Modular& a, const Modular& b) {Modular c(a); return c -= b;}\ntemplate<typename T>\nModular operator-(const Modular& a, const T& b) {return a - Modular(b);}\ntemplate<typename T>\nModular operator-(const T& a, const Modular& b) {return Modular(a) - b;}\n\nModular operator*(const Modular& a, const Modular& b) {Modular c(a); return c *= b;}\ntemplate<typename T>\nModular operator*(const Modular& a, const T& b) {return a * Modular(b);}\ntemplate<typename T>\nModular operator*(const T& a, const Modular& b) {return Modular(a) * b;}\n\nModular operator/(const Modular& a, const Modular& b) {Modular c(a); return c /= b;}\ntemplate<typename T>\nModular operator/(const Modular& a, const T& b) {return a / Modular(b);}\ntemplate<typename T>\nModular operator/(const T& a, const Modular& b) {return Modular(a) / b;}\n\nstd::ostream& operator<<(std::ostream& os, const Modular& m) {\n    return os << m.value;\n}\n\nstd::istream& operator>>(std::istream& is, Modular& m) {\n    return is >> m.value;\n}\nint main() {\n    Modular::set_mod(1000000007);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<Modular>> dp(n + 1, vector<Modular>(m + 1));\n    for (int i = 0; i <= m; ++i) {\n        dp[0][i] = Modular(1);\n        if (i == 0)\n            dp[1][i] = Modular(1);\n        else\n            dp[1][i] = 2 * dp[1][i - 1];\n    }\n    Modular two(2);\n    for (int i = 2; i <= n; ++i) {\n        Modular s;\n        for (int j = 0; j <= m; ++j) {\n            dp[i][j] = (j + 1) * dp[i - 1][j];\n//            for (int p = 2; p <= j; ++p) {\n//                dp[i][j] += two.pow(p - 2) * (j - p + 1) * dp[i - 1][j - p + 1];\n//            }\n            if (j >= 2)\n                s += ((j - 1) * dp[i - 1][j - 1]) / two.pow(j);\n            dp[i][j] += s * two.pow(j);\n        }\n    }\n    cout << dp[n][m] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int max_n = 5055, mod = 1000000007;\n\nint mul(int x, int y) {\n    return 1LL * x * y % mod;\n}\n\nint power(int a, int b) {\n    if (b == 0) {\n        return 1 % mod;\n    }\n    if (b % 2 == 0) {\n        return power(mul(a, a), b / 2);\n    }\n    return mul(a, power(a, b - 1));\n}\n\nint inv(int x) {\n    return power(x, mod - 2);\n}\n\nint n, m, dp[max_n][max_n], pw[max_n], coef[max_n], rpw[max_n];\nint sum[max_n][max_n];\n\nbool get_bit(int mask, int pos) {\n    return (mask >> pos) & 1;\n}\n\nvoid prec(int i) {\n    for (int j = 0; j < max_n; ++j) {\n        sum[i][j] = mul(dp[i][j], pw[j]);\n        if (j) {\n            sum[i][j] += sum[i][j - 1];\n            sum[i][j] %= mod;\n        }\n    }\n}\n\nint solve(int n, int m) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][m] = 1;\n    /*for (int i = 0; i < n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i + 1][j] += mul(j + 1, dp[i][j]);\n            dp[i + 1][j] %= mod;\n            for (int len = 2; len <= j; ++len) {\n                dp[i + 1][j - len + 1] += mul(dp[i][j], mul(pw[len - 2], j - len + 1));\n                dp[i + 1][j - len + 1] %= mod;\n            }\n        }\n    }*/\n    prec(0);\n    for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= m; ++j) {\n            dp[i][j] = mul(j + 1, dp[i - 1][j]);\n            int add = 0;\n            add = sum[i - 1][m] - sum[i - 1][j];\n            add += mod;\n            add %= mod;\n            add = mul(add, rpw[j + 1]);\n            for (int len = 2; j + len - 1 <= m; ++len) {\n                break;\n                add += mul(dp[i - 1][j + len - 1], pw[len - 2]);\n                add %= mod;\n            }\n            dp[i][j] += mul(add, j);\n            dp[i][j] %= mod;\n        }\n        prec(i);\n    }\n    return accumulate(dp[n] + 1, dp[n] + m + 1, 0LL) % mod;\n}\n\nint main() {\n    //freopen(\"input.txt\", \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    pw[0] = 1;\n    rpw[0] = 1;\n    const int r2 = inv(2);\n    for (int i = 1; i < max_n; ++i) {\n        pw[i] = mul(2, pw[i - 1]);\n        rpw[i] = mul(r2, rpw[i - 1]);\n    }\n    cin >> n >> m;\n    cout << solve(n, m) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 5005\n#define MOD 1000000007\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll dp[SIZE];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i=1;i<=m;i++) dp[i]=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll sum=0;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tll nd=sum+dp[j]*(ll) (j+1);\n\t\t\tnd%=MOD;\n\t\t\tsum*=2LL;\n\t\t\tsum+=dp[j]*(ll) j%MOD;\n\t\t\tsum%=MOD;\n\t\t\tdp[j]=nd;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[m]);\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\n\n\n\ntemplate <class Mint>\nV<Mint> powTable(int n, Mint x) {\n    V<Mint> table(n + 1);\n    table[0] = Mint(1);\n    for (int i = 1; i <= n; i++) {\n        table[i] = table[i - 1] * x;\n    }\n    return table;\n}\n\ntemplate<class Mint>\nstruct Comb {\n    int max_n;\n    V<Mint> fact, ifact;\n    Comb() {}\n    Comb(int n) : max_n(n) {\n        fact = ifact = V<Mint>(n + 1);\n        fact[0] = Mint(1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;\n    }\n\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        assert(0 <= k && k <= n && n <= max_n);\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    // n個の区別出来ないボールをk個の箱に入れる入れ方\n    Mint H(int n, int k) {\n        if (n == 0 && k == 0) return Mint(1);\n        return C(n + k - 1, n);\n    }\n};\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\n\n\n\n// bit op\nint popcnt(uint x) { return __builtin_popcount(x); }\nint popcnt(ull x) { return __builtin_popcountll(x); }\nint bsr(uint x) { return 31 - __builtin_clz(x); }\nint bsr(ull x) { return 63 - __builtin_clzll(x); }\nint bsf(uint x) { return __builtin_ctz(x); }\nint bsf(ull x) { return __builtin_ctzll(x); }\n\n\nstruct DynamicModInt {\n    using M = DynamicModInt;\n\n  private:\n    static uint MD;\n    static ull iMD;\n    uint v = 0;\n\n  public:\n    static void set_mod(uint _MD) {\n        assert(2 <= _MD);\n        MD = _MD;\n        iMD = ull(-1) / _MD + 1;\n    }\n    DynamicModInt() {}\n    DynamicModInt(ll _v) { set_v(uint(_v % MD + MD)); }\n    uint val() const { return v; }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    /*\n    u32 fact_fast(u32 n, u32 mod) {\n      u64 imod = u64(-1) / mod + 1; // ceil((1<<64) / mod);\n      auto mul_mod = [&](u32 a, u32 b) {\n        u64 c = u64(a) * b;\n        u64 d = (__uint128_t(c) * imod) >> 64;\n        u64 e = (c - d * mod + mod);\n        //return e;\n        return (e < mod) ? e : e - mod;\n      };\n      u32 ret = 1;\n      for (int i = 1; i <= n; ++i) ret = mul_mod(ret, i);\n      return ret;\n    }\n    */\n    M operator*(const M& r) const {\n        ull c = ull(v) * r.v;\n        ull d = (__uint128_t(c) * iMD) >> 64;\n        return M().set_v(uint(c - d * MD + MD));\n    }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const {\n        pair<uint, ll> p = {MD, 0}, q = {v, 1};\n        while (q.first) {\n            uint t = p.first / q.first;\n            p.first -= t * q.first;\n            p.second -= t * q.second;\n            swap(p, q);\n        }\n        return M(p.second);\n    }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\nuint DynamicModInt::MD;\null DynamicModInt::iMD;\nusing Mint = DynamicModInt;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    Mint::set_mod(TEN(9) + 7);\n    V<Mint> p2 = powTable(10000, Mint(2));\n    int n, m;\n    sc.read(n, m);\n\n    V<Mint> dp(m + 1);\n    dp[m] = Mint(1);\n\n    for (int ph = 0; ph < n; ph++) {\n        V<Mint> ndp(m + 1);\n        Mint sm = 0;\n        for (int j = m; j >= 1; j--) {\n            ndp[j] = Mint(j) * sm + dp[j] * Mint(j + 1);\n            sm *= Mint(2);\n            sm += dp[j];\n        }\n        dp = ndp;\n/*        for (int j = 1; j <= m; j++) {\n            for (int k = 1; k < j; k++) {\n                // j -> k\n                dp[k] += dp[j] * Mint(k) * p2[j - k - 1];\n            }\n            dp[j] *= Mint(j + 1);\n        }*/\n    }\n           ;\n    Mint sm = 0;\n    for (auto x: dp) {\n        sm += x;\n    }\n    pr.writeln(sm.val());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline void read (int &x) {\n\tchar ch = getchar(); x = 0;\n\twhile (!isdigit(ch)) ch = getchar();\n\twhile (isdigit(ch)) x = x * 10 + ch - 48, ch = getchar(); \n} const int N = 5038, mod = 1e9 + 7; int f[N][N];\nsigned main() {\n\tint n, m; read (n), read (m);\n\tfor (int i = 1; i <= n; ++i) f[0][i] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint sum = 0;\n\t\tfor (int j = 1; j <= m; ++j) {\n\t\t\tf[i][j] = (sum + (j + 1) * f[i - 1][j]) % mod;\n\t\t\tsum = (sum * 2 + j * (f[i - 1][j])) % mod;\n\t\t}\n\t} return printf (\"%lld\\n\", f[n][m]), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit unsigned int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 1e9 + 7;\nusing mod_int = _m_int<MOD>;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<mod_int> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++) {\n        mod_int sum = 0;\n\n        for (int m = 0; m <= M; m++) {\n            mod_int product = m * dp[m];\n            dp[m] += sum + product;\n            sum = sum + sum + product;\n        }\n    }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\n\nusing M = Mint<int>;\nconst int MAX = 5050;\nM po[MAX],op[MAX];\n\n\nM dfs(int h,int w);\n\nM dp2[MAX][MAX];\nint used2[MAX][MAX]={};\nM sum(int h,int w){\n  M &res=dp2[h][w];\n  if(used2[h][w]) return res;\n  used2[h][w]=1;\n\n  res=M(0);\n  if(w>0) res+=sum(h,w-1);\n  res+=dfs(h,w)*op[w+1]*M(w);\n  return res;\n}\n\nM dp[MAX][MAX];\nint used[MAX][MAX]={};\nM dfs(int h,int w){\n  // cout<<h<<' '<<w<<endl;\n  M &res=dp[h][w];\n  if(used[h][w]) return res;\n  used[h][w]=1;\n\n  assert(h>=0 and w>=0);\n  if(h==0 or w==0) return res=M(1);\n  if(w==1) return res=po[h];\n  if(h==1) return res=po[w];\n\n  res=M(0);\n\n  //  (j)  (w-j)\n  // 0...0/1...1\n\n  /*\n    for(int j=0;j<=w;j++)\n    res+=dfs(h-1,j)*dfs(h-1,w-j);\n  */\n  res+=dfs(h-1,w)*M(w+1);\n\n  //  (j) (1)(?)(1)(k)\n  // 0...0/1?????0(1*)\n  /*\n    for(int j=0;j+1<w;j++)\n    for(int k=0;j+1+k<w;k++)\n    res+=dfs(h-1,j+1+k)*po[w-(j+1+k+1)];\n  */\n\n  // j+k -> j\n  /*\n    for(int j=0;j+1<w;j++)\n    res+=dfs(h-1,j+1)*po[w-(j+1+1)]*M(j+1);\n  */\n  // res+=dfs(h-1,j+1)/po[j+1+1]*M(j+1)*po[w];\n  res+=sum(h-1,w-1)*po[w];\n  return res;\n};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m;\n  cin>>n>>m;\n  po[0]=op[0]=M(1);\n  for(int i=0;i<n+m;i++) po[i+1]=po[i]*M(2);\n  for(int i=0;i<n+m;i++) op[i+1]=op[i]*M(2).inv();\n\n  cout<<dfs(n,m)<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define SZ(x) ((int)x.size())\n#define ALL(x) x.begin(),x.end()\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> T gcd(T a, T b){return !b?a:gcd(b,a%b);}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 5050, mo = 1e9+7, inv2 =(mo+1)/2;\nconst ll MOD=7LL*mo*mo;\ninline void add(int &x, int y){x=x+y<mo?x+y:x+y-mo;}\ninline void sub(int &x, int y){x=x-y>=0?x-y:x-y+mo;}\ninline int power(int a, int n) {\n\tint res=1;\n\twhile (n) {\n\t\tif (n&1) res=1LL*res*a%mo;\n\t\ta=1LL*a*a%mo; n>>=1;\n\t}\n\treturn res;\n}\nint n,m,f[N][N],mi[N],ni[N];\nint main() {\n\tn=5000;mi[0]=ni[0]=1;rep(i,1,n)mi[i]=2*mi[i-1]%mo,ni[i]=power(mi[i],mo-2);\n\tread(n);read(m);\n\trep(i,1,m)f[0][i]=1;\n\trep(i,1,n){\n\t\tint cur=0;\n\t\trep(j,1,m){\n\t\t\tf[i][j]=1ll*f[i-1][j]*(j+1)%mo;\n\t\t\tadd(f[i][j],1ll*cur*mi[j-1]%mo);\n\t\t\tcur=(cur+1ll*f[i-1][j]*j%mo*ni[j])%mo;\n\t\t}\n\t}\n\tcout<<f[n][m];\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\nint ipow2[5555];\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(5555);\n\tfor(int i=0;i<5011;i++) ipow2[i]=inverse(pow2[i]);\n\tint n,m; cin>>n>>m;\n\tvi old(m+1,0);\n\told[m]=1;\n\tfor(int z=1;z<=n;z++)\n\t{\n\t\tvi nw(m+1,0);\n\t\tvi suf(m+2,0);\n\t\tfor(int i=m;i>=1;i--)\n\t\t{\n\t\t\tsuf[i]=add(suf[i+1],mult(pow2[i],old[i]));\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tnw[i]=add(nw[i],mult(old[i],i+1));\n\t\t\tnw[i]=add(nw[i],mult(mult(i,ipow2[i+1]),suf[i+1]));\n\t\t}\n\t\told=nw;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=m;i++) radd(ans,old[i]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll mod=1e9+7;\nint n,m; \nll  dp[5005]; \nint main(){\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;++i){\n\t\tdp[i]=1;\n\t}\n\tfor(int i=0;i<n;++i){\n\t\tll sum=0;\n\t\tfor(int j=1;j<=m;++j){\n\t\t\tll val=sum+dp[j]*1ll*(j+1);\n\t\t\tval%=mod;\n\t\t\tsum*=2;\n\t\t\tsum+=dp[j]*1ll*j%mod;\n\t\t\tsum%=mod;\n\t\t\tdp[j]=val;\n\t\t}\n\t}\n\tcout<<dp[m]<<'\\n';\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<complex>\n#include<numeric>\nusing namespace std;\n#define MOD 1000000007\n#define MOD2 998244353\n#define PRIM 3\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\n#define PI 3.1415926535897932384626433832795028\ntypedef long long Int;\ntypedef pair<Int, Int> P;\ntypedef long double Real;\ntypedef complex<Real> CP;\n\nInt _pow2[110000];\nInt *pow2 = _pow2 + 55000;\nInt n, m;\nInt dp[5500][5500];\nInt dp2[5500][5500];\nint main(){\n    cin >> n >> m;\n    pow2[0] = 1;\n    for(int i = 1;i < 54000;i++){\n        pow2[i] = pow2[i-1] * 2 % MOD;\n        pow2[-i] = pow2[1-i] * ((MOD+1) / 2) % MOD;\n    }\n    for(int i = 0;i <= n;i++){\n        for(int j = 0;j <= m;j++){\n            if(i == 0){\n                dp[i][j] = 1;\n            }\n            else{\n                dp[i][j] = dp[i-1][j] * (j+1) % MOD;\n                if(j >= 2)\n                    (dp[i][j] += dp2[i-1][j-1] * pow2[j-1] % MOD) %= MOD;\n            }\n            if(j)\n                (dp2[i][j] = (dp2[i][j-1] + dp[i][j] * j % MOD * pow2[-j] % MOD) % MOD) %= MOD;\n        }\n    }\n    cout << dp[n][m] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma region preprocessor\n#ifdef LOCAL\n//*\n    #define _GLIBCXX_DEBUG  // gcc\n/*/\n    #define _LIBCPP_DEBUG 0 // clang\n//*/\n    #define __clock__\n    // #define __buffer_check__\n#else\n    #pragma GCC optimize(\"Ofast\")\n    // #define __buffer_check__\n    // #define NDEBUG\n#endif\n#define __precision__ 15\n#define iostream_untie true\n#include <bits/stdc++.h>\n#include <ext/rope>\n#define __all(v) std::begin(v), std::end(v)\n#define __rall(v) std::rbegin(v), std::rend(v)\n#define __popcount(n) __builtin_popcountll(n)\n#define __clz32(n) __builtin_clz(n)\n#define __clz64(n) __builtin_clzll(n)\n#define __ctz32(n) __builtin_ctz(n)\n#define __ctz64(n) __builtin_ctzll(n)\n\n#ifdef __clock__\n    #include \"clock.hpp\"\n#else\n    #define build_clock() ((void)0)\n    #define set_clock() ((void)0)\n    #define get_clock() ((void)0)\n#endif\n\n#ifdef LOCAL\n    #include \"dump.hpp\"\n    #define mesg(str) std::cerr << \"[ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ]  \" << str << \"\\n\"\n#else\n    #define dump(...) ((void)0)\n    #define mesg(str) ((void)0)\n#endif\n#pragma endregion // preprocessor\n\n#pragma region std-overload\nnamespace std\n{\n    // hash\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T, U>> { size_t operator()(pair<T, U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1> struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class... T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    // iostream\n    template <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) { return is >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<<(ostream &os, const pair<T, U> &p) { return os << p.first << ' ' << p.second; }\n    template <class tuple_t, size_t index> struct tupleis { static istream &apply(istream &is, tuple_t &t) { tupleis<tuple_t, index - 1>::apply(is, t); return is >> get<index>(t); } };\n    template <class tuple_t> struct tupleis<tuple_t, SIZE_MAX> { static istream &apply(istream &is, tuple_t &t) { return is; } };\n    template <class... T> istream &operator>>(istream &is, tuple<T...> &t) { return tupleis<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is, t); }\n    template <> istream &operator>>(istream &is, tuple<> &t) { return is; }\n    template <class tuple_t, size_t index> struct tupleos { static ostream &apply(ostream &os, const tuple_t &t) { tupleos<tuple_t, index - 1>::apply(os, t); return os << ' ' << get<index>(t); } };\n    template <class tuple_t> struct tupleos<tuple_t, 0> { static ostream &apply(ostream &os, const tuple_t &t) { return os << get<0>(t); } };\n    template <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) { return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os, t); }\n    template <> ostream &operator<<(ostream &os, const tuple<> &t) { return os; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    istream& operator>>(istream& is, Container &cont) { for(auto&& e : cont) is >> e; return is; }\n    template <class Container, typename Value = typename Container::value_type, enable_if_t<!is_same<decay_t<Container>, string>::value, nullptr_t> = nullptr>\n    ostream& operator<<(ostream& os, const Container &cont) { bool flag = 1; for(auto&& e : cont) flag ? flag = 0 : (os << ' ', 0), os << e; return os; }\n} // namespace std\n#pragma endregion // std-overload\n\n#pragma region executive-setting\nnamespace setting\n{\n    using namespace std;\n    using namespace chrono;\n    system_clock::time_point start_time, end_time;\n    long long get_elapsed_time() { end_time = system_clock::now(); return duration_cast<milliseconds>(end_time - start_time).count(); }\n    void print_elapsed_time() { cerr << \"\\n----- Exec time : \" << get_elapsed_time() << \" ms -----\\n\\n\"; }\n    void buffer_check() { char bufc; if(cin >> bufc) cerr << \"\\n\\033[1;35mwarning\\033[0m: buffer not empty.\\n\"; }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie) ios::sync_with_stdio(false), cin.tie(nullptr);\n            cout << fixed << setprecision(__precision__);\n    #ifdef stderr_path\n            freopen(stderr_path, \"a\", stderr);\n    #endif\n    #ifdef LOCAL\n            cerr << fixed << setprecision(__precision__) << boolalpha << \"\\n----- stderr at LOCAL -----\\n\\n\";\n    #endif\n    #ifdef __clock__\n            start_time = system_clock::now();\n            atexit(print_elapsed_time);\n    #endif\n    #ifdef __buffer_check__\n            atexit(buffer_check);\n    #endif\n        }\n    } __setupper; // struct setupper\n} // namespace setting\n#pragma endregion // executive-setting\n\n#pragma region fucntion-utility\n// lambda wrapper for recursive method.\ntemplate <class lambda_type>\nclass make_recursive\n{\n    lambda_type func;\npublic:\n    make_recursive(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\ntemplate <class T, class... types> T read(types... args) noexcept { typename std::remove_const<T>::type obj(args...); std::cin >> obj; return obj; }\n// #define input(type, var, ...) type var{read<type>(__VA_ARGS__)}\n// substitute y for x if x > y.\ntemplate <class T> inline bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\n// substitute y for x if x < y.\ntemplate <class T> inline bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\niter_type binary(iter_type __ok, iter_type __ng, pred_type pred)\n{\n    assert(__ok != __ng);\n    std::ptrdiff_t dist(__ng - __ok);\n    while(std::abs(dist) > 1)\n    {\n        iter_type mid(__ok + dist / 2);\n        if(pred(mid)) __ok = mid, dist -= dist / 2;\n        else __ng = mid, dist /= 2;\n    }\n    return __ok;\n}\n// binary search on real numbers.\ntemplate <class pred_type>\nlong double binary(long double __ok, long double __ng, const long double eps, pred_type pred)\n{\n    assert(__ok != __ng);\n    while(std::abs(__ok - __ng) > eps)\n    {\n        long double mid{(__ok + __ng) / 2};\n        (pred(mid) ? __ok : __ng) = mid;\n    }\n    return __ok;\n}\n// trinary search on discrete range.\ntemplate <class iter_type, class comp_type>\niter_type trinary(iter_type __first, iter_type __last, comp_type comp)\n{\n    assert(__first < __last);\n    std::ptrdiff_t dist(__last - __first);\n    while(dist > 2)\n    {\n        iter_type __left(__first + dist / 3), __right = (__first + dist * 2 / 3);\n        if(comp(__left, __right)) __last = __right, dist = dist * 2 / 3;\n        else __first = __left, dist -= dist / 3;\n    }\n    if(dist > 1 && comp(next(__first), __first)) ++__first;\n    return __first;\n}\n// trinary search on real numbers.\ntemplate <class comp_type>\nlong double trinary(long double __first, long double __last, const long double eps, comp_type comp)\n{\n    assert(__first < __last);\n    while(__last - __first > eps)\n    {\n        long double __left{(__first * 2 + __last) / 3}, __right{(__first + __last * 2) / 3};\n        if(comp(__left, __right)) __last = __right;\n        else __first = __left;\n    }\n    return __first;\n}\n// size of array.\ntemplate <class A, size_t N> size_t size(A (&array)[N]) { return N; }\n// be careful that val is type-sensitive.\ntemplate <class T, class A, size_t N> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\n#pragma endregion // function-utility\n\n#pragma region using-alias\nusing namespace std;\nusing i32 = int_least32_t; using i64 = int_least64_t; using u32 = uint_least32_t; using u64 = uint_least64_t;\nusing p32 = pair<i32, i32>; using p64 = pair<i64, i64>;\ntemplate <class T, class Comp = less<T>> using heap = priority_queue<T, vector<T>, Comp>;\ntemplate <class T> using hashset = unordered_set<T>;\ntemplate <class Key, class Value> using hashmap = unordered_map<Key, Value>;\nusing namespace __gnu_cxx;\n#pragma endregion // using-alias\n\n#pragma region library\n\n\n#ifndef modint_hpp\n#define modint_hpp\n#include <cassert>\n#include <iostream>\n\ntemplate <int mod>\nclass modint\n{\n    int val;\npublic:\n    static constexpr modint identity() noexcept { return 1; }\n    constexpr modint() noexcept : val(0) {}\n    template <class int_type, std::enable_if_t<std::is_integral<int_type>::value, std::nullptr_t> = nullptr>\n    constexpr modint(int_type _val) noexcept : val((_val %= mod) < 0 ? mod + _val : _val) {}\n    constexpr long long value() const noexcept { return val; }\n    constexpr modint operator++(int) noexcept { modint t = *this; return ++val, t; }\n    constexpr modint operator--(int) noexcept { modint t = *this; return --val, t; }\n    constexpr modint &operator++() noexcept { return ++val, *this; }\n    constexpr modint &operator--() noexcept { return --val, *this; }\n    constexpr modint operator-() const noexcept { return modint(-val); }\n    constexpr modint &operator+=(const modint &rhs) noexcept { return (val += rhs.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator-=(const modint &rhs) noexcept { return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this; }\n    constexpr modint &operator*=(const modint &rhs) noexcept { return val = (long long)val * rhs.val % mod, *this; }\n    constexpr modint &operator/=(const modint &rhs) noexcept { return *this *= inverse(rhs); }\n    constexpr modint operator+(const modint &rhs) const noexcept { return modint(*this) += rhs; }\n    constexpr modint operator-(const modint &rhs) const noexcept { return modint(*this) -= rhs; }\n    constexpr modint operator*(const modint &rhs) const noexcept { return modint(*this) *= rhs; }\n    constexpr modint operator/(const modint &rhs) const noexcept { return modint(*this) /= rhs; }\n    constexpr bool operator==(const modint &rhs) const noexcept { return val == rhs.val; }\n    constexpr bool operator!=(const modint &rhs) const noexcept { return val != rhs.val; }\n    constexpr bool operator!() const noexcept { return !val; }\n    friend constexpr modint operator+(long long lhs, modint rhs) noexcept { return modint(lhs) + rhs; }\n    friend constexpr modint operator-(long long lhs, modint rhs) noexcept { return modint(lhs) - rhs; }\n    friend constexpr modint operator*(long long lhs, modint rhs) noexcept { return modint(lhs) * rhs; }\n    friend constexpr modint operator/(long long lhs, modint rhs) noexcept { return modint(lhs) / rhs; }\n    static constexpr modint inverse(const modint &rhs) noexcept\n    {\n        assert(rhs != 0);\n        int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n        while(b) t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n        return {u};\n    }\n    static constexpr modint pow(modint rhs, long long e) noexcept\n    {\n        if(e < 0) e = e % (mod - 1) + mod - 1;\n        modint res{1};\n        while(e) { if(e & 1) res *= rhs; rhs *= rhs, e >>= 1; }\n        return res;\n    }\n    friend std::ostream &operator<<(std::ostream &os, const modint &rhs) noexcept { return os << rhs.val; }\n    friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept { long long val; rhs = {(is >> val, val)}; return is; }\n}; // class modint\n\ntemplate <>\nclass modint<2>\n{\n    bool val;\npublic:\n    static constexpr modint identity() noexcept { return 1; }\n    constexpr modint() noexcept : val(false) {}\n    template <class int_type, std::enable_if_t<std::is_integral<int_type>::value, std::nullptr_t> = nullptr>\n    constexpr modint(int_type _val) noexcept : val(_val & 1) {}\n    constexpr operator bool() const noexcept { return val; }\n    constexpr bool value() const noexcept { return val; }\n    constexpr modint &operator+=(const modint &rhs) noexcept { return val ^= rhs.val, *this; }\n    constexpr modint &operator-=(const modint &rhs) noexcept { return val ^= rhs.val, *this; }\n    constexpr modint &operator*=(const modint &rhs) noexcept { return val &= rhs.val, *this; }\n    constexpr modint &operator/=(const modint &rhs) noexcept { assert(rhs.val); return *this; }\n    constexpr modint operator!() const noexcept { return !val; }\n    constexpr modint operator-() const noexcept { return *this; }\n    constexpr modint operator+(const modint &rhs) const noexcept { return val != rhs.val; }\n    constexpr modint operator-(const modint &rhs) const noexcept { return val != rhs.val; }\n    constexpr modint operator*(const modint &rhs) const noexcept { return val && rhs.val; }\n    constexpr modint operator/(const modint &rhs) const noexcept { assert(rhs.val); return *this; }\n    constexpr bool operator==(const modint &rhs) const noexcept { return val == rhs.val; }\n    constexpr bool operator!=(const modint &rhs) const noexcept { return val != rhs.val; }\n    friend constexpr modint operator+(long long lhs, modint rhs) noexcept { return lhs & 1 ? !rhs : rhs; }\n    friend constexpr modint operator-(long long lhs, modint rhs) noexcept { return lhs & 1 ? !rhs : rhs; }\n    friend constexpr modint operator*(long long lhs, modint rhs) noexcept { return lhs & 1 ? rhs : modint<2>{0}; }\n    friend constexpr modint operator/(long long lhs, modint rhs) noexcept { assert(rhs.val); return lhs & 1 ? rhs : modint<2>{0}; }\n    friend std::ostream &operator<<(std::ostream &os, const modint &rhs) noexcept { return os << rhs.val; }\n    friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept { long long val; rhs.val = (is >> val, val & 1); return is; }\n}; // class modint specialization\n\n#endif // modint_hpp\n\n#pragma endregion // library\n\n#pragma region main-code\nstruct solver; template <class> void main_(); int main() { main_<solver>(); }\ntemplate <class solver> void main_()\n{\n    unsigned t = 1;\n#ifdef LOCAL\n    t = 1;\n#endif\n    // t = -1; // infinite loop\n    // cin >> t; // case number given\n\n    while(t--) solver();\n}\n\n\nstruct solver\n{\n    using mint=modint<(int)1e9+7>;\n\n    solver()\n    {\n        int n,m; cin>>n>>m;\n        vector<mint> dp(m+1,1);\n        for(int i=0; i<n; i++)\n        {\n            vector<mint> nx(m+1);\n            for(int j=0; j<m; j++)\n            {\n                nx[j+1]=nx[j]*2+j*dp[j];\n            }\n            for(int j=0; j<=m; j++)\n            {\n                nx[j]+=dp[j]*(j+1);\n            }\n            swap(nx,dp);\n            // dump(nx);\n        }\n        cout << dp[m] << \"\\n\";\n    }\n};\n#pragma endregion // main-code\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7,iv=(mod+1)/2;\nint n,m,dp[5555][5555],sum[5555][5555];\nint pw[5555],ipw[5555];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tpw[0]=ipw[0]=1;\n\tfor (int i=1;i<=5005;i++) \n\t{\n\t\tpw[i]=(pw[i-1]+pw[i-1])%mod;\n\t\tipw[i]=1ll*iv*ipw[i-1]%mod;\n\t}\n\tfor (int i=1;i<=m;i++) dp[0][i]=1;\n\tfor (int i=1;i<=m;i++) sum[0][i]=(1ll*dp[0][i]*i%mod*ipw[i]+sum[0][i-1])%mod;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tdp[i][j]=(1ll*sum[i-1][j-1]*pw[j-1]%mod+1ll*dp[i-1][j]*(j+1))%mod;\n\t\t}\n\t\tfor (int j=1;j<=m;j++)\n\t\t{\n\t\t\tsum[i][j]=(1ll*dp[i][j]*j%mod*ipw[j]+sum[i][j-1])%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n][m]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#define int long long\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i,a,b) for (int i = a; i < b; ++i)\n#define ROF(i,b,a) for (int i = (b)-1; i >= a; --i)\nusing namespace std;\n\nconst int N = 5010, P = 1e9+7;\ntypedef long long ll;\n\nint qpow(int a, int x) {\n\tint ret = 1;\n\tfor (; x; a = 1ll*a*a%P, x >>= 1) if (x&1) ret = 1ll*ret*a%P;\n\treturn ret;\n}\n\nint n, m;\nint f[N][N], s[N][N], pow2[N], inv2[N];\n\nsigned main() {\n\tscanf(\"%d%d\", &m, &n);\n\tFOR(i,0,n+1) {\n\t\tpow2[i] = qpow(2, i);\n\t\tinv2[i] = qpow(2, P-1-i);\n\t}\n\tFOR(i,1,n+1) {\n\t\tf[0][i] = 1;\n\t\ts[0][i] = (s[0][i-1] + 1ll*inv2[i]*i%P*f[0][i])%P;\n\t\t//printf(\"s[%d][%d] = %d\\n\", 0, i, s[0][i]);\n\t}\n\tFOR(i,1,m+1) {\n\t\tFOR(j,1,n+1) {\n\t\t\tf[i][j] = ((j+1ll)*f[i-1][j] + 1ll*pow2[j-1]*s[i-1][j-1])%P;\n\t\t\ts[i][j] = (s[i][j-1] + 1ll*inv2[j]*j%P*f[i][j])%P;\n\t\t\t//printf(\"s[%d][%d] = %d\\n\", i, j, s[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", f[m][n]);\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <__uint128_t Mod = 0> struct modint {\n  using mod_type = typename std::conditional<bool(Mod), const int, int>::type;\n  static mod_type mod;\n  using value_type = int;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\ntemplate <__uint128_t Mod>\ntypename modint<Mod>::mod_type modint<Mod>::mod = Mod;\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  solver() {\n    // start here!\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    dp[0] = dp[0] + 1;\n    dp[0] = dp[0] - 1;\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nconst int MOD = (1e9 + 7);\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nvoid radd(int &a, int b)\n{\n\ta=add(a,b); \n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nvoid rmult(int &a, int b)\n{\n\ta=mult(a,b);\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(a<b) return 0;\n\tif(b==0) return 1;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tpow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\t\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(5555);\n\tint n,m; cin>>n>>m;\n\tvi old(m+1,0);\n\told[m]=1;\n\tfor(int z=1;z<=n;z++)\n\t{\n\t\tvi nw(m+1,0);\n\t\tvi suf(m+2,0);\n\t\tfor(int i=m;i>=1;i--)\n\t\t{\n\t\t\tsuf[i]=add(suf[i+1],mult(pow2[i],old[i]));\n\t\t}\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\t/*\n\t\t\tfor(int j=1;j<i;j++)\n\t\t\t{\n\t\t\t\tnw[j]=add(nw[j],mult(old[i],mult(j,pow2[i-j-1])));\n\t\t\t}\n\t\t\t*/\n\t\t\tnw[i]=add(nw[i],mult(old[i],i+1));\n\t\t\tnw[i]=add(nw[i],mult(mult(i,inverse(pow2[i+1])),suf[i+1]));\n\t\t}\n\t\told=nw;\n\t}\n\tint ans=0;\n\tfor(int i=1;i<=m;i++) radd(ans,old[i]);\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 5005, mod = 1e9 + 7;\n\nint n, m;\nint f[maxN + 1][maxN + 1], sum[maxN + 1][maxN + 1];\nint pw[maxN + 1], ipw[maxN + 1];\n\ninline int ADD(int x, int y) { return x + y >= mod ? x + y - mod : x + y; }\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\n\tint I = (mod + 1) / 2;\n\tpw[0] = ipw[0] = 1;\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tpw[i] = 2ll * pw[i - 1] % mod;\n\t\tipw[i] = 1ll * I * ipw[i - 1] % mod;\n\t}\n\n\tfor(int j = 1; j <= m; j++) f[1][j] = pw[j];\n\tfor(int j = 1; j < m; j++) sum[1][j] = ADD(sum[1][j - 1], 1ll * f[1][j] * j % mod * ipw[j + 1] % mod);\n\tfor(int i = 2; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= m; j++)\n\t\t{\n\t\t\tf[i][j] = 1ll * (j + 1) * f[i - 1][j] % mod;\n\t\t\tf[i][j] = ADD(f[i][j], 1ll * sum[i - 1][j - 1] * pw[j] % mod);\n\t\t}\n\t\tfor(int j = 1; j < m; j++) \n\t\t\tsum[i][j] = ADD(sum[i][j - 1], 1ll * f[i][j] * j % mod * ipw[j + 1] % mod);\n\t}\n\n\tprintf(\"%d\\n\", f[n][m]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\n\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\n\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\ntemplate <class T>\nconstexpr static bool is_integral_ext_v = is_integral_ext<T>::value;\n\ntemplate <typename T, typename = void> struct multiplicable_uint {\n  using type = uint_least32_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(2 < sizeof(T))>::type> {\n  using type = uint_least64_t;\n};\ntemplate <typename T>\nstruct multiplicable_uint<T, typename std::enable_if<(4 < sizeof(T))>::type> {\n  using type = __uint128_t;\n};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\modulus\\\\modint.hpp\"\n\n#line 6 \"Library\\\\modulus\\\\modint.hpp\"\n\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      Mod != 0, typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint(bool n) noexcept : modint(int(n)) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (typename multiplicable_uint<value_type>::type)value *\n                   rhs.value % mod,\n           *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1}, p{*this};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n// #include \"atcoder/modint.hpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  // using mint = modint_runtime;\n  // using mint = atcoder::modint;\n\n  solver() {\n    // start here!\n    // mint::mod = 1e9 + 7;\n    // mint::set_mod(1e9 + 7);\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(dp, nx);\n    }\n    cout << dp[m] << \"\\n\";\n    // cout << dp[m].val() << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof (x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\n#define outval(x) cerr<<#x\" = \"<<x<<endl\n#define outv(x) cerr<<#x\" = \"<<x<<\"  \"\n#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n#define outarr(a,L,R) cerr<<#a\"[\"<<L<<\"..\"<<R<<\"] = \";\\\n\tFor(_x,L,R) cerr<<a[_x]<<\" \";cerr<<endl;\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\nconst int mod=1e9+7;\nint Pow(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=(LL)x*x%mod)\n\t\tif (y&1)\n\t\t\tans=(LL)ans*x%mod;\n\treturn ans;\n}\nvoid Add(int &x,int y){\n\tif ((x+=y)>=mod)\n\t\tx-=mod;\n}\nvoid Del(int &x,int y){\n\tif ((x-=y)<0)\n\t\tx+=mod;\n}\nint Add(int x){\n\treturn x>=mod?x-mod:x;\n}\nint Del(int x){\n\treturn x<0?x+mod:x;\n}\nconst int N=5005;\nint n,m;\nint Fac[N],Inv[N];\nint C(int n,int m){\n\tif (m<0||m>n)\n\t\treturn 0;\n\treturn (LL)Fac[n]*Inv[m]%mod*Inv[n-m]%mod;\n}\nLL dp[N][N];\nint main(){\n\tn=read(),m=read();\n\tFac[0]=1;\n\tFor(i,1,m)\n\t\tFac[i]=(LL)Fac[i-1]*i%mod;\n\tInv[m]=Pow(Fac[m],mod-2);\n\tFod(i,m,1)\n\t\tInv[i-1]=(LL)Inv[i]*i%mod;\n\tdp[0][1]=1;\n\tFor(i,1,n){\n\t\tFor(j,1,m){\n\t\t\tint v=dp[i-1][j];\n\t\t\tLL val=(LL)v*(j+1);\n\t\t\tdp[i][j]+=val;\n\t\t\tdp[i][j+1]-=val;\n\t\t\tdp[i][j+1]+=2LL*v*j;\n\t\t}\n\t\tFor(j,1,m)\n\t\t\tdp[i][j]=(dp[i][j]+dp[i][j-1])%mod;\n\t}\n\tint ans=0;\n\tFor(i,1,m)\n\t\tAdd(ans,(LL)dp[n][i]*C(m-1,i-1)%mod);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int M = 1e9 + 7;\n\nint pw(int a, int n = M - 2) {\n    int ret = 1;\n    while (n) {\n        if (n & 1)\n            ret = (ll) ret * a % M;\n        a = (ll) a * a % M;\n        n >>= 1;\n    }\n    return ret;\n}\n\nconst int N = 5050;\n\nint dp[N][N];\n\nvoid insum(int & a, int b) {\n    a = (a + b) % M;\n}\n\nvoid smain() {\n\n    int n, m;\n    cin >> n >> m;\n\n    for (int j = 1; j <= m; ++j) {\n        dp[n - 1][j] = pw(2, j);\n    }\n\n    for (int i = n - 2; i >= 0; --i) {\n        /* no 01 */;\n        for (int j = 1; j <= m; ++j) {\n            insum(dp[i][j], (ll) dp[i + 1][j] * (j + 1) % M);\n            dp[i + 1][j] = (ll) dp[i + 1][j] * j % M;\n        }\n        /* at least one 01 */;\n        int sum = 0;\n        for (int j = 1; j <= m; ++j) {\n            sum = (ll) sum * 2 % M;\n            insum(sum, dp[i + 1][j - 1]);\n            insum(dp[i][j], sum);\n//            for (int k = 1; k < j; ++k) {\n//                insum(dp[i][j], (ll) dp[i + 1][k] * pw(2, j - k - 1) % M);\n//            }\n        }\n    }\n    cout << dp[0][m];\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint Mod = 1000000007, n, m;\nint w[5], res;\nlong long D[5010], T[5010], po[5010], Ipo[5010], Inv2=Mod/2+1;\nvoid Do(){\n    int j;\n    long long sum=0;\n    for(j=1;j<=m;j++){\n        sum=(sum+D[j-1]*Ipo[j]%Mod*(j-1))%Mod;\n        T[j]=(D[j]*(j+1)+sum*po[j])%Mod;\n    }\n    for(j=1;j<=m;j++)D[j]=T[j];\n}\nint main(){\n    int i;\n    po[0]=Ipo[0]=1;\n    scanf(\"%d%d\",&n,&m);\n    for(i=1;i<=5000;i++)po[i]=po[i-1]*2%Mod, Ipo[i]=Ipo[i-1]*Inv2%Mod;\n    for(i=1;i<=m;i++)D[i]=po[i];\n    for(i=1;i<n;i++){\n        Do();\n    }\n    printf(\"%lld\\n\",D[m]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n#define SZ(x) ((int)((x).size()))\n\ntemplate <typename T1, typename T2>\nstring print_iterable(T1 begin_iter, T2 end_iter, int counter) {\n    bool done_something = false;\n    stringstream res;\n    res << \"[\";\n    for (; begin_iter != end_iter and counter; ++begin_iter) {\n        done_something = true;\n        counter--;\n        res << *begin_iter << \", \";\n    }\n    string str = res.str();\n    if (done_something) {\n        str.pop_back();\n        str.pop_back();\n    }\n    str += \"]\";\n    return str;\n}\n\nvector<int> SortIndex(int size, std::function<bool(int, int)> compare) {\n    vector<int> ord(size);\n    for (int i = 0; i < size; i++) ord[i] = i;\n    sort(ord.begin(), ord.end(), compare);\n    return ord;\n}\n\ntemplate <typename T>\nbool MinPlace(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool MaxPlace(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename S, typename T>\nostream& operator <<(ostream& out, const pair<S, T>& p) {\n    out << \"{\" << p.first << \", \" << p.second << \"}\";\n    return out;\n}\n\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& v) {\n    out << \"[\";\n    for (int i = 0; i < (int)v.size(); i++) {\n        out << v[i];\n        if (i != (int)v.size()-1) out << \", \";\n    }\n    out << \"]\";\n    return out;\n}\n\ntemplate<class TH>\nvoid _dbg(const char* name, TH val){\n    clog << name << \": \" << val << endl;\n}\ntemplate<class TH, class... TA>\nvoid _dbg(const char* names, TH curr_val, TA... vals) {\n    while(*names != ',') clog << *names++;\n    clog << \": \" << curr_val << \", \";\n    _dbg(names+1, vals...);\n}\n\n#if DEBUG && !ONLINE_JUDGE\n    ifstream input_from_file(\"input.txt\");\n    #define cin input_from_file\n\n    #define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n    #define dbg_arr(x, len) clog << #x << \": \" << print_iterable(x, x+len, -1) << endl;\n#else\n    #define dbg(...)\n    #define dbg_arr(x, len)\n#endif\n\n///////////////////////////////////////////////////////////////////////////\n//////////////////// DO NOT TOUCH BEFORE THIS LINE ////////////////////////\n///////////////////////////////////////////////////////////////////////////\n\n\nconst int MAXN = 5100;\nLL c[MAXN][MAXN];\nconst LL mod = 1e9 + 7;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0); // Remove in problems with online queries!\n\n    int N, M;\n    cin >> N >> M;\n\n    for (int m = 1; m <= M; m++) c[0][m] = 1;\n    for (int n = 1; n <= N; n++) {\n        for (int m = 1; m <= M; m++) {\n            c[n][m] = (m+1)*c[n-1][m] % mod;\n            c[n-1][m] = c[n-1][m] * m % mod;\n        }\n        \n        // for (int m = 1; m <= M; m++) {\n            // LL sum = 0;\n            // LL pot = 1;\n            // for (int s = 2; s <= m; s++, pot = 2*pot % mod) {\n                // sum += c[n-1][m-s+1] * pot % mod;\n            // }\n            // sum %= mod;\n            // c[n][m] = (c[n][m] + sum) % mod;\n        // }\n        LL sum = 0;\n        LL pot = 1;\n        LL inv2 = (mod+1)/2;\n        LL invpot = inv2;\n        for (int m = 1; m <= M; m++) {\n            c[n][m] = (c[n][m] + sum * pot) % mod;\n            sum = (sum + c[n-1][m] * invpot) % mod;\n            pot = 2*pot % mod;\n            invpot = inv2 * invpot % mod;\n        }\n    }\n    cout << c[N][M] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<pair<int, int> > vpii;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef vector<ll> vll;\n#define INF 0x3f3f3f3f\n#define MOD 1000000007LL\n#define HF   500000004LL\n#define EPS 0.00001\n#define f first\n#define s second\n#define pb push_back\n\n#define FOR(i, a, b) for (int i=(a); i<=(signed)(b); i++)\n#define F0R(i, a) for (int i=0; i<(signed)(a); i++)\n#define RFOR(i, a, b) for (int i=(a); i >= b; i--)\n\n#define MN 5005\nint n, m;\nll p2[MN], ip2[MN];\nll dp[MN][MN];\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    cin >> n >> m;\n    p2[0] = 1;\n    ip2[0] = 1;\n    FOR(i, 1, MN-2){\n        p2[i] = (p2[i-1]*2)%MOD;\n        ip2[i] = (ip2[i-1]*HF)%MOD;\n    }\n    FOR(j, 1, m){\n        dp[1][j] = p2[j];\n    }\n    FOR(i, 2, n){\n        ll sm = 0;\n        FOR(j, 1, m){\n            ll pt1 = (dp[i-1][j]*(j+1))%MOD;\n            ll pt2 = (sm*p2[j-1])%MOD;\n            dp[i][j] = (pt1+pt2)%MOD;\n\n            sm += ((dp[i-1][j]*j)%MOD*ip2[j])%MOD;\n            sm %= MOD;\n        }\n    }\n    cout << dp[n][m] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nvoid add(int &a, int b) {\n    a = a + b < MOD ? a + b : a + b - MOD;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++)\n        for (int m = 0, sum = 0; m <= M; m++) {\n            int extra = (sum + int64_t(m) * dp[m]) % MOD;\n            add(dp[m], extra);\n            add(sum, extra);\n        }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Modular {\nprivate:\n    static long long MOD;\n    // a * x + b * y == g; g == gcd(x, y)\n    static void extended_gcd(long long x, long long y, long long& a, long long& b, long long& g) {\n        if (x < 0) {\n            extended_gcd(-x, y, a, b, g);\n            a = -a;\n        } else if (y < 0) {\n            extended_gcd(x, -y, a, b, g);\n            b = -b;\n        } else if (x > y) {\n            extended_gcd(y, x, b, a, g);\n        } else if (x == 0) {\n            a = 0;\n            b = 1;\n            g = y;\n        } else {\n            long long a1 = -1;\n            long long b1 = -1;\n            extended_gcd(y % x, x, a1, b1, g);\n            b = a1;\n            a = b1 - a1 * (y / x);\n        }\n    }\n    static long long mod_inv(long long x, long long m) {\n        long long a = 0;\n        long long b = 0;\n        long long g = 0;\n        extended_gcd(x, m, a, b, g);\n        a = ((a % m) + m) % m;\n        return a;\n    }\npublic:\n    long long value;\n    Modular(): value(0) {}\n    explicit Modular(long long v): value(normalize(v)) {}\n    static long long normalize(long long v) {\n        v = v % MOD;\n        if (v < 0)\n            v += MOD;\n        return v;\n    }\n\n    bool operator==(const Modular& a) const {return value == a.value;}\n    bool operator<(const Modular& a) const { return value < a.value;}\n    Modular operator+=(const Modular& a) {value = normalize(value + a.value); return *this;}\n    Modular operator-=(const Modular& a) {value = normalize(value - a.value); return *this;}\n    Modular operator*=(const Modular& a) {value = normalize(value * a.value); return *this;}\n    Modular operator/=(const Modular& a) {return (*this) *= a.inv();}\n\n    Modular operator++() {value = normalize(value + 1); return *this;}\n    Modular operator--() {value = normalize(value - 1); return *this;}\n    Modular operator++(int) {Modular tmp = *this; value = normalize(value + 1); return tmp;}\n    Modular operator--(int) {Modular tmp = *this; value = normalize(value - 1); return tmp;}\n\n    template <typename T>\n    Modular operator+=(const T& a) {value = normalize(value + a); return *this;}\n    template <typename T>\n    Modular operator-=(const T& a) {value = normalize(value - a); return *this;}\n    template <typename T>\n    Modular operator*=(const T& a) {value = normalize(value * a); return *this;}\n\n    Modular inv() const {return Modular(mod_inv(value, MOD));}\n    Modular pow(long long p) const {  // this doesn't assume prime MOD\n        Modular res(1);\n        Modular sq(value);\n        while (p > 0) {\n            if (p % 2 == 1) {\n                res *= sq;\n            }\n            sq *= sq;\n            p /= 2;\n        }\n        return res;\n    }\n\n    static void set_mod(long long mod) {MOD = mod;}\n};\nlong long Modular::MOD = 0;\n\nModular operator+(const Modular& a, const Modular& b) {Modular c(a); return c += b;}\ntemplate<typename T>\nModular operator+(const Modular& a, const T& b) {return a + Modular(b);}\ntemplate<typename T>\nModular operator+(const T& a, const Modular& b) {return Modular(a) + b;}\n\nModular operator-(const Modular& a, const Modular& b) {Modular c(a); return c -= b;}\ntemplate<typename T>\nModular operator-(const Modular& a, const T& b) {return a - Modular(b);}\ntemplate<typename T>\nModular operator-(const T& a, const Modular& b) {return Modular(a) - b;}\n\nModular operator*(const Modular& a, const Modular& b) {Modular c(a); return c *= b;}\ntemplate<typename T>\nModular operator*(const Modular& a, const T& b) {return a * Modular(b);}\ntemplate<typename T>\nModular operator*(const T& a, const Modular& b) {return Modular(a) * b;}\n\nModular operator/(const Modular& a, const Modular& b) {Modular c(a); return c /= b;}\ntemplate<typename T>\nModular operator/(const Modular& a, const T& b) {return a / Modular(b);}\ntemplate<typename T>\nModular operator/(const T& a, const Modular& b) {return Modular(a) / b;}\n\nstd::ostream& operator<<(std::ostream& os, const Modular& m) {\n    return os << m.value;\n}\n\nstd::istream& operator>>(std::istream& is, Modular& m) {\n    return is >> m.value;\n}\nint main() {\n    Modular::set_mod(1000000007);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<Modular>> dp(n + 1, vector<Modular>(m + 1));\n    for (int i = 0; i <= m; ++i) {\n        dp[0][i] = Modular(1);\n        if (i == 0)\n            dp[1][i] = Modular(1);\n        else\n            dp[1][i] = 2 * dp[1][i - 1];\n    }\n    Modular two(2);\n    vector<Modular> twos(m + 1);\n    twos[0] = Modular(1);\n    for (int i = 1; i <= m; ++i)\n        twos[i] = 2 * twos[i - 1];\n    vector<Modular> itwos(m + 1);\n    itwos[0] = Modular(1);\n    for (int i = 1; i <= m; ++i)\n        itwos[i] = itwos[i - 1] / 2;\n\n\n    for (int i = 2; i <= n; ++i) {\n        Modular s;\n        for (int j = 0; j <= m; ++j) {\n            dp[i][j] = (j + 1) * dp[i - 1][j];\n//            for (int p = 2; p <= j; ++p) {\n//                dp[i][j] += two.pow(p - 2) * (j - p + 1) * dp[i - 1][j - p + 1];\n//            }\n            if (j >= 2)\n                s += ((j - 1) * dp[i - 1][j - 1]) * itwos[j];\n            dp[i][j] += s * twos[j];\n        }\n    }\n    cout << dp[n][m] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=5005,M=1e9+7;\nint n,m,g[N][N],f[N][N],fac[N],inv[N];\ninline int ksm(int x,int y){\n\tint ans=1;\n\tfor (;y;y>>=1,x=x*x%M)\n\t\tif (y&1)(ans*=x)%=M;\n\treturn ans;\n}\nsigned main(){\n\tscanf(\"%lld%lld\",&m,&n);\n\tfac[0]=inv[0]=1;\n\tfor (int i=1;i<N;i++)fac[i]=fac[i-1]*2%M,inv[i]=ksm(fac[i],M-2);\n\tfor (int i=1;i<=n;i++)f[0][i]=1,g[0][i]=(g[0][i-1]+inv[i+1]*i)%M;\n\tfor (int i=1;i<=m;i++)\n\t\tfor (int j=1;j<=n;j++){\n\t\t\t(f[i][j]+=g[i-1][j-1]*fac[j]+f[i-1][j]*(j+1))%=M;\n\t\t\t(g[i][j]+=g[i][j-1]+f[i][j]*inv[j+1]%M*j)%=M;\n\t\t}\n\tprintf(\"%lld\\n\",f[m][n]);\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int N=5e3+2;\nint dp[N][N],pw2[N],inv2[N],sum[N][N];\nvoid add(int &x,int y){\n\tx+=y;\n\tif(x>=mod){\n\t\tx-=mod;\n\t}\n}\nvoid sub(int &x,int y){\n\tx-=y;\n\tif(x<0){\n\t\tx+=mod;\n\t}\n}\nint mul(int x,int y){\n\treturn (1ll*x*y)%mod;\n}\nint binpow(int x,int y){\n\tint tich=1;\n\twhile(y){\n\t\tif(y&1){\n\t\t\ttich=mul(tich,x);\n\t\t}\n\t\tx=mul(x,x);\n\t\ty>>=1;\n\t}\n\treturn tich;\n}\nsigned main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m,i,j,k,l;\n\tcin>>n>>m;\n\tpw2[0]=1;\n\tfor(i=1;i<=m+1;i++){\n\t\tpw2[i]=pw2[i-1];\n\t\tadd(pw2[i],pw2[i-1]);\n\t}\n\tinv2[m+1]=binpow(pw2[m+1],mod-2);\n\tfor(i=m+1;i>0;i--){\n\t\tinv2[i-1]=inv2[i];\n\t\tadd(inv2[i-1],inv2[i-1]);\n\t}\n\tfor(i=1;i<=m;i++){\n\t\tdp[0][i]=1;\n\t\tsum[0][i]=sum[0][i-1];\n\t\tadd(sum[0][i],mul(mul(dp[0][i],i),inv2[i+1]));\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<=m;j++){\n\t\t\tdp[i][j]=mul(dp[i-1][j],j+1);\n\t\t\tadd(dp[i][j],mul(sum[i-1][j-1],pw2[j]));\n\t\t\tsum[i][j]=sum[i][j-1];\n\t\t\tadd(sum[i][j],mul(mul(dp[i][j],j),inv2[j+1]));\n\t\t}\n\t}\n\tcout<<dp[n][m];\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      bool(Mod), typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = typename std::decay<mod_type>::type;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1}, p{*this};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    intmax_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n// #include \"atcoder/modint.hpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  // using mint = modint_runtime;\n  // using mint = atcoder::modint;\n\n  solver() {\n    // start here!\n    // mint::mod = 1e9 + 7;\n    // mint::set_mod(1e9 + 7);\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(dp, nx);\n    }\n    cout << dp[m] << \"\\n\";\n    // cout << dp[m].val() << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n  \nlong long int gcd(long long int a, long long int b){\n\tif (a > b){\n\t\tswap(a, b);\n\t}\n\twhile (a){\n\t\tswap(a, b);\n\t\ta %= b;\n\t}\n\treturn b;\n}\nlong long int lcm(long long int a, long long int b){\n\treturn a / gcd(a, b)*b;\n}\nlong long int ppow(long long int i, long long int j){\n\t\tlong long int res = 1LL;\n\t\twhile (j){\n\t\t\tif ((j & 1LL)){\n\t\t\t\tres *= i;\n\t\t\t\tif (res >= MOD){\n\t\t\t\t\tres %= MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj >>= 1;\n\t\t\ti *= i;\n\t\t\tif (i >= MOD){\n\t\t\t\ti %= MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\nclass Combination{\n\t\npublic:\n\tvector<long long int> k;\n\tvector<long long int> r;\n\tvoid resize(int N){\n\t\tk.resize(N + 2);\n\t\tr.resize(N + 2);\n\t\tk[0] = 1;\n\t\tfor (int i = 1; i < N+2; i++){\n\t\t\tk[i] = k[i - 1];\n\t\t\tk[i] *= i;\n\t\t\tif (k[i] >= MOD)k[i] %= MOD;\n\t\t}\n\t\tlong long int al = k[k.size() - 1];\n\t\tlong long int iv = ppow(k[k.size() - 1],MOD-2);\n\t\tr[k.size() - 1] = iv;\n\t\tfor (int i = (int)(r.size()) - 2; i >= 0; i--){\n\t\t\tr[i] = r[i + 1] * (i + 1);\n\t\t\tif (r[i] >= MOD){\n\t\t\t\tr[i] %= MOD;\n\t\t\t}\n\t\t}\n\t}\n\tlong long int C(int a, int b){\n\t\tif (a < b)return 0;\n\t\tlong long int up = k[a];\n\t\tlong long int dw = r[b] * r[a - b];\n\t\tdw %= MOD;\n\t\tup *= dw;\n\t\tup %= MOD;\n\t\treturn up;\n\t}\n\tlong long int H(int a, int b){\n\t\treturn C(a + b - 1, b);\n\t}\n\tlong long int catalan_number(int n){\n\t\treturn (C(2 * n, n) + MOD - C(2 * n, n - 1)) % MOD;\n\t}\n};\nCombination C;\n\n#define MAX 5002\nint n;\nint m;\nint dp[MAX][MAX];\nbool use[MAX][MAX];\nint im[MAX][MAX];\ninline int dfs(int a,int b){\n\tif(b==0)return 0;\n\tif(a==n)return 1;\n\tif(use[a][b])return dp[a][b];\n\tuse[a][b]=true;\n\taddto(dp[a][b],mul(1+b,dfs(a+1,b)));\n\t/*for(int i=1;i<=b-1;i++){\n\t\t//addto(dp[a][b],mul(b-i,mul(ppow(2,i-1),dp[a+1][b-i])));\n\t\tcerr<<\"add1 \"<<mul(b-i,ppow(2,i-1))<<\" \"<<b-i<<\" \"<<ppow(2,i-1)<<endl;\n\t}\n\tfor(int imi=2;imi<=b;imi++){\n\t\t//(b-1)*1*dfs(a+1,b-1)+(b-2)*2*dfs(a+1,b-2)+4*dfs(a+1,b-3)...dfs(a+1,1)\n\t\t//addto(dp[a][b],mul(b-imi+1,mul(ppow(2,imi-2),dfs(a+1,b-imi+1))));\n\t\t//cerr<<\"add2 \"<<mul(b-imi+1,ppow(2,imi-2))<<\" \"<<dp[a+1][b-imi+1]<<endl;\n\t}*/\n\taddto(dp[a][b],mul(im[a+1][b-1],ppow(ppow(2,(m-b+1)),MOD-2)));\n\treturn dp[a][b];\n}\nint main(){\n\tcin>>n>>m;\n\tfor(int i=n;i>=0;i--){\n\t\tfor(int j=m;j>=0;j--){\n\t\t\t//cerr<<\"ad \"<<i<<\" \"<<j<<endl;\n\t\t\tdp[i][j]=dfs(i,j);\n\t\t}\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tim[i][j]=mul(ppow(2,m-j),mul(j,dp[i][j]));\n\t\t\taddto(im[i][j],im[i][j-1]);\n\t\t}\n\t}\n\tcout<<dfs(0,m)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\n\nusing M = Mint<int>;\nconst int MAX = 5050;\nM dp[MAX][MAX];\nint used[MAX][MAX]={};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m;\n  cin>>n>>m;\n  vector<M> po(n+m+1,1);\n  for(int i=0;i<n+m;i++) po[i+1]=po[i]*M(2);\n\n  MFP([&](auto dfs,int h,int w)->M{\n    // cout<<h<<' '<<w<<endl;\n    M &res=dp[h][w];\n    if(used[h][w]) return res;\n    used[h][w]=1;\n\n    assert(h>=0 and w>=0);\n    if(h==0 or w==0) return res=M(1);\n    if(w==1) return res=po[h];\n    if(h==1) return res=po[w];\n\n    res=M(0);\n\n    //  (j)  (w-j)\n    // 0...0/1...1\n    for(int j=0;j<=w;j++)\n      res+=dfs(h-1,j)*dfs(h-1,w-j);\n\n    //  (j) (1)(?)(1)(k)\n    // 0...0/1?????0(1*)\n    /*\n    for(int j=0;j+1<w;j++)\n      for(int k=0;j+1+k<w;k++)\n        res+=dfs(h-1,j+1+k)*po[w-(j+1+k+1)];\n    */\n\n    // j+k -> j\n    for(int j=0;j+1<w;j++)\n      res+=dfs(h-1,j+1)*po[w-(j+1+1)]*M(w-(j+1));\n\n    return res;\n  })(n,m);\n\n  cout<<dp[n][m]<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define MN 5010\n#define mod 1000000007\n\nint f[MN][MN], mi[MN];\n\nint main()\n{\n\tint n, m; scanf(\"%d%d\", &n, &m);\n\tmi[0] = 1; for(int i = 1; i <= m; i++) mi[i] = mi[i - 1] * 2 % mod;\n\tfor(int j = 1; j <= m; j++) f[0][j] = 1;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tf[i][j] = (f[i][j - 1] * 2 + 1ll * f[i - 1][j - 1] * (j - 1)) % mod;\n\t\tfor(int j = 1; j <= m; j++)\n\t\t\tf[i][j] = (f[i][j] + 1ll * f[i - 1][j] * (j + 1)) % mod;\n\t}\n\t\t\n\tprintf(\"%d\\n\", f[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  intmax_t dist(ng - ok);\n  while (std::abs(dist) > 1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (eps < std::abs(ok - ng)) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n}  // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n#line 7 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n// template <auto mod> class modint;\ntemplate <auto &mod> class modint {\n  int val;\n\n public:\n  static constexpr modint identity() noexcept { return 1; }\n  constexpr modint() noexcept : val(0) {}\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type _val) noexcept\n      : val((_val %= mod) < 0 ? mod + _val : _val) {}\n  constexpr long long value() const noexcept { return val; }\n  constexpr modint operator++(int) noexcept {\n    modint t = *this;\n    return ++val, t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t = *this;\n    return --val, t;\n  }\n  constexpr modint &operator++() noexcept { return ++val, *this; }\n  constexpr modint &operator--() noexcept { return --val, *this; }\n  constexpr modint operator-() const noexcept { return modint(-val); }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (val += rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return val = (long long)val * rhs.val % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return *this *= inverse(rhs);\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint &rhs) const noexcept {\n    return val == rhs.val;\n  }\n  constexpr bool operator!=(const modint &rhs) const noexcept {\n    return val != rhs.val;\n  }\n  constexpr bool operator!() const noexcept { return !val; }\n  friend constexpr modint operator+(long long lhs, modint rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  friend constexpr modint operator-(long long lhs, modint rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  friend constexpr modint operator*(long long lhs, modint rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  friend constexpr modint operator/(long long lhs, modint rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  static constexpr modint inverse(const modint &rhs) noexcept {\n    assert(rhs != 0);\n    int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  static constexpr modint pow(modint rhs, long long e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.val;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    long long val;\n    rhs = {(is >> val, val)};\n    return is;\n  }\n};  // class modint\n/*\ntemplate <int &mod> class modint {\n  int val;\n\n public:\n  static constexpr modint identity() noexcept { return 1; }\n  constexpr modint() noexcept : val(0) {}\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type _val) noexcept\n      : val((_val %= mod) < 0 ? mod + _val : _val) {}\n  constexpr long long value() const noexcept { return val; }\n  constexpr modint operator++(int) noexcept {\n    modint t = *this;\n    return ++val, t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t = *this;\n    return --val, t;\n  }\n  constexpr modint &operator++() noexcept { return ++val, *this; }\n  constexpr modint &operator--() noexcept { return --val, *this; }\n  constexpr modint operator-() const noexcept { return modint(-val); }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (val += rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return val = (long long)val * rhs.val % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return *this *= inverse(rhs);\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint &rhs) const noexcept {\n    return val == rhs.val;\n  }\n  constexpr bool operator!=(const modint &rhs) const noexcept {\n    return val != rhs.val;\n  }\n  constexpr bool operator!() const noexcept { return !val; }\n  friend constexpr modint operator+(long long lhs, modint rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  friend constexpr modint operator-(long long lhs, modint rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  friend constexpr modint operator*(long long lhs, modint rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  friend constexpr modint operator/(long long lhs, modint rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  static constexpr modint inverse(const modint &rhs) noexcept {\n    assert(rhs != 0);\n    int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  static constexpr modint pow(modint rhs, long long e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.val;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    long long val;\n    rhs = {(is >> val, val)};\n    return is;\n  }\n};  // class modint\n*/\n\nstruct workspace::solver {\n  solver() {\n    constexpr static int mod = 1000000007;\n    using mint = modint<mod>;\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n      // dump(nx);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint dp[MAXN][MAXN];\nint main() {\n\tint n, m; read(n), read(m);\n\tfor (int i = 1; i <= m; i++)\n\t\tdp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++) {\n\t\tint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tupdate(dp[i][j], 1ll * dp[i - 1][j] * (j + 1) % P);\n\t\t\tupdate(dp[i][j], sum);\n\t\t\tsum = (2ll * sum + 1ll * dp[i - 1][j] * j) % P;\n\t\t}\n\t}\n\tcout << dp[n][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\nunsigned long long n,sum=0;\ncin>>n;\nfor(unsigned long long i=1;i<=n+1;i++){\ncin>>a[i];\n}\nint b[n+5]={0},c[n+5]={0};\nfor(unsigned long long i=2;i<=n+1;i++){\nb[i]=(b[i-1]-a[i-1])*2;\n}\nfor(unsigned long long i=n;i>=1;i--){\nc[i]=c[i+1]+a[i];\n}\nfor(unsigned long long i=1;i<=n+1;i++){\nsum+=min(b[i],c[i]);\n}\nfor(unsigned long long i=1;i<=n;i++){\nif(a[i]>b[i]){\ncout<<\"-1\"<<endl;\nreturn 0;\n}\n}\ncout<<sum<<endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"unroll-loops\")\n#include<bits/stdc++.h>\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\nusing namespace std;\nusing ll = long long;\nusing vi = vector<ll>;\nconst int maxn = 5050, mod = 1e9 + 7;\nint n, m, dp[maxn][maxn];\nvoid add(int &a, int b) {\n\ta += b;\n\tif(a >= mod) a -= mod;\n}\nint main() {\n\tcin.tie(0)->sync_with_stdio(0);\n\tcin >> n >> m;\n\tfor(int i = 0; i <= m; i++) dp[0][i] = 1;\n\tfor(int i = 1; i <= n; i++) {\n\t\tint cur = 0;\n\t\tdp[i][0] = 1;\n\t\tadd(dp[i][1], dp[i-1][1]);\n\t\tadd(dp[i][1], dp[i-1][1]);\n\t\tfor(int j = 2; j <= m; j++) {\n\t\t\tadd(dp[i][j], dp[i-1][j] * 1ll * (j+1) %mod);\n\t\t\tadd(cur, cur);\n\t\t\tadd(cur, dp[i-1][j-1]*1ll*(j-1)%mod);\n\t\t\tadd(dp[i][j], cur);\n\t\t}\n\t}\n\tcout << dp[n][m];\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=5005,mod=1e9+7,inv2=(mod+1)/2;\nint f[N][N],s[N][N],sa[N][N],sb[N][N],sab[N][N];\nint ipw[N],pw[N];\nint n,m,ans;\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1) res=(ll)res*x%mod;\n\treturn res;\n}\nint mul(int x,int y){\n\treturn (ll)x*y%mod;\n}\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\nint pw(int x){\n\treturn x>=mod?pw[x]:ipw[-x];\n}\n\nint main(){\n\tread(n),read(m);\n\tpw[0]=ipw[0]=1;\n\trpe(i,1,5000){\n\t\tpw[i]=mul(pw[i-1],2);\n\t\tipw[i]=mul(ipw[i-1],inv2);\n\t}\n\trep(i,0,n) rep(j,0,m){\n\t\tif(i==0){\n\t\t\tif(j==0) f[i][j]=1;\n\t\t}\n\t\telse if(j){\n\t\t\tf[i][j]=mul(s[i-1][j-1],mod-j+1);\n\t\t\tadd(f[i][j],mul(sa[i-1][j-1],mul(pw(i-1),mod-b)));\n\t\t\tadd(f[i][j],mul(sb[i-1][j-1]));\n\t\t\tadd(f[i][j],mul(sab[i-1][j-1],mod-pw(i-1)));\n\t\t}\n\t\telse{\n\t\t\tf[i][j]=1;\n\t\t}\n\t\ts[i][j]=f[i][j];\n\t\tif(i) add(s[i][j],mod-s[i-1][j]);\n\t\tif(j) add(s[i][j],mod-s[i][j-1]);\n\t\tif(i&&j) add(s[i][j],s[i-1][j-1]);\n\t\tsa[i][j]=mul(f[i][j],pw(-i));\n\t\tif(i) add(sa[i][j],mod-sa[i-1][j]);\n\t\tif(j) add(sa[i][j],mod-sa[i][j-1]);\n\t\tif(i&&j) add(sa[i][j],sa[i-1][j-1]);\n\t\tsb[i][j]=mul(f[i][j],j);\n\t\tif(i) add(sb[i][j],mod-sb[i-1][j]);\n\t\tif(j) add(sb[i][j],mod-sb[i][j-1]);\n\t\tif(i&&j) add(sb[i][j],sb[i-1][j-1]);\n\t\tsab[i][j]=mul(f[i][j],mul(pw(-i),j));\n\t\tif(i) add(sab[i][j],mod-sab[i-1][j]);\n\t\tif(j) add(sab[i][j],mod-sab[i][j-1]);\n\t\tif(i&&j) add(sab[i][j],sab[i-1][j-1]);\n\t}\n\tint ans=0;\n\trep(i,0,m) add(ans,f[n][i]);\n\tcout<<ans<<endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  intmax_t dist(ng - ok);\n  while (std::abs(dist) > 1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (eps < std::abs(ok - ng)) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n}  // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n#line 7 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"C:\\\\cygwin64\\\\home\\\\euler\\\\competitive-programming\\\\Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n// template <auto mod> class modint;\ntemplate <auto &mod> class modint {\n  int val;\n\n public:\n  static constexpr modint identity() noexcept { return 1; }\n  constexpr modint() noexcept : val(0) {}\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type _val) noexcept\n      : val((_val %= mod) < 0 ? mod + _val : _val) {}\n  constexpr long long value() const noexcept { return val; }\n  constexpr modint operator++(int) noexcept {\n    modint t = *this;\n    return ++val, t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t = *this;\n    return --val, t;\n  }\n  constexpr modint &operator++() noexcept { return ++val, *this; }\n  constexpr modint &operator--() noexcept { return --val, *this; }\n  constexpr modint operator-() const noexcept { return modint(-val); }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (val += rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return val = (long long)val * rhs.val % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return *this *= inverse(rhs);\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint &rhs) const noexcept {\n    return val == rhs.val;\n  }\n  constexpr bool operator!=(const modint &rhs) const noexcept {\n    return val != rhs.val;\n  }\n  constexpr bool operator!() const noexcept { return !val; }\n  friend constexpr modint operator+(long long lhs, modint rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  friend constexpr modint operator-(long long lhs, modint rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  friend constexpr modint operator*(long long lhs, modint rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  friend constexpr modint operator/(long long lhs, modint rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  static constexpr modint inverse(const modint &rhs) noexcept {\n    assert(rhs != 0);\n    int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  static constexpr modint pow(modint rhs, long long e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.val;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    long long val;\n    rhs = {(is >> val, val)};\n    return is;\n  }\n};  // class modint\n/*\ntemplate <int &mod> class modint {\n  int val;\n\n public:\n  static constexpr modint identity() noexcept { return 1; }\n  constexpr modint() noexcept : val(0) {}\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type _val) noexcept\n      : val((_val %= mod) < 0 ? mod + _val : _val) {}\n  constexpr long long value() const noexcept { return val; }\n  constexpr modint operator++(int) noexcept {\n    modint t = *this;\n    return ++val, t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t = *this;\n    return --val, t;\n  }\n  constexpr modint &operator++() noexcept { return ++val, *this; }\n  constexpr modint &operator--() noexcept { return --val, *this; }\n  constexpr modint operator-() const noexcept { return modint(-val); }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (val += rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (val += mod - rhs.val) < mod ? 0 : val -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return val = (long long)val * rhs.val % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return *this *= inverse(rhs);\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint(*this) += rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint(*this) -= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint(*this) *= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint(*this) /= rhs;\n  }\n  constexpr bool operator==(const modint &rhs) const noexcept {\n    return val == rhs.val;\n  }\n  constexpr bool operator!=(const modint &rhs) const noexcept {\n    return val != rhs.val;\n  }\n  constexpr bool operator!() const noexcept { return !val; }\n  friend constexpr modint operator+(long long lhs, modint rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  friend constexpr modint operator-(long long lhs, modint rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  friend constexpr modint operator*(long long lhs, modint rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  friend constexpr modint operator/(long long lhs, modint rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  static constexpr modint inverse(const modint &rhs) noexcept {\n    assert(rhs != 0);\n    int a{mod}, b{rhs.val}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  static constexpr modint pow(modint rhs, long long e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.val;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    long long val;\n    rhs = {(is >> val, val)};\n    return is;\n  }\n};  // class modint\n*/\n\nstruct workspace::solver {\n  constexpr static int mod = 1000000007;\n  using mint = modint<mod>;\n\n  solver() {\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n      // dump(nx);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int MOD=1e9+7;\nint add(int a,int b){\n\treturn (a+b)%MOD;\n}\nvoid dadd(int &a,int b){\n\ta=add(a,b);\n}\nint sub(int a,int b){\n\treturn (a-b+MOD)%MOD;\n}\nint mul(int a,int b){\n\treturn (LL)a*b%MOD;\n}\nconst int N=5050;\nint dp[N][N];\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++){\n\t\tdp[0][i]=1;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j+1<=m;j++){\n\t\t\tdp[i][j+1]=mul(dp[i-1][j],j);\n\t\t}\n\t\tfor(int j=2;j<=m;j++){\n\t\t\tdadd(dp[i][j],mul(dp[i][j-1],2));\n\t\t}\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tdadd(dp[i][j],mul(dp[i-1][j],j+1));\n\t\t}\n\t}\n\tint ans=dp[n][m];\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\ntemplate<long long MOD>\nstruct ModInt{\n\n    using ll = long long;\n    ll val;\n\n    void setval(ll v) { val = v % MOD; };\n    ModInt(): val(0) {}\n    ModInt(ll v) { setval(v); };\n\n    ModInt operator+(const ModInt &x) const { return ModInt(val + x.val); }\n    ModInt operator-(const ModInt &x) const { return ModInt(val - x.val + MOD); }\n    ModInt operator*(const ModInt &x) const { return ModInt(val * x.val); }\n    ModInt operator/(const ModInt &x) const { return *this * x.inv(); }\n    ModInt operator-() const { return ModInt(MOD - val); }\n    ModInt operator+=(const ModInt &x) { return *this = *this + x; }\n    ModInt operator-=(const ModInt &x) { return *this = *this - x; }\n    ModInt operator*=(const ModInt &x) { return *this = *this * x; }\n    ModInt operator/=(const ModInt &x) { return *this = *this / x; }\n\n    friend ostream& operator<<(ostream &os, const ModInt &x) { os << x.val; return os; }\n    friend istream& operator>>(istream &is, ModInt &x) { is >> x.val; x.val = (x.val % MOD + MOD) % MOD; return is; }\n\n    ModInt pow(ll n) const {\n        ModInt a = 1;\n        if(n == 0) return a;\n        int i0 = 64 - __builtin_clzll(n);\n        for(int i = i0 - 1; i >= 0; i--){\n            a = a * a;\n            if((n >> i) & 1) a *= (*this); \n        }\n        return a;\n    }\n    ModInt inv() const { return this->pow(MOD - 2); }\n};\n\nusing mint = ModInt<mod>; mint pow(mint x, long long n) { return x.pow(n); }\n//using mint = double; //for debug\nusing mvec = vector<mint>;\nusing mmat = vector<mvec>;\n\nstruct Combination{\n\n    vector<mint> fact, invfact;\n\n    Combination(int N){\n        fact = vector<mint>({mint(1)});\n        invfact = vector<mint>({mint(1)});\n        fact_initialize(N);\n    }\n\n    void fact_initialize(int N){\n        int i0 = fact.size();\n        if(i0 >= N + 1) return;\n        fact.resize(N + 1);\n        invfact.resize(N + 1);\n        for(int i = i0; i <= N; i++) fact[i] = fact[i - 1] * i;\n        invfact[N] = (mint)1 / fact[N];\n        for(int i = N - 1; i >= i0; i--) invfact[i] = invfact[i + 1] * (i + 1); \n    }\n\n    mint nCr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[r] * invfact[n - r];\n    }\n\n    mint nPr(int n, int r){\n        if(n < 0 || r < 0 || r > n) return mint(0);\n        if(fact.size() < n + 1) fact_initialize(n);\n        return fact[n] * invfact[n - r];\n    }\n\n    mint Catalan(int n){\n        if(n < 0) return 0;\n        else if(n == 0) return 1;\n        if(fact.size() < 2 * n + 1) fact_initialize(2 * n);\n        return fact[2 * n] * invfact[n + 1] * invfact[n];\n    }\n\n};\n\nsigned main(){\n\n    int N, M; cin >> N >> M;\n    mmat dp(N, mvec(M + 1, 0));\n    FOR(j, 1, M + 1) dp[0][j] = pow((mint)2, j);\n    REP(i, N - 1){\n        FOR(j, 1, M + 1) dp[i + 1][j] += dp[i][j] * (j + 1);\n        mint t = 0;\n        FOR(j, 1, M + 1){\n            dp[i + 1][j] += t;\n            t = t * 2 + dp[i][j] * j;\n        }\n    }\n\n    Out(dp[N - 1][M]);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Let's join Kaede Takagaki Fan Club !!\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC target (\"avx\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\n#define all(x) x.begin(),x.end()\ntemplate<class T>\nvoid dmp(T a){\n\trep(i,a.size()) cout << a[i] << \" \";\n\tcout << endl;\n}\ntemplate<class T>\nbool chmax(T&a, T b){\n\tif(a < b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nbool chmin(T&a, T b){\n\tif(a > b){\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate<class T>\nvoid g(T &a){\n\tcin >> a;\n}\ntemplate<class T>\nvoid o(const T &a,bool space=false){\n\tcout << a << (space?' ':'\\n');\n}\n//ios::sync_with_stdio(false);\nconst ll mod = 1000000007;//998244353\ntemplate<class T>\nvoid add(T&a,T b){\n\ta+=b;\n\tif(a >= mod) a-=mod;\n}\nint n, m;\nll dp[5005][5005], bin[5005], revb[5005];\nll dp2[5005][5005];\n\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nint main(){\n\tbin[0] = 1;\n\tfor(int i=1;i<5005;i++) bin[i] = bin[i-1] * 2LL % mod;\n\trep(i, 5005) revb[i] = modpow(bin[i], mod-2);\n\tcin >> m >> n;\n\trep(i, 5005) dp[i][0] = 1;\n\t//dp2[i][j] = dp[i][j] * i * rev[i+1]\n\t\n\trep(i, 5005) dp2[i][0] = dp[i][0] * i % mod * revb[i+1] % mod;\n\tfor(int j=1;j<=m;j++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t//same\n\t\t\tdp[i][j] += dp[i][j-1] * (i+1) % mod;\n\t\t\t//small\n\t\t\t//for(int k=1;k<i;k++){\n\t\t\t//\tdp[i][j] += dp[k][j-1] * k % mod * bin[i-k-1] % mod;\n\t\t\t//}\n\t\t\tdp[i][j] += dp2[i-1][j-1] * bin[i] % mod;\n\t\t\tdp[i][j] %= mod;\n\t\t\tdp2[i][j] = dp[i][j] * i % mod * revb[i+1] % mod;\n\t\t\tdp2[i][j-1] = dp2[i-1][j-1] + dp2[i][j-1];\n\t\t\tdp2[i][j-1] %= mod;\n\t\t}\n\t}\n\tcout << dp[n][m] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\n#define fir first\n#define sec second\n#define rep(i,a,b) for (int i = (a) ; i <= (b) ; ++ i)\n#define rrp(i,a,b) for (int i = (a) ; i >= (b) ; -- i)\n#define gc() getchar()\ntemplate <typename tp>\ninline void read(tp& x) {\n  x = 0; char tmp; bool key = 0;\n  for (tmp = gc() ; !isdigit(tmp) ; tmp = gc())\n    key = (tmp == '-');\n  for ( ; isdigit(tmp) ; tmp = gc())\n    x = (x << 3) + (x << 1) + (tmp ^ '0');\n  if (key) x = -x;\n}\ntemplate <typename tp>\ninline void ckmn(tp& x,tp y) {\n  x = x < y ? x : y;\n}\ntemplate <typename tp>\ninline void ckmx(tp& x,tp y) {\n  x = x < y ? y : x;\n}\n\nconst int MOD = (int)(1e9 + 7);\ninline void Add(int& x,int y) {\n  x = x + y >= MOD ? x + y - MOD : x + y;\n}\ninline void Sub(int& x,int y) {\n  x = x - y < 0 ? x - y + MOD : x - y;\n}\nint power(int a,int b) {\n  int ret = 1;\n  while (b) {\n    if (b&1) ret = 1ll * ret * a % MOD;\n    a = 1ll * a * a % MOD;\n    b >>= 1;\n  }\n  return ret;\n}\nconst int N = 5010;\nint dp[N][N], n, m, jc[N], ijc[N];\nvoid prework(int sz) {\n  jc[0] = 1;\n  rep (i, 1, sz) jc[i] = (ll)jc[i-1] * i % MOD;\n  ijc[sz] = power(jc[sz], MOD - 2);\n  rrp (i, sz-1, 0) ijc[i] = (ll)ijc[i+1] * (i+1) % MOD;\n}\nint comb(int a,int b) {\n  if (b < 0 || a < b) return 0;\n  return (ll)jc[a] * ijc[b] % MOD * ijc[a-b] % MOD;\n}\nint main() {\n  read(n), read(m);\n  prework(max(n, m));\n  dp[n][1] = 1;\n  rrp (i, n, 1) {\n    int tmp = 0;\n    rep (j, 1, m) {\n      Add(dp[i-1][j], (ll)(j+1) * dp[i][j] % MOD);\n      Add(dp[i-1][j], tmp);\n      Add(tmp, (ll)(2 * j) * dp[i][j] % MOD);\n    }\n  }\n  int ans = 0;\n  rep (j, 1, m) {\n    Add(ans, (ll)dp[0][j] * comb(m - 1, j - 1) % MOD);\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <auto Mod = 0, typename Mod_type = decltype(Mod)> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value,\n                \"Mod must be integral type.\");\n  static_assert(!(Mod < 0), \"Mod must be non-negative.\");\n\n  using mod_type = typename std::conditional<\n      bool(Mod), typename std::add_const<Mod_type>::type, Mod_type>::type;\n  static mod_type mod;\n\n  using value_type = int;\n\n  constexpr operator value_type() const noexcept { return value; }\n\n  constexpr static modint one() noexcept { return 1; }\n\n  constexpr modint() noexcept = default;\n\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      power(int_type e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1}, p{*this};\n    for (modint p{value}; e; e >>= 1, p *= p) {\n      if (e & 1) res *= p;\n    }\n    return res;\n  }\n\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\n\ntemplate <auto Mod, typename Mod_type>\ntypename modint<Mod, Mod_type>::mod_type modint<Mod, Mod_type>::mod = Mod;\n\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n// #include \"atcoder/modint.hpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  // using mint = modint_runtime;\n  // using mint = atcoder::modint;\n\n  solver() {\n    // start here!\n    // mint::mod = 1e9 + 7;\n    // mint::set_mod(1e9 + 7);\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(dp, nx);\n    }\n    cout << dp[m] << \"\\n\";\n    // cout << dp[m].val() << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long int dp[5010][5010],pre[5010],po[5010],inv[5010];\n\nconst int mod = 1e9 + 7;\nconst int i2 = 5e8 + 4;\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tpo[0]=inv[0]=1;\n\tfor(int i=1;i<=5005;i++)\tpo[i]=po[i-1]*2%mod,inv[i]=inv[i-1]*i2%mod;\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;i++)\tdp[n][i]=1;\n\tfor(int i=n-1;i>=0;i--){\n\t\tfor(int j=1;j<=m;j++){\n\t\t\tpre[j]=(pre[j-1]+dp[i+1][j]*inv[j+1]%mod*j)%mod;\n\t\t\tdp[i][j]=(dp[i+1][j]*(j+1)+pre[j-1]*po[j])%mod;\n\t\t}\n\t}\n\tcout<<dp[0][m]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n//#STAY AT HOME\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define M0(r) memset(r, 0, sizeof(r))\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wconversion\"\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using vll=vector<ll>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#define def_op(...) struct _{};\n#if !defined(LOCAL) && !defined(LOCAL2)\n#define exit my_exit\nvoid my_exit(int x) {fflush(stdout);_Exit(x);}\n#endif\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\n#define pow do not use cmath pow unless you know what you are doing\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;ll fix(ll o, ll m){o%=m;if(o<0)o+=m;ros;}\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=(ll)(a*(ld)b/m);ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#pragma GCC diagnostic pop\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\nsim> struct REV {using value_type=typename c::value_type;c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {using value_type=typename c::value_type;const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n#define done(r...) exit(0 * printf(r))\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\n//#STAY AT HOME\nconst int mod = 1e9 + 7, nax = 5048;\nll p2[nax];\nll dp[nax][nax];\nint main() {\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tp2[0] = 1;\n\tfor (int i = 1; i < nax; ++i) p2[i] = p2[i - 1] * 2 % mod;\n\tfor (int l = 0; l <= m; ++l) dp[0][l] = 1;\n\tfor (int b = 0; b <= n; ++b) dp[b][0] = 1;\n\tfor (int b = 1; b <= n; ++b) {\n\t\tfor (int l = 1; l <= m; ++l) {\n\t\t\tif (l >= 2)\n\t\t\t\tdp[b][l] = (2 * dp[b][l - 1] + dp[b - 1][l - 1] * (l - 1)) % mod;\n\t\t\t\t// int bef = l - merged + 1;\n\t\t\t\t// ll ways = p2[merged - 2];\n\t\t\t\t// (dp[b][l] += dp[b - 1][bef] * ways % mod * bef) %= mod;\n\t\t}\n\t\tfor (int l = 1; l <= m; ++l) {\n\t\t\t(dp[b][l] += dp[b - 1][l] * (l + 1)) %= mod;\n\t\t\t// debug(arr(dp, b, l));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", fix(dp[n][m], mod));\n\texit(0);\n}\n//#STAY AT HOME\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Modular {\nprivate:\n    static long long MOD;\n    // a * x + b * y == g; g == gcd(x, y)\n    static void extended_gcd(long long x, long long y, long long& a, long long& b, long long& g) {\n        if (x < 0) {\n            extended_gcd(-x, y, a, b, g);\n            a = -a;\n        } else if (y < 0) {\n            extended_gcd(x, -y, a, b, g);\n            b = -b;\n        } else if (x > y) {\n            extended_gcd(y, x, b, a, g);\n        } else if (x == 0) {\n            a = 0;\n            b = 1;\n            g = y;\n        } else {\n            long long a1 = -1;\n            long long b1 = -1;\n            extended_gcd(y % x, x, a1, b1, g);\n            b = a1;\n            a = b1 - a1 * (y / x);\n        }\n    }\n    static long long mod_inv(long long x, long long m) {\n        long long a = 0;\n        long long b = 0;\n        long long g = 0;\n        extended_gcd(x, m, a, b, g);\n        a = ((a % m) + m) % m;\n        return a;\n    }\npublic:\n    long long value;\n    Modular(): value(0) {}\n    explicit Modular(long long v): value(normalize(v)) {}\n    static long long normalize(long long v) {\n        v = v % MOD;\n        if (v < 0)\n            v += MOD;\n        return v;\n    }\n\n    bool operator==(const Modular& a) const {return value == a.value;}\n    bool operator<(const Modular& a) const { return value < a.value;}\n    Modular operator+=(const Modular& a) {value = normalize(value + a.value); return *this;}\n    Modular operator-=(const Modular& a) {value = normalize(value - a.value); return *this;}\n    Modular operator*=(const Modular& a) {value = normalize(value * a.value); return *this;}\n    Modular operator/=(const Modular& a) {return (*this) *= a.inv();}\n\n    Modular operator++() {value = normalize(value + 1); return *this;}\n    Modular operator--() {value = normalize(value - 1); return *this;}\n    Modular operator++(int) {Modular tmp = *this; value = normalize(value + 1); return tmp;}\n    Modular operator--(int) {Modular tmp = *this; value = normalize(value - 1); return tmp;}\n\n    template <typename T>\n    Modular operator+=(const T& a) {value = normalize(value + a); return *this;}\n    template <typename T>\n    Modular operator-=(const T& a) {value = normalize(value - a); return *this;}\n    template <typename T>\n    Modular operator*=(const T& a) {value = normalize(value * a); return *this;}\n\n    Modular inv() const {return Modular(mod_inv(value, MOD));}\n    Modular pow(long long p) const {  // this doesn't assume prime MOD\n        Modular res(1);\n        Modular sq(value);\n        while (p > 0) {\n            if (p % 2 == 1) {\n                res *= sq;\n            }\n            sq *= sq;\n            p /= 2;\n        }\n        return res;\n    }\n\n    static void set_mod(long long mod) {MOD = mod;}\n};\nlong long Modular::MOD = 0;\n\nModular operator+(const Modular& a, const Modular& b) {Modular c(a); return c += b;}\ntemplate<typename T>\nModular operator+(const Modular& a, const T& b) {return a + Modular(b);}\ntemplate<typename T>\nModular operator+(const T& a, const Modular& b) {return Modular(a) + b;}\n\nModular operator-(const Modular& a, const Modular& b) {Modular c(a); return c -= b;}\ntemplate<typename T>\nModular operator-(const Modular& a, const T& b) {return a - Modular(b);}\ntemplate<typename T>\nModular operator-(const T& a, const Modular& b) {return Modular(a) - b;}\n\nModular operator*(const Modular& a, const Modular& b) {Modular c(a); return c *= b;}\ntemplate<typename T>\nModular operator*(const Modular& a, const T& b) {return a * Modular(b);}\ntemplate<typename T>\nModular operator*(const T& a, const Modular& b) {return Modular(a) * b;}\n\nModular operator/(const Modular& a, const Modular& b) {Modular c(a); return c /= b;}\ntemplate<typename T>\nModular operator/(const Modular& a, const T& b) {return a / Modular(b);}\ntemplate<typename T>\nModular operator/(const T& a, const Modular& b) {return Modular(a) / b;}\n\nstd::ostream& operator<<(std::ostream& os, const Modular& m) {\n    return os << m.value;\n}\n\nstd::istream& operator>>(std::istream& is, Modular& m) {\n    return is >> m.value;\n}\nint main() {\n    Modular::set_mod(1000000007);\n    int n, m;\n    cin >> n >> m;\n    vector<vector<Modular>> dp(n + 1, vector<Modular>(m + 1));\n    for (int i = 0; i <= m; ++i) {\n        dp[0][i] = Modular(1);\n        if (i == 0)\n            dp[1][i] = Modular(1);\n        else\n            dp[1][i] = 2 * dp[1][i - 1];\n    }\n    Modular two(2);\n    for (int i = 2; i <= n; ++i) {\n        Modular s;\n        Modular q(1);\n        for (int j = 0; j <= m; ++j) {\n            dp[i][j] = (j + 1) * dp[i - 1][j];\n//            for (int p = 2; p <= j; ++p) {\n//                dp[i][j] += two.pow(p - 2) * (j - p + 1) * dp[i - 1][j - p + 1];\n//            }\n            if (j >= 2)\n                s += ((j - 1) * dp[i - 1][j - 1]) / q;\n            dp[i][j] += s * q;\n            q *= 2;\n        }\n    }\n    cout << dp[n][m] << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,M;\nconst ll mo=1000000007;\n\nll dp[5050][5050];\nll p2[5050];\n\nll comb(ll N_, ll C_) {\n\tconst int NUM_=400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>M;\n\tFOR(i,M+1) dp[0][i]=1;\n\t\n\tp2[0]=1;\n\tFOR(i,5010) p2[i+1]=p2[i]*2%mo;\n\t\n\t\n\tfor(i=1;i<=N;i++) {\n\t\tdp[i][0]=1;\n\t\tfor(x=1;x<=M;x++) {\n\t\t\t// 000111\n\t\t\t(dp[i][x]+=dp[i-1][x]*(x+1))%=mo;\n\t\t\t// 00111000\n\t\t\tfor(int len=2;len<=x;len++) {\n\t\t\t\t(dp[i][x]+=dp[i-1][x-(len-1)]*p2[len-2]%mo*(x-len+1))%=mo;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<dp[N][M]<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\nusing namespace std;\nconst int N=5005;\nconst int mo=1000000007;\nint n,m;\nint f[N][N];\nint g[N][N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,m) f[0][i]=1;\n\tFor(i,1,n) For(j,1,m){\n\t\tg[i-1][j]=(2*g[i-1][j-1]+1ll*f[i-1][j]*j)%mo;\n\t\tf[i][j]=(1ll*f[i-1][j]*(j+1)+g[i-1][j-1])%mo; \n\t}\n\tprintf(\"%d\\n\",f[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  intmax_t dist(ng - ok);\n  while (std::abs(dist) > 1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (eps < std::abs(ok - ng)) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\variation\\\\modint.hpp\"\ntemplate <auto &mod>  // compile-time defined modulo.\nstruct modint {\n  using value_type = int_least64_t;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (int_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr modint operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator+(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator-(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator*(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type, std::enable_if_t<std::is_integral<int_type>::value,\n                                             std::nullptr_t> = nullptr>\n  constexpr friend modint operator/(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};  // class modint\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  solver() {\n    constexpr static int mod = 1000000007;\n    using mint = modint<mod>;\n\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n      // dump(nx);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mod 1000000007\nlong long dp[5005][5005];\nint main()\n{\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tdp[1][0]=1;\n\tfor (int i=1;i<=m;i++)\n\tdp[1][i]=(2*dp[1][i-1])%mod;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tfor (int j=2;j<=m;j++)\n\t\tdp[i][j]=(2*dp[i][j-1]+dp[i-1][j-1]*(j-1))%mod;\n\t\tfor (int j=1;j<=m;j++)\n\t\tdp[i][j]=(dp[i][j]+(j+1)*dp[i-1][j])%mod;\n\t}\n\tprintf(\"%lld\",dp[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=2e5+5;\nchar c[N];\nint n,i,x,y,z;\nlong long ans;\nint main(){\n\tscanf(\"%s\",c+1);n=strlen(c+1);\n\tfor(i=1;i<=n;++i)if(c[i]=='1')++x,ans+=x+1>>1;else ++y;\n\tx=0;\n\tfor(i=1;i<=n;++i)if(c[i]=='1'){\n\t\t++x;\n\t\tz=i-x;\n\t\tans+=x&1?z>>1:z+1>>1;\n\t\tif(i&1)ans+=y-(i-x);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef double db;\nmt19937 mrand(random_device{}()); \nconst ll mod=1000000007;\nint rnd(int x) { return mrand() % x;}\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll gcd(ll a,ll b) { return b?gcd(b,a%b):a;}\n// head\n\nint n,m;\nll dp[5010][5010];\nint main() {\n\tscanf(\"%d%d\",&n,&m);\n\tswap(n,m);\n\trep(i,1,n+1) dp[i][0]=1;\n\trep(j,1,m+1) {\n\t\tll s=0;\n\t\trep(i,1,n+1) {\n\t\t\tdp[i][j]=((i+1)*dp[i][j-1]+s)%mod;\n\t\t\ts=(s*2+i*dp[i][j-1])%mod;\n\t\t\t//rep(k,1,i) dp[i][j]=(dp[i][j]+(i-k)*powmod(2,k-1)%mod*dp[i-k][j-1])%mod;\n\t\t\t//printf(\"%d %d %lld\\n\",i,j,dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",dp[n][m]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int mod=1e9+7,N=5005;\nint f[N][N];\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=1;i<=m;++i)\n\t\tf[0][i]=1;\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=2;j<=m;++j)\n\t\t\tf[i][j]=(f[i][j-1]*2ll+f[i-1][j-1]*(j-1)%mod)%mod;\n\t\tfor(int j=1;j<=m;++j)\n\t\t\tf[i][j]=(f[i][j]+f[i-1][j]*(j+1)%mod)%mod;\n\t}\n\tcout<<f[n][m];\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,m,i,j,f[5005][5005],sum;\nint main(){\n\tn=read();m=read();\n\tf[0][m]=1;\n\tfor(i=1;i<=n;i++){\n\t\tsum=0;\n\t\tfor(j=m;j>=1;j--){\n\t\t\tf[i][j]=(sum*j+f[i-1][j]*(j+1))%mo;\n\t\t\tsum=(sum*2+f[i-1][j])%mo;\n\t\t}\n\t}\n\tsum=0;\n\tfor(i=1;i<=m;i++)\n\t\tsum=(sum+f[n][i])%mo;\n\tpus(sum,2);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <__uint128_t Mod = 0> struct modint {\n  using mod_type = typename std::conditional<bool(Mod), const int, int>::type;\n  static mod_type mod;\n  using value_type = int;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr modint operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr modint operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr modint operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr modint operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr friend modint operator+(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr friend modint operator-(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr friend modint operator*(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type,\n            typename std::enable_if<std::is_integral<int_type>::value>::type * =\n                nullptr>\n  constexpr friend modint operator/(const int_type &lhs,\n                                    const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\ntemplate <__uint128_t Mod>\ntypename modint<Mod>::mod_type modint<Mod>::mod = Mod;\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  solver() {\n    // start here!\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(nx, dp);\n      // dump(nx);\n    }\n    cout << dp[m] << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n\ntemplate <uint MD> struct ModInt {\n    using M = ModInt;\n    static constexpr uint get_mod() { return MD; }\n    const static M G;\n    uint v;\n    ModInt(ll _v = 0) { set_v(uint(_v % MD + MD)); }\n    M& set_v(uint _v) {\n        v = (_v < MD) ? _v : _v - MD;\n        return *this;\n    }\n    explicit operator bool() const { return v != 0; }\n    M operator-() const { return M() - *this; }\n    M operator+(const M& r) const { return M().set_v(v + r.v); }\n    M operator-(const M& r) const { return M().set_v(v + MD - r.v); }\n    M operator*(const M& r) const { return M().set_v(uint(ull(v) * r.v % MD)); }\n    M operator/(const M& r) const { return *this * r.inv(); }\n    M& operator+=(const M& r) { return *this = *this + r; }\n    M& operator-=(const M& r) { return *this = *this - r; }\n    M& operator*=(const M& r) { return *this = *this * r; }\n    M& operator/=(const M& r) { return *this = *this / r; }\n    bool operator==(const M& r) const { return v == r.v; }\n    M pow(ll n) const {\n        M x = *this, r = 1;\n        while (n) {\n            if (n & 1) r *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return r;\n    }\n    M inv() const { return pow(MD - 2); }\n    friend ostream& operator<<(ostream& os, const M& r) { return os << r.v; }\n};\n// using Mint = ModInt<998244353>;\n// template<> const Mint Mint::G = Mint(3);\n\n\n\n\ntemplate <class Mint>\nV<Mint> powTable(int n, Mint x) {\n    V<Mint> table(n + 1);\n    table[0] = Mint(1);\n    for (int i = 1; i <= n; i++) {\n        table[i] = table[i - 1] * x;\n    }\n    return table;\n}\n\ntemplate<class Mint>\nstruct Comb {\n    int max_n;\n    V<Mint> fact, ifact;\n    Comb() {}\n    Comb(int n) : max_n(n) {\n        fact = ifact = V<Mint>(n + 1);\n        fact[0] = Mint(1);\n        for (int i = 1; i <= n; i++) fact[i] = fact[i - 1] * i;\n        ifact[n] = fact[n].inv();\n        for (int i = n; i >= 1; i--) ifact[i - 1] = ifact[i] * i;\n    }\n\n    Mint C(int n, int k) {\n        if (n < k || n < 0) return Mint(0);\n        assert(0 <= k && k <= n && n <= max_n);\n        return fact[n] * ifact[k] * ifact[n - k];\n    }\n\n    // n個の区別出来ないボールをk個の箱に入れる入れ方\n    Mint H(int n, int k) {\n        if (n == 0 && k == 0) return Mint(1);\n        return C(n + k - 1, n);\n    }\n};\n\n\n\n#include <unistd.h>\n\nstruct Scanner {\n    int fd = -1;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += ::read(fd, line + ed, (1 << 15) - ed);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) {\n            bool sep = false;\n            for (size_t i = st; i < ed; i++) {\n                if (isspace(line[i])) {\n                    sep = true;\n                    break;\n                }\n            }\n            if (!sep) reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] & 0xf);\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* fp) : fd(fileno(fp)) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char(0x30 | (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\nusing Mint = ModInt<TEN(9) + 7>;\n\nScanner sc = Scanner(stdin);\nPrinter pr = Printer(stdout);\n\nint main() {\n    V<Mint> p2 = powTable(10000, Mint(2));\n    int n, m;\n    sc.read(n, m);\n\n    V<Mint> dp(m + 1);\n    dp[m] = Mint(1);\n\n    for (int ph = 0; ph < n; ph++) {\n        V<Mint> ndp(m + 1);\n        Mint sm = 0;\n        for (int j = m; j >= 1; j--) {\n            ndp[j] = Mint(j) * sm + dp[j] * Mint(j + 1);\n            sm *= Mint(2);\n            sm += dp[j];\n        }\n        dp = ndp;\n/*        for (int j = 1; j <= m; j++) {\n            for (int k = 1; k < j; k++) {\n                // j -> k\n                dp[k] += dp[j] * Mint(k) * p2[j - k - 1];\n            }\n            dp[j] *= Mint(j + 1);\n        }*/\n    }\n           ;\n    Mint sm = 0;\n    for (auto x: dp) {\n        sm += x;\n    }\n    pr.writeln(sm.v);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;++A)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\n\nll N,M;\nll dp[5050][5050];\nll p2[5555];\n\nll i, j, k;\nll ans;\n\nint main(){\n    scanf(\"%lld%lld\", &N, &M);\n    p2[0] = 1;\n    fornum(i,0,5050){\n        p2[i + 1] = p2[i] * 2 % MOD;\n        dp[0][i] = 1;\n    }\n\n    fornum(i,0,N){\n        ll a = 0, b = 0;\n        fornum(j,0,M+1){\n            (dp[i + 1][j] += dp[i][j] * (j + 1) + a) %= MOD;\n            (a *= 2) %= MOD;\n            a += dp[i][j] * j;\n            //printf(\"%lld \", dp[i + 1][j]);\n        }\n        //printf(\"\\n\");\n    }\n    printf(\"%lld\\n\", dp[N][M]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef double db; \ntypedef string str; \n\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<db,db> pd; \n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<db> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define mp make_pair\n#define f first\n#define s second\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back()\n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353;\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = acos((ld)-1);\nconst int xd[4] = {1,0,-1,0}, yd[4] = {0,1,0,-1}; \nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count()); \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn b < a ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; } \nint pct(int x) { return __builtin_popcount(x); } \nint bits(int x) { return 31-__builtin_clz(x); } // floor(log2(x)) \nint cdiv(int a, int b) { return a/b+!(a<0||a%b == 0); } // division of a by b rounded up, assumes b > 0 \nint fstTrue(function<bool(int)> f, int lo, int hi) {\n\thi ++; assert(lo <= hi); // assuming f is increasing\n\twhile (lo < hi) { // find first index such that f is true \n\t\tint mid = (lo+hi)/2; \n\t\tf(mid) ? hi = mid : lo = mid+1; \n\t} \n\treturn lo;\n}\n\n// INPUT\ntemplate<class A> void re(complex<A>& c);\ntemplate<class A, class B> void re(pair<A,B>& p);\ntemplate<class A> void re(vector<A>& v);\ntemplate<class A, size_t SZ> void re(array<A,SZ>& a);\n\ntemplate<class T> void re(T& x) { cin >> x; }\nvoid re(db& d) { str t; re(t); d = stod(t); }\nvoid re(ld& d) { str t; re(t); d = stold(t); }\ntemplate<class H, class... T> void re(H& h, T&... t) { re(h); re(t...); }\n\ntemplate<class A> void re(complex<A>& c) { A a,b; re(a,b); c = {a,b}; }\ntemplate<class A, class B> void re(pair<A,B>& p) { re(p.f,p.s); }\ntemplate<class A> void re(vector<A>& x) { trav(a,x) re(a); }\ntemplate<class A, size_t SZ> void re(array<A,SZ>& x) { trav(a,x) re(a); }\n\n// TO_STRING\n#define ts to_string\nstr ts(char c) { return str(1,c); }\nstr ts(bool b) { return b ? \"true\" : \"false\"; }\nstr ts(const char* s) { return (str)s; }\nstr ts(str s) { return s; }\ntemplate<class A> str ts(complex<A> c) { \n\tstringstream ss; ss << c; return ss.str(); }\nstr ts(vector<bool> v) { \n\tstr res = \"{\"; F0R(i,sz(v)) res += char('0'+v[i]);\n\tres += \"}\"; return res; }\ntemplate<size_t SZ> str ts(bitset<SZ> b) {\n\tstr res = \"\"; F0R(i,SZ) res += char('0'+b[i]);\n\treturn res; }\ntemplate<class A, class B> str ts(pair<A,B> p);\ntemplate<class T> str ts(T v) { // containers with begin(), end()\n\tbool fst = 1; str res = \"{\";\n\tfor (const auto& x: v) {\n\t\tif (!fst) res += \", \";\n\t\tfst = 0; res += ts(x);\n\t}\n\tres += \"}\"; return res;\n}\ntemplate<class A, class B> str ts(pair<A,B> p) {\n\treturn \"(\"+ts(p.f)+\", \"+ts(p.s)+\")\"; }\n\n// OUTPUT\ntemplate<class A> void pr(A x) { cout << ts(x); }\ntemplate<class H, class... T> void pr(const H& h, const T&... t) { \n\tpr(h); pr(t...); }\nvoid ps() { pr(\"\\n\"); } // print w/ spaces\ntemplate<class H, class... T> void ps(const H& h, const T&... t) { \n\tpr(h); if (sizeof...(t)) pr(\" \"); ps(t...); }\n\n// DEBUG\nvoid DBG() { cerr << \"]\" << endl; }\ntemplate<class H, class... T> void DBG(H h, T... t) {\n\tcerr << ts(h); if (sizeof...(t)) cerr << \", \";\n\tDBG(t...); }\n#ifdef LOCAL // compile with -DLOCAL\n#define dbg(...) cerr << \"LINE(\" << __LINE__ << \") -> [\" << #__VA_ARGS__ << \"]: [\", DBG(__VA_ARGS__)\n#else\n#define dbg(...) 0\n#endif\n\n// FILE I/O\nvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\nvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\nvoid unsyncIO() { ios_base::sync_with_stdio(0); cin.tie(0); }\nvoid setIO(string s = \"\") {\n\tunsyncIO();\n\t// cin.exceptions(cin.failbit); \n\t// throws exception when do smth illegal\n\t// ex. try to read letter into int\n\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n}\n\n/**\n * Description: modular arithmetic operations \n * Source: \n\t* KACTL\n\t* https://codeforces.com/blog/entry/63903\n\t* https://codeforces.com/contest/1261/submission/65632855 (tourist)\n\t* https://codeforces.com/contest/1264/submission/66344993 (ksun)\n * Verification: \n\t* https://open.kattis.com/problems/modulararithmetic\n */\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T; \n \t/// don't silently convert to T\n\tT v; explicit operator T() const { return v; }\n\tmi() { v = 0; }\n\tmi(ll _v) { \n\t\tv = (-MOD < _v && _v < MOD) ? _v : _v % MOD;\n\t\tif (v < 0) v += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.v == b.v; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.v < b.v; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend str ts(mi a) { return ts(a.v); }\n   \n\tmi& operator+=(const mi& m) { \n\t\tif ((v += m.v) >= MOD) v -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((v -= m.v) < 0) v += MOD; \n\t\treturn *this; }\n\tmi& operator*=(const mi& m) { \n\t\tv = (ll)v*m.v%MOD; return *this; }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { assert(a.v != 0); \n\t\treturn pow(a,MOD-2); }\n\t\t\n\tmi operator-() const { return mi(-v); }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef vector<mi> vmi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<pmi> vpmi;\n\nvector<vmi> scmb; // small combinations\nvoid genComb(int SZ) {\n\tscmb.assign(SZ,vmi(SZ)); scmb[0][0] = 1;\n\tFOR(i,1,SZ) F0R(j,i+1) \n\t\tscmb[i][j] = scmb[i-1][j]+(j?scmb[i-1][j-1]:0);\n}\n\nint N,M;\nmi dp[5001][5001];\nmi po2[5001];\n\nint main() {\n\tpo2[0] = 1; FOR(i,1,5001) po2[i] = 2*po2[i-1];\n\tsetIO(); re(N,M);\n\tFOR(j,1,M+1) dp[0][j] = 1;\n\tFOR(i,1,N+1) {\n\t\tmi cum = 0;\n\t\tFOR(j,1,M+1) {\n\t\t\tcum *= 2;\n\t\t\tcum += (j-1)*dp[i-1][j-1];\n\t\t\tdp[i][j] += (j+1)*dp[i-1][j];\n\t\t\tdp[i][j] += cum;\n\t\t\t// for (int len = 2;len <= j; ++len)\n\t\t\t// \tdp[i][j] += po2[len-2]*(j-len+1)*dp[i-1][j-len+1];\n\t\t}\n\t}\n\tps(dp[N][M]);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?)\n\t* do smth instead of nothing and stay organized\n\t* WRITE STUFF DOWN\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int64_t> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++)\n        for (int m = 0, sum = 0; m <= M; m++) {\n            int extra = (sum + m * dp[m]) % MOD;\n            dp[m] = (dp[m] + extra) % MOD;\n            sum = (sum + extra) % MOD;\n        }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC optimize (\"unroll-loops\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n\n#pragma warning(disable:4786)\n#pragma warning(disable:4996)\n#include <ctime>\n#include<list>\n#include <numeric>\n#include<bitset>\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<set>\n#include<map>\n#include<functional>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<utility>\n#include<fstream>\n#include<sstream>\n#include<cmath>\n#include<stack>\n#include<assert.h>\n#include<unordered_map>\n#include<unordered_set>\n#include <array>\nusing namespace std;\n\n#define MEM(a, b) memset(a, (b), sizeof(a))\n#define CLR(a) memset(a, 0, sizeof(a))\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n#define ABS(X) ( (X) > 0 ? (X) : ( -(X) ) )\n#define S(X) ( (X) * (X) )\n#define SZ(V) (int )V.size()\n#define FORN(i, n) for(int i = 0; i < n; i++)\n#define FORAB(i, a, b) for(int i = a; i <= b; i++)\n#define ALL(V) V.begin(), V.end()\n#define IN(A, B, C)  ((B) <= (A) && (A) <= (C))\n#define AIN(A, B, C) assert(IN(A, B, C))\n\ntypedef long long int LL;\n//typedef __int128 LLL;\ntypedef long long LLL;\n\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<double, double> PDD;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PLL> VPL;\ntypedef vector<PII> VP;\ntypedef vector<double> VD;\ntypedef vector<vector<int>> VVI;\ntypedef vector<string> VS;\ntypedef long double ld;\n\n#define MAXN 5000\n//#define MAXN 1006\n\nconst LL MOD = 1000000007;\n//const LL MOD = 998244353;\nconst LL INF = 2000000000000000001LL; //2e18 + 1\n\nLL dp[5005][5005];\nLL sdp[5005][5005];\nLL p2[5005], invp2[5005];\n\nLL bigmod(LL a, LL b) {\n\tif (b == 0) return 1;\n\tLL x = bigmod(a, b / 2);\n\tx = (x * x) % MOD;\n\tif (b & 1) x = (x * a) % MOD;\n\treturn x;\n}\n\nvoid solve(int ks) {\n\tp2[0] = 1;\n\tinvp2[0] = 1;\n\tLL inv = bigmod(2, MOD - 2);\n\tfor (int i = 1; i <= MAXN + 2; i++) {\n\t\tp2[i] = (2 * p2[i - 1]) % MOD;\n\t\tinvp2[i] = (inv * invp2[i - 1]) % MOD;\n\t}\n\tfor (int i = 0; i <= MAXN; i++) {\n\t\tfor (int j = 0; j <= MAXN; j++) {\n\t\t\tif (i == 0 || j == 0) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tif (i) sdp[i][j] = sdp[i - 1][j];\n\t\t\t\tsdp[i][j] = (sdp[i][j] + ((invp2[i + 1] * i) % MOD) * dp[i][j]) % MOD;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// 0*1*\n\t\t\tdp[i][j] = (dp[i][j] + dp[i][j - 1] * (i + 1)) % MOD;\n\t\t\t// 0*1(anything)01*.\n\t\t\tdp[i][j] = (dp[i][j] + p2[i] * (sdp[i - 1][j - 1] - sdp[0][j - 1] + MOD)) % MOD;\n\t\t\tif (i) sdp[i][j] = sdp[i - 1][j];\n\t\t\tsdp[i][j] = (sdp[i][j] + ((invp2[i + 1] * i) % MOD) * dp[i][j]) % MOD;\n\t\t\t//for (int x = 0; x <= i - 2; x++) {\n\t\t\t//\tdp[i][j] = (dp[i][j] + ((p2[i - x - 2] * (x + 1)) % MOD) * dp[x + 1][j - 1]) % MOD;\n\t\t\t//}\n\t\t}\n\t}\n\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tprintf(\"%lld\\n\", dp[m][n]);\n}\n\nvoid gen() {\n}\n\nint main()\n{\n\tdouble start_time = clock();\n#ifdef LOCAL\n\tfreopen(\"C:\\\\Home\\\\ContestCodes\\\\sample.in\", \"r\", stdin);\n\t// freopen(\"C:\\\\Home\\\\ContestCodes\\\\sample.in\", \"r\", stdin);\n\t//\tfreopen(\"out.out\", \"w\", stdout);\n#endif\n\n\tgen();\n\n\tif (0) {\n\t\tint T;\n\t\tscanf(\"%d\", &T);\n\t\t//AIN(T, 1, 5000);\n\t\tfor (int ks = 1; ks <= T; ks++) {\n\t\t\tsolve(ks);\n\t\t\tif (ks % 1 == 0) fprintf(stderr, \"%d done\\n\", ks);\n\t\t}\n\t}\n\telse {\n\t\tsolve(0);\n\t}\n\n\tdouble end_time = clock();\n\tfprintf(stderr, \"Time = %lf\\n\", (end_time - start_time) / CLOCKS_PER_SEC);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FSortingGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m; cin >> n >> m;\n      vector<ll> dp(n+1);\n      vector<ll> cumsum(n+1);\n\n      ll base = 2;\n      for(int j=1; j<=m; j++) {\n        dp[1] = base;\n        base = base*2%mod;\n        for(int i=1; i<n; i++) {\n          dp[i+1] = (cumsum[i+1] + dp[i]*(j+1))%mod;\n          cumsum[i+1] = (cumsum[i+1]*2 + dp[i]*j)%mod;\n        }\n      }\n      cout << dp[n] << endl;\n    }\n};\n\nsigned main() {\n  FSortingGame solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define ull unsigned ll\n#define uint unsigned\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define IT iterator\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a));\n#define CPY(a,b) memcpy(a,b,sizeof(a));\n#define debug puts(\"wzpakking\")\n#define y1 ysghysgsygsh\nusing namespace std;\nconst int mo=1000000007;\nconst int N=5005;\nint n,m,P[N],IP[N];\nint f[N][N],g[N][N];\nint main(){\n\tP[0]=IP[0]=1;\n\tFor(i,1,N-1) P[i]=2ll*P[i-1]%mo;\n\tFor(i,1,N-1) IP[i]=1ll*IP[i-1]*(mo+1)/2%mo;\n\tscanf(\"%d%d\",&n,&m);\n\tFor(i,1,m) f[0][i]=1;\n\tFor(i,1,n){\n\t\tFor(j,1,m) g[i-1][j]=(g[i-1][j-1]+1ll*f[i-1][j]*j%mo*IP[j])%mo;\n\t\tFor(j,1,m) f[i][j]=(1ll*f[i-1][j]*(j+1)%mo+1ll*g[i-1][j-1]*P[j-1])%mo; \n\t}\n\t//cout<<f[1][2]<<' '<<f[2][2]<<' '<<f[3][2]<<endl;\n\tprintf(\"%d\\n\",f[n][m]);\n}\n/*\n21? 12\n2?1\n?21\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &v) { os << '{'; string sep; for (const auto &x : v) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename T, size_t size> ostream& operator<<(ostream &os, const array<T, size> &arr) { os << '{'; string sep; for (const auto &x : arr) os << sep << x, sep = \", \"; return os << '}'; }\ntemplate<typename A, typename B> ostream& operator<<(ostream &os, const pair<A, B> &p) { return os << '(' << p.first << \", \" << p.second << ')'; }\n\nvoid dbg_out() { cerr << endl; }\ntemplate<typename Head, typename... Tail> void dbg_out(Head H, Tail... T) { cerr << ' ' << H; dbg_out(T...); }\n\n#ifdef NEAL_DEBUG\n#define dbg(...) cerr << \"(\" << #__VA_ARGS__ << \"):\", dbg_out(__VA_ARGS__)\n#else\n#define dbg(...)\n#endif\n\ntemplate<const int &MOD>\nstruct _m_int {\n    int val;\n\n    _m_int(int64_t v = 0) {\n        if (v < 0) v = v % MOD + MOD;\n        if (v >= MOD) v %= MOD;\n        val = int(v);\n    }\n\n    static int inv_mod(int a, int m = MOD) {\n        // https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Example\n        int g = m, r = a, x = 0, y = 1;\n\n        while (r != 0) {\n            int q = g / r;\n            g %= r; swap(g, r);\n            x -= q * y; swap(x, y);\n        }\n\n        return x < 0 ? x + m : x;\n    }\n\n    explicit operator int() const { return val; }\n    explicit operator int64_t() const { return val; }\n\n    _m_int& operator+=(const _m_int &other) {\n        val -= MOD - other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    _m_int& operator-=(const _m_int &other) {\n        val -= other.val;\n        if (val < 0) val += MOD;\n        return *this;\n    }\n\n    static unsigned fast_mod(uint64_t x, unsigned m = MOD) {\n#if !defined(_WIN32) || defined(_WIN64)\n        return unsigned(x % m);\n#endif\n        // Optimized mod for Codeforces 32-bit machines.\n        // x must be less than 2^32 * m for this to work, so that x / m fits in a 32-bit unsigned int.\n        unsigned x_high = unsigned(x >> 32), x_low = unsigned(x);\n        unsigned quot, rem;\n        asm(\"divl %4\\n\"\n            : \"=a\" (quot), \"=d\" (rem)\n            : \"d\" (x_high), \"a\" (x_low), \"r\" (m));\n        return rem;\n    }\n\n    _m_int& operator*=(const _m_int &other) {\n        val = fast_mod(uint64_t(val) * other.val);\n        return *this;\n    }\n\n    _m_int& operator/=(const _m_int &other) {\n        return *this *= other.inv();\n    }\n\n    friend _m_int operator+(const _m_int &a, const _m_int &b) { return _m_int(a) += b; }\n    friend _m_int operator-(const _m_int &a, const _m_int &b) { return _m_int(a) -= b; }\n    friend _m_int operator*(const _m_int &a, const _m_int &b) { return _m_int(a) *= b; }\n    friend _m_int operator/(const _m_int &a, const _m_int &b) { return _m_int(a) /= b; }\n\n    _m_int& operator++() {\n        val = val == MOD - 1 ? 0 : val + 1;\n        return *this;\n    }\n\n    _m_int& operator--() {\n        val = val == 0 ? MOD - 1 : val - 1;\n        return *this;\n    }\n\n    _m_int operator++(int) { _m_int before = *this; ++*this; return before; }\n    _m_int operator--(int) { _m_int before = *this; --*this; return before; }\n\n    _m_int operator-() const {\n        return val == 0 ? 0 : MOD - val;\n    }\n\n    bool operator==(const _m_int &other) const { return val == other.val; }\n    bool operator!=(const _m_int &other) const { return val != other.val; }\n\n    _m_int inv() const {\n        return inv_mod(val);\n    }\n\n    _m_int pow(int64_t p) const {\n        if (p < 0)\n            return inv().pow(-p);\n\n        _m_int a = *this, result = 1;\n\n        while (p > 0) {\n            if (p & 1)\n                result *= a;\n\n            p >>= 1;\n\n            if (p > 0)\n                a *= a;\n        }\n\n        return result;\n    }\n\n    friend ostream& operator<<(ostream &os, const _m_int &m) {\n        return os << m.val;\n    }\n};\n\nextern const int MOD = 1e9 + 7;\nusing mod_int = _m_int<MOD>;\n\n\nint main() {\n    ios::sync_with_stdio(false);\n#ifndef NEAL_DEBUG\n    cin.tie(nullptr);\n#endif\n\n    int N, M;\n    cin >> N >> M;\n    vector<mod_int> dp(M + 1, 1);\n\n    for (int i = 0; i < N; i++) {\n        vector<mod_int> next_dp(M + 1, 0);\n        mod_int sum = 0;\n\n        for (int m = 0; m <= M; m++) {\n            next_dp[m] = (m + 1) * dp[m];\n\n            if (m >= 2)\n                sum = sum + sum + (m - 1) * dp[m - 1];\n\n            next_dp[m] += sum;\n        }\n\n        dp = next_dp;\n    }\n\n    cout << dp[M] << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#include<iostream>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\n#define VI vector<int>\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=5005;\nconst int mod=1e9+7;\nvoid ad(int &x,int y){x+=y;if(x>=mod)x-=mod;}\nint f[MAXN][MAXN],n,m,bin[MAXN];\nint main()\n{\n\t#ifdef Rose\n\t\tdouble BeginJudgeTime=clock();\n\t#endif\n\tbin[0]=1;for(int i=1;i<MAXN;i++)bin[i]=(bin[i-1]<<1)%mod;\n\tn=read();m=read();\n\tfor(int i=1;i<=m;i++)f[1][i]=bin[i];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tint S=0;\n\t\tfor(int j=1;j<=m;j++)\n\t\t{\n\t\t\tS=2LL*S%mod;ad(S,1LL*f[i-1][j-1]*(j-1)%mod);\n\t\t\tf[i][j]=S;ad(f[i][j],1LL*f[i-1][j]*(j+1)%mod);\n\t\t}\n\t}pr2(f[n][m]);\n\treturn 0;\n\t#ifdef Rose\n\t\tdouble EndJudgeTime=clock();\n\t\tcerr<<\"JudgeTime is\"<<\" \";\n\t\tcerr<<(EndJudgeTime-BeginJudgeTime)/CLOCKS_PER_SEC<<endl;\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn=5005;\nconst int mod=1e9+7;\nint n,m;\nint f[maxn],sf[maxn],pw2[maxn],ipw2[maxn];\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tpw2[0]=ipw2[0]=1;\n\tfor(int i=1;i<=m;i++){\n\t\tpw2[i]=2LL*pw2[i-1]%mod;\n\t\tipw2[i]=1LL*ipw2[i-1]*(mod+1)/2%mod;\n\t}\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(!i)f[j]=1;\n\t\t\telse f[j]=(1LL*f[j]*(j+1)+(j>=2?1LL*sf[j-2]*pw2[j-2]:0))%mod;\n\t\t}\n\t\tfor(int j=0;j<=m;j++)\n\t\t\tsf[j]=((!j?0:sf[j-1])+1LL*f[j+1]*ipw2[j]%mod*(j+1))%mod;\n\t}\n\tprintf(\"%d\\n\",f[m]);\n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FSortingGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m; cin >> n >> m;\n      vector<mint> dp(n+1);\n      vector<mint> cumsum(n+1);\n\n      mint base = 2;\n      for(int j=1; j<=m; j++) {\n        dp[1] = base;\n        base *= 2;\n        for(int i=1; i<n; i++) {\n          dp[i+1] = cumsum[i+1] + dp[i]*(j+1);\n          cumsum[i+1] *= 2;\n          cumsum[i+1] += dp[i]*j;\n        }\n      }\n\n      cout << dp[n].x << endl;\n    }\n};\n\nsigned main() {\n  FSortingGame solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>> way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1,1,-1 };\nvel dy = { 1,-1,0,0,1,1 };\n#define all(a) a.begin(),a.end()\ntemplate<typename T>\nvoid mk_uni(V<T>& a) {\n\tstd::sort(a.begin(), a.end());\n\ta.erase(std::unique(a.begin(), a.end()), a.end());\n}\ntemplate <std::uint_fast64_t Modulus> class modint {\n\tusing u64 = std::uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr modint(const u64 x = 0) noexcept : a(x% Modulus) {}\n\tconstexpr u64& value() noexcept { return a; }\n\tconstexpr const u64& value() const noexcept { return a; }\n\tconstexpr modint operator+(const modint rhs) const noexcept {\n\t\treturn modint(*this) += rhs;\n\t}\n\tconstexpr modint operator-(const modint rhs) const noexcept {\n\t\treturn modint(*this) -= rhs;\n\t}\n\tconstexpr modint operator*(const modint rhs) const noexcept {\n\t\treturn modint(*this) *= rhs;\n\t}\n\tconstexpr modint operator/(const modint rhs) const noexcept {\n\t\treturn modint(*this) /= rhs;\n\t}\n\tconstexpr modint& operator+=(const modint rhs) noexcept {\n\t\ta += rhs.a;\n\t\tif (a >= Modulus) {\n\t\t\ta -= Modulus;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator-=(const modint rhs) noexcept {\n\t\tif (a < rhs.a) {\n\t\t\ta += Modulus;\n\t\t}\n\t\ta -= rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator*=(const modint rhs) noexcept {\n\t\ta = a * rhs.a % Modulus;\n\t\treturn *this;\n\t}\n\tconstexpr modint& operator/=(modint rhs) noexcept {\n\t\tu64 exp = Modulus - 2;\n\t\twhile (exp) {\n\t\t\tif (exp % 2) {\n\t\t\t\t*this *= rhs;\n\t\t\t}\n\t\t\trhs *= rhs;\n\t\t\texp /= 2;\n\t\t}\n\t\treturn *this;\n\t}\n};\nusing mint = modint<1000000007>;\nusing vem = vector<mint>;\nusing vvem = vector<vem>;\nmint mpow(mint a, int n) {\n\tmint ans = 1;\n\twhile (n) {\n\t\tif (n & 1) { ans *= a; }\n\t\ta *= a; n /= 2;\n\t}\n\treturn ans;\n}\nsigned main() {\n\tomajinai;\n\tmint a = 1000000000;\n\tcout << (a * 2).value() << endl;\n\tint n, m; cin >> n >> m;\n\tvvem dp(n + 1, vem(m + 1, 0));\n\tfor (int i = 1; i <= m; i++) {\n\t\tdp[1][i] = mpow(2, i);\n\t}\n\tfor (int i = 2; i <= n; i++) {\n\t\tmint sum = 0;\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tdp[i][j] += sum + dp[i - 1][j] * (j + 1);\n\t\t\tsum *= 2;\n\t\t\tsum += dp[i - 1][j] * j;\n\t\t}\n\t}\n\tcout << dp[n][m].value() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#line 1 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n#include <bits/extc++.h>\n\n#line 5 \"Library\\\\config.hpp\"\nnamespace config {\nconst auto start_time{std::chrono::system_clock::now()};\nint64_t elapsed() {\n  using namespace std::chrono;\n  const auto end_time{system_clock::now()};\n  return duration_cast<milliseconds>(end_time - start_time).count();\n}\n__attribute__((constructor)) void setup() {\n  using namespace std;\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  cout << fixed << setprecision(15);\n#ifdef _buffer_check\n  atexit([] {\n    char bufc;\n    if (cin >> bufc)\n      cerr << \"\\n\\033[43m\\033[30mwarning: buffer not empty.\\033[0m\\n\\n\";\n  });\n#endif\n}\nunsigned cases(void), caseid = 1;\ntemplate <class C> void main() {\n  for (const unsigned total = cases(); caseid <= total; ++caseid) C();\n}\n}  // namespace config\n#line 3 \"Library\\\\gcc_builtin.hpp\"\nnamespace workspace {\nconstexpr int clz32(const uint32_t &n) noexcept { return __builtin_clz(n); }\nconstexpr int clz64(const uint64_t &n) noexcept{ return __builtin_clzll(n); }\nconstexpr int ctz(const uint64_t &n) noexcept { return __builtin_ctzll(n); }\nconstexpr int popcnt(const uint64_t &n) noexcept { return __builtin_popcountll(n); }\n} // namespace workspace\n#line 2 \"Library\\\\gcc_option.hpp\"\n#ifdef ONLINE_JUDGE\n    #pragma GCC optimize(\"O3\")\n    #pragma GCC target(\"avx,avx2\")\n    #pragma GCC optimize(\"unroll-loops\")\n#endif\n#line 5 \"Library\\\\utils\\\\binary_search.hpp\"\nnamespace workspace {\n// binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, iter_type>, bool>,\n    iter_type>\nbinary_search(iter_type ok, iter_type ng, pred_type pred) {\n  assert(ok != ng);\n  __int128_t dist(ng - ok);\n  while (dist > 1 || dist < -1) {\n    iter_type mid(ok + dist / 2);\n    if (pred(mid))\n      ok = mid, dist -= dist / 2;\n    else\n      ng = mid, dist /= 2;\n  }\n  return ok;\n}\n// parallel binary search on discrete range.\ntemplate <class iter_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<iter_type>>,\n                     std::vector<bool>>,\n                 std::vector<iter_type>>\nbinary_search(std::vector<std::pair<iter_type, iter_type>> ends,\n              pred_type pred) {\n  std::vector<iter_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      iter_type mid(ok + (ng - ok) / 2);\n      if (mids[i] != mid) {\n        all_found = false;\n        mids[i] = mid;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n// binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<\n    std::is_convertible_v<std::invoke_result_t<pred_type, real_type>, bool>,\n    real_type>\nbinary_search(real_type ok, real_type ng, const real_type eps, pred_type pred) {\n  assert(ok != ng);\n  while (ok + eps < ng || ng + eps < ok) {\n    real_type mid{(ok + ng) / 2};\n    (pred(mid) ? ok : ng) = mid;\n  }\n  return ok;\n}\n// parallel binary search on real numbers.\ntemplate <class real_type, class pred_type>\nstd::enable_if_t<std::is_convertible_v<\n                     std::invoke_result_t<pred_type, std::vector<real_type>>,\n                     std::vector<bool>>,\n                 std::vector<real_type>>\nbinary_search(std::vector<std::pair<real_type, real_type>> ends,\n              const real_type eps, pred_type pred) {\n  std::vector<real_type> mids(ends.size());\n  for (;;) {\n    bool all_found = true;\n    for (size_t i{}; i != ends.size(); ++i) {\n      auto [ok, ng] = ends[i];\n      if (ok + eps < ng || ng + eps < ok) {\n        all_found = false;\n        mids[i] = (ok + ng) / 2;\n      }\n    }\n    if (all_found) break;\n    auto res = pred(mids);\n    for (size_t i{}; i != ends.size(); ++i) {\n      (res[i] ? ends[i].first : ends[i].second) = mids[i];\n    }\n  }\n  return mids;\n}\n}  // namespace workspace\n#line 3 \"Library\\\\utils\\\\casefmt.hpp\"\nnamespace workspace {\nstd::ostream &casefmt(std::ostream& os) { return os << \"Case #\" << config::caseid << \": \"; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\chval.hpp\"\nnamespace workspace {\ntemplate <class T, class Comp = std::less<T>> bool chle(T &x, const T &y, Comp comp = Comp()) { return comp(y, x) ? x = y, true : false; }\ntemplate <class T, class Comp = std::less<T>> bool chge(T &x, const T &y, Comp comp = Comp()) { return comp(x, y) ? x = y, true : false; }\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\fixed_point.hpp\"\nnamespace workspace {\n// specify the return type of lambda.\ntemplate <class lambda_type>\nclass fixed_point\n{\n    lambda_type func;\npublic:\n    fixed_point(lambda_type &&f) : func(std::move(f)) {}\n    template <class... Args> auto operator()(Args &&... args) const { return func(*this, std::forward<Args>(args)...); }\n};\n} // namespace workspace\n#line 2 \"Library\\\\utils\\\\sfinae.hpp\"\n#include <type_traits>\ntemplate <class type, template <class> class trait>\nusing enable_if_trait_type = typename std::enable_if<trait<type>::value>::type;\ntemplate <class Container>\nusing element_type = typename std::decay<decltype(\n    *std::begin(std::declval<Container&>()))>::type;\ntemplate <class T, class = void> struct is_integral_ext : std::false_type {};\ntemplate <class T>\nstruct is_integral_ext<\n    T, typename std::enable_if<std::is_integral<T>::value>::type>\n    : std::true_type {};\ntemplate <> struct is_integral_ext<__int128_t> : std::true_type {};\ntemplate <> struct is_integral_ext<__uint128_t> : std::true_type {};\n#line 7 \"Library\\\\utils\\\\hash.hpp\"\nnamespace workspace {\ntemplate <class T, class = void>\nstruct hash : std::hash<T> {};\ntemplate <class Unique_bits_type>\nstruct hash<Unique_bits_type, enable_if_trait_type<Unique_bits_type, std::has_unique_object_representations>>\n{\n    size_t operator()(uint64_t x) const\n    {\n        static const uint64_t m = std::random_device{}();\n        x ^= x >> 23;\n        // x *= 0x2127599bf4325c37ULL;\n        x ^= m;\n        x ^= x >> 47;\n        return x - (x >> 32);\n    }\n};\ntemplate <class Key>\nsize_t hash_combine(const size_t &seed, const Key &key)\n{\n    return seed ^ (hash<Key>()(key) + 0x9e3779b9 /* + (seed << 6) + (seed >> 2) */ );\n}\ntemplate <class T1, class T2>\nstruct hash<std::pair<T1, T2>>\n{\n    size_t operator()(const std::pair<T1, T2> &pair) const\n    {\n        return hash_combine(hash<T1>()(pair.first), pair.second);\n    }\n};\ntemplate <class... T>\nclass hash<std::tuple<T...>>\n{\n    template <class Tuple, size_t index = std::tuple_size<Tuple>::value - 1> struct tuple_hash { static uint64_t apply(const Tuple &t) { return hash_combine(tuple_hash<Tuple, index - 1>::apply(t), std::get<index>(t)); } };\n    template <class Tuple> struct tuple_hash<Tuple, size_t(-1)> { static uint64_t apply(const Tuple &t) { return 0; } };\npublic:\n    uint64_t operator()(const std::tuple<T...> &t) const { return tuple_hash<std::tuple<T...>>::apply(t); }\n};\ntemplate <class hash_table>\nstruct hash_table_wrapper : hash_table\n{\n    using key_type = typename hash_table::key_type;\n    size_t count(const key_type &key) const { return hash_table::find(key) != hash_table::end(); }\n    template <class... Args> auto emplace(Args&&... args) { return hash_table::insert(typename hash_table::value_type(args...)); }\n};\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing cc_hash_table = hash_table_wrapper<__gnu_pbds::cc_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped = __gnu_pbds::null_type>\nusing gp_hash_table = hash_table_wrapper<__gnu_pbds::gp_hash_table<Key, Mapped, hash<Key>>>;\ntemplate <class Key, class Mapped>\nusing unordered_map = std::unordered_map<Key, Mapped, hash<Key>>;\ntemplate <class Key>\nusing unordered_set = std::unordered_set<Key, hash<Key>>;\n} // namespace workspace\n#line 3 \"Library\\\\utils\\\\read.hpp\"\nnamespace workspace {\n// read with std::cin.\ntemplate <class T = void>\nstruct read\n{\n    typename std::remove_const<T>::type value;\n    template <class... types>\n    read(types... args) : value(args...) { std::cin >> value; }\n    operator T() const { return value; }\n};\ntemplate <>\nstruct read<void>\n{\n    template <class T>\n    operator T() const { T value; std::cin >> value; return value; }\n};\n} // namespace workspace\n#line 4 \"Library\\\\utils\\\\stream.hpp\"\n\n#line 6 \"Library\\\\utils\\\\stream.hpp\"\nnamespace std {\ntemplate <class T, class U> istream &operator>>(istream &is, pair<T, U> &p) {\n  return is >> p.first >> p.second;\n}\ntemplate <class T, class U>\nostream &operator<<(ostream &os, const pair<T, U> &p) {\n  return os << p.first << ' ' << p.second;\n}\ntemplate <class tuple_t, size_t index> struct tuple_is {\n  static istream &apply(istream &is, tuple_t &t) {\n    tuple_is<tuple_t, index - 1>::apply(is, t);\n    return is >> get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_is<tuple_t, SIZE_MAX> {\n  static istream &apply(istream &is, tuple_t &t) { return is; }\n};\ntemplate <class... T> istream &operator>>(istream &is, tuple<T...> &t) {\n  return tuple_is<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(is,\n                                                                          t);\n}\ntemplate <class tuple_t, size_t index> struct tuple_os {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    tuple_os<tuple_t, index - 1>::apply(os, t);\n    return os << ' ' << get<index>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, 0> {\n  static ostream &apply(ostream &os, const tuple_t &t) {\n    return os << get<0>(t);\n  }\n};\ntemplate <class tuple_t> struct tuple_os<tuple_t, SIZE_MAX> {\n  static ostream &apply(ostream &os, const tuple_t &t) { return os; }\n};\ntemplate <class... T> ostream &operator<<(ostream &os, const tuple<T...> &t) {\n  return tuple_os<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(os,\n                                                                          t);\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   istream &>::type\noperator>>(istream &is, Container &cont) {\n  for (auto &&e : cont) is >> e;\n  return is;\n}\ntemplate <class Container, typename Value = element_type<Container>>\ntypename enable_if<!is_same<typename decay<Container>::type, string>::value &&\n                       !is_same<typename decay<Container>::type, char *>::value,\n                   ostream &>::type\noperator<<(ostream &os, const Container &cont) {\n  bool head = true;\n  for (auto &&e : cont) head ? head = 0 : (os << ' ', 0), os << e;\n  return os;\n}\n}  // namespace std\n#line 13 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n\nnamespace workspace {\nconstexpr char eol = '\\n';\nusing namespace std;\nusing i64 = int_least64_t;\nusing p32 = pair<int, int>;\nusing p64 = pair<i64, i64>;\ntemplate <class T, class Comp = std::less<T>>\nusing priority_queue = std::priority_queue<T, std::vector<T>, Comp>;\ntemplate <class T> using stack = std::stack<T, std::vector<T>>;\nstruct solver;\n}  // namespace workspace\nint main() { config::main<workspace::solver>(); }\nunsigned config::cases() {\n  // return -1; // not specify\n  // int t; std::cin >> t; return t; // given\n  return 1;\n}\n\n#line 4 \"Library\\\\dev\\\\modint.hpp\"\n\n#line 6 \"Library\\\\dev\\\\modint.hpp\"\ntemplate <auto Mod = 0> struct modint {\n  static_assert(is_integral_ext<decltype(Mod)>::value);\n  static_assert(!(Mod < 0));\n  using mod_type =\n      typename std::conditional<bool(Mod),\n                                typename std::add_const<decltype(Mod)>::type,\n                                __int128_t>::type;\n  static mod_type mod;\n  using value_type = int;\n  constexpr static modint one() noexcept { return 1; }\n  constexpr operator value_type() const noexcept { return value; }\n  constexpr modint() noexcept = default;\n  template <class int_type,\n            typename std::enable_if<is_integral_ext<int_type>::value>::type * =\n                nullptr>\n  constexpr modint(int_type n) noexcept : value((n %= mod) < 0 ? mod + n : n) {}\n  constexpr modint operator++(int) noexcept {\n    modint t{*this};\n    return operator+=(1), t;\n  }\n  constexpr modint operator--(int) noexcept {\n    modint t{*this};\n    return operator-=(1), t;\n  }\n  constexpr modint &operator++() noexcept { return operator+=(1); }\n  constexpr modint &operator--() noexcept { return operator-=(1); }\n  constexpr modint operator-() const noexcept {\n    return value ? mod - value : 0;\n  }\n  constexpr modint &operator+=(const modint &rhs) noexcept {\n    return (value += rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator-=(const modint &rhs) noexcept {\n    return (value += mod - rhs.value) < mod ? 0 : value -= mod, *this;\n  }\n  constexpr modint &operator*=(const modint &rhs) noexcept {\n    return value = (uint_fast64_t)value * rhs.value % mod, *this;\n  }\n  constexpr modint &operator/=(const modint &rhs) noexcept {\n    return operator*=(rhs.inverse());\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  constexpr modint operator+(const modint &rhs) const noexcept {\n    return modint{*this} += rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  constexpr modint operator-(const modint &rhs) const noexcept {\n    return modint{*this} -= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  constexpr modint operator*(const modint &rhs) const noexcept {\n    return modint{*this} *= rhs;\n  }\n  template <class int_type>\n  constexpr\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  constexpr modint operator/(const modint &rhs) const noexcept {\n    return modint{*this} /= rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator+(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) + rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator-(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) - rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator*(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) * rhs;\n  }\n  template <class int_type>\n  constexpr friend\n      typename std::enable_if<is_integral_ext<int_type>::value, modint>::type\n      operator/(const int_type &lhs, const modint &rhs) noexcept {\n    return modint(lhs) / rhs;\n  }\n  constexpr modint inverse() const noexcept {\n    assert(value);\n    value_type a{mod}, b{value}, u{}, v{1}, t{};\n    while (b)\n      t = a / b, a ^= b ^= (a -= t * b) ^= b, u ^= v ^= (u -= t * v) ^= v;\n    return {u};\n  }\n  constexpr static modint pow(modint rhs, int_fast64_t e) noexcept {\n    if (e < 0) e = e % (mod - 1) + mod - 1;\n    modint res{1};\n    while (e) {\n      if (e & 1) res *= rhs;\n      rhs *= rhs, e >>= 1;\n    }\n    return res;\n  }\n  friend std::ostream &operator<<(std::ostream &os,\n                                  const modint &rhs) noexcept {\n    return os << rhs.value;\n  }\n  friend std::istream &operator>>(std::istream &is, modint &rhs) noexcept {\n    int_fast64_t value;\n    rhs = (is >> value, value);\n    return is;\n  }\n\n protected:\n  value_type value = 0;\n};\ntemplate <auto Mod> typename modint<Mod>::mod_type modint<Mod>::mod = Mod;\nusing modint_runtime = modint<0>;\n#line 33 \"atcoder-workspace\\\\nomura2020\\\\f\\\\f.cpp\"\n// #include \"atcoder/modint.hpp\"\n\nstruct workspace::solver {\n  using mint = modint<1000000007>;\n  // using mint = modint_runtime;\n  // using mint = atcoder::modint;\n\n  solver() {\n    // start here!\n    // mint::mod = 1e9 + 7;\n    // mint::set_mod(1e9 + 7);\n    int n, m;\n    cin >> n >> m;\n    vector<mint> dp(m + 1, 1);\n    for (int i = 0; i < n; i++) {\n      vector<mint> nx(m + 1);\n      for (int j = 0; j < m; j++) {\n        nx[j + 1] = nx[j] * 2 + j * dp[j];\n      }\n      for (int j = 0; j <= m; j++) {\n        nx[j] += dp[j] * (j + 1);\n      }\n      swap(dp, nx);\n    }\n    cout << dp[m] << \"\\n\";\n    // cout << dp[m].val() << \"\\n\";\n  }\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing R = __int128;\nusing pii = pair<int, int>;\ntemplate <class T>\nusing V = vector<T>;\ntemplate <class T>\nusing VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i, n) rep2(i, 0, n)\n#define rep2(i, m, n) for (int i = m; i < (n); i++)\n#define per(i, b) per2(i, 0, b)\n#define per2(i, a, b) for (int i = int(b) - 1; i >= int(a); i--)\n#define ALL(c) (c).begin(), (c).end()\n\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\n\ntemplate <class T, class U>\nvoid chmin(T& t, const U& u) {\n    if (t > u) t = u;\n}\ntemplate <class T, class U>\nvoid chmax(T& t, const U& u) {\n    if (t < u) t = u;\n}\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \",\" << p.second << \")\";\n    return os;\n}\n\ntemplate <class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"{\";\n    rep(i, v.size()) {\n        if (i) os << \",\";\n        os << v[i];\n    }\n    os << \"}\";\n    return os;\n}\n\n#ifdef LOCAL\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << H;\n    debug_out(T...);\n}\n#define debug(...) \\\n    cerr << __LINE__ << \" [\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#define dump(x) cerr << __LINE__ << \" \" << #x << \" = \" << (x) << endl\n#else\n#define debug(...) (void(0))\n#define dump(x) (void(0))\n#endif\n\ntemplate <unsigned int MOD>\nstruct ModInt {\n    using uint = unsigned int;\n    using ull = unsigned long long;\n    using M = ModInt;\n\n    uint v;\n\n    ModInt(ll _v = 0) { set_norm(_v % MOD + MOD); }\n    M& set_norm(uint _v) {  //[0, MOD * 2)->[0, MOD)\n        v = (_v < MOD) ? _v : _v - MOD;\n        return *this;\n    }\n\n    explicit operator bool() const { return v != 0; }\n    M operator+(const M& a) const { return M().set_norm(v + a.v); }\n    M operator-(const M& a) const { return M().set_norm(v + MOD - a.v); }\n    M operator*(const M& a) const { return M().set_norm(ull(v) * a.v % MOD); }\n    M operator/(const M& a) const { return *this * a.inv(); }\n    M& operator+=(const M& a) { return *this = *this + a; }\n    M& operator-=(const M& a) { return *this = *this - a; }\n    M& operator*=(const M& a) { return *this = *this * a; }\n    M& operator/=(const M& a) { return *this = *this / a; }\n    M operator-() const { return M() - *this; }\n    M& operator++(int) { return *this = *this + 1; }\n    M& operator--(int) { return *this = *this - 1; }\n\n    M pow(ll n) const {\n        if (n < 0) return inv().pow(-n);\n        M x = *this, res = 1;\n        while (n) {\n            if (n & 1) res *= x;\n            x *= x;\n            n >>= 1;\n        }\n        return res;\n    }\n\n    M inv() const {\n        ll a = v, b = MOD, p = 1, q = 0, t;\n        while (b != 0) {\n            t = a / b;\n            swap(a -= t * b, b);\n            swap(p -= t * q, q);\n        }\n        return M(p);\n    }\n\n    bool operator==(const M& a) const { return v == a.v; }\n    bool operator!=(const M& a) const { return v != a.v; }\n    friend ostream& operator<<(ostream& os, const M& a) { return os << a.v; }\n    static uint get_mod() { return MOD; }\n};\n\nusing Mint = ModInt<1000000007>;\n\nconst int MX = 5010;\nMint p2[MX];\nMint dp[MX][MX], prf[MX][MX];\n\nint main() {\n    p2[0] = 1;\n    rep(i, MX - 1) p2[i + 1] = p2[i] * 2;\n    int N, M;\n    cin >> N >> M;\n    for (int j = 1; j <= M; ++j) {\n        dp[0][j] = 1;\n        prf[0][j] = prf[0][j - 1] * 2 + j;\n    }\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            Mint a = dp[i - 1][j] * (j + 1);\n            dp[i][j] = a + prf[i - 1][j - 1];\n            prf[i][j] = prf[i][j - 1] * 2 + dp[i][j] * j;\n            /*\n                        for (int k = 1; k < j; ++k) {\n                            dp[i][j] += dp[i - 1][k] * k * p2[j - k - 1];\n                        }*/\n        }\n    }\n    cout << dp[N][M] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> void read(T &x){\n\tint f=0; x=0; char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar()) f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\tif(f) x=-x;\n}\n\nconst int N=5005,mod=1e9+7,inv2=(mod+1)/2;\nint f[N][N],s2[N][N],pw[N],ipw[N],n,m,ans;\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1) res=(ll)res*x%mod;\n\treturn res;\n}\nint mul(int x,int y){\n\treturn (ll)x*y%mod;\n}\nvoid add(int &x,int y){\n\tx=(x+y>=mod?x+y-mod:x+y);\n}\nint pw2(int x){\n\treturn x>=0?pw[x]:ipw[-x];\n}\n\nint main(){\n\tread(n),read(m);\n\tswap(n,m);\n\tpw[0]=ipw[0]=1;\n\trep(i,1,5000){\n\t\tpw[i]=mul(pw[i-1],2);\n\t\tipw[i]=mul(ipw[i-1],inv2);\n\t}\n\trep(i,1,n){\n\t\tf[0][i]=1;\n\t\ts2[0][i]=mul(i,pw2(-i));\n\t\tadd(s2[0][i],s2[0][i-1]);\n\t}\n\trep(i,1,m){\n\t\trep(j,1,n){\n\t\t\tf[i][j]=mul(j+1,f[i-1][j]);\n\t\t\tif(j>=2) add(f[i][j],mul(s2[i-1][j-1],pw2(j-1)));\n\t\t\ts2[i][j]=mul(f[i][j],mul(j,pw2(-j)));\n\t\t\tadd(s2[i][j],s2[i][j-1]);\n\t\t}\n\t}\n\tcout<<f[m][n]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing P = pair<ll, ll>;\n\nconstexpr long double PI = 3.14159265358979323846264338327950288L;\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr ll mod17 = 1e9+7;\nconstexpr ll mod19 = 1e9+9;\nconstexpr ll mod9 = 998244353;\nll mod = mod17;\n\n// Mod int libraries\ntemplate<typename T>\nT mod_pow(T a, ll x) {\n  T res = 1;\n  while(x > 0) {\n    if (x & 1) res *= a;\n    a *= a; x >>= 1;\n  }\n  return res;\n}\n\n// Mint32\nunordered_map<ll, ll> minvmap;\nll minv(ll a, ll m) {\n  auto k = a; auto p = minvmap[a]; if (p != 0) return p;\n  ll b = m, u = 1, v = 0;\n  while (b) { ll t = a/b; swap(a -= t*b, b); swap(u -= t*v, v); }\n  p = (u%m+m)%m; minvmap[k] = p; return p;\n}\n\nstruct mint {\n  ll x;\n  mint():x(0){}\n  mint(ll x):x((x%mod+mod)%mod){}\n  mint& fix() { x = (x%mod+mod)%mod; return *this;}\n  mint operator-() const { return mint(0) - *this;}\n  mint& operator+=(const mint& a){ if((x+=a.x)>=mod) x-=mod; return *this;}\n  mint& operator-=(const mint& a){ if((x+=mod-a.x)>=mod) x-=mod; return *this;}\n  mint& operator*=(const mint& a){ (x*=a.x)%=mod; return *this;}\n  mint& operator/=(const mint& a){ (x*=minv(a.x, mod))%=mod; return *this; }\n  mint operator+(const mint& a)const{ return mint(*this) += a;}\n  mint operator-(const mint& a)const{ return mint(*this) -= a;}\n  mint operator*(const mint& a)const{ return mint(*this) *= a;}\n  mint operator/(const mint& a)const{ return mint(*this) /= a;}\n  bool operator<(const mint& a)const{ return x < a.x;}\n  bool operator==(const mint& a)const{ return x == a.x;}\n};\n\n// Mint64\nstruct mint64 {\n    ull x;\n    static ull mod, inv, r2;\n    mint64(): x(0){}\n    mint64(ull x): x(init(x)) {}\n    static ull init(ull x) { return reduce(__uint128_t(x)*r2);}\n    static void set_mod(ull m) {\n      mod = inv = m;\n      for(int i=0; i<5; i++) inv *= 2 - inv*m;\n      r2 = -__uint128_t(m)%m;\n    }\n    static ull reduce(__uint128_t x) {\n      ull y = ull(x >> 64) - ull((__uint128_t(ull(x)*inv)*mod)>>64);\n      return ll(y) < 0 ? y+mod : y;\n    }\n    mint64& operator+=(mint64& a) { x+=a.x-mod; if(ll(x)<0) x+=mod; return *this; }\n    mint64 operator+(mint64& a) const{ return mint64(*this)+=a; }\n    mint64& operator*=(mint64& a) { x=reduce(__uint128_t(x)*a.x); return *this; }\n    mint64 operator*(mint64& a) const { return mint64(*this)*=a; }\n};\n\null mint64::mod, mint64::inv, mint64::r2;\n\n// Verify: https://yukicoder.me/submissions/472580\nstruct Miller {\n    const vector<ull> v = {2, 325, 9375, 28178, 450775, 9780504, 1795265022};\n    bool suspect(ull a, ull s, ull d, ull n) {\n      if (mint64::mod != n) mint64::set_mod(n);\n      mint64 one = 1, minusone = n-1, ma = a;\n      auto x = mod_pow(ma, d);\n      if (x.x == one.x) return true;\n      for(int r = 0; r < s; r++) {\n        if (x.x == minusone.x) return true;\n        x = x * x;\n      }\n      return false;\n    }\n\n    // check if n is prime\n    bool check(ull n) {\n      if (n < 2 || (n > 2 && n % 2 == 0)) return false;\n      ull d = n - 1;\n      ull s = 0;\n      while (!(d & 1)) {\n        d >>= 1;\n        s++;\n      }\n      for (auto a: v) {\n        if (a >= n) break;\n        if (!suspect(a, s, d, n)) return false;\n      }\n      return true;\n    }\n};\n\nclass combination {\n    // factorial\n    public: std::vector<mint> fact;\n    public: std::vector<mint> inv;\n\n    combination(int n) {\n      fact.resize(n + 1);\n      inv.resize(n + 1);\n      fact[0] = 1;\n      for (int i = 1; i <= n; i++) {\n        fact[i] = fact[i - 1] * i;\n      }\n      inv[n] = mint(1) / fact[n];\n      for (int i = n - 1; i >= 0; i--) {\n        inv[i] = inv[i + 1] * (i + 1);\n      }\n    }\n\n    // nCr\n    public: mint get(int n, int r) {\n      if (n < r || n < 0 || r < 0) return 0;\n      return fact[n]*inv[r]*inv[n-r];\n    }\n    // nPr\n    public: mint p(int n, int r) {\n      if (n < r || n < 0) return 0;\n      return fact[n]*inv[n-r];\n    }\n};\n\n\nclass FSortingGame {\npublic:\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, m; cin >> n >> m;\n      vector<vector<mint>> dp(n+1, vector<mint>(m+1));\n      mint base = 1;\n      vector<mint> cumsum(n+1);\n      rep(j, m) {\n        base *= 2;\n        dp[1][j+1] = base;\n      }\n\n      for(int j=1; j<=m; j++) {\n        for(int i=1; i<n; i++) {\n          dp[i+1][j] = cumsum[i+1] + dp[i][j] * (j+1);\n          cumsum[i+1] *= 2;\n          cumsum[i+1] += dp[i][j]*j;\n        }\n      }\n\n      cout << dp[n][m].x << endl;\n    }\n};\n\nsigned main() {\n  FSortingGame solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define re register\nint f[5010],inv[5010];\nconst int mod=1e9+7;\nint main()\n{\n\tre int n,m,c=1;\n\tscanf(\"%d%d\",&n,&m);\n\tinv[1]=1;\n\tfor(re int i=2;i<=m;i++)inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;\n\tfor(re int i=1;i<=m;i++)\n\t{\n\t\tf[i]=c;\n\t\tc=1ll*c*(m-i)%mod*inv[i]%mod;\n\t}\n\tfor(re int i=1;i<=n;i++)\n\t{\n\t\tre int num=0;\n\t\tfor(re int j=m;j>=1;j--)\n\t\t{\n\t\t\tre int xx=f[j];\n\t\t\tf[j]=(1ll*(j+1)*f[j]+2ll*j*num)%mod;\n\t\t\tnum=(num+xx)%mod;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",f[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\nusing namespace std;\nlong long n,m,i,j,f[5005][5005],sum;\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tf[0][m]=1;\n\tfor(i=1;i<=n;i++)\n\t\tfor(sum=0,j=m;j>=1;j--){\n\t\t\tf[i][j]=(sum*j+f[i-1][j]*(j+1))%mo;\n\t\t\tsum=(sum*2+f[i-1][j])%mo;\n\t\t}\n\tfor(i=1,sum=0;i<=m;i++)\n\t\tsum=(sum+f[n][i])%mo;\n\tprintf(\"%lld\\n\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\nusing Int = long long;\nconst char newl = '\\n';\n\n\ntemplate<typename T,T MOD = 1000000007>\nstruct Mint{\n  static constexpr T mod = MOD;\n  T v;\n  Mint():v(0){}\n  Mint(signed v):v(v){}\n  Mint(long long t){v=t%MOD;if(v<0) v+=MOD;}\n\n  Mint pow(long long k){\n    Mint res(1),tmp(v);\n    while(k){\n      if(k&1) res*=tmp;\n      tmp*=tmp;\n      k>>=1;\n    }\n    return res;\n  }\n\n  static Mint add_identity(){return Mint(0);}\n  static Mint mul_identity(){return Mint(1);}\n\n  Mint inv(){return pow(MOD-2);}\n\n  Mint& operator+=(Mint a){v+=a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator-=(Mint a){v+=MOD-a.v;if(v>=MOD)v-=MOD;return *this;}\n  Mint& operator*=(Mint a){v=1LL*v*a.v%MOD;return *this;}\n  Mint& operator/=(Mint a){return (*this)*=a.inv();}\n\n  Mint operator+(Mint a) const{return Mint(v)+=a;}\n  Mint operator-(Mint a) const{return Mint(v)-=a;}\n  Mint operator*(Mint a) const{return Mint(v)*=a;}\n  Mint operator/(Mint a) const{return Mint(v)/=a;}\n\n  Mint operator-() const{return v?Mint(MOD-v):Mint(v);}\n\n  bool operator==(const Mint a)const{return v==a.v;}\n  bool operator!=(const Mint a)const{return v!=a.v;}\n  bool operator <(const Mint a)const{return v <a.v;}\n\n  static Mint comb(long long n,int k){\n    Mint num(1),dom(1);\n    for(int i=0;i<k;i++){\n      num*=Mint(n-i);\n      dom*=Mint(i+1);\n    }\n    return num/dom;\n  }\n};\ntemplate<typename T,T MOD> constexpr T Mint<T, MOD>::mod;\ntemplate<typename T,T MOD>\nostream& operator<<(ostream &os,Mint<T, MOD> m){os<<m.v;return os;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\n\nusing M = Mint<int>;\nconst int MAX = 5050;\nM po[MAX],op[MAX];\n\n\nM dfs(int h,int w);\n\nM dp2[MAX][MAX];\nint used2[MAX][MAX]={};\nM sum(int h,int w){\n  M &res=dp2[h][w];\n  if(used2[h][w]) return res;\n  used2[h][w]=1;\n\n  res=M(0);\n  if(w>0) res+=sum(h,w-1);\n  res+=dfs(h,w)*op[w+1]*M(w);\n  return res;\n}\n\nM dp[MAX][MAX];\nint used[MAX][MAX]={};\nM dfs(int h,int w){\n  M &res=dp[h][w];\n  if(used[h][w]) return res;\n  used[h][w]=1;\n\n  assert(h>=0 and w>=0);\n  if(h==0 or w==0) return res=M(1);\n  if(w==1) return res=po[h];\n  if(h==1) return res=po[w];\n\n  res=M(0);\n  res+=dfs(h-1,w)*M(w+1);\n  res+=sum(h-1,w-1)*po[w];\n  return res;\n};\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  int n,m;\n  cin>>n>>m;\n  po[0]=op[0]=M(1);\n  for(int i=0;i+1<MAX;i++) po[i+1]=po[i]*M(2);\n  for(int i=0;i+1<MAX;i++) op[i+1]=op[i]*M(2).inv();\n\n  cout<<dfs(n,m)<<newl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 5005;\nconst int P = 1e9 + 7;\ntypedef long long ll;\ntemplate <typename T> void chkmax(T &x, T y) {x = max(x, y); }\ntemplate <typename T> void chkmin(T &x, T y) {x = min(x, y); } \ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nvoid update(int &x, int y) {\n\tx += y;\n\tif (x >= P) x -= P;\n}\nint power(int x, int y) {\n\tif (y == 0) return 1;\n\tint tmp = power(x, y / 2);\n\tif (y % 2 == 0) return 1ll * tmp * tmp % P;\n\telse return 1ll * tmp * tmp % P * x % P;\n}\nint dp[MAXN][MAXN];\nint main() {\n\tint n, m; read(n), read(m);\n\tfor (int i = 1; i <= m; i++)\n\t\tdp[0][i] = 1;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = 1; j <= m; j++) {\n\t\tupdate(dp[i][j], 1ll * dp[i - 1][j] * (j + 1) % P);\n\t\tfor (int k = 2; k <= j; k++)\n\t\t\tupdate(dp[i][j], 1ll * dp[i - 1][j - k + 1] * (j - k + 1) % P * power(2, k - 2) % P);\n\t}\n\tcout << dp[n][m] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "wakruwakewwwwwwwwwwwwwwwwwwwww"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC optimize(\"O3\")\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007LL\n#define VERYBIG 2000000000000000007LL\n#define ULTRABIG 300000000000000000000LL\n\n#define MOD 1000000007LL\n#define FOD  998244353LL\n#define HOD 1000000009LL\n#define IOD  100000007LL\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n// #include <functional>\n// #include <array>\n#include <iostream>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n// using std::get;\n// using std::function;\n// using std::array;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nvoid uw (ull *l, ull *r) {\n\tif (*l == *r) return;\n\tull t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 10], invf[N_MAX * 10];\nvoid f_init (sll n, sll m) {\n\tfrac[0] = 1;\n\tfor (sll i = 1; i <= n; i++) {\n\t\tfrac[i] = frac[i - 1] * i % m;\n\t}\n\n\tinvf[n] = divide(1, frac[n], m);\n\tfor (sll i = n - 1; i >= 0; i--) {\n\t\tinvf[i] = invf[i + 1] * (i + 1) % m;\n\t}\n}\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX * 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX * 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX * 5];\nsll d[N_MAX * 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 4];\nhwllc tup[N_MAX * 4];\n// sll table[3005][3005];\nsll table[2005][2005];\null gin[N_MAX];\n// here we go\n\null parent[201910], size[201910], edges[201910];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t\tedges[i] = 0;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull v, ull u) {\n\tv = find(v);\n\tu = find(u);\n\n\tedges[v]++;\n\n\tif (v == u) return false;\n\n\tif (size[v] < size[u]) {\n\t\tull tmp = v;\n\t\tv = u;\n\t\tu = tmp;\n\t}\n\tsize[v] += size[u];\n\tedges[v] += edges[u];\n\tparent[u] = v;\n\treturn true;\n}\n\nsll us[N_MAX], ulen = 0;\n\nsll dp[5050][5050], dq[5050][5050];\n\nsll pow2[N_MAX], inv2[N_MAX];\n\nsll solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\t// f_init(n * 5 + 5);\n\n\tconst sll inv = (MOD + 1) / 2;\n\n\tpow2[0] = 1;\n\tinv2[0] = 1;\n\tfor (i = 1; i <= n + m; i++) {\n\t\tpow2[i] = (pow2[i - 1] * 2) % MOD;\n\t\tinv2[i] = (inv2[i - 1] * inv) % MOD;\n\t}\n\n\tfor (i = 0; i <= n; i++) {\n\n\t\tfor (j = 1; j <= m; j++) {\n\t\t\tif (i == 0) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = ((j + 1) * dp[i - 1][j] + dq[i - 1][j - 1] * pow2[j - 1]) % MOD;\n\t\t\t}\n\n\t\t\tdq[i][j] = (dq[i][j - 1] + (dp[i][j] * j % MOD) * inv2[j]) % MOD;\n\t\t\t\n\n\t\t\t// printf(\"%lld %lld: %lld %lld\\n\", i, j, dp[i][j], dq[i][j]);\n\t\t}\n\t}\n\tresult = dp[n][m];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\th = 5;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%lld\", &w);\n\t// scanf(\"%lld%lld\", &h, &w);\n\tscanf(\"%lld%lld\", &n, &m);\n\t// scanf(\"%lld\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%lld\", &k);\n\t// scanf(\"%lld\", &m);\n\t// scanf(\"%lld\", &n);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%s\", s[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// }\n\t// scanf(\" %c\", &ch);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%lld%lld\", &va, &vb);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// scanf(\"%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \tc[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", t[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &e[i], &c[i], &d[i]);\n\t// \tc[i]--;\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n// #pragma GCC optimize(\"unroll-loops\")\n// #pragma GCC optimize(\"O3\")\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007LL\n#define VERYBIG 2000000000000000007LL\n#define ULTRABIG 300000000000000000000LL\n\n#define MOD 1000000007LL\n#define FOD  998244353LL\n#define HOD 1000000009LL\n#define IOD  100000007LL\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n// #include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n// #include <functional>\n// #include <array>\n#include <iostream>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\n// using std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n// using std::get;\n// using std::function;\n// using std::array;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\nvoid uw (ull *l, ull *r) {\n\tif (*l == *r) return;\n\tull t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 10], invf[N_MAX * 10];\nvoid f_init (sll n, sll m) {\n\tfrac[0] = 1;\n\tfor (sll i = 1; i <= n; i++) {\n\t\tfrac[i] = frac[i - 1] * i % m;\n\t}\n\n\tinvf[n] = divide(1, frac[n], m);\n\tfor (sll i = n - 1; i >= 0; i--) {\n\t\tinvf[i] = invf[i + 1] * (i + 1) % m;\n\t}\n}\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX * 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX * 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX * 5];\nsll d[N_MAX * 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX * 4];\nhwllc tup[N_MAX * 4];\n// sll table[3005][3005];\nsll table[2005][2005];\null gin[N_MAX];\n// here we go\n\null parent[201910], size[201910], edges[201910];\nvoid init (ull n) {\n\tfor (sll i = 0; i < n; i++) {\n\t\tparent[i] = i;\n\t\tsize[i] = 1;\n\t\tedges[i] = 0;\n\t}\n}\null find (ull x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = find(parent[x]);\n}\nbool unite (ull v, ull u) {\n\tv = find(v);\n\tu = find(u);\n\n\tedges[v]++;\n\n\tif (v == u) return false;\n\n\tif (size[v] < size[u]) {\n\t\tull tmp = v;\n\t\tv = u;\n\t\tu = tmp;\n\t}\n\tsize[v] += size[u];\n\tedges[v] += edges[u];\n\tparent[u] = v;\n\treturn true;\n}\n\nsll us[N_MAX], ulen = 0;\n\nsll dp[5050][5050], dq[5050][5050];\n\nsll solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\t// f_init(n * 5 + 5);\n\n\n\tfor (i = 0; i <= n; i++) {\n\n\t\tfor (j = 1; j <= m; j++) {\n\t\t\tif (i == 0) {\n\t\t\t\tdp[i][j] = 1;\n\t\t\t} else {\n\t\t\t\tdp[i][j] = ((j + 1) * dp[i - 1][j] + dq[i - 1][j - 1] * bitpow(2, j - 1, MOD)) % MOD;\n\t\t\t}\n\n\t\t\tdq[i][j] = (dq[i][j - 1] + divide(\n\t\t\t\tdp[i][j] * j % MOD,\n\t\t\t\tbitpow(2, j, MOD), MOD)) % MOD;\n\t\t\t\n\n\t\t\t// printf(\"%lld %lld: %lld %lld\\n\", i, j, dp[i][j], dq[i][j]);\n\t\t}\n\t}\n\tresult = dp[n][m];\n\n\tprintf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 3;\n\tm = 0;\n\th = 5;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%lld\", &w);\n\t// scanf(\"%lld%lld\", &h, &w);\n\tscanf(\"%lld%lld\", &n, &m);\n\t// scanf(\"%lld\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%lld\", &k);\n\t// scanf(\"%lld\", &m);\n\t// scanf(\"%lld\", &n);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%s\", s[i]);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// }\n\t// scanf(\" %c\", &ch);\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < 0; i++) {\n\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// scanf(\"%lld\", &e[i]);\n\t\ta[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%lld%lld\", &va, &vb);\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", t);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// \t// scanf(\"%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \tc[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%s\", t[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld%lld\", &e[i], &c[i], &d[i]);\n\t// \tc[i]--;\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tstatic final long MOD = 1000000007;\n\tstatic long[][] table;\n\tstatic long[][] table2;\n\tstatic int N, M;\n\tstatic long[] pot2, invPot2;\n\t\n\tstatic long calc(int rem, int bits) {\n\t\tlong ret = table[rem][bits];\n\t\tif (ret != -1) return ret;\n\t\tif (bits == 1) return table[rem][bits] = pot2[rem];\n\t\tret = (calc2(rem - 1, bits - 1) * pot2[rem]) % MOD;\n\t\tret += (rem + 1) * calc(rem, bits - 1);\n\t\tret %= MOD;\n\t\treturn table[rem][bits] = ret;\n\t}\n\t\n\tstatic long calc2(int rem, int bits) {\n\t\tlong ret = table2[rem][bits];\n\t\tif (ret != -1) return ret;\n\t\tif (rem == 0) return table2[rem][bits] = 0;\n\t\tret = calc2(rem - 1, bits);\n\t\tlong tmp = (rem * calc(rem, bits)) % MOD;\n\t\ttmp = (tmp * invPot2[rem + 1]) % MOD;\n\t\tret = (ret + tmp) % MOD;\n\t\treturn table2[rem][bits] = ret;\n\t}\n\t\n\tstatic long eleva(long a, int e) {\n\t\tif (e == 0) return 1;\n\t\tlong ret = eleva(a, e / 2);\n\t\tret = (ret * ret) % MOD;\n\t\tif (e % 2 == 1) {\n\t\t\tret = (ret * a) % MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic long inv(long a) {\n\t\treturn eleva(a, (int)MOD - 2);\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tMyScanner sc = new MyScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tpot2 = new long[M + 1];\n\t\tinvPot2 = new long[M + 1];\n\t\tpot2[0] = 1;\n\t\tfor (int i = 1; i < pot2.length; i++) {\n\t\t\tpot2[i] = (pot2[i-1] * 2) % MOD;\n\t\t}\n\t\tinvPot2[pot2.length - 1] = inv(pot2[pot2.length - 1]);\n\t\tfor (int i = pot2.length - 2; i >= 0; i--) {\n\t\t\tinvPot2[i] = (invPot2[i+1] * 2) % MOD;\n\t\t}\n\t\ttable = new long[M+1][N+1];\n\t\ttable2 = new long[M+1][N+1];\n\t\tfor (int i = 0; i < table.length; i++) {\n\t\t\tArrays.fill(table[i], -1);\n\t\t\tArrays.fill(table2[i], -1);\n\t\t}\n\t\tout.println(calc(M, N));\n\t\t\n\t\tout.flush();\n\t}\n\t\n\tstatic class MyScanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tokenizer;\n\t\t\n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "#region いつもの\nusing AtCoderProject;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static AtCoderProject.Global;\nusing BigInteger = System.Numerics.BigInteger;\nusing BitOperations = System.Numerics.BitOperations;\nusing IEnumerable = System.Collections.IEnumerable;\nusing IEnumerator = System.Collections.IEnumerator;\nusing StringBuilder = System.Text.StringBuilder;\nusing Unsafe = System.Runtime.CompilerServices.Unsafe;\n\nnamespace AtCoderProject { using System.IO; using System.Text; using System.Diagnostics; using System.Runtime.CompilerServices; using System.Linq.Expressions; public static class Global { public static T[] NewArray<T>(int len0, T value) => new T[len0].Fill(value); public static T[] NewArray<T>(int len0, Func<T> factory) { var arr = new T[len0]; for (int i = 0; i < arr.Length; i++) arr[i] = factory(); return arr; } public static T[][] NewArray<T>(int len0, int len1, T value) where T : struct { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, value); return arr; } public static T[][] NewArray<T>(int len0, int len1, Func<T> factory) { var arr = new T[len0][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, factory); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, T value) where T : struct { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, value); return arr; } public static T[][][] NewArray<T>(int len0, int len1, int len2, Func<T> factory) { var arr = new T[len0][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, factory); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, T value) where T : struct { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, value); return arr; } public static T[][][][] NewArray<T>(int len0, int len1, int len2, int len3, Func<T> factory) { var arr = new T[len0][][][]; for (int i = 0; i < arr.Length; i++) arr[i] = NewArray(len1, len2, len3, factory); return arr; } public static int Pow(int x, int y) { int res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static BigInteger ParseBigInteger(ReadOnlySpan<char> s) { /* 自前実装の方が速い */ BigInteger res; if (s.Length % 9 == 0) res = 0; else { res = new BigInteger(int.Parse(s.Slice(0, s.Length % 9))); s = s.Slice(s.Length % 9); } while (s.Length > 0) { var sp = s.Slice(0, 9); res *= 1000_000_000; res += int.Parse(sp); s = s.Slice(9); } return res; } public static int PopCount(int x) => BitOperations.PopCount((uint)x); public static int PopCount(long x) => BitOperations.PopCount((ulong)x); public static int PopCount(ulong x) => BitOperations.PopCount(x); public static int MSB(int x) => BitOperations.Log2((uint)x); public static int MSB(uint x) => BitOperations.Log2(x); public static int MSB(long x) => BitOperations.Log2((ulong)x); public static int MSB(ulong x) => BitOperations.Log2(x); public static int LSB(int x) => BitOperations.TrailingZeroCount((uint)x); public static int LSB(uint x) => BitOperations.TrailingZeroCount(x); public static int LSB(long x) => BitOperations.TrailingZeroCount((ulong)x); public static int LSB(ulong x) => BitOperations.TrailingZeroCount(x); } public static class Ext { public static bool UpdateMax(this ref int r, int val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMax(this ref long r, long val) { if (r < val) { r = val; return true; } return false; } public static bool UpdateMin(this ref int r, int val) { if (r > val) { r = val; return true; } return false; } public static bool UpdateMin(this ref long r, long val) { if (r > val) { r = val; return true; } return false; } public static long ToLong(this int i) => i; public static T[] Fill<T>(this T[] arr, T value) { Array.Fill(arr, value); return arr; } public static T[] Sort<T>(this T[] arr) { Array.Sort(arr); return arr; } public static string[] Sort(this string[] arr) => Sort(arr, StringComparer.OrdinalIgnoreCase); public static T[] Sort<T, U>(this T[] arr, Expression<Func<T, U>> selector) where U : IComparable<U> => Sort(arr, new ExpComparer<T, U>(selector)); public static T[] Sort<T>(this T[] arr, Comparison<T> comparison) { Array.Sort(arr, comparison); return arr; } public static T[] Sort<T>(this T[] arr, IComparer<T> comparer) { Array.Sort(arr, comparer); return arr; } public static T[] Reverse<T>(this T[] arr) { Array.Reverse(arr); return arr; } public static (int index, T max) MaxBy<T>(this T[] arr) where T : IComparable<T> { T max = arr[0]; int maxIndex = 0; for (int i = 0; i < arr.Length; i++) { if (max.CompareTo(arr[i]) < 0) { max = arr[i]; maxIndex = i; } } return (maxIndex, max); } public static (TSource item, TMax max) MaxBy<TSource, TMax>(this IEnumerable<TSource> source, Func<TSource, TMax> maxBySelector) where TMax : IComparable<TMax> { TMax max; TSource maxByItem; var e = source.GetEnumerator(); e.MoveNext(); maxByItem = e.Current; max = maxBySelector(maxByItem); while (e.MoveNext()) { var item = e.Current; var next = maxBySelector(item); if (max.CompareTo(next) < 0) { max = next; maxByItem = item; } } return (maxByItem, max); } public static (int index, T min) MinBy<T>(this T[] arr) where T : IComparable<T> { T min = arr[0]; int minIndex = 0; for (int i = 0; i < arr.Length; i++) { if (min.CompareTo(arr[i]) > 0) { min = arr[i]; minIndex = i; } } return (minIndex, min); } public static (TSource item, TMin min) MinBy<TSource, TMin>(this IEnumerable<TSource> source, Func<TSource, TMin> minBySelector) where TMin : IComparable<TMin> { TMin min; TSource minByItem; var e = source.GetEnumerator(); e.MoveNext(); minByItem = e.Current; min = minBySelector(minByItem); while (e.MoveNext()) { var item = e.Current; var next = minBySelector(item); if (min.CompareTo(next) > 0) { min = next; minByItem = item; } } return (minByItem, min); } public static IComparer<T> Reverse<T>(this IComparer<T> comparer) => Comparer<T>.Create((x, y) => comparer.Compare(y, x)); public static Dictionary<TKey, int> GroupCount<TSource, TKey>(this IEnumerable<TSource> source, Func<TSource, TKey> keySelector) => source.GroupBy(keySelector).ToDictionary(g => g.Key, g => g.Count()); public static Dictionary<TKey, int> GroupCount<TKey>(this IEnumerable<TKey> source) => source.GroupCount(i => i); public static ref T Get<T>(this T[] arr, int index) { if (index < 0) return ref arr[arr.Length + index]; return ref arr[index]; } public static TValue Get<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key) { dic.TryGetValue(key, out var v); return v; } public static TValue GetOrInit<TKey, TValue>(this IDictionary<TKey, TValue> dic, TKey key, TValue value) { if (dic.TryGetValue(key, out var v)) return v; return dic[key] = value; } } public class ExpComparer<T, K> : IComparer<T> where K : IComparable<K> { private class ParameterReplaceVisitor : ExpressionVisitor { private readonly ParameterExpression from; private readonly ParameterExpression to; public ParameterReplaceVisitor(ParameterExpression from, ParameterExpression to) { this.from = from; this.to = to; } protected override Expression VisitParameter(ParameterExpression node) => node == from ? to : base.VisitParameter(node); } private readonly Func<T, T, int> func; public ExpComparer(Expression<Func<T, K>> expression) { var paramA = expression.Parameters[0]; var paramB = Expression.Parameter(typeof(T)); var f2 = (Expression<Func<T, K>>)new ParameterReplaceVisitor(expression.Parameters[0], paramB).Visit(expression); var compExp = Expression.Lambda<Func<T, T, int>>(Expression.Call(expression.Body, typeof(K).GetMethod(nameof(IComparable<K>.CompareTo), new[] { typeof(K) }), f2.Body), paramA, paramB); this.func = compExp.Compile(); } public int Compare(T x, T y) => func(x, y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ReverseComparer<T> : IComparer<T> where T : IComparable<T> { private static ReverseComparer<T> defaultComparer; public static IComparer<T> Default => defaultComparer ??= new ReverseComparer<T>(); public int Compare(T y, T x) => x.CompareTo(y); public override bool Equals(object obj) => obj != null && GetType() == obj.GetType(); public override int GetHashCode() => GetType().GetHashCode(); } public class ΔDebugView<T> { private IEnumerable<T> collection; public ΔDebugView(IEnumerable<T> collection) { this.collection = collection ?? throw new ArgumentNullException(nameof(collection)); }[DebuggerBrowsable(DebuggerBrowsableState.RootHidden)] public T[] Items => collection.ToArray(); }[DebuggerStepThrough] public class ConsoleReader { const int BufSize = 1 << 12; private readonly byte[] buffer = new byte[BufSize]; private readonly Stream input; private readonly Encoding encoding; private int pos = 0; private int len = 0; public ConsoleReader(Stream input, Encoding encoding) { this.input = input; this.encoding = encoding; } public ConsoleReader(Stream input) : this(input, Console.InputEncoding) { } private void MoveNext() { if (++pos >= len) { len = input.Read(buffer, 0, buffer.Length); if (len == 0) { buffer[0] = 10; } pos = 0; } } public int Int { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { int res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = checked(res * 10 + (buffer[pos] ^ 48)); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public int Int0 => this.Int - 1; public long Long { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { long res = 0; bool neg = false; while (buffer[pos] < 48) { neg = buffer[pos] == 45; MoveNext(); } do { res = res * 10 + (buffer[pos] ^ 48); MoveNext(); } while (48 <= buffer[pos]); return neg ? -res : res; } } public long Long0 => this.Long - 1; public string String { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return this.encoding.GetString(sb.ToArray()); } } public string Ascii { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new StringBuilder(); while (buffer[pos] <= 32) MoveNext(); do { sb.Append((char)buffer[pos]); MoveNext(); } while (32 < buffer[pos]); return sb.ToString(); } } public string Line { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { var sb = new List<byte>(); while (buffer[pos] <= 32) MoveNext(); do { sb.Add(buffer[pos]); MoveNext(); } while (buffer[pos] != 10 && buffer[pos] != 13); return this.encoding.GetString(sb.ToArray()); } } public char Char { [MethodImpl(MethodImplOptions.AggressiveInlining)] get { while (buffer[pos] <= 32) MoveNext(); char res = (char)buffer[pos]; MoveNext(); return res; } } public double Double => double.Parse(this.Ascii);[DebuggerStepThrough] public struct RepeatReader { ConsoleReader cr; int count; public RepeatReader(ConsoleReader cr, int count) { this.cr = cr; this.count = count; } public T[] Select<T>(Func<ConsoleReader, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr); return arr; } public T[] Select<T>(Func<ConsoleReader, int, T> factory) { var arr = new T[count]; for (var i = 0; i < count; i++) arr[i] = factory(cr, i); return arr; } public string[] Line { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Line; return arr; } } public string[] String { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.String; return arr; } } public string[] Ascii { get { var arr = new string[count]; for (var i = 0; i < count; i++) arr[i] = cr.Ascii; return arr; } } public int[] Int { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int; return arr; } } public int[] Int0 { get { var arr = new int[count]; for (var i = 0; i < count; i++) arr[i] = cr.Int0; return arr; } } public long[] Long { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long; return arr; } } public long[] Long0 { get { var arr = new long[count]; for (var i = 0; i < count; i++) arr[i] = cr.Long0; return arr; } } public double[] Double { get { var arr = new double[count]; for (var i = 0; i < count; i++) arr[i] = cr.Double; return arr; } } public static implicit operator int[](RepeatReader rr) => rr.Int; public static implicit operator long[](RepeatReader rr) => rr.Long; public static implicit operator double[](RepeatReader rr) => rr.Double; public static implicit operator string[](RepeatReader rr) => rr.Ascii; } public RepeatReader Repeat(int count) => new RepeatReader(this, count);[DebuggerStepThrough] public struct SplitReader { ConsoleReader cr; public SplitReader(ConsoleReader cr) { this.cr = cr; } public string[] String { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.String); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public string[] Ascii { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<string>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Ascii); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public int[] Int0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<int>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Int0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public long[] Long0 { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<long>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Long0); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public double[] Double { get { while (cr.buffer[cr.pos] <= 32) cr.MoveNext(); var list = new List<double>(); do { if (cr.buffer[cr.pos] < 32) cr.MoveNext(); else list.Add(cr.Double); } while (cr.buffer[cr.pos] != 10 && cr.buffer[cr.pos] != 13); return list.ToArray(); } } public static implicit operator int[](SplitReader sr) => sr.Int; public static implicit operator long[](SplitReader sr) => sr.Long; public static implicit operator double[](SplitReader sr) => sr.Double; public static implicit operator string[](SplitReader sr) => sr.Ascii; } public SplitReader Split => new SplitReader(this); public static implicit operator int(ConsoleReader cr) => cr.Int; public static implicit operator long(ConsoleReader cr) => cr.Long; public static implicit operator double(ConsoleReader cr) => cr.Double; public static implicit operator string(ConsoleReader cr) => cr.Ascii; public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2) => (o1, o2) = (this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3) => (o1, o2, o3) = (this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4) => (o1, o2, o3, o4) = (this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5) => (o1, o2, o3, o4, o5) = (this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6) => (o1, o2, o3, o4, o5, o6) = (this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7) => (o1, o2, o3, o4, o5, o6, o7) = (this, this, this, this, this, this, this); public void Deconstruct(out ConsoleReader o1, out ConsoleReader o2, out ConsoleReader o3, out ConsoleReader o4, out ConsoleReader o5, out ConsoleReader o6, out ConsoleReader o7, out ConsoleReader o8) => (o1, o2, o3, o4, o5, o6, o7, o8) = (this, this, this, this, this, this, this, this); }[DebuggerStepThrough] public class ConsoleWriter {[DebuggerBrowsable(DebuggerBrowsableState.Never)] public readonly StreamWriter sw; public ConsoleWriter(Stream output) : this(output, Console.OutputEncoding) { } public ConsoleWriter(Stream output, Encoding encoding) { sw = new StreamWriter(output, encoding); } public void Flush() => sw.Flush(); public ConsoleWriter WriteLine(ReadOnlySpan<char> obj) { sw.WriteLine(obj); return this; } public ConsoleWriter WriteLine<T>(T obj) { sw.WriteLine(obj.ToString()); return this; } public ConsoleWriter WriteLineJoin<T>(ReadOnlySpan<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLineJoin<T>(IEnumerable<T> col) => WriteMany(' ', col); public ConsoleWriter WriteLines<T>(ReadOnlySpan<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLines<T>(IEnumerable<T> col) => WriteMany('\\n', col); public ConsoleWriter WriteLineGrid<T>(IEnumerable<IEnumerable<T>> cols) { var en = cols.GetEnumerator(); while (en.MoveNext()) WriteLineJoin(en.Current); return this; } private ConsoleWriter WriteMany<T>(char sep, ReadOnlySpan<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } private ConsoleWriter WriteMany<T>(char sep, IEnumerable<T> col) { var en = col.GetEnumerator(); if (!en.MoveNext()) return this; sw.Write(en.Current.ToString()); while (en.MoveNext()) { sw.Write(sep); sw.Write(en.Current.ToString()); } sw.WriteLine(); return this; } } }\npublic partial class Program {[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleReader cr;[System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)] public ConsoleWriter cw; public Program(ConsoleReader reader, ConsoleWriter writer) { this.cr = reader; this.cw = writer; System.Globalization.CultureInfo.CurrentCulture = System.Globalization.CultureInfo.InvariantCulture; } static void Main() => new Program(new ConsoleReader(Console.OpenStandardInput()), new ConsoleWriter(Console.OpenStandardOutput())).Run(); public void Run() { var res = Calc(); if (res is double) cw.WriteLine(Result((double)res)); else if (res is bool) cw.WriteLine(Result((bool)res)); else if (res != null) cw.WriteLine(res.ToString()); cw.Flush(); } }\npublic partial class Program\n{\n    public static string Result(double d) => d.ToString(\"0.####################\", System.Globalization.CultureInfo.InvariantCulture);\n    #endregion\n    public static string Result(bool b) => b ? \"Yes\" : \"No\";\n    private object Calc()\n    {\n        // 参考: https://kmjp.hatenablog.jp/entry/2020/06/09/0930\n        N = cr;\n        M = cr;\n        var dp = NewArray<Mod>(N + 1, M + 1, 0);\n        dp[0] = NewArray<Mod>(M + 1, 1);\n        var p2 = new Mod[M];\n        var r2 = new Mod[M];\n        p2[0] = r2[0] = 1;\n        for (int i = 1; i < M; i++)\n        {\n            p2[i] = p2[i - 1] * 2;\n            r2[i] = r2[i - 1] * ((Mod.mod + 1) / 2);\n        }\n\n        for (var i = 1; i <= N; i++)\n        {\n            dp[i][0] = 1;\n            Mod sum = 0;\n            for (var x = 1; x <= M; x++)\n            {\n                dp[i][x] += dp[i - 1][x] * (x + 1);\n                if (x >= 2) sum += (x - 1) * dp[i - 1][x - 1] * p2[M - x];\n                dp[i][x] += sum * r2[M - x];\n            }\n        }\n\n        return dp[N][M];\n    }\n    int N;\n    int M;\n}\n\n\n\nreadonly struct Mod : IEquatable<Mod> { public const long mod = 1000000007; public static readonly Mod invalid = new Mod(-1, false); public readonly long val; private Mod(long val, bool isValid) : this(val) { if (!isValid) this.val = val; } public Mod(long val) { this.val = val % mod; if (this.val < 0) this.val += mod; } public override bool Equals(object obj) => (obj is Mod) && this == ((Mod)obj); public bool Equals(Mod obj) => this.val == obj.val; public override int GetHashCode() => val.GetHashCode(); public override string ToString() => val.ToString(); public static implicit operator Mod(long x) => new Mod(x); public static implicit operator Mod(ConsoleReader cr) => new Mod(cr.Long); public static Mod operator -(Mod x) => new Mod(-x.val); public static Mod operator +(Mod x, Mod y) => new Mod(x.val + y.val); public static Mod operator -(Mod x, Mod y) => new Mod(x.val - y.val); public static Mod operator *(Mod x, Mod y) => new Mod(x.val * y.val); public static Mod operator /(Mod x, Mod y) => x * y.Inverse(); public static bool operator ==(Mod x, Mod y) => x.val == y.val; public static bool operator !=(Mod x, Mod y) => x.val != y.val; public Mod Inverse() { long a = val, b = mod, u = 1, v = 0; while (b > 0) { long t = a / b; var b2 = a - t * b; a = b; b = b2; var v2 = u - t * v; u = v; v = v2; } u %= mod; if (u < 0) u += mod; return u; } public static Mod Pow(Mod x, int y) { Mod res = 1; for (; y > 0; y >>= 1) { if ((y & 1) == 1) res *= x; x *= x; } return res; } public static Factor CreateFactor(int max) => new Factor(max); public class Factor { private readonly Mod[] fac, finv; public Factor(int max) { ++max; var inv = new Mod[max]; fac = new Mod[max]; finv = new Mod[max]; fac[0] = fac[1] = 1; finv[0] = finv[1] = 1; inv[1] = 1; for (var i = 2; i < max; i++) { fac[i] = fac[i - 1] * i; inv[i] = mod - inv[mod % i].val * (mod / i) % mod; finv[i] = finv[i - 1] * inv[i]; } } /** <summary>組み合わせ関数(二項係数)</summary> */ public Mod Combine(int n, int k) { if (n < k) return 0; if (n < 0 || k < 0) return 0; return fac[n] * finv[k] * finv[n - k]; } public Mod Factorial(int n) => fac[n]; public Mod FactorialInvers(int n) => finv[n]; } }\nstatic class ModExt { public static Mod Sum(this IEnumerable<Mod> source) { Mod sum = 0; foreach (var v in source) sum += v; return sum; } }\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.bitmanip, std.complex, std.container, std.math, std.mathspecial, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\nstruct ModInt(int M_) {\n  import std.conv : to;\n  alias M = M_;\n  int x;\n  this(ModInt a) { x = a.x; }\n  this(long a) { x = cast(int)(a % M); if (x < 0) x += M; }\n  ref ModInt opAssign(long a) { return (this = ModInt(a)); }\n  ref ModInt opOpAssign(string op)(ModInt a) {\n    static if (op == \"+\") { x += a.x; if (x >= M) x -= M; }\n    else static if (op == \"-\") { x -= a.x; if (x < 0) x += M; }\n    else static if (op == \"*\") { x = cast(int)((cast(long)(x) * a.x) % M); }\n    else static if (op == \"/\") { this *= a.inv(); }\n    else static assert(false);\n    return this;\n  }\n  ref ModInt opOpAssign(string op)(long a) {\n    static if (op == \"^^\") {\n      if (a < 0) return (this = inv()^^(-a));\n      ModInt t2 = this, te = ModInt(1);\n      for (long e = a; e > 0; e >>= 1) {\n        if (e & 1) te *= t2;\n        t2 *= t2;\n      }\n      x = cast(int)(te.x);\n      return this;\n    } else return mixin(\"this \" ~ op ~ \"= ModInt(a)\");\n  }\n  ModInt inv() const {\n    int a = x, b = M, y = 1, z = 0, t;\n    for (; ; ) {\n      t = a / b; a -= t * b;\n      if (a == 0) {\n        assert(b == 1 || b == -1);\n        return ModInt(b * z);\n      }\n      y -= t * z;\n      t = b / a; b -= t * a;\n      if (b == 0) {\n        assert(a == 1 || a == -1);\n        return ModInt(a * y);\n      }\n      z -= t * y;\n    }\n  }\n  ModInt opUnary(string op: \"-\")() const { return ModInt(-x); }\n  ModInt opBinary(string op, T)(T a) const {\n    return mixin(\"ModInt(this) \" ~ op ~ \"= a\");\n  }\n  ModInt opBinaryRight(string op)(long a) const {\n    return mixin(\"ModInt(a) \" ~ op ~ \"= this\");\n  }\n  bool opCast(T: bool)() const { return (x != 0); }\n  string toString() const { return x.to!string; }\n}\n\nenum MO = 10^^9 + 7;\nalias Mint = ModInt!MO;\n\n\nvoid main() {\n  try {\n    for (; ; ) {\n      const N = readInt();\n      const M = readInt();\n      \n      auto dp = new Mint[][](N + 1, M + 1);\n      dp[0][] = Mint(1);\n      foreach (n; 1 .. N + 1) {\n        Mint sum;\n        foreach (m; 0 .. M + 1) {\n          dp[n][m] = sum + (m + 1) * dp[n - 1][m];\n          sum = sum * 2 + m * dp[n - 1][m];\n        }\n      }\n      debug {\n        if (N <= 10 && M <= 10) {\n          foreach (n; 0 .. N + 1) {\n            writeln(n, \": \", dp[n]);\n          }\n        }\n      }\n      writeln(dp[N][M]);\n      \n      debug {\n        if (N <= 100 && M <= 100) {\n          auto slow = new Mint[][](N + 1, M + 1);\n          slow[0][] = Mint(1);\n          foreach (n; 1 .. N + 1) {\n            foreach (m; 0 .. M + 1) {\n              // no 10\n              slow[n][m] += (m + 1) * slow[n - 1][m];\n              // 10\n              foreach (i; 0 .. m) foreach (j; i + 1 .. m) {\n                slow[n][m] += Mint(2)^^(j - i - 1) * slow[n - 1][m - (j - i)];\n              }\n            }\n          }\n          if (N <= 10 && M <= 10) {\n            foreach (n; 0 .. N + 1) {\n              writeln(n, \": \", slow[n]);\n            }\n          }\n          writeln(\"slow[N][M] = \", slow[N][M]);\n        }\n      }\n      \n      debug {\n        if (N <= 5 && M <= 5) {\n          int brt;\n          foreach (p; 0 .. (2^^N)^^M) {\n            auto as = iota(M).map!(i => (p / (2^^N)^^i % 2^^N)).array;\n            bool ok = true;\n            foreach (i; 0 .. M) foreach (j; i + 1 .. M) {\n              foreach_reverse (e; 0 .. N) {\n                if (((as[i] >> e) & 1) && !((as[j] >> e) & 1)) {\n                  ok = ok && !((as[i] ^ as[j]) & ((1 << e) - 1));\n                  break;\n                }\n              }\n            }\n            if (ok) {\n              ++brt;\n            }\n          }\n          writeln(\"brt = \", brt);\n        }\n      }\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "import itertools\nN = int(input())\nA = [int(_) for _ in input().split()]\nif A[0] != 0:\n    if N == 0 and A[0] == 1:\n        print(1)\n    else:\n        print(-1)\n    exit()\nans = 1\nn = 1\nif A[0] > 1:\n    print(-1)\n    exit()\ncumr = list(itertools.accumulate(A[::-1]))[::-1]\nfor i in range(1, N + 1):\n    n = min(2 * (n - A[i - 1]), cumr[i])\n    ans += n\n    if n < 0:\n        print(-1)\n        exit()\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "input()\nprint(1)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\nfact = [i for i in range(10**5+1)]\nfact[0] = 1\nfor i in range(10**5):\n  fact[i+1]*=fact[i]\n  fact[i+1]%=mod\ninvfact=[None]*(10**5+1)\ninvfact[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(10**5):\n  invfact[-i-2]=(invfact[-i-1]*(10**5-i))%mod\n\ndef cmb(n,k):\n  return fact[n]*invfact[k]*invfact[n-k]%mod\n#solve\ndef solve():\n    n, m = LI()\n    dp = [[0, 0] for i in range(n + 1)]\n    dp[0][0] = 1\n    dp[1][0] = n\n    dp[1][1] = n\n    for i in range(1,n):\n        dp[i + 1][0] = cmb(n,i)\n        dp[i + 1][1] = cmb(n,i)*i%mod\n    ans = pow(2, m, mod)\n    tmp = 0\n    for d1, d2 in dp:\n        tmp += d1 + d2\n        tmp %= mod\n    print(ans * tmp % mod)\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "class comb():\n  F = [1, 1]\n  Fi = [1, 1]\n  I = [0, 1]\n  def __init__(self, num, mod):\n    self.MOD = mod\n    for i in range(2, num + 1):\n      self.F.append((self.F[-1] * i) % mod)\n      self.I.append(mod - self.I[mod % i] * (mod // i) % mod)\n      self.Fi.append(self.Fi[-1] * self.I[i] % mod)\n  def com(self, n, k):\n    if n < k: return 0\n    if n < 0 or k < 0: return 0\n    return self.F[n] * (self.Fi[k] * self.Fi[n - k] % self.MOD) % self.MOD\n\n\nM, N = list(map(int, input().split()))\nMOD = 10 ** 9 + 7\nDP = [[[0] * 2 for i in range(M + 1)] for _ in range(N)]\n\ncom = comb(M + 1, MOD)\n\nL = [0] * (M + 1)\nfor i in range(M + 1):\n  L[i] = com.com(M, i)\n\nfor i in range(M + 1):\n  DP[0][i][0] = 1\n\nfor i in range(1, N):\n  for j in range(M + 1):\n    if j != 0:\n      DP[i][j][0] += (DP[i - 1][j - 1][0] + DP[i - 1][j - 1][1]) * L[j - 1] % MOD\n    DP[i][j][0] += DP[i - 1][j][0] * L[j] % MOD\n    DP[i][j][0] %= MOD\n\n    if j != M:\n      DP[i][j][1] += (DP[i - 1][j + 1][0]) * L[j + 1] % MOD\n    DP[i][j][1] += DP[i - 1][j][1] * L[j] % MOD\n\nans = 0\nfor i in range(M + 1):\n  ans = (ans + DP[-1][i][0] + DP[-1][i][1]) % MOD\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\n\n#solve\ndef solve():\n    n, m = LI()\n    dp = [[0, 0] for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        dp[i + 1][0] = dp[i][0] * (n - i) % mod\n        dp[i + 1][1] = (dp[i][1] * (n - i) + dp[i][0] * (n - i)) % mod\n    ans = pow(2, m, mod)\n    tmp = 0\n    for d1, d2 in dp:\n        tmp += d1 + d2\n        tmp %= mod\n    print(ans * tmp % mod)\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\nfact = [i for i in range(10**5+1)]\nfact[0] = 1\nfor i in range(10**5):\n  fact[i+1]*=fact[i]\n  fact[i+1]%=mod\ninvfact=[None]*(10**5+1)\ninvfact[-1]=pow(fact[-1],mod-2,mod)\nfor i in range(10**5):\n  invfact[-i-2]=(invfact[-i-1]*(10**5-i))%mod\n\ndef cmb(n,k):\n  return fact[n]*invfact[k]*invfact[n-k]%mod\n#solve\ndef solve():\n    n, m = LI()\n    dp = [[0, 0] for i in range(n + 1)]\n    dp[0][0] = 1\n    dp[1][0] = n\n    dp[1][1] = n\n    for i in range(1,n):\n        dp[i + 1][0] = cmb(n,i)\n        dp[i + 1][1] = cmb(n,i)*(i+1)%mod\n    ans = pow(2, m, mod)\n    tmp = 0\n    for d1, d2 in dp:\n        tmp += d1 + d2\n        tmp %= mod\n    print(ans * tmp % mod)\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport numpy as np\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nMOD = 10**9 + 7\n\nN, M = map(int, read().split())\n\ndef make_power(a, L, MOD=MOD):\n    B = L.bit_length()\n    x = np.empty(1 << B, np.int64)\n    x[0] = 1\n    for n in range(B):\n        x[1 << n:1 << (n + 1)] = x[:1 << n] * a % MOD\n        a *= a\n        a %= MOD\n    x = x[:L]\n    x.flags.writeable = False\n    return x\n\npow2 = make_power(2, M + 10)\nipow2 = make_power((1 + MOD) // 2, M + 10)\n\ndef update(dp):\n    B = dp.copy()\n    C = dp * np.arange(M + 1) % MOD * ipow2[:M + 1] % MOD\n    dp[1:] = np.cumsum(C[:-1]) % MOD\n    dp[1:] *= pow2[:M]\n    dp %= MOD\n    dp += np.arange(1, M + 2) * B\n    dp %= MOD\n\ndp = pow2[:M + 1].copy()\nfor _ in range(N - 1):\n    update(dp)\n\nprint(dp[-1])"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\n\n#solve\ndef solve():\n    n, m = LI()\n    dp = [[0, 0] for i in range(n + 1)]\n    dp[0][0] = 1\n    for i in range(n):\n        dp[i + 1][0] = dp[i][0] * (n - i) % mod\n        dp[i + 1][1] = (dp[i][1] * (n - i) * i + dp[i][0] * (n - i)) % mod\n    ans = pow(2, m, mod)\n    tmp = 0\n    for d1, d2 in dp:\n        tmp += d1 + d2\n        tmp %= mod\n    print(ans * tmp % mod)\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n"
  }
]