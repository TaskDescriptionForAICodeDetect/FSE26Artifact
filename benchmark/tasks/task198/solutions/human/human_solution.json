[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nvector<string> split(const string &str, char delim){\n  vector<string> res;\n  size_t current = 0, found;\n  while((found = str.find_first_of(delim, current)) != string::npos){\n    res.push_back(string(str, current, found - current));\n    current = found + 1;\n  }\n  res.push_back(string(str, current, str.size() - current));\n  return res;\n}\n\nvector<int> dx, dy;\n\nint dfs(int x, int y, bool used[4][4]) {\n\n  int result = 0;\n  int new_x, new_y;\n\n  // cout << x << \" \" << y << endl;\n  // for(int i = 0;i < 4;i++) {\n\n  //   for(int j = 0;j < 4;j++) {\n\n  //     cout << used[j][i];\n  //   }\n\n  //   cout << endl;\n\n  // }\n\n  // cout << endl;\n  \n  while(used[x][y] == true) {\n\n    x++;\n\n    if(x == 4) {\n\n      y++;\n      x = 0;\n      \n      if(y == 4) {\n\n\treturn 1;\n\n      }\n\n    }\n\n  }\n\n  used[x][y] = true;\n\n  for(int i = 0;i < 4;i++) {\n\n    new_x = x + dx[i];\n    new_y = y + dy[i];\n\n    if(new_x >= 0 && new_x <= 3 && new_y >= 0 && new_y <= 3 && (used[new_x][new_y] == false)) {\n\n      used[new_x][new_y] = true;\n\n      // cout << dx[i] << \",\" << dy[i] << endl;\n      // for(int i = 0;i < 4;i++) {\n\n      // \tfor(int j = 0;j < 4;j++) {\n\n      // \t  cout << used[j][i];\n      // \t}\n\n      // \tcout << endl;\n\n      // }\n      // cout << endl;\n      if(x == 3) result += dfs(0, y+1, used);\n      else result += dfs(x+1, y, used);\n      used[new_x][new_y] = false;\n\t\n    }\n    \n  }\n\n  used[x][y] = false;\n\n  return result;\n  \n}\n\nint solve() {\n\n  bool used[4][4];\n\n  for(int i = 0;i < 4;i++) {\n\n    for(int j = 0;j < 4;j++) {\n\n      used[j][i] = false;\n\n    }\n\n  }\n  \n  return dfs(0, 0, used);\n\n}\n\nint main() {\n\n  string line;\n\n  while(getline(cin, line)) {\n    \n    if(line.length() == 1 && atoi(line.c_str()) > 4) break;\n\n    else {\n\n      vector<string> strarray;\n\n      strarray.clear();\n\n      strarray = split(line, ' ');\n      \n      for(int i = 0;i < 8;i++) {\n\n      \tif(i % 2 == 0) dx.push_back(atoi(strarray[i].c_str()));\n\n      \telse dy.push_back(atoi(strarray[i].c_str()));\n\n      }\n\n      cout << solve() << endl;\n\n    }\n\n  }\n  \n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nint dx[4],dy[4];\nbool used[4][4];\n\nint rec(int d){\n\n  if(d>=8)return 1;  \n\n  int tmpx=-1,tmpy=-1;\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      if(!used[i][j]){\n\ttmpx=j,tmpy=i;\n\tgoto end;\n      }\n    }\n  }\n end:;\n\n  if(tmpx<0 || tmpy<0)return 0;\n  used[tmpy][tmpx]=true;\n\n  int res=0;\n  for(int i=0;i<4;i++){\n    int nx=tmpx+dx[i],ny=tmpy+dy[i];\n    if(nx<0 || ny<0 || 3<nx || 3<ny || used[ny][nx])continue;\n    used[ny][nx]=true;\n    res+=rec(d+1);\n    used[ny][nx]=false;\n  }\n  used[tmpy][tmpx]=false;\n  return res;\n}\n\nint main(void){\n  \n  while(true){\n    for(int i=0;i<4;i++){\n      cin >> dx[i];\n      if(dx[i]>4)return 0;\n      cin >> dy[i];\n    }\n    fill(used[0],used[4],false);\n    cout << rec(0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint dy[5],dx[5],ans;\n\n#define id(y,x) (y*4+x)\n\nint f(int y,int x,int mask){\n    if(y==4)return 1;\n    if(x==4)return f(y+1,0,mask);\n    if(mask>>id(y,x)&1)return f(y,x+1,mask);\n    int res=0;\n    rep(i,4){\n        int ny=y+dy[i],nx=x+dx[i];\n        if(ny<0 || 4<=ny || nx<0 || 4<=nx\n           || mask>>id(ny,nx)&1)continue;\n        res+=f(y,x+1,mask|1<<id(ny,nx));\n    }\n    return res;\n}\n\nint main(){\n\twhile(cin>>dx[0] && dx[0]<4){\n        cin>>dy[0];\n        rep2(i,1,4)cin>>dx[i]>>dy[i];\n        ans=0;\n        cout<<f(0,0,0)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing db = double;\nusing ll = long long;\nusing vi = vector <int>;\n#define op operator\n#define pb push_back\n\nint x[4], y[4];\nbool v[4][4];\n\nint dfs(int i, int j) {\n\twhile(v[i][j]) {\n\t\tj ++;\n\t\tif(j == 4) {\n\t\t\ti ++;\n\t\t\tj = 0;\n\t\t}\n\t}\n\tif(i == 4) return 1;\n\tint r = 0;\n\tfor(int sgn : {-1, 1})\n\tfor(int k = 0; k < 4; k ++) {\n\t\tint ni = i + sgn * x[k];\n\t\tint nj = j + sgn * y[k];\n\t\tif(ni >= 0 && ni < 4 && nj >= 0 && nj < 4 && !v[ni][nj]) {\n\t\t\tv[i][j] = v[ni][nj] = 1;\n\t\t\tr += dfs(i, j);\n\t\t\tv[i][j] = v[ni][nj] = 0;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\tcout << fixed << setprecision(9);\n\tios :: sync_with_stdio(0);\n\n\tfor(; cin >> x[0] && x[0] <= 4; ) {\n\t\tcin >> y[0];\n\t\tfor(int i = 1; i < 4; i ++)\n\t\t\tcin >> x[i] >> y[i];\n\t\tcout << dfs(0, 0) << '\\n';\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <stdio.h>\n\nstruct Rule{\n\tint dx;\n\tint dy;\n};\n\nRule rule[4];\n\nint countPattern(int board[16], int pos)\n{\n\tif(board[pos]){\n\t\tif(pos < 15) return countPattern(board, pos+1);\n\t\telse{\n\t\t\treturn 1;\n\t\t}\n\t}\n\tboard[pos] = pos+1;\n\t\n\tint sum = 0;\n\tint other_posx, other_posy;\n\t\n\tfor(int i = 0; i < 4; i++){\n\t\tother_posx = pos % 4 + rule[i].dx;\n\t\tother_posy = pos / 4 + rule[i].dy;\n\t\tif(other_posx < 0 || other_posx >= 4 || other_posy < 0 || other_posy >= 4 || board[other_posx + other_posy * 4]) continue;\n\t\tboard[other_posx + other_posy * 4] = pos+1;\n\t\tsum += countPattern(board, pos+1);\n\t\tboard[other_posx + other_posy * 4] = 0;\n\t}\n\t\n\tboard[pos] = 0;\n\treturn sum;\n}\n\n\t\nint main(void)\n{\n\tint board[16];\n\t\n\twhile(1){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tscanf(\"%d\", &rule[i].dx);\n\t\t\tif(rule[i].dx >= 4) goto end;\n\t\t\tscanf(\"%d\", &rule[i].dy);\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < 16; i++) board[i] = 0;\n\t\t\n\t\tprintf(\"%d\\n\", countPattern(board, 0));\n\t}\n\t\n\tend:\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <algorithm>\n#include <memory>\n#include <memory.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\ntypedef pair<P,P> P2;\nconst int INF = 1 << 30;\nconst double EPS = 1E-9;\n\nP p[4];\nvector<P> mv;\nbool used[4][4];\n\nint calc(int p){\n\twhile(p < 16 && used[p/4][p%4]) p++;\n\tif(p == 16){\n\t\treturn 1;\n\t}\n\tint count = 0;\n\tused[p/4][p%4] = true;\n\tint y = p / 4;\n\tint x = p % 4;\n\tfor(int i = 0; i < (int)mv.size(); i++){\n\t\tint x2 = x + mv[i].first;\n\t\tint y2 = y + mv[i].second;\n\t\tif(x2 >= 0 && x2 < 4 && y2 >= 0 && y2 < 4 && !used[y2][x2]){\n\t\t\tused[y2][x2] = true;\n\t\t\tcount += calc(p+1);\n\t\t\tused[y2][x2] = false;\n\t\t}\n\t}\n\tused[y][x] = false;\n\treturn count;\n}\n\nint main(){ \n\twhile(cin >> p[0].first && p[0].first < 5){\n\t\tcin >> p[0].second;\n\t\tmv.clear();\n\t\tfor(int i = 1; i < 4; i++) cin >> p[i].first >> p[i].second;\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tmv.push_back(p[i]);\n\t\t}\n\t\tmemset(used, false, sizeof(used));\n\t\tcout << calc(0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nvector<P> rel;\nbool used[4][4];\n\nint dfs(int card){\n  int ans = 0;\n  if(card == 0) return 1;\n  \n  int x, y;\n  \n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      if(used[i][j]) continue;\n      x = j, y = i;\n      goto TO;\n    }\n  }\n TO:;\n  used[y][x] = true;\n  \n  for(int i = 0 ; i < 4 ; i++){\n    int nx = x + rel[i].first, ny = y + rel[i].second;\n    if(nx < 0 || nx > 3 || ny < 0 || ny > 3) continue;\n    if(used[ny][nx]) continue;\n    \n    used[ny][nx] = true;\n    ans += dfs(card-1);\n    used[ny][nx] = false;\n  }\n  used[y][x] = false;\n  return ans;\n  /*\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      if(used[i][j]) continue;\n      used[i][j] = true;\n      for(int k = 0 ; k < 4 ; k++){\n\tint nx = j + rel[k].first, ny = i + rel[k].second;\n\tif(nx < 0 || nx > 3 || ny < 0 || ny > 3) continue;\n\tif(used[ny][nx]) continue;\n\tused[ny][nx] = true;\n\tans += dfs(card-1);\n\tused[ny][nx] = false;\n      }\n      used[i][j] = false;\n    }\n  }\n  return ans;\n  */\n}\n\nint main(){\n  int x1,x2,x3,x4,y1,y2,y3,y4;\n  while(cin >> x1 >> y1 >> x2 >> y2 >> x3 >> y3 >> x4 >> y4){\n    memset(used, false, sizeof(false));\n    rel.clear();\n    rel.push_back(P(x1, y1));\n    rel.push_back(P(x2, y2));\n    rel.push_back(P(x3, y3));\n    rel.push_back(P(x4, y4));\n  \n    int ans = dfs(8);\n    \n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nint main() {\n\n  int m, n;\n\n  while(cin >> m >> n) {\n\n    if(m == 0 || n == 0) break;\n  \n    int x = 1;\n    int y = 1;\n\n    string command;\n    int offset;\n\n    int direction = 0;\n    \n    while(cin >> command) {\n\n      if(command == \"STOP\") {\n\n\tcout << x << \" \" << y << endl;\n\tbreak;\n\n      }\n\n      if(command == \"LEFT\") {\n\n\tdirection += 1;\n\tdirection %= 4;\n\n      }\n\n      if(command == \"RIGHT\") {\n\n\tdirection -= 1;\n\tif(direction == -1) direction = 3;\n\tdirection %= 4;\n\n      }\n\n      if(command == \"FORWARD\") {\n\n\tcin >> offset;\n\t\n\tswitch(direction) {\n\n\tcase 0:\n\t  if(y + offset > n) y = n;\n\n\t  else y += offset;\n\n\t  break;\n\n\tcase 1:\n\t  if(x - offset < 1) x = 1;\n\n\t  else x -= offset;\n\n\t  break;\n\n\tcase 2:\n\t  if(y - offset < 1) y = 1;\n\n\t  else y -= offset;\n\n\t  break;\n\n\tcase 3:\n\t  if(x + offset > m) x = m;\n\n\t  else x += offset;\n\n\t  break;\n\n\t}\n\n      }\n\n      if(command == \"BACKWARD\") {\n\n\tcin >> offset;\n\t\n\tswitch(direction) {\n\n\tcase 0:\n\t  if(y - offset < 1) y = 1;\n\n\t  else y -= offset;\n\n\t  break;\n\n\tcase 1:\n\t  if(x + offset > m) x = m;\n\n\t  else x += offset;\n\n\t  break;\n\n\tcase 2:\n\t  if(y + offset > n) y = n;\n\n\t  else y += offset;\n\n\t  break;\n\n\tcase 3:\n\t  if(x - offset < 1) x = 1;\n\n\t  else x -= offset;\n\n\t  break;\n\n\t}\n\t\n      }\n\n      //cout << x << \" \" << y << \" \" << direction << endl;\n\n    }\n  }\n  \n  \n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n \nbool in_range(int i, int j) {\n  return 0 <= i && i < 4 && 0 <= j && j < 4; \n}\n \nvector<int> x(4), y(4);\n \nbool G[4][4];\n \nint rec(int i, int j) {\n   \n  int ni = i, nj = j + 1;\n     \n  if(nj == 4) {\n    ni ++;\n    nj = 0;\n  }\n   \n  if(ni == 4) return G[i][j];\n \n  if(G[i][j]) return rec(ni, nj);\n   \n  int ret = 0;\n \n  G[i][j] = 1;\n   \n  rep(k, 4) {\n    int pi = i + y[k], pj = j + x[k];\n    if(!in_range(pi, pj)) continue;\n    if(G[pi][pj]) continue; // iranai ?\n    G[pi][pj] = 1;\n    ret += rec(ni, nj);\n    G[pi][pj] = 0;\n  }\n   \n  G[i][j] = 0;\n   \n  return ret;\n}\n \nint main() {\n \n  while(1) {\n    rep(i, 4) {\n      cin >> x[i] >> y[i];\n      if(cin.eof()) exit(0);\n    }\n     \n    rep(i, 4) rep(j, 4) G[i][j] = 0;\n    cout << rec(0, 0) << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nint x[4], y[4];\nint board[4][4];\nint out;\n\nusing namespace std;\n\nvoid rec(int card)\n{\n\tif( card > 8 )\n\t{\n\t\tint count = 1;\n\t\tfor( int j = 0; j < 4; j++)\n\t\t\tfor( int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tif( board[j][i] == count )\n\t\t\t\t\tfor( int k = 0; k < 4; k++ )\n\t\t\t\t\t\tif( board[j+y[k]][i+x[k]] == count )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\tif( count > 8 )\n\t\t\tout++;\n\t\t\t\n\t\treturn;\n\t}\n\t\n\tfor( int j = 0; j < 4; j++)\n\t\tfor( int i = 0; i < 4; i++)\n\t\t{\n\t\t\t\n\t\t\tif(board[j][i] == 0)\n\t\t\t{\n\t\t\t\tboard[j][i] = card;\n\t\t\t\t\n\t\t\t\tfor( int k = 0; k < 4 ; k++)\n\t\t\t\t{\n\t\t\t\t\tint nx = i+x[k], ny = j+y[k];\n\t\t\t\t\tif(nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && board[ny][nx] == 0 )\n\t\t\t\t\t{\n\t\t\t\t\t\tboard[ny][nx] = card;\n\t\t\t\t\t\trec(card+1);\n\t\t\t\t\t\tboard[ny][nx] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboard[j][i] = 0;\n\t\t\t}\n\t\t}\n\n\treturn;\n}\n\nint main()\n{\n\n\twhile(1)\n\t{\n\t\t\n\t\tmemset(board, 0, sizeof(board));\n\t\tout = 0;\n\t\t\n\t\tfor( int i = 0; i < 4 ; i++)\n\t\t{\n\t\t\tcin >> x[i];\n\t\t\t\n\t\t\tif( x[i] > 4 )\n\t\t\t\treturn 0;\n\t\t\t\n\t\t\tcin >> y[i];\n\t\t}\n\t\t\n\t\trec(1);\n\t\t\n\t\tcout << out << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct\n{\n  int x, y;\n} Point;\n\nint solve(vector<vector<int> >& board, int idx, const vector<Point>& rp)\n{\n  if (idx >= 8) {\n    bool valid = true;\n    for (int i = 0; i < 4 && valid; ++i) {\n      for (int j = 0; j < 4 && valid; ++j) {\n\tif (board[i][j] == -1)\n\t  valid = false;\n      }\n    }\n    if (valid)\n      return 1;\n    return 0;\n  }\n\n  int res = 0, x = 0, y = 0;\n  for (y = 0; y < 4; ++y) {\n    bool valid = false;\n    for (x = 0; x < 4; ++x) {\n      if (board[y][x] == -1) {\n\tvalid = true;\n\tbreak;\n      }\n    }\n    if (valid)\n      break;\n  }\n\n  for (unsigned int i = 0; i < rp.size(); ++i) {\n    int xx = x + rp[i].x;\n    int yy = y + rp[i].y;\n    if (xx < 0 || 4 <= xx || yy < 0 || 4 <= yy || board[yy][xx] != -1)\n      continue;\n    board[y][x] = board[yy][xx] = idx;\n    res += solve(board, idx+1, rp);\n    board[y][x] = board[yy][xx] = -1;\n  }\n  return res;\n}\n\nint main()\n{\n  vector<Point> rp(4);\n  while (cin >> rp[0].x >> rp[0].y >> rp[1].x >> rp[1].y\n\t >> rp[2].x >> rp[2].y >> rp[3].x >> rp[3].y) {\n    if (rp[0].x >= 4)\n      break;\n\n    vector<vector<int> > board(4, vector<int>(4, -1));\n    cout << solve(board, 0, rp) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tint x,y;\n};\n\nInfo info[4];\n\nint ans_count;\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= 3 && col >= 0 && col <= 3)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid recursive(short table[4][4],int num){\n\n\tif(num == 9){\n\t\tans_count++;\n\t\treturn;\n\t}\n\n\tshort new_table[4][4][4];\n\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tfor(int p = 0; p < 4; p++)new_table[i][p][k] = table[p][k];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < 4; i++){\n\t\tfor(int k = 0; k < 4; k++){\n\t\t\tif(table[i][k] == 0){\n\t\t\t\tfor(int p = 0; p < 4; p++)new_table[p][i][k] = num;\n\t\t\t\tif(rangeCheck(i+info[0].y,k+info[0].x) == true && table[i+info[0].y][k+info[0].x] == 0){\n\t\t\t\t\tnew_table[0][i+info[0].y][k+info[0].x] = num;\n\t\t\t\t\trecursive(new_table[0],num+1);\n\t\t\t\t}\n\t\t\t\tif(rangeCheck(i+info[1].y,k+info[1].x)  == true && table[i+info[1].y][k+info[1].x] == 0){\n\t\t\t\t\tnew_table[1][i+info[1].y][k+info[1].x] = num;\n\t\t\t\t\trecursive(new_table[1],num+1);\n\t\t\t\t}\n\t\t\t\tif(rangeCheck(i+info[2].y,k+info[2].x)  == true && table[i+info[2].y][k+info[2].x] == 0){\n\t\t\t\t\tnew_table[2][i+info[2].y][k+info[2].x] = num;\n\t\t\t\t\trecursive(new_table[2],num+1);\n\t\t\t\t}\n\t\t\t\tif(rangeCheck(i+info[3].y,k+info[3].x)  == true && table[i+info[3].y][k+info[3].x] == 0){\n\t\t\t\t\tnew_table[3][i+info[3].y][k+info[3].x] = num;\n\t\t\t\t\trecursive(new_table[3],num+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nint main(){\n\n\tshort table[4][4];\n\n\twhile(true){\n\t\tscanf(\"%d\",&info[0].x);\n\t\tif(info[0].x >= 5)break;\n\n\t\tscanf(\"%d %d %d %d %d %d %d\",&info[0].y,&info[1].x,&info[1].y,&info[2].x,&info[2].y,&info[3].x,&info[3].y);\n\n\t\tans_count = 0;\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tfor(int k = 0; k < 8; k++)table[i][k] = 0;\n\t\t}\n\n\t\trecursive(table,1);\n\n\t\tprintf(\"%d\\n\",ans_count);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\nusing namespace std;\ntypedef complex<int> P;\n\nP input[4];\nvector<int> ansVec;\nint calc(int now, int board[])\n{\n\tif(now >= 4*4)\n\t\treturn 1;\n\tif(board[now] != 0)\n\t\treturn calc(now+1, board);\n\n\tint ret = 0;\n\t\t\n\tfor(int i=0; i<4; ++i)\n\t{\n\t\tint x = now % 4;\n\t\tint y = now / 4;\n\t\tx += input[i].real();\n\t\ty += input[i].imag();\n\t\tint tmp[4*4];\n\t\tfor(int j=0; j<4*4; ++j)\n\t\t{\n\t\t\ttmp[j] = board[j];\n\t\t}\n\t\ttmp[now] = i+1;\n\t\tif(x < 0 || x > 3 || y < 0 || y > 3)\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tint ref = now + input[i].real() + input[i].imag()*4;\n\t\t\n\t\tif(board[ref] != 0)\n\t\t\tcontinue;\n\t\ttmp[ref] = i+1;\n\t\tret += calc(now+1, tmp);\n\t}\n\treturn ret;\n}\n\n\nint main(int argc, char *argv[]) {\n\twhile(1)\n\t{\n\t\tint x1,y1,x2,y2,x3,y3,x4,y4;\n\t\tcin>>x1;\n\t\tif(x1>4)\n\t\t{\n\t\t\tfor(int i=0; i<ansVec.size(); ++i)\n\t\t\t{\n\t\t\t\tcout<< ansVec.at(i)<< endl;\n\t\t\t}\n\t\t\treturn 0;\t\t\t\n\t\t}\n\n\t\tcin>>y1>>x2>>y2>>x3>>y3>>x4>>y4;\n\t\tinput[0] = P(x1,y1);\n\t\tinput[1] = P(x2,y2);\n\t\tinput[2] = P(x3,y3);\n\t\tinput[3] = P(x4,y4);\n\t\tint board [4*4];\n\t\tfor(int i=0; i<4*4; ++i)\n\t\t{\n\t\t\tboard[i] = 0;\n\t\t}\n\t\tint ans;\n\t\tans = calc(0, board);\n\t\tansVec.push_back(ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int,int>P;\nvector<P>vec;\n\nint data[4][4];\n\nbool input(){\n  vec.clear();\n  int a,b;\n  cin >> a;\n  if(a > 4)return false;\n  cin >> b;\n  vec.push_back(P(a,b));\n  for(int i = 0 ; i < 3 ; i++){\n    cin >> a >> b;\n    vec.push_back(P(a,b));\n  }\n  return true;\n}\n\nvoid init(){\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      data[i][j] = -1;\n    }\n  }\n}\n\nvoid display(){\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      cout << data[i][j] << ' ';\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nint dfs(int cnt){\n\n  if(cnt == 8){\n    return 1;\n  }\n  int ret = 0;\n\n  for(int i = 0 ; i < 4 ; i++){\n    for(int j = 0 ; j < 4 ; j++){\n      if(data[i][j] != -1)continue;\n      for(int k = 0 ; k < vec.size() ; k++){\n        int nx,ny;\n        nx = j + vec[k].second;\n        ny = i + vec[k].first;\n        if(!(0 <= nx && nx < 4 && 0 <= ny && ny < 4))continue;\n        if(data[ny][nx] != -1)continue;\n        \n        data[ny][nx] = cnt;\n        data[i][j] = cnt;\n\n        ret += dfs(cnt+1);\n\n        data[ny][nx] = -1;\n        data[i][j] = -1;\n      }\n    }\n  }\n  return ret;\n}\n\nint main(){\n  while(input()){\n    init();\n    cout << dfs(0)/40320 << endl;\n    //cout << dfs(0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\nusing namespace std;\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nconstexpr int PATTERN = 4;\nconstexpr int SIZE = 4;\n\nint ans;\nbool used[SIZE][SIZE];\nint vx[PATTERN], vy[PATTERN];\n\nvoid normalize() {\n\trep(i, PATTERN) {\n\t\tif(vx[i] + 10 * vy[i] < 0) {\n\t\t\tvx[i] = -vx[i];\n\t\t\tvy[i] = -vy[i];\n\t\t}\n\t}\n}\n\nbool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= SIZE || y >= SIZE;\n}\n\nvoid dfs(int x, int y) {\n\tif(y == SIZE) {\n\t\t++ans;\n\t\treturn;\n\t}\n\tif(x == SIZE) return dfs(0, y + 1);\n\tif(used[y][x]) return dfs(x + 1, y);\n\n\trep(i, PATTERN) {\n\t\tconst int px = x + vx[i];\n\t\tconst int py = y + vy[i];\n\n\t\tif(out(px, py) || used[py][px]) continue;\n\t\tused[py][px] = true;\n\t\tdfs(x + 1, y);\n\t\tused[py][px] = false;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(true) {\n\t\trep(i, PATTERN) cin >> vx[i] >> vy[i];\n\t\tif(vx[0] > SIZE) break;\n\t\tnormalize();\n\n\t\tans = 0;\n\t\tdfs(0, 0);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nint x[4], y[4];\nint board[4][4];\n\nusing namespace std;\n\nint rec(int card)\n{\n\tint i, j, k, nx, ny, out = 0;\n\n\tif( card > 8 )\n\t\treturn 1;\n\t\n\tfor( j = 0; j < 4; j++)\n\t{\n\t\tfor( i = 0; i < 4; i++ )\n\t\t{\n\t\t\tif(board[j][i] == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif( i != 4 )\n\t\t\tbreak;\n\t}\n\t\n\tboard[j][i] = 1;\n\t\n\tfor( k = 0; k < 4 ; k++)\n\t{\n\t\tnx = i+x[k], ny = j+y[k];\n\t\n\t\tif(nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && board[ny][nx] == 0 )\n\t\t{\n\t\t\tboard[ny][nx] = 1;\n\t\t\tout += rec(card+1);\n\t\t\tboard[ny][nx] = 0;\n\t\t}\n\t}\n\t\n\tboard[j][i] = 0;\n\t\n\treturn out;\n}\n\n\n\nint main()\n{\n\n\twhile(1)\n\t{\n\t\t\n\t\tmemset(board, 0, sizeof(board));\n\n\t\tfor( int i = 0; i < 4 ; i++)\n\t\t{\n\t\t\tcin >> x[i];\n\t\t\t\n\t\t\tif( x[i] > 4 )\n\t\t\t\treturn 0;\n\t\t\t\n\t\t\tcin >> y[i];\n\t\t}\n\t\t\n\t\tint out = rec(1);\n\t\t\n\t\tcout << out << endl;\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int dx[24] = {-3,-3,-3,-2,-2,-2,-1,-1,-1,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3};\nconst int dy[24] = {1,2,3,1,2,3,1,2,3,1,2,3,0,1,2,3,0,1,2,3,0,1,2,3};\nconst int H = 4;\nconst int W = 4;\nconst int N = H*W;\nint dp[2][1<<N];\n\nint main() {\n  int dx[4], dy[4];\n  while(cin >> dx[0] && dx[0] <= 4) {\n    cin >> dy[0];\n    for(int i = 1; i < 4; ++i) cin >> dx[i] >> dy[i];\n\n    fill(dp[0], dp[2], 0);\n    dp[0][0] = 1;\n    for(int t = 0; t < N; ++t) {\n      int i = t / W; \n      int j = t % W;\n      int p = t % 2;\n      int q = 1 - p;\n      for(int k = 0; k < (1<<N); ++k) dp[q][k] = 0;\n      for(int k = 0; k < (1<<N); ++k) {\n        if(k & (1<<t)) {\n          dp[q][k] += dp[p][k];\n        } else {\n          for(int m = 0; m < 4; ++m) {\n            int ni = i + dy[m];\n            int nj = j + dx[m];\n            int nt = ni * W + nj;\n            if(ni < 0 || ni >= H) continue;\n            if(nj < 0 || nj >= W) continue;\n            if(k & (1<<nt)) continue;\n            dp[q][k|(1<<t)|(1<<nt)] += dp[p][k];\n          }\n        }\n      }\n    }\n    cout << dp[N%2][(1<<N)-1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\nint M[1<<16],X[4],Y[4];\nint G(int x,int y){return y*4+x;}\nint F(int f)\n{\n\tif(M[f]>=0)return M[f];\n\tif(!f)return 1;\n\tint r=0,x,y,i,j,k;\n\tfor(i=0;i<4;++i)for(j=0;j<4;++j)\n\t{\n\t\tif(!(f&(1<<G(j,i))))continue;\n\t\tfor(k=0;k<4;++k)\n\t\t{\n\t\t\ty=i+Y[k];x=j+X[k];\n\t\t\tif(0<=y&&y<4&&0<=x&&x<4&&(f&(1<<G(x,y))))r+=F(f^(1<<G(j,i))^(1<<G(x,y)));\n\t\t}\n\t\treturn M[f]=r;\n\t}\n\treturn M[f]=0;\n}\nint main()\n{\n\tfor(;;)\n\t{\n\t\tmemset(M,-1,sizeof(M));\n\t\tfor(int i=0;i<4;++i)if(scanf(\"%d%d\",X+i,Y+i)-2)return 0;\n\t\tprintf(\"%d\\n\",F(65535));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nbool check(int x,int y){return x>=0&&x<4&&y>=0&&y<4;}\n\nint main() {\n  int n=8,m=4;\n  P d[n];\n  while(cin >> d[0].F >> d[0].S) {\n    for(int i=1; i<m; i++) cin >> d[i].F >> d[i].S;\n    for(int i=0; i<n; i++) {\n      if(d[i].F<0) {\n        d[i].F*=-1;\n        d[i].S*=-1;\n      }\n      if(d[i].F==0&&d[i].S<0) d[i].S*=-1;\n    }\n    int ans=0;\n    for(int t=0; t<(1<<(n*2)); t++) {\n      P a[n];\n      for(int i=0; i<n; i++) {\n        int x=t/(1<<(i*2));\n        x%=4;\n        a[i]=d[x];\n      }\n      int c[m][m];\n      memset(c,-1,sizeof(c));\n      int k=0;\n      for(int i=0; i<m; i++) {\n        for(int j=0; j<m; j++) {\n          if(c[i][j]==-1) {\n            int x=i+a[k].F,y=j+a[k].S;\n            if(!check(x,y)||c[x][y]!=-1) goto next;\n            c[i][j]=k;\n            c[x][y]=k;\n            k++;\n          }\n        }\n      }\n      ans++;\n    next:;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint x[4], y[4];\nbool used[4][4];\n\nbool valid(int i, int j) {\n    return 0 <= i && i < 4 && 0 <= j && j < 4;\n}\n\nint dfs(int i1, int j1) {\n    int i2 = (i1*4+j1+1) / 4;\n    int j2 = (i1*4+j1+1) % 4;\n    if (used[i1][j1]) {\n        return i2 < 4 ? dfs(i2, j2) : 1;\n    }\n    int ret = 0;\n    for (int i=0; i<4; ++i) {\n        if (valid(i1+y[i], j1+x[i]) && ! used[i1+y[i]][j1+x[i]]) {\n            used[i1][j1] = used[i1+y[i]][j1+x[i]] = 1;\n            ret += dfs(i2, j2);\n            used[i1][j1] = used[i1+y[i]][j1+x[i]] = 0;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> x[0], x[0] < 4) {\n        cin >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3];\n        cout << dfs(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint xy[4][2];\nbool used[4][4];\n\nint dfs(int x, int y){\n    if(y == 4) return 1;\n    if(x == 4) return dfs(0, y+1);\n    if(used[x][y]){\n        return dfs(x+1, y);\n    }\n    int res = 0;\n    for(int i=0; i<4; i++){\n        int nx = x +xy[i][0];\n        int ny = y +xy[i][1];\n        if(nx<0 or 4<=nx or ny<0 or 4<=ny) continue;\n        if(used[nx][ny]) continue;\n        used[nx][ny] = true;\n        res += dfs(x+1, y);\n        used[nx][ny] = false;\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int tmp;\n        cin >> tmp;\n        if(tmp > 4) break;\n\n        for(int i=0; i<4; i++){\n            for(int j=0; j<2; j++){\n                if(i==0 and j==0){\n                    xy[i][j] = tmp;\n                }else{\n                    cin >> xy[i][j];\n                }\n            }\n        }\n        cout << dfs(0, 0) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nbool used[4][4];\nint rel_x[4], rel_y[4];\n\nint patnum(int depth, int x, int y) {\n\tif (depth == 0) return 1;\n\n\twhile (used[y][x]) {\n\t\tx++;\n\t\tif (x == 4)\n\t\t\tx = 0, y++;\n\t}\n\n\tint ret = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint xx = x+rel_x[i], yy = y+rel_y[i];\n\t\tif (xx < 0 || xx >= 4 || yy >= 4 || used[yy][xx])\n\t\t\tcontinue;\n\t\tused[yy][xx] = true;\n\t\tint x1 = x+1, y1 = y;\n\t\tif (x1 == 4)\n\t\t\tx1 = 0, y1++;\n\t\tret += patnum(depth-1, x1, y1);\n\t\tused[yy][xx] = false;\n\t}\n\treturn ret;\n}\n\nint main() {\n\twhile (cin >> rel_x[0], rel_x[0] <= 4) {\n\t\tcin >> rel_y[0] >> rel_x[1] >> rel_y[1]\n\t\t\t>> rel_x[2] >> rel_y[2] >> rel_x[3] >> rel_y[3];\n\t\tfor (int y = 0; y < 4; y++)\n\t\t\tfor (int x = 0; x < 4; x++)\n\t\t\t\tused[y][x] = false;\n\t\tcout << patnum(8, 0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\n\nbool check(vector< vector<int> > board){\n    for(int i=0;i<4;i++){\n\tfor(int j=0;j<4;j++){\n\t    if(board[i][j] == 0) return false;\n\t}\n    }\n    return true;\n}\n\nint saiki(vector<int> x,vector<int> y,vector< vector<int> > board,int nx,int ny){\n\n    int res = 0;\n    bool flag = true;\n    while(flag){\n\tif (check(board)) return 1;\n\tif (nx == 4){\n\t    nx = 0;\n\t    ny++;\n\t}\n\tif (board[ny][nx] == 0){\n            flag = false;\n\t    board[ny][nx]++;\n\t    for(int i=0;i<x.size();i++){\n\t\tint nexty = ny + y[i],nextx = nx + x[i];\n\t\tif(nexty > -1 && nexty < 4 && nextx > -1 && nextx < 4 && board[nexty][nextx] == 0){\n\t\t    board[nexty][nextx]++;\n\t\t    res += saiki(x,y,board,nx+1,ny);\n\t\t    board[nexty][nextx]--;\n\t\t}\n\t    }\n\t}else{\n\t    nx++;\n\t}\n    }\n    return res;\n}\n\n   \nint main(){\n\n    vector< vector<int> > board(4,vector<int>(4));\n\n\n    int temp,c1=0,c=0;\n    vector< vector<int> > x,y;\n    vector<int> dx,dy;\n    while(true)\n    {\n\tcin >> temp;\n\tif (temp > 3) break;\n\tdx.push_back(temp);\n\tcin >> temp;\n\tdy.push_back(temp);\n\n\tc1++;\n\tif(c1 == 4)\n\t{\n\t    c1 = 0;\n\t    c++;\n\t    x.push_back(dx);\n\t    y.push_back(dy);\n\t    dx.clear();\n\t    dy.clear();\n\t}\n    }\n\n    vector<int> t(4);\n    \n    for(int i=0;i<c;i++){\n\tfill(board.begin(),board.end(),t);\n        cout << saiki(x[i],y[i],board,0,0) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP(a, b) make_pair(a, b)\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint board[4][4];\nint dy[4], dx[4];\n\nint dfs(int n){\n  if(n >= 8) return 1;\n\n  int res = 0;\n  int y, x;\n  rep(y, 4){\n    rep(x, 4) if(!board[y][x]) break;\n    if(x != 4) break;\n  }\n\n  int d;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= 4 || nx >= 4 || board[ny][nx] != 0) continue;\n    board[y][x] = board[ny][nx] = 1;\n    res += dfs(n+1);\n    board[y][x] = board[ny][nx] = 0;\n  }\n\n  return res;\n}\n\nint main(){\n  int i;\n  while(1){\n    rep(i, 4) if(scanf(\"%d%d\", &dx[i], &dy[i])  && dx[0] >= 4) return 0;\n    memset(board, 0, sizeof(board));\n\n    printf(\"%d\\n\", dfs(0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n\nstruct board{\n  char M[4][4];\n  board(){\n    for(int i = 0; i < 4; ++i)for(int j = 0; j < 4; ++j)M[i][j]='*';\n  }\n  bool isinside(const pair<int,int> &p)const{\n    return 0<=p.first&&p.first<4&&0<=p.second&&p.second<4;\n  }\n  bool fillable(const pair<int,int> &p)const{\n    return M[p.first][p.second]=='*';\n  }\n  bool filled()const{\n    for(int i = 0; i < 4; ++i)\n      for(int j = 0; j < 4; ++j)\n\tif(M[i][j]=='*')return false;\n    return true;\n  }\n  bool operator<(const board &b)const{\n    for(int i=0;i<4;++i){\n      for(int j=0;j<4;++j){\n\tif(M[i][j]!=b.M[i][j])return M[i][j]<b.M[i][j];\n      }\n    }\n    return false;\n  }\n  void print()const{\n    for(int i = 0; i < 4; ++i){\n      for(int j = 0; j < 4; ++j){\n\tcout << M[i][j] << ' ';\n      }\n      cout << endl;\n    }\n    cout << endl;\n  }\n};\n\nvoid dfsFill(char c, board &b, pair<int,int> relpos[4], set<board> &vis, set<board> &S){\n  if(vis.find(b)==vis.end()){\n    vis.insert(b);\n  }else return ;\n  if(b.filled()){\n    S.insert(b);\n  }\n  for(int i = 0; i < 4; ++i){\n    for(int j = 0; j < 4; ++j){\n      for(int k = 0; k < 4; ++k){\n\tpair<int,int> np(i,j);\n\tpair<int,int> next(i+relpos[k].first,j+relpos[k].second);\n\tif(b.isinside(next)&&b.fillable(np)&&b.fillable(next)){\n\t  char t1,t2;\n\t  t1=b.M[np.first][np.second];\n\t  b.M[np.first][np.second]=c+k;\n\t  t2=b.M[next.first][next.second];\n\t  b.M[next.first][next.second]=c+k;\n\n\t  dfsFill(c,b,relpos,vis,S);\n\n\t  b.M[next.first][next.second]=t2;\n\t  b.M[np.first][np.second]=t1;\n\t}\n      }\n    }\n  }\n}\n\nint solve(pair<int,int> relpos[4]){\n  board init;\n  set<board> S,vis;\n  dfsFill('A', init, relpos, vis, S);\n  return S.size();\n}\n\nint main(){\n  while(true){\n    pair<int,int> relpos[4];\n    for(int i = 0; i < 4; ++i){\n      int x,y;\n      cin >> x;\n      if(x>4)return 0;\n      cin >> y;\n      relpos[i] = make_pair(y,x);\n    }\n    cout << solve(relpos) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint dx[4],dy[4];\n\nint dfs(bool (*g)[4]){\n  int e=find(g[0],g[4],false)-g[0];\n  if(e==16)return 1;\n  int y=e/4,x=e%4;\n  g[y][x]=true;\n  int r=0;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i];\n    int nx=x+dx[i];\n    if(0<=min(ny,nx)&&max(ny,nx)<4&&g[ny][nx]==false){\n      g[ny][nx]=true;\n      r+=dfs(g);\n      g[ny][nx]=false;\n    }\n  }\n  g[y][x]=false;\n  return r;\n}\n\nint main(){\n  for(;;){\n    for(int i=0;i<4;i++){\n      cin>>dx[i]>>dy[i];\n      if(dx[i]>4)return 0;\n    }\n    bool g[4][4]={{}};\n    cout<<dfs(g)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n// #include <windows.h>\n\nint ans = 0;\nint x[4],y[4];\nint depth = 0;\n\nint put_map(int m[4][4],int current){\n\t\n\tif(depth == 8){\n\t\tans++;\n\t\treturn 0;\n\t}\n\n\tint i,j,k,a,b,pointer;\n\tint next1,next2;\n\tint copy[4][4];\n\n\tfor(pointer = current; pointer < 15; pointer++){\n\t\ti = pointer / 4;\n\t\tj = pointer % 4;\n\n\t\tif(m[i][j] == 0){\n\t\t\tfor(k = 0; k < 4; k++){\n\t\t\t\tnext1 = i + x[k];\n\t\t\t\tnext2 = j + y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t//\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t//\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t//\t\t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t//\t\t}\n\t\t\t\t\t//\t\tprintf(\"\\n\");\n\t\t\t\t\t//\t}\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext1 = i - x[k];\n\t\t\t\tnext2 = j - y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint map[4][4];\n\tint i,j;\n\tscanf(\"%d\",&x[0]);\n\twhile(x[0] < 4){\n\t\tscanf(\"%d\",&y[0]);\n\t\tfor(i = 1; i < 4; i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]); // x,yの読み取り\n\t\t}\n\n\t\tans = 0; // 解の個数を0に戻す\n\t\tdepth = 0; // 探索中の深さを0に戻す\n\n\t\tfor(i = 0; i < 4; i++){\n\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\tmap[i][j] = 0; // マップの初期化\n\t\t\t}\n\t\t}\n\t\ti = put_map(map,0);\n\t\tprintf(\"%d\\n\",ans); // 解の出力\n\t\n\t\tscanf(\"%d\",&x[0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nbool m[4][4];\nint x[4],y[4];\nint dfs(int cnt){\n    int res=0;\n    if(cnt>=16) return 1;\n    int x1=cnt%4,y1=cnt/4;\n    if(m[y1][x1]) return dfs(cnt+1);\n    rep(i,4){\n        if(x1+x[i]>=0&&x1+x[i]<4&&y1+y[i]>=0&&y1+y[i]<4&&!m[y1+y[i]][x1+x[i]]){\n            m[y1][x1]=m[y1+y[i]][x1+x[i]]=true;\n            res +=dfs(cnt+1);\n            m[y1][x1]=m[y1+y[i]][x1+x[i]]=false;\n        }\n    }\n    return res;\n}\nint main(){\n    while(cin>>x[0],x[0]<5){\n        cin>>y[0]>>x[1]>>y[1]>>x[2]>>y[2]>>x[3]>>y[3];\n        memset(m,0,sizeof(m));\n        int ans=dfs(0);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nset<string> used;\nint cnt = 0;\nii raint[4];\n\nbool check(string perm)\n{\n  int num[8],index = 0;\n  rep(i,8)num[i] = -1;\n  string ast = string(16,'x');\n  rep(i,16)\n    {\n      if(num[perm[i]-'A'] == -1)\n\t{\n\t  num[perm[i]-'A'] = index++;\n\t  ast[i] = (char)(index-1+'0');\n\t}\n      else ast[i] = (char)(num[perm[i]-'A']+'0');\n    }\n  if(used.find(ast) == used.end())\n    {\n      used.insert(ast);\n      return true;\n    }\n  else return false;\n}\n\nvoid dfs(int cur,int st,string perm)\n{\n  //if(used.find(perm) != used.end())return;\n  if(cur >= 8)\n    {\n      if(check(perm))cnt++;\n      return;\n    }\n  //else used.insert(perm);\n\n  REP(i,st,16)\n    {\n      if(perm[i] != 'x')continue;\n      int x = i%4;\n      int y = i/4;\n      rep(j,4)\n\t{\n\t  int nx = x + raint[j].first;\n\t  int ny = y + raint[j].second;\n\t  if(!(0 <= nx && nx < 4 && 0 <= ny && ny < 4))continue;\n\t  if(perm[nx+ny*4] != 'x')continue;\n\t  string nperm = perm;\n\t  nperm[i] = nperm[nx+ny*4] = ('A'+cur);\n\t  dfs(cur+1,i+1,nperm);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(cin >> raint[0].first,raint[0].first <= 4)\n    {\n      cin >> raint[0].second;\n      REP(i,1,4)cin >> raint[i].first >> raint[i].second;\n      cnt = 0;\n      string perm = string(16,'x');\n\n      dfs(0,0,perm);\n\n      cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int N = 4;\n\nP in[N];\nint ans, data[N][N];\nbool used[N][N];\n\nvoid solve(int y, int x){\n  while(used[y][x]){\n    if(++x == N){\n      x = 0;\n      if(++y == N){\n        ans++;\n        return;\n      }\n    }\n  }\n  for(int i=0;i<N;i++){\n    int ny = y + in[i].first;\n    int nx = x + in[i].second;\n    if(ny<0 || ny>=N) continue;\n    if(nx<0 || nx>=N) continue;\n    if(used[ny][nx]) continue;\n    used[y][x] = used[ny][nx] = true;\n    solve(y, x);\n    used[y][x] = used[ny][nx] = false;\n  }\n}\n\nmain(){\n  while(cin >> in[0].second >> in[0].first && in[0].second <= N){\n    for(int i=1;i<N;i++) cin >> in[i].second >> in[i].first;\n    ans = 0;\n    fill(used[0], used[N], false);\n    solve(0, 0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint dx[4],dy[4],ret=0;\nint f[4][4];\n\nvoid dfs(int depth){\n    int x=-1,y=-1,nx,ny;\n\n    if(depth == 8){\n        ret++;\n        return;\n    }\n\n    for(int i=0;i<4;i++){\n        for(int j=0;j<4;j++){\n            if(f[i][j] == 0){\n                y = i;\n                x = j;\n                break;\n            }\n        }\n        if(x >= 0) break;\n    }\n    f[y][x] = 1;\n    for(int i=0;i<4;i++){\n        ny = y + dy[i];\n        nx = x + dx[i];\n        if(0 <= nx && nx < 4 && 0 <= ny && ny < 4 && !f[ny][nx]){\n            f[ny][nx] = 1;\n            dfs(depth+1);\n            f[ny][nx] = 0;\n        }\n    }\n    f[y][x] = 0;\n}\n\nint main(){\n    while(cin >> dx[0] >> dy[0]){\n        memset(f, 0, sizeof(f));\n        if(dx[0] > 4) break;\n        ret=0;\n        for(int i=1;i<4;i++){\n            cin >> dx[i] >> dy[i];\n        }\n        dfs(0);\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint x[4];\nint y[4];\n\nint b[4][4];\n\nint solve(int pos){\n  if(pos == 9){\n    //REP(i,4) { REP(j,4) printf(\"%c \", 'A' + b[i][j] - 1); puts(\"\"); } puts(\"\");\n    return 1;\n  }\n  \n  int ret = 0;\n\n\n  REP(i,4) REP(j,4){\n    if(b[i][j] == 0){\n      b[i][j] = pos;\n\n      REP(k, 4){\n\tint xx = j + x[k];\n\tint yy = i + y[k];\n\n\tif(ISIN(xx,yy,4,4) && b[yy][xx] == 0){\n\t  b[yy][xx] = pos;\n\t  //printf(\"%c: (%d, %d) (%d, %d)\\n\", 'A' + pos - 1, j, i, xx, yy);\n\t  ret += solve(pos + 1);\n\t  b[yy][xx] = 0;\n\t}\n      }\n\n      b[i][j] = 0;\n      goto end;\n    }\n  }\n end:\n\n  return ret;\n}\n\nint main(){\n  while(true){\n    REP(i,4) cin>>x[i]>>y[i];\n    if(x[0] > 4) break;\n\n    REP(i,4) REP(j,4) b[i][j] = 0;\n\n    print(solve(1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\nint c[4][4];\nint x[8],y[8];\nint ans;\nint dfs(int X,int Y){\n\tif( X == 0 && Y == 4 ) return 1;\n\tif( c[Y][X] ) return dfs(X==3?0:X+1,X==3?Y+1:Y);\n\tint ans = 0;\n\tc[Y][X] = true;\n\tfor(int i = 0 ; i < 8 ; i++){\n\t\tif( X+x[i] >= 0 && X+x[i] < 4 && Y+y[i] >= 0 && Y+y[i] < 4 ){\n\t\t\tif( c[Y+y[i]][X+x[i]] ){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tc[Y+y[i]][X+x[i]] = true;\n\t\t\tans += dfs(X==3?0:X+1,X==3?Y+1:Y);\n\t\t\tc[Y+y[i]][X+x[i]] = false;\n\t\t}\n\t}\n\tc[Y][X] = false;\n\treturn ans;\n}\nint main(){\n\tint n;\n\twhile(1){\n\t\tfor(int i = 0 ; i < 4 ; i++){\n\t\t\tcin >> x[i] >> y[i];\n\t\t\tx[4+i] = -x[i];\n\t\t\ty[4+i] = -y[i];\n\t\t\t\n\t\t\tif( x[i] > 4 ) return 0;\n\t\t}\n\t\tans=dfs(0,0);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nvector<string> split(const string &str, char delim){\n  vector<string> res;\n  size_t current = 0, found;\n  while((found = str.find_first_of(delim, current)) != string::npos){\n    res.push_back(string(str, current, found - current));\n    current = found + 1;\n  }\n  res.push_back(string(str, current, str.size() - current));\n  return res;\n}\n\nvector<int> dx, dy;\n\nint dfs(int x, int y, bool used[4][4]) {\n\n  int result = 0;\n  int new_x, new_y;\n\n  // cout << x << \" \" << y << endl;\n  // for(int i = 0;i < 4;i++) {\n\n  //   for(int j = 0;j < 4;j++) {\n\n  //     cout << used[j][i];\n  //   }\n\n  //   cout << endl;\n\n  // }\n\n  // cout << endl;\n  \n  while(used[x][y] == true) {\n\n    x++;\n\n    if(x == 4) {\n\n      y++;\n      x = 0;\n      \n      if(y == 4) {\n\n\treturn 1;\n\n      }\n\n    }\n\n  }\n\n  used[x][y] = true;\n\n  for(int i = 0;i < 4;i++) {\n\n    new_x = x + dx[i];\n    new_y = y + dy[i];\n\n    if(new_x >= 0 && new_x <= 3 && new_y >= 0 && new_y <= 3 && (used[new_x][new_y] == false)) {\n\n      used[new_x][new_y] = true;\n\n      // cout << dx[i] << \",\" << dy[i] << endl;\n      // for(int i = 0;i < 4;i++) {\n\n      // \tfor(int j = 0;j < 4;j++) {\n\n      // \t  cout << used[j][i];\n      // \t}\n\n      // \tcout << endl;\n\n      // }\n      // cout << endl;\n      if(x == 3) result += dfs(0, y+1, used);\n      else result += dfs(x+1, y, used);\n      used[new_x][new_y] = false;\n\t\n    }\n    \n  }\n\n  used[x][y] = false;\n\n  return result;\n  \n}\n\nint solve() {\n\n  bool used[4][4];\n\n  for(int i = 0;i < 4;i++) {\n\n    for(int j = 0;j < 4;j++) {\n\n      used[j][i] = false;\n\n    }\n\n  }\n  \n  return dfs(0, 0, used);\n\n}\n\nint main() {\n\n  string line;\n  vector<string> strarray;\n\n  while(getline(cin, line)) {\n    \n    if(line.length() == 1 && atoi(line.c_str()) > 4) break;\n\n    else {\n\n      dx.clear();\n      dy.clear();\n\n      strarray = split(line, ' ');\n\n      for(int i = 0;i < 8;i++) {\n\n      \tif(i % 2 == 0) dx.push_back(atoi(strarray[i].c_str()));\n\n      \telse dy.push_back(atoi(strarray[i].c_str()));\n\n      }\n\n      cout << solve() << endl;\n      \n    }\n\n  }\n  \n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\nvector<string> split(const string &str, char delim){\n  vector<string> res;\n  size_t current = 0, found;\n  while((found = str.find_first_of(delim, current)) != string::npos){\n    res.push_back(string(str, current, found - current));\n    current = found + 1;\n  }\n  res.push_back(string(str, current, str.size() - current));\n  return res;\n}\n\nvector<int> dx, dy;\n\nint dfs(int x, int y, bool used[4][4]) {\n\n  int result = 0;\n  int new_x, new_y;\n\n  // cout << x << \" \" << y << endl;\n  // for(int i = 0;i < 4;i++) {\n\n  //   for(int j = 0;j < 4;j++) {\n\n  //     cout << used[j][i];\n  //   }\n\n  //   cout << endl;\n\n  // }\n\n  // cout << endl;\n  \n  while(used[x][y] == true) {\n\n    x++;\n\n    if(x == 4) {\n\n      y++;\n      x = 0;\n      \n      if(y == 4) {\n\n\treturn 1;\n\n      }\n\n    }\n\n  }\n\n  used[x][y] = true;\n\n  for(int i = 0;i < 4;i++) {\n\n    new_x = x + dx[i];\n    new_y = y + dy[i];\n\n    if(new_x >= 0 && new_x <= 3 && new_y >= 0 && new_y <= 3 && (used[new_x][new_y] == false)) {\n\n      used[new_x][new_y] = true;\n\n      // cout << dx[i] << \",\" << dy[i] << endl;\n      // for(int i = 0;i < 4;i++) {\n\n      // \tfor(int j = 0;j < 4;j++) {\n\n      // \t  cout << used[j][i];\n      // \t}\n\n      // \tcout << endl;\n\n      // }\n      // cout << endl;\n      if(x == 3) result += dfs(0, y+1, used);\n      else result += dfs(x+1, y, used);\n      used[new_x][new_y] = false;\n\t\n    }\n    \n  }\n\n  used[x][y] = false;\n\n  return result;\n  \n}\n\nint solve() {\n\n  bool used[4][4];\n\n  for(int i = 0;i < 4;i++) {\n\n    for(int j = 0;j < 4;j++) {\n\n      used[j][i] = false;\n\n    }\n\n  }\n  \n  return dfs(0, 0, used);\n\n}\n\nint main() {\n\n  string line;\n\n  while(getline(cin, line)) {\n    \n    if(line.length() == 1 && atoi(line.c_str()) > 4) break;\n\n    else {\n\n      vector<string> strarray;\n\n      strarray = split(line, ' ');\n      \n      for(int i = 0;i < 8;i++) {\n\n\tif(i % 2 == 0) dx.push_back(atoi(strarray[i].c_str()));\n\n\telse dy.push_back(atoi(strarray[i].c_str()));\n\n      }\n\n      cout << solve() << endl;\n\n    }\n\n  }\n  \n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nint x[4],y[4];\nint fie[4][4];\nint cnt;\n\nvoid dfs(int v){\n\tif(v==8){\n\t\tcnt++;\n\t\treturn;\n\t}\n\tfor(int j=0;j<4;j++){\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(fie[k][j]==0){\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint ny=j+y[i],nx=k+x[i];\n\t\t\t\t\tif(nx>=0 && nx<4 && ny>=0 && ny<4){\n\t\t\t\t\t\tif(fie[nx][ny]==0){\n\t\t\t\t\t\t\tfie[nx][ny]=1;\n\t\t\t\t\t\t\tfie[k][j]=1;\n\t\t\t\t\t\t\tdfs(v+1);\n\t\t\t\t\t\t\tfie[nx][ny]=0;\n\t\t\t\t\t\t\tfie[k][j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&x[0]);\n\t\tif(x[0]>=5)break;\n\t\tscanf(\"%d\",&y[0]);\n\t\tfor(int i=1;i<4;i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\t}\n\t\tcnt=0;\n\t\tdfs(0);\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint dx[4],dy[4];\n\nint dfs(int y,int x,bool used[4][4]){\n\tif(y==4) return 1;\n\tif(x==4) return dfs(y+1,0,used);\n\tif(used[y][x]) return dfs(y,x+1,used);\n\n\tused[y][x]=true;\n\n\tint res=0;\n\trep(i,4) rep(j,2) {\n\t\tint yy=y+(j?1:-1)*dy[i];\n\t\tint xx=x+(j?1:-1)*dx[i];\n\t\tif(0<=yy && yy<4 && 0<=xx && xx<4 && !used[yy][xx]){\n\t\t\tused[yy][xx]=true;\n\t\t\tres+=dfs(y,x+1,used);\n\t\t\tused[yy][xx]=false;\n\t\t}\n\t}\n\n\tused[y][x]=false;\n\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\trep(i,4) scanf(\"%d%d\",dx+i,dy+i);\n\t\tif(dx[0]>4) break;\n\t\tbool used[4][4]={};\n\t\tprintf(\"%d\\n\",dfs(0,0,used));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <string,string> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[4],ty[4];\n\nint dfs(int stage,int c){\t\n\tif(c==8) return 1;\t\n\n\tint res = 0;\n\tint sx = -1;\n\tint sy = -1;\n\tfor(int y=0;y<4;y++){\n\t\tfor(int x=0;x<4;x++){\n\t\t\tif(~stage & (1<<(y*4+x))){\t\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\nfound:;\n\n\n\tif(sx == -1) return 0;\n\n\tfor(int i=0;i<4;i++){\n\t\tint dx = sx + tx[i];\n\t\tint dy = sy + ty[i];\n\t\tif(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n\t\tif(stage & (1<<(dy*4+dx))) continue;\n\n\t\tstage |= (1<<(dy*4+dx));\n\t\tstage |= (1<<(sy*4+sx));\n\t\tres += dfs(stage,c+1);\n\t\tstage &= ~(1<<(dy*4+dx));\n\t\tstage &= ~(1<<(sy*4+sx));\n\t}\n\n\treturn res;\n}\n\nint main(){\n\n\twhile(~scanf(\"%d\",tx+0)){\n\t\tif(tx[0] >= 5) break; \n\t\tscanf(\"%d %d %d %d %d %d %d\",ty+0,tx+1,ty+1,tx+2,ty+2,tx+3,ty+3);\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar mp[2001][2001];\nint p,c,w,s;\nint I,J;\n\nvoid init(){\n  I=J=0;\n  for(int i=0;i<p;i++)\n    for(int j=0;j<101;j++) mp[i][j]='.'; \n  \n  for(int i=0;i<101;i++)mp[i][c*w+(c-1)*s]='\\0';\n}\n\nint Idx(int a){\n  if(!a)return 0;\n  return a*(s+w);\n}\n\nvoid write(string str){\n  for(int i=0;i<(int)str.size();i++) mp[I][Idx(J)+i]=str[i];\n  I++;\n\n  if(I==p&&J>=c-1){\n    for(int i=0;i<p;i++) printf(\"%s\\n\",mp[i]);\n    cout<<\"#\"<<endl;\n    init();\n  }\n  if(I==p)I=0,J++;\n\n}\n\n\n//p=tate, c=page , w=moji, s=space\nint main(){\n  \n  while(1){\n    cin>>p;\n    if(!p)return 0;\n    cin>>c>>w>>s;\n    \n    init();\n    string str;\n    getline(cin,str);\n\n    while(1){\n      getline(cin,str);\n      if(str==\"?\")break;\n      if(!str.size()){write(\"\");continue;}\n\n      string a=\"\";\n      for(int i=0;i<str.size();i++){\n\ta+=str[i];\n\tif((int)a.size()>=w)write(a),a=\"\";\n      }\n      if(a.size())write(a);\n    }\n    if(I!=0)I=p-1,J=c-1,write(\"\");\n    cout<<\"?\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb         push_back\n\ntypedef long long ll;\nconst ll INF = 1000000000000000000ll;\nconst ll MOD = 1000000007ll;\nconst double EPS = 1e-8;\n\nint main(void) {\n\t//ios_base::sync_with_stdio(false);\n\t//cin.tie(0);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nchar alphabet;\nchar board[4][4];\nint dx[4], dy[4];\nint count;\n\nvoid attempt(int y, int x)\n{\n  if (y == 4) {\n    ++count;\n  } else if (board[y][x]) {\n    if (x == 3)\n      attempt(y+1, 0);\n    else\n      attempt(y, x+1);\n  } else {\n    board[y][x] = alphabet;\n    for (int i = 0; i < 4; ++i) {\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n      if (ny < 0 || ny >= 4 || nx < 0 || nx >= 4 || board[ny][nx])\n        continue;\n      board[ny][nx] = alphabet;\n      ++alphabet;\n      if (x == 3)\n        attempt(y+1, 0);\n      else\n        attempt(y, x+1);\n      --alphabet;\n      board[ny][nx] = 0;\n    }\n    board[y][x] = 0;\n  }\n}\n\nint main()\n{\n  while (scanf(\"%d%d%d%d%d%d%d%d\", dx, dy, dx+1, dy+1, dx+2, dy+2, dx+3, dy+3) == 8) {\n    memset(board, 0, sizeof(board));\n    alphabet = 'A';\n    count = 0;\n    attempt(0, 0);\n    printf(\"%d\\n\", count);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int,int> P;\nconst int SIZE = 16;\nchar field[SIZE][SIZE];\nint ans;\nvector<P> v(4);\n\nbool isInside(int h, int w){return 0<=h&&h<4&&0<=w&&w<4;}\n\nbool input(){\n  for(int i = 0; i < 4; i++)\n    if(!(cin >> v[i].first >> v[i].second)) return false;\n  return true;\n}\n\nvoid rec(char c,int pos){\n\n  int h = pos/4;\n  int w = pos%4;\n  if(pos == 16){\n    ans++;\n    return;\n  }\n\n  if(field[h][w] != '.'){\n    rec(c,pos+1);\n    return;\n  }\n \n  for(int i = 0; i < 4; i++)\n    for(int sign = 0; sign < 2; sign++){\n      int s = (sign==0?1:-1);\n      \n      int nh = h+s*v[i].first;\n      int nw = w+s*v[i].second;\n      if(!isInside(nh,nw)) continue;\n      if(field[h][w] != '.' || field[nh][nw] != '.') continue;\n      \n      field[h][w] = field[nh][nw] = c;\n      rec(c+1,pos+1);\n      field[h][w] = field[nh][nw] = '.';\n    }\n}\n\nint main(){\n\n  while(input()){\n    memset(field,'.',sizeof(field));\n    ans = 0;\n    rec('A',0);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nbool passed[101][101];\nvector<pair<int,int> > d;\nint cnt=0;\n\n// Eº©çÔÉèµÄ¢­\nvoid dfs(int x,int y,int left){\n  // cèª0ÉÈÁ½çJEg\n  if(left==0)\n    cnt++;\n  else{\n    // »ÝÌêðè\n    // à¤ÊßÏÝÈçAÖ\n    if(passed[y][x]){\n      int ny=y;\n      int nx=x-1;\n      if(nx<0){\n\tny--;nx=3;\n\tif(ny<0)\n\t  return;\n      }\n      dfs(nx,ny,left);\n    }\n    else{\n      // ÊßÏÝÅÈ¢ÈçAÜ¾ÇÁÅ«éÆ±ëð\n      // ÇÁµAÄA\n      passed[y][x]=true;\n      for(int i = 0; i < d.size(); i++){\n\tint ny=d[i].first+y;\n\tint nx=d[i].second+x;\n\t// ÍÍàÅ é\n\tif(ny>=0&&nx>=0&&ny<4&&nx<4&&!passed[ny][nx]){\n\t  // ÊßÏÝÉ·é\n\t  passed[ny][nx]=true;\n\t  // »ÝÊuÌÌêÉÚ®µAÄA\n\t  int nny=y;int nnx=x-1;\n\t  if(nnx<0){\n\t    nny--;nnx=3;\n\t  }\n\t  dfs(nnx,nny,left-2);\n\t  // ³Éß·\n\t  passed[ny][nx]=false;\n\t}\n      }\n      passed[y][x]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    memset(passed,0,sizeof(passed));\n    d.clear();cnt=0;\n    for(int i = 0; i < 4; i++){\n      int x,y;\n      cin>>x;\n      if(x>4)\n\treturn 0;\n      cin>>y;\n      d.push_back(make_pair(-y,-x));\n    }\n    dfs(3,3,16);\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=a; i<b; i++)\n#define rep(i,a) loop(i,0,a)\n\nint rx[4],ry[4];\nbool v[4][4];\n\ninline bool in(int x, int y){\n    return 0<=x&&x<=3&&0<=y&&y<=3;\n}\n\nint f(){\n    int xx=-1,yy=-1;\n    rep(i,16){\n        int tx=i&3;\n        int ty=i>>2;\n        if(!v[ty][tx]){\n            xx=tx,yy=ty;\n            break;\n        }\n    }\n    if(xx<0) return 1;\n\n    v[yy][xx]=1;\n    int ans=0;\n    for(int i=0;i<4;i++){\n        int nx=xx+rx[i],ny=yy+ry[i];\n        if(in(nx,ny)&&!v[ny][nx]){\n            v[ny][nx]=1;\n            ans+=f();\n            v[ny][nx]=0;\n        }\n    }\n    v[yy][xx]=0;\n    return ans;\n}\n\nint main(void){\n    while(1){\n        cin>>rx[0];\n        if(rx[0]>=5) return 0;\n        cin>>ry[0];\n        loop(i,1,4) cin>>rx[i]>>ry[i];\n        memset(v,0,sizeof(v));\n        cout<<f()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (typeof((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(typeof(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\nint dx[4], dy[4];\n\nbool used[4][4];\nint res = 0;\n\nvoid dfs(int con, int x, int y) {\n    if (con == 8) {\n        ++res;\n        return;\n    }\n    for (int i = 0; i < 4; ++i) {\n        int px = x + dx[i], py = y + dy[i];\n        if (px < 0 || px >= 4 || py < 0 || py >= 4) continue;\n        if (!used[px][py]) {\n            used[x][y] = true;\n            used[px][py] = true;\n            \n            int nx = 0, ny = 0;\n            while (used[nx][ny]) {\n                ++nx;\n                if (nx == 4) nx = 0, ++ny;\n            }\n                \n            dfs(con+1, nx, ny);\n            used[x][y] = false;\n            used[px][py] = false;\n        }\n    }\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Documents/Programming/Contest/input.in\", \"r\", stdin );\n    \n    while (cin >> dx[0]) {\n        if (dx[0] == 5) break;\n        cin >> dy[0] >> dx[1] >> dy[1] >> dx[2] >> dy[2] >> dx[3] >> dy[3];\n        \n        for (int i = 0; i < 4; ++i) if (dy[i] < 0) {dx[i] = -dx[i]; dy[i] = -dy[i];}\n        \n        res = 0;\n        memset(used, 0, sizeof(used));\n        dfs(0, 0, 0);\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nset<string> used;\nint cnt = 0;\nii raint[4];\n\nvoid dfs(int cur,int st,string perm)\n{\n  if(cur >= 8)\n    {\n      if(used.find(perm) != used.end())return;\n      used.insert(perm);\n      rep(i,16)if(perm[i] == 'x')return;\n\tcnt++;\n      return;\n    }\n\n  REP(i,st,16)\n    {\n      int x = i%4;\n      int y = i/4;\n      rep(j,4)\n\t{\n\t  int nx = x + raint[j].first;\n\t  int ny = y + raint[j].second;\n\t  if(!(0 <= nx && nx < 4 && 0 <= ny && ny < 4))continue;\n\t  if(perm[nx+ny*4] != 'x')continue;\n\t  string nperm = perm;\n\t  nperm[x+y*4] = nperm[nx+ny*4] = (char)('0'+cur);\n\t  dfs(cur+1,i+1,nperm);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(cin >> raint[0].first,raint[0].first <= 4)\n    {\n      cin >> raint[0].second;\n      REP(i,1,4)cin >> raint[i].first >> raint[i].second;\n      cnt = 0;\n      string perm = string(16,'x');\n\n      dfs(0,0,perm);\n\n      cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\ntypedef long long int uli;\n\nint x[4],y[4];\nuli f[16][16][16][16];\nint bat(int n,int idx){\n   if(n&(1<<idx))return 1;\n   return 0;\n}\nuli solve(int p[4]){\n   uli &ans=f[p[0]][p[1]][p[2]][p[3]];\n   if(ans!=-1)return ans;\n   ans=0;\n   bool fnd=false;\n   for(int i=0;i<4 && !fnd;i++){\n      for(int j=0;j<4 && !fnd;j++){\n         if(bat(p[i],3-j)==1)continue;\n         int r=i,c=j;\n         fnd=true;\n         for(int k=0;k<4;k++){\n            int sgn=-1;\n            for(int l=0;l<2;l++){\n               sgn*=-1;\n               int nr=r+sgn*x[k];\n               int nc=c+sgn*y[k];\n               if(0<=nr && nr<4 && 0<=nc && nc<4){\n                  if(bat(p[nr],3-nc)==1)continue;\n                  int q[4]={p[0],p[1],p[2],p[3]};\n                  q[r]^=(1<<(3-c));\n                  q[nr]^=(1<<(3-nc));\n                  ans+=solve(q);\n               }\n            }\n         }\n      }\n   }\n   return ans;\n}\nint main(){\n   while(scanf(\"%d\",x)==1){\n      if(x[0]>4)break;\n      scanf(\"%d\",y);\n      for(int i=1;i<4;i++)\n         scanf(\"%d %d\",x+i,y+i);\n      memset(f,-1,sizeof f);\n      f[15][15][15][15]=1;\n      int p[4]={0,0,0,0};\n      uli ans=solve(p);\n      printf(\"%lld\\n\",ans);\n   }\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<cassert>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint plen,cnum,width,cspace;\n\nvoid compute()\n{\n  char text[plen][cnum*width+(cnum-1)*cspace];  \n  string line;\n  int x,y,r;\n  x = y = r = 0;\n  rep(i,plen)rep(j,cnum*width+(cnum-1)*cspace)text[i][j] = '.';\n  cin.ignore();\n  bool printed = false;\n  bool update = false;\n  while(true)\n    {\n\n      getline(cin,line);\n      if(line == \"?\")break;\n      update = true;\n      if(printed)printed = false;\n      //cout << \"line : \" << line << endl;\n\n      if(line == \"\")\n\t{\n\t  x = 0;\n\t  y++;\n\t  if(y >= plen)\n\t    {\n\t      y = 0;\n\t      r++;\n\t    }\n\t  if(r >= cnum)\n\t    {\n\t      printed = true;\n\t      x = y = r = 0;\n\t      rep(j,plen)\n\t\t{\n\t\t  rep(k,width*cnum+cspace*(cnum-1))\n\t\t    {\n\t\t      cout << text[j][k];\n\t\t    }\n\t\t  cout << endl;\n\t\t}\n\t      cout << \"#\" << endl;\n\n\t      rep(j,plen)rep(k,width*cnum+(cnum-1)*cspace)text[j][k] = '.';\n\t    }\n\t  continue;\n\t}\n      rep(i,line.size())\n\t{\n\n\t  if(x >= width)\n\t    {\n\t      x = 0;\n\t      y++;\n\t    }\n\t  if(y >= plen)\n\t    {\n\t      y = 0;\n\t      r++;\n\t    }\n\t  if(r >= cnum)\n\t    {\n\t      printed = true;\n\t      x = y = r = 0;\n\t      rep(j,plen)\n\t\t{\n\t\t  rep(k,width*cnum+cspace*(cnum-1))\n\t\t    {\n\t\t      cout << text[j][k];\n\t\t    }\n\t\t  cout << endl;\n\t\t}\n\t      rep(j,plen)rep(k,width*cnum+(cnum-1)*cspace)text[j][k] = '.';\n\t      cout << \"#\" << endl;\n\t    }\n\n\t  text[y][x+r*(width+cspace)] = line[i];\n\t  x++;\n\t  printed = false;\n\n\t}\n      x = 0;\n      y++;\n      if(y >= plen)\n\t{\n\t  y = 0;\n\t  r++;\n\t}\n      if(r >= cnum)\n\t{\n\t  printed = true;\n\t      x = y = r = 0;\n\t      rep(j,plen)\n\t\t{\n\t\t  rep(k,width*cnum+(cnum-1)*cspace)\n\t\t    {\n\t\t      cout << text[j][k];\n\t\t    }\n\t\t  cout << endl;\n\t\t}\n\t      cout << \"#\" << endl;\n\t      rep(j,plen)rep(k,width*cnum+(cnum-1)*cspace)text[j][k] = '.';\n\t}\n      // cout << \"x,y,r = \" << x << \",\" << y << \",\" << r<< endl;\n    }\n  // cout << \"printed ? \" << printed << endl;\n  if(!update)printed =true;\n  if(!printed)\n    {\n      rep(j,plen)\n\t\t{\n\t\t  rep(k,width*cnum+cspace*(cnum-1))\n\t\t    {\n\t\t      cout << text[j][k];\n\t\t    }\n\t\t  cout << endl;\n\t\t}\n\t      cout << \"#\" << endl;\n\t      rep(j,plen)rep(k,width*cnum+cspace*(cnum-1))text[j][k] = '.';\n    }\n  cout << \"?\" << endl;\n}\n\nint main()\n{\n  while(cin >> plen,plen)\n    {\n      cin >> cnum >> width >> cspace;\n      compute();\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\nusing namespace std;\n\nbool passed[101][101];\nvector<pair<int,int> > d;\nint cnt=0;\n\nvoid dfs(int x,int y,int left){\n  if(left==0)\n    cnt++;\n  else{\n    if(passed[y][x]){\n      int ny=y;\n      int nx=x-1;\n      if(nx<0){\n\tny--;nx=3;\n\tif(ny<0)\n\t  return;\n      }\n      dfs(nx,ny,left);\n    }\n    else{\n      passed[y][x]=true;\n      for(int i = 0; i < d.size(); i++){\n\tint ny=d[i].first+y;\n\tint nx=d[i].second+x;\n\tif(ny>=0&&nx>=0&&ny<4&&nx<4&&!passed[ny][nx]){\n\t  passed[ny][nx]=true;\n\t  int nny=y;int nnx=x-1;\n\t  if(nnx<0){\n\t    nny--;nnx=3;\n\t  }\n\t  dfs(nnx,nny,left-2);\n\t  passed[ny][nx]=false;\n\t}\n      }\n      passed[y][x]=false;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    memset(passed,0,sizeof(passed));\n    d.clear();cnt=0;\n    for(int i = 0; i < 4; i++){\n      int x,y;\n      cin>>x;\n      if(x>4)\n\treturn 0;\n      cin>>y;\n      d.push_back(make_pair(-y,-x));\n    }\n    dfs(3,3,16);\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dx[4];\nint dy[4];\nint f[4][4];\n\nint dfs(int x, int y)\n{\n\tint ret=0;\n\t//cout << x << \" \" << y << endl;\n\n\tif(x==0 && y==4)\n\t{\n\t\treturn 1;\n\t}\n\n\tfor(int i=0; i<4; i++)\n\t{\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\n\t\tif(0<=nx && nx<=3 && 0<=ny && ny<=3)\n\t\t{\n\t\t\tif(f[nx][ny]) continue;\n\t\t\tf[nx][ny] = 1;\n\t\t\tf[x][y]=1;\n\n\t\t\tint t=y*4+x+1;\n\t\t\tfor(; t<16; t++)\n\t\t\t{\n\t\t\t\tif(f[t%4][t/4]==0) break;\n\t\t\t}\n\t\t\tret += dfs(t%4,t/4);\n\t\t\tf[x][y]=0;\n\t\t\tf[nx][ny] = 0;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile(cin >> dx[0])\n\t{\n\t\tif(dx[0]>4) break;\n\t\t\n\t\tcin >> dy[0];\n\t\tfor(int i=1; i<4; i++)\n\t\t{\n\t\t\tcin >> dx[i] >> dy[i];\n\t\t}\n\n\t\tmemset(f,0,sizeof(f));\n\t\tcout << dfs(0,0) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\ntypedef long long ll;\n\nint main(){\n    int x[4], y[4];\n    while(cin >> x[0], x[0] < 4){\n        cin >> y[0];\n        for(int i = 1; i < 4; i++)  cin >> x[i] >> y[i];\n        vector<int> v;\n        for(int i = 0; i < 4; i++){\n            for(int j = 0; j < 4; j++){\n                int origin = i*4+j;\n                for(int k = 0; k < 4; k++){\n                    int ni = i+x[k], nj = j+y[k];\n                    if(!inRange(ni,0,4)||!inRange(nj,0,4))  continue;\n                    int next = ni*4+nj;\n                    v.push_back((1<<origin) + (1<<next));\n                }\n            }\n        }\n        sort(v.begin(),v.end());\n        v.erase(unique(v.begin(),v.end()),v.end());\n        vector<ll> dp(1<<16, 0);\n        dp[0] = 1;\n        for(int s = 0; s < 1<<16; s++){\n            for(int j : v){\n                if((s&j) == 0)  dp[s^j] += dp[s];\n            }\n        }\n        cout << dp.back()/40320 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint dx[4],dy[4];\n\nint dfs(int y,int x,bool used[4][4]){\n\tif(y==4) return 1;\n\tif(x==4) return dfs(y+1,0,used);\n\tif(used[y][x]) return dfs(y,x+1,used);\n\n\tused[y][x]=true;\n\n\tint res=0;\n\trep(i,4){\n\t\tint yy=y+dy[i];\n\t\tint xx=x+dx[i];\n\t\tif(0<=yy && yy<4 && 0<=xx && xx<4 && !used[yy][xx]){\n\t\t\tused[yy][xx]=true;\n\t\t\tres+=dfs(y,x+1,used);\n\t\t\tused[yy][xx]=false;\n\t\t}\n\t}\n\n\tused[y][x]=false;\n\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\trep(i,4) scanf(\"%d%d\",dx+i,dy+i);\n\t\tif(dx[0]>4) break;\n\t\tbool used[4][4]={};\n\t\tprintf(\"%d\\n\",dfs(0,0,used));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar mp[101][101];\nint p,c,w,s;\nint I,J;\n\nvoid init(){\n  I=J=0;\n  for(int i=0;i<p;i++)\n    for(int j=0;j<101;j++) mp[i][j]='.'; \n  \n  for(int i=0;i<101;i++)mp[i][c*w+(c-1)*s]='\\0';\n}\n\nint Idx(int a){\n  if(!a)return 0;\n  return a*(s+w);\n}\n\nvoid write(string str){\n  for(int i=0;i<(int)str.size();i++) mp[I][Idx(J)+i]=str[i];\n  I++;\n\n  if(I==p&&J>=c-1){\n    for(int i=0;i<p;i++) printf(\"%s\\n\",mp[i]);\n    cout<<\"#\"<<endl;\n    init();\n  }\n  if(I==p)I=0,J++;\n\n}\n\n\n//p=tate, c=page , w=moji, s=space\nint main(){\n  \n  while(1){\n    cin>>p;\n    if(!p)return 0;\n    cin>>c>>w>>s;\n    \n    init();\n    string str;\n    getline(cin,str);\n\n    while(1){\n      getline(cin,str);\n      if(str==\"?\")break;\n      if(!str.size()){write(\"\");continue;}\n\n      string a=\"\";\n      for(int i=0;i<str.size();i++){\n\ta+=str[i];\n\tif((int)a.size()>=w)write(a),a=\"\";\n      }\n      if(a.size())write(a);\n    }\n    if(I!=0)I=p-1,J=c-1,write(\"\");\n    cout<<\"?\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nbool m[4][4];\nint x[4],y[4];\nint dfs(int cnt){\n    int res=0;\n    if(cnt>16) return 1;\n    int x1=cnt%4,y1=cnt/4;\n    if(m[y1][x1]) return dfs(cnt+1);\n    rep(i,4){\n        if(x1+x[i]>=0&&x1+x[i]<4&&y1+y[i]>=0&&y1+y[i]<4&&!m[y1+y[i]][x1+x[i]]){\n            m[y1][x1]=m[y1+y[i]][x1+x[i]]=true;\n            res +=dfs(cnt+1);\n            m[y1][x1]=m[y1+y[i]][x1+x[i]]=false;\n        }\n    }\n    return res;\n}\nint main(){\n    while(cin>>x[0],x[0]<5){\n        cin>>y[0]>>x[1]>>y[1]>>x[2]>>y[2]>>x[3]>>y[3];\n        memset(m,0,sizeof(m));\n        int ans=dfs(0);\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint out;\nint in[4][2];\nvvi fil;\nvoid f(int a){\n\tif(a==16){\n\t\tout++;\n\t\treturn;\n\t}\n\tint x=a/4,y=a%4;\n\tif(fil[x][y]){\n\t\tf(a+1);\n\t\treturn;\n\t}\n\trep(i,4){\n\t\tint nx=x+in[i][1];\n\t\tint ny=y+in[i][0];\n\t\tif(nx<0||ny<0||nx>=4||ny>=4||fil[nx][ny])continue;\n\t\tfil[x][y]=fil[nx][ny]=true;\n\t\tf(a+1);\n\t\tfil[x][y]=fil[nx][ny]=false;\n\t}\n}\nint main(){\n\tint q;\n\twhile(cin>>q,q<5){\n\t\tfil=vvi(4,vi(4));\n\t\trep(i,8){\n\t\t\tif(i)cin>>in[i/2][i%2];\n\t\t\telse in[0][0]=q;\n\t\t}\n\t\tout=0;\n\t\tf(0);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\n#define LP(i,n) for(int i = 0; i < n; i++)\n\nusing namespace std;\n\nint s;\nint x[4][2];\n\nvoid comb(int y[8], int n){\n\tif(n == 8){\n\t\tint p[4][4];\n\t\tmemset(p,0,sizeof p);\n\t\tint idx = 0;\n\t\tfor(int j = 0 ; j< 4 ;j++){\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tif(p[i][j]==0){\n\t\t\t\t\tif(0<=i+x[y[idx]][0]&&i+x[y[idx]][0]<4&&0<=j+x[y[idx]][1]&&j+x[y[idx]][1]<4&&p[i+x[y[idx]][0]][j+x[y[idx]][1]] == 0){\n\t\t\t\t\t\tp[i+x[y[idx]][0]][j+x[y[idx]][1]] = ++idx;\n\t\t\t\t\t}else return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ts++;\n\t\treturn;\n\t}\n\tfor(int i = 0; i < 4; i++){\n\t\ty[n] = i;\n\t\tcomb(y,n+1);\n\t}\n}\n\nint main(){\n\tcin >> **x;\n\twhile(**x < 5){\n\t\ts = 0;\n\t\tfor(int i = 1; i < 8; i++){\n\t\t\tcin >> *(*x+i);\n\t\t}\n\t\tint y[8];\n\t\tcomb(y,0);\n\t\tcout << s << endl;\n\t\tcin >> **x;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nint board[4][4];\n \nbool inField(int x,int y){\n    return (0 <= x && x < 4 && 0 <= y && y < 4);\n}\n \nint solve(int idx,int *x,int *y){\n    if(idx == 8){ return 1; }\n    int sx,sy;\n    for(int i = 0 ; i < 4 ; i++){\n\tbool found = false;\n\tfor(int j = 0 ; j < 4 ; j++){\n\t    if(board[i][j] == -1){\n\t\tsx = j; sy = i;\n\t\tfound = true;\n\t\tbreak;\n\t    }\n\t}\n\tif(found){ break; }\n    }\n    int res = 0;\n    for(int i = 0 ; i < 4 ; i++){\n\tint tx = sx+x[i],ty = sy+y[i];\n\tif(!inField(tx,ty) || board[ty][tx] != -1){\n\t    continue;\n\t}\n\tboard[sy][sx] = board[ty][tx] = idx;\n\tres += solve(idx+1,x,y);\n\tboard[sy][sx] = board[ty][tx] = -1;\n    }\n    return res;\n}\n \nint main(){\n    int x[4],y[4];\n    while(cin >> x[0] >> y[0], x[0] < 4){\n\tfor(int i = 1 ; i < 4 ; i++){\n\t    cin >> x[i] >> y[i];\n\t}\n\tmemset(board,-1,sizeof(board));\n\tcout << solve(0,x,y) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nbool in_range(int i, int j) {\n  return 0 <= i && i < 4 && 0 <= j && j < 4; \n}\n\nvector<int> x(4), y(4);\n\nbool G[4][4];\n\nint rec(int i, int j) {\n  \n  int ni = i, nj = j + 1;\n    \n  if(nj == 4) {\n    ni ++;\n    nj = 0;\n  }\n  \n  if(ni == 4) return G[i][j];\n\n  if(G[i][j]) return rec(ni, nj);\n  \n  int ret = 0;\n\n  G[i][j] = 1;\n  \n  rep(k, 4) {\n    int pi = i + y[k], pj = j + x[k];\n    if(!in_range(pi, pj)) continue;\n    if(G[pi][pj]) continue; // iranai ?\n    G[pi][pj] = 1;\n    ret += rec(ni, nj);\n    G[pi][pj] = 0;\n  }\n  \n  G[i][j] = 0;\n  \n  return ret;\n}\n\nint main() {\n\n  while(1) {\n    rep(i, 4) {\n      cin >> x[i] >> y[i];\n      if(cin.eof()) exit(0);\n    }\n    \n    rep(i, 4) rep(j, 4) G[i][j] = 0;\n    cout << rec(0, 0) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<int> dy(4), dx(4);\nvector<vector<bool> > check(4, vector<bool>(4, false));\n\nint solve(int y0, int x0){\n    if(y0 == 4)\n        return 1;\n    if(x0 == 4)\n        return solve(y0+1, 0);\n    if(check[y0][x0])\n        return solve(y0, x0+1);\n\n    check[y0][x0] = true;\n\n    int ret = 0;\n    for(int i=0; i<4; ++i){\n        int y1 = y0 + dy[i];\n        int x1 = x0 + dx[i];\n        if(y1 >= 4 || x1 < 0 || x1 >= 4 || check[y1][x1])\n            continue;\n        check[y1][x1] = true;\n        ret += solve(y0, x0+1);\n        check[y1][x1] = false;\n    }\n\n    check[y0][x0] = false;\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        for(int i=0; i<4; ++i)\n            cin >> dx[i] >> dy[i];\n        if(dx[0] > 4)\n            return 0;\n\n        cout << solve(0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\nusing namespace std;\n#include <iostream>\n#include <vector>\n#include <string.h>\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef vector<int> VI;\n\nint cnt;\nint num[8];\n\nvoid solve(VI board, int depth)\n{\n\t//end check\n\tif(depth == 8)\n\t{\n\t\tbool is_end = true;\n\t\tREP(i, board.size())\n\t\t{\n\t\t\tif(board[i] == 0)\n\t\t\t{\n\t\t\t\tis_end = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_end){\n\t \t\tcnt++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//normal procedure\n\tbool is_set = false;\n\tREP(y, 4)\n\t{\n\t\tREP(x, 4)\n\t\t{\n\t\t\tif(board[y*4+x] == 0)\n\t\t\t{\n\t\t\t\tREP(i, 4)\n\t\t\t\t{\n\t\t\t\t\tint dx = num[i*2+0];\n\t\t\t\t\tint dy = num[i*2+1];\n\t\t\t\t\tint xx = x + dx;\n\t\t\t\t\tint yy = y + dy;\n\t\t\t\t\tif(xx>=0 && yy>=0 && xx<4 && yy<4) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(board[yy*4+xx] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVI v = VI(16);\n\t\t\t\t\t\t\tmemcpy(&v[0], &board[0], sizeof(int)*16);\n\t\t\t\t\t\t\tv[y*4+x] = depth+1;\n\t\t\t\t\t\t\tv[yy*4+xx] = depth+1;\n\t\t\t\t\t\t\tsolve(v, depth+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tis_set = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(is_set) break;\n\t}\t\n}\n   \nint main()\n{\n\twhile( 1 )\n\t{\n\t\tscanf(\"%d\", &num[0]);\n\t\tif(num[0] > 4) break;\n\t\t\n\t\tfor(int i=1; i<8; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &num[i]);\n\t\t}\n\n\t\tcnt = 0;\n\t\tVI v = VI(16);\n\t\tmemset(&v[0], 0, sizeof(int)*16);\n\t\tsolve(v, 0);\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdafx.h\"\n#include <stdio.h>\n\nint ans = 0;\nint x[4],y[4];\nint depth = 0;\n\nint put_map(int m[4][4],int current){\n\t\n\tif(depth == 8){\n\t\tans++;\n\t\treturn 0;\n\t}\n\n\tint i,j,k,a,b,pointer;\n\tint next1,next2;\n\tint copy[4][4];\n\n\tfor(pointer = current; pointer < 15; pointer++){\n\t\ti = pointer / 4;\n\t\tj = pointer % 4;\n\n\t\tif(m[i][j] == 0){\n\t\t\tfor(k = 0; k < 4; k++){\n\t\t\t\tnext1 = i + x[k];\n\t\t\t\tnext2 = j + y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext1 = i - x[k];\n\t\t\t\tnext2 = j - y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint map[4][4];\n\tint i,j;\n\tscanf(\"%d\",&x[0]);\n\twhile(x[0] < 4){\n\t\tscanf(\"%d\",&y[0]);\n\t\tfor(i = 1; i < 4; i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]);\t}\n\n\t\tans = 0;\n\t\tdepth = 0;\n\n\t\tfor(i = 0; i < 4; i++){\n\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\tmap[i][j] = 0; \t\t\t}\n\t\t}\n\t\ti = put_map(map,0);\n\t\tprintf(\"%d\\n\",ans);\t\n\t\tscanf(\"%d\",&x[0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\nset<string> used;\nint cnt = 0;\nii raint[4];\n\nvoid dfs(int cur,int st,string perm)\n{\n  if(cur >= 8)\n    {\n      if(used.find(perm) != used.end())return;\n      used.insert(perm);\n      rep(i,16)if(perm[i] == 'x')return;\n\tcnt++;\n      return;\n    }\n\n  REP(i,st,16)\n    {\n      int x = i%4;\n      int y = i/4;\n      rep(j,4)\n\t{\n\t  int nx = x + raint[j].first;\n\t  int ny = y + raint[j].second;\n\t  if(!(0 <= nx && nx < 4 && 0 <= ny && ny < 4))continue;\n\t  if(perm[nx+ny*4] != 'x')continue;\n\t  string nperm = perm;\n\t  nperm[x+y*4] = nperm[nx+ny*4] = (char)('0'+cur);\n\t  dfs(cur+1,i+1,nperm);\n\t}\n    }\n\n}\n\nint main()\n{\n  while(cin >> raint[0].first,raint[0].first <= 4)\n    {\n      used.clear();\n      cin >> raint[0].second;\n      REP(i,1,4)cin >> raint[i].first >> raint[i].second;\n      cnt = 0;\n      string perm = string(16,'x');\n\n      dfs(0,0,perm);\n\n      cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define REP(i,a,n) for(i=a; i<n; i++)\n#define rep(i,n) REP(i,0,n)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define foreach(it,x) for(typeof(x.begin()) it=x.begin(); it!=x.end(); it++)\n\nint x[4],y[4];\nbool board[4][4];\n\nint solve(int cnt){\n    int i, j, k, res = 0;\n\n    if( cnt == 8 ) return 1;\n\n    bool f = false;\n    rep(i,4){\n        rep(j,4){\n            if( !board[i][j] ){\n                f = true; break;\n            }\n        }\n        if( f ) break;\n    }\n\n    rep(k,4){\n        int tx = j + x[k];\n        int ty = i + y[k];\n        if( tx < 0 || tx >= 4 || ty >= 4 || ty < 0 || board[ty][tx] ) continue;\n        board[i][j] = board[ty][tx] = true;\n        res += solve(cnt+1);\n        board[i][j] = board[ty][tx] = false;\n    }\n    return res;\n}\n\nint main(){\n\n    while( scanf(\"%d %d %d %d %d %d %d %d\",x,y,x+1,y+1,x+2,y+2,x+3,y+3) != 1 ){\n        memset(board, false, sizeof(board));\n        cout << solve(0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"stdafx.h\"\n#include <stdio.h>\n// #include <windows.h>\n\nint ans = 0;\nint x[4],y[4];\nint depth = 0;\n\nint put_map(int m[4][4],int current){\n\t\n\tif(depth == 8){\n\t\tans++;\n\t\treturn 0;\n\t}\n\n\tint i,j,k,a,b,pointer;\n\tint next1,next2;\n\tint copy[4][4];\n\n\tfor(pointer = current; pointer < 15; pointer++){\n\t\ti = pointer / 4;\n\t\tj = pointer % 4;\n\n\t\tif(m[i][j] == 0){\n\t\t\tfor(k = 0; k < 4; k++){\n\t\t\t\tnext1 = i + x[k];\n\t\t\t\tnext2 = j + y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t//\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t//\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t//\t\t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t//\t\t}\n\t\t\t\t\t//\t\tprintf(\"\\n\");\n\t\t\t\t\t//\t}\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext1 = i - x[k];\n\t\t\t\tnext2 = j - y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tprintf(\"\\n\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint map[4][4];\n\tint i,j;\n\tscanf(\"%d\",&x[0]);\n\twhile(x[0] < 4){\n\t\tscanf(\"%d\",&y[0]);\n\t\tfor(i = 1; i < 4; i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]); // x,yの読み取り\n\t\t}\n\n\t\tans = 0; // 解の個数を0に戻す\n\t\tdepth = 0; // 探索中の深さを0に戻す\n\n\t\tfor(i = 0; i < 4; i++){\n\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\tmap[i][j] = 0; // マップの初期化\n\t\t\t}\n\t\t}\n\t\ti = put_map(map,0);\n\t\tprintf(\"%d\\n\",ans); // 解の出力\n\t\n\t\tscanf(\"%d\",&x[0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\npair<int,int> rp[4];\nchar bd[4][4];\nint dfs(char c){\n\tif(c=='I')return 1;\n\tint r=0;\n\trep(y,4)rep(x,4)if(bd[y][x]=='.'){\n\t\tbd[y][x]=c;\n\t\trep(k,4){\n\t\t\tint ny=y+rp[k].first,nx=x+rp[k].second;\n\t\t\tif(0<=ny&&ny<4&&0<=nx&&nx<4&&bd[ny][nx]=='.'){\n\t\t\t\tbd[ny][nx]=c;\n\t\t\t\tr+=dfs(c+1);\n\t\t\t\tbd[ny][nx]='.';\n\t\t\t}\n\t\t}\n\t\tbd[y][x]='.';\n\t\tif(r>0)return r;\n\t}\n\treturn 0;\n}\nint main(){\n\tint a,b;\n\twhile(cin>>a,a<5){\n\t\tcin>>b; rp[0]=make_pair(b,a);\n\t\trep(i,3)cin>>a>>b,rp[i+1]=make_pair(b,a);\n\t\trep(i,4)rep(j,4)bd[i][j]='.';\n\t\tcout<<dfs('A')<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nchar mp[101][101];\nint p,c,w,s;\nint I,J;\n\nvoid init(){\n  I=J=0;\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++) mp[i][j]='.'; \n  \n  for(int i=0;i<101;i++)mp[i][c*w+(c-1)*s]='\\0';\n}\n\nint Idx(int a){\n  if(!a)return 0;\n  return a*(s+w);\n}\n\nvoid write(string str){\n  for(int i=0;i<(int)str.size();i++) mp[I][Idx(J)+i]=str[i];\n  I++;\n\n  if(I==p&&J>=c-1){\n    for(int i=0;i<p;i++) printf(\"%s\\n\",mp[i]);\n    cout<<\"#\"<<endl;\n    init();\n  }\n  if(I==p)I=0,J++;\n\n}\n\n\n//p=tate, c=page , w=moji, s=space\nint main(){\n  int cnt=0;\n  \n  while(1){\n    cin>>p;\n    if(!p)return 0;\n    cin>>c>>w>>s;\n    \n    \n    \n    init();\n    string str;\n    getline(cin,str);\n    while(1){\n      getline(cin,str);\n      if(str==\"?\")break;\n      if(!str.size()){write(\"\");continue;}\n\n      string a=\"\";\n      for(int i=0;i<str.size();i++){\n\ta+=str[i];\n\tif((int)a.size()>=w)write(a),a=\"\";\n      }\n      if(a.size())write(a);\n    }\n    if(I!=0)J=1;\n    while(J!=0)write(\"\");\n    cout<<\"?\"<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#include <iostream>\n#include <vector>\n\n#define REP(i, n) for(int i=0; i<n; i++)\n\ntypedef vector<int> VI;\n\nint cnt;\nint num[8];\n\nvoid solve(VI board, int depth)\n{\n\t//end check\n\tif(depth == 8)\n\t{\n\t\tbool is_end = true;\n\t\tREP(i, board.size())\n\t\t{\n\t\t\tif(board[i] == 0)\n\t\t\t{\n\t\t\t\tis_end = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_end){\n\t \t\tcnt++;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t//normal procedure\n\tbool is_set = false;\n\tREP(y, 4)\n\t{\n\t\tREP(x, 4)\n\t\t{\n\t\t\tif(board[y*4+x] == 0)\n\t\t\t{\n\t\t\t\tREP(i, 4)\n\t\t\t\t{\n\t\t\t\t\tint dx = num[i*2+0];\n\t\t\t\t\tint dy = num[i*2+1];\n\t\t\t\t\tint xx = x + dx;\n\t\t\t\t\tint yy = y + dy;\n\t\t\t\t\tif(xx>=0 && yy>=0 && xx<4 && yy<4) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(board[yy*4+xx] == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tVI v = VI(16);\n\t\t\t\t\t\t\tmemcpy(&v[0], &board[0], sizeof(int)*16);\n\t\t\t\t\t\t\tv[y*4+x] = depth+1;\n\t\t\t\t\t\t\tv[yy*4+xx] = depth+1;\n\t\t\t\t\t\t\tsolve(v, depth+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tis_set = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(is_set) break;\n\t}\t\n}\n   \nint main()\n{\n\twhile( 1 )\n\t{\n\t\tscanf(\"%d\", &num[0]);\n\t\tif(num[0] > 4) break;\n\t\t\n\t\tfor(int i=1; i<8; i++)\n\t\t{\n\t\t\tscanf(\"%d\", &num[i]);\n\t\t}\n\n\t\tcnt = 0;\n\t\tVI v = VI(16);\n\t\tmemset(&v[0], 0, sizeof(int)*16);\n\t\tsolve(v, 0);\n\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n//#include <windows.h>\n\nint ans = 0;\nint x[4],y[4];\nint depth = 0;\n\nint put_map(int m[4][4],int current){\n\t\n\tif(depth == 8){\n\t\tans++;\n\t\treturn 0;\n\t}\n\n\tint i,j,k,a,b,pointer;\n\tint next1,next2;\n\tint copy[4][4];\n\n\tfor(pointer = current; pointer < 15; pointer++){\n\t\ti = pointer / 4;\n\t\tj = pointer % 4;\n\n\t\tif(m[i][j] == 0){\n\t\t\tfor(k = 0; k < 4; k++){\n\t\t\t\tnext1 = i + x[k];\n\t\t\t\tnext2 = j + y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t//\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t//\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t//\t\t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t//\t\t}\n\t\t\t\t\t//\t\tprintf(\"\\n\");\n\t\t\t\t\t//\t}\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnext1 = i - x[k];\n\t\t\t\tnext2 = j - y[k];\n\t\t\t\tif(0 <= next1 && next1 <= 3 && 0 <= next2 && next2 <= 3){\n\t\t\t\t\tif(m[next1][next2] == 0){\n\t\t\t\t\t\tfor(a = 0; a < 4; a++){\n\t\t\t\t\t\t\tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t\t\tcopy[a][b] = m[a][b];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcopy[i][j] = 1;\n\t\t\t\t\t\tcopy[next1][next2] = 1;\n\t\t\t\t\t\tdepth++;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// for(a = 0; a < 4; a++){\n\t\t\t\t\t\t// \tfor(b = 0; b < 4; b++){\n\t\t\t\t\t\t// \t\tprintf(\"%d\",copy[b][a]);\n\t\t\t\t\t\t// \t}\n\t\t\t\t\t\t// \tprintf(\"\\n\");\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tput_map(copy,pointer);\n\n\t\t\t\t\t\tdepth--;\n\t\t\t\t\t\tcopy[i][j] = 0;\n\t\t\t\t\t\tcopy[next1][next2] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint map[4][4];\n\tint i,j;\n\tscanf(\"%d\",&x[0]);\n\twhile(x[0] < 4){\n\t\tscanf(\"%d\",&y[0]);\n\t\tfor(i = 1; i < 4; i++){\n\t\t\tscanf(\"%d %d\",&x[i],&y[i]); // x,yの読み取り\n\t\t}\n\n\t\tans = 0; // 解の個数を0に戻す\n\t\tdepth = 0; // 探索中の深さを0に戻す\n\n\t\tfor(i = 0; i < 4; i++){\n\t\t\tfor(j = 0; j < 4; j++){\n\t\t\t\tmap[i][j] = 0; // マップの初期化\n\t\t\t}\n\t\t}\n\t\ti = put_map(map,0);\n\t\tprintf(\"%d\\n\",ans); // 解の出力\n\t\n\t\tscanf(\"%d\",&x[0]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\nbool check(int x,int y){return x>=0&&x<4&&y>=0&&y<4;}\n \nint main() {\n  int n=8,m=4;\n  P d[n];\n  while(cin >> d[0].F >> d[0].S) {\n    for(int i=1; i<m; i++) cin >> d[i].F >> d[i].S;\n    for(int i=0; i<n; i++) {\n      if(d[i].F<0) {\n        d[i].F*=-1;\n        d[i].S*=-1;\n      }\n      if(d[i].F==0&&d[i].S<0) d[i].S*=-1;\n    }\n    int ans=0;\n    for(int t=0; t<(1<<(n*2)); t++) {\n      P a[n];\n      for(int i=0; i<n; i++) {\n        int x=t/(1<<(i*2));\n        x%=4;\n        a[i]=d[x];\n      }\n      int c[m][m];\n      memset(c,-1,sizeof(c));\n      int k=0;\n      for(int i=0; i<m; i++) {\n        for(int j=0; j<m; j++) {\n          if(c[i][j]==-1) {\n            int x=i+a[k].F,y=j+a[k].S;\n            if(!check(x,y)||c[x][y]!=-1) goto next;\n            c[i][j]=k;\n            c[x][y]=k;\n            k++;\n          }\n        }\n      }\n      ans++;\n    next:;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n// 入力\nint dx[4], dy[4];\n// used[y][x] := (y,x) にカードをおいたかどうか\nbool used[4][4];\n\nint solve(int n){\n\tif(n == 0) return 1;\n\t\n\tint res = 0;\n\t\n\t// 1 枚目のカードを置く\n\tint x1, y1;\n\tfor( y1 = 0 ; y1 < 4 ; y1++ ){\n\t\tfor( x1 = 0 ; x1 < 4 ; x1++ ){\n\t\t\tif( !used[y1][x1] ) break;\n\t\t}\n\t\tif( x1 != 4 ) break;\n\t}\n\tused[y1][x1] = true;\n\t\n\t// 2 枚目のカードを置く\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x1 + dx[i];\n\t\tint my = y1 + dy[i];\n\t\tif( mx < 0 || my < 0 || mx >= 4 || my >= 4 || used[my][mx] ) continue;\n\t\tused[my][mx] = true;\n\t\tres += solve(n-1);\n\t\tused[my][mx] = false;\n\t}\n\t\n\tused[y1][x1] = false;\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> dx[0] ){\n\t\tif( dx[0] > 4 ) break;\n\t\t\n\t\tcin >> dy[0];\n\t\tfor(int i=1 ; i < 4 ; i++ ){\n\t\t\tcin >> dx[i] >> dy[i];\n\t\t}\n\t\t\n\t\t// 初期化\n\t\tfor(int y=0 ; y < 4 ; y++ ){\n\t\t\tfor(int x=0 ; x < 4 ; x++ ){\n\t\t\t\tused[y][x] = false;\n\t\t\t}\n\t\t}\n\t\tint ans = solve(8);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 100000000\n\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <string,string> P;\ntypedef pair <int,P> PP;\n\nstatic const double EPS = 1e-8;\n\nint tx[4],ty[4];\n\nbool used[1<<16];\n\nint dfs(int stage,int c){\t\n\tif(c==8) return 1;\t\n\n\tint res = 0;\n\tint sx = -1;\n\tint sy = -1;\n\tfor(int y=0;y<4;y++){\n\t\tfor(int x=0;x<4;x++){\n\t\t\tif(~stage & (1<<(y*4+x))){\t\n\t\t\t\tsx = x;\n\t\t\t\tsy = y;\n\t\t\t\tgoto found;\n\t\t\t}\n\t\t}\n\t}\nfound:;\n\n\n\tif(sx == -1) return 0;\n\n\tfor(int i=0;i<4;i++){\n\t\tint dx = sx + tx[i];\n\t\tint dy = sy + ty[i];\n\t\tif(dx < 0 || dx >= 4 || dy < 0 || dy >= 4) continue;\n\t\tif(stage & (1<<(dy*4+dx))) continue;\n\n\t\t//bitset<16> next = stage;\n\t\tstage |= (1<<(dy*4+dx));\n\t\tstage |= (1<<(sy*4+sx));\n\t\tres += dfs(stage,c+1);\n\t\tstage &= ~(1<<(dy*4+dx));\n\t\tstage &= ~(1<<(sy*4+sx));\n\t}\n\n\treturn res;\n}\n\nint main(){\n\n\twhile(~scanf(\"%d\",tx+0)){\n\t\tif(tx[0] >= 5) break; \n\t\tscanf(\"%d %d %d %d %d %d %d\",ty+0,tx+1,ty+1,tx+2,ty+2,tx+3,ty+3);\n\n\t\tmemset(used,0,sizeof(used));\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <iterator>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n\nusing namespace std;\n\n#define dump(n) cerr<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint solve(int bit,vi& xs,vi& ys,vi& memo)\n{\n\tif(memo[bit]!=-1)\n\t\treturn memo[bit];\n\tif(bit==0xffff)\n\t\treturn memo[bit]=1;\n\t\n\trep(i,4) rep(j,4){\n\t\tint p=i*4+j;\n\t\tif(bit&1<<p)\n\t\t\tcontinue;\n\t\tint res=0;\n\t\trep(k,4){\n\t\t\tint ii=i+ys[k],jj=j+xs[k],pp=ii*4+jj;\n\t\t\tif(ii<0 || 4<=ii || jj<0 || 4<=jj || (bit&1<<pp))\n\t\t\t\tcontinue;\n\t\t\tint next=bit|1<<p|1<<pp;\n\t\t\tres+=solve(next,xs,ys,memo);\n\t\t}\n\t\treturn memo[bit]=res;\n\t}\n\tassert(false);\n}\n\nint main()\n{\n\tfor(;;){\n\t\tvi xs(4),ys(4);\n\t\trep(i,4)\n\t\t\tcin>>xs[i]>>ys[i];\n\t\tif(xs[0]>4)\n\t\t\tbreak;\n\t\t\n\t\tvi memo(1<<16,-1);\n\t\tcout<<solve(0,xs,ys,memo)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool between(int n){\n    return (0 <= n) && (n <= 3);\n}\n\nint main(){\n    while( true ){\n        int dx[4], dy[4];\n        cin >> dx[0];\n        if( dx[0] > 4 ) break;\n        cin >> dy[0] >> dx[1] >> dy[1] >> dx[2] >> dy[2] >> dx[3] >> dy[3];\n        queue< vector<int> > que;\n        for(int i = 0; i < 4; i++){\n            vector<int> a(16, 0);\n            a[0] = 1;\n            if(dx[i] >= 0 && dy[i] >= 0 && !a[ dx[i] + 4*dy[i] ]){\n                a[ dx[i] + 4*dy[i] ] = 1;\n                que.push( a );\n            }\n        }\n        que.push( vector<int>(1, 100) );\n        int count = 0, m = 2;\n        while( !que.empty() ){\n            int i = 0;\n            vector<int> b = que.front();\n            que.pop();\n            if( b[0] == 100 ){\n                if( m > 8 ) break;\n                m++;\n                que.push( vector<int>(1, 100) );\n                continue;\n            }\n            for(; i < 16; i++){\n                if( !b[i] ) break;\n            }\n            if(i == 16){\n                count++;\n                continue;\n            }\n            b[i] = m;\n            int x = i%4, y = i/4;\n            for(int j = 0; j < 4; j++){\n                int s = (x+dx[j])+4*(y+dy[j]);\n                if( between( x+dx[j] ) && between( y+dy[j] ) && !b[ s ] ){\n                    b[ s ] = m; \n                    que.push( b );\n                    b[ s ] = 0;\n                }\n            }\n        }\n        cout << count << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n \nusing namespace std;\n \ntypedef pair<int,int> ii;\nset<string> used;\nint cnt = 0;\nii raint[4];\n \nvoid dfs(int cur,int st,string perm)\n{\n  if(cur >= 8)\n    {\n      if(used.find(perm) != used.end())return;\n      used.insert(perm);\n      rep(i,16)if(perm[i] == 'x')return;\n    cnt++;\n      return;\n    }\n \n  REP(i,st,16)\n    {\n      int x = i%4;\n      int y = i/4;\n      rep(j,4)\n    {\n      int nx = x + raint[j].first;\n      int ny = y + raint[j].second;\n      if(!(0 <= nx && nx < 4 && 0 <= ny && ny < 4))continue;\n      if(perm[nx+ny*4] != 'x')continue;\n      string nperm = perm;\n      nperm[x+y*4] = nperm[nx+ny*4] = (char)('0'+cur);\n      dfs(cur+1,i+1,nperm);\n    }\n    }\n \n}\n \nint main()\n{\n  while(cin >> raint[0].first,raint[0].first <= 4)\n    {\n      used.clear();\n      cin >> raint[0].second;\n      REP(i,1,4)cin >> raint[i].first >> raint[i].second;\n      cnt = 0;\n      string perm = string(16,'x');\n \n      dfs(0,0,perm);\n \n      cout << cnt << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[1<<16];\nint x[5];\nint y[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a<=4){\n\t\tx[0]=a;\n\t\tscanf(\"%d%d%d%d%d%d%d\",y,x+1,y+1,x+2,y+2,x+3,y+3);\n\t\tfor(int i=0;i<(1<<16);i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(int i=0;i<(1<<16);i++){\n\t//\t\tif(dp[i])printf(\"%d: %d\\n\",i,dp[i]);\n\t\t\tfor(int j=0;j<16;j++){\n\t\t\t\tif(!(i&(1<<j))){\n\t\t\t\t\tint row=j/4;int col=j%4;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint tr=row+y[k];\n\t\t\t\t\t\tint tc=col+x[k];\n\t\t\t\t\t\tif(tr<0||tc<0||tr>3||tc>3||((i+(1<<j))&(1<<(tr*4+tc))))continue;\n\t\t\t\t\t\tdp[i+(1<<j)+(1<<(tr*4+tc))]+=dp[i];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[(1<<16)-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint ans;\nbool b[5][5];\nint p[4][2];\n\nvoid rec(int n){\n  if(n==8){ans++; return;}\n\n  for(int i=0;i<4;i++){\n    for(int j=0;j<4;j++){\n      if(!b[i][j]){\n\tfor(int k=0;k<4;k++){\n\t  int sx = j+p[k][0], sy = i+p[k][1];\n\t  if(sx<0 || sy<0 || 3<sx || 3<sy)continue;\n\t  if(b[sy][sx])continue;\n\n\t  b[i][j] = b[sy][sx] = true;\n\t  rec(n+1);\n\t  b[i][j] = b[sy][sx] = false;\n\t}\n\treturn;\n      }\n    }\n  }\n}\n\nint main(){\n  for(;;){\n    cin >> p[0][0];\n    if(p[0][0]>4)break;\n\n    cin >> p[0][1];\n    for(int i=1;i<4;i++)cin >> p[i][0] >> p[i][1];\n\n    for(int i=0;i<4;i++)\n      if(p[i][0]<0 && p[i][1]<0){p[i][0]*=-1; p[i][1]*=-1;}\n\n    ans = 0;\n    for(int i=0;i<4;i++)\n      for(int j=0;j<4;j++)b[i][j] = false;\n    rec(0);\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint a[4],b[4],c[4][4]={};\nint fn(int p,int q){\n  int i;\n  int ct=0;\n  if(0){\n  }else if(q==4){\n    ct=1;\n  }else if(c[q][p]){\n    ct+=fn(p==3?0:p+1,p==3?q+1:q);\n  }else{\n    c[q][p]=-1;\n    for(i=0;i<4;i++){\n      if(0<=p+a[i]&&p+a[i]<4&&0<=q+b[i]&&q+b[i]<4&&c[q+b[i]][p+a[i]]==0){\t\n\tc[q+b[i]][p+a[i]]=-1;\n\tct+=fn(p==3?0:p+1,p==3?q+1:q);\n\tc[q+b[i]][p+a[i]]=0;\n      }\n    }\n    c[q][p]=0;\n  }\n  return ct;\n}\nint main(){\n  int i;\n  for(;;){\n    for(i=0;i<4;i++)\n      cin>>a[i]>>b[i];\n    if(a[0]>4)\n      break;\n    cout<<fn(0,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cctype>\n#include <cstdio>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <complex>\n#include <cstring>\nusing namespace std;\n#define loop(i,a,b) for(int i=a; i<b; i++)\n#define rep(i,a) loop(i,0,a)\n\nint rx[4],ry[4],v[4][4];\n\ninline bool valid(int x, int y){\n    return 0<=x&&x<=3&&0<=y&&y<=3;\n}\n\nint dfs(){\n    int xx=-1,yy=-1;\n    rep(i,16){\n        int tx = i&3;\n        int ty = i>>2;\n        if(!v[ty][tx]){\n            xx = tx, yy = ty;\n            break;\n        }\n    }\n    if(xx < 0) return 1;\n    v[yy][xx]=1;\n    int ans=0;\n    rep(i,4){\n        int nx=xx+rx[i], ny=yy+ry[i];\n        if(valid(nx,ny) && !v[ny][nx]){\n            v[ny][nx] = 1;\n            ans+=dfs();\n            v[ny][nx] = 0;\n        }\n    }\n    v[yy][xx]=0;\n    return ans;\n}\n\nint main(){\n    while(cin >> rx[0] >> ry[0]){\n        loop(i,1,4) cin>>rx[i]>>ry[i];\n        memset(v,0,sizeof(v));\n        cout << dfs() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nint x[4], y[4];\nbool used[4][4];\n\nbool valid(int i, int j) {\n    if (0 <= i && i < 4 && 0 <= j && j < 4) return true;\n    return false;\n}\n\nint dfs(int i1, int j1) {\n    int i2, j2;\n    if (valid(i1, j1+1)) {\n        i2 = i1;\n        j2 = j1+1;\n    } else if (valid(i1+1, 0)) {\n        i2 = i1+1;\n        j2 = 0;\n    } else {\n        i2 = j2 = -1;\n    }\n\n    if (used[i1][j1]) {\n        if (i2 != -1) return dfs(i2, j2);\n        return 1;\n    }\n    int ret = 0;\n    for (int i=0; i<4; ++i) {\n        if (valid(i1+y[i], j1+x[i]) && ! used[i1+y[i]][j1+x[i]]) {\n            used[i1][j1] = used[i1+y[i]][j1+x[i]] = true;\n            ret += dfs(i2, j2);\n            used[i1][j1] = used[i1+y[i]][j1+x[i]] = false;\n        }\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> x[0], x[0] < 4) {\n        cin >> y[0] >> x[1] >> y[1] >> x[2] >> y[2] >> x[3] >> y[3];\n        cout << dfs(0, 0) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint board[4][4];\n\nbool inField(int x,int y){\n  return (0 <= x && x < 4 && 0 <= y && y < 4);\n}\n\nint solve(int idx,int *x,int *y){\n  if(idx == 8){ return 1; }\n  int sx,sy;\n  for(int i = 0 ; i < 4 ; i++){\n    bool found = false;\n    for(int j = 0 ; j < 4 ; j++){\n      if(board[i][j] == -1){\n        sx = j; sy = i;\n        found = true;\n        break;\n      }\n    }\n    if(found){ break; }\n  }\n  int res = 0;\n  for(int i = 0 ; i < 4 ; i++){\n    int tx = sx+x[i],ty = sy+y[i];\n    if(!inField(tx,ty) || board[ty][tx] != -1){\n      continue;\n    }\n    board[sy][sx] = board[ty][tx] = idx;\n    res += solve(idx+1,x,y);\n    board[sy][sx] = board[ty][tx] = -1;\n  }\n  return res;\n}\n\nint main(){\n  int x[4],y[4];\n  while(cin >> x[0] >> y[0], x[0] < 4){\n    for(int i = 1 ; i < 4 ; i++){\n      cin >> x[i] >> y[i];\n    }\n    memset(board,-1,sizeof(board));\n    cout << solve(0,x,y) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nmap<int, int>memo;\nvector<pair<int, int>>rels;\nint getans(bitset<16>&used) {\n\tif (memo.find(used.to_ulong()) == memo.end()) {\n\t\tif (used.count() == 16)return 1;\n\t\telse {\n\t\t\tint sum = 0;\n\t\t\tbool flag = false;\n\t\t\tfor (int y = 0; y < 4; ++y) {\n\t\t\t\tfor (int x = 0; x < 4; ++x) {\n\t\t\t\t\tif (!flag&&!used[y*4+x]) {\n\t\t\t\t\t\tflag = true;\n\t\t\t\t\t\tfor (int k = 0; k < 4; ++k) {\n\t\t\t\t\t\t\tconst int nexty = y + rels[k].second;\n\t\t\t\t\t\t\tconst int nextx = x + rels[k].first;\n\t\t\t\t\t\t\tif (nextx >= 0 && nextx <= 3 && nexty>= 0 && nexty <= 3) {\n\t\t\t\t\t\t\t\tconst int ne = nexty * 4 + nextx;\n\t\t\t\t\t\t\t\tif (!used[ne]) {\n\t\t\t\t\t\t\t\t\tused[ne] = true;\n\t\t\t\t\t\t\t\t\tused[y * 4 + x] = true;\n\t\t\t\t\t\t\t\t\tsum += getans(used);\n\t\t\t\t\t\t\t\t\tused[ne] = false;\n\t\t\t\t\t\t\t\t\tused[y * 4 + x] = false;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[used.to_ulong()] = sum;\n\t\t}\n\t}\n\treturn memo[used.to_ulong()];\n\t\n}\n\nint main() {\n\twhile (1) {\n\t\tmemo.clear();\n\t\tint a; cin >> a;\n\t\tif (a > 4)break;\n\t\tint b; cin >> b;\n\t\trels.clear();\n\t\trels.emplace_back(a, b);\n\t\tfor (int i = 0; i < 3; ++i) {\n\t\t\tint c, d; cin >> c >> d;\n\t\t\trels.push_back(make_pair(c, d));\n\t\t}\n\t\tfor (auto&rel : rels) {\n\t\t\tif (rel.second < 0||(rel.first<0&&rel.second==0)) {\n\t\t\t\trel.first = -rel.first;\n\t\t\t\trel.second = -rel.second;\n\t\t\t}\n\t\t}\n\t\tbitset<16>bs;\n\t\tint ans = getans(bs);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n\nbool check(vector< vector<int> > board){\n    for(int i=0;i<4;i++){\n\tfor(int j=0;j<4;j++){\n\t    if(board[i][j] == 0) return false;\n\t}\n    }\n    return true;\n}\n\nint saiki(vector<int> x,vector<int> y,vector< vector<int> > board,int nx,int ny){\n\n    int res = 0;\n    bool flag = true;\n    while(flag){\n\tif (check(board)) return 1;\n\tif (nx == 4){\n\t    nx = 0;\n\t    ny++;\n\t}\n\tif (board[ny][nx] == 0){\n            flag = false;\n\t    board[ny][nx]++;\n\t    for(int i=0;i<x.size();i++){\n\t\tint nexty = ny + y[i],nextx = nx + x[i];\n\t\tif(nexty > -1 && nexty < 4 && nextx > -1 && nextx < 4 && board[nexty][nextx] == 0){\n\t\t    board[nexty][nextx]++;\n\t\t    res += saiki(x,y,board,nx+1,ny);\n\t\t    board[nexty][nextx]--;\n\n\t\t}\n\t    }\n\t}else{\n\t    nx++;\n\t}\n    }\n\n    return res;\n}\n\n   \nint main(){\n\n    vector< vector<int> > board(4,vector<int>(4));\n\n\n    int temp,c1=0,c=0;\n    vector< vector<int> > x(4),y(4);\n    while(true)\n    {\n\tcin >> temp;\n\tif (temp > 3) break;\n\tx[c].push_back(temp);\n\tcin >> temp;\n\ty[c].push_back(temp);\n\n\tc1++;\n\tif(c1 == 4)\n\t{\n\t    c1 = 0;\n\t    c++;\n\t}\n    }\n\n    \n    for(int i=0;i<c;i++){\n\tint res = saiki(x[i],y[i],board,0,0);\n\tcout << res << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint dx[4], dy[4];\nbool ba[4][4];\n\nint rec(int x,int y) {\n  for (;y<4; ++x) {\n    if (x==4) {\n      y++;x=0;\n    }\n    if (!ba[x][y]) {\n      break;\n    }\n  }\n  if (y==4) return 1;\n\n  // printf(\"%d,%d\\n\", x,y);\n  // REP(i,4) {\n  //   REP(j,4)\n  //     cout << ba[j][i] << \" \";\n  //   cout<< endl;\n  // }\n  \n  ba[x][y] = 1;\n  int res = 0;\n  REP(i,4) {\n    int xx = x+dx[i];\n    int yy = y+dy[i];\n    if (xx<0||xx>=4||yy<0||yy>=4) continue;\n    if (ba[xx][yy]) continue;\n    ba[xx][yy] = 1;\n    res += rec(x+1, y);\n    ba[xx][yy] = 0;\n  }\n  ba[x][y] = 0;\n  return res;\n}\n\nint main() {\n  while(cin >> dx[0], dx[0]<=3) {\n    REP(i,4) {\n      if (i)cin >> dx[i];\n      cin >> dy[i];\n    }\n    memset(ba,0,sizeof(ba));\n    cout << rec(0,0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <list>\n#include <map>\n#include <bitset>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define UNDEFCHAN -1\n\nint dx[4],dy[4];\nint fmem[1<<16];\n\nint f(int s){\n\tif(fmem[s]!=UNDEFCHAN) return fmem[s];\n\tif(s==0) return 1;\n\n\tint bn=15;\n\twhile(bn>=0){\n\t\tif(s>>(15-bn)&1){break;}\n\t\telse{bn--; continue;}\n\t}\n\n\tint bx=bn%4, by=bn/4;\n\n\tint re=0;\n\tFOR(i,0,4){\n\t\tint ax=bx-dx[i], ay=by-dy[i];\n\t\tint an=ay*4+ax;\n\t\tif(ax<0||4<=ax||ay<0||4<=ay||(~s>>(15-an)&1)){continue;}\n\t\telse{\n\t\t\tre += f( s - (1<<(15-an)) - (1<<(15-bn)));\n\t\t}\n\t}\n\n\tfmem[s]=re;\n\treturn re;\n}\n\n\n\nint solve(){\n\tFOR(s,0,1<<16) fmem[s]=UNDEFCHAN;\n\treturn f((1<<16)-1);\n}\n\n\n\nint main(){\n\twhile(true){\n\t\tcin>>dx[0];\t\tif(dx[0]>=4) return 0;\n\t\tcin>>dy[0]>>dx[1]>>dy[1]>>dx[2]>>dy[2]>>dx[3]>>dy[3];\n\t\tcout<<solve()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\nstatic const double EPS = 1e-8;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nbool brank[4][4];\nint solve(int n,vector<PII>& p){\n  if(n==8) return 1;\n  int res = 0;\n  REP(y,4)REP(x,4){\n    bool findempty = false;\n    if(!brank[y][x]){\n      findempty = true;\n      brank[y][x] = true;\n      REP(i,4){\n        int nx = x + p[i].first;\n        int ny = y + p[i].second;\n        if(0<=nx&&nx<4&&0<=ny&&ny<4&&!brank[ny][nx]){\n          brank[ny][nx] = true;\n          res += solve(n+1,p);\n          brank[ny][nx] = false;\n        }\n      }\n      brank[y][x] = false;\n    }\n    if(findempty) goto END;\n  }\nEND:\n  return res;\n}\nint main(void){\n  int x,y;\n  while(cin>>x>>y){\n    if(x>4) break;\n    vector<PII> data;\n    data.push_back(PII(x,y));\n    REP(i,3){\n      cin>>x>>y;\n      data.push_back(PII(x,y));\n    }\n    memset(brank,0,sizeof(brank));\n    cout<<solve(0,data)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1103: Board Arrangements for Concentration Gam...\n// 2017.9.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint rel[4][2];\nchar map[4][4];\nint ans;\n\nvoid combi(int k)\n{\n\tint i, x, y, x2, y2;\n\n\tif (k == 9) { ans++; return; }\n\tfor (y = 0; y < 4; y++) for (x = 0; x < 4; x++) {\n\t\tif (map[y][x]) continue;\n\t\tmap[y][x] = k;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tx2 = x + rel[i][0], y2 = y + rel[i][1];\n\t\t\tif (x2 < 0 || x2 >= 4 || y2 < 0 || y2 >= 4 || map[y2][x2]) continue;\n\t\t\tmap[y2][x2] = k, combi(k+1), map[y2][x2] = 0;\n\t\t}\n\t\tmap[y][x] = 0;\n\t\treturn;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tint i, x, y;\n\n\twhile (scanf(\"%d\", &x) && x < 4) {\n\t\tscanf(\"%d\", &y), rel[0][0] = x, rel[0][1] = y;\n\t\tfor (i = 1; i < 4; i++) scanf(\"%d%d\", &x, &y), rel[i][0] = x, rel[i][1] = y;\n\t\tmemset(map, 0, sizeof(map)), ans = 0; map[0][0] = 1;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tx = rel[i][0], y = rel[i][1];\n\t\t\tif (x >= 0 && y >= 0) map[y][x] = 1, combi(2), map[y][x] = 0;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A1103\nBoard Arrangements for Concentration Games\n*/\n#include <stdio.h>\n\nchar  tehai[45];\nint haiti[]={1,2,3,4,11,12,13,14,21,22,23,24,31,32,33,34};\n\nint rel_pos[]={10,21,22,33};\nint cnt;\nchar dummy;\n\nvoid showhand(char mark)\n{\n  /*\n  int i,j,k;\n\n  printf(\"%c\",mark);\n  for(i=0;i<4;i++)\n    {\n      for(j=0;j<=4;j++)\n        if(tehai[k=i*10+j])\n          printf(\"%d\",k);\n      printf(\"/\");\n    }\n  printf(\"\\n\");\n  */\n  /*\n    scanf(\"%c\",&dummy);\n  */\n}\n\nvoid isagari()\n{ int i,j;\n\n  showhand('B');\n\n  for(i=0;i<45;i++)\n    if(tehai[i])\n      goto NEXT;\n  cnt++;\n  return;\n\n NEXT:\n  for(i=0;i<45;i++)\n    {  \n      if(tehai[i]==0)\n\tcontinue;\n      for(j=0;j<4;j++)\n\t{\n\t  if( tehai[i+rel_pos[j]])\n\t    {  tehai[i]--;\n\t      tehai[i+rel_pos[j]]--;\n\t      isagari();\n\t      tehai[i]++;\n\t      tehai[i+rel_pos[j]]++;\n\t    }\n\t}\n      break;\n    }\n    return;\n}\n\nint main()\n{\n  \n  int  i;\n  int ret;\n  int c;\n  int a1,a2,a3,a4,a5,a6,a7,a8;\n  char buf[256];\n\n  while(NULL != fgets(buf,200,stdin))\n    {\n      sscanf(buf,\"%d %d %d %d %d %d %d %d\",&a1,&a2,&a3,&a4,&a5,&a6,&a7,&a8);\n    \n      if(a1 > 4)break;\n\n      rel_pos[0]=a1+a2*10;\n      rel_pos[1]=a3+a4*10;\n      rel_pos[2]=a5+a6*10;\n      rel_pos[3]=a7+a8*10;\n      /*      printf(\"%d\\n\",rel_pos[0]); */\n      for(i=0;i<45;i++)\n\ttehai[i]=0;\n \n      for(i=0;i<16;i++)\n\ttehai[haiti[i]]=1;\n\n      cnt = 0;\n  /*  showhand('A'); */ \n      \n      isagari();  \n      printf(\"%d\\n\",cnt);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint b[4][2],c,d[16]={0};\nvoid f(int a){\n  if(a==16){\n    c++;\n    return ;\n  }\n  if(d[a]){\n    f(a+1);\n    return ;\n  }\n  int i;\n  for(i=0;i<4;i++){\n    int y=(a/4)+b[i][1],x=(a%4)+b[i][0];\n    if(y<0||3<y||x<0||3<x)continue;\n    if(d[y*4+x])continue;\n    d[a]=d[y*4+x]=1;\n    f(a+1);\n    d[a]=d[y*4+x]=0;\n  }\n  return ;\n}\nint main(){\n  int i;\n  while(scanf(\"%d\",&b[0][0]),b[0][0]<5){\n    scanf(\"%d\",&b[0][1]);\n    for(i=1;i<4;i++)scanf(\"%d %d\",&b[i][0],&b[i][1]);\n    f(c=0);\n    printf(\"%d\\n\",c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <inttypes.h>\n#include <string.h>\n\nint x[4], y[4];\n\nuint64_t memo[1 << 16];\n\nuint64_t search(int current) {\n\tint i, j, k;\n\tif (current == (1 << 16) - 1) return 1;\n\tif (memo[current]) return ~memo[current];\n\tfor (i = 0; i < 4; i++) {\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (!((current >> (i * 4 + j)) & 1)) {\n\t\t\t\tuint64_t ret = 0;\n\t\t\t\tint next = current | (1 << (i * 4 + j));\n\t\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\t\tint ni, nj;\n\t\t\t\t\tif (k % 2 == 0) {\n\t\t\t\t\t\tni = i + y[k / 2];\n\t\t\t\t\t\tnj = j + x[k / 2];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tni = i - y[k / 2];\n\t\t\t\t\t\tnj = j - x[k / 2];\n\t\t\t\t\t}\n\t\t\t\t\tif (0 <= ni && ni < 4 && 0 <= nj && nj < 4 && !((current >> (ni * 4 + nj)) & 1)) {\n\t\t\t\t\t\tret += search(next | (1 << (ni * 4 + nj)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn ~(memo[current] = ~ret);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0; /* will not come here */\n}\n\nint main(void) {\n\twhile (scanf(\"%d\", &x[0]) == 1 && x[0] <= 4) {\n\t\tint i;\n\t\tif (scanf(\"%d\", &y[0]) != 1) return 1;\n\t\tfor (i = 1; i < 4; i++) {\n\t\t\tif (scanf(\"%d%d\", &x[i], &y[i]) != 2) return 1;\n\t\t}\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tprintf(\"%\"PRIu64\"\\n\", search(0));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define REP(i,n,m) for(i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint dx[4],dy[4];\nint t[4][4];\n\nint solve(int rem){\n\tint i;\n\tint x,y,nx,ny;\n\tint res = 0;\n\n\tif(rem == 0) return 1;\n\n\trep(y,4) rep(x,4){\n\t\tif(t[y][x]) continue;\n\t\tt[y][x] = 1;\n\n\t\trep(i,4){\n\t\t\tnx = x + dx[i];\n\t\t\tny = y + dy[i];\n\t\t\tif(nx>=0 && nx<4 && ny>=0 && ny<4 && !t[ny][nx]){\n\t\t\t\tt[ny][nx] = 1;\n\t\t\t\tres += solve(rem-1);\n\t\t\t\tt[ny][nx] = 0;\n\t\t\t}\n\t\t}\n\n\t\tt[y][x] = 0;\n\n\t\tif(res > 0) return res;\n\t}\n\n\treturn 0;\n}\n\nint main(void){\n\tint i;\n\n\twhile(1){\n\t\tfor(i=0;i<4;i++) if(scanf(\"%d%d\",&dx[i],&dy[i]) != 2) return 0;\n\t\tmemset(t,0,sizeof(t));\n\t\tprintf(\"%d\\n\",solve(8));\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar bo[4][4];\nint xy4[8];\nint check(int x,int y){\n  return x*y>-1&&x<4&&y<4;\n}\nint count(int x,int y,int num){\n  int i,j,k,total;\n  if(num==8) return 1;\n  for(i=0,total=0;i<4;i++){\n    if(check(x+xy4[i*2],y+xy4[i*2+1])&&bo[y+xy4[i*2+1]][x+xy4[i*2]]==0){\n      bo[y][x]=bo[y+xy4[i*2+1]][x+xy4[i*2]]=num+1;\n      for(j=y;j<4;j++)\n\tfor(k=j==y?x:0;k<4;k++)\n\t  if(bo[j][k]==0) goto find;\n    find:\n      total+=count(k,j,num+1);\n      bo[y][x]=bo[y+xy4[i*2+1]][x+xy4[i*2]]=0;\n    }\n  }\n  return total;\n}\nint main(){\n  int i;\n  while(1){\n    scanf(\"%d\",xy4);\n    if(xy4[0]>4) break;\n    for(i=1;i<8;i++) scanf(\" %d\",xy4+i);\n    printf(\"%d\\n\",count(0,0,0));\n  }\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] dx = new int[4];\n\tstatic int[] dy = new int[4];\n\n\tstatic int dfs(int x, int y, boolean[][] used) {\n\t\twhile (used[x][y]) {\n\t\t\t++x;\n\t\t\tif (x == 4) {\n\t\t\t\tx = 0;\n\t\t\t\t++y;\n\t\t\t\tif (y == 4) return 1;\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tused[x][y] = true;\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tif (0 <= nx && nx < 4 && 0 <= ny && ny < 4 && !used[nx][ny]) {\n\t\t\t\tused[nx][ny] = true;\n\t\t\t\tret += dfs(x, y, used);\n\t\t\t\tused[nx][ny] = false;\n\t\t\t}\n\t\t}\n\t\tused[x][y] = false;\n\t\treturn ret;\n\t}\n\n\tstatic int solve() {\n\t\tboolean[][] used = new boolean[4][4];\n\t\treturn dfs(0, 0, used);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tdx[0] = sc.nextInt();\n\t\t\tif (dx[0] > 4) break;\n\t\t\tdy[0] = sc.nextInt();\n\t\t\tfor (int i = 1; i < 4; ++i) {\n\t\t\t\tdx[i] = sc.nextInt();\n\t\t\t\tdy[i] = sc.nextInt();\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n    \n    int HEIGHT = 4;\n    int WIDTH = 4;\n    int[][] relationXY;\n\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        //int[][] temp = { { -2, 1},{ -1, 1},{ 1, 1},{ 1, 2}};\n        \n        while(true){\n            int[][] temp = new int[4][2];\n            int x = sc.nextInt();\n            if(x > 4){\n                break;\n            }\n            int y = sc.nextInt();\n            temp[0][0] = x;\n            temp[0][1] = y;\n            for(int i = 1;i < 4;i++){\n                temp[i][0] = sc.nextInt();\n                temp[i][1] = sc.nextInt();\n            }\n            relationXY = temp;\n            boolean[][] visited = new boolean[HEIGHT][WIDTH];\n            System.out.println(dfs(visited,HEIGHT*WIDTH,0));\n        }\n    }\n    int dfs(boolean[][] visited,int remain,int next){\n        /*\n        System.out.println(\"remain \"+remain);\n        for(int i = 0;i < HEIGHT;i++){\n            for(int ii = 0;ii < WIDTH;ii++){\n                System.out.print(visited[i][ii]? 1: 0);\n            }\n            System.out.println();\n        }\n        */\n        if(remain == 0){\n            return 1;\n        }\n        if(next >= HEIGHT*WIDTH){\n            return 0;\n        }\n\n        int count = 0;\n\n        int y = next / HEIGHT;\n        int x = next % WIDTH;\n        if( visited[y][x]){\n            count+=dfs(visited,remain,next+1);\n        }\n        else{\n            for(int i = 0;i < relationXY.length;i++){\n                int rx = x + relationXY[i][0];\n                int ry = y + relationXY[i][1];\n                if(rx < 0 || WIDTH <= rx || ry < 0 || HEIGHT <= ry){\n                    continue;\n                }\n                if(!visited[ry][rx]){\n                    visited[y][x] = true;\n                    visited[ry][rx] = true;\n                    count += dfs(visited,remain-2,next+1);\n                    visited[y][x] = false;\n                    visited[ry][rx] = false;\n                }\n            }\n        }\n\n        return count;\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint cnt;\n\tint[][] p;\n\tint[][] f;\n\n\tvoid bt(int x, int y) {\n\t\tif (4 <= y) {\n\t\t\tcnt++;\n\t\t\treturn;\n\t\t}\n\t\tint nx = x + 1;\n\t\tint ny = y;\n\t\tif (4 <= nx) {\n\t\t\tnx = 0;\n\t\t\tny++;\n\t\t}\n\n\t\tif (f[y][x] == 0) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint px = x + p[i][0];\n\t\t\t\tint py = y + p[i][1];\n\t\t\t\tif (px < 0 || 4 <= px) continue;\n\t\t\t\tif (py < 0 || 4 <= py) continue;\n\t\t\t\tif (f[py][px] == 1) continue;\n\t\t\t\tf[y][x] = f[py][px] = 1;\n\t\t\t\tbt(nx, ny);\n\t\t\t\tf[y][x] = f[py][px] = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tbt(nx, ny);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\tp = new int[4][2];\n\t\tf = new int[4][4];\n\t\twhile (true) {\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\t\tp[i][j] = sc.nextInt();\n\t\t\t\t\tif (4 < p[i][j]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = 0;\n\t\t\tbt(0, 0);\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n//public class Problem1103_BoardArrangementsForConcentrationGames {\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t//\tProblem1103_BoardArrangementsForConcentrationGames test = new Problem1103_BoardArrangementsForConcentrationGames();\n\t\t\tMain test = new Main();\n\t\t\t\n\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\n\t\t\tString line;\n\t\t\twhile((line = reader.readLine()) != null) {\n\t\t\t\tString[] textArray = line.split(\" \");\n\t\t\t\tif(textArray.length > 1) {\n\t\t\t\t\tint answer = test.checkBoard(test.createRelativePosition(textArray));\n\t\t\t\t\tSystem.out.println(answer);\n\t\t\t\t} else {\n\t\t\t\t\tint number = Integer.parseInt(textArray[0]);\n\t\t\t\t\tif(number > 4) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tRelativePosition createRelativePosition(String[] textArray) {\n\t\tRelativePosition startPosition = new RelativePosition(Integer.parseInt(textArray[0]), Integer.parseInt(textArray[1]), null);\n\t\tRelativePosition position = startPosition;\n\t\tfor(int i = 1; i < 4; i++) {\n\t\t\tposition.setNext(new RelativePosition(Integer.parseInt(textArray[i*2]), Integer.parseInt(textArray[i*2 +1]), null));\n\t\t\tposition = position.getNext();\n\t\t}\n\t\t\n\t\treturn startPosition;\n\t}\n\t\n\t\n\tint checkBoard(RelativePosition start) {\n\t\tGameBoard gameBoard = new GameBoard();\n\t\tRelativePosition position = start;\n\t\tRelativePosition startPosition = start;\n\t\t\n\t\tint answerCount = 0;\n\t\tint puttedCount = 0;\n\t\tint x = 0, y = 0;  \n\t\twhile(true) {\n\t\t\twhile(puttedCount < 8) {\n\t\t\t//\tSystem.out.println(\"ÇÁpÚF\" + position.toString() + \"  \\tx:\" + x + \"\\ty:\" + y);\n\t\t\t\tif(gameBoard.isPutted(x,y)) {\t//ÝuÏÝÅAputtedCount < 8 ÌÆ«ÍAª éÌÅ¸B\n\t\t\t\t\tposition = startPosition;\n\t\t\t\t\tx = (x < 3 ? x+1 : 0);\n\t\t\t\t\ty = (x == 0 ? y+1 : y);\n\t\t\t\t} else if(gameBoard.put(x, y, position)){\t//u¯êÎu­\n\t\t\t\t\tposition = startPosition;\n\t\t\t\t\tx = (x < 3 ? x+1 : 0);\n\t\t\t\t\ty = (x == 0 ? y+1 : y);\n\t\t\t\t\tputtedCount++;\n\t\t\t//\t\tSystem.out.println(\"ÇÁ\" + puttedCount +\"ÂÚ\");\n\t\t\t\t} else {\n\t\t\t\t\tposition = position.getNext();\t//ÝuÅ«È¯êÎÊÌóâÅÝuµÄÝéB\n\t\t\t\t\t\n\t\t\t\t\tif(position == null) {\t//SÄÌÚÅÝuÅ«È¢êBPÂßéB\n\t\t\t//\t\t\tSystem.out.println(\"positionªÅãÜÅB\");\n\t\t\t\t\t\tPuttedPoint removedPoint;\n\t\t\t\t\t\t\n\t\t\t\t\t\twhile(true) {\n\t\t\t\t\t\t\tremovedPoint = gameBoard.removeLast();\n\t\t\t\t\t\t\tif(removedPoint.getRelativePosition().getNext() == null) {\n\t\t\t\t\t\t\t\tif(removedPoint.getPreviousPoint() == null) {\n\t\t\t//\t\t\t\t\t\tSystem.out.println(\"jIõI¹\");\n\t\t\t\t\t\t\t\t\treturn answerCount;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tputtedCount--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tposition = removedPoint.getRelativePosition().getNext();\n\t\t\t\t\t\t\t\tx = removedPoint.getX();\n\t\t\t\t\t\t\t\ty = removedPoint.getY();\n\t\t\t\t\t\t\t\tputtedCount--;\n\t\t\t//\t\t\t\t\tSystem.out.println(\"ßéF\" + removedPoint.getRelativePosition() + \"\\tJE^F\" + puttedCount);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//êñÜÁ½ê\n\t\t\tanswerCount++;\n\t\t//\tSystem.out.println(\"****ÜÁ½æ\\t\" + answerCount + \"ñÚ****\");\n\t\t\tfor(int i = 8; -1 < i; i--) {\n\t\t\t\tPuttedPoint removedPoint = gameBoard.removeLast();\n\t\t\t\tposition = removedPoint.getRelativePosition().getNext();\n\t\t\t\tputtedCount--;\n\t\t\t\tif(position == null) {\t//óâªÈ¢ÌÈçà¤êÂßé\n\t\t\t\t\tif(i == 0) {\t//i == 0@¦¿ASõI¹\n\t\t\t//\t\t\tSystem.out.println(\"jIõI¹\");\n\t\t\t\t\t\treturn answerCount;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//loop more \t//à¤êÂßé\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tx = removedPoint.getX();\n\t\t\t\t\ty = removedPoint.getY();\n\t\t\t\t\tbreak;\t//fJ[và¤êñ\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate class GameBoard {\n\t\tprivate boolean[][] board;\t//ÝuÏÝÈçfalse, ¢ÝuÌÆ«true\n\t\tprivate PuttedPoint lastPuttedPoint;\n\t\t\n\t\tGameBoard(int height, int width) {\n\t\t\tboard = new boolean[height][width];\n\t\t\tfor(boolean[] boardRow : board) {\n\t\t\t\tArrays.fill(boardRow,true);\n\t\t\t}\n\t\t\tlastPuttedPoint= null;\n\t\t}\n\t\tGameBoard() {\n\t\t\tthis(4,4);\n\t\t}\n\t\tboolean isPutted(int x, int y) {\n\t\t\tboolean result = board[x][y];\n\t\t\treturn !result;\t//½]Ó\n\t\t}\n\t\tboolean put(int x, int y, RelativePosition position) {\n\t\t\tif(canAdd(x,y,position)) {\n\t\t\t\tif(addPosition(x,y,position)) {\n\t\t\t\t\tlastPuttedPoint = new PuttedPoint(x, y, position, lastPuttedPoint);\n\t\t\t//\t\tSystem.out.println(\"ÇÁF\" + \"  \\tx:\" + lastPuttedPoint.getX() + \"\\ty:\" +  lastPuttedPoint.getY());\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tPuttedPoint removeLast() {\n\t\t\tPuttedPoint removedPoint = lastPuttedPoint;\n\t\t\tif(removedPoint == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif(removePosition(lastPuttedPoint.getX(), lastPuttedPoint.getY(), lastPuttedPoint.getRelativePosition())) {\n\t\t\t//\tSystem.out.println(\"íF\" + lastPuttedPoint.getRelativePosition() + \"  \\tx:\" + lastPuttedPoint.getX() + \"\\ty:\" +  lastPuttedPoint.getY());\n\t\t\t\tlastPuttedPoint = lastPuttedPoint.getPreviousPoint();\n\t\t\t\t\n\t\t\t/*\tif(lastPuttedPoint == null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}*/\n\t\t\t} else {\n\t\t\t\tthrow new IllegalStateException(\"í¸s\");\n\t\t\t}\n\t\t\treturn removedPoint;\n\t\t}\n\t\t/*\n\t\t\tøÌÊuÆAyAÌÊu¼ûª¢Ýu¾Á½êÉ true\n\t\t*/\n\t\tprivate boolean canAdd(int x, int y, RelativePosition position) {\n\t\t\tint pointX = x;\n\t\t\tint pointY = y;\n\t\t\t\n\t\t\ttry {\n\t\t\t\tif(board[pointX][pointY] && board[x + position.getX()][y + position.getY()]) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} catch(IndexOutOfBoundsException e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\t³ÝuÅ«½çtrue\tAµAaddÌêªÝu¢Ýu©Ç¤©mFµÈ¢B\n\t\t*/\n\t\tprivate boolean addPosition(int x, int y, RelativePosition position) {\n\t\t\tint pointX = x;\n\t\t\tint pointY = y;\n\t\t\tint pointPairX = pointX + position.getX();\n\t\t\tint pointPairY = pointY + position.getY();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tboard[x][y] = false;\n\t\t\t\tboard[pointPairX][pointPairY] = false;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t} catch(IndexOutOfBoundsException e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t\t³íÅ«½çtrue\tAµAremoveÌêªÝuÏÝ©Ç¤©mFµÈ¢B\n\t\t*/\n\t\tprivate boolean removePosition(int x, int y, RelativePosition position) {\n\t\t\tint pointX = x;\n\t\t\tint pointY = y;\n\t\t\tint pointPairX = pointX + position.getX();\n\t\t\tint pointPairY = pointY + position.getY();\n\t\t\t\n\t\t\ttry {\n\t\t\t\tboard[x][y] = true;\n\t\t\t\tboard[pointPairX][pointPairY] = true;\n\t\t\t\t\n\t\t\t\treturn true;\n\t\t\t} catch(IndexOutOfBoundsException e) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\tprivate class PuttedPoint {\n\t\tprivate int x;\n\t\tprivate int y;\n\t\t\n\t\tprivate PuttedPoint previousPoint;\n\t\tprivate RelativePosition puttedRelativePosition;\n\t\t\n\t\tPuttedPoint(int x, int y, RelativePosition point, PuttedPoint previous) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tputtedRelativePosition = point;\n\t\t\tpreviousPoint = previous;\n\t\t}\n\t\tint getX() {\n\t\t\treturn x;\n\t\t}\n\t\tint getY() {\n\t\t\treturn y;\n\t\t}\n\t\tRelativePosition getRelativePosition() {\n\t\t\treturn puttedRelativePosition;\n\t\t}\n\t\tPuttedPoint getPreviousPoint() {\n\t\t\treturn previousPoint;\n\t\t}\n\t}\n\tprivate class RelativePosition {\n\t\tprivate int x;\n\t\tprivate int y;\n\t\t\n\t\tprivate RelativePosition nextPosition;\n\t\t\n\t\tRelativePosition(int x, int y, RelativePosition next) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tnextPosition = next;\n\t\t}\n\t\tint getX() {\n\t\t\treturn x;\n\t\t}\n\t\tint getY() {\n\t\t\treturn y;\n\t\t}\n\t\tvoid setNext(RelativePosition position) {\n\t\t\tnextPosition = position;\n\t\t}\n\t\tRelativePosition getNext() {\n\t\t\treturn nextPosition;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + x + \",\" + y + \")\";\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\npublic class Main {\n\tint [][] setted;\n\tint [] xcard;\n\tint [] ycard;\n\tint ans;\n\n\tprivate boolean isRange(int x, int y){\n\t\tif(x < 0 || x >= 4 || y < 0 || y >= 4){\n\t\t\treturn false;\n\t\t}\n\t\telse{\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate void solve(int deep){\n\t\tif(deep == 9){\n\t\t\tans++;\n\t\t\treturn ;\n\t\t}\n\t\tfor(int i=0; i < 4; i++){\n\t\t\tfor(int j=0; j < 4; j++){\n\t\t\t\tif(setted[i][j] == 0){\n\t\t\t\t\tfor(int k=0; k < 4; k++){\n\t\t\t\t\t\tint xdis = xcard[k] + j;\n\t\t\t\t\t\tint ydis = ycard[k] + i;\n\t\t\t\t\t\tif(isRange(xdis, ydis)  && (setted[ydis][xdis] == 0)){\n\t\t\t\t\t\t\tsetted[i][j] = deep;\n\t\t\t\t\t\t\tsetted[ydis][xdis] = deep;\n\n\t\t\t\t\t\t\tsolve(deep + 1);\n\n\t\t\t\t\t\t\tsetted[i][j] = 0;\n\t\t\t\t\t\t\tsetted[ydis][xdis] = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\treturn ;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\n\tpublic void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\txcard = new int[4];\n\t\t\tycard = new int[4];\n\t\t\tsetted = new int[4][4];\n\t\t\tans = 0;\n\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n  > 4){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\txcard[0] = n;\n\t\t\tycard[0] = sc.nextInt();\n\t\t\tfor(int i=1; i < 4;i++){\n\t\t\t\txcard[i] = sc.nextInt();\n\t\t\t\tycard[i] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve(1);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Main{\n\tstatic int answer;\n\tstatic ArrayList<Integer[]> inputs;\n\n\tpublic static void main(String args[]){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tinputs = new ArrayList<Integer[]>();\n\t\t\t\tanswer = 0;\n\t\t\t\tString strs[] = str.split(\" \");\n\t\t\t\tint n = Integer.parseInt(strs[0]);\n\t\t\t\tif(n >= 5) return;\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tInteger input[] = new Integer[2];\n\t\t\t\t\tinput[0]= Integer.parseInt(strs[2 * i]);\n\t\t\t\t\tinput[1] = Integer.parseInt(strs[2 * i + 1]);\n\t\t\t\t\tinputs.add(input);\n\t\t\t\t}\n\t\t\t\t//printArray(inputs);\n\t\t\t\tboolean table[][] = new boolean[4][4];\n\t\t\t\tint position[] = {0, 0};\n\t\t\t\tsolve(table, position, \"\");\n\t\t\t\tSystem.out.println(answer);\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tpublic static void solve(boolean table[][], int position[], String rireki){\n\t\t// 埋まった場合\n\t\trireki += \"(\" + position[0] + \", \" + position[1] + \")\";\n\t\t//System.out.println(rireki);\n\t\tif(position[0] == 3 && position[1] == 3){\n\t\t\t//System.out.println(\"埋まった\");\n\t\t\tanswer++;\n\t\t\treturn;\n\t\t}\n\n\t\t// 次の座標を用意\n\t\tint next_position[] = new int[2];\n\t\tnext_position[0] = (position[0] + 1) % 4;\n\t\tnext_position[1] = (position[0] + 1) / 4 + position[1];\n\n\t\t// 既に埋まっている場合は次へ\n\t\tif(table[position[0]][position[1]]){\n\t\t\t//System.out.println(\"埋まっているので次へ\");\n\t\t\tsolve(table, next_position, rireki);\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tInteger pattern[] = inputs.get(i);\n\t\t\t//System.out.println(\"当てはめる \" + \"(\" + pattern[0] + \", \" + pattern[1] + \")\");\n\n\t\t\t// 座標を足す オーバーしていたらreturn\n\t\t\tint pair_position[] = new int[2];\n\t\t\tpair_position[0] = position[0] + pattern[0];\n\t\t\tif(pair_position[0] < 0 || pair_position[0] > 3) continue;\n\t\t\tpair_position[1] = position[1] + pattern[1];\n\t\t\tif(pair_position[1] < 0 || pair_position[1] > 3) continue;\n\n\t\t\t// 既に埋まっている場合も return\n\t\t\tif(table[pair_position[0]][pair_position[1]]) continue;\n\n\t\t\t// 置ける場合は配置して次へ\n\t\t\ttable[position[0]][position[1]] = true;\n\t\t\ttable[pair_position[0]][pair_position[1]] = true;\n\n\t\t\tsolve(table, next_position, rireki);\n\n\t\t\ttable[position[0]][position[1]] = false;\n\t\t\ttable[pair_position[0]][pair_position[1]] = false;\n\t\t}\n\t\treturn;\n\t}\n\n\tstatic void printArray(ArrayList<Integer[]> array){\n\t\tSystem.out.println(\"PrintArray \" + array.size());\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tInteger set[] = array.get(i);\n\t\t\tSystem.out.print(\"(\" + set[0] + \", \" + set[1] + \")\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n    \n    int HEIGHT = 4;\n    int WIDTH = 4;\n    int[][] relationXY;\n\n    void run(){\n        Scanner sc = new Scanner(System.in);        \n        while(true){\n            int[][] temp = new int[4][2];\n            int x = sc.nextInt();\n            if(x > 4){\n                break;\n            }\n            int y = sc.nextInt();\n            temp[0][0] = x;\n            temp[0][1] = y;\n            for(int i = 1;i < 4;i++){\n                temp[i][0] = sc.nextInt();\n                temp[i][1] = sc.nextInt();\n            }\n            relationXY = temp;\n            boolean[][] visited = new boolean[HEIGHT][WIDTH];\n            System.out.println(dfs(visited,HEIGHT*WIDTH,0));\n        }\n    }\n    int dfs(boolean[][] visited,int remain,int next){\n        if(remain == 0){\n            return 1;\n        }\n        if(next >= HEIGHT*WIDTH){\n            return 0;\n        }\n\n        int count = 0;\n\n        int y = next / HEIGHT;\n        int x = next % WIDTH;\n        if( visited[y][x]){\n            count+=dfs(visited,remain,next+1);\n        }\n        else{\n            for(int i = 0;i < relationXY.length;i++){\n                int rx = x + relationXY[i][0];\n                int ry = y + relationXY[i][1];\n                if(rx < 0 || WIDTH <= rx || ry < 0 || HEIGHT <= ry){\n                    continue;\n                }\n                if(!visited[ry][rx]){\n                    visited[y][x] = true;\n                    visited[ry][rx] = true;\n                    count += dfs(visited,remain-2,next+1);\n                    visited[y][x] = false;\n                    visited[ry][rx] = false;\n                }\n            }\n        }\n\n        return count;\n    }\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class AOJ_1103{\n    \n    int HEIGHT = 4;\n    int WIDTH = 4;\n    int[][] relationXY;\n\n    void run(){\n        Scanner sc = new Scanner(System.in);\n        //int[][] temp = { { -2, 1},{ -1, 1},{ 1, 1},{ 1, 2}};\n        \n        while(true){\n            int[][] temp = new int[4][2];\n            int x = sc.nextInt();\n            if(x > 4){\n                break;\n            }\n            int y = sc.nextInt();\n            temp[0][0] = x;\n            temp[0][1] = y;\n            for(int i = 1;i < 4;i++){\n                temp[i][0] = sc.nextInt();\n                temp[i][1] = sc.nextInt();\n            }\n            relationXY = temp;\n            boolean[][] visited = new boolean[HEIGHT][WIDTH];\n            System.out.println(dfs(visited,HEIGHT*WIDTH,0));\n        }\n    }\n    int dfs(boolean[][] visited,int remain,int next){\n        /*\n        System.out.println(\"remain \"+remain);\n        for(int i = 0;i < HEIGHT;i++){\n            for(int ii = 0;ii < WIDTH;ii++){\n                System.out.print(visited[i][ii]? 1: 0);\n            }\n            System.out.println();\n        }\n        */\n        if(remain == 0){\n            return 1;\n        }\n        if(next >= HEIGHT*WIDTH){\n            return 0;\n        }\n\n        int count = 0;\n\n        int y = next / HEIGHT;\n        int x = next % WIDTH;\n        if( visited[y][x]){\n            count+=dfs(visited,remain,next+1);\n        }\n        else{\n            for(int i = 0;i < relationXY.length;i++){\n                int rx = x + relationXY[i][0];\n                int ry = y + relationXY[i][1];\n                if(rx < 0 || WIDTH <= rx || ry < 0 || HEIGHT <= ry){\n                    continue;\n                }\n                if(!visited[ry][rx]){\n                    visited[y][x] = true;\n                    visited[ry][rx] = true;\n                    count += dfs(visited,remain-2,next+1);\n                    visited[y][x] = false;\n                    visited[ry][rx] = false;\n                }\n            }\n        }\n\n        return count;\n    }\n    public static void main(String[] args) {\n        new AOJ_1103().run();\n    }\n}\n    "
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Board Arrangements for Concentration Games\npublic class Main{\n\n\tint[][] r;\n\tint c;\n\tint[] p;\n\t\n\tvoid dfs(int k){\n\t\tif(k==8){\n\t\t\tboolean[][] a = new boolean[4][4];\n\t\t\tk = 0;\n\t\t\tboolean f = true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\t\tif(a[i][j])continue;\n\t\t\t\t\ta[i][j] = true;\n\t\t\t\t\tint ni = i+r[p[k]][0];\n\t\t\t\t\tint nj = j+r[p[k]][1];\n\t\t\t\t\tif(0<=ni&&ni<4&&0<=nj&&nj<4&&!a[ni][nj]){\n\t\t\t\t\t\ta[ni][nj] = true;\n\t\t\t\t\t\tk++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tf = false;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f)c++;\n\t\t\treturn;\n\t\t}\n\t\tfor(int i=0;i<4;i++){\n\t\t\tp[k] = i;\n\t\t\tdfs(k+1);\n\t\t}\n\t}\n\t\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint x = sc.nextInt();\n\t\t\tif(x>4)break;\n\t\t\tint y = sc.nextInt();\n\t\t\tr = new int[4][2];\n\t\t\tp = new int[8];\n\t\t\tr[0][0] = y;\n\t\t\tr[0][1] = x;\n\t\t\tfor(int i=1;i<4;i++)for(int j=1;j>=0;j--)r[i][j]=sc.nextInt();\n\t\t\tc = 0;\n\t\t\tdfs(0);\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tint[] ax = new int[4];\n\tint[] ay = new int[4];\n\tint ans;\n\tint nextNum;\n\tint[][] board = new int[4][4];\n\n\tvoid dfs(int r, int c) {\n\t\tif (r == 4) {\n\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\tif (c == 4) {\n\t\t\tdfs(r + 1, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (board[r][c] != -1) {\n\t\t\tdfs(r, c+1);\n\t\t\treturn;\n\t\t}\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint x1 = r;\n\t\t\tint y1 = c;\n\t\t\tint x2 = r + ax[i];\n\t\t\tint y2 = c + ay[i];\n\t\t\tif (0 <= x2 && x2 < 4 && 0 <= y2 && y2 < 4 && board[x2][y2] == -1) {\n\t\t\t\tboard[x1][y1] = board[x2][y2] = nextNum;\n\t\t\t\tnextNum++;\n\t\t\t\tdfs(r, c+1);\n\t\t\t\tboard[x1][y1] = board[x2][y2] = -1;\n\t\t\t\tnextNum--;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid solve() {\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint x = sc.nextInt();\n\t\t\tif (x >= 4) return;\n\t\t\tint y = sc.nextInt();\n\t\t\tif (x < 0) {\n\t\t\t\tx *= -1;\n\t\t\t\ty *= -1;\n\t\t\t}\n\t\t\tif (x == 0 && y < 0) {\n\t\t\t\ty *= -1;\n\t\t\t}\n\t\t\tax[i] = x;\n\t\t\tay[i] = y;\n\t\t}\n\t\tans = 0;\n\t\tnextNum = 0;\n\t\tfor (int i = 0; i < 4; i++) for (int j = 0; j < 4; j++) board[i][j] = -1;\n\t\tdfs(0, 0);\n\t\tout.println(ans);\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\t\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\t\n\tpublic Main(){\t\t\n\t\tnew AOJ1103();\n\t}\n\t\n\tclass AOJ1103{\n\t\tRelative relative[];\n\t\tpublic AOJ1103() {\n\t\t\twhile(true){\n\t\t\t\trelative = new Relative[4];\n\t\t\t\tboolean sw=false;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint a = in.nextInt();\n\t\t\t\t\tif(a>=4){\n\t\t\t\t\t\tsw=true;break;\n\t\t\t\t\t}\n\t\t\t\t\tint b = in.nextInt();\n\t\t\t\t\trelative[i]=new Relative(a,b);\n\t\t\t\t}\n\t\t\t\tif(sw)break;\n\t\t\t\tint[][] map = new int[4][4];for(int i=0;i<4;i++)Arrays.fill(map[i],-1);\n\t\t\t\tSystem.out.println(bfs(map,0));\n\t\t\t}\n\t\t}\n\t\tvoid print(int[][] map){\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int s=0;s<4;s++)System.out.print(map[i][s]+\" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint bfs(int[][] map,int num){\n\t\t\t\n//\t\t\tSystem.out.println(num);\n//\t\t\tprint(map);\n//\t\t\tSystem.out.println();\n\t\t\t\n\t\t\tint result = 0;\n\t\t\tif(num>=7){\n\t\t\t\tboolean sw = true;\n\t\t\t\tfor(int i=0;i<4;i++)for(int s=0;s<4;s++)if(map[s][i]==-1)sw=false;\n\t\t\t\tif(sw)return 1;\n\t\t\t}else if(num>=7)return 0;\n\t\t\tint x=0,y=0;\n\t\t\tfor(y=0;y<4;y++){//一番目に置くカードの位置\n\t\t\t\tboolean sw=true;\n\t\t\t\tfor(x=0;x<4;x++)if(map[y][x]==-1){\n\t\t\t\t\tsw=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(!sw)break;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<4;i++){//二枚目に置くカードの位置\n\t\t\t\tint nx = x+relative[i].x;\n\t\t\t\tint ny = y+relative[i].y;//もう片方の数字\n\t\t\t\tif(nx<0||nx>=4||ny<0||ny>=4)continue;\n\t\t\t\tif(map[ny][nx]!=-1)continue;\n\t\t\t\tmap[ny][nx]=map[y][x]=num;\n\t\t\t\tresult+=bfs(map,num+1);\n//\t\t\t\tif(bfs(map, num+1)==1){\n//\t\t\t\t\tSystem.out.println(num);\n//\t\t\t\t\tprint(map);\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n\t\t\t\tmap[ny][nx]=map[y][x]=-1;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tclass Relative{\n\t\t\tint x,y;\n\t\t\tpublic Relative(int x,int y) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\nclass Main{\n\tstatic int answer;\n\tstatic ArrayList<Integer[]> inputs;\n\n\tpublic static void main(String args[]){\n\t\t// 標準入力準備\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString str = new String();\n\n\t\t// 集合定義のためのハッシュ\n\t\ttry{\n\t\t\twhile((str = br.readLine()) != null){\n\t\t\t\t// メソッドと引数を分離\n\t\t\t\tinputs = new ArrayList<Integer[]>();\n\t\t\t\tanswer = 0;\n\t\t\t\tString strs[] = str.split(\" \");\n\t\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\t\tInteger input[] = new Integer[2];\n\t\t\t\t\tinput[0]= Integer.parseInt(strs[2 * i]);\n\t\t\t\t\tinput[1] = Integer.parseInt(strs[2 * i + 1]);\n\t\t\t\t\tinputs.add(input);\n\t\t\t\t}\n\t\t\t\t//printArray(inputs);\n\t\t\t\tboolean table[][] = new boolean[4][4];\n\t\t\t\tint position[] = {0, 0};\n\t\t\t\tsolve(table, position, \"\");\n\t\t\t\tSystem.out.println(answer);\n\t\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.err.println(e);\n\t\t}\n\t}\n\n\tpublic static void solve(boolean table[][], int position[], String rireki){\n\t\t// 埋まった場合\n\t\trireki += \"(\" + position[0] + \", \" + position[1] + \")\";\n\t\t//System.out.println(rireki);\n\t\tif(position[0] == 3 && position[1] == 3){\n\t\t\t//System.out.println(\"埋まった\");\n\t\t\tanswer++;\n\t\t\treturn;\n\t\t}\n\n\t\t// 次の座標を用意\n\t\tint next_position[] = new int[2];\n\t\tnext_position[0] = (position[0] + 1) % 4;\n\t\tnext_position[1] = (position[0] + 1) / 4 + position[1];\n\n\t\t// 既に埋まっている場合は次へ\n\t\tif(table[position[0]][position[1]]){\n\t\t\t//System.out.println(\"埋まっているので次へ\");\n\t\t\tsolve(table, next_position, rireki);\n\t\t\treturn;\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tInteger pattern[] = inputs.get(i);\n\t\t\t//System.out.println(\"当てはめる \" + \"(\" + pattern[0] + \", \" + pattern[1] + \")\");\n\n\t\t\t// 座標を足す オーバーしていたらreturn\n\t\t\tint pair_position[] = new int[2];\n\t\t\tpair_position[0] = position[0] + pattern[0];\n\t\t\tif(pair_position[0] < 0 || pair_position[0] > 3) continue;\n\t\t\tpair_position[1] = position[1] + pattern[1];\n\t\t\tif(pair_position[1] < 0 || pair_position[1] > 3) continue;\n\n\t\t\t// 既に埋まっている場合も return\n\t\t\tif(table[pair_position[0]][pair_position[1]]) continue;\n\n\t\t\t// 置ける場合は配置して次へ\n\t\t\ttable[position[0]][position[1]] = true;\n\t\t\ttable[pair_position[0]][pair_position[1]] = true;\n\n\t\t\tsolve(table, next_position, rireki);\n\n\t\t\ttable[position[0]][position[1]] = false;\n\t\t\ttable[pair_position[0]][pair_position[1]] = false;\n\t\t}\n\t\treturn;\n\t}\n\n\tstatic void printArray(ArrayList<Integer[]> array){\n\t\tSystem.out.println(\"PrintArray \" + array.size());\n\t\tfor(int i = 0; i < array.size(); i++){\n\t\t\tInteger set[] = array.get(i);\n\t\t\tSystem.out.print(\"(\" + set[0] + \", \" + set[1] + \")\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tstatic void printMatrix(int matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printMatrix(boolean matrix[][]){\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\tfor(int column = 0; column < matrix[row].length; column++){\n\t\t\t\tSystem.out.print(matrix[row][column] + \"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++){\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n\nclass OriginalSet{\n\tpublic ArrayList<Integer> set;\n\n\tOriginalSet(){\n\t\tset = new ArrayList<Integer>();\n\t}\n\n\tpublic void add(int inputInt){\n\t\tif(set.indexOf(inputInt) == -1){\n\t\t\tset.add(inputInt);\n\t\t}\n\t}\n\n\tpublic void addAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tadd(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void remove(int inputInt){\n\t\tset.remove((Integer)inputInt);\n\t}\n\n\tpublic void removeAll(OriginalSet inputSet){\n\t\tArrayList<Integer> inputArray = inputSet.set;\n\t\tfor(int i = 0; i < inputArray.size(); i++){\n\t\t\tremove(inputArray.get(i));\n\t\t}\n\t}\n\n\tpublic void print(){\n\t\tif(set.size() == 0){\n\t\t\tSystem.out.println(\"NULL\");\n\t\t\treturn;\n\t\t}\n\t\t// ソート\n\t\tCollections.sort(set);\n\t\tSystem.out.print(set.get(0));\n\t\tfor(int i = 1; i < set.size(); i++){\n\t\t\tSystem.out.print(\" \" + set.get(i));\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n    static int[][] field;\n    static int[] x,y;\n    static int arrange;\n    static int setX,setY;\n\n    public static void main(String[] args){\n\tScanner sc = new Scanner(System.in);\n\n\tx = new int[4];\n\ty = new int[4];\n\n\tx[0] = sc.nextInt();\n\n\twhile(x[0]<5){\n\t    field = new int[8][8];\n\t    arrange = 0;\n\t    int count = 0;\n\n\t    y[0] = sc.nextInt();\n\t    for(int i=1; i<4; i++){\n\t\tx[i] = sc.nextInt();\n\t\ty[i] = sc.nextInt();\n\t    }\n\n\t    solve(count);\n\n\t    System.out.println(arrange);\n\n\t    x[0] = sc.nextInt();\n\t}\n    }\n\n    public static void solve(int count){\n\tif(count==8){arrange++; return;}\n\n\tfor(int i=0; i<4; i++){\n\t    set();\n\t    if(setX!=-1){\n\t\tint xx = setX;\n\t\tint yy = setY;\n\t\tif(setPair(i,xx,yy)){\n\t\t    field[yy+y[i]][xx+x[i]] = 1;\n\t\t    solve(count+1);\n\t\t    field[yy+y[i]][xx+x[i]] = 0;\n\t\t}\n\t\tfield[yy][xx] = 0;\n\t    }\n\t}\n    }\n\n    public static void set(){\n\tfor(int i=0; i<4; i++){\n\t    for(int j=0 ;j<4; j++){\n\t\tif(field[i][j]==0){\n\t\t    field[i][j] = 1;\n\t\t    setX = j;\n\t\t    setY = i;\n\t\t    return;\n\t\t}\n\t    }\n\t}\n\tsetX = -1;\n    }\n\n    public static boolean setPair(int num, int xx, int yy){\n\tif(yy+y[num]<0 || xx+x[num]<0 || yy+y[num]>3 || xx+x[num]>3){return false;}\n\tif(field[yy+y[num]][xx+x[num]]==0){return true;}\n\treturn false;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\t\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args){\n\t\tnew Main();\n\t}\n\t\n\tpublic Main(){\t\t\n\t\tnew AOJ1103();\n\t}\n\t\n\tclass AOJ1103{\n\t\tRelative relative[];\n\t\tpublic AOJ1103() {\n\t\t\twhile(true){\n\t\t\t\trelative = new Relative[4];\n\t\t\t\tboolean sw=false;\n\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\tint a = in.nextInt();\n\t\t\t\t\tif(a>=4){\n\t\t\t\t\t\tsw=true;break;\n\t\t\t\t\t}\n\t\t\t\t\tint b = in.nextInt();\n\t\t\t\t\trelative[i]=new Relative(a,b);\n\t\t\t\t}\n\t\t\t\tif(sw)break;\n\t\t\t\tint[][] map = new int[4][4];for(int i=0;i<4;i++)Arrays.fill(map[i],-1);\n\t\t\t\tSystem.out.println(bfs(map,0)/40300);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tvoid test(int[][] map){\n\t\t\tint[][] map2 = map.clone();\n\t\t\tmap2[0][0]=1;\n\t\t}\n\t\tvoid print(int[][] map){\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tfor(int s=0;s<4;s++)System.out.print(map[i][s]+\" \");\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t}\n\t\t\n\t\tint bfs(int[][] map,int num){\n//\t\t\tSystem.out.println(num);\n//\t\t\tprint(map);\n\t\t\tint result=0;\n\t\t\tboolean sw=true;\n\t\t\tfor(int i=0;i<4;i++)for(int s=0;s<4;s++)if(map[i][s]==-1)sw=false;\n\t\t\tif(sw)return 1;\n\t\t\tfor(int x=0;x<4;x++)for(int y=0;y<4;y++)if(map[y][x]==-1){\n\t\t\t\tfor(int s=0;s<4;s++){\n\t\t\t\t\tint nx=x+relative[s].x;\n\t\t\t\t\tint ny=y+relative[s].y;\n\t\t\t\t\tif(nx<0||nx>=4||ny<0||ny>=4)continue;\n\t\t\t\t\tif(map[ny][nx]!=-1)continue;\n\t\t\t\t\tmap[y][x]=num;map[ny][nx]=num;\n\t\t\t\t\tresult+=bfs(map,num+1);\n\t\t\t\t\tmap[y][x]=-1;map[ny][nx]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\t\n\t\tclass Relative{\n\t\t\tint x,y;\n\t\t\tpublic Relative(int x,int y) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t}\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "Ruby",
    "code": "N = 8\nH, W = 4, 4\nX, Y = 0, 1\n\ndef dfs(board, position, depth)\n  return 1 if depth == N\n  for y in 0...H do\n    for x in 0...W do\n      break unless board[x][y]\n    end\n    break unless board[x][y]\n  end\n  count = 0\n  position.each do |p|\n    nx, ny = x+p[X], y+p[Y]\n    next if nx < 0 || W <= nx || ny < 0 || H <= ny\n    next if board[nx][ny]\n    b = board.map(&:dup)\n    b[x][y] = b[nx][ny] = true\n    count += dfs(b, position, depth+1)\n  end\n  count\nend\n\nwhile (line=gets).include?(\" \") do\n  position = Array.new\n  line.split.map(&:to_i).each_slice(2) do |x, y|\n    position.push([x, y])\n  end\n  p dfs(Array.new(W){Array.new(H)}, position, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "N = 8\nH, W = 4, 4\nX, Y = 0, 1\n\ndef dfs(board, position, depth)\n  return 1 if depth == N\n  for x in 0...W do\n    for y in 0...H do\n      break unless board[x][y]\n    end\n    break unless board[x][y]\n  end\n  count = 0\n  position.each do |p|\n    nx, ny = x+p[X], y+p[Y]\n    next if nx < 0 || W <= nx || ny < 0 || H <= ny\n    next if board[nx][ny]\n    b = board.map(&:dup)\n    b[x][y] = b[nx][ny] = true\n    count += dfs(b, position, depth+1)\n  end\n  count\nend\n\nwhile (line=gets).include?(\" \") do\n  position = Array.new\n  line.split.map(&:to_i).each_slice(2) do |x, y|\n    position.push([x, y])\n  end\n  p dfs(Array.new(W){Array.new(H)}, position, 0)\nend"
  },
  {
    "language": "Ruby",
    "code": "$ans = Array.new(4).map{Array.new(4,0)}\n\n$relational =  Array.new(4).map{Array.new(2,0)}\n#$relational =[[-2,1],[-1,1],[1,1],[1,2]]\n#$relational = [[1,0], [2,1],[2,2],[3,3]]\n\ndef calc(x,y) #,x2,y2,x3,y3,x4,y4)\n\t\n\tif (x == 4) then\n\t\t$count += 1\n\telsif ($ans[x][y] == 1) then\n\t\tif y == 3 then\n\t\t\tcalc(x+1,0)\n\t\telse\n\t\t\tcalc(x,y+1)\n\t\tend\n\telse\n\t\t$ans[x][y] = 1\n\t\tfor re in $relational\n\t\t\trx = x + re[1]\n\t\t\try = y + re[0]\n\t\t\tif (rx < 4) && (ry < 4) && (rx >= 0) && (ry >= 0) && ($ans[rx][ry] == 0) then\n\t\t\t\t$ans[rx][ry] = 1\n\t\t\t\t\n\t\t\t\tif y == 3 then\n\t\t\t\t\tcalc(x+1,0)\n\t\t\t\telse\n\t\t\t\t\tcalc(x,y+1)\n\t\t\t\tend\n\t\t\t\t$ans[rx][ry] = 0\n\t\t\telse\n\t\t\t\t#\n\t\t\tend\n\t\tend\n\t\t$ans[x][y] = 0\n\tend\n\nend\n\nloop{\n\tline = gets\n\tif line==nil then\n\t\tbreak\n\tend\n\tsp = line.split(nil)\n\t\n\tif sp.count() != 8 then\n\t\tbreak\n\telse\n\t\t$count = 0\n\t\t$relational = [[sp[0].to_i,sp[1].to_i],[sp[2].to_i,sp[3].to_i],[sp[4].to_i,sp[5].to_i],[sp[6].to_i,sp[7].to_i]]\n\t\tcalc(0,0)\n\t\tprint $count\n\t\tprint(\"\\n\")\n\tend\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nN = 4\nN2 = N * N / 2\n\n### subroutines\n\ndef count_rec(rem, x, y)\n  return 1 if rem == 0\n\n  while $used[y][x]\n    x += 1\n    if x >= N\n      y += 1\n      x = 0\n    end\n  end\n\n  count = 0\n  $used[y][x] = true\n\n  for xy in $xys\n    x0 = x + xy[0]\n    y0 = y + xy[1]\n    if x0 >= 0 && x0 < N && y0 < N && ! $used[y0][x0]\n      $used[y0][x0] = true\n      count += count_rec(rem - 1, x, y)\n      $used[y0][x0] = false\n    end\n  end\n\n  $used[y][x] = false\n  count\nend\n\n### main\n\nloop do\n  line = gets.strip\n  break if line.to_i > N\n\n  ds = line.split.map(&:to_i)\n\n  $xys = []\n  N.times do\n    xi = ds.shift\n    yi = ds.shift\n    $xys << [xi, yi]\n  end\n  #p $xys\n\n  $used = N.times.map{N.times.map{false}}\n\n  count = count_rec(N2, 0, 0)\n\n  p count\nend"
  },
  {
    "language": "Python",
    "code": "# AOJ 1103: Board Arrangements for Concentration Gam...\n# Python3 2018.7.14 bal4u\n\ndef combi(k):\n\tglobal ans\n\tif k == 9:\n\t\tans += 1\n\t\treturn\n\tfor y in range(4):\n\t\tfor x in range(4):\n\t\t\tif arr[y][x]: continue\n\t\t\tarr[y][x] = k\n\t\t\tfor i in range(4):\n\t\t\t\tx2, y2 = x + a[i<<1], y + a[(i<<1)+1]\n\t\t\t\tif x2 < 0 or x2 >= 4 or y2 < 0 or y2 >= 4 or arr[y2][x2]: continue\n\t\t\t\tarr[y2][x2] = k\n\t\t\t\tcombi(k+1)\n\t\t\t\tarr[y2][x2] = 0\n\t\t\tarr[y][x] = 0\n\t\t\treturn;\n\nwhile True:\n\ta = list(map(int, input().split()))\n\tif len(a) == 1: break\n\tarr = [[0 for i in range(4)] for j in range(4)]\n\tans = 0\n\tarr[0][0] = 1\n\tfor i in range(4):\n\t\tx, y = a[i<<1], a[(i<<1)+1]\n\t\tif x >= 0 and y >= 0:\n\t\t\tarr[y][x] = 1\n\t\t\tcombi(2)\n\t\t\tarr[y][x] = 0\n\tprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def get_index(fixed):\n    for y, f in enumerate(fixed):\n        try:\n            x = f.index(0)\n            return x, y\n        except ValueError:\n            pass\n\n\ndef recursive(i, fixed):\n    if i == 9:\n        return 1\n    result = 0\n    x, y = get_index(fixed)\n    fixed[y][x] = i\n    for dx, dy in ds:\n        x2, y2 = x + dx, y + dy\n        if not (0 <= x2 < 4 and 0 <= y2 < 4):\n            continue\n        if fixed[y2][x2]:\n            continue\n        fixed[y2][x2] = i\n        result += recursive(i + 1, fixed)\n        fixed[y2][x2] = 0\n    fixed[y][x] = 0\n    return result\n\n\nwhile True:\n    ipt = list(map(int, input().split()))\n    if len(ipt) == 1:\n        break\n    ds = list(zip(*[iter(ipt)] * 2))\n    print(recursive(1, [[0] * 4 for _ in range(4)]))"
  },
  {
    "language": "Python",
    "code": "def get_index(DATA):\n    for y, f in enumerate(DATA):\n        try:\n            x=f.index(0)\n            return x,y\n        except ValueError:\n            pass\n        \n\ndef solve(i, DATA):\n    if i==9:\n        return 1\n        \n    result=0\n    x1,y1=get_index(DATA)\n    DATA[y1][x1]=i\n    \n    for dx, dy in ds:\n        x2=x1+dx\n        y2=y1+dy\n        if not (0 <= x2 < 4 and 0 <= y2 < 4 ):\n            continue\n        if DATA[y2][x2]:\n            continue\n        DATA[y2][x2]=i\n        result+=solve(i+1,DATA)\n        DATA[y2][x2]=0\n    DATA[y1][x1]=0\n    return result\n\nwhile True:\n\n    data=list(map(int,input().split()))\n    if len(data)==1:\n        break\n    ds=list(zip(*[iter(data)]*2))\n    print(solve(1,[[0]*4 for _ in range(4)]))\n        \n"
  },
  {
    "language": "Rust",
    "code": "use std::ops::DivAssign;\nuse std::ops::MulAssign;\nuse std::ops::SubAssign;\nuse std::collections::BinaryHeap;\nuse std::str::FromStr;\nuse std::collections::HashSet;\nuse std::collections::BTreeMap;\nuse std::fmt::Display;\nuse std::ops::Neg;\nuse std::ops::Div;\nuse std::ops::Mul;\nuse std::ops::Add;\nuse std::ops::{AddAssign, Sub};\nuse std::cmp::max;\nuse std::collections::VecDeque;\nuse std::cmp::min;\nuse std::collections::{HashMap, BTreeSet};\nuse std::cmp::Ordering;\nuse std::fmt::Debug;\n\nfn read_line() -> String {\n    let mut buffer = String::new();\n    std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n    buffer.trim().to_owned()\n}\nfn read_lines<T: std::str::FromStr>(count: usize) -> Vec<T> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(buffer.trim().parse().ok().expect(\"Can't Parse\"));\n        buffer.clear();\n    }\n    vec\n}\nfn read_tabulate<R, T: Fn(&str)->R> (count: usize, transformer: T) -> Vec<R> {\n    let mut buffer = String::new();\n    let mut vec = Vec::with_capacity(count);\n    for _ in 0 .. count {\n        std::io::stdin().read_line(&mut buffer).expect(\"No Line\");\n        vec.push(transformer(buffer.trim()));\n        buffer.clear();\n    }\n    vec\n}\nfn read_value<T: std::str::FromStr>() -> T {\n    read_line().trim().parse().ok().unwrap()\n}\nfn read_values<T: std::str::FromStr>() -> Vec<T> {\n    read_line().trim().split(' ').map(|x| x.parse().ok().expect(\"Can't Parse\")).collect::<Vec<T>>()\n}\nmacro_rules! freeze {\n    ($($id:ident), *) => {\n        $(let $id = $id;)*\n    };\n}\nmacro_rules! read_map {\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n}\nmacro_rules! read {\n    (mut $ident: ident: [$ty:ty]) => {\n        let mut $ident = read_values::<$ty>();\n    };\n    ($ident: ident: [$ty:ty]) => {\n        let $ident = read_values::<$ty>();\n    };\n    (mut $ident: ident: [[$ty:ty]; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    ($ident: ident: [[$ty:ty]; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| read_values::<$ty>()).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$ty:ty; $size:expr]) => {\n        let mut $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$ty:ty; $size:expr]) => {\n        let $ident = read_lines::<$ty>($size);\n    };\n    ($ident: ident: [$block: block; $size: expr]) => {\n        let $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    (mut $ident: ident: [$block: block; $size: expr]) => {\n        let mut $ident = (0 .. $size).into_iter().map(|_| $block).collect::<Vec<_>>();\n    };\n    ($($token: tt)*) => {\n        let mut iter = read_values::<String>().into_iter();\n        read_from_iter!(iter; $($token)*);\n    };\n}\nmacro_rules! read_from_iter {\n    ($iter:expr; mut $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; $ident:ident:$ty:ty, $($rest:tt)*) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n        read_from_iter!($iter; $($rest)*);\n    };\n    ($iter:expr; mut $ident:ident:$ty:ty) => {\n        let mut $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter:expr; $ident:ident:$ty:ty) => {\n        let $ident = $iter.next().unwrap().parse::<$ty>().expect(\"Can't Parse\");\n    };\n    ($iter: expr; ) => {};\n}\nstruct KeyValue<K, V> {\n    key: K,\n    value: V\n}\nimpl <K: PartialOrd, V> PartialEq for KeyValue<K, V> {\n    fn eq(&self, other: &Self) -> bool {\n        self.key.eq(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Eq for KeyValue<K, V> {}\nimpl <K: PartialOrd, V> PartialOrd for KeyValue<K, V> {\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        self.key.partial_cmp(&other.key)\n    }\n}\nimpl <K: PartialOrd, V> Ord for KeyValue<K, V> {\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.key.partial_cmp(&other.key).ok_or(\"Can't Compare\").unwrap()\n    }\n}\n#[derive(Copy, Clone)]\nstruct Cell {\n    x: i32, y: i32\n}\nimpl Add for Cell {\n    type Output = Cell;\n    fn add(self, other: Cell) -> <Self as std::ops::Add<Cell>>::Output { \n        Cell{x: self.x + other.x, y: self.y + other.y}\n     }\n}\nfn cal_pattern(current: usize, current_state: usize, relational_pos: &Vec<Cell>,memo: &mut Vec<i32>) -> i32 {\n    if current == 16 {\n        return 1\n    }else if memo[current_state] >= 0 {\n        return memo[current_state]\n    }\n    let result = if current_state & (1 << current) != 0 {\n        cal_pattern(current + 1, current_state, relational_pos, memo)\n    }else {\n        let mut pat = 0;\n        let pos = Cell{x: (current & 3) as i32, y: (current >> 2) as i32};\n        for &diff in relational_pos {\n            let next = pos + diff;\n            if next.x < 0 || 4 <= next.x || next.y < 0 || 4 <= next.y {continue;}\n            let rank = 1 << ((next.y << 2) + next.x);\n            if current_state & rank != 0 {continue;}\n            pat += cal_pattern(current + 1, current_state | (1 << current) | rank, relational_pos, memo);\n        }\n        pat\n    };\n    memo[current_state] = result;\n    result\n}\n\nfn main() {\n    loop {\n        read!(nums: [i32]);\n        if nums[0] > 4 {break;}\n        let relational_pos = (0 .. 4).into_iter().map(|i| Cell{x: nums[i << 1], y: nums[(i << 1) + 1]}).collect::<Vec<_>>();\n        let mut memo = vec![-1; 1 << 16];\n        println!(\"{}\", cal_pattern(0, 0, &relational_pos, &mut memo));\n    }\n}\n"
  }
]