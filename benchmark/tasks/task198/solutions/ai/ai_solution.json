[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint count = 0;\nchar board[4][4];\nint used[8] = {0};\n\ntypedef struct {\n    int dx;\n    int dy;\n} Position;\n\nPosition positions[4];\n\nvoid check_positions() {\n    for (int i = 0; i < 4; i++) {\n        int found = 0;\n        for (int x = 0; x < 4 && !found; x++) {\n            for (int y = 0; y < 4 && !found; y++) {\n                if (board[x][y] != '\\0') {\n                    int nx = x + positions[i].dx;\n                    int ny = y + positions[i].dy;\n                    if (nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && board[nx][ny] == board[x][y]) {\n                        found = 1;\n                    }\n                }\n            }\n        }\n        if (!found) return;\n    }\n    count++;\n}\n\nvoid backtrack(int pos) {\n    if (pos == 16) {\n        check_positions();\n        return;\n    }\n    int x = pos / 4;\n    int y = pos % 4;\n    if (board[x][y] != '\\0') {\n        backtrack(pos + 1);\n        return;\n    }\n    for (int i = 0; i < 8; i++) {\n        if (used[i] < 2) {\n            used[i]++;\n            board[x][y] = 'A' + i;\n            backtrack(pos + 1);\n            board[x][y] = '\\0';\n            used[i]--;\n        }\n    }\n}\n\nint main() {\n    while (1) {\n        for (int i = 0; i < 4; i++) {\n            scanf(\"%d %d\", &positions[i].dx, &positions[i].dy);\n            if (positions[i].dx > 4) {\n                return 0;\n            }\n        }\n        memset(board, 0, sizeof(board));\n        memset(used, 0, sizeof(used));\n        count = 0;\n        backtrack(0);\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConcentrationArrangements {\n    static final int BOARD_SIZE = 4;\n    static final int NUM_PAIRS = 8;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int numConstraints = scanner.nextInt();\n            \n            if (numConstraints > 4) {\n                break;\n            }\n            \n            List<int[]> constraints = new ArrayList<>();\n            for (int i = 0; i < numConstraints; i++) {\n                int a = scanner.nextInt() - 1;\n                int b = scanner.nextInt() - 1;\n                constraints.add(new int[]{a, b});\n            }\n            \n            int arrangements = countArrangements(constraints);\n            System.out.println(arrangements);\n        }\n        \n        scanner.close();\n    }\n    \n    static int countArrangements(List<int[]> constraints) {\n        List<String> cards = new ArrayList<>();\n        for (char c = 'A'; c <= 'H'; c++) {\n            cards.add(String.valueOf(c));\n            cards.add(String.valueOf(c));\n        }\n        \n        List<List<String>> validArrangements = new ArrayList<>();\n        generateArrangements(cards, new ArrayList<>(), validArrangements, constraints);\n        \n        return validArrangements.size();\n    }\n    \n    static void generateArrangements(List<String> remainingCards, \n                                     List<String> currentArrangement, \n                                     List<List<String>> validArrangements,\n                                     List<int[]> constraints) {\n        if (remainingCards.isEmpty()) {\n            if (checkConstraints(currentArrangement, constraints)) {\n                validArrangements.add(new ArrayList<>(currentArrangement));\n            }\n            return;\n        }\n        \n        for (int i = 0; i < remainingCards.size(); i++) {\n            String card = remainingCards.get(i);\n            currentArrangement.add(card);\n            \n            List<String> newRemaining = new ArrayList<>(remainingCards);\n            newRemaining.remove(i);\n            \n            generateArrangements(newRemaining, currentArrangement, validArrangements, constraints);\n            \n            currentArrangement.remove(currentArrangement.size() - 1);\n        }\n    }\n    \n    static boolean checkConstraints(List<String> arrangement, List<int[]> constraints) {\n        for (int[] constraint : constraints) {\n            int pos1 = constraint[0];\n            int pos2 = constraint[1];\n            \n            String card1 = arrangement.get(pos1);\n            String card2 = arrangement.get(pos2);\n            \n            if (card1.equals(card2)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 19:02:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint countArrangements(const vector<pair<int, int>>& positions) {\n    vector<char> cards;\n    for (char c = 'A'; c <= 'H'; ++c) {\n        cards.push_back(c);\n        cards.push_back(c);\n    }\n    \n    int count = 0;\n    do {\n        bool valid = true;\n        for (const auto& pos : positions) {\n            int first = pos.first - 1;\n            int second = pos.second - 1;\n            if (cards[first] != cards[second]) {\n                valid = false;\n                break;\n            }\n        }\n        if (valid) {\n            count++;\n        }\n    } while (next_permutation(cards.begin(), cards.end()));\n    \n    return count;\n}\n\nint main() {\n    vector<pair<int, int>> positions;\n    int a, b;\n    while (cin >> a) {\n        if (a > 4) break;\n        cin >> b;\n        positions.emplace_back(a, b);\n    }\n    \n    int result = countArrangements(positions);\n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define BOARD_SIZE 16\n#define CARD_TYPES 8\n\nint count_arrangements(int* relative_positions, int num_positions) {\n    char board[BOARD_SIZE];\n    bool used_cards[CARD_TYPES];\n    int unique_arrangements = 0;\n\n    memset(used_cards, 0, sizeof(used_cards));\n\n    void backtrack(int pos) {\n        if (pos == BOARD_SIZE) {\n            unique_arrangements++;\n            return;\n        }\n\n        if (board[pos] != 0) {\n            backtrack(pos + 1);\n            return;\n        }\n\n        for (int card = 0; card < CARD_TYPES; card++) {\n            if (used_cards[card]) continue;\n\n            bool valid_placement = true;\n            for (int i = 0; i < num_positions; i++) {\n                int pos1 = pos + (relative_positions[i] / 4);\n                int pos2 = pos + (relative_positions[i] % 4);\n\n                if (pos1 < 0 || pos1 >= BOARD_SIZE || pos2 < 0 || pos2 >= BOARD_SIZE) \n                    continue;\n\n                if (board[pos1] != 0 && board[pos2] != 0 && \n                    board[pos1] == board[pos2]) {\n                    valid_placement = false;\n                    break;\n                }\n            }\n\n            if (valid_placement) {\n                board[pos] = card + 'A';\n                used_cards[card] = true;\n                backtrack(pos + 1);\n                board[pos] = 0;\n                used_cards[card] = false;\n            }\n        }\n    }\n\n    backtrack(0);\n    return unique_arrangements;\n}\n\nint main() {\n    int relative_positions[16];\n    int pos_count;\n\n    while (1) {\n        scanf(\"%d\", &pos_count);\n        if (pos_count > 4) break;\n\n        for (int i = 0; i < pos_count; i++) {\n            scanf(\"%d\", &relative_positions[i]);\n        }\n\n        printf(\"%d\\n\", count_arrangements(relative_positions, pos_count));\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:02:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nint countUniqueArrangements(vector<pair<char, char>>& constraints) {\n    vector<char> cards = {'A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', \n                          'E', 'E', 'F', 'F', 'G', 'G', 'H', 'H'};\n    set<vector<char>> uniqueArrangements;\n\n    do {\n        bool valid = true;\n        for (auto& constraint : constraints) {\n            auto first = find(cards.begin(), cards.end(), constraint.first);\n            auto second = find(cards.begin(), cards.end(), constraint.second);\n            \n            if (abs(first - second) != 1 && abs(first - second) != 4) {\n                valid = false;\n                break;\n            }\n        }\n        \n        if (valid) {\n            uniqueArrangements.insert(cards);\n        }\n    } while (next_permutation(cards.begin(), cards.end()));\n\n    return uniqueArrangements.size();\n}\n\nint main() {\n    int n;\n    while (cin >> n && n <= 4) {\n        vector<pair<char, char>> constraints;\n        for (int i = 0; i < n; i++) {\n            char a, b;\n            cin >> a >> b;\n            constraints.push_back({a, b});\n        }\n        \n        cout << countUniqueArrangements(constraints) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:03:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ConcentrationGame {\n    static int[][] positions;\n    static int count;\n    static char[] board;\n    static boolean[] used;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line;\n        while (!(line = br.readLine()).trim().isEmpty()) {\n            int n = Integer.parseInt(line.trim());\n            if (n > 4) break;\n            positions = new int[n][4];\n            for (int i = 0; i < n; i++) {\n                String[] parts = br.readLine().trim().split(\" \");\n                for (int j = 0; j < 4; j++) {\n                    positions[i][j] = Integer.parseInt(parts[j]);\n                }\n            }\n            count = 0;\n            board = new char[16];\n            used = new boolean[8];\n            backtrack(0);\n            System.out.println(count);\n        }\n    }\n\n    static void backtrack(int pos) {\n        if (pos == 16) {\n            if (checkConstraints()) {\n                count++;\n            }\n            return;\n        }\n        for (int i = 0; i < 8; i++) {\n            if (!used[i]) {\n                used[i] = true;\n                board[pos] = (char) ('A' + i);\n                int nextPos = findNextEmpty(pos + 1);\n                if (nextPos != -1) {\n                    board[nextPos] = (char) ('A' + i);\n                    backtrack(nextPos + 1);\n                    board[nextPos] = '\\0';\n                }\n                used[i] = false;\n                board[pos] = '\\0';\n            }\n        }\n    }\n\n    static int findNextEmpty(int start) {\n        for (int i = start; i < 16; i++) {\n            if (board[i] == '\\0') {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    static boolean checkConstraints() {\n        for (int[] pos : positions) {\n            int x1 = pos[0], y1 = pos[1], x2 = pos[2], y2 = pos[3];\n            int idx1 = x1 * 4 + y1;\n            int idx2 = x2 * 4 + y2;\n            if (board[idx1] != board[idx2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 19:03:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef is_valid(arrangement, constraints):\n    positions = {arrangement[i]: i for i in range(16)}\n    for a, b in constraints:\n        if not positions[a] < positions[b]:\n            return False\n    return True\n\ndef count_unique_arrangements(constraints_list):\n    cards = [chr(ord('A') + i//2) for i in range(16)]\n    all_arrangements = permutations(cards)\n    results = []\n    \n    for constraints in constraints_list:\n        count = 0\n        for arrangement in all_arrangements:\n            if is_valid(arrangement, constraints):\n                count += 1\n        results.append(count)\n    \n    return results\n\ndef parse_input(input_data):\n    constraints_list = []\n    for line in input_data.strip().split('\\n'):\n        if line.strip().isdigit() and int(line.strip()) > 4:\n            break\n        constraints = []\n        line_constraints = line.strip().split(';')\n        for con in line_constraints:\n            if con:\n                a, b = con.split('-')\n                constraints.append((a, b))\n        constraints_list.append(constraints)\n    return constraints_list\n\ninput_data = \"\"\"\nA-B;C-D\nA-C;B-D\nA-B;B-C;C-D\n5\n\"\"\"\n\nconstraints_list = parse_input(input_data)\nresults = count_unique_arrangements(constraints_list)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 02:10:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ConcentrationGame {\n    private static final int SIZE = 4;\n    private static final int PAIRS = 8;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        List<List<String>> constraints = new ArrayList<>();\n        while (true) {\n            String input = scanner.nextLine().trim();\n            if (!Character.isDigit(input.charAt(0)) || Integer.parseInt(input) > SIZE) {\n                break;\n            }\n            constraints.add(Arrays.asList(input.split(\"\\\\s+\")));\n        }\n\n        for (List<String> constraintSet : constraints) {\n            System.out.println(countArrangements(constraintSet));\n        }\n    }\n\n    private static int countArrangements(List<String> constraints) {\n        char[] board = new char[SIZE * SIZE];\n        Arrays.fill(board, '*');\n        return solve(board, constraints, 0);\n    }\n\n    private static int solve(char[] board, List<String> constraints, int filledPairs) {\n        if (filledPairs == PAIRS) {\n            if (checkConstraints(board, constraints)) {\n                return 1;\n            }\n            return 0;\n        }\n\n        char label = (char) ('A' + filledPairs);\n        int count = 0;\n        for (int i = 0; i < board.length; i++) {\n            if (board[i] == '*') {\n                for (int j = i + 1; j < board.length; j++) {\n                    if (board[j] == '*') {\n                        board[i] = board[j] = label;\n                        count += solve(board, constraints, filledPairs + 1);\n                        board[i] = board[j] = '*';\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    private static boolean checkConstraints(char[] board, List<String> constraints) {\n        for (String constraint : constraints) {\n            int firstPos = findPosition(board, constraint.charAt(0));\n            int secondPos = findPosition(board, constraint.charAt(1));\n            char rel = constraint.charAt(2);\n\n            int row1 = firstPos / SIZE;\n            int col1 = firstPos % SIZE;\n            int row2 = secondPos / SIZE;\n            int col2 = secondPos % SIZE;\n\n            switch (rel) {\n                case 'N': if (row1 <= row2) return false; break;\n                case 'S': if (row1 >= row2) return false; break;\n                case 'E': if (col1 <= col2) return false; break;\n                case 'W': if (col1 >= col2) return false; break;\n            }\n        }\n        return true;\n    }\n\n    private static int findPosition(char[] board, char card) {\n        for (int i = 0; i < board.length; i++) {\n            if (board[i] == card) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}",
    "timestamp": "2025-08-13 02:10:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define BOARD_SIZE 16\n#define NUM_PAIRS 8\n\ntypedef struct {\n    int card1;\n    int card2;\n} RelativePosition;\n\nbool is_valid(char board[], int idx, char card, RelativePosition* relPos, int relCount) {\n    board[idx] = card;\n    for (int i = 0; i < relCount; i++) {\n        if ((board[relPos[i].card1] != '\\0' && board[relPos[i].card2] != '\\0' \n            && board[relPos[i].card1] != board[relPos[i].card2])) {\n            board[idx] = '\\0';\n            return false;\n        }\n    }\n    board[idx] = '\\0';\n    return true;\n}\n\nint count_arrangements(char board[], int pos, char cards[], int count[], RelativePosition* relPos, int relCount) {\n    if (pos == BOARD_SIZE) return 1;\n\n    int total = 0;\n    for (int i = 0; i < NUM_PAIRS; i++) {\n        if (count[i] < 2) {\n            if (is_valid(board, pos, cards[i], relPos, relCount)) {\n                board[pos] = cards[i];\n                count[i]++;\n                total += count_arrangements(board, pos + 1, cards, count, relPos, relCount);\n                count[i]--;\n                board[pos] = '\\0';\n            }\n        }\n    }\n\n    return total;\n}\n\nint main() {\n    char board[BOARD_SIZE];\n    char cards[NUM_PAIRS] = \"ABCDEFGH\";\n    RelativePosition relPos[4];\n    int cardCount[NUM_PAIRS];\n    int relCount, totalArrangements;\n\n    while (1) {\n        scanf(\"%d\", &relCount);\n        if (relCount > 4) break;\n\n        for (int i = 0; i < relCount; i++) {\n            scanf(\"%d %d\", &relPos[i].card1, &relPos[i].card2);\n            relPos[i].card1--;\n            relPos[i].card2--;\n        }\n\n        memset(board, '\\0', sizeof(board));\n        memset(cardCount, 0, sizeof(cardCount));\n        \n        totalArrangements = count_arrangements(board, 0, cards, cardCount, relPos, relCount);\n        \n        printf(\"%d\\n\", totalArrangements);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 02:11:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef count_arrangements(constraints):\n    cards = ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D', \n             'E', 'E', 'F', 'F', 'G', 'G', 'H', 'H']\n    \n    valid_arrangements = set()\n    \n    for perm in permutations(range(16)):\n        board = [cards[p] for p in perm]\n        \n        valid = True\n        for pair in constraints:\n            a, b, dist = pair\n            pos_a = perm.index(a)\n            pos_b = perm.index(b)\n            \n            if abs(pos_a - pos_b) != dist:\n                valid = False\n                break\n        \n        if valid:\n            arrangement = tuple(board)\n            valid_arrangements.add(arrangement)\n    \n    return len(valid_arrangements)\n\ndef main():\n    while True:\n        n = int(input())\n        \n        if n > 4:\n            break\n        \n        constraints = []\n        for _ in range(n):\n            a, b, dist = map(int, input().split())\n            constraints.append((a, b, dist))\n        \n        print(count_arrangements(constraints))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:11:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom itertools import permutations\n\ndef count_unique_arrangements(relative_positions):\n    positions = [(0, 0), (0, 1), (0, 2), (0, 3),\n                 (1, 0), (1, 1), (1, 2), (1, 3),\n                 (2, 0), (2, 1), (2, 2), (2, 3),\n                 (3, 0), (3, 1), (3, 2), (3, 3)]\n    letters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'] * 2\n    unique = set()\n    \n    for perm in permutations(letters):\n        board = [[None for _ in range(4)] for _ in range(4)]\n        idx = 0\n        for i in range(4):\n            for j in range(4):\n                board[i][j] = perm[idx]\n                idx += 1\n        \n        valid = True\n        for (dx1, dy1, dx2, dy2) in relative_positions:\n            found = False\n            for i in range(4):\n                for j in range(4):\n                    ni1, nj1 = i + dx1, j + dy1\n                    ni2, nj2 = i + dx2, j + dy2\n                    if 0 <= ni1 < 4 and 0 <= nj1 < 4 and 0 <= ni2 < 4 and 0 <= nj2 < 4:\n                        if board[i][j] == board[ni1][nj1] and board[i][j] == board[ni2][nj2]:\n                            found = True\n                            break\n                if found:\n                    break\n            if not found:\n                valid = False\n                break\n        if valid:\n            # Flatten the board to a tuple for hashing\n            flat = tuple(tuple(row) for row in board)\n            unique.add(flat)\n    return len(unique)\n\ndef main():\n    input_lines = []\n    for line in sys.stdin:\n        line = line.strip()\n        if line.isdigit() and int(line) > 4:\n            break\n        input_lines.append(line)\n    \n    idx = 0\n    while idx < len(input_lines):\n        n = int(input_lines[idx])\n        idx += 1\n        relative_positions = []\n        for _ in range(n):\n            parts = list(map(int, input_lines[idx].split()))\n            relative_positions.append(tuple(parts))\n            idx += 1\n        print(count_unique_arrangements(relative_positions))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 02:12:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n\nusing namespace std;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    vector<vector<int>> constraints;\n    \n    while (cin >> n && n <= 4) {\n        vector<int> constraint(4);\n        for (int i = 0; i < 4; ++i) {\n            cin >> constraint[i];\n        }\n        constraints.push_back(constraint);\n    }\n    \n    do {\n        vector<int> positions(16);\n        iota(positions.begin(), positions.end(), 0);\n        int totalCount = 0;\n        \n        do {\n            bool valid = true;\n            for (const auto &constraint : constraints) {\n                int x1 = positions[constraint[0] - 1] / 4;\n                int y1 = positions[constraint[0] - 1] % 4;\n                int x2 = positions[constraint[1] - 1] / 4;\n                int y2 = positions[constraint[1] - 1] % 4;\n                int x3 = positions[constraint[2] - 1] / 4;\n                int y3 = positions[constraint[2] - 1] % 4;\n                int x4 = positions[constraint[3] - 1] / 4;\n                int y4 = positions[constraint[3] - 1] % 4;\n                \n                if ((x1 == x2 && y1 == y2) ||\n                    (x3 == x4 && y3 == y4) ||\n                    (x1 != x2 && y1 != y2) ||\n                    (x3 != x4 && y3 != y4) ||\n                    (x1 == x3 && y1 == y3) ||\n                    (x2 == x4 && y2 == y4)) {\n                    valid = false;\n                    break;\n                }\n            }\n            if (valid) ++totalCount;\n        } while (next_permutation(positions.begin(), positions.end()));\n        \n        cout << totalCount << \"\\n\";\n    } while (true);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:04:43"
  }
]