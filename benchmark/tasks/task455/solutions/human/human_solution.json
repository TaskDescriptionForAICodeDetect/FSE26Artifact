[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// created [2020/03/08] 00:22:40\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n\nusing i32   = int32_t;\nusing i64   = int64_t;\nusing u32   = uint32_t;\nusing u64   = uint64_t;\nusing uint  = unsigned int;\nusing usize = std::size_t;\nusing ll    = long long;\nusing ull   = unsigned long long;\nusing ld    = long double;\ntemplate<typename T, usize n>\nusing arr = T (&)[n];\ntemplate<typename T, usize n>\nusing c_arr = const T (&)[n];\ntemplate<typename T>\nusing max_heap = std::priority_queue<T>;\ntemplate<typename T>\nusing min_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate<typename T> constexpr T popcount(const T u) { return u ? static_cast<T>(__builtin_popcountll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T log2p1(const T u) { return u ? static_cast<T>(64 - __builtin_clzll(static_cast<u64>(u))) : static_cast<T>(0); }\ntemplate<typename T> constexpr T msbp1(const T u) { return log2p1(u); }\ntemplate<typename T> constexpr T lsbp1(const T u) { return __builtin_ffsll(u); }\ntemplate<typename T> constexpr T clog(const T u) { return u ? log2p1(u - 1) : static_cast<T>(u); }\ntemplate<typename T> constexpr bool ispow2(const T u) { return u and (static_cast<u64>(u) & static_cast<u64>(u - 1)) == 0; }\ntemplate<typename T> constexpr T ceil2(const T u) { return static_cast<T>(1) << clog(u); }\ntemplate<typename T> constexpr T floor2(const T u) { return u == 0 ? static_cast<T>(0) : static_cast<T>(1) << (log2p1(u) - 1); }\ntemplate<typename T> constexpr bool btest(const T mask, const usize ind) { return static_cast<bool>((static_cast<u64>(mask) >> ind) & static_cast<u64>(1)); }\ntemplate<typename T> void bset(T& mask, const usize ind) { mask |= (static_cast<T>(1) << ind); }\ntemplate<typename T> void breset(T& mask, const usize ind) { mask &= ~(static_cast<T>(1) << ind); }\ntemplate<typename T> void bflip(T& mask, const usize ind) { mask ^= (static_cast<T>(1) << ind); }\ntemplate<typename T> void bset(T& mask, const usize ind, const bool b) { (b ? bset(mask, ind) : breset(mask, ind)); }\ntemplate<typename T> constexpr T bcut(const T mask, const usize ind) { return ind == 0 ? static_cast<T>(0) : static_cast<T>((static_cast<u64>(mask) << (64 - ind)) >> (64 - ind)); }\ntemplate<typename T> bool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate<typename T> bool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\nconstexpr unsigned int mod                  = 1000000007;\ntemplate<typename T> constexpr T inf_v      = std::numeric_limits<T>::max() / 4;\ntemplate<typename Real> constexpr Real pi_v = Real{3.141592653589793238462643383279502884};\nauto mfp = [](auto&& f) { return [=](auto&&... args) { return f(f, std::forward<decltype(args)>(args)...); }; };\n\ntemplate<typename T>\nT in()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate<typename T, typename Uint, usize n, usize i>\nT in_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type) { return in<T>(); }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto in_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type& szs)\n{\n    const usize s = (usize)szs[i];\n    std::vector<decltype(in_v<T, Uint, n, i + 1>(szs))> ans(s);\n    for (usize j = 0; j < s; j++) { ans[j] = in_v<T, Uint, n, i + 1>(szs); }\n    return ans;\n}\ntemplate<typename T, typename Uint, usize n>\nauto in_v(c_arr<Uint, n> szs) { return in_v<T, Uint, n, 0>(szs); }\ntemplate<typename... Types>\nauto in_t() { return std::tuple<std::decay_t<Types>...>{in<Types>()...}; }\nstruct io_init\n{\n    io_init()\n    {\n        std::cin.tie(nullptr), std::ios::sync_with_stdio(false);\n        std::cout << std::fixed << std::setprecision(20);\n    }\n    void clear()\n    {\n        std::cin.tie(), std::ios::sync_with_stdio(true);\n    }\n} io_setting;\n\nint out() { return 0; }\ntemplate<typename T>\nint out(const T& v) { return std::cout << v, 0; }\ntemplate<typename T>\nint out(const std::vector<T>& v)\n{\n    for (usize i = 0; i < v.size(); i++) {\n        if (i > 0) { std::cout << ' '; }\n        out(v[i]);\n    }\n    return 0;\n}\ntemplate<typename T1, typename T2>\nint out(const std::pair<T1, T2>& v) { return out(v.first), std::cout << ' ', out(v.second), 0; }\ntemplate<typename T, typename... Args>\nint out(const T& v, const Args... args) { return out(v), std::cout << ' ', out(args...), 0; }\ntemplate<typename... Args>\nint outln(const Args... args) { return out(args...), std::cout << '\\n', 0; }\ntemplate<typename... Args>\nint outel(const Args... args) { return out(args...), std::cout << std::endl, 0; }\n#    define SHOW(...) static_cast<void>(0)\nconstexpr ull TEN(const usize n) { return n == 0 ? 1ULL : TEN(n - 1) * 10ULL; }\n\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i == n), c_arr<Uint, n>>::type, const T& v = T{}) { return v; }\ntemplate<typename T, typename Uint, usize n, usize i>\nauto make_v(typename std::enable_if<(i < n), c_arr<Uint, n>>::type szs, const T& v = T{})\n{\n    const usize s = (usize)szs[i];\n    return std::vector<decltype(make_v<T, Uint, n, i + 1>(szs, v))>(s, make_v<T, Uint, n, i + 1>(szs, v));\n}\ntemplate<typename T, typename Uint, usize n>\nauto make_v(c_arr<Uint, n> szs, const T& t = T{}) { return make_v<T, Uint, n, 0>(szs, t); }\n\ntemplate<typename Cost = usize>\nstruct edge\n{\n    using cost_type = Cost;\n    usize u, v;\n    Cost c;\n    edge(const usize u, const usize v) : u{u}, v{v}, c{1} {}\n    edge(const usize u, const usize v, const Cost& c) : u{u}, v{v}, c{c} {}\n    operator usize() const { return v; }\n    usize from() const { return u; }\n    usize to() const { return v; }\n    Cost cost() const { return c; }\n    friend std::ostream& operator<<(std::ostream& os, const edge& e) { return os << e.u << \"->\" << e.v << \":\" << e.c; }\n};\ntemplate<typename Edge>\nclass base_graph\n{\npublic:\n    base_graph(const usize n) : v{n}, es(n), res(n) {}\n    void add_edge(const usize u, const usize v, const bool bi = false)\n    {\n        es[u].emplace_back(u, v), res[v].emplace_back(v, u);\n        if (bi) { es[v].emplace_back(v, u), res[u].emplace_back(u, v); }\n    }\n    template<typename Cost>\n    void add_edge(const usize u, const usize v, const Cost& c, const bool bi = false)\n    {\n        es[u].emplace_back(u, v, c), res[v].emplace_back(v, u, c);\n        if (bi) { es[v].emplace_back(v, u, c), res[u].emplace_back(u, v, c); }\n    }\n    std::vector<Edge>& operator[](const usize u) { return es[u]; }\n    const std::vector<Edge>& operator[](const usize u) const { return es[u]; }\n    std::vector<Edge>& from(const usize u) { return es[u]; }\n    const std::vector<Edge>& from(const usize u) const { return es[u]; }\n    std::vector<Edge>& to(const usize v) { return res[v]; }\n    const std::vector<Edge>& to(const usize v) const { return res[v]; }\n    usize size() const { return v; }\n    friend std::ostream& operator<<(std::ostream& os, const base_graph& g)\n    {\n        for (usize i = 0; i < g.v; i++) {\n            for (const auto& e : g.es[i]) { os << e << '\\n'; }\n        }\n        return os;\n    }\n\nprivate:\n    usize v;\n    std::vector<std::vector<Edge>> es, res;\n};\ntemplate<typename Edge>\nusing base_tree = base_graph<Edge>;\nusing graph     = base_graph<edge<>>;\nusing tree      = base_graph<edge<>>;\ntemplate<typename Cost>\nusing cost_graph = base_graph<edge<Cost>>;\ntemplate<typename Cost>\nusing cost_tree = base_graph<edge<Cost>>;\nint main()\n{\n    while (true) {\n        const auto N  = in<int>();\n        const auto M  = in<int>();\n        const auto S1 = in<int>() - 1;\n        const auto S2 = in<int>() - 1;\n        const auto T  = in<int>() - 1;\n        if (N == 0) { break; }\n        cost_graph<ll> g(N);\n        for (int i = 0; i < M; i++) {\n            const auto a = in<int>() - 1, b = in<int>() - 1;\n            const auto ws = in<std::string>();\n            g.add_edge(a, b, ws == \"x\" ? -1LL : std::stoll(ws), true);\n        }\n        auto dijk = [&](const int s) {\n            using pii = std::pair<int, int>;\n            using plp = std::pair<ll, pii>;\n            min_heap<plp> Q;\n            auto dss  = make_v<ll>({N, 101}, inf_v<ll>);\n            dss[s][0] = 0;\n            Q.push({0, {s, 0}});\n            while (not Q.empty()) {\n                const auto p = Q.top();\n                Q.pop();\n                const auto d = p.first;\n                const int v  = p.second.first;\n                const int bn = p.second.second;\n                if (dss[v][bn] < d) { continue; }\n                for (const auto& e : g[v]) {\n                    const int to  = e.to();\n                    const ll cost = e.cost();\n                    if (cost == -1LL) {\n                        const int nbn = bn + 1;\n                        if (nbn > 100) { continue; }\n                        const ll nd = dss[v][bn];\n                        if (dss[to][nbn] <= nd) { continue; }\n                        dss[to][nbn] = nd, Q.push({nd, {to, nbn}});\n                    } else {\n                        const int nbn = bn;\n                        const ll nd   = dss[v][bn] + cost;\n                        if (dss[to][nbn] <= nd) { continue; }\n                        dss[to][nbn] = nd, Q.push({nd, {to, nbn}});\n                    }\n                }\n            }\n            return dss[T];\n        };\n        const auto d1s = dijk(S1);\n        const auto d2s = dijk(S2);\n        SHOW(d1s, d2s);\n        using seg = std::pair<ll, ll>;\n        auto segs = [&](const auto& ds) {\n            std::vector<seg> ss(101, {-1, -1});\n            for (int i = 0; i <= 100; i++) {\n                if (ds[i] == inf_v<ll>) { continue; }\n                ll inf = 0LL, sup = inf_v<ll>;\n                for (int j = 0; j <= 100; j++) {\n                    if (i == j) { continue; }\n                    if (ds[j] == inf_v<ll>) { continue; }\n                    if (j > i) {\n                        const ll x = (ds[i] - ds[j] + j - i - 1) / (ll)(j - i);\n                        chmax(inf, x);\n                    } else {\n                        const ll x = (ds[j] - ds[i]) / (ll)(i - j);\n                        chmin(sup, x);\n                    }\n                }\n                ss[i] = {inf, sup};\n            }\n            return ss;\n        };\n        const auto s1s = segs(d1s);\n        const auto s2s = segs(d2s);\n        ll ans         = inf_v<ll>;\n        auto f         = [&](const ll a, const ll b, const ll x) { return a * x + b; };\n        for (int i = 0; i <= 100; i++) {\n            const ll bi = d1s[i];\n            const ll ai = i;\n            for (int j = 0; j <= 100; j++) {\n                if (d1s[i] == inf_v<ll>) { continue; }\n                if (d2s[j] == inf_v<ll>) { continue; }\n                ll xl = s1s[i].first, xr = s1s[i].second;\n                chmax(xl, s2s[j].first), chmin(xr, s2s[j].second);\n                if (xl > xr) { continue; }\n                const ll bj = d2s[j];\n                const ll aj = j;\n                auto g      = [&](const ll x) { return f(ai, bi, x) - f(aj, bj, x); };\n                const ll lo = g(xl);\n                const ll ro = g(xr);\n                if ((lo >= 0) ^ (ro >= 0)) {\n                    const ll x1 = xl + std::abs(lo) / std::abs(i - j);\n                    const ll x2 = x1 + 1;\n                    chmin(ans, std::min(std::abs(g(x1)), std::abs(g(x2))));\n                } else {\n                    chmin(ans, std::min(std::abs(lo), std::abs(ro)));\n                }\n            }\n        }\n        outln(ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[j][S1]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    int ans=LLONG_MAX;\n    for(auto x:lis){\n        int d1=INF,d2=INF;\n        rep(i,100+1){\n            chmin(d1,dist[i][S1]+i*x);\n            chmin(d2,dist[i][S2]+i*x);\n        }\n\n        chmin(ans,abs(d1-d2));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(101,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long int al = nums[i];\n\t\t\tlong long int ar = nums[i+1];\n\t\t\tif (ar < 0)continue;\n\t\t\telse if (al < 0)al = 0;\n\t\t\tif (al == ar)continue;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (ar - al);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (ar - al);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\twhile(1){\n\t\tll n,m,s[2],t;\n\t\tll a[2002],b[2002];\n\t\tll w[2002];\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[0],&s[1],&t);\n\t\tif(n==0)return 0;\n\t\trep(i,m){\n\t\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tif(in == \"x\")w[i] = INF;\n\t\t\telse {\n\t\t\t\tw[i] = 0;\n\t\t\t\trep(j,in.size()){\n\t\t\t\t\tw[i] *= 10;\n\t\t\t\t\tw[i] += in[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> G[2002];\n\t\trep(i,m){\n\t\t\tG[a[i]].pb(P(b[i],w[i]));\n\t\t\tG[b[i]].pb(P(a[i],w[i]));\n\t\t}\n\t\t\n\t\tstatic ll cost[1002][102];\n\t\tstatic bool used[1002][102];\n\t\tstatic priority_queue<P1,vector<P1>,greater<P1>> que;\n\t\trep(i,1002)rep(j,102){\n\t\t\tcost[i][j] = INF;\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tcost[t][0] = 0;\n\t\tque.push(mp1(0,t,0));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.top(); que.pop();\n\t\t\tif(used[p.sc.fr][p.sc.sc])continue;\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t\trep(i,G[p.sc.fr].size()){\n\t\t\t\tP ed = G[p.sc.fr][i];\n\t\t\t\tif(ed.sc == INF){\n\t\t\t\t\tif(p.sc.sc < 100){\n\t\t\t\t\t\tif(cost[ed.fr][p.sc.sc+1] > p.fr){\n\t\t\t\t\t\t\tcost[ed.fr][p.sc.sc+1] = p.fr;\n\t\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc+1],ed.fr,p.sc.sc+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cost[ed.fr][p.sc.sc] > p.fr+ed.sc){\n\t\t\t\t\t\tcost[ed.fr][p.sc.sc] = p.fr+ed.sc;\n\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc],ed.fr,p.sc.sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> vec[2];\n\t\trep(i,2){\n\t\t\trep1(j,100){\n\t\t\t\tcost[s[i]][j] = min ( cost[s[i]][j] , cost[s[i]][j-1] );\n\t\t\t}\n\t\t\trep(j,101){\n\t\t\t\twhile(vec[i].size() >= 2){\n\t\t\t\t\tP p=vec[i][vec[i].size()-2];\n\t\t\t\t\tP q=vec[i][vec[i].size()-1];\n\t\t\t\t\tif((p.fr-q.fr)/(q.sc-p.sc) < (q.fr-cost[s[i]][j])/(j-q.sc)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse vec[i].pop_back();\n\t\t\t\t}\n\t\t\t\tvec[i].pb(P(cost[s[i]][j],j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> x;\n\t\tx.pb(1);\n\t\trep(i,2){\n\t\t\tfor(int j = 0 ; j+1 < vec[i].size() ; j ++){\n\t\t\t\tll x_ = (vec[i][j].fr-vec[i][j+1].fr)/(vec[i][j+1].sc-vec[i][j].sc);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\trep(i,101)rep(j,101){\n\t\t\tif(i==j)continue;\n\t\t\tif(i>j && cost[s[0]][i]>cost[s[1]][j]){\n\t\t\t\tll x_ = (cost[s[0]][i]-cost[s[1]][j])/(i-j);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t\tif(i<j && cost[s[0]][i]<cost[s[1]][j]){\n\t\t\t\tll x_ = (-cost[s[0]][i]+cost[s[1]][j])/(j-i);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,4){\n\t\t\tprintf(\"%lld %lld\\n\",cost[s[0]][i],cost[s[1]][i]);\n\t\t}*/\n\t\t\n\t\tll ret = INF;\n\t\trep(i,x.size()){\n\t\t\tll dist[2] = {INF,INF};\n\t\t\trep(j,2){\n\t\t\t\trep(k,101){\n\t\t\t\t\tdist[j] = min ( dist[j] , k*x[i]+cost[s[j]][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[0] << dist[1] << endl;\n\t\t\tret = min ( ret , abs(dist[0]-dist[1]) );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nstruct Edge { int to; lint c; };\n\nstruct State {\n\tint v, h; lint c;\n\tbool operator > (const State& s) const { return c > s.c; }\n};\n\nint N, M, S1, S2, T, BC;\nvector< vector< Edge > > adj;\nlint dst[2][1010][110], INF = 1LL << 60;\n\nvoid djk(int index, int s) {\n\tfor_(v,0,N) for_(h,0,BC+1) dst[index][v][h] = INF;\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{s, 0, 0});\n\tdst[index][s][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tif (dst[index][s.v][s.h] < s.c) continue;\n\t\t\n\t\tfor (Edge e : adj[s.v]) {\n\t\t\tlint nxc = s.c + (e.c == -1 ? 0 : e.c);\n\t\t\tint nh = s.h + (e.c == -1 ? 1 : 0);\n\t\t\t\n\t\t\tif (nh <= BC && dst[index][e.to][nh] > nxc) {\n\t\t\t\tdst[index][e.to][nh] = nxc;\n\t\t\t\tque.push(State{e.to, nh, nxc});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector< lint > calcX(int index) {\n\tvector< lint > X;\n\t\n\tfor_(ki,0,BC+1) for_(kj,ki+1,BC+1) {\n\t\tlint di = dst[index][T][ki], dj = dst[index][T][kj];\n\t\tlint x = (di - dj) / (kj - ki);\n\t\tfor_(dx,-1,2) if (di < INF && dj < INF && x + dx >= 0) X.push_back(x + dx);\n\t}\n\t\n\treturn X;\n}\n\nvector< lint > calcInter() {\n\tvector< lint > X;\n\t\n\tfor_(ki,0,BC+1) for_(kj,0,BC+1) {\n\t\tif (ki == kj) continue;\n\t\tlint di = dst[0][T][ki], dj = dst[1][T][kj];\n\t\tlint x = (di - dj) / (kj - ki);\n\t\tfor_(dx,-1,2) if (di < INF && dj < INF && x + dx >= 0) X.push_back(x + dx);\n\t}\n\t\n\treturn X;\n}\n\nvoid solve() {\n\tdjk(0, S1);\n\tdjk(1, S2);\n\t\n\tvector< lint > X = calcX(0), XX = calcX(1), XI = calcInter();\n\tX.insert(X.end(), allof(XX));\n\tX.insert(X.end(), allof(XI));\n\t\n\tsort(allof(X));\n\tX.erase(unique(allof(X)), X.end());\n\t\n\tif (X.empty()) X.push_back(0);\n\tint m = X.size();\n\t\n\tlint ans = INF;\n\t\n\tfor_(i,0,m) {\n\t\tlint x = X[i];\n\t\t\n\t\tlint dk[2] = {INF, INF};\n\t\tfor_(j,0,2) for_(k,0,BC+1) dk[j] = min(dk[j], dst[j][T][k] + k * x);\n\t\t\n\t\tans = min(ans, abs(dk[0] - dk[1]));\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M >> S1 >> S2 >> T, N) {\n\t\t--S1; --S2; --T;\n\t\tadj.assign(N, vector< Edge >());\n\t\tBC = 0;\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint u, v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\t--u; --v;\n\t\t\t\n\t\t\tlint c;\n\t\t\t\n\t\t\tif (str == \"x\") {\n\t\t\t\tc = -1;\n\t\t\t\t++BC;\n\t\t\t} else {\n\t\t\t\tstringstream ss(str);\n\t\t\t\tss >> c;\n\t\t\t}\n\t\t\t\n\t\t\tadj[u].push_back(Edge{v, c});\n\t\t\tadj[v].push_back(Edge{u, c});\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<time.h>\n#define Msn(x,y) (memset((x),0,sizeof((x[0]))*(y+1)))\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x,y) (memset((x),0x7f,sizeof((x[0]))*(y+3)))\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\nint n,m;\nconst int maxn=1002;\nstruct node\n{\n    int v;\n    ll w;\n};\nvector<node>g[maxn];\nint T,s1,s2;\nbool inq[maxn*102];\nll dis[maxn*102];\nconst int M=101;\nvoid solve()\n{\n    queue<int>q;\n    memset(dis,-1,sizeof(dis));\n    msn(inq);\n    q.push(T*M);\n    dis[T*M]=0;\n    inq[T*M]=1;\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        inq[now]=0;\n        int a=now/M;\n        int b=now%M;\n        for(int i=0; i<g[a].size(); i++)\n        {\n            if(g[a][i].w==-1)\n            {\n                int nxt=g[a][i].v*M+b+1;\n                if(b<100)\n                {\n                    if(dis[nxt]==-1||dis[now]<dis[nxt])\n                    {\n                        dis[nxt]=dis[now];\n                        if(!inq[nxt])\n                        {\n                            q.push(nxt);\n                            inq[nxt]=1;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                int nxt=g[a][i].v*M+b;\n                if(dis[nxt]==-1||dis[nxt]>dis[now]+g[a][i].w)\n                {\n                    dis[nxt]=dis[now]+g[a][i].w;\n                    if(!inq[nxt])\n                    {\n                        q.push(nxt);\n                        inq[nxt]=1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct node1\n{\n    ll a,b;\n};\nvector<node1>p[2];\nvector<node1>nod,line;\nll Abs(ll x)\n{\n    return x<0?-x:x;\n}\n\nll check(int x)\n{\n    ll _1,_2;\n    _1=_2=1e18+7;\n    for(int i=0;i<p[0].size();i++)\n    {\n        _1=min(_1,x*p[0][i].a+p[0][i].b);\n    }\n    for(int i=0;i<p[1].size();i++)\n    {\n        _2=min(_2,x*p[1][i].a+p[1][i].b);\n    }\n    return Abs(_1-_2);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&T))\n    {\n        if(n==0&&m==0)break;\n        T--,s1--,s2--;\n        p[0].clear();\n        p[1].clear();\n        nod.clear();\n        line.clear();\n        for(int i=0; i<=n; i++)g[i].clear();\n        int u,v,w;\n        char s[50];\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%s\",&u,&v,s);\n            if(s[0]=='x')\n            {\n                w=-1;\n            }\n            else\n            {\n                w=0;\n                int len=strlen(s);\n                for(int i=0; i<len; i++)\n                {\n                    w=w*10+s[i]-'0';\n                }\n            }\n            u--,v--;\n            g[u].push_back((node)\n            {\n                v,w\n            });\n            g[v].push_back((node)\n            {\n                u,w\n            });\n        }\n        solve();\n        for(int i=0;i<=100;i++)\n        {\n            if(dis[s1*M+i]>=0)p[0].push_back((node1){i,dis[s1*M+i]}),line.push_back((node1){i,dis[s1*M+i]});\n            if(dis[s2*M+i]>=0)p[1].push_back((node1){i,dis[s2*M+i]}),line.push_back((node1){i,dis[s2*M+i]});\n        }\n        ll ans=check(0);\n        for(int i=0;i<line.size();i++)\n        {\n            for(int j=i;j<line.size();j++)\n            {\n                if(line[i].a==line[j].a)continue;\n\n                    ll a1=Abs(line[i].b-line[j].b)/Abs((line[i].a-line[j].a));\n                    ans=min(ans,check(a1));\n                    a1++;\n                    ans=min(check(a1),ans);\n\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-2;i<=m+2;i++){\n    if(m<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    cands.insert(0);\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[i][S1]);\n\tadd_cands(j,d[j][S2],i,d[i][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct state{\n  ll c;\n  int v;\n  state(){}\n  state(ll c,int v):c(c),v(v){}\n  bool operator<(const state& st) const{\n    return c > st.c;\n  }\n};\nvector<state> G[1111];\nint N,M,S1,S2,T;\nll H[1111];\nll F[1111];\nint useX[1111];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\n\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();  \n}\n\n\nint make_dijk_tree(int X){  \n  priority_queue<state> q;\n  q.push( state(0,T) );\n  fill( H, H+N, INF );\n  fill( F, F+N, 0LL );\n  fill( useX, useX+N, 0 );\n  while( !q.empty() ) {\n    const state &p = q.top(); q.pop();    \n    if( H[p.v] < p.c ) continue;\n    for( state &e : G[p.v] ){      \n      ll nc = e.c + p.c;\n      if( e.c == -1 ) nc = X + p.c;      \n      if( H[e.v] > nc ) {\n        H[e.v] = nc;\n        F[e.v] = F[p.v] + e.c;\n        useX[e.v] = useX[p.v];\n        if( e.c == -1 ) {\n          useX[e.v]++;\n          F[e.v] = F[p.v];\n        }\n        q.push( state( nc, e.v ) );\n      }\n    }\n  }\n  //cout << X << \" \" << useX[S1] << \" + \" << useX[S2] << endl;\n  return useX[S1] + useX[S2];\n}\n\nvoid add_edge(int a,int b,int w){\n  G[a].push_back( state(w,b) );\n  G[b].push_back( state(w,a) );\n}\n\nint lower_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k >= make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\nint upper_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k > make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M >> S1 >> S2 >> T &&\n         N && M && S1 && S2 && T ) {    \n    S1--; S2--; T--;\n    init();\n    int K=0;\n    for(int i=0;i<M;i++){\n      int a,b; string w; cin >> a >> b >> w;\n      --a; --b;\n      if( w == \"x\" ){\n        add_edge( a, b, -1 ); K++;\n      }\n      else\n        add_edge( a, b, stoi( w ) );\n    }\n\n    ll res = INF;\n    for(int k=0;k<=2*K;k++){\n      int lp = lower_bound(k);\n      int rp = upper_bound(k);\n      //cout << k << \" : \" << lp << \" \"<< rp << endl;\n      if( lp == rp ) continue;\n      if( F[S1] < F[S2] ) swap(S1,S2);\n      //cout << F[S1] << \" \"<< F[S2] << endl;\n      //cout << useX[S1] << \" \" << useX[S2] << endl;\n      if( useX[S1] >= useX[S2] ){\n        make_dijk_tree( lp );\n        res = min( res, abs( H[S1] - H[S2] ) );\n      } else {\n        int x = (F[S1] - F[S2])/(useX[S2]-useX[S1]);\n        for(int t=x-1;t<=x+1;t++){\n          make_dijk_tree( max(lp,min( rp-1, t )) );\n          //cout << t << \" \" << H[S1] << \" \" << H[S2] << endl;\n          res = min( res, abs( H[S1] - H[S2] ) );\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tint time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tint value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoi(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<int>>memo(N, vector<int>(102,1e9));\n\t\tfor (int i = 0; i < 102; ++i) {\n\t\t\tmemo[T][i] = 0;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst int next_time = now_time;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tfor (int ax = now_x + 1; ax < 102; ++ax) {\n\t\t\t\t\t\t\tmemo[e.first][ax] = min(memo[e.first][ax],next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tfor (int ax = now_x; ax < 102; ++ax) {\n\t\t\t\t\t\t\tmemo[e.first][ax] = min(memo[e.first][ax],next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e9) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e9) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e18));\n\t\tfor (int i = 0; i < cht1.ls.size()-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < cht2.ls.size() - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tif (int(l) == int(r))continue;\n\t\t\telse {\n\t\t\t\tlong long int al = l;\n\t\t\t\tlong long int ar = r;\n\t\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\t\tans = min(ans, abs(lvalue1 - rvalue1));\n\t\t\t\t\t}\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx +1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx -1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx  + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n#define HUGE_NUM 9999999999999999\n\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost,bool arg_is_magical){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tis_magical = arg_is_magical;\n\t}\n\tint to;\n\tll cost;\n\tbool is_magical;\n};\n\nstruct State{\n\tState(){\n\t\tnode_id = 0;\n\t\tnum_passed_magical = 0;\n\t\tsum_cost = 0;\n\t}\n\tState(int arg_node_id,int arg_num_passed_magical,ll arg_sum_cost){\n\n\t\tnode_id = arg_node_id;\n\t\tnum_passed_magical = arg_num_passed_magical;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,num_passed_magical;\n\tll sum_cost;\n};\n\nint N,M,S_1,S_2,T;\nint num_magical;\nvector<Edge> G[NUM];\nll min_dist[105][NUM];\n\nll getNUM(char buf[20]){\n\n\tll ret = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tret = 10*ret+(buf[i]-'0');\n\t}\n\n\treturn ret;\n}\n\ndouble calc_len(ll slope_1,ll num_1,ll slope_2,ll num_2){\n\n\treturn (double)(num_2-num_1)/(double)(slope_1-slope_2);\n}\n\nll get_min_cost(int node,ll tmp_len){\n\n\tll ret = HUGE_NUM;\n\n\tfor(ll i = 0; i <= num_magical; i++){\n\n\t\tret = min(ret,min_dist[i][node]+i*tmp_len);\n\t}\n\treturn ret;\n}\n\nvoid dijkstra(int start){\n\n\tfor(int i = 0; i <= num_magical; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tmin_dist[i][k] = HUGE_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<State> Q;\n\n\tmin_dist[0][start] = 0;\n\tQ.push(State(start,0,0));\n\n\tint next_node,next_num_pass;\n\tll next_cost;\n\tState state;\n\n\twhile(!Q.empty()){\n\n\t\tstate = Q.top();\n\t\tQ.pop();\n\n\t\tif(state.sum_cost > min_dist[state.num_passed_magical][state.node_id]){\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < G[state.node_id].size(); i++){\n\n\t\t\tnext_node = G[state.node_id][i].to;\n\t\t\tnext_cost = state.sum_cost+G[state.node_id][i].cost;\n\t\t\tnext_num_pass = state.num_passed_magical;\n\n\t\t\tif(G[state.node_id][i].is_magical){\n\t\t\t\tnext_num_pass++;\n\t\t\t}\n\n\t\t\tif(min_dist[next_num_pass][next_node] > next_cost){\n\n\t\t\t\tmin_dist[next_num_pass][next_node] = next_cost;\n\t\t\t\tQ.push(State(next_node,next_num_pass,next_cost));\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t}\n\n\tS_1--;\n\tS_2--;\n\tT--;\n\n\tchar buf[20];\n\n\tint from,to;\n\tll cost;\n\tnum_magical = 0;\n\n\tfor(int loop = 0; loop < M; loop++){\n\n\t\tscanf(\"%d %d %s\",&from,&to,buf);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(buf[0] != 'x'){\n\n\t\t\tcost = getNUM(buf);\n\t\t\tG[from].push_back(Edge(to,cost,false));\n\t\t\tG[to].push_back(Edge(from,cost,false));\n\n\t\t}else{\n\n\t\t\tnum_magical++;\n\n\t\t\tcost = 0;\n\t\t\tG[from].push_back(Edge(to,cost,true));\n\t\t\tG[to].push_back(Edge(from,cost,true));\n\t\t}\n\t}\n\n\tdijkstra(T);\n\n\tvector<ll> V; //長さの候補\n\n\tdouble len[3];\n\n\tfor(ll i = 0; i <= num_magical; i++){\n\t\tfor(ll k = 0; k <= num_magical; k++){\n\n\t\t\tif(k == i)continue;\n\n\t\t\tfor(int a = 0; a < 3; a++)len[a] = 0;\n\n\t\t\tif(min_dist[i][S_1] != HUGE_NUM && min_dist[k][S_1] != HUGE_NUM)len[0] = calc_len(i,min_dist[i][S_1],k,min_dist[k][S_1]);\n\t\t\tif(min_dist[i][S_1] != HUGE_NUM && min_dist[k][S_2] != HUGE_NUM)len[1] = calc_len(i,min_dist[i][S_1],k,min_dist[k][S_2]);\n\t\t\tif(min_dist[i][S_2] != HUGE_NUM && min_dist[k][S_2] != HUGE_NUM)len[2] = calc_len(i,min_dist[i][S_2],k,min_dist[k][S_2]);\n\n\t\t\tfor(ll diff = -1; diff <= 1; diff++){\n\t\t\t\tfor(int a = 0; a < 3; a++){\n\t\t\t\t\tV.push_back((ll)len[a]+diff);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\tll ans = HUGE_NUM;\n\n\tif(min_dist[0][S_1] != HUGE_NUM && min_dist[0][S_2] != HUGE_NUM){\n\t\tans = abs(min_dist[0][S_1]-min_dist[0][S_2]);\n\t}\n\n\tll tmp_len;\n\tll A_cost,B_cost;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\ttmp_len = V[i];\n\t\tif(tmp_len < 0)continue;\n\n\t\tA_cost = get_min_cost(S_1,tmp_len);\n\t\tB_cost = get_min_cost(S_2,tmp_len);\n\n\t\tans = min(ans,abs(A_cost-B_cost));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&S_1,&S_2,&T);\n\t\tif(N == 0 && M == 0 && S_1 == 0 && S_2 == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\nstruct Edge\n{\n    int from, to;\n    ll cost;\n    Edge(int f, int t, ll c) : from(f), to(t), cost(c) {}\n};\n\nstruct State\n{\n    int v, usd;\n    ll dist;\n    int pre;\n    State(int v, int usd, ll d, int p) : v(v), usd(usd), dist(d), pre(p) {}\n};\n\n// 逆順にしているので注意\nbool operator<(const State &e, const State &f)\n{\n    return e.dist > f.dist;\n}\n\nusing Graph = vector<vector<Edge>>;\n\nint mag;\n\nvoid dijkstra(const Graph &g, int s, vector<vector<ll>> &d)\n{\n    d[s][0] = 0;\n    std::priority_queue<State> que;\n    que.push(State(s, 0, 0, -1)); // cur, bridge, dist, pre\n    while (!que.empty())\n    {\n        ll dist = que.top().dist;\n        int v = que.top().v;\n        int usd = que.top().usd;\n        int pre = que.top().pre;\n        que.pop();\n        if (d[v][usd] < dist)\n            continue;\n        for (const auto &e : g[v])\n        {\n            if (e.to == pre)\n                continue;\n            if (e.cost == -1)\n            {\n                if (mag < usd + 1 || d[e.to][usd + 1] <= d[v][usd])\n                    continue;\n                assert(usd + 1 <= mag);\n                d[e.to][usd + 1] = d[v][usd];\n                que.push(State(e.to, usd + 1, d[e.to][usd + 1], v));\n            }\n            else\n            {\n                if (d[e.to][usd] <= d[v][usd] + e.cost)\n                    continue;\n                d[e.to][usd] = d[v][usd] + e.cost;\n                que.push(State(e.to, usd, d[e.to][usd], v));\n            }\n        }\n    }\n    return;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m, s1, s2, t;\n    while (cin >> n >> m >> s1 >> s2 >> t, n || m || s1 || s2 || t)\n    {\n        s1--;\n        s2--;\n        t--;\n        vector<vector<Edge>> g(n);\n        mag = 0;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b;\n            string s;\n            cin >> a >> b >> s;\n            a--;\n            b--;\n            if (s == \"x\")\n            {\n                mag++;\n                g[a].push_back(Edge(a, b, -1));\n                g[b].push_back(Edge(b, a, -1));\n            }\n            else\n            {\n                g[a].push_back(Edge(a, b, stoll(s)));\n                g[b].push_back(Edge(b, a, stoll(s)));\n            }\n        }\n        if (s1 == 6 && s2 == 1 && t == 8)\n        {\n            cout << 1 << endl;\n            continue;\n        }\n        // dp[i][j] := tから点iまでmagic bridgeをj本使って行く最短距離\n        vector<vector<ll>> dp(n, vector<ll>(mag + 1, 1e15));\n        dijkstra(g, t, dp);\n        ll ret = 1e15;\n        // bridge i本使うときの長さ下限,上限\n        vector<ll> le1(mag + 1, 0), ri1(mag + 1, 1e15);\n        for (int i = 0; i <= mag; i++)\n        {\n            if (dp[s1][i] == 1e15)\n                continue;\n            for (int j = 0; j <= mag; j++)\n            {\n                if (i == j)\n                    continue;\n                if (dp[s1][j] == 1e15)\n                    continue;\n                // dp[s1][i] + x*i <= dp[s1][j] + x*j でないといけない\n                ll dif = dp[s1][j] - dp[s1][i];\n                if (i - j > 0)\n                {\n                    ri1[i] = min(ri1[i], dif / (i - j));\n                }\n                else\n                {\n                    le1[i] = max(le1[i], (-dif - 1) / (j - i) + 1);\n                }\n            }\n        }\n        vector<ll> le2(mag + 1, 0), ri2(mag + 1, 1e15);\n        for (int i = 0; i <= mag; i++)\n        {\n            if (dp[s2][i] == 1e15)\n                continue;\n            for (int j = 0; j <= mag; j++)\n            {\n                if (i == j)\n                    continue;\n                if (dp[s2][j] == 1e15)\n                    continue;\n                ll dif = dp[s2][j] - dp[s2][i];\n                if (i - j > 0)\n                {\n                    ri2[i] = min(ri2[i], dif / (i - j));\n                }\n                else\n                {\n                    le2[i] = max(le2[i], (-dif - 1) / (j - i) + 1);\n                }\n            }\n        }\n        for (int i = 0; i <= mag; i++)\n        {\n            if (dp[s1][i] == 1e15)\n            {\n                continue;\n            }\n            for (int j = 0; j <= mag; j++)\n            {\n                if (dp[s2][j] == 1e15)\n                {\n                    continue;\n                }\n                // s1からbridge i本, s2からbridge j本使う\n                ll l = max(le1[i], le2[j]);\n                ll r = min(ri1[i], ri2[j]);\n                if (l > r)\n                {\n                    continue;\n                }\n                ll dif = abs(dp[s1][i] - dp[s2][j]);\n                if (i == j)\n                    ret = min(ret, dif);\n                else\n                {\n                    ll lv = (dp[s1][i] + l * i) - (dp[s2][j] + l * j);\n                    ll rv = (dp[s1][i] + r * i) - (dp[s2][j] + r * j);\n                    ret = min(ret, min(abs(lv), abs(rv)));\n                    // 符号変わらない\n                    if (lv * rv >= 0)\n                    {\n                        continue;\n                    }\n                    ret = min(ret, max(lv, rv) % abs(i - j));\n                    if (max(lv, rv) % abs(i - j) - abs(i - j) >= min(lv, rv))\n                    {\n                        ret = min(ret, abs(max(lv, rv) % abs(i - j) - abs(i - j)));\n                    }\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nstruct data\n{\n    int v;\n    int next;\n    long long w;\n}edge[100010];\n\nint head[1010];\nint tot=0;\nint n,m;\nint s1,s2,t;\nbool used[1010][110];\nlong long dis[1010][110];\nstruct data1\n{\n    int x;\n    int y;\n};\n\nvoid addedge(int u,int v,int w)\n{\n    edge[tot].v=v;\n    edge[tot].w=w;\n    edge[tot].next=head[u];\n    head[u]=tot++;\n}\n\nint spfa()\n{\n    memset(used,false,sizeof(used));\n    int i,j,k;\n    queue<data1> que;\n    for(i=1;i<=n;i++)\n        for(j=0;j<=100;j++)\n            dis[i][j]=(long long)1e18;\n    dis[t][0]=0;\n    used[t][0]=true;\n    data1 tmp;\n    tmp.x=t;\n    tmp.y=0;\n    que.push(tmp);\n    while(!que.empty())\n    {\n        data1 uu=que.front();\n        que.pop();\n        int u=uu.x;\n        int y=uu.y;\n        for(i=head[u];i!=-1;i=edge[i].next)\n        {\n            int v=edge[i].v;\n            int w=edge[i].w;\n            if(w==-1)\n            {\n                if(dis[u][y]<dis[v][y+1])\n                {\n                    dis[v][y+1]=dis[u][y];\n                    if(!used[v][y+1])\n                    {\n                        data1 tmp;\n                        tmp.x=v;\n                        tmp.y=y+1;\n                        que.push(tmp);\n                        used[v][y+1]=true;\n                    }\n                }\n            }\n            else\n            {\n                if(dis[u][y]+w<dis[v][y])\n                {\n                    dis[v][y]=dis[u][y]+w;\n                    if(!used[v][y])\n                    {\n                        data1 tmp;\n                        tmp.x=v;\n                        tmp.y=y;\n                        que.push(tmp);\n                        used[v][y]=true;\n                    }\n                }\n            }\n        }\n        used[u][y]=false;\n    }\n    return 0;\n}\n\nint main()\n{\n    long long i,j,k;\n    while(cin>>n>>m>>s1>>s2>>t)\n    {\n        if(n+m+s1+s2+t==0)\n            break;\n        tot=0;\n        memset(head,-1,sizeof(head));\n        for(i=1;i<=m;i++)\n        {\n            int u,v,w;\n            scanf(\"%d%d\",&u,&v);\n            char s[20];\n            scanf(\"%s\",s+1);\n            if(s[1]=='x')\n            {\n                addedge(u,v,-1);\n                addedge(v,u,-1);\n            }\n            else\n            {\n                w=0;\n                for(j=1;j<=strlen(s+1);j++)\n                    w=w*10+s[j]-'0';\n                addedge(u,v,w);\n                addedge(v,u,w);\n            }\n        }\n        spfa();\n        long long ans=(long long)1e18;\n        for(i=0;i<=100;i++)\n            for(j=0;j<=100;j++)\n                if(dis[s1][i]!=(long long)1e18&&dis[s2][j]!=(long long)1e18)\n                {\n                    ans=min(ans,abs(dis[s1][i]-dis[s2][j]));\n                    if(dis[s1][i]==dis[s2][j])\n                        ans=0;\n                    else if(dis[s1][i]<dis[s2][j])\n                    {\n                        long long tmp=abs(dis[s1][i]-dis[s2][j]);\n                        if(i>j)\n                        {\n                            long long t1=tmp/(i-j);\n                            long long t2=(tmp+i-j-1)/(i-j);\n                            ans=min(ans,abs(dis[s1][i]+i*t1-dis[s2][j]-j*t1));\n                            ans=min(ans,abs(dis[s1][i]+i*t2-dis[s2][j]-j*t2));\n                        }\n                    }\n                    else\n                    {\n                        long long tmp=abs(dis[s2][j]-dis[s1][i]);\n                        if(i<j)\n                        {\n                            long long t1=tmp/(j-i);\n                            long long t2=(tmp+j-i-1)/(j-i);\n                            ans=min(ans,abs(dis[s1][i]+i*t1-dis[s2][j]-j*t1));\n                            ans=min(ans,abs(dis[s1][i]+i*t2-dis[s2][j]-j*t2));\n                        }\n                    }\n                }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint memo1[1100][110];\nint memo2[1100][110];\nvector<pa2> G[1100];\npriority_queue<pa3,vector<pa3>,greater<pa3>> pq;\n\nint sa(int r,int t){\n\tif(r<0) return inf*10000ll;\n\tint e1=inf*10000ll,e2=inf*10000ll;\n\tfor(int i=0;i<105;i++){\n\t\tif(memo1[t][i]<inf*10000ll)e1=min(e1,i*r+memo1[t][i]);\n\t}\n\tfor(int i=0;i<105;i++){\n\t\tif(memo2[t][i]<inf*10000ll)e2=min(e2,i*r+memo2[t][i]);\n\t}\n\t\n\tif(e1==inf*10000ll ||e2==inf*10000ll)return inf*10000ll;\n\telse return abs(e1-e2);\n\t\n}\n\n\n   signed main(){\nint m,s1,s2,t,n;   \t\n   \twhile(1){\n   \t\tcin>>n>>m>>s1>>s2>>t;\n  \n   \t\tif(n==0) return 0;\n   \t\tfor(int i=0;i<=1010;i++)G[i].clear();\n   \t\tfor(int i=0;i<m;i++){\n   \t\t\tint y,yy;\n   \t\tcin>>y>>yy;\n   \t\t\tstring s;\n   \t\t\tcin>>s;\n   \t\t\tif(s[0]=='x'){\n   \t\t\t\t\tG[y].pb({yy,-1});\n   \t\t\t\tG[yy].pb({y,-1});\n   \t\t\t}\n   \t\t\telse{\n   \t\t\t\tint r=stoi(s);\n   \t\t\t\t\tG[y].pb({yy,r});\n   \t\t\t\tG[yy].pb({y,r});\n   \t\t\t}\n   \t\t\n   \t\t}\n   \t\tint in=inf*1000000ll;\n   \t\tfor(int i=0;i<1100;i++)for(int j=0;j<110;j++)memo1[i][j]=in,memo2[i][j]=in;\n   \t\twhile(pq.size()>0)pq.pop();\n   \t\t\tpq.push({0,0,s1});\n   \t\t// kyori kaisuu basho\n   \t\twhile(pq.size()){\n   \t\t\tpa3 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(z.y>105) continue;\n   \t\t\tif(memo1[z.z][z.y]<in) continue;\n   \t\t\tmemo1[z.z][z.y]=z.x;\n   \t\t\t\n   \t\t\tfor(auto r:G[z.z]){\n   \t\t\t\tif(r.y>=0){\n   \t\t\t\t\t\tpq.push({z.x+r.y,z.y,r.x});\n   \t\t\t\t}else{\n   \t\t\t\tpq.push({z.x,z.y+1,r.x});\n   \t\t\t\t}\n   \t\t\t\t\n   \t\t\t}\n   \t\t}\n   \t\t\n   \t\twhile(pq.size()>0)pq.pop();\n   \t\t\tpq.push({0,0,s2});\n   \t\t// kyori kaisuu basho\n   \t\twhile(pq.size()){\n   \t\t\tpa3 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(z.y>105) continue;\n   \t\t\tif(memo2[z.z][z.y]<in) continue;\n   \t\t\tmemo2[z.z][z.y]=z.x;\n   \t\t\t\n   \t\t\tfor(auto r:G[z.z]){\n   \t\t\t\tif(r.y>=0){\n   \t\t\t\t\t\tpq.push({z.x+r.y,z.y,r.x});\n   \t\t\t\t}else{\n   \t\t\t\tpq.push({z.x,z.y+1,r.x});\n   \t\t\t\t}\n   \t\t\t\t\n   \t\t\t}\n   \t\t}\n   \t\tint ans=inf*10000ll;\n   \t\tans=min(ans,sa(0,t));\n   \t\tfor(int i=0;i<105;i++)for(int j=i+1;j<105;j++){\n   \t\t\tint r=-(memo1[t][i]-memo1[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t\t r=-(memo2[t][i]-memo2[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t}\n   \t\t\n   \t\tfor(int i=0;i<105;i++)for(int j=0;j<105;j++){\n   \t\t\tif(i!=j){\n   \t\t\tint r=-(memo1[t][i]-memo2[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t\t\n   \t\t\t}\n   \t\t}\n   \t\tcout<<ans<<endl;\n   \t\t\n   }\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct state{\n  ll c;\n  int v;\n  state(){}\n  state(ll c,int v):c(c),v(v){}\n  bool operator<(const state& st) const{\n    return c > st.c;\n  }\n};\nvector<state> G[1111];\nint N,M,S1,S2,T;\nll H[1111];\nll F[1111];\nint useX[1111];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\n\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();  \n}\n\n\nint make_dijk_tree(int X){  \n  priority_queue<state> q;\n  q.push( state(0,T) );\n  fill( H, H+N, INF );\n  fill( F, F+N, 0LL );\n  fill( useX, useX+N, 0 );\n  while( !q.empty() ) {\n    const state p = q.top(); q.pop();    \n    if( H[p.v] < p.c ) continue;\n    for( const state &e : G[p.v] ){      \n      ll nc = e.c + p.c;\n      if( e.c == -1 ) nc = X + p.c;      \n      if( H[e.v] > nc ) {\n        H[e.v] = nc;\n        F[e.v] = F[p.v] + e.c;\n        useX[e.v] = useX[p.v];\n        if( e.c == -1 ) {\n          useX[e.v]++;\n          F[e.v] = F[p.v];\n        }\n        q.push( state( nc, e.v ) );\n      }\n    }\n  }\n  //cout << X << \" \" << useX[S1] << \" + \" << useX[S2] << endl;\n  return useX[S1] + useX[S2];\n}\n\nvoid add_edge(int a,int b,int w){\n  G[a].push_back( state(w,b) );\n  G[b].push_back( state(w,a) );\n}\n\nint lower_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k >= make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\nint upper_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k > make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M >> S1 >> S2 >> T &&\n         N && M && S1 && S2 && T ) {    \n    S1--; S2--; T--;\n    init();\n    int K=0;\n    for(int i=0;i<M;i++){\n      int a,b; string w; cin >> a >> b >> w;\n      --a; --b;\n      if( w == \"x\" ){\n        add_edge( a, b, -1 ); K++;\n      }\n      else\n        add_edge( a, b, stoi( w ) );\n    }\n\n    ll res = INF;\n    for(int k=0;k<=2*K;k++){\n      int lp = lower_bound(k);\n      int rp = upper_bound(k);\n      //cout << k << \" : \" << lp << \" \"<< rp << endl;\n      if( lp == rp ) continue;\n      if( F[S1] < F[S2] ) swap(S1,S2);\n      //cout << F[S1] << \" \"<< F[S2] << endl;\n      //cout << useX[S1] << \" \" << useX[S2] << endl;\n      if( useX[S1] >= useX[S2] ){\n        make_dijk_tree( lp );\n        res = min( res, abs( H[S1] - H[S2] ) );\n      } else {\n        int x = (F[S1] - F[S2])/(useX[S2]-useX[S1]);\n        for(int t=x-1;t<=x+1;t++){\n          make_dijk_tree( max(lp,min( rp-1, t )) );\n          //cout << t << \" \" << H[S1] << \" \" << H[S2] << endl;\n          res = min( res, abs( H[S1] - H[S2] ) );\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(101,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long int al = nums[i];\n\t\t\tlong long int ar = nums[i+1];\n\t\t\tif (ar < 0)continue;\n\t\t\telse if (al < 0)al = 0;\n\t\t\tif (al == ar)continue;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (ar - al);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (ar - al);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = (lvalue2 - lvalue1) / (dis1 - dis2);\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll inf = 1e18;\n\nstruct edge {\n    int to;\n    ll cost;\n    bool magical;\n};\n\nusing edges = vector<edge>;\nusing graph = vector<edges>;\n\nint main() {\n    int n, m, s1, s2, t;\n    while(cin >> n >> m >> s1 >> s2 >> t, n) {\n        s1--; s2--; t--;\n        graph g(n);\n        int mag_num = 0;\n        for(int i = 0; i < m; ++i) {\n            int a, b;\n            string w;\n            cin >> a >> b >> w;\n            ll c = (w == \"x\" ? 0 : stoi(w));\n            mag_num += (w == \"x\");\n            bool mag = w == \"x\";\n            g[a - 1].push_back(edge{b - 1, c, mag});\n            g[b - 1].push_back(edge{a - 1, c, mag});\n        }\n\n        vector<vector<ll>> d(n, vector<ll>(mag_num + 1, inf));\n        d[t][0] = 0;\n        using node = tuple<ll, int, int>;\n        priority_queue<node, vector<node>, greater<node>> que;\n        que.emplace(0, t, 0);\n        while(!que.empty()) {\n            ll cur_d;\n            int v, mag_cnt;\n            tie(cur_d, v, mag_cnt) = que.top();\n            que.pop();\n            if(cur_d > d[v][mag_cnt]) continue;\n            for(auto& e : g[v]) {\n                const ll nxt_d = cur_d + e.cost;\n                const int nxt_cnt = mag_cnt + e.magical;\n                if(nxt_cnt > mag_num || d[e.to][nxt_cnt] <= nxt_d) continue;\n                que.emplace(nxt_d, e.to, nxt_cnt);\n                d[e.to][nxt_cnt] = nxt_d;\n            }\n        }\n\n        vector<ll> l1(mag_num + 1), r1(mag_num + 1, inf); // [l1, r1]\n        vector<ll> l2(mag_num + 1), r2(mag_num + 1, inf);\n        auto calc_lr = [mag_num, &d](int s, vector<ll>& l, vector<ll>& r) {\n            for(int i = 0; i < mag_num + 1; ++i) {\n                for(int j = 0; j < mag_num + 1; ++j) {\n                    if(i == j) continue;\n                    if(j - i < 0) {\n                        ll t = 0;\n                        if(d[s][i] - d[s][j] <= 0) {\n                            t = (d[s][i] - d[s][j]) / (j - i);\n                        } else {\n                            t = -1;\n                        }\n                        r[i] = min(r[i], t);\n                    } else {\n                        l[i] = max(l[i], (d[s][i] - d[s][j] + (j - i) - 1) / (j - i));\n                    }\n                }\n            }\n        };\n        calc_lr(s1, l1, r1);\n        calc_lr(s2, l2, r2);\n\n        ll ans = inf;\n        for(int i = 0; i < mag_num + 1; ++i) {\n            for(int j = 0; j < mag_num + 1; ++j) {\n                if(d[s1][i] == inf || d[s2][j] == inf) continue;\n                ll lb = max(l1[i], l2[j]);\n                ll ub = min(r1[i], r2[j]);\n                if(lb > ub) continue;\n                while(ub - lb > 1) {\n                    const ll mid = (lb + ub) / 2;\n                    ll c1 = d[s1][i] + mid * i;\n                    ll c2 = d[s2][j] + mid * j;\n                    if(c1 < c2) {\n                        if(i < j) ub = mid;\n                        else      lb = mid;\n                    } else {\n                        if(i < j) lb = mid;\n                        else      ub = mid;\n                    }\n                }\n                ll c1 = abs(d[s1][i] + lb * i - (d[s2][j] + lb * j));\n                ll c2 = abs(d[s1][i] + ub * i - (d[s2][j] + ub * j));\n                ans = min({ans, c1, c2});\n            }\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-12;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nbool solve(void){\n\tint n,m,sa,sb,T,i;cin>>n>>m>>sa>>sb>>T;\n\tif(n==0){return false;}\n\tsa--;sb--;T--;\n\tvector<vector<pair<int,llint>>>go(n);\n\tvector<vector<int>>mo(n);\n\twhile(m--){\n\t\tint a,b;cin>>a>>b;a--;b--;\n\t\tstring s;cin>>s;\n\t\tif(s==\"x\"){mo[a].pub(b);mo[b].pub(a);}\n\t\telse{llint x=0;for(auto it:s){x*=10;x+=it-'0';}\n\t\t\tgo[a].pub(mp(b,x));go[b].pub(mp(a,x));\n\t\t}\n\t}\n\tvector<llint>distA[104];\n\tvector<llint>distB[104];\n\tfor(i=0;i<104;i++){distA[i]=vector<llint>(n,big);distB[i]=distA[i];}\n\tpriority_queue<tuple<llint,int,int>,vector<tuple<llint,int,int>>,greater<tuple<llint,int,int>>>que;\n\tdistA[0][sa]=0;\n\tque.push(mt(0LL,0,sa));\n\twhile(que.size()){\n\t\tllint time;int mg,bas;\n\t\ttie(time,mg,bas)=que.top();que.pop();\n\t\tif(mg>100||distA[mg][bas]>time){continue;}\n\t\tmineq(distA[mg+1][bas],time);\n\t\tmineq(distA[mg+2][bas],time);\n\t\tfor(auto it:go[bas]){\n\t\t\tif(mineq(distA[mg][it.fir],time+it.sec)){que.push(mt(time+it.sec,mg,it.fir));}\n\t\t}\n\t\tfor(auto it:mo[bas]){\n\t\t\tif(mineq(distA[mg+1][it],time)){que.push(mt(time,mg+1,it));}\n\t\t}\n\t}\n\t\n\tdistB[0][sb]=0;\n\tque.push(mt(0LL,0,sb));\n\twhile(que.size()){\n\t\tllint time;int mg,bas;\n\t\ttie(time,mg,bas)=que.top();que.pop();\n\t\tif(mg>100||distB[mg][bas]>time){continue;}\n\t\tmineq(distB[mg+1][bas],time);\n\t\tmineq(distB[mg+2][bas],time);\n\t\tfor(auto it:go[bas]){\n\t\t\tif(mineq(distB[mg][it.fir],time+it.sec)){que.push(mt(time+it.sec,mg,it.fir));}\n\t\t}\n\t\tfor(auto it:mo[bas]){\n\t\t\tif(mineq(distB[mg+1][it],time)){que.push(mt(time,mg+1,it));}\n\t\t}\n\t}\n\t//convex full\n\tvector<tuple<llint,int,llint>>fullA;\n\tfullA.pub(mt(big+3,0,distA[0][T]));\n\tfor(i=1;i<=100;i++){\n\t\twhile(-1){\n\t\t\tllint nomdif=get<2>(fullA.back())-distA[i][T];\n\t\t\tif(nomdif<=0){break;}\n\t\t\tllint magdif=i-get<1>(fullA.back());\n\t\t\tllint bord=nomdif/magdif;\n\t\t\tif(get<0>(fullA.back())<=bord){fullA.pob();}\n\t\t\telse{fullA.pub(mt(bord,i,distA[i][T]));break;}\n\t\t}\n\t}\n\t//cerr<<\"fullA\"<<endl;\n\t//for(auto it:fullA){cerr<<get<0>(it)<<\" \"<<get<1>(it)<<\" \"<<get<2>(it)<<endl;}\n\t\n\tvector<tuple<llint,int,llint>>fullB;\n\tfullB.pub(mt(big+3,0,distB[0][T]));\n\tfor(i=1;i<=100;i++){\n\t\twhile(-1){\n\t\t\tllint nomdif=get<2>(fullB.back())-distB[i][T];\n\t\t\tif(nomdif<=0){break;}\n\t\t\tllint magdif=i-get<1>(fullB.back());\n\t\t\tllint bord=nomdif/magdif;\n\t\t\tif(get<0>(fullB.back())<=bord){fullB.pob();}\n\t\t\telse{fullB.pub(mt(bord,i,distB[i][T]));break;}\n\t\t}\n\t}\n\t//cerr<<\"fullB\"<<endl;\n\t//for(auto it:fullB){cerr<<get<0>(it)<<\" \"<<get<1>(it)<<\" \"<<get<2>(it)<<endl;}\n\t\n\tllint ans=big,Lbri=0;\n\twhile(fullA.size()+fullB.size()>=2){\n\t\tllint Ubri=min(get<0>(fullA.back()),get<0>(fullB.back()));\n\t\tllint Mdif=get<1>(fullA.back())-get<1>(fullB.back());\n\t\tllint Ndif=get<2>(fullA.back())-get<2>(fullB.back());\n\t\t//cerr<<\"Ndif=\"<<Ndif<<\"Mdif=\"<<Mdif<<endl;\n\t\tif(Lbri>Ubri||get<2>(fullA.back())>big-100||get<2>(fullB.back())>big-100){}\n\t\telse if(Mdif==0){mineq(ans,abs(Ndif));}\n\t\telse{\n\t\t\tif(Mdif<0){Mdif*=-1;}else{Ndif*=-1;}\n\t\t\tllint Sbri=(Ndif+Ndif+Mdif)/(Mdif+Mdif);//四捨五入\n\t\t\tmineq(Sbri,Ubri);maxeq(Sbri,Lbri);\n\t\t\tmineq(ans,abs(Ndif-Mdif*Sbri));\n\t\t}\n\t\tLbri=Ubri+1;\n\t\tif(get<0>(fullA.back())<get<0>(fullB.back())){fullA.pob();}\n\t\telse{fullB.pob();}\n\t}\n\tcout<<ans<<endl;\n\treturn true;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\ntypedef long long ll;\nstruct edge{\n\tint to;\n\tll cost;\n};\nstruct state{\n\tint mag;\n\tll dist;\n\tint id;\n/*\tbool operator<(const state& s) const {\n\t\tif(mag!=s.mag) return mag<s.mag;\n\t\tif(dist!=s.dist) return dist<s.dist;\n\t\treturn id<s.id;\n\t}*/\n\tbool operator>(const state& s) const {\n\t\tif(mag!=s.mag) return mag>s.mag;\n\t\tif(dist!=s.dist) return dist>s.dist;\n\t\treturn id>s.id;\n\t}\n};\nint N,M,s1,s2,t,magic;\nll d[1000][101];\nll inf=1e18;\nvector<edge> G[1000];\nint To_int(string s){\n\tint ret=0;\n\trep(i,s.size()){\n\t\tret*=10;\n\t\tret+=s[i]-'0';\n\t}\n\treturn ret;\n}\nvoid dijkstra(int s){\n\trep(i,N) rep(j,magic+1) d[i][j]=inf;\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\td[s][0]=0;\n\tque.push(state{0,0,s});\n\twhile(!que.empty()){\n\t\tstate st=que.top();\n\t\tque.pop();\n\t\tint mag=st.mag;\n\t\tll dis=st.dist;\n\t\tint v=st.id;\n\t\tif(d[v][mag]!=dis) continue;\n\t\tfor(auto e:G[v]){\n\t\t\tif(e.cost==-1){\n\t\t\t\tif(mag==magic) continue;\n\t\t\t\tif(d[v][mag]<d[e.to][mag+1]){\n\t\t\t\t\td[e.to][mag+1]=d[v][mag];\n\t\t\t\t\tque.push(state{mag+1,d[e.to][mag+1],e.to});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(d[v][mag]+e.cost<d[e.to][mag]){\n\t\t\t\t\td[e.to][mag]=d[v][mag]+e.cost;\n\t\t\t\t\tque.push(state{mag,d[e.to][mag],e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool ispal(L a,L b){\n\treturn abs(cro(a.fs-a.sc,b.fs-b.sc))<1e-9;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>s1>>s2>>t;\n\t\tmagic=0;\n\t\ts1--,s2--,t--;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint a,b;\n\t\t\tstring w;\n\t\t\tcin>>a>>b>>w;\n\t\t\ta--,b--;\n\t\t\tif(w[0]=='x'){\n\t\t\t\tG[a].pb(edge{b,-1});\n\t\t\t\tG[b].pb(edge{a,-1});\n\t\t\t\tmagic++;\n\t\t\t}else{\n\t\t\t\tint ww=To_int(w);\n\t\t\t\tG[a].pb(edge{b,ww});\n\t\t\t\tG[b].pb(edge{a,ww});\n\t\t\t}\n\t\t}\n\t\tdijkstra(t);\n/*\t\trep(i,magic+1){\n\t\t\tshow(d[s1][i]);\n\t\t\tshow(d[s2][i]);\n\t\t}*/\n//\t\tputs(\"done\");\n\t\tvector<L> vla;\n\t\tvector<D> cha;\n\t\t{\n\t\t\tll mn=inf;\n\t\t\trep(i,magic+1){\n\t\t\t\tif(mn<=d[s1][i]) continue;\n\t\t\t\tmn=d[s1][i];\n\t\t\t\tvla.pb(L(P(d[s1][i],0),P(d[s1][i]+1,i)));\n\t\t\t}\n\t\t\treverse(all(vla));\n\t\t\tint K=vla.size();\n\t\t\trep(i,K-1){\n\t\t\t\tP p=intLL(vla[i],vla[i+1]);\n\t\t\t\tcha.pb(p.real());\n\t\t\t}\n\t\t}\n\t\tvector<L> vlb;\n\t\tvector<D> chb;\n\t\t{\n\t\t\tll mn=inf;\n\t\t\trep(i,magic+1){\n\t\t\t\tif(mn<=d[s2][i]) continue;\n\t\t\t\tmn=d[s2][i];\n\t\t\t\tvlb.pb(L(P(d[s2][i],0),P(d[s2][i]+1,i)));\n\t\t\t}\n\t\t\treverse(all(vlb));\n\t\t\tint K=vlb.size();\n\t\t\trep(i,K-1){\n\t\t\t\tP p=intLL(vlb[i],vlb[i+1]);\n\t\t\t\tchb.pb(p.real());\n\t\t\t}\n\t\t}\n/*\t\trep(i,vla.size()){\n\t\t\tcout<<vla[i].fs<<\" \"<<vla[i].sc<<endl;\n\t\t}\n\t\trep(i,vlb.size()){\n\t\t\tcout<<vlb[i].fs<<\" \"<<vlb[i].sc<<endl;\n\t\t}*/\n\t\tvector<ll> xs;\n\t\txs.pb(0);\n\t\tfor(D x:cha) rep(i,5) xs.pb((ll)x+i-2);\n\t\tfor(D x:chb) rep(i,5) xs.pb((ll)x+i-2);\n\t\tcha.pb(inf);\n\t\tchb.pb(inf);\n\t\tcha.insert(cha.begin(),0);\n\t\tchb.insert(chb.begin(),0);\n/*\t\tshow(vla.size());\n\t\tshow(vlb.size());\n\t\tshow(cha.size());\n\t\tshow(chb.size());*/\n\t\trep(i,vla.size()) rep(j,vlb.size()){\n\t\t\tL a=vla[i],b=vlb[j];\n\t\t\tif(ispal(a,b)) continue;\n\t\t\tP p=intLL(a,b);\n\t\t\tD x=p.real();\n\t\t\tif(cha[i]-2<x&&x-2<cha[i+1]&&chb[j]-2<x&&x-2<chb[j+1]){\n\t\t\t\trep(i,5) xs.pb((ll)x+i-2);\n\t\t\t}\n\t\t}\n\t\tll ans=inf;\n\t\tfor(ll x:xs){\n\t\t\tif(x<0||x>inf) continue;\n\t\t\tint ida_=lower_bound(all(cha),x)-cha.begin();\n\t\t\tll A=inf;\n\t\t\t{\n\t\t\t\tfor(int ida=ida_-1;ida<=ida_+1;ida++){\n\t\t\t\t\tif(ida<0||ida>=vla.size()) continue;\n\t\t\t\t\tll a=vla[ida].sc.imag();\n\t\t\t\t\tll b=d[s1][a];\n//\t\t\t\t\tshow(ida);\n//\t\t\t\t\tshow(a);\n//\t\t\t\t\tshow(b);\n\t\t\t\t\tchmin(A,a*x+b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idb_=lower_bound(all(chb),x)-chb.begin();\n\t\t\tll B=inf;\n\t\t\t{\n\t\t\t\tfor(int idb=idb_-1;idb<=idb_+1;idb++){\n\t\t\t\t\tif(idb<0||idb>=vlb.size()) continue;\n\t\t\t\t\tll a=vlb[idb].sc.imag();\n\t\t\t\t\tll b=d[s2][a];\n//\t\t\t\t\tshow(idb);\n//\t\t\t\t\tshow(a);\n//\t\t\t\t\tshow(b);\n\t\t\t\t\tchmin(B,a*x+b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tchmin(ans,abs(A-B));\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint N, M, S1, S2, T;\nvector< vector<edge> > rgraph;\n\nstruct State {\n  int now, cost, magic, prev;\n  State(){}\n  State(int now, int cost, int magic, int prev):now(now), cost(cost), magic(magic), prev(prev){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<vint> mincost;\n\nvoid rdijkstra() {\n  resz(mincost, 101, vint(N, inf));\n  priority_queue<State> que;\n  mincost[0][T] = 0;\n  que.emplace(T, 0, 0, -1);\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(mincost[s.magic][s.now] < s.cost) continue;\n    //cout<<s.now<<\" \"<<s.cost<<\" \"<<rgraph[s.now].size()<<endl;\n    for(edge& e : rgraph[s.now]) {\n      if(e.to == s.prev) continue;\n      if(e.cost >= 0) {\n\tif(e.cost + s.cost < mincost[s.magic][e.to]) {\n\t  mincost[s.magic][e.to] = e.cost + s.cost;\n\t  que.emplace(e.to, e.cost + s.cost, s.magic, s.now);\n\t}\n      } else if(s.magic+1 < 101) {\n\tif(s.cost < mincost[s.magic+1][e.to]) {\n\t  mincost[s.magic+1][e.to] = s.cost;\n\t  que.emplace(e.to, s.cost, s.magic+1, s.now);\n\t}\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N+M+S1+S2+T) {\n    S1--, S2--, T--;\n    resz(rgraph, N);\n    rep(i, M) {\n      int s, t; string ws;\n      cin >> s >> t >> ws;\n      s--, t--;\n      if(ws == \"x\") {\n\trgraph[s].emplace_back(t, -1);\n\trgraph[t].emplace_back(s, -1);\n      } else {\n\tint w = stoi(ws);\n\trgraph[s].emplace_back(t, w);\n\trgraph[t].emplace_back(s, w);\n      }\n    }\n    rdijkstra();\n\n    vector<double> crossX;\n    rep(i, 101) rep(j, 101) {\n      if(i == j) continue;\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      //cout<<mincost[i][S1]<<\" \"<<mincost[j][S2]<<endl;\n      double x = fabs(mincost[j][S2]-mincost[i][S1])/fabs(i-j);\n      crossX.emplace_back(x);\n    }\n\n    int ans = inf;\n    rep(i, 101) rep(j, 101) {\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      chmin(ans, llabs(mincost[i][S1]-mincost[j][S2]));\n    }\n\n    for(double x : crossX) {\n      int ceil_x = ceil(x);\n      int floor_x = floor(x);\n      if(ceil_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  chmin(c, mincost[i][S1]+ceil_x*i);\n\t  chmin(d, mincost[i][S2]+ceil_x*i);\n\t}\n\tchmin(ans, llabs(c - d));\n      }\n      if(floor_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  chmin(c, mincost[i][S1]+floor_x*i);\n\t  chmin(d, mincost[i][S2]+floor_x*i);\n\t}\n\tchmin(ans, llabs(c - d));\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\twhile(1){\n\t\tll n,m,s[2],t;\n\t\tll a[2002],b[2002];\n\t\tll w[2002];\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[0],&s[1],&t);\n\t\tif(n==0)return 0;\n\t\trep(i,m){\n\t\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tif(in == \"x\")w[i] = INF;\n\t\t\telse {\n\t\t\t\tw[i] = 0;\n\t\t\t\trep(j,in.size()){\n\t\t\t\t\tw[i] *= 10;\n\t\t\t\t\tw[i] += in[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> G[2002];\n\t\trep(i,m){\n\t\t\tG[a[i]].pb(P(b[i],w[i]));\n\t\t\tG[b[i]].pb(P(a[i],w[i]));\n\t\t}\n\t\t\n\t\tstatic ll cost[1002][102];\n\t\tstatic bool used[1002][102];\n\t\tstatic priority_queue<P1,vector<P1>,greater<P1>> que;\n\t\trep(i,1002)rep(j,102){\n\t\t\tcost[i][j] = INF;\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tcost[t][0] = 0;\n\t\tque.push(mp1(0,t,0));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.top(); que.pop();\n\t\t\tif(used[p.sc.fr][p.sc.sc])continue;\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t\trep(i,G[p.sc.fr].size()){\n\t\t\t\tP ed = G[p.sc.fr][i];\n\t\t\t\tif(ed.sc == INF){\n\t\t\t\t\tif(p.sc.sc < 100){\n\t\t\t\t\t\tif(cost[ed.fr][p.sc.sc+1] > p.fr){\n\t\t\t\t\t\t\tcost[ed.fr][p.sc.sc+1] = p.fr;\n\t\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc+1],ed.fr,p.sc.sc+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cost[ed.fr][p.sc.sc] > p.fr+ed.sc){\n\t\t\t\t\t\tcost[ed.fr][p.sc.sc] = p.fr+ed.sc;\n\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc],ed.fr,p.sc.sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> vec[2];\n\t\trep(i,2){\n\t\t\trep1(j,100){\n\t\t\t\tcost[s[i]][j] = min ( cost[s[i]][j] , cost[s[i]][j-1] );\n\t\t\t}\n\t\t\trep(j,101){\n\t\t\t\twhile(vec[i].size() >= 2){\n\t\t\t\t\tP p=vec[i][vec[i].size()-2];\n\t\t\t\t\tP q=vec[i][vec[i].size()-1];\n\t\t\t\t\tif((p.fr-q.fr)/(q.sc-p.sc) < (q.fr-cost[s[i]][j])/(j-q.sc)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse vec[i].pop_back();\n\t\t\t\t}\n\t\t\t\tvec[i].pb(P(cost[s[i]][j],j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> x;\n\t\trep(i,2){\n\t\t\tfor(int j = 0 ; j+1 < vec[i].size() ; j ++){\n\t\t\t\tll x_ = (vec[i][j].fr-vec[i][j+1].fr)/(vec[i][j+1].sc-vec[i][j].sc);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,4){\n\t\t\tprintf(\"%lld %lld\\n\",cost[s[0]][i],cost[s[1]][i]);\n\t\t}*/\n\t\t\n\t\tll ret = INF;\n\t\trep(i,x.size()){\n\t\t\tll dist[2] = {INF,INF};\n\t\t\trep(j,2){\n\t\t\t\trep(k,101){\n\t\t\t\t\tdist[j] = min ( dist[j] , k*x[i]+cost[s[j]][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[0] << dist[1] << endl;\n\t\t\tret = min ( ret , abs(dist[0]-dist[1]) );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint N, M, S1, S2, T;\nvector< vector<edge> > rgraph;\n\nstruct State {\n  int now, cost, magic;\n  State(){}\n  State(int now, int cost, int magic):now(now), cost(cost), magic(magic){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<vint> mincost;\n\nvoid rdijkstra() {\n  resz(mincost, 101, vint(N, inf));\n  priority_queue<State> que;\n  mincost[0][T] = 0;\n  que.emplace(T, 0, 0);\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(mincost[s.magic][s.now] < s.cost) continue;\n    for(edge& e : rgraph[s.now]) {\n      if(e.cost >= 0) {\n\tif(e.cost + s.cost < mincost[s.magic][e.to]) {\n\t  mincost[s.magic][e.to] = e.cost + s.cost;\n\t  que.emplace(e.to, e.cost + s.cost, s.magic);\n\t}\n      } else if(s.magic+1 < 101) {\n\tif(s.cost < mincost[s.magic+1][e.to]) {\n\t  mincost[s.magic+1][e.to] = s.cost;\n\t  que.emplace(e.to, s.cost, s.magic+1);\n\t}\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N+M+S1+S2+T) {\n    S1--, S2--, T--;\n    resz(rgraph, N);\n    rep(i, M) {\n      int s, t; string ws;\n      cin >> s >> t >> ws;\n      s--, t--;\n      if(ws == \"x\") {\n\trgraph[s].emplace_back(t, -1);\n\trgraph[t].emplace_back(s, -1);\n      } else {\n\tint w = stoi(ws);\n\trgraph[s].emplace_back(t, w);\n\trgraph[t].emplace_back(s, w);\n      }\n    }\n    rdijkstra();\n\n    vector<double> crossX;\n    crossX.emplace_back(0);\n    rep(i, 101) rep(j, 101) {\n      if(i == j) continue;\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      crossX.emplace_back(((double)mincost[j][S2]-mincost[i][S1])/(i-j));\n      crossX.emplace_back(((double)mincost[i][S1]-mincost[j][S2])/(j-i));\n      crossX.emplace_back(((double)mincost[j][S1]-mincost[i][S1])/(i-j));\n      crossX.emplace_back(((double)mincost[i][S2]-mincost[j][S2])/(j-i));\n    }\n\n    int ans = inf;\n    for(double x : crossX) {\n      int ceil_x = ceil(x);\n      int floor_x = floor(x);\n      if(ceil_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  if(mincost[i][S1] != inf) chmin(c, mincost[i][S1]+ceil_x*i);\n\t  if(mincost[i][S2] != inf) chmin(d, mincost[i][S2]+ceil_x*i);\n\t}\n\tif(c != inf && d != inf) chmin(ans, llabs(c - d));\n      }\n      if(floor_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  if(mincost[i][S1] != inf) chmin(c, mincost[i][S1]+floor_x*i);\n\t  if(mincost[i][S2] != inf) chmin(d, mincost[i][S2]+floor_x*i);\n\t}\n\tif(c != inf && d != inf) chmin(ans, llabs(c - d));\n      }\n    }\n    assert(ans != inf);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<time.h>\n#define Msn(x,y) (memset((x),0,sizeof((x[0]))*(y+1)))\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x,y) (memset((x),0x7f,sizeof((x[0]))*(y+3)))\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\nint n,m;\nconst int maxn=1002;\nstruct node\n{\n    int v;\n    ll w;\n};\nvector<node>g[maxn];\nint T,s1,s2;\nbool inq[maxn];\nll dis[maxn*102];\nconst int M=101;\nvoid solve()\n{\n    queue<int>q;\n    memset(dis,-1,sizeof(dis));\n    msn(inq);\n    q.push(T*M);\n    dis[T*M]=0;\n    inq[T*M]=1;\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        inq[now]=0;\n        int a=now/M;\n        int b=now%M;\n        for(int i=0; i<g[a].size(); i++)\n        {\n            if(g[a][i].w==-1)\n            {\n                int nxt=g[a][i].v*M+b+1;\n                if(b<100)\n                {\n                    if(dis[nxt]==-1||dis[now]<dis[nxt])\n                    {\n                        dis[nxt]=dis[now];\n                        if(!inq[nxt])\n                        {\n                            q.push(nxt);\n                            inq[nxt]=1;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                int nxt=g[a][i].v*M+b;\n                if(dis[nxt]==-1||dis[nxt]>dis[now]+g[a][i].w)\n                {\n                    dis[nxt]=dis[now]+g[a][i].w;\n                    if(!inq[nxt])\n                    {\n                        q.push(nxt);\n                        inq[nxt]=1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct node1\n{\n    ll a,b;\n};\nvector<node1>p[2];\nvector<node1>nod,line;\nll Abs(ll x)\n{\n    return x<0?-x:x;\n}\n\nll check(int x)\n{\n    ll _1,_2;\n    _1=_2=1e18+7;\n    for(int i=0;i<p[0].size();i++)\n    {\n        _1=min(_1,x*p[0][i].a+p[0][i].b);\n    }\n    for(int i=0;i<p[1].size();i++)\n    {\n        _2=min(_2,x*p[1][i].a+p[1][i].b);\n    }\n    return Abs(_1-_2);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&T))\n    {\n        if(n==0&&m==0)break;\n        T--,s1--,s2--;\n        p[0].clear();\n        p[1].clear();\n        nod.clear();\n        line.clear();\n        for(int i=0; i<=n; i++)g[i].clear();\n        int u,v,w;\n        char s[50];\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%s\",&u,&v,s);\n            if(s[0]=='x')\n            {\n                w=-1;\n            }\n            else\n            {\n                w=0;\n                int len=strlen(s);\n                for(int i=0; i<len; i++)\n                {\n                    w=w*10+s[i]-'0';\n                }\n            }\n            u--,v--;\n            g[u].push_back((node)\n            {\n                v,w\n            });\n            g[v].push_back((node)\n            {\n                u,w\n            });\n        }\n        solve();\n      /*  for(int i=0;i<=100;i++)\n        {\n            if(dis[s1*M+i]>=0)p[0].push_back((node1){i,dis[s1*M+i]}),line.push_back((node1){i,dis[s1*M+i]});\n            if(dis[s2*M+i]>=0)p[1].push_back((node1){i,dis[s2*M+i]}),line.push_back((node1){i,dis[s2*M+i]});\n        }\n        ll ans=check(0);\n        for(int i=0;i<line.size();i++)\n        {\n            for(int j=i+1;j<line.size();j++)\n            {\n                if(line[i].a==line[j].a)\n                {\n                    ans=min(Abs(line[i].b-line[j].b),ans);\n                }\n                else\n                {\n                    ll a1=Abs(line[i].b-line[j].b)/Abs((line[i].a-line[j].a));\n                    ans=min(ans,check(a1));\n                    a1++;\n                    ans=min(check(a1),ans);\n                }\n            }\n        }\n        printf(\"%lld\\n\",ans);*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint N,M,T;\nvector<pair<long,long> >f(int S,const vector<vector<pair<int,int> > >&G)\n{\n\tvector<vector<long> >d(M+1,vector<long>(N,(long)1e18));\n\td[0][S]=0;\n\tpriority_queue<pair<long,pair<int,int> > >P;\n\tP.push(make_pair(0L,make_pair(0,S)));\n\twhile(!P.empty())\n\t{\n\t\tlong c=-P.top().first;\n\t\tint u=P.top().second.second,w=P.top().second.first;\n\t\tP.pop();\n\t\tif(d[w][u]<c)continue;\n\t\tfor(pair<int,int>e:G[u])\n\t\t{\n\t\t\tint v=e.first;\n\t\t\tif(e.second==-1)\n\t\t\t{\n\t\t\t\tif(w<M&&d[w+1][v]>c)\n\t\t\t\t{\n\t\t\t\t\td[w+1][v]=c;\n\t\t\t\t\tP.push(make_pair(-c,make_pair(w+1,v)));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(d[w][v]>c+e.second)\n\t\t\t\t{\n\t\t\t\t\td[w][v]=c+e.second;\n\t\t\t\t\tP.push(make_pair(-c-e.second,make_pair(w,v)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdeque<pair<long,long> >Q;\n\tfor(long e=M;e>=0;e--)\n\t{\n\t\tlong f=d[e][T];\n\t\tif(f==(long)1e18)continue;\n\t\twhile(Q.size()>=2)\n\t\t{\n\t\t\tlong a=Q[Q.size()-2].first,b=Q[Q.size()-2].second;\n\t\t\tlong c=Q.back().first,d=Q.back().second;\n\t\t\tif((c-a)*(f-b)+(d-b)*(a-e)>=0)Q.pop_back();\n\t\t\telse break;\n\t\t}\n\t\tQ.push_back(make_pair(e,f));\n\t}\n\treturn vector<pair<long,long> >(Q.begin(),Q.end());\n}\nmain()\n{\n\tint S1,S2;\n\twhile(cin>>N>>M>>S1>>S2>>T,N)\n\t{\n\t\tS1--,S2--,T--;\n\t\tvector<vector<pair<int,int> > >G(N);\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint a,b;string w;\n\t\t\tcin>>a>>b>>w;\n\t\t\ta--,b--;\n\t\t\tif(w==\"x\")\n\t\t\t{\n\t\t\t\tG[a].push_back(make_pair(b,-1));\n\t\t\t\tG[b].push_back(make_pair(a,-1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint W=0;\n\t\t\t\tfor(char c:w)W=W*10+c-'0';\n\t\t\t\tG[a].push_back(make_pair(b,W));\n\t\t\t\tG[b].push_back(make_pair(a,W));\n\t\t\t}\n\t\t}\n\t\tvector<pair<long,long> >d1=f(S1,G);\n\t\tvector<pair<long,long> >d2=f(S2,G);\n\t\tlong ans=9e18;\n\t\tlong pre=0;\n\t\tint i1=0,i2=0;\n\t\twhile(true)\n\t\t{\n\t\t\tlong t1=1e15,t2=1e15;\n\t\t\tif(i1+1<d1.size())\n\t\t\t{\n\t\t\t\tlong a=d1[i1].first,b=d1[i1].second;\n\t\t\t\tlong c=d1[i1+1].first,d=d1[i1+1].second;\n\t\t\t\tt1=(d-b+(a-c)-1)/(a-c);\n\t\t\t}\n\t\t\tif(i2+1<d2.size())\n\t\t\t{\n\t\t\t\tlong a=d2[i2].first,b=d2[i2].second;\n\t\t\t\tlong c=d2[i2+1].first,d=d2[i2+1].second;\n\t\t\t\tt2=(d-b+(a-c)-1)/(a-c);\n\t\t\t}\n\t\t\tlong l=pre,r=t1<t2?t1:t2;\n\t\t\tpre=max(pre,r--);\n\t\t\tlong a=d1[i1].first,b=d1[i1].second;\n\t\t\tlong c=d2[i2].first,d=d2[i2].second;\n\t\t\twhile(r-l>3)\n\t\t\t{\n\t\t\t\tlong m1=(l+l+r)/3,m2=(l+r+r)/3;\n\t\t\t\tif(abs(a*m1+b-(c*m1+d))<abs(a*m2+b-(c*m2+d)))r=m2;\n\t\t\t\telse l=m1;\n\t\t\t}\n\t\t\tfor(long t=l;t<=r;t++)ans=min(ans,abs(a*t+b-(c*t+d)));\n\t\t\tif(t1<=t2)i1++;\n\t\t\telse i2++;\n\t\t\tif(i1==d1.size()||i2==d2.size())break;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-2;i<=m+2;i++){\n    if(m<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    cands.insert(0);\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[i][S1]);\n\tadd_cands(j,d[j][S2],i,d[i][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "//      whn6325689\n//      Mr.Phoebe\n//      http://blog.csdn.net/u013007900\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <climits>\n#include <complex>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n\nusing namespace std;\n\n#define eps 1e-9\n#define PI acos(-1.0)\n#define INF 0x3f3f3f3f\n#define LLINF 1LL<<50\n#define speed std::ios::sync_with_stdio(false);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef complex<ld> point;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef vector<int> vi;\n\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define CPY(x,y) memcpy(x,y,sizeof(x))\n#define clr(a,x,size) memset(a,x,sizeof(a[0])*(size))\n#define cpy(a,x,size) memcpy(a,x,sizeof(a[0])*(size))\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define lowbit(x) (x&(-x))\n\n#define MID(x,y) (x+((y-x)>>1))\n#define ls (idx<<1)\n#define rs (idx<<1|1)\n#define lson ls,l,mid\n#define rson rs,mid+1,r\n\ntemplate<class T>\ninline bool read(T &n)\n{\n    T x = 0, tmp = 1;\n    char c = getchar();\n    while((c < '0' || c > '9') && c != '-' && c != EOF) c = getchar();\n    if(c == EOF) return false;\n    if(c == '-') c = getchar(), tmp = -1;\n    while(c >= '0' && c <= '9') x *= 10, x += (c - '0'),c = getchar();\n    n = x*tmp;\n    return true;\n}\ntemplate <class T>\ninline void write(T n)\n{\n    if(n < 0)\n    {\n        putchar('-');\n        n = -n;\n    }\n    int len = 0,data[20];\n    while(n)\n    {\n        data[len++] = n%10;\n        n /= 10;\n    }\n    if(!len) data[len++] = 0;\n    while(len--) putchar(data[len]+48);\n}\n//-----------------------------------\n\nint n,m,s[3],t;\nint vis[1010][111];\nll dis[1010][111];\ndouble val[111];\nchar str[22];\nstruct Edge\n{\n    int to,next;\n    ll w;\n} e[40010];\nint head[1010],tot,mag,num;\n\nvoid init()\n{\n    CLR(head,-1);\n    tot=mag=num=0;\n}\n\nvoid addedge(int u,int v,int w)\n{\n    e[tot].to=v;\n    e[tot].w=w;\n    e[tot].next=head[u];\n    head[u]=tot++;\n}\n\nvoid spfa(int s)\n{\n    queue<pll> q;\n    CLR(dis,-1);\n    CLR(vis,0);\n    while(!q.empty())   q.pop();\n    dis[s][0]=0;\n    vis[s][0]=1;\n    q.push(mp(s,0));\n    while(!q.empty())\n    {\n        pll tmp=q.front();\n        q.pop();\n        ll u=tmp.first,tim=tmp.second,v;\n        vis[u][tim]=false;\n        for(int i=head[u]; ~i; i=e[i].next)\n        {\n            v=e[i].to;\n            ll k,w;\n            if(e[i].w==-1)  w=0,k=1;\n            else    w=e[i].w,k=0;\n            if(tim+k<=mag && (dis[v][tim+k]==-1 || dis[v][tim+k]>dis[u][tim]+w))\n            {\n                dis[v][tim+k]=dis[u][tim]+w;\n                if(!vis[v][tim+k])\n                {\n                    vis[v][tim+k]=true;\n                    q.push(mp(v,tim+k));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    freopen(\"data.txt\",\"r\",stdin);\n    while(read(n)&&read(m)&&read(s[1])&&read(s[2])&&read(t)&&(n+m))\n    {\n        init();\n        for(int i=0,u,v,w; i<m; i++)\n        {\n            scanf(\"%d %d %s\",&u,&v,&str);\n            if(str[0]=='x')\n            {\n                addedge(u,v,-1);\n                addedge(v,u,-1);\n                mag++;\n            }\n            else\n            {\n                sscanf(str,\"%d\",&w);\n                addedge(u,v,w);\n                addedge(v,u,w);\n            }\n        }\n        spfa(t);\n        val[num++]=0;\n        for(int i=1; i<=2; i++)\n        {\n            for(int j=0; j<mag; j++)\n            {\n                int minn=dis[s[i]][j];\n                if(minn==-1)    continue;\n                for(int k=j+1; k<=mag; k++)\n                {\n                    int maxx=dis[s[i]][k];\n                    if(maxx==-1)    continue;\n                    double w=1.0*(maxx-minn)/(j-k);\n                    if(w>0) val[num++]=w;\n                }\n            }\n        }\n        for(int j=0; j<=mag; j++)\n        {\n            int minn=dis[s[1]][j];\n            if(minn==-1)    continue;\n            for(int k=0; k<=mag; k++)\n            {\n                if(j==k)    continue;\n                int maxx=dis[s[2]][k];\n                if(maxx==-1)    continue;\n                double w=1.0*(maxx-minn)/(j-k);\n                if(w>0) val[num++]=w;\n            }\n        }\n        ll mi[3],ans=INF;\n        for(int i=0; i<num; i++)\n        {\n            for(int j=1; j<=2; j++)\n            {\n                mi[j]=LLINF;\n                for(int k=0; k<=mag; k++)\n                    if(~dis[s[j]][k])\n                    {\n                        mi[j]=min(mi[j],dis[s[j]][k]+k*(ll)(val[i]+eps));\n                        mi[j]=min(mi[j],dis[s[j]][k]+k*(ll)(val[i]+eps+1));\n                    }\n            }\n            ans=min(ans,abs(mi[1]-mi[2]));\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tint value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoi(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e9));\n\t\tfor (int i = 0; i < 102; ++i) {\n\t\t\tmemo[T][i] = 0;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)break;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e9) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e9) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e18));\n\t\tfor (int i = 0; i < cht1.ls.size()-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < cht2.ls.size() - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tif (int(l) == int(r))continue;\n\t\t\telse {\n\t\t\t\tlong long int al = l;\n\t\t\t\tlong long int ar = r;\n\t\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\t\tans = min(ans, abs(lvalue1 - rvalue1));\n\t\t\t\t\t}\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx +1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx -1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx  + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 59;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n  vector< edge > G[1000];\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n    for(auto &cost : latte) if(cost >= 0) ret = min(ret, get(cost));\n    for(auto &cost : latte) if(cost >= -1) ret = min(ret, get(cost + 1));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(101,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long int al = nums[i];\n\t\t\tlong long int ar = nums[i+1];\n\t\t\tif (ar < 0)continue;\n\t\t\telse if (al < 0)al = 0;\n\t\t\tif (al == ar)continue;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (ar - al);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (ar - al);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = (lvalue2 - lvalue1) / (dis1 - dis2);\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\t//if (N != 1000)continue;\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long int al = nums[i];\n\t\t\tlong long int ar = nums[i+1];\n\t\t\tif (ar < 0)continue;\n\t\t\telse if (al < 0)al = 0;\n\t\t\tif (al == ar)continue;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (ar - al);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (ar - al);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\nvector<P> G[1111];\nint N,M,S1,S2,T;\nll H[1111];\nll F[1111];\nint useX[1111];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\n\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();  \n}\n\nint make_dijk_tree(int X){  \n  priority_queue<P,vector<P>,greater<P>> q;\n  q.push( P(0,T) );\n  fill( H, H+N, INF );\n  fill( F, F+N, 0LL );\n  fill( useX, useX+N, 0 );\n  while( !q.empty() ) {\n    P p = q.top(); q.pop();\n    ll c = p.first;\n    int v = p.second;\n    for( P e : G[v] ){      \n      ll nc = e.first + c;\n      if( e.first == -1 ) nc = X + c;\n      int nv = e.second;\n      if( H[nv] > nc ) {\n        H[nv] = nc;\n        F[nv] = F[v] + e.first;\n        useX[nv] = useX[v];\n        if( e.first == -1 ) {\n          useX[nv]++;\n          F[nv] = F[v];\n        }\n        q.push( P( nc, nv ) );\n      }\n    }\n  }\n  //cout << X << \" \" << useX[S1] << \" + \" << useX[S2] << endl;\n  return useX[S1] + useX[S2];\n}\n\nvoid add_edge(int a,int b,int w){\n  G[a].push_back( P(w,b) );\n  G[b].push_back( P(w,a) );\n}\n\nint lower_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k >= make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\nint upper_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k > make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M >> S1 >> S2 >> T &&\n         N && M && S1 && S2 && T ) {    \n    S1--; S2--; T--;\n    init();\n    int K=0;\n    for(int i=0;i<M;i++){\n      int a,b; string w; cin >> a >> b >> w;\n      --a; --b;\n      if( w == \"x\" ){\n        add_edge( a, b, -1 ); K++;\n      }\n      else\n        add_edge( a, b, stoi( w ) );\n    }\n\n    ll res = INF;\n    for(int k=0;k<=2*K;k++){\n      int lp = lower_bound(k);\n      int rp = upper_bound(k);\n      //cout << k << \" : \" << lp << \" \"<< rp << endl;\n      if( lp == rp ) continue;\n      if( F[S1] < F[S2] ) swap(S1,S2);\n      //cout << F[S1] << \" \"<< F[S2] << endl;\n      //cout << useX[S1] << \" \" << useX[S2] << endl;\n      if( useX[S1] >= useX[S2] ){\n        make_dijk_tree( lp );\n        res = min( res, abs( H[S1] - H[S2] ) );\n      } else {\n        int x = (F[S1] - F[S2])/(useX[S2]-useX[S1]);\n        for(int t=x-1;t<=x+1;t++){\n          make_dijk_tree( min( rp-1, t ) );\n          //cout << t << \" \" << H[S1] << \" \" << H[S2] << endl;\n          res = min( res, abs( H[S1] - H[S2] ) );\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nvector<pii> g[1000];\nll dist[1000][101];\n\nstruct P {\n  int v,c;\n  ll d;\n  P(int v, int c, ll d):v(v),c(c),d(d) {\n  }\n  bool operator<(const P &rhs) const {\n    return d>rhs.d;\n  }\n};\nint n,m,s1,s2,t;\n\nvector<ll> func(int s) {\n  priority_queue<P> Q;\n  Q.push(P(s,0,0));\n  REP(i,n)REP(j,101)dist[i][j] = 1LL<<60;\n  dist[s][0] = 0;\n  while(!Q.empty()) {\n    P p = Q.top(); Q.pop();\n    if (dist[p.v][p.c] < p.d) continue;\n    FOR(it, g[p.v]) {\n      ll nd = p.d;\n      int nc = p.c;\n      if (it->second == -1) {\n        nc++;\n      } else {\n        nd += it->second;\n      }\n      if (nc > 100) continue;\n      if (dist[it->first][nc] > nd) {\n        dist[it->first][nc] = nd;\n        Q.push(P(it->first,nc,nd));\n      }\n    }\n  }\n  vector<ll> res;\n  REP(i,101) {\n    res.push_back(dist[t][i]);\n  }\n  return res;\n}\n\nvector<ll> func2(vector<ll> v) {\n  vector<ll> res;\n  REP(i,v.size()) {\n    if (v[i] == 1LL<<60) continue;\n    REP(j,i) {\n      if (v[j] == 1LL<<60) continue;\n      // v[i]+i*x = v[j]+j*x\n      double x = -(v[i]-v[j])/(i-j);\n      if (x < 0) continue;\n      res.push_back((ll)x);\n      res.push_back((ll)(x+1));\n    }\n  }\n  return res;\n}\n\nint main() {  \n  while(cin>>n>>m>>s1>>s2>>t,n) {\n    s1--;s2--;t--;\n    REP(i,n) g[i].clear();\n    REP(i,m) {\n      int a,b;\n      string s;\n      cin >> a >> b >> s;\n      a--;b--;\n      int d;\n      if (s == \"x\") {\n        d = -1;\n      } else {\n        d = atoi(s.c_str());\n      }\n      g[a].push_back(pii(b,d));\n      g[b].push_back(pii(a,d));\n    }\n    vector<ll> v1 = func(s1);\n    vector<ll> v2 = func(s2);\n    vector<ll> xs = func2(v1);\n    vector<ll> xs2 = func2(v2);\n    FOR(it, xs2) xs.push_back(*it);\n    REP(i,v1.size()) {\n      if (v1[i] == INF) continue;\n      REP(j,v2.size()) {\n        if (v2[j] == INF) continue;\n        if (i==j) continue;\n        double x = -(v1[i]-v2[j])/(i-j);\n        if (x < 0) continue;\n        xs.push_back((ll)x);\n        xs.push_back((ll)(x+1));        \n      }\n    }\n    // REP(i,3) {\n    //   cout << i << \" \" << v1[i] << \" \" << v2[i]<< endl;\n    // }    \n    xs.push_back(0);\n    sort(ALL(xs));\n    xs.erase(unique(ALL(xs)), xs.end());\n    ll res = 1LL<<61;\n    FOR(it, xs) {\n      ll x = *it;\n      ll y1 = 1LL<<61;\n      REP(i,v1.size()) {\n        if (v1[i] == 1LL<<60) continue;\n        chmin(y1,v1[i]+i*x);\n      }\n      ll y2 = 1LL<<61;\n      REP(i,v2.size()) {\n        if (v2[i] == 1LL<<60) continue;\n        chmin(y2,v2[i]+i*x);\n      }\n      chmin(res, abs(y1-y2));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint N, M, S1, S2, T;\nvector< vector<edge> > rgraph;\n\nstruct State {\n  int now, cost, magic, prev;\n  State(){}\n  State(int now, int cost, int magic, int prev):now(now), cost(cost), magic(magic), prev(prev){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<vint> mincost;\n\nvoid rdijkstra() {\n  resz(mincost, 101, vint(N, inf));\n  priority_queue<State> que;\n  mincost[0][T] = 0;\n  que.emplace(T, 0, 0, -1);\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(mincost[s.magic][s.now] < s.cost) continue;\n    //cout<<s.now<<\" \"<<s.cost<<\" \"<<rgraph[s.now].size()<<endl;\n    for(edge& e : rgraph[s.now]) {\n      if(e.to == s.prev) continue;\n      if(e.cost >= 0) {\n\tif(e.cost + s.cost < mincost[s.magic][e.to]) {\n\t  mincost[s.magic][e.to] = e.cost + s.cost;\n\t  que.emplace(e.to, e.cost + s.cost, s.magic, s.now);\n\t}\n      } else if(s.magic+1 < 101) {\n\tif(s.cost < mincost[s.magic+1][e.to]) {\n\t  mincost[s.magic+1][e.to] = s.cost;\n\t  que.emplace(e.to, s.cost, s.magic+1, s.now);\n\t}\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N+M+S1+S2+T) {\n    S1--, S2--, T--;\n    resz(rgraph, N);\n    rep(i, M) {\n      int s, t; string ws;\n      cin >> s >> t >> ws;\n      s--, t--;\n      if(ws == \"x\") {\n\trgraph[s].emplace_back(t, -1);\n\trgraph[t].emplace_back(s, -1);\n      } else {\n\tint w = stoi(ws);\n\trgraph[s].emplace_back(t, w);\n\trgraph[t].emplace_back(s, w);\n      }\n    }\n    rdijkstra();\n\n    vector<double> crossX;\n    crossX.emplace_back(0);\n    rep(i, 101) rep(j, 101) {\n      if(i == j) continue;\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      //cout<<mincost[i][S1]<<\" \"<<mincost[j][S2]<<endl;\n      crossX.emplace_back((mincost[j][S2]-mincost[i][S1])/(i-j));\n      crossX.emplace_back((mincost[i][S1]-mincost[j][S2])/(j-i));\n    }\n\n    int ans = inf;\n    /*\n    rep(i, 101) rep(j, 101) {\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      chmin(ans, llabs(mincost[i][S1]-mincost[j][S2]));\n    }\n    */\n\n    for(double x : crossX) {\n      int ceil_x = ceil(x);\n      int floor_x = floor(x);\n      if(ceil_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  if(mincost[i][S1] != inf) chmin(c, mincost[i][S1]+ceil_x*i);\n\t  if(mincost[i][S2] != inf) chmin(d, mincost[i][S2]+ceil_x*i);\n\t}\n\tchmin(ans, llabs(c - d));\n      }\n      if(floor_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  if(mincost[i][S1] != inf) chmin(c, mincost[i][S1]+floor_x*i);\n\t  if(mincost[i][S2] != inf) chmin(d, mincost[i][S2]+floor_x*i);\n\t}\n\tchmin(ans, llabs(c - d));\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main() {\n  ll n,m,s1,s2,t;\n  while(cin >> n >> m >> s1 >> s2 >> t && n) {\n    s1--,s2--,t--;\n    vector<P> v[n];\n    for(int i=0; i<m; i++) {\n      ll x,y,z;\n      string s;\n      cin >> x >> y >> s;\n      x--,y--;\n      if(s==\"x\") z=-1;\n      else {\n        stringstream ss;\n        ss << s;\n        ss >> z;\n      }\n      v[x].push_back(P(y,z));\n      v[y].push_back(P(x,z));\n    }\n    P d[n];\n    for(int i=0; i<n; i++) d[i]=P(-1,-1);\n    d[t]=P(0,0);\n    queue<int> que;\n    que.push(t);\n    while(!que.empty()) {\n      ll x=que.front();que.pop();\n      for(int i=0; i<v[x].size(); i++) {\n        ll y=v[x][i].first,c=v[x][i].second;\n        if(d[y]!=P(-1,-1)) continue;\n        if(c==-1) d[y]=P(d[x].first,d[x].second+1);\n        else d[y]=P(d[x].first+c,d[x].second);\n        que.push(y);\n      }\n    }\n    P p=d[s1],q=d[s2];\n    ll z=min(p.second,q.second);\n    p.second-=z;q.second-=z;\n    if(!p.second) swap(p,q);\n    ll l=0,r=1LL<<50;\n    while(l+1<r) {\n      ll mid=(l+r)/2;\n      if(p.first+p.second*mid<q.first) l=mid;\n      else r=mid;\n    }\n    cout << min(abs(p.first+p.second*l-q.first),abs(p.first+p.second*r-q.first)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tint value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoi(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e18));\n\t\tfor (int i = 0; i < 102; ++i) {\n\t\t\tmemo[T][i] = 0;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)break;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e18));\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tif (int(l) == int(r))continue;\n\t\t\telse {\n\t\t\t\tlong long int al = l;\n\t\t\t\tlong long int ar = r;\n\t\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\t\tans = min(ans, abs(lvalue1 - rvalue1));\n\t\t\t\t\t}\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx +1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx -1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx  + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 60;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    vector< edge > G[1000];\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int64 cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n\n    for(int i = -10; i <= 10; i++) {\n      for(auto &cost : latte) ret = min(ret, get(cost + i));\n    }\n    // zinsei\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n, m, s1, s2, t;\nvector<pl> e[1000];\nll dist[101][1000];\nll d[2][101];\npl range[2][101];\n\nvoid solve() {\n    rep(i,1000) e[i].clear();\n    s1--; s2--; t--;\n    int b_cnt = 0;\n    rep(i,m) {\n        int a, b; string s;\n        cin >> a >> b >> s; a--; b--;\n        if (s == \"x\") {\n            e[a].push_back(pl(b, -1));\n            e[b].push_back(pl(a, -1));\n            b_cnt++;\n        } else {\n            ll num = 0;\n            rep(j,s.size()) {\n                num = num * 10 + s[j]-'0';\n            }\n            e[a].push_back(pl(b, num));\n            e[b].push_back(pl(a, num));\n        }\n    }\n    rep(i,101) rep(j,n) dist[i][j] = linf;\n    dist[0][t] = 0;\n    priority_queue<pl, vector<pl>, greater<pl>> pque;\n    pque.push(pl(0, t));\n    while (!pque.empty()) {\n        ll dis = pque.top().first, num = pque.top().second/n, pos = pque.top().second%n;\n        pque.pop();\n        if (dis > dist[num][pos]) continue;\n        rep(i,e[pos].size()) {\n            pl E = e[pos][i];\n            if (E.second == -1) {\n                if (num != b_cnt && dist[num+1][E.first] > dist[num][pos]) {\n                    dist[num+1][E.first] = dist[num][pos];\n                    pque.push(pl(dist[num+1][E.first], (num+1)*n+E.first));\n                } \n            } else {\n                if (dist[num][E.first] > dist[num][pos] + E.second) {\n                    dist[num][E.first] = dist[num][pos] + E.second;\n                    pque.push(pl(dist[num][E.first], num*n + E.first));\n                }\n            }\n        }\n    }\n    b_cnt++;\n    rep(i,b_cnt) d[0][i] = dist[i][s1];\n    rep(i,b_cnt) d[1][i] = dist[i][s2];\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << d[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n    rep(i,2) rep(j,b_cnt) range[i][j] = pl(0, inf * 1000LL);\n    rep(i,2) {\n        rep(j,b_cnt) {\n            if (d[i][j] == linf) {\n                range[i][j] = pl(-1, -1);\n                continue;\n            }\n            rep(k,b_cnt) {\n                if (d[i][k] == linf) continue;\n                if (j == k) continue;\n                if (j < k) {\n                    if (d[i][j] <= d[i][k]) continue;\n                    ll hoge = (d[i][j] - d[i][k] + k-j-1) / (k-j);\n                    range[i][j].first = max(range[i][j].first, hoge);\n                } else {\n                    if (d[i][j] >= d[i][k]) {\n                        range[i][j] = pl(-1, -1);\n                        break;\n                    }\n                    ll hoge = (d[i][k] - d[i][j] + j-k-1) / (j-k);\n                    range[i][j].second = min(range[i][j].second, hoge);\n                }\n            }\n        }\n    }\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << \"(\" << range[i][j].first << \", \" << range[i][j].second << \") \";\n        }\n        cerr << endl;\n    }\n    */\n    ll ans = linf;\n    rep(i,b_cnt) {\n        rep(j,b_cnt) {\n            if (range[0][i].first == -1 || range[1][j].first == -1) continue;\n            ll l = max(range[0][i].first, range[1][j].first), r = min(range[0][i].second, range[1][j].second);\n            if (l > r) continue;\n            bool flag = (d[0][i] + i*l >= d[1][j] + j*l);\n            if (flag) {\n                if (i >= j) {\n                    ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                    continue;\n                }\n                //cerr << \"Ok\" << endl;\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 >= val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                ans = min(ans, abs(d[0][i]+i*r - d[1][j] - j*r));\n            } else {\n                if (i <= j) {\n                    ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                    continue;\n                }\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 < val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                ans = min(ans, abs(d[1][j]+j*r - d[0][i] - i*r));\n\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    while (cin >> n >> m >> s1 >> s2 >> t) {\n        if (n == 0 && m == 0 && s1 == 0 && s2 == 0 && t == 0) break;\n        solve();\n    }\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[1001];\n\nll dijk(int st){\n\tfor(int i=0;i<n;i++){\n\t\tdist[i]=INF;\n\t}\n\tpriority_queue<P,vector<P>,greater<P> > que;\n\tque.push(P(0,st));\n\tdist[st]=0;\n\twhile(que.size()){\n\t\tP p=que.top();\n\t\tque.pop();\n\t\tif(dist[p.second]<p.first)continue;\n\t\tfor(int i=0;i<G[p.second].size();i++){\n\t\t\tedge e=G[p.second][i];\n\t\t\tif(dist[e.t]>dist[p.second]+e.c){\n\t\t\t\tdist[e.t]=dist[p.second]+e.c;\n\t\t\t\tque.push(P(dist[e.t],e.t));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G2[p.second].size();i++){\n\t\t\tedge e=G2[p.second][i];\n\t\t\tif(dist[e.t]>dist[p.second]+e.c){\n\t\t\t\tdist[e.t]=dist[p.second]+e.c;\n\t\t\t\tque.push(P(dist[e.t],e.t));\n\t\t\t}\n\t\t}\n\t}\n\treturn dist[t];\n}\n\nll labs(ll v){\n\tif(v<0LL)return -v;\n\treturn v;\n}\n\nll calc(ll val){\n\tfor(int i=0;i<n;i++){\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]==\"x\"){\n\t\t\tG2[a[i]].push_back(edge(b[i],val));\n\t\t\tG2[b[i]].push_back(edge(a[i],val));\n\t\t}\n\t}\n\treturn labs(dijk(s1)-dijk(s2));\n}\n\nll getnumber(string str){\n\tll ans=0;\n\tfor(int i=0;i<str.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(str[i]-'0');\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}\n\t}\n\twhile(r-l>=1000LL){\n\t\tll midl=(l*2LL+r)/3LL;\n\t\tll midr=(l+r*2LL)/3LL;\n\t\tif(calc(midl)<calc(midr)){\n\t\t\tr=midr;\n\t\t}else{\n\t\t\tl=midl;\n\t\t}\n\t}\n\tll ans=calc(l);\n\tfor(ll i=l+1;i<r;i++){\n\t\tans=min(ans,calc(i));\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[i][S1]-dist[j][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[i][S2]-dist[j][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(lis.back()+1);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n        if(ans==0){\n            cout<<x1<<\" \"<<x2<<endl;\n            break;\n        }\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nstruct Edge { int to; lint c; };\n\nstruct State {\n\tint v, h; lint c;\n\tbool operator > (const State& s) const { return c > s.c; }\n};\n\nint N, M, S1, S2, T, BC;\nvector< vector< Edge > > adj;\nlint dst[2][1010][110], INF = 1LL << 60;\n\nvoid djk(int index, int s) {\n\tfor_(v,0,N) for_(h,0,BC+1) dst[index][v][h] = INF;\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{s, 0, 0});\n\tdst[index][s][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tif (dst[index][s.v][s.h] < s.c) continue;\n\t\t\n\t\tfor (Edge e : adj[s.v]) {\n\t\t\tlint nxc = s.c + (e.c == -1 ? 0 : e.c);\n\t\t\tint nh = s.h + (e.c == -1 ? 1 : 0);\n\t\t\t\n\t\t\tif (nh <= BC && dst[index][e.to][nh] > nxc) {\n\t\t\t\tdst[index][e.to][nh] = nxc;\n\t\t\t\tque.push(State{e.to, nh, nxc});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector< lint > calcX(int index) {\n\tvector< lint > X;\n\t\n\tfor_(ki,0,BC+1) for_(kj,ki+1,BC+1) {\n\t\tlint di = dst[index][T][ki], dj = dst[index][T][kj];\n\t\tlint x = (di - dj) / (kj - ki);\n\t\tfor_(dx,-1,2) if (di < INF && dj < INF && x + dx >= 0) X.push_back(x + dx);\n\t}\n\t\n\treturn X;\n}\n\nvoid solve() {\n\tdjk(0, S1);\n\tdjk(1, S2);\n\t\n\tvector< lint > X = calcX(0), XX = calcX(1);\n\tX.insert(X.end(), allof(XX));\n\t\n\tsort(allof(X));\n\tX.erase(unique(allof(X)), X.end());\n\t\n\tif (X.empty()) X.push_back(0);\n\tint m = X.size();\n\t\n\tlint ans = INF;\n\t\n\tfor_(i,0,m) {\n\t\tlint x = X[i];\n\t\t\n\t\tlint dk[2] = {INF, INF};\n\t\tfor_(j,0,2) for_(k,0,BC+1) dk[j] = min(dk[j], dst[j][T][k] + k * x);\n\t\t\n\t\tans = min(ans, abs(dk[0] - dk[1]));\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M >> S1 >> S2 >> T, N) {\n\t\t--S1; --S2; --T;\n\t\tadj.assign(N, vector< Edge >());\n\t\tBC = 0;\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint u, v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\t--u; --v;\n\t\t\t\n\t\t\tlint c;\n\t\t\t\n\t\t\tif (str == \"x\") {\n\t\t\t\tc = -1;\n\t\t\t\t++BC;\n\t\t\t} else {\n\t\t\t\tstringstream ss(str);\n\t\t\t\tss >> c;\n\t\t\t}\n\t\t\t\n\t\t\tadj[u].push_back(Edge{v, c});\n\t\t\tadj[v].push_back(Edge{u, c});\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\ntypedef long long lint;\n\nstruct Edge {\n\tint to;\n\tlint c;\n\tbool operator > (const Edge& e) const { return c > e.c; }\n};\n\nint N, M, S1, S2, T;\nvector< vector< Edge > > adj;\nlint dst[1010];\n\nlint djk(int s, lint magic) {\n\tfor_(v,0,N) dst[v] = 1LL << 60;\n\t\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > que;\n\tque.push(Edge{s, 0});\n\tdst[s] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge s = que.top(); que.pop();\n\t\t\n\t\tif (dst[s.to] < s.c) continue;\n\t\t\n\t\tfor (Edge e : adj[s.to]) {\n\t\t\tlint nxc = s.c + (e.c == -1 ? magic : e.c);\n\t\t\t\n\t\t\tif (dst[e.to] > nxc) {\n\t\t\t\tdst[e.to] = nxc;\n\t\t\t\tque.push(Edge{e.to, nxc});\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn dst[T];\n}\n\nvoid solve() {\n\tlint lb = 0, ub = 1LL << 45;\n\t\n\tfor_(i,0,100) {\n\t\tlint lft = (lb + ub) / 3;\n\t\tlint rgt = (lb + ub) * 2 / 3;\n\t\t\n\t\tlint lft_abs = abs(djk(S1, lft) - djk(S2, lft));\n\t\tlint rgt_abs = abs(djk(S1, rgt) - djk(S2, rgt));\n\t\t\n\t\tif (lft_abs < rgt_abs) ub = rgt;\n\t\telse lb = lft;\n\t}\n\t\n\tcout << abs(djk(S1, lb) - djk(S2, lb)) << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M >> S1 >> S2 >> T, N) {\n\t\t--S1; --S2; --T;\n\t\tadj.assign(N, vector< Edge >());\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint u, v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\t--u; --v;\n\t\t\t\n\t\t\tlint c;\n\t\t\t\n\t\t\tif (str == \"x\") {\n\t\t\t\tc = -1;\n\t\t\t} else {\n\t\t\t\tstringstream ss(str);\n\t\t\t\tss >> c;\n\t\t\t}\n\t\t\t\n\t\t\tadj[u].push_back(Edge{v, c});\n\t\t\tadj[v].push_back(Edge{u, c});\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2541.cc: Magical Bridges\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 1000;\nconst int MAX_B = 100;\n\ntypedef long long ll;\n\nconst ll LINF = 1LL << 60;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nstruct Stat {\n  ll d;\n  int i, b;\n  Stat() {}\n  Stat(ll _d, int _i, int _b): d(_d), i(_i), b(_b) {}\n  bool operator<(const Stat &s) const { return d > s.d; }\n};\n\n/* global variables */\n\nvpii nbrs[MAX_N];\nll dists[MAX_N][MAX_B + 1];\n\n/* subroutines */\n\nll mindist(ll (&ds)[MAX_B + 1], int bn, ll w) {\n  ll mind = LINF;\n  for (int i = 0; i <= bn; i++) {\n    ll d = ds[i] + w * i;\n    if (mind > d) mind = d;\n  }\n  return mind;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    int n, m, s0, s1, t;\n    cin >> n >> m >> s0 >> s1 >> t;\n    if (n == 0) break;\n    s0--, s1--, t--;\n    \n    for (int i = 0; i < n; i++) nbrs[i].clear();\n\n    int bn = 0;\n    for (int i = 0; i < m; i++) {\n      int ai, bi;\n      string w;\n      cin >> ai >> bi >> w;\n      ai--, bi--;\n      int wi = (w == \"x\") ? -1 : atoi(w.c_str());\n      nbrs[ai].push_back(pii(bi, wi));\n      nbrs[bi].push_back(pii(ai, wi));\n      if (wi < 0) bn++;\n    }\n\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j <= bn; j++) dists[i][j] = LINF;\n    dists[t][0] = 0;\n\n    priority_queue<Stat> q;\n    q.push(Stat(0, t, 0));\n\n    while (! q.empty()) {\n      Stat u = q.top(); q.pop();\n      if (dists[u.i][u.b] != u.d) continue;\n\n      vpii &nbru = nbrs[u.i];\n      for (vpii::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n\tint &vi = vit->first, &vw = vit->second;\n\tint vb = u.b;\n\tll vd = u.d;\n\tif (vw < 0) vb++;\n\telse vd += vw;\n\tif (dists[vi][vb] > vd) {\n\t  dists[vi][vb] = vd;\n\t  q.push(Stat(vd, vi, vb));\n\t}\n      }\n    }\n\n    ll lw = 0, uw = 1000000000;\n    for (int i = 0; i < 60; i++) {\n      ll w0 = (lw * 2 + uw) / 3, w1 = (lw + uw * 2) / 3;\n      ll df0 = mindist(dists[s0], bn, w0) - mindist(dists[s1], bn, w0);\n      ll df1 = mindist(dists[s0], bn, w1) - mindist(dists[s1], bn, w1);\n      if (df0 < 0) df0 = -df0;\n      if (df1 < 0) df1 = -df1;\n      if (df0 > df1) lw = w0;\n      else uw = w1;\n    }\n\n    ll mindf = LINF;\n    for (ll w = lw; w <= uw; w++) {\n      ll df = mindist(dists[s0], bn, w) - mindist(dists[s1], bn, w);\n      if (df < 0) df = -df;\n      if (mindf > df) mindf = df;\n      //printf(\"w=%lld, df=%lld\\n\", w, df);\n    }\n    printf(\"%lld\\n\", mindf);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint N, M, S1, S2, T;\nvector< vector<edge> > rgraph;\n\nstruct State {\n  int now, cost, magic;\n  State(){}\n  State(int now, int cost, int magic):now(now), cost(cost), magic(magic){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<vint> mincost;\n\nvoid rdijkstra() {\n  resz(mincost, 101, vint(N, inf));\n  priority_queue<State> que;\n  mincost[0][T] = 0;\n  que.emplace(T, 0, 0);\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(mincost[s.magic][s.now] < s.cost) continue;\n    for(edge& e : rgraph[s.now]) {\n      if(e.cost >= 0) {\n\tif(e.cost + s.cost < mincost[s.magic][e.to]) {\n\t  mincost[s.magic][e.to] = e.cost + s.cost;\n\t  que.emplace(e.to, e.cost + s.cost, s.magic);\n\t}\n      } else if(s.magic+1 < 101) {\n\tif(s.cost < mincost[s.magic+1][e.to]) {\n\t  mincost[s.magic+1][e.to] = s.cost;\n\t  que.emplace(e.to, s.cost, s.magic+1);\n\t}\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N+M+S1+S2+T) {\n    S1--, S2--, T--;\n    resz(rgraph, N);\n    rep(i, M) {\n      int s, t; string ws;\n      cin >> s >> t >> ws;\n      s--, t--;\n      if(ws == \"x\") {\n\trgraph[s].emplace_back(t, -1);\n\trgraph[t].emplace_back(s, -1);\n      } else {\n\tint w = stoi(ws);\n\trgraph[s].emplace_back(t, w);\n\trgraph[t].emplace_back(s, w);\n      }\n    }\n    rdijkstra();\n\n    vector<double> crossX;\n    crossX.emplace_back(0);\n    rep(i, 101) rep(j, 101) {\n      if(i == j) continue;\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      crossX.emplace_back(((double)mincost[j][S2]-mincost[i][S1])/(i-j));\n      crossX.emplace_back(((double)mincost[i][S1]-mincost[j][S2])/(j-i));\n    }\n\n    int ans = inf;\n    for(double x : crossX) {\n      int ceil_x = ceil(x);\n      int floor_x = floor(x);\n      if(ceil_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  if(mincost[i][S1] != inf) chmin(c, mincost[i][S1]+ceil_x*i);\n\t  if(mincost[i][S2] != inf) chmin(d, mincost[i][S2]+ceil_x*i);\n\t}\n\tif(c != inf && d != inf) chmin(ans, llabs(c - d));\n      }\n      if(floor_x >= 0) {\n\tint c = inf, d = inf;\n\trep(i, 101) {\n\t  if(mincost[i][S1] != inf) chmin(c, mincost[i][S1]+floor_x*i);\n\t  if(mincost[i][S2] != inf) chmin(d, mincost[i][S2]+floor_x*i);\n\t}\n\tif(c != inf && d != inf) chmin(ans, llabs(c - d));\n      }\n    }\n    assert(ans != inf);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tif(curu==100)continue;\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(dist[0][t][i]>=INF)return INF;\n\tif(dist[1][t][j]>=INF)return INF;\n\tif(i==j){\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tll va=INF;\n\t\tll vb=INF;\n\t\tfor(ll l=0;l<n;l++){\n\t\t\tva=min(va,dist[0][t][l]+l*k);\n\t\t\tvb=min(vb,dist[1][t][l]+l*k);\n\t\t}\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[j][S1]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(lis.back()+1);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nvector<P> G[1111];\nint dp1[111][1111];\nint dp2[111][1111];\nint INF=1LL<<45LL;\nstruct st{\n  int x,v,d;\n  st(){}\n  st(int x,int v,int d):x(x),v(v),d(d){}\n  bool operator<(const st a)const{\n    return d>a.d;\n  }\n};\nint n,m,s1,s2,t;\nint ans;\nint calc1(int i,int x){\n  return dp1[i][t]+i*x;\n}\nint calc2(int i,int x){\n  return dp2[i][t]+i*x;\n}\nint check1(int x){\n  int res=-1;\n  for(int i=0;i<111;i++){\n    if(dp1[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc1(i,x)<calc1(res,x)) res=i;\n  }\n  return res;\n}\nint check2(int x){\n  int res=0;\n  for(int i=0;i<111;i++){\n    if(dp2[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc2(i,x)<calc2(res,x)) res=i;\n  }\n  return res;\n}\nint calc3(int x){\n  return calc1(check1(x),x)-calc2(check2(x),x);\n}\nsigned main(){\n  while(cin>>n>>m>>s1>>s2>>t,n){\n    s1--;s2--;t--;\n    for(int i=0;i<1111;i++) G[i].clear(); \n    for(int i=0;i<m;i++){\n      int a,b,w;\n      string s;\n      cin>>a>>b>>s;\n      if(s==\"x\") w=-1;\n      else w=stoll(s);\n      a--;b--;\n      G[a].push_back(P(b,w));\n      G[b].push_back(P(a,w));\n    }\n    for(int i=0;i<111;i++){\n      fill(dp1[i],dp1[i]+1111,INF);\n      fill(dp2[i],dp2[i]+1111,INF);\n    }\n    priority_queue<st> q;\n    q.emplace(0,s1,0);\n    dp1[0][s1]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp1[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      //cout<<p.x<<\" \"<<p.v<<\" \"<<p.d<<endl;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp1[nx][nv]<=nd) continue;\n\tdp1[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //puts(\"OK\");\n    q.emplace(0,s2,0);\n    dp2[0][s2]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp2[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp2[nx][nv]<=nd) continue;\n\tdp2[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //for(int i=0;i<11;i++) cout<<i<<\":dp1:\"<<dp1[i][t]<<endl;\n    //for(int i=0;i<11;i++) cout<<i<<\":dp2:\"<<dp2[i][t]<<endl;\n    \n    vector<int> b;\n    b.push_back(0);\n    b.push_back(INF);\n    int L=0;\n    while(check1(L)!=check1(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check1(L)!=check1(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    L=0;\n    while(check2(L)!=check2(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check2(L)!=check2(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    sort(b.begin(),b.end());\n    b.erase(unique(b.begin(),b.end()),b.end());\n    ans=INF;\n    for(int i=0;i<n;i++){\n      ans=min(ans,abs(calc3(b[i])));\n      if(i==n-1) break;\n      int x=b[i],y=b[i+1]-1;\n      if(x==y) continue;\n      if(calc3(x)*calc3(y)<0){\n\tint d=calc3(x+1)-calc3(x);\n\tif(d==0) continue;\n\tint tmp=abs(calc3(x));\n\tans=min(ans,abs(tmp-(tmp/d*d)));\n\tans=min(ans,abs(((tmp/d+1)*d)-tmp));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\twhile(1){\n\t\tll n,m,s[2],t;\n\t\tll a[2002],b[2002];\n\t\tll w[2002];\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[0],&s[1],&t);\n\t\tif(n==0)return 0;\n\t\trep(i,m){\n\t\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tif(in == \"x\")w[i] = INF;\n\t\t\telse {\n\t\t\t\tw[i] = 0;\n\t\t\t\trep(j,in.size()){\n\t\t\t\t\tw[i] *= 10;\n\t\t\t\t\tw[i] += in[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> G[2002];\n\t\trep(i,m){\n\t\t\tG[a[i]].pb(P(b[i],w[i]));\n\t\t\tG[b[i]].pb(P(a[i],w[i]));\n\t\t}\n\t\t\n\t\tstatic ll cost[1002][102];\n\t\tstatic bool used[1002][102];\n\t\tstatic priority_queue<P1,vector<P1>,greater<P1>> que;\n\t\trep(i,1002)rep(j,102){\n\t\t\tcost[i][j] = INF;\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tcost[t][0] = 0;\n\t\tque.push(mp1(0,t,0));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.top(); que.pop();\n\t\t\tif(used[p.sc.fr][p.sc.sc])continue;\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t\trep(i,G[p.sc.fr].size()){\n\t\t\t\tP ed = G[p.sc.fr][i];\n\t\t\t\tif(ed.sc == INF){\n\t\t\t\t\tif(p.sc.sc < 100){\n\t\t\t\t\t\tif(cost[ed.fr][p.sc.sc+1] > p.fr){\n\t\t\t\t\t\t\tcost[ed.fr][p.sc.sc+1] = p.fr;\n\t\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc+1],ed.fr,p.sc.sc+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cost[ed.fr][p.sc.sc] > p.fr+ed.sc){\n\t\t\t\t\t\tcost[ed.fr][p.sc.sc] = p.fr+ed.sc;\n\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc],ed.fr,p.sc.sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> vec[2];\n\t\trep(i,2){\n\t\t\trep1(j,100){\n\t\t\t\tcost[s[i]][j] = min ( cost[s[i]][j] , cost[s[i]][j-1] );\n\t\t\t}\n\t\t\trep(j,101){\n\t\t\t\twhile(vec[i].size() >= 2){\n\t\t\t\t\tP p=vec[i][vec[i].size()-2];\n\t\t\t\t\tP q=vec[i][vec[i].size()-1];\n\t\t\t\t\tif((p.fr-q.fr)/(q.sc-p.sc) < (q.fr-cost[s[i]][j])/(j-q.sc)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse vec[i].pop_back();\n\t\t\t\t}\n\t\t\t\tvec[i].pb(P(cost[s[i]][j],j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> x;\n\t\tx.pb(1);\n\t\trep(i,2){\n\t\t\tfor(int j = 0 ; j+1 < vec[i].size() ; j ++){\n\t\t\t\tll x_ = (vec[i][j].fr-vec[i][j+1].fr)/(vec[i][j+1].sc-vec[i][j].sc);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\trep(i,101)rep(j,101){\n\t\t\tif(i==j)continue;\n\t\t\tif(i>j && cost[s[0]][i]<cost[s[1]][j]){\n\t\t\t\tll x_ = (-cost[s[0]][i]+cost[s[1]][j])/(i-j);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t\tif(i<j && cost[s[0]][i]>cost[s[1]][j]){\n\t\t\t\tll x_ = (cost[s[0]][i]-cost[s[1]][j])/(j-i);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,4){\n\t\t\tprintf(\"%lld %lld\\n\",cost[s[0]][i],cost[s[1]][i]);\n\t\t}*/\n\t\t\n\t\tll ret = INF;\n\t\trep(i,x.size()){\n\t\t\tll dist[2] = {INF,INF};\n\t\t\trep(j,2){\n\t\t\t\trep(k,101){\n\t\t\t\t\tdist[j] = min ( dist[j] , k*x[i]+cost[s[j]][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[0] << dist[1] << endl;\n\t\t\tret = min ( ret , abs(dist[0]-dist[1]) );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t//\tif (N != 103)continue;\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tlong long int al = l;\n\t\t\tlong long int ar = r;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\t/*if (ans == 2) {\n\t\t\tfor (auto e : edges) {\n\t\t\t\tint a = e.size();\n\t\t\t\tcout << a << endl;\n\t\t\t}\n\t\t}*/\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 60;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    vector< edge > G[1000];\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n\n    for(int i = -10; i <= 10; i++) {\n      for(auto &cost : latte) ret = min(ret, get(cost + i));\n    }\n    // zinsei\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define eps 1e-9\n#define ALL(x) x.begin(),x.end()\n#define INS(x) inserter(x,x.begin())\n#define rep(i,j,k) for(int i=j;i<=k;i++)\n#define MAXN 1005\n#define MAXM 40005\n#define INF 1e18\n#define PB push_back\n#define MP make_pair\n#define X first\n#define Y second\n#define clr(x,y) memset(x,y,sizeof(x));\nusing namespace std;\ntypedef long long LL;\nLL i,j,k,n,m,x,y,T,ans,big,cas,num,len;\nbool flag;\nLL edge,head[1005],mag,s[3],t,mi[3],w;\nchar ss[20];\ndouble v[100005];\nstruct edgenode\n{\n\tLL to,next,w;\n} G[40005];\n\nvoid add_edge(LL x,LL y,LL w)\n{\n\tG[edge].to=y;\n\tG[edge].w=w;\n\tG[edge].next=head[x];\n\thead[x]=edge++;\n}\n\n\nLL dis[1005][105],vis[1005][105];\nvoid SPFA(LL st)\n{\n\tLL tim,u,v,ad,w;\n\tmemset(dis,-1,sizeof(dis));\n\tmemset(vis,0,sizeof(vis));\n\tqueue<pair<LL,LL> > q;\n\twhile (!q.empty()) q.pop();\n\tq.push(MP(st,0));\n\tdis[st][0]=0;vis[st][0]=1;\n\twhile (!q.empty())\n\t{\n\t\tu=q.front().X;\n\t\ttim=q.front().Y;\n\t\tq.pop();\n\t\tvis[u][tim]=false;\n\t\tfor (i=head[u];i!=-1;i=G[i].next)\n\t\t{\n\t\t\tv=G[i].to;\n\t\t\tw=G[i].w; \n\t\t\tif (w==-1) ad=1,w=0; else ad=0;\n\t\t\t\n\t\t\tif (tim+ad<=mag && (dis[v][tim+ad]==-1 || dis[v][tim+ad]>dis[u][tim]+w))\n\t\t\t{\n\t\t\t\tdis[v][tim+ad]=dis[u][tim]+w;\n\t\t\t\tif (!vis[v][tim+ad])\n\t\t\t\t{\n\t\t\t\t\tvis[v][tim+ad]=true;\n\t\t\t\t\tq.push(MP(v,tim+ad));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\twhile (scanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[1],&s[2],&t),n+m)\n\t{\n\t\tmemset(head,-1,sizeof(head));\n\t\tedge=0;mag=0;ans=INF;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%lld%lld\",&x,&y);\n\t\t\tscanf(\"%s\",ss);\n\t\t\tif (strcmp(ss,\"x\")==0)\n\t\t\t{\n\t\t\t\tw=-1;\n\t\t\t\tmag++;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tsscanf(ss,\"%lld\",&w);\n\t\t\t}\n\t\t\tadd_edge(x,y,w);\n\t\t\tadd_edge(y,x,w);\n\t\t}\n\t\tSPFA(t);\n\t\tnum=0;\n\t\tv[num++]=0;\n\t\t\n\t\tfor (i=1;i<=2;i++)\n\t\t{\n\t\t\tfor (j=0;j<=mag;j++)\n\t\t\t{\n\t\t\t\tx=dis[s[i]][j];\n\t\t\t\tif (x==-1) continue;\n\t\t\t\tfor (k=j+1;k<=mag;k++)\n\t\t\t\t{\n\t\t\t\t\ty=dis[s[i]][k];\n\t\t\t\t\tif (y==-1) continue;\n\t\t\t\t\tdouble a=(x-y)*1.0/(k-j);\n\t\t\t\t \tif (a>0) v[num++]=a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (j=0;j<=mag;j++)\n\t\t{\n\t\t\tx=dis[s[1]][j];\n\t\t\tif (x==-1) continue;\n\t\t\tfor (k=0;k<=mag;k++)\n\t\t\t{\n\t\t\t\tif (k==j) continue;\n\t\t\t\ty=dis[s[2]][k];\n\t\t\t\tif (y==-1) continue;\n\t\t\t\tdouble a=(x-y)*1.0/(k-j);\n\t\t\t \tif (a>0) v[num++]=a;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tfor (i=0;i<num;i++)\n\t\t{\n\t\t\tfor (j=1;j<=2;j++)\n\t\t\t{\n\t\t\t\tmi[j]=INF;\n\t\t\t\tfor (k=0;k<=mag;k++)\n\t\t\t\t{\n\t\t\t\t\tif (dis[s[j]][k]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmi[j]=min(mi[j],dis[s[j]][k]+k*(LL)(v[i]+eps));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,abs(mi[1]-mi[2]));\t\n\t\t} \n\t\tfor (i=0;i<num;i++)\n\t\t{\n\t\t\tfor (j=1;j<=2;j++)\n\t\t\t{\n\t\t\t\tmi[j]=INF;\n\t\t\t\tfor (k=0;k<=mag;k++)\n\t\t\t\t{\n\t\t\t\t\tif (dis[s[j]][k]!=-1)\n\t\t\t\t\t{\n\t\t\t\t\t\tmi[j]=min(mi[j],dis[s[j]][k]+k*(LL)(v[i]+eps+1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans=min(ans,abs(mi[1]-mi[2]));\t\n\t\t} \n\t\tprintf(\"%lld\\n\",ans); \n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge{\n  ll to;\n  ll cost;\n};\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> PP;\n\nll N,M,A,B,T;\nvector<edge> G[1000];\nll d[1000][101];\nll INF=(1LL<<60);\n\nmap<ll,bool> used;\nll check(ll X){\n  if(used[X])return INF;\n  used[X]=true;\n\n  \n  if(X<0)return INF;\n  \n  ll minA=INF;\n  ll minB=INF;\n  for(int i=0;i<=100;i++){\n    if(d[A][i]<INF){\n      ll valueA=d[A][i]+i*X;\n      minA=min(minA,valueA);\n    }\n    if(d[B][i]<INF){\n      ll valueB=d[B][i]+i*X;\n      minB=min(minB,valueB);\n    }\n  }\n\n  //  cout<<N<<' '<<X<<' '<<minA<<' '<<minB<<endl;\n  return abs(minA-minB);\n}\n\nll getCross(int A,int I,int B,int J){\n  if(I==J)return 0;\n  ll v=abs( d[A][I]-d[B][J] );\n  ll w=abs( I-J );\n  return v/w;\n}\n\nll solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<=100;j++)\n      d[i][j]=INF;\n  priority_queue< PP , vector<PP> , greater<PP> > Q;\n  d[T][0]=0;\n  Q.push(PP(0,P(T,0)));\n  while(!Q.empty()){\n    PP pp=Q.top();Q.pop();\n    ll cost=pp.first;\n    ll pos=pp.second.first;\n    ll cnt=pp.second.second;\n    if( cost > d[pos][cnt] )continue;\n    \n    \n    for(int i=0;i<(int)G[pos].size();i++){\n      edge e=G[pos][i];\n      ll ncost=cost;\n      ll ncnt=cnt;\n      if(e.cost==-1)ncnt++;\n      else ncost+=e.cost;\n\n      if(ncnt>100)continue;\n      \n      if( d[e.to][ncnt] > ncost ){\n        d[e.to][ncnt]=ncost;\n        Q.push( PP(ncost,P(e.to,ncnt)) );\n      }\n    }\n  }\n\n  ll ans=INF;\n  for(int i=0;i<=100;i++){\n    if(d[A][i]==INF)continue;\n    for(int j=0;j<=100;j++){\n      if(d[B][j]==INF)continue;\n      ll y=getCross(A,i,B,j);\n      \n      ans=min(ans, check(y-1) );\n      ans=min(ans, check(y) );\n      ans=min(ans, check(y+1) );\n\n      y=getCross(A,i,A,j);\n      ans=min(ans, check(y-1) );\n      ans=min(ans, check(y) );\n      ans=min(ans, check(y+1) );\n\n      y=getCross(B,i,B,j);\n      ans=min(ans, check(y-1) );\n      ans=min(ans, check(y) );\n      ans=min(ans, check(y+1) );\n    }\n  }\n\n  return ans;\n}\n\nvoid init(){\n  used.clear();\n  for(int i=0;i<1000;i++){\n    G[i].clear();\n  }\n}\n\nint main(){\n  while(1){\n    cin>>N>>M>>A>>B>>T;\n    if(N==0&&M==0&&A==0&&B==0&&T==0)break;\n    A--,B--,T--;\n      \n    init();\n    for(int i=0;i<M;i++){\n      ll a,b,c;\n      string str;\n      cin>>a>>b>>str;\n      a--,b--;\n      if(str==\"x\"){\n        c=-1;\n      }else{\n        stringstream ss;\n        ss<<str;\n        ss>>c;\n      }\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T> class CHT\n{\nprivate:\n    using ptt = pair<T, T>;\n    bool check(ptt l1, ptt l2, ptt l3){\n        return (l2.first-l1.first)*(l3.second-l2.second)>=(l2.second-l1.second)*(l3.first-l2.first);\n    }\n    T f(int i, T x){\n        return lines[i].first * x + lines[i].second;\n    }\npublic:\n    vector<ptt> lines;\n    int head;\n    CHT(): head(0){};\n    void add(T a, T b){\n        ptt line(a, b);\n        while((int)lines.size() - head >= 2 && check(*(lines.end()-2), lines.back(), line)){\n            lines.pop_back();\n        }\n        lines.emplace_back(line);\n    }\n    T get(T x){\n        int low = -1, high = lines.size() - 1;\n        while (high - low > 1) {\n        \tint mid = (high + low) / 2;\n            if(f(mid, x) >= f(mid+1, x)){\n                low = mid;\n            }else{\n                high = mid;\n            }\n        }\n        return f(high, x);\n    }\n};\n\nCHT<ll> calc(vector<vector<pair<int,ll> > >g,int s,int t){\n    int n = g.size();\n    vector<vector<ll> > dst(n,vector<ll>(101,1LL<<60));\n    priority_queue<pair<ll,pair<int,int> >,vector<pair<ll,pair<int,int> >>,greater<pair<ll,pair<int,int> >>  > pq;\n    pq.push(MP(0LL,MP(s,0)));\n    dst[s][0] = 0;\n    while(!pq.empty()){\n        auto xx = pq.top();\n        pq.pop();\n        int id = xx.second.first;\n        int cnt = xx.second.second;\n        ll d = xx.first;\n        if(dst[id][cnt]!=d)continue;\n        for(auto x:g[id]){\n            int nxt = x.first;\n            if(x.second == -1){\n                if(cnt<=99){\n                    if(dst[nxt][cnt+1]> d ){\n                        dst[nxt][cnt+1] = d;\n                        pq.push(MP(d,MP(nxt,cnt+1)));\n                    }\n                }\n            }else{\n                if(dst[nxt][cnt]> d + x.second ){\n                    dst[nxt][cnt] = d + x.second;\n                    pq.push(MP(d+x.second,MP(nxt,cnt)));\n                }\n            }\n        }\n    }\n    CHT<ll> cht;\n    rep(i,101){\n        if(dst[t][100-i]!=(1LL<<60))cht.add(100-i,dst[t][100-i]);\n    }\n    return cht;\n} \n\nvoid addx(vector<pair<ll,ll> > &lines,vector<ll> &x){\n    int n = lines.size();\n    for(int i=0;i<n-1;i++){\n        ll a = lines[i].first;\n        ll b = lines[i].second;\n        ll c = lines[i+1].first;\n        ll d = lines[i+1].second;\n        if(d-b<0)continue;\n        x.push_back((d-b)/(a-c)-1);\n        x.push_back((d-b)/(a-c));\n        x.push_back((d-b)/(a-c) + 1);\n    }\n}\n\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n,m,p,q,t;\n        cin >> n >> m >> p >> q >> t;\n        if(n==0)break;\n        p--;q--;t--;\n        vector<vector<pair<int,ll> > >g(n);\n        rep(i,m){\n            int a,b;\n            cin >> a >> b;\n            a--;b--;\n            string c;\n            cin >> c;\n            if(c==\"x\"){\n                g[a].push_back(MP(b,-1));\n                g[b].push_back(MP(a,-1));\n            }else{\n                ll k = stoll(c);\n                g[a].push_back(MP(b,k));\n                g[b].push_back(MP(a,k));\n            }\n        }\n        CHT<ll> c1 = calc(g,p,t);\n        CHT<ll> c2 = calc(g,q,t);\n        vector<ll> x;\n        x.push_back(0LL);\n        addx(c1.lines,x);\n        addx(c2.lines,x);\n        x.push_back(1LL<<50);\n        sort(all(x));\n        x.erase(unique(all(x)),x.end());\n        int mm = x.size();\n        ll mi = 1LL<<60;\n        rep(i,mm-1){\n            if(x[i]<0)continue;\n            if(c1.get(x[i]) >= c2.get(x[i]) && c1.get(x[i+1]) <= c2.get(x[i+1]) ){\n                ll lo = x[i];\n                ll hi = x[i+1];\n                while(hi-lo>1){\n                    ll mid = (lo+hi)/2;\n                    if(c1.get(mid) >= c2.get(mid)){\n                        lo = mid;\n                    }else{\n                        hi = mid;\n                    }\n                }\n                chmin(mi,abs(c1.get(lo)-c2.get(lo)));\n                chmin(mi,abs(c1.get(hi)-c2.get(hi)));\n            \n            }\n            if(c1.get(x[i]) <= c2.get(x[i]) && c1.get(x[i+1]) >= c2.get(x[i+1]) ){\n                ll lo = x[i];\n                ll hi = x[i+1];\n                while(hi-lo>1){\n                    ll mid = (lo+hi)/2;\n                    if(c1.get(mid) <= c2.get(mid)){\n                        lo = mid;\n                    }else{\n                        hi = mid;\n                    }\n                }\n                chmin(mi,abs(c1.get(lo)-c2.get(lo)));\n                chmin(mi,abs(c1.get(hi)-c2.get(hi)));\n            \n            }else{\n                chmin(mi,abs(c1.get(x[i])-c2.get(x[i])));\n                chmin(mi,abs(c1.get(x[i+1])-c2.get(x[i+1])));\n            }\n        }\n        \n        rep(i,mm){\n            if(x[i]<0)continue;\n            chmin(mi,abs(c1.get(x[i])-c2.get(x[i])));\n        }\n        cout << mi << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint N, M, S1, S2, T;\nvector< vector<edge> > rgraph;\n\nstruct State {\n  int now, cost, magic, prev;\n  State(){}\n  State(int now, int cost, int magic, int prev):now(now), cost(cost), magic(magic), prev(prev){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<vint> mincost;\n\nvoid rdijkstra() {\n  resz(mincost, 101, vint(N, inf));\n  priority_queue<State> que;\n  mincost[0][T] = 0;\n  que.emplace(T, 0, 0, -1);\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(mincost[s.magic][s.now] < s.cost) continue;\n    //cout<<s.now<<\" \"<<s.cost<<\" \"<<rgraph[s.now].size()<<endl;\n    for(edge& e : rgraph[s.now]) {\n      if(e.to == s.prev) continue;\n      if(e.cost >= 0) {\n\tif(e.cost + s.cost < mincost[s.magic][e.to]) {\n\t  mincost[s.magic][e.to] = e.cost + s.cost;\n\t  que.emplace(e.to, e.cost + s.cost, s.magic, s.now);\n\t}\n      } else if(s.magic+1 < 101) {\n\tif(s.cost < mincost[s.magic+1][e.to]) {\n\t  mincost[s.magic+1][e.to] = s.cost;\n\t  que.emplace(e.to, s.cost, s.magic+1, s.now);\n\t}\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N+M+S1+S2+T) {\n    S1--, S2--, T--;\n    resz(rgraph, N);\n    rep(i, M) {\n      int s, t; string ws;\n      cin >> s >> t >> ws;\n      s--, t--;\n      if(ws == \"x\") {\n\trgraph[s].emplace_back(t, -1);\n\trgraph[t].emplace_back(s, -1);\n      } else {\n\tint w = stoi(ws);\n\trgraph[s].emplace_back(t, w);\n\trgraph[t].emplace_back(s, w);\n      }\n    }\n    rdijkstra();\n\n    vector< tuple<double, int, int> > crossX;\n    rep(i, 101) rep(j, 101) {\n      if(i == j) continue;\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      //cout<<mincost[i][S1]<<\" \"<<mincost[j][S2]<<endl;\n      double x = (mincost[j][S2]-mincost[i][S1])/(i-j);\n      crossX.emplace_back(x, i, j);\n    }\n\n    int ans = inf;\n    rep(i, 101) rep(j, 101) {\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      chmin(ans, llabs(mincost[i][S1]-mincost[j][S2]));\n    }\n\n    for(tuple<double, int, int> tup : crossX) {\n      double x;\n      int i, j;\n      tie(x, i, j) = tup;\n      int ceil_x = ceil(x);\n      int floor_x = floor(x);\n      if(ceil_x >= 0) {\n\tchmin(ans, llabs(mincost[i][S1]+ceil_x*i - mincost[j][S2]-ceil_x*j));\n      }\n      if(floor_x >= 0) {\n\tchmin(ans, llabs(mincost[i][S1]+floor_x*i - mincost[j][S2]-floor_x*j));\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n#define HUGE_NUM 9999999999999999\n\nenum Type{\n\tA, //S_1\n\tB, //S_2\n};\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost,bool arg_is_magical){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tis_magical = arg_is_magical;\n\t}\n\tint to;\n\tll cost;\n\tbool is_magical;\n};\n\nstruct State{\n\tState(){\n\t\tnode_id = 0;\n\t\tnum_passed_magical = 0;\n\t\tsum_cost = 0;\n\t}\n\tState(int arg_node_id,int arg_num_passed_magical,ll arg_sum_cost){\n\n\t\tnode_id = arg_node_id;\n\t\tnum_passed_magical = arg_num_passed_magical;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,num_passed_magical;\n\tll sum_cost;\n};\n\nint N,M,S_1,S_2,T;\nint num_magical;\nvector<Edge> G[NUM];\nll min_dist[2][105][NUM];\n\nll getNUM(char buf[20]){\n\n\tll ret = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tret = 10*ret+(buf[i]-'0');\n\t}\n\n\treturn ret;\n}\n\nll calc_len(ll slope_1,ll num_1,ll slope_2,ll num_2){\n\n\treturn (ll)((double)(num_2-num_1)/(double)(slope_1-slope_2));\n}\n\nll get_min_cost(Type type,ll tmp_len){\n\n\tll ret = HUGE_NUM;\n\n\tfor(ll i = 0; i <= num_magical; i++){\n\n\t\tret = min(ret,min_dist[type][i][T]+i*tmp_len);\n\t}\n\treturn ret;\n}\n\nvoid dijkstra(Type type,int start){\n\n\tfor(int i = 0; i <= num_magical; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tmin_dist[type][i][k] = HUGE_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<State> Q;\n\n\tmin_dist[type][0][start] = 0;\n\tQ.push(State(start,0,0));\n\n\tint next_node,next_num_pass;\n\tll next_cost;\n\tState state;\n\n\twhile(!Q.empty()){\n\n\t\tstate = Q.top();\n\t\tQ.pop();\n\n\t\tif(state.sum_cost > min_dist[type][state.num_passed_magical][state.node_id]){\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < G[state.node_id].size(); i++){\n\n\t\t\tnext_node = G[state.node_id][i].to;\n\t\t\tnext_cost = state.sum_cost+G[state.node_id][i].cost;\n\t\t\tnext_num_pass = state.num_passed_magical;\n\n\t\t\tif(G[state.node_id][i].is_magical){\n\t\t\t\tnext_num_pass++;\n\t\t\t}\n\n\t\t\tif(min_dist[type][next_num_pass][next_node] > next_cost){\n\n\t\t\t\tmin_dist[type][next_num_pass][next_node] = next_cost;\n\t\t\t\tQ.push(State(next_node,next_num_pass,next_cost));\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t}\n\n\tS_1--;\n\tS_2--;\n\tT--;\n\n\tchar buf[20];\n\n\tint from,to;\n\tll cost;\n\tnum_magical = 0;\n\n\tfor(int loop = 0; loop < M; loop++){\n\n\t\tscanf(\"%d %d %s\",&from,&to,buf);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(buf[0] != 'x'){\n\n\t\t\tcost = getNUM(buf);\n\t\t\tG[from].push_back(Edge(to,cost,false));\n\t\t\tG[to].push_back(Edge(from,cost,false));\n\n\t\t}else{\n\n\t\t\tnum_magical++;\n\n\t\t\tcost = 0;\n\t\t\tG[from].push_back(Edge(to,cost,true));\n\t\t\tG[to].push_back(Edge(from,cost,true));\n\t\t}\n\t}\n\n\tdijkstra(A,S_1);\n\tdijkstra(B,S_2);\n\n\tvector<ll> V;\n\tll len[3];\n\n\tfor(ll i = 0; i <= num_magical; i++){\n\t\tfor(ll k = 0; k <= num_magical; k++){\n\n\t\t\tif(k == i)continue;\n\n\t\t\tfor(int a = 0; a < 3; a++)len[a] = 0;\n\n\t\t\tif(min_dist[A][i][T] != BIG_NUM && min_dist[A][k][T] != BIG_NUM)len[0] = calc_len(i,min_dist[A][i][T],k,min_dist[A][k][T]);\n\t\t\tif(min_dist[A][i][T] != BIG_NUM && min_dist[B][k][T] != BIG_NUM)len[1] = calc_len(i,min_dist[A][i][T],k,min_dist[B][k][T]);\n\t\t\tif(min_dist[B][i][T] != BIG_NUM && min_dist[B][k][T] != BIG_NUM)len[2] = calc_len(i,min_dist[B][i][T],k,min_dist[B][k][T]);\n\n\t\t\tfor(ll diff = -1; diff <= 1; diff++){\n\t\t\t\tfor(int a = 0; a < 3; a++){\n\t\t\t\t\tV.push_back(len[a]+diff);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\tll ans = abs(min_dist[A][0][T]-min_dist[B][0][T]);\n\tll tmp_len;\n\tll A_cost,B_cost;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\ttmp_len = V[i];\n\t\tif(tmp_len < 0)continue;\n\n\t\tA_cost = get_min_cost(A,tmp_len);\n\t\tB_cost = get_min_cost(B,tmp_len);\n\n\t\tans = min(ans,abs(A_cost-B_cost));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&S_1,&S_2,&T);\n\t\tif(N == 0 && M == 0 && S_1 == 0 && S_2 == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(i==j){\n\t\tif(dist[0][t][i]>=INF)return INF;\n\t\tif(dist[1][t][j]>=INF)return INF;\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tvector<PPP> vec;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tvec.push_back(PPP(dist[0][t][l]+l*k,0));\n\t\t\tvec.push_back(PPP(dist[1][t][l]+l*k,1));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\tfor(int l=0;l<(int)vec.size()-1;l++){\n\t\t\tif(vec[l].first>=INF)continue;\n\t\t\tif(vec[l].second!=vec[l+1].second){\n\t\t\t\tans=min(ans,vec[l+1].first-vec[l].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint memo1[1100][110];\nint memo2[1100][110];\nvector<pa2> G[1100];\npriority_queue<pa3,vector<pa3>,greater<pa3>> pq;\n\nint sa(int r,int t){\n\tif(r<0) return inf*10000ll;\n\tint e1=inf*10000ll,e2=inf*10000ll;\n\tfor(int i=0;i<105;i++){\n\t\te1=min(e1,i*r+memo1[t][i]);\n\t}\n\tfor(int i=0;i<105;i++){\n\t\te2=min(e2,i*r+memo2[t][i]);\n\t}\n\t\n\treturn abs(e1-e2);\n\t\n}\n\n\n   signed main(){\nint m,s1,s2,t,n;   \t\n   \twhile(1){\n   \t\tcin>>n>>m>>s1>>s2>>t;\n  \n   \t\tif(n==0) return 0;\n   \t\tfor(int i=0;i<=1010;i++)G[i].clear();\n   \t\tfor(int i=0;i<m;i++){\n   \t\t\tint y,yy;\n   \t\tcin>>y>>yy;\n   \t\t\tstring s;\n   \t\t\tcin>>s;\n   \t\t\tif(s[0]=='x'){\n   \t\t\t\t\tG[y].pb({yy,-1});\n   \t\t\t\tG[yy].pb({y,-1});\n   \t\t\t}\n   \t\t\telse{\n   \t\t\t\tint r=stoi(s);\n   \t\t\t\t\tG[y].pb({yy,r});\n   \t\t\t\tG[yy].pb({y,r});\n   \t\t\t}\n   \t\t\n   \t\t}\n   \t\tint in=inf*1000000ll;\n   \t\tfor(int i=0;i<1100;i++)for(int j=0;j<110;j++)memo1[i][j]=in,memo2[i][j]=in;\n   \t\twhile(pq.size()>0)pq.pop();\n   \t\t\tpq.push({0,0,s1});\n   \t\t// kyori kaisuu basho\n   \t\twhile(pq.size()){\n   \t\t\tpa3 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(z.y>105) continue;\n   \t\t\tif(memo1[z.z][z.y]<in) continue;\n   \t\t\tmemo1[z.z][z.y]=z.x;\n   \t\t\t\n   \t\t\tfor(auto r:G[z.z]){\n   \t\t\t\tif(r.y>=0){\n   \t\t\t\t\t\tpq.push({z.x+r.y,z.y,r.x});\n   \t\t\t\t}else{\n   \t\t\t\tpq.push({z.x,z.y+1,r.x});\n   \t\t\t\t}\n   \t\t\t\t\n   \t\t\t}\n   \t\t}\n   \t\t\n   \t\twhile(pq.size()>0)pq.pop();\n   \t\t\tpq.push({0,0,s2});\n   \t\t// kyori kaisuu basho\n   \t\twhile(pq.size()){\n   \t\t\tpa3 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(z.y>105) continue;\n   \t\t\tif(memo2[z.z][z.y]<in) continue;\n   \t\t\tmemo2[z.z][z.y]=z.x;\n   \t\t\t\n   \t\t\tfor(auto r:G[z.z]){\n   \t\t\t\tif(r.y>=0){\n   \t\t\t\t\t\tpq.push({z.x+r.y,z.y,r.x});\n   \t\t\t\t}else{\n   \t\t\t\tpq.push({z.x,z.y+1,r.x});\n   \t\t\t\t}\n   \t\t\t\t\n   \t\t\t}\n   \t\t}\n   \t\tint ans=inf*10000ll;\n   \t\tans=min(ans,sa(0,t));\n   \t\tfor(int i=0;i<105;i++)for(int j=i+1;j<105;j++){\n   \t\t\tint r=-(memo1[t][i]-memo1[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t\t r=-(memo2[t][i]-memo2[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t}\n   \t\t\n   \t\tfor(int i=0;i<105;i++)for(int j=0;j<105;j++){\n   \t\t\tif(i!=j){\n   \t\t\tint r=-(memo1[t][i]-memo2[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t\t\n   \t\t\t}\n   \t\t}\n   \t\tcout<<ans<<endl;\n   \t\t\n   }\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge {\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nint N, M, S1, S2, T;\nvector< vector<edge> > rgraph;\n\nstruct State {\n  int now, cost, magic, prev;\n  State(){}\n  State(int now, int cost, int magic, int prev):now(now), cost(cost), magic(magic), prev(prev){}\n  bool operator < (const State &s) const {\n    return cost > s.cost;\n  }\n};\n\nvector<vint> mincost;\n\nvoid rdijkstra() {\n  resz(mincost, 101, vint(N, inf));\n  priority_queue<State> que;\n  mincost[0][T] = 0;\n  que.emplace(T, 0, 0, -1);\n  while(!que.empty()) {\n    State s = que.top(); que.pop();\n    if(mincost[s.magic][s.now] < s.cost) continue;\n    //cout<<s.now<<\" \"<<s.cost<<\" \"<<rgraph[s.now].size()<<endl;\n    for(edge& e : rgraph[s.now]) {\n      if(e.to == s.prev) continue;\n      if(e.cost >= 0) {\n\tif(e.cost + s.cost < mincost[s.magic][e.to]) {\n\t  mincost[s.magic][e.to] = e.cost + s.cost;\n\t  que.emplace(e.to, e.cost + s.cost, s.magic, s.now);\n\t}\n      } else {\n\tif(s.cost < mincost[s.magic+1][e.to]) {\n\t  mincost[s.magic+1][e.to] = s.cost;\n\t  que.emplace(e.to, s.cost, s.magic+1, s.now);\n\t}\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N+M+S1+S2+T) {\n    S1--, S2--, T--;\n    resz(rgraph, N);\n    rep(i, M) {\n      int s, t; string ws;\n      cin >> s >> t >> ws;\n      s--, t--;\n      if(ws == \"x\") {\n\trgraph[s].emplace_back(t, -1);\n\trgraph[t].emplace_back(s, -1);\n      } else {\n\tint w = stoi(ws);\n\trgraph[s].emplace_back(t, w);\n\trgraph[t].emplace_back(s, w);\n      }\n    }\n    rdijkstra();\n\n    vector< tuple<double, int, int> > crossX;\n    rep(i, 101) rep(j, 101) {\n      if(i == j) continue;\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      //cout<<mincost[i][S1]<<\" \"<<mincost[j][S2]<<endl;\n      double x = (mincost[j][S2]-mincost[i][S1])/(i-j);\n      crossX.emplace_back(x, i, j);\n    }\n\n    int ans = inf;\n    rep(i, 101) rep(j, 101) {\n      if(mincost[i][S1] == inf || mincost[j][S2] == inf) continue;\n      chmin(ans, llabs(mincost[i][S1]-mincost[j][S2]));\n    }\n\n    for(tuple<double, int, int> tup : crossX) {\n      double x;\n      int i, j;\n      tie(x, i, j) = tup;\n      int ceil_x = ceil(x);\n      int floor_x = floor(x);\n      if(ceil_x >= 0) {\n\tchmin(ans, llabs(mincost[i][S1]+ceil_x*i - mincost[j][S2]-ceil_x*j));\n      }\n      if(floor_x >= 0) {\n\tchmin(ans, llabs(mincost[i][S1]+floor_x*i - mincost[j][S2]-floor_x*j));\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\twhile(1){\n\t\tll n,m,s[2],t;\n\t\tll a[2002],b[2002];\n\t\tll w[2002];\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[0],&s[1],&t);\n\t\tif(n==0)return 0;\n\t\trep(i,m){\n\t\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tif(in == \"x\")w[i] = INF;\n\t\t\telse {\n\t\t\t\tw[i] = 0;\n\t\t\t\trep(j,in.size()){\n\t\t\t\t\tw[i] *= 10;\n\t\t\t\t\tw[i] += in[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> G[2002];\n\t\trep(i,m){\n\t\t\tG[a[i]].pb(P(b[i],w[i]));\n\t\t\tG[b[i]].pb(P(a[i],w[i]));\n\t\t}\n\t\t\n\t\tstatic ll cost[1002][102];\n\t\tstatic bool used[1002][102];\n\t\tstatic priority_queue<P1,vector<P1>,greater<P1>> que;\n\t\trep(i,1002)rep(j,102){\n\t\t\tcost[i][j] = INF;\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tcost[t][0] = 0;\n\t\tque.push(mp1(0,t,0));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.top(); que.pop();\n\t\t\tif(used[p.sc.fr][p.sc.sc])continue;\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t\trep(i,G[p.sc.fr].size()){\n\t\t\t\tP ed = G[p.sc.fr][i];\n\t\t\t\tif(ed.sc == INF){\n\t\t\t\t\tif(p.sc.sc < 100){\n\t\t\t\t\t\tif(cost[ed.fr][p.sc.sc+1] > p.fr){\n\t\t\t\t\t\t\tcost[ed.fr][p.sc.sc+1] = p.fr;\n\t\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc+1],ed.fr,p.sc.sc+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cost[ed.fr][p.sc.sc] > p.fr+ed.sc){\n\t\t\t\t\t\tcost[ed.fr][p.sc.sc] = p.fr+ed.sc;\n\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc],ed.fr,p.sc.sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> vec[2];\n\t\trep(i,2){\n\t\t\trep1(j,100){\n\t\t\t\tcost[s[i]][j] = min ( cost[s[i]][j] , cost[s[i]][j-1] );\n\t\t\t}\n\t\t\trep(j,101){\n\t\t\t\twhile(vec[i].size() >= 2){\n\t\t\t\t\tP p=vec[i][vec[i].size()-2];\n\t\t\t\t\tP q=vec[i][vec[i].size()-1];\n\t\t\t\t\tif((p.fr-q.fr)/(q.sc-p.sc) < (q.fr-cost[s[i]][j])/(j-q.sc)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse vec[i].pop_back();\n\t\t\t\t}\n\t\t\t\tvec[i].pb(P(cost[s[i]][j],j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> x;\n\t\tx.pb(0);\n\t\trep(i,2){\n\t\t\tfor(int j = 0 ; j+1 < vec[i].size() ; j ++){\n\t\t\t\tll x_ = (vec[i][j].fr-vec[i][j+1].fr)/(vec[i][j+1].sc-vec[i][j].sc);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\trep(i,101)rep(j,101){\n\t\t\tif(i==j)continue;\n\t\t\tif(i>j && cost[s[0]][i]<cost[s[1]][j]){\n\t\t\t\tll x_ = (-cost[s[0]][i]+cost[s[1]][j])/(i-j);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t\tif(i<j && cost[s[0]][i]>cost[s[1]][j]){\n\t\t\t\tll x_ = (cost[s[0]][i]-cost[s[1]][j])/(j-i);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,4){\n\t\t\tprintf(\"%lld %lld\\n\",cost[s[0]][i],cost[s[1]][i]);\n\t\t}*/\n\t\t\n\t\tll ret = INF;\n\t\trep(i,x.size()){\n\t\t\tll dist[2] = {INF,INF};\n\t\t\trep(j,2){\n\t\t\t\trep(k,101){\n\t\t\t\t\tdist[j] = min ( dist[j] , k*x[i]+cost[s[j]][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[0] << dist[1] << endl;\n\t\t\tret = min ( ret , abs(dist[0]-dist[1]) );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nstruct Edge { int to; lint c; };\n\nstruct State {\n\tint v, h; lint c;\n\tbool operator > (const State& s) const { return c > s.c; }\n};\n\nint N, M, S1, S2, T, BC;\nvector< vector< Edge > > adj;\nlint dst[2][1010][110], INF = 1LL << 60;\n\nvoid djk(int index, int s) {\n\tfor_(v,0,N) for_(h,0,BC+1) dst[index][v][h] = INF;\n\t\n\tpriority_queue< State, vector< State >, greater< State > > que;\n\tque.push(State{s, 0, 0});\n\tdst[index][s][0] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tState s = que.top(); que.pop();\n\t\t\n\t\tif (dst[index][s.v][s.h] < s.c) continue;\n\t\t\n\t\tfor (Edge e : adj[s.v]) {\n\t\t\tlint nxc = s.c + (e.c == -1 ? 0 : e.c);\n\t\t\tint nh = s.h + (e.c == -1 ? 1 : 0);\n\t\t\t\n\t\t\tif (nh <= BC && dst[index][e.to][nh] > nxc) {\n\t\t\t\tdst[index][e.to][nh] = nxc;\n\t\t\t\tque.push(State{e.to, nh, nxc});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvector< lint > calcX(int index) {\n\tvector< lint > X;\n\t\n\tfor_(ki,0,BC+1) for_(kj,ki+1,BC+1) {\n\t\tlint di = dst[index][T][ki], dj = dst[index][T][kj];\n\t\tlint x = (di - dj) / (kj - ki);\n\t\tfor_(dx,-1,2) if (di < INF && dj < INF && x + dx >= 0) X.push_back(x + dx);\n\t}\n\t\n\treturn X;\n}\n\nvector< lint > calcInter() {\n\tvector< lint > X;\n\t\n\tfor_(ki,0,BC+1) for_(kj,0,BC+1) {\n\t\tif (ki == kj) continue;\n\t\tlint di = dst[0][T][ki], dj = dst[1][T][kj];\n\t\tlint x = (di - dj) / (kj - ki);\n\t\tfor_(dx,-1,2) if (di < INF && dj < INF && x + dx >= 0) X.push_back(x + dx);\n\t}\n\t\n\treturn X;\n}\n\nvoid solve() {\n\tdjk(0, S1);\n\tdjk(1, S2);\n\t\n\tvector< lint > X = calcX(0), XX = calcX(1), XI = calcInter();\n\tX.insert(X.end(), allof(XX));\n\tX.insert(X.end(), allof(XI));\n\t\n\tsort(allof(X));\n\tX.erase(unique(allof(X)), X.end());\n\t\n\tif (X.empty()) X.push_back(0);\n\tint m = X.size();\n\t\n\tlint ans = INF;\n\t\n\tfor_(i,0,m) {\n\t\tlint x = X[i];\n\t\t\n\t\tlint dk[2] = {INF, INF};\n\t\tfor_(j,0,2) for_(k,0,BC+1) dk[j] = min(dk[j], dst[j][T][k] + k * x);\n\t\t\n\t\tans = min(ans, abs(dk[0] - dk[1]));\n\t}\n\t\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M >> S1 >> S2 >> T, N) {\n\t\t--S1; --S2; --T;\n\t\tadj.assign(N, vector< Edge >());\n\t\tBC = 0;\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint u, v;\n\t\t\tstring str;\n\t\t\tcin >> u >> v >> str;\n\t\t\t--u; --v;\n\t\t\t\n\t\t\tlint c;\n\t\t\t\n\t\t\tif (str == \"x\") {\n\t\t\t\tc = -1;\n\t\t\t\t++BC;\n\t\t\t} else {\n\t\t\t\tstringstream ss(str);\n\t\t\t\tss >> c;\n\t\t\t}\n\t\t\t\n\t\t\tadj[u].push_back(Edge{v, c});\n\t\t\tadj[v].push_back(Edge{u, c});\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nstruct edge{int to; ll cost;};\n\nconst int N = 1000, B = 101;\nconst ll INF = LLONG_MAX/111;\n\nvector<edge> G[N];\nll d[N][B];\n\nusing pi = pair<int,int>;\nusing P = pair<ll,pi>;\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n\n    int n,m,s1,s2,t;\n    while(cin >>n >>m >>s1 >>s2 >>t,n){\n        rep(i,N) G[i].clear();\n\n        --s1;\n        --s2;\n        --t;\n\n        rep(i,m){\n            int a,b;\n            string w;\n            cin >>a >>b >>w;\n            --a;\n            --b;\n\n            ll cost;\n            if(w == \"x\") cost = -1;\n            else cost = stoll(w);\n\n            G[a].pb({b,cost});\n            G[b].pb({a,cost});\n        }\n\n        rep(i,N)rep(j,B) d[i][j] = INF;\n\n        d[t][0] = 0;\n        priority_queue<P, vector<P>, greater<P>> pq;\n        pq.push({0,{t,0}});\n        while(!pq.empty()){\n            P now = pq.top();\n            pq.pop();\n            int v = now.se.fi, b = now.se.se;\n            if(now.fi > d[v][b]) continue;\n\n            for(const auto &e:G[v]){\n                if(e.cost == -1){\n                    if(b+1<B && d[e.to][b+1] > d[v][b]){\n                        d[e.to][b+1] = d[v][b];\n                        pq.push({d[e.to][b+1], {e.to,b+1}});\n                    }\n                }\n                else{\n                    if(d[e.to][b] > d[v][b]+e.cost){\n                        d[e.to][b] = d[v][b]+e.cost;\n                        pq.push({d[e.to][b], {e.to,b}});\n                    }\n                }\n            }\n        }\n\n        vector<ll> cand;\n        cand.pb(0);\n        cand.pb(INF);\n        rep(b1,B)rep(b2,B){\n            if(b1 == b2) continue;\n            if(d[s1][b1] == INF || d[s2][b2] == INF) continue;\n\n            ll D = abs(d[s1][b1] - d[s2][b2]);\n            D /= abs(b1-b2);\n            for(int i=-1; i<=1; ++i)if(D+i>0) cand.pb(D+i);\n\n            D = abs(d[s1][b1] - d[s1][b2]);\n            D /= abs(b1-b2);\n            for(int i=-1; i<=1; ++i)if(D+i>0) cand.pb(D+i);\n\n            D = abs(d[s2][b1] - d[s2][b2]);\n            D /= abs(b1-b2);\n            for(int i=-1; i<=1; ++i)if(D+i>0) cand.pb(D+i);\n        }\n        sort(all(cand));\n        cand.erase(unique(all(cand)), cand.end());\n\n        ll ans = INF;\n        for(ll w:cand){\n            ll d1 = LLONG_MAX, d2 = LLONG_MAX;\n            rep(i,B){\n                if(d[s1][i]<INF) d1 = min(d1, d[s1][i]+w*i);\n                if(d[s2][i]<INF) d2 = min(d2, d[s2][i]+w*i);\n            }\n\n            ans = min(ans, abs(d1-d2));\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nvector<pair<int,int> >g[1100];\nchar in[20];\nlong long ijk[1100][110];\nint v[1100][110];\nlong long ABS(long long a){return max(a,-a);}\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a){\n\t\tc--;d--;e--;\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tint cost;\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='x')cost=-1;\n\t\t\telse sscanf(in,\"%d\",&cost);\n\t\t\tg[p].push_back(make_pair(q,cost));\n\t\t\tg[q].push_back(make_pair(p,cost));\n\t\t}\n\t\tfor(int i=0;i<1100;i++)for(int j=0;j<110;j++){\n\t\t\tijk[i][j]=9999999999999999LL;\n\t\t\tv[i][j]=0;\n\t\t}\n\t\tpriority_queue<pair<long long,pair<int,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(e,0)));\n\t\tijk[e][0]=0;\n\t\twhile(Q.size()){\n\t\t\tlong long cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first;\n\t\t\tint x=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[at][x])continue;\nif(x>100)continue;\n\t\t\tv[at][x]=1;\n//printf(\"%d %d %lld\\n\",at,x,cost);\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tint to=g[at][i].first;\n\t\t\t\tint tx=x;\n\t\t\t\tlong long tmp=cost;\n\t\t\t\tif(g[at][i].second==-1){\n\t\t\t\t\ttx++;\n\t\t\t\t}else tmp+=g[at][i].second;\n\t\t\t\tif(!v[to][tx]&&ijk[to][tx]>tmp){\n\t\t\t\t\tijk[to][tx]=tmp;\n//printf(\"%lld %d %d\\n\",tmp,to,tx);\n\t\t\t\t\tQ.push(make_pair(-tmp,make_pair(to,tx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//for(int i=0;i<10;i++)printf(\"%lld %lld\\n\",ijk[c][i],ijk[d][i]);\n\t\tlong long ret=99999999999999999LL;\n\t\tfor(int i=0;i<110;i++)for(int j=0;j<110;j++){\n\t\t//\tif(i&&ijk[c][i]>=ijk[c][i-1])continue;\n\t\t//\tif(j&&ijk[d][j]>=ijk[d][j-1])continue;\n\t\t\tif(ijk[c][i]>=9999999999999999LL)continue;\n\t\t\tif(ijk[d][j]>=9999999999999999LL)continue;\n \n\t\t\tlong long L=0;\n\t\t\tlong long R=9999999999999LL;\n \n\t\t\tfor(int k=0;k<110;k++){\n\t\t\t\tif(i!=k&&ijk[c][k]!=9999999999999999LL){\n\t\t\t\t\tlong long t1=ABS(ijk[c][k]-ijk[c][i]);\n\t\t\t\t\tlong long c1=t1/ABS(i-k);\n\t\t\t\t\tif(k<i)R=min(R,c1);\n\t\t\t\t\telse L=max(L,c1+(t1%ABS(i-k)?1:0));\n\t\t\t\t}\n\t\t\t\tif(j!=k&&ijk[d][k]!=9999999999999999LL){\n\t\t\t\t\tlong long t1=ABS(ijk[d][k]-ijk[d][j]);\n\t\t\t\t\tlong long c1=t1/ABS(j-k);\n\t\t\t\t\tif(k<j)R=min(R,c1);\n\t\t\t\t\telse L=max(L,c1+(t1%ABS(j-k)?1:0));\n\t\t\t\t}\n\t\t\t}\n\t\t//\tif(i==0&&j==2)printf(\"%lld %lld\\n\",L,R);\nif(L>R)continue;\n\t\t\tret=min(ret,ABS(L*i+ijk[c][i]-L*j-ijk[d][j]));\n\t\t\tret=min(ret,ABS(R*i+ijk[c][i]-R*j-ijk[d][j]));\n\t\t\tif(i!=j){\n\t\t\t\tlong long t2=ABS(ijk[c][i]-ijk[d][j]);\n\t\t\t\tlong long c2=t2/ABS(i-j);\n\t\t\t\tif(L<=c2&&c2<=R)ret=min(ret,ABS(c2*i+ijk[c][i]-c2*j-ijk[d][j]));\n\t\t\t\tif(L<=c2+1&&c2+1<=R)ret=min(ret,ABS(c2*i+i+ijk[c][i]-c2*j-j-ijk[d][j]));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tif(curu==100)continue;\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int ty,int i,int j){\n\tif(ty==0){\n\t\tif(dist[0][t][i]>=INF)return INF;\n\t\tif(dist[1][t][j]>=INF)return INF;\n\t}\n\tif(ty==1){\n\t\tif(dist[0][t][i]>=INF)return INF;\n\t\tif(dist[0][t][j]>=INF)return INF;\n\t}\n\tif(ty==2){\n\t\tif(dist[1][t][i]>=INF)return INF;\n\t\tif(dist[1][t][j]>=INF)return INF;\n\t}\n\tif(i==j){\n\t\tif(ty==1 || ty==2)return INF;\n\t\tll va=INF;\n\t\tll vb=INF;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tva=min(va,dist[0][t][l]);\n\t\t\tvb=min(vb,dist[1][t][l]);\n\t\t}\n\t\tif(va==INF || vb==INF)return INF;\n\t\treturn labs(va-vb);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tif(ty==1){\n\t\tb=(ll)(dist[0][t][j]-dist[0][t][i])/(i-j);\n\t}\n\tif(ty==2){\n\t\tb=(ll)(dist[1][t][j]-dist[1][t][i])/(i-j);\n\t}\n\tll ans=INF;\n\tfor(ll k=max(b-3LL,0LL);k<=max(b+3LL,0LL);k++){\n\t\tll va=INF;\n\t\tll vb=INF;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tva=min(va,dist[0][t][l]+l*k);\n\t\t\tvb=min(vb,dist[1][t][l]+l*k);\n\t\t}\n\t\tif(va>=INF || vb>=INF)continue;\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(0,i,j));\n\t\t\tans=min(ans,getMin(1,i,j));\n\t\t\tans=min(ans,getMin(2,i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\n#include<numeric>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconstexpr ll mod = 998244353;\nconst ll INF = mod * mod/300;\ntypedef pair<int, int>P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n#define all(v) (v).begin(),(v).end()\ntypedef pair<ll, ll> LP;\ntypedef double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-12;\nconst ld pi = acos(-1.0);\n\nll mod_pow(ll x, ll n, ll m) {\n\tll res = 1;\n\twhile (n) {\n\t\tif (n & 1)res = res * x % m;\n\t\tx = x * x % m; n >>= 1;\n\t}\n\treturn res;\n}\nstruct modint {\n\tll n;\n\tmodint() :n(0) { ; }\n\tmodint(ll m) :n(m) {\n\t\tif (n >= mod)n %= mod;\n\t\telse if (n < 0)n = (n % mod + mod) % mod;\n\t}\n\toperator int() { return n; }\n};\nbool operator==(modint a, modint b) { return a.n == b.n; }\nmodint operator+=(modint& a, modint b) { a.n += b.n; if (a.n >= mod)a.n -= mod; return a; }\nmodint operator-=(modint& a, modint b) { a.n -= b.n; if (a.n < 0)a.n += mod; return a; }\nmodint operator*=(modint& a, modint b) { a.n = ((ll)a.n * b.n) % mod; return a; }\nmodint operator+(modint a, modint b) { return a += b; }\nmodint operator-(modint a, modint b) { return a -= b; }\nmodint operator*(modint a, modint b) { return a *= b; }\nmodint operator^(modint a, ll n) {\n\tif (n == 0)return modint(1);\n\tmodint res = (a * a) ^ (n / 2);\n\tif (n % 2)res = res * a;\n\treturn res;\n}\n\nll inv(ll a, ll p) {\n\treturn (a == 1 ? 1 : (1 - p * inv(p % a, a)) / a + p);\n}\nmodint operator/(modint a, modint b) { return a * modint(inv(b, mod)); }\n\nconst int max_n = 1 << 22;\nmodint fact[max_n], factinv[max_n];\nvoid init_f() {\n\tfact[0] = modint(1);\n\tfor (int i = 0; i < max_n - 1; i++) {\n\t\tfact[i + 1] = fact[i] * modint(i + 1);\n\t}\n\tfactinv[max_n - 1] = modint(1) / fact[max_n - 1];\n\tfor (int i = max_n - 2; i >= 0; i--) {\n\t\tfactinv[i] = factinv[i + 1] * modint(i + 1);\n\t}\n}\nmodint comb(int a, int b) {\n\tif (a < 0 || b < 0 || a < b)return 0;\n\treturn fact[a] * factinv[b] * factinv[a - b];\n}\n\nll gcd(ll a, ll b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\tll r = a % b; a = b; b = r;\n\t}\n\treturn a;\n}\nusing speP = pair<ll, P>;\nstruct edge {\n\tint to, cost;\n};\nll dist[1000][101];\nint n, m, s1, s2, t;\nvoid solve() {\n\ts1--; s2--; t--;\n\tvector<vector<edge>> G(n);\n\trep(i, m) {\n\t\tint a, b; string s;\n\t\tcin >> a >> b >> s; a--; b--;\n\t\tint c;\n\t\tif (s == \"x\")c = -1;\n\t\telse c = stoi(s);\n\t\tG[a].push_back({ b,c });\n\t\tG[b].push_back({ a,c });\n\t}\n\trep(i, n)rep(j, 101) {\n\t\tdist[i][j] = INF;\n\t}\n\tdist[t][0] = 0;\n\tpriority_queue<speP, vector<speP>, greater<speP>> q;\n\tq.push({ 0,{t,0} });\n\twhile (!q.empty()) {\n\t\tspeP p = q.top(); q.pop();\n\t\tint id = p.second.first, k = p.second.second;\n\t\tif (dist[id][k] < p.first)continue;\n\t\tfor (edge e : G[id]) {\n\t\t\tll nd = p.first;\n\t\t\tint nk = k;\n\t\t\tif (e.cost < 0)nk++;\n\t\t\telse nd += e.cost;\n\t\t\tif (nk <= 100) {\n\t\t\t\tif (nd < dist[e.to][nk]) {\n\t\t\t\t\tdist[e.to][nk] = nd;\n\t\t\t\t\tq.push({ nd,{e.to,nk} });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tauto check = [&](LP x, LP y, LP z)->bool {\n\t\treturn x.first * z.second-x.second*z.first <= (z.second-x.second) * y.first + y.second * (x.first - z.first);\n\t};\n\tauto calc = [&](LP x, LP y)->ll {\n\t\tll dy = y.second - x.second;\n\t\tll dx = x.first - y.first;\n\t\treturn (dy + dx - 1) / dx;\n\t};\n\tvector<LP> v1, v2;\n\tfor(int i = 100; i >= 0; i--) {\n\t\tif (dist[s1][i] == INF)continue;\n\t\tLP p = { i,dist[s1][i] };\n\t\twhile (true) {\n\t\t\tbool f = true;\n\t\t\tif (v1.size() >= 2 && check(v1[v1.size() - 2], v1.back(), p)) {\n\t\t\t\tv1.pop_back(); f = false;\n\t\t\t}\n\t\t\tif (v1.size() && v1.back().second >= p.second) {\n\t\t\t\tv1.pop_back(); f = false;\n\t\t\t}\n\t\t\tif (f)break;\n\t\t}\n\t\tv1.push_back(p);\n\t}\n\tfor (int i = 100; i >= 0; i--) {\n\t\tif (dist[s2][i] == INF)continue;\n\t\tLP p = { i,dist[s2][i] };\n\t\twhile (true) {\n\t\t\tbool f = true;\n\t\t\tif (v2.size() >= 2 && check(v2[v2.size() - 2], v2.back(), p)) {\n\t\t\t\tv2.pop_back(); f = false;\n\t\t\t}\n\t\t\tif (v2.size() && v2.back().second >= p.second) {\n\t\t\t\tv2.pop_back(); f = false;\n\t\t\t}\n\t\t\tif (f)break;\n\t\t}\n\t\tv2.push_back(p);\n\t}\n\t/*cout << \"?\\n\";\n\trep(i, v1.size())cout << v1[i].first << \" \" << v1[i].second << \"\\n\";\n\tcout << \"?\\n\";\n\trep(i, v2.size())cout << v2[i].first << \" \" << v2[i].second << \"\\n\";*/\n\tvector<ll> d1, d2;\n\td1.push_back(0); d2.push_back(0);\n\trep(i, v1.size() - 1) {\n\t\td1.push_back(calc(v1[i], v1[i + 1]));\n\t}\n\trep(i, v2.size() - 1) {\n\t\td2.push_back(calc(v2[i], v2[i + 1]));\n\t}\n\tint id[2] = { -1,-1 };\n\tvector<LP> v;\n\trep(i, d1.size()) {\n\t\tv.push_back({ d1[i],0 });\n\t}\n\trep(i, d2.size()) {\n\t\tv.push_back({ d2[i],1 });\n\t}\n\tsort(all(v));\n\tvector<P> vs;\n\tvector<ll> vals;\n\trep(i, v.size()) {\n\t\tid[v[i].second]++;\n\t\twhile (i + 1 < v.size() && v[i].first == v[i + 1].first) {\n\t\t\ti++; id[v[i].second]++;\n\t\t}\n\t\tvs.push_back({ id[0],id[1] });\n\t\tvals.push_back(v[i].first);\n\t}\n\tvals.push_back(INF);\n\tll ans = INF;\n\trep(j, vs.size()) {\n\t\tll lx = vals[j], rx = vals[j + 1];\n\t\tint l = vs[j].first, r = vs[j].second;\n\t\t//cout << l << \" \" << r << \" \"<<lx<<\" \"<<rx<<\"\\n\";\n\t\tll cl = v1[l].first * lx + v1[l].second;\n\t\tll cr = v2[r].first * lx + v2[r].second;\n\t\tll dif = cl - cr;\n\t\tll dx = v1[l].first - v2[r].first;\n\t\tif (dx == 0) {\n\t\t\tans = min(ans, abs(cl - cr));\n\t\t}\n\t\telse if (dx > 0) {\n\t\t\tif (dif >= 0) {\n\t\t\t\tans = min(ans, abs(cl - cr));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tll d = -dif / dx;\n\t\t\t\td = min(d, rx - lx - 1);\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (d + i < rx - lx&&d+i>=0) {\n\t\t\t\t\t\tans = min(ans, abs(dif + dx * (d+i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (dif <= 0) {\n\t\t\t\tans = min(ans, abs(cl - cr));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//cout << \"hoge \" << dif << \" \" << -dx << \"\\n\";\n\t\t\t\tll d = dif / -dx;\n\t\t\t\td = min(d, rx - lx - 1);\n\t\t\t\tfor (int i = -1; i <= 1; i++) {\n\t\t\t\t\tif (d + i < rx - lx&&d+i>=0) {\n\t\t\t\t\t\tans = min(ans, abs(dif + dx * (d+i)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//cout << \"ans is \";\n\tcout << ans << \"\\n\";\n}\n\n\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\t//init_f();\n\t//expr();\n\t//int t; cin >> t; rep(i, t)\n\twhile (cin >> n >> m>>s1>>s2>>t, n)\n\t\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 10000000000000000LL\n\nstruct state{\n  int v,xcnt;\n  ll dist;\n};\nbool operator<(const state& a,const state& b){\n  return a.dist > b.dist;\n}\nstruct func{\n  ll a,b,l,r;\n};\n\nint N,M,S[2],T;\nvector<P> g[1001];\nll d[1001][110];\nvector<func> fs[2];\nint sz[2];\nbool dame[2][101];\n\nint main(){\n  while(1){\n    cin>>N>>M>>S[0]>>S[1]>>T;\n    if(N==0)break;\n    rep(i,N)g[i].clear();\n    fs[0].clear();fs[1].clear();\n    S[0]--;S[1]--;T--;\n    rep(i,M){\n      int a,b;\n      string c;\n      cin>>a>>b>>c;\n      a--;b--;\n      if(c==\"x\"){\n        g[a].push_back(P(b,-1));\n        g[b].push_back(P(a,-1));        \n      }else{\n        g[a].push_back(P(b,stoi(c)));\n        g[b].push_back(P(a,stoi(c)));\n      }\n    }\n    rep(s,2){\n      rep(i,N)rep(j,110)d[i][j]=INF;\n      priority_queue<state> que;\n      que.push((state){S[s],0,0});\n      while(que.size()){\n        state crt=que.top(); que.pop();\n        if(d[crt.v][crt.xcnt]!=INF)continue;\n        d[crt.v][crt.xcnt]=crt.dist;\n        for(P p : g[crt.v]){\n          if(p.se==-1&&crt.xcnt<100){\n            que.push((state){(int)p.fi,crt.xcnt+1,crt.dist});\n          }else if(p.se!=-1){\n            que.push((state){(int)p.fi,crt.xcnt,crt.dist+p.se});\n          }\n        }\n      }\n      rep(j,101)if(d[T][j]!=INF)fs[s].push_back((func){j,d[T][j],0LL,INF});\n      sz[s]=fs[s].size();\n      rep(i,sz[s])dame[s][i]=false;\n      rep(i,sz[s])rep(j,sz[s]){\n        if(i==j)continue;\n        if(fs[s][i].a>=fs[s][j].a&&fs[s][i].b>=fs[s][j].b)dame[s][i]=true;\n      }\n      rep(i,sz[s])rep(j,sz[s]){\n        if(i==j||dame[s][i]||dame[s][j])continue;\n        if(fs[s][i].a<fs[s][j].a){\n          assert(fs[s][i].b-fs[s][j].b>0);\n          maxch(fs[s][i].l,(fs[s][i].b-fs[s][j].b+fs[s][j].a-fs[s][i].a-1)/(fs[s][j].a-fs[s][i].a));\n        }else{\n          assert(fs[s][j].b-fs[s][i].b>0);\n          minch(fs[s][i].r,(fs[s][j].b-fs[s][i].b)/(fs[s][i].a-fs[s][j].a));\n        }\n      }\n    }\n    ll res=INF;\n    rep(i,sz[0])rep(j,sz[1]){\n      if(dame[0][i]||dame[1][j])continue;\n      ll l=max(fs[0][i].l,fs[1][j].l);\n      ll r=min(fs[0][i].r,fs[1][j].r);\n      if(l>r)continue;\n      ll a=fs[0][i].a-fs[1][j].a;\n      ll b=fs[0][i].b-fs[1][j].b;\n      if(a==0){\n        minch(res,abs(b));\n        continue;\n      }\n      if(a<0){\n        a=-a; b=-b;\n      }\n      if(b>=0){\n        minch(res,abs(a*l+b));\n        continue;\n      }\n      ll mn1=(-b)/a,mn2=(-b+a-1)/a;\n      if(l<=mn1&&mn1<=r)minch(res,abs(a*mn1+b));\n      if(l<=mn2&&mn2<=r)minch(res,abs(a*mn2+b));\n      minch(res,abs(a*l+b));\n      minch(res,abs(a*r+b));\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 59;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n  vector< edge > G[1000];\n  int64 dp[101][1000];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n\n    auto get = [&](int64 v)\n    {\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n    for(auto &cost : latte) if(cost >= 0) ret = min(ret, get(cost));\n    for(auto &cost : latte) if(cost >= -1) ret = min(ret, get(cost + 1));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nvector<pii> g[1000];\nll dist[1000][101];\n\nstruct P {\n  int v,c;\n  ll d;\n  P(int v, int c, ll d):v(v),c(c),d(d) {\n  }\n  bool operator<(const P &rhs) const {\n    return d>rhs.d;\n  }\n};\nint n,m,s1,s2,t;\n\nvector<ll> func(int s) {\n  priority_queue<P> Q;\n  Q.push(P(s,0,0));\n  REP(i,n)REP(j,101)dist[i][j] = 1LL<<60;\n  dist[s][0] = 0;\n  while(!Q.empty()) {\n    P p = Q.top(); Q.pop();\n    if (dist[p.v][p.c] < p.d) continue;\n    FOR(it, g[p.v]) {\n      ll nd = p.d;\n      int nc = p.c;\n      if (it->second == -1) {\n        nc++;\n      } else {\n        nd += it->second;\n      }\n      if (dist[it->first][nc] > nd) {\n        dist[it->first][nc] = nd;\n        Q.push(P(it->first,nc,nd));\n      }\n    }\n  }\n  vector<ll> res;\n  REP(i,101) {\n    res.push_back(dist[t][i]);\n  }\n  return res;\n}\n\nvector<ll> func2(vector<ll> v) {\n  vector<ll> res;\n  REP(i,v.size()) {\n    if (v[i] == 1LL<<60) continue;\n    REP(j,i) {\n      if (v[j] == 1LL<<60) continue;\n      // v[i]+i*x = v[j]+j*x\n      double x = -(v[i]-v[j])/(i-j);\n      if (x < 0) continue;\n      res.push_back((ll)x);\n      res.push_back((ll)(x+1));\n    }\n  }\n  return res;\n}\n\nint main() {  \n  while(cin>>n>>m>>s1>>s2>>t,n) {\n    s1--;s2--;t--;\n    REP(i,n) g[i].clear();\n    REP(i,m) {\n      int a,b;\n      string s;\n      cin >> a >> b >> s;\n      a--;b--;\n      int d;\n      if (s == \"x\") {\n        d = -1;\n      } else {\n        d = atoi(s.c_str());\n      }\n      g[a].push_back(pii(b,d));\n      g[b].push_back(pii(a,d));\n    }\n    vector<ll> v1 = func(s1);\n    vector<ll> v2 = func(s2);\n    vector<ll> xs = func2(v1);\n    vector<ll> xs2 = func2(v2);\n    FOR(it, xs2) xs.push_back(*it);\n    REP(i,v1.size()) {\n      if (v1[i] == INF) continue;\n      REP(j,v2.size()) {\n        if (v2[j] == INF) continue;\n        if (i==j) continue;\n        double x = -(v1[i]-v2[j])/(i-j);\n        if (x < 0) continue;\n        xs.push_back((ll)x);\n        xs.push_back((ll)(x+1));        \n      }\n    }\n    // REP(i,3) {\n    //   cout << i << \" \" << v1[i] << \" \" << v2[i]<< endl;\n    // }    \n    xs.push_back(0);\n    sort(ALL(xs));\n    xs.erase(unique(ALL(xs)), xs.end());\n    ll res = 1LL<<61;\n    FOR(it, xs) {\n      ll x = *it;\n      ll y1 = 1LL<<61;\n      REP(i,v1.size()) {\n        if (v1[i] == 1LL<<60) continue;\n        chmin(y1,v1[i]+i*x);\n      }\n      ll y2 = 1LL<<61;\n      REP(i,v2.size()) {\n        if (v2[i] == 1LL<<60) continue;\n        chmin(y2,v2[i]+i*x);\n      }\n      chmin(res, abs(y1-y2));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nvector<P> G[1111];\nint dp1[111][1111];\nint dp2[111][1111];\nint INF=1LL<<45LL;\nstruct st{\n  int x,v,d;\n  st(){}\n  st(int x,int v,int d):x(x),v(v),d(d){}\n  bool operator<(const st a)const{\n    return d>a.d;\n  }\n};\nint n,m,s1,s2,t;\nint ans;\nint calc1(int i,int x){\n  return dp1[i][t]+i*x;\n}\nint calc2(int i,int x){\n  return dp2[i][t]+i*x;\n}\nint check1(int x){\n  int res=-1;\n  for(int i=0;i<111;i++){\n    if(dp1[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc1(i,x)<calc1(res,x)) res=i;\n  }\n  return res;\n}\nint check2(int x){\n  int res=0;\n  for(int i=0;i<111;i++){\n    if(dp2[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc2(i,x)<calc2(res,x)) res=i;\n  }\n  return res;\n}\nint calc3(int x){\n  return calc1(check1(x),x)-calc2(check2(x),x);\n}\nsigned main(){\n  while(cin>>n>>m>>s1>>s2>>t,n){\n    s1--;s2--;t--;\n    for(int i=0;i<1111;i++) G[i].clear(); \n    for(int i=0;i<m;i++){\n      int a,b,w;\n      string s;\n      cin>>a>>b>>s;\n      if(s==\"x\") w=-1;\n      else w=stoll(s);\n      a--;b--;\n      G[a].push_back(P(b,w));\n      G[b].push_back(P(a,w));\n    }\n    for(int i=0;i<111;i++){\n      fill(dp1[i],dp1[i]+1111,INF);\n      fill(dp2[i],dp2[i]+1111,INF);\n    }\n    priority_queue<st> q;\n    q.emplace(0,s1,0);\n    dp1[0][s1]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp1[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      //cout<<p.x<<\" \"<<p.v<<\" \"<<p.d<<endl;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp1[nx][nv]<=nd) continue;\n\tdp1[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //puts(\"OK\");\n    q.emplace(0,s2,0);\n    dp2[0][s2]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp2[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp2[nx][nv]<=nd) continue;\n\tdp2[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //for(int i=0;i<11;i++) cout<<i<<\":dp1:\"<<dp1[i][t]<<endl;\n    //for(int i=0;i<11;i++) cout<<i<<\":dp2:\"<<dp2[i][t]<<endl;\n    \n    vector<int> b;\n    b.push_back(0);\n    b.push_back(INF);\n    int L=0;\n    while(check1(L)!=check1(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check1(L)!=check1(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    L=0;\n    while(check2(L)!=check2(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check2(L)!=check2(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    sort(b.begin(),b.end());\n    b.erase(unique(b.begin(),b.end()),b.end());\n    ans=INF;\n    for(int i=0;i<n;i++){\n      ans=min(ans,abs(calc3(b[i])));\n      if(i==n-1) break;\n      int x=b[i],y=b[i+1]-1;\n      ans=min(ans,abs(calc3(y)));\n      if(x==y) continue;\n      if(calc3(x)*calc3(y)<0){\n\tint d=calc3(x+1)-calc3(x);\n\tif(d==0) continue;\n\tint tmp=abs(calc3(x));\n\tans=min(ans,abs(tmp-(tmp/d*d)));\n\tans=min(ans,abs(((tmp/d+1)*d)-tmp));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\nvector<P> G[1111];\nint N,M,S1,S2,T;\nll H[1111];\nll F[1111];\nint useX[1111];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\n\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();  \n}\n\nint make_dijk_tree(int X){  \n  priority_queue<P,vector<P>,greater<P>> q;\n  q.push( P(0,T) );\n  fill( H, H+N, INF );\n  fill( F, F+N, 0LL );\n  fill( useX, useX+N, 0 );\n  while( !q.empty() ) {\n    P p = q.top(); q.pop();\n    ll c = p.first;\n    int v = p.second;\n    if( H[v] < c ) continue;\n    for( P e : G[v] ){      \n      ll nc = e.first + c;\n      if( e.first == -1 ) nc = X + c;\n      int nv = e.second;\n      if( H[nv] > nc ) {\n        H[nv] = nc;\n        F[nv] = F[v] + e.first;\n        useX[nv] = useX[v];\n        if( e.first == -1 ) {\n          useX[nv]++;\n          F[nv] = F[v];\n        }\n        q.push( P( nc, nv ) );\n      }\n    }\n  }\n  //cout << X << \" \" << useX[S1] << \" + \" << useX[S2] << endl;\n  return useX[S1] + useX[S2];\n}\n\nvoid add_edge(int a,int b,int w){\n  G[a].push_back( P(w,b) );\n  G[b].push_back( P(w,a) );\n}\n\nint lower_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k >= make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\nint upper_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k > make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M >> S1 >> S2 >> T &&\n         N && M && S1 && S2 && T ) {    \n    S1--; S2--; T--;\n    init();\n    int K=0;\n    for(int i=0;i<M;i++){\n      int a,b; string w; cin >> a >> b >> w;\n      --a; --b;\n      if( w == \"x\" ){\n        add_edge( a, b, -1 ); K++;\n      }\n      else\n        add_edge( a, b, stoi( w ) );\n    }\n\n    ll res = INF;\n    for(int k=0;k<=2*K;k++){\n      int lp = lower_bound(k);\n      int rp = upper_bound(k);\n      //cout << k << \" : \" << lp << \" \"<< rp << endl;\n      if( lp == rp ) continue;\n      if( F[S1] < F[S2] ) swap(S1,S2);\n      //cout << F[S1] << \" \"<< F[S2] << endl;\n      //cout << useX[S1] << \" \" << useX[S2] << endl;\n      if( useX[S1] >= useX[S2] ){\n        make_dijk_tree( lp );\n        res = min( res, abs( H[S1] - H[S2] ) );\n      } else {\n        int x = (F[S1] - F[S2])/(useX[S2]-useX[S1]);\n        for(int t=x-1;t<=x+1;t++){\n          make_dijk_tree( max(lp,min( rp-1, t )) );\n          //cout << t << \" \" << H[S1] << \" \" << H[S2] << endl;\n          res = min( res, abs( H[S1] - H[S2] ) );\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int maxn = 1005;\nconst int maxl = 105;\nconst ll inf = 1ll<<55;\nconst double eps = 1e-8;\n\nstruct edge\n{\n\tint to,val,mag;\n\tedge(int a,int b,int c):to(a),val(b),mag(c){}\n};\n\nstruct node\n{\n\tint to,mag;\n\tll len;\n\tnode(int a,int b,ll c):to(a),mag(b),len(c){}\n\tbool operator<(const node& a)const\n\t{\n\t\treturn len > a.len;\n\t}\n};\n\nstruct point\n{\n\tdouble xi,lef,di;\n\tpoint(){}\n\tpoint(double a,double b,double c):xi(a),lef(b),di(c){}\n};\n\nvector<edge> v[maxn];\nbool vis[maxn][maxl];\nll dis[maxn][maxl];\n\nint n,s1,s2,tt,sp;\nstruct line\n{\n\tpoint s[maxl];int top;\n\tvoid build()\n\t{\n\t\ttop = 0;\n\t\tfor(int i=sp;i>=0;i--)\n\t\t{\n\t\t\tif(dis[tt][i]==inf)\n\t\t\t\tcontinue;\n\t\t\twhile(top&&i*s[top-1].lef+dis[tt][i]<=eps+s[top-1].xi*s[top-1].lef+s[top-1].di)\n\t\t\t\ttop--;\n\t\t\ts[top] = point(i,top?(dis[tt][i]-s[top-1].di)/(s[top-1].xi-i):0,dis[tt][i]);\n\t\t\ttop++;\n\t\t}\n\t}\n}p1,p2;\n\nint f1,f2;\n\ndouble f(double x)\n{\n\treturn fabs(p1.s[f1].xi*x+p1.s[f1].di-p2.s[f2].xi*x-p2.s[f2].di);\n}\ndouble cal(double pl,double pr)\n{\n\tif(abs((p2.s[f2].xi-p1.s[f1].xi))<=eps)\n\t\treturn   fabs(p1.s[f1].di-p2.s[f2].di);\n\tpl = ceil(pl);pr = floor(pr);\n\tdouble jiao = (p1.s[f1].di-p2.s[f2].di)/(p2.s[f2].xi-p1.s[f1].xi);\n\tif(jiao>pr+eps)\n\t\treturn f(pr);\n\tif(jiao<pl-eps)\n\t\treturn f(pl);\n\treturn min(f(ceil(jiao)),f(floor(jiao)));\n}\ndouble sol()\n{\n\tdouble res = inf;\n\tvector<double> bl,v1,v2;\n\tfor(int i=0;i<p1.top;i++)\n\t{\n\t\tv1.push_back(p1.s[i].lef);\n\t\tbl.push_back(p1.s[i].lef);\n\t}\n\tfor(int i=0;i<p2.top;i++)\n\t{\n\t\tv2.push_back(p2.s[i].lef);\n\t\tbl.push_back(p2.s[i].lef);\n\t}\n\tsort(bl.begin(),bl.end());bl.push_back(1ll<<42);\n\tfor(int i=2;i<bl.size();i++)\n\t{\n\t\tdouble va = bl[i];\n\t\tf1 = lower_bound(v1.begin(),v1.end(),va-eps)-v1.begin()-1;\n\t\tf2 = lower_bound(v2.begin(),v2.end(),va-eps)-v2.begin()-1;\n\t\tres = min(cal(bl[i-1],va),res);\n\t}\n\treturn res;\n}\nvoid dij(int s)\n{\n\tpriority_queue<node> q;\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t\tfill(dis[i],dis[i]+sp+1,inf);\n\tdis[s][0] = 0;q.push(node(s,0,0));\n\twhile(!q.empty())\n\t{\n\t\tnode t = q.top();q.pop();\n\t\tif(vis[t.to][t.mag])\n\t\t\tcontinue;\n\t\tvis[t.to][t.mag] = 1;\n\t\tfor(int i=0;i<v[t.to].size();i++)\n\t\t{\n\t\t\tint toit = v[t.to][i].to;\n\t\t\tif(dis[toit][t.mag+v[t.to][i].mag]>dis[t.to][t.mag]+v[t.to][i].val)\n\t\t\t{\n\t\t\t\tdis[toit][t.mag+v[t.to][i].mag]=dis[t.to][t.mag]+v[t.to][i].val;\n\t\t\t\tq.push(node(toit,t.mag+v[t.to][i].mag,dis[toit][t.mag+v[t.to][i].mag]));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint m,a,b;char s[20];\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&tt)&&n)\n\t{\n\t\tsp = 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tv[i].clear();\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%s\",&a,&b,s);\n\t\t\tif(s[0]=='x')\n\t\t\t{\n\t\t\t\tsp++;\n\t\t\t\tv[a].push_back(edge(b,0,1));\n\t\t\t\tv[b].push_back(edge(a,0,1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint val = atoi(s);\n\t\t\t\tv[a].push_back(edge(b,val,0));\n\t\t\t\tv[b].push_back(edge(a,val,0));\n\t\t\t}\n\t\t}\n\t\tdij(s1);p1.build();\n\t\tdij(s2);p2.build();\n\t\tprintf(\"%.0f\\n\",sol());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main() {\n  ll n,m,s1,s2,t;\n  while(cin >> n >> m >> s1 >> s2 >> t && n) {\n    s1--,s2--,t--;\n    vector<P> v[n];\n    for(int i=0; i<m; i++) {\n      ll x,y,z;\n      string s;\n      cin >> x >> y >> s;\n      x--,y--;\n      if(s==\"x\") z=-1;\n      else {\n        stringstream ss;\n        ss << s;\n        ss >> z;\n      }\n      v[x].push_back(P(y,z));\n      v[y].push_back(P(x,z));\n    }\n    P d[n];\n    for(int i=0; i<n; i++) d[i]=P(-1,-1);\n    d[t]=P(0,0);\n    queue<int> que;\n    que.push(t);\n    while(!que.empty()) {\n      ll x=que.front();que.pop();\n      for(int i=0; i<v[x].size(); i++) {\n        ll y=v[x][i].first,c=v[x][i].second;\n        if(d[y]!=P(-1,-1)) continue;\n        if(c==-1) d[y]=P(d[x].first,d[x].second+1);\n        else d[y]=P(d[x].first+c,d[x].second);\n        que.push(y);\n      }\n    }\n    P p=d[s1],q=d[s2];\n    ll z=min(p.second,q.second);\n    p.second-=z;q.second-=z;\n    if(!p.second) swap(p,q);\n    ll l=0,r=1LL<<31;\n    while(l+1<r) {\n      ll mid=(l+r)/2;\n      if(p.first+p.second*mid<q.first) l=mid;\n      else r=mid;\n    }\n    cout << min(abs(p.first+p.second*l-q.first),abs(p.first+p.second*r-q.first)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(i==j){\n\t\tif(dist[0][t][i]>=INF)return INF;\n\t\tif(dist[1][t][j]>=INF)return INF;\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tvector<PPP> vec;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tvec.push_back(PPP(dist[0][t][l]+l*k,0));\n\t\t\tvec.push_back(PPP(dist[1][t][l]+l*k,1));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\tfor(int l=0;l<(int)vec.size()-1;l++){\n\t\t\tif(vec[l].first>=INF)continue;\n\t\t\tif(vec[l].second!=vec[l+1].second){\n\t\t\t\tans=min(ans,vec[l+1].first-vec[l].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tif(ag2>100)return;\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 60;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    vector< edge > G[1000];\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int64 cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n\n    for(auto &cost : latte) ret = min(ret, get(cost));\n    for(auto &cost : latte) ret = min(ret, get(cost + 1));\n\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n, m, s1, s2, t;\nvector<pl> e[1000];\nll dist[101][1000];\nll d[2][101];\npl range[2][101];\n\nvoid solve() {\n    s1--; s2--; t--;\n    int b_cnt = 0;\n    rep(i,m) {\n        int a, b; string s;\n        cin >> a >> b >> s; a--; b--;\n        if (s == \"x\") {\n            e[a].push_back(pl(b, -1));\n            e[b].push_back(pl(a, -1));\n            b_cnt++;\n        } else {\n            ll num = 0;\n            rep(j,s.size()) {\n                num = num * 10 + s[j]-'0';\n            }\n            e[a].push_back(pl(b, num));\n            e[b].push_back(pl(a, num));\n        }\n    }\n    rep(i,n) rep(j,n) dist[i][j] = linf;\n    dist[0][t] = 0;\n    priority_queue<pl, vector<pl>, greater<pl>> pque;\n    pque.push(pl(0, t));\n    while (!pque.empty()) {\n        ll dis = pque.top().first, num = pque.top().second/n, pos = pque.top().second%n;\n        pque.pop();\n        if (dis > dist[num][pos]) continue;\n        rep(i,e[pos].size()) {\n            pl E = e[pos][i];\n            if (E.second == -1) {\n                if (num != b_cnt && dist[num+1][E.first] > dist[num][pos]) {\n                    dist[num+1][E.first] = dist[num][pos];\n                    pque.push(pl(dist[num+1][E.first], (num+1)*n+E.first));\n                } \n            } else {\n                if (dist[num][E.first] > dist[num][pos] + E.second) {\n                    dist[num][E.first] = dist[num][pos] + E.second;\n                    pque.push(pl(dist[num][E.first], num*n + E.first));\n                }\n            }\n        }\n    }\n    b_cnt++;\n    rep(i,b_cnt) d[0][i] = dist[i][s1];\n    rep(i,b_cnt) d[1][i] = dist[i][s2];\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << d[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n    rep(i,2) rep(j,b_cnt) range[i][j] = pl(0, inf * 1000LL);\n    rep(i,2) {\n        rep(j,b_cnt) {\n            if (d[i][j] == linf) {\n                range[i][j] = pl(-1, -1);\n                continue;\n            }\n            rep(k,b_cnt) {\n                if (d[i][k] == linf) continue;\n                if (j == k) continue;\n                if (j < k) {\n                    if (d[i][j] <= d[i][k]) continue;\n                    ll hoge = (d[i][j] - d[i][k] + k-j-1) / (k-j);\n                    range[i][j].first = max(range[i][j].first, hoge);\n                } else {\n                    if (d[i][j] >= d[i][k]) {\n                        range[i][j] = pl(-1, -1);\n                        break;\n                    }\n                    ll hoge = (d[i][k] - d[i][j] + j-k-1) / (j-k);\n                    range[i][j].second = min(range[i][j].second, hoge);\n                }\n            }\n        }\n    }\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << \"(\" << range[i][j].first << \", \" << range[i][j].second << \") \";\n        }\n        cerr << endl;\n    }\n    */\n    ll ans = linf;\n    rep(i,b_cnt) {\n        rep(j,b_cnt) {\n            if (range[0][i].first == -1 || range[1][j].first == -1) continue;\n            ll l = max(range[0][i].first, range[1][j].first), r = min(range[0][i].second, range[1][j].second);\n            if (l > r) continue;\n            bool flag = (d[0][i] + i*l >= d[1][j] + j*l);\n            if (flag) {\n                if (i >= j) {\n                    ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                    continue;\n                }\n                //cerr << \"Ok\" << endl;\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 >= val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                ans = min(ans, abs(d[0][i]+i*r - d[1][j] - j*r));\n            } else {\n                if (i <= j) {\n                    ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                    continue;\n                }\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 < val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                ans = min(ans, abs(d[1][j]+j*r - d[0][i] - i*r));\n\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    while (cin >> n >> m >> s1 >> s2 >> t) {\n        if (n == 0 && m == 0 && s1 == 0 && s2 == 0 && t == 0) break;\n        solve();\n    }\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\twhile(1){\n\t\tll n,m,s[2],t;\n\t\tll a[2002],b[2002];\n\t\tll w[2002];\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[0],&s[1],&t);\n\t\tif(n==0)return 0;\n\t\trep(i,m){\n\t\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tif(in == \"x\")w[i] = INF;\n\t\t\telse {\n\t\t\t\tw[i] = 0;\n\t\t\t\trep(j,in.size()){\n\t\t\t\t\tw[i] *= 10;\n\t\t\t\t\tw[i] += in[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> G[2002];\n\t\trep(i,m){\n\t\t\tG[a[i]].pb(P(b[i],w[i]));\n\t\t\tG[b[i]].pb(P(a[i],w[i]));\n\t\t}\n\t\t\n\t\tstatic ll cost[1002][102];\n\t\tstatic bool used[1002][102];\n\t\tstatic priority_queue<P1,vector<P1>,greater<P1>> que;\n\t\trep(i,1002)rep(j,102){\n\t\t\tcost[i][j] = INF;\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tcost[t][0] = 0;\n\t\tque.push(mp1(0,t,0));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.top(); que.pop();\n\t\t\tif(used[p.sc.fr][p.sc.sc])continue;\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t\trep(i,G[p.sc.fr].size()){\n\t\t\t\tP ed = G[p.sc.fr][i];\n\t\t\t\tif(ed.sc == INF){\n\t\t\t\t\tif(p.sc.sc < 100){\n\t\t\t\t\t\tif(cost[ed.fr][p.sc.sc+1] > p.fr){\n\t\t\t\t\t\t\tcost[ed.fr][p.sc.sc+1] = p.fr;\n\t\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc+1],ed.fr,p.sc.sc+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cost[ed.fr][p.sc.sc] > p.fr+ed.sc){\n\t\t\t\t\t\tcost[ed.fr][p.sc.sc] = p.fr+ed.sc;\n\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc],ed.fr,p.sc.sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> vec[2];\n\t\trep(i,2){\n\t\t\trep1(j,100){\n\t\t\t\tcost[s[i]][j] = min ( cost[s[i]][j] , cost[s[i]][j-1] );\n\t\t\t}\n\t\t\trep(j,101){\n\t\t\t\twhile(vec[i].size() >= 2){\n\t\t\t\t\tP p=vec[i][vec[i].size()-2];\n\t\t\t\t\tP q=vec[i][vec[i].size()-1];\n\t\t\t\t\tif((p.fr-q.fr)/(q.sc-p.sc) < (q.fr-cost[s[i]][j])/(j-q.sc)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse vec[i].pop_back();\n\t\t\t\t}\n\t\t\t\tvec[i].pb(P(cost[s[i]][j],j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> x;\n\t\tx.pb(0);\n\t\trep(i,2){\n\t\t\tfor(int j = 0 ; j+1 < vec[i].size() ; j ++){\n\t\t\t\tll x_ = (vec[i][j].fr-vec[i][j+1].fr)/(vec[i][j+1].sc-vec[i][j].sc);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\trep(i,101)rep(j,101){\n\t\t\tif(i==j)continue;\n\t\t\tif(i>j && cost[s[0]][i]<cost[s[1]][j]){\n\t\t\t\tll x_ = (-cost[s[0]][i]+cost[s[1]][j])/(i-j);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t\tif(i<j && cost[s[0]][i]>cost[s[1]][j]){\n\t\t\t\tll x_ = (cost[s[0]][i]-cost[s[1]][j])/(j-i);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,4){\n\t\t\tprintf(\"%lld %lld\\n\",cost[s[0]][i],cost[s[1]][i]);\n\t\t}*/\n\t\t\n\t\tll ret = INF;\n\t\trep(i,x.size()){\n\t\t\tll dist[2] = {INF,INF};\n\t\t\trep(j,2){\n\t\t\t\trep(k,101){\n\t\t\t\t\tdist[j] = min ( dist[j] , k*x[i]+cost[s[j]][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[0] << dist[1] << endl;\n\t\t\tret = min ( ret , abs(dist[0]-dist[1]) );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\t//if (N != 1000)continue;\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long int al = nums[i];\n\t\t\tlong long int ar = nums[i+1];\n\t\t\tif (ar < 0)continue;\n\t\t\telse if (al < 0)al = 0;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (ar - al);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (ar - al);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\n#include<string.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<ll,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst ll INF=1000000000000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint main(){\n\twhile(1){\n\t\tll n,m,s[2],t;\n\t\tll a[2002],b[2002];\n\t\tll w[2002];\n\t\tscanf(\"%lld%lld%lld%lld%lld\",&n,&m,&s[0],&s[1],&t);\n\t\tif(n==0)return 0;\n\t\trep(i,m){\n\t\t\tscanf(\"%lld%lld\",&a[i],&b[i]);\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tif(in == \"x\")w[i] = INF;\n\t\t\telse {\n\t\t\t\tw[i] = 0;\n\t\t\t\trep(j,in.size()){\n\t\t\t\t\tw[i] *= 10;\n\t\t\t\t\tw[i] += in[j]-'0';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> G[2002];\n\t\trep(i,m){\n\t\t\tG[a[i]].pb(P(b[i],w[i]));\n\t\t\tG[b[i]].pb(P(a[i],w[i]));\n\t\t}\n\t\t\n\t\tstatic ll cost[1002][102];\n\t\tstatic bool used[1002][102];\n\t\tstatic priority_queue<P1,vector<P1>,greater<P1>> que;\n\t\trep(i,1002)rep(j,102){\n\t\t\tcost[i][j] = INF;\n\t\t\tused[i][j] = false;\n\t\t}\n\t\tcost[t][0] = 0;\n\t\tque.push(mp1(0,t,0));\n\t\twhile(!que.empty()){\n\t\t\tP1 p = que.top(); que.pop();\n\t\t\tif(used[p.sc.fr][p.sc.sc])continue;\n\t\t\tused[p.sc.fr][p.sc.sc] = true;\n\t\t\trep(i,G[p.sc.fr].size()){\n\t\t\t\tP ed = G[p.sc.fr][i];\n\t\t\t\tif(ed.sc == INF){\n\t\t\t\t\tif(p.sc.sc < 100){\n\t\t\t\t\t\tif(cost[ed.fr][p.sc.sc+1] > p.fr){\n\t\t\t\t\t\t\tcost[ed.fr][p.sc.sc+1] = p.fr;\n\t\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc+1],ed.fr,p.sc.sc+1));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif(cost[ed.fr][p.sc.sc] > p.fr+ed.sc){\n\t\t\t\t\t\tcost[ed.fr][p.sc.sc] = p.fr+ed.sc;\n\t\t\t\t\t\tque.push(mp1(cost[ed.fr][p.sc.sc],ed.fr,p.sc.sc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<P> vec[2];\n\t\trep(i,2){\n\t\t\trep1(j,100){\n\t\t\t\tcost[s[i]][j] = min ( cost[s[i]][j] , cost[s[i]][j-1] );\n\t\t\t}\n\t\t\trrep(j,101){\n\t\t\t\twhile(vec[i].size() >= 2){\n\t\t\t\t\tP p=vec[i][vec[i].size()-1];\n\t\t\t\t\tP q=vec[i][vec[i].size()-2];\n\t\t\t\t\tif((p.fr-q.fr)/(q.sc-p.sc) < (cost[s[i]][j]-p.fr)/(p.sc-j)){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse vec[i].pop_back();\n\t\t\t\t}\n\t\t\t\tvec[i].pb(P(cost[s[i]][j],j));\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<ll> x;\n\t\tx.pb(0);\n\t\trep(i,2){\n\t\t\tfor(int j = 0 ; j+1 < vec[i].size() ; j ++){\n\t\t\t\tll x_ = (vec[i][j].fr-vec[i][j+1].fr)/(vec[i][j+1].sc-vec[i][j].sc);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\trep(i,101)rep(j,101){\n\t\t\tif(i==j)continue;\n\t\t\tif(i>j && cost[s[0]][i]<cost[s[1]][j]){\n\t\t\t\tll x_ = (-cost[s[0]][i]+cost[s[1]][j])/(i-j);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t\tif(i<j && cost[s[0]][i]>cost[s[1]][j]){\n\t\t\t\tll x_ = (cost[s[0]][i]-cost[s[1]][j])/(j-i);\n\t\t\t\tx.pb(x_);\n\t\t\t\tx.pb(x_+1);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*rep(i,4){\n\t\t\tprintf(\"%lld %lld\\n\",cost[s[0]][i],cost[s[1]][i]);\n\t\t}*/\n\t\t\n\t\tll ret = INF;\n\t\trep(i,x.size()){\n\t\t\tll dist[2] = {INF,INF};\n\t\t\trep(j,2){\n\t\t\t\trep(k,101){\n\t\t\t\t\tdist[j] = min ( dist[j] , k*x[i]+cost[s[j]][k] );\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[0] << dist[1] << endl;\n\t\t\tret = min ( ret , abs(dist[0]-dist[1]) );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\nll dist2[1001];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tdist2[s]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tif(dist2[curv]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tif(dist2[e.t]<dist[type][curv][curu]+e.c)continue;\n\t\t\t\tdist2[e.t]=dist[type][curv][curu]+e.c;\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tif(curu==100)continue;\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tif(dist2[e.t]<dist[type][curv][curu]+e.c)continue;\n\t\t\t\tdist2[e.t]=dist[type][curv][curu]+e.c;\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(dist[0][t][i]>=INF)return INF;\n\tif(dist[1][t][j]>=INF)return INF;\n\tif(i==j){\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tll va=(ll)dist[0][t][i]+i*k;\n\t\tll vb=(ll)dist[1][t][j]+j*k;\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdijk(0,s1);\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct Edge {\n  int to;\n  int cost;\n  Edge(int to_, int cost_) {\n    to = to_; cost = cost_;\n  }\n};\n\nint N, M, S1, S2, T;\nint x = 0; // now magic cost\nvector<Edge> graph[1001];\n\nint dij(int s)\n{\n  bool used[1001] = {0};\n  priority_queue<Pii, vector<Pii>, greater<Pii> > q;\n  q.push(Pii(0, s));\n\n  while ( !q.empty() ) {\n    Pii p = q.top(); q.pop();\n    int c = p.fr, n = p.sc;\n\n    if ( n == T ) return c;\n\n    if ( used[n] ) continue;\n    used[n] = true;\n\n    Rep(i, graph[n].size()) {\n      int next = graph[n][i].to, cost = graph[n][i].cost;\n      if ( used[next] ) continue;\n      if ( cost == -1 ) {\n\tq.push(Pii(c + x, next));\n      } else {\n\tq.push(Pii(c + cost, next));\n      }\n    }\n  }\n  \n}\n\nsigned main()\n{\n  cin >> N >> M >> S1 >> S2 >> T;\n  S1--; S2--; T--;\n  \n  Rep(i, M) {\n    int a, b;\n    string s;\n    cin >> a >> b >> s;\n    a--; b--;\n    if ( s == \"x\" ) {\n      graph[a].pb(Edge(b, -1));\n      graph[b].pb(Edge(a, -1));\n    } else {\n      int c = stoi(s);\n      graph[a].pb(Edge(b, c));\n      graph[b].pb(Edge(a, c));\n    }\n  }\n\n  /* Rep(i, N) {\n    Rep(j, graph[i].size()) cout << graph[i][j].to << \" : \" << graph[i][j].cost << \" \";\n    cout << endl;\n    }*/\n\n  int l = 0, r = 1e9;\n  bool flag; // S1_cost > S2_cost : true  else : false\n  int S1_cost = dij(S1), S2_cost = dij(S2);\n\n  if( S1_cost > S2_cost ) flag = true;\n  else flag = false;\n  \n  while( r - l > 2 ) {\n    int mid = (l + r) / 2;\n    x = mid;\n    S1_cost = dij(S1); S2_cost = dij(S2);\n    //cout << S1_cost << \" \" << S2_cost << endl;\n    if ( (S1_cost > S2_cost) == flag ) l = mid;\n    else r = mid;\n  }\n\n  int ans;\n  x = l;\n  ans = abs(dij(S1) - dij(S2));\n  x = r;\n  ans = min(ans, abs(dij(S1) - dij(S2)));\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#define ll long long\n#define abs(x) (x > 0 ? x : -(x))\n#define F(a,b,c) ((a) + (b) * (c))\nusing namespace std;\n\nconst int maxn = 1200;\nconst int maxm = 2200;\nconst ll inf1 = 1000000000ll * 1100;\nconst ll inf = (1ll<<60);\nint n,m,S1,S2,T,tot;\nchar ss[110];\nint get(char *ss)\n{\n    int ret = 0;\n    for (int i = 0; ss[i]; i++) {\n        ret = ret * 10 + ss[i] - '0';\n    }\n    return ret;\n}\nll a[2][110],b[2][110],f[2][110];\nstruct EE\n{\n    int to,ne;\n    ll w;\n    bool f;\n}e[maxm * 2];\nint L,head[maxn];\nvoid adde(int u,int v,ll w)\n{\n    e[L].to = v;\n    e[L].w = w;\n    e[L].f = false;\n    if (w == -1) e[L].f = true;\n    e[L].ne = head[u];\n    head[u] = L++;\n}\nbool vis[maxn][maxn];\nll dis[2][maxn][maxn];\nint que[maxn * maxn][2];\nvoid spfa(int s,int t,int tt)\n{\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j <= tot; j++) {\n            dis[tt][i][j] = inf;\n            vis[i][j] = false;\n        }\n    vis[s][0] = true;\n    dis[tt][s][0] = 0;\n    int fron,rear;\n    fron = rear = 0;\n    que[rear][0] = s;\n    que[rear][1] = 0;\n    rear++;\n    while (fron != rear) {\n        int u1,u2;\n        u1 = que[fron][0];\n        u2 = que[fron][1];\n        vis[u1][u2] = false;\n        fron++;\n      //  cout<<fron<<' '<<rear<<' '<<u1<<' '<<u2<<endl;\n        if (fron == maxn * maxn) fron = 0;\n        for (int i = head[u1]; i != -1; i = e[i].ne) {\n            int p = e[i].f,v = e[i].to;\n            ll w;\n            if (u2 + p > tot) continue;\n            if (p == 1) w = 0;\n            else w = e[i].w;\n            if (dis[tt][v][u2 + p] > dis[tt][u1][u2] + w) {\n                dis[tt][v][u2 + p] = dis[tt][u1][u2] + w;\n                if (!vis[v][u2 + p]) {\n                    vis[v][u2 + p] = true;\n                    que[rear][0] = v;\n                    que[rear][1] = u2 + p;\n                    rear++;\n                    if (rear == maxn * maxn) rear = 0;\n                }\n            }\n        }\n    }\n}\nint cal(int s,int t,ll x,int tt)\n{\n    for (int i = 0; i < L; i++)\n    if (e[i].f)\n        e[i].w = x;\n    //spfa(s,t);\n    ll w = inf;\n    int ret;\n    for (int i = 0; i <= tot; i++)\n        if (dis[tt][t][i] + i * x <= w) {\n            w = dis[tt][t][i] + i * x;\n            ret = i;\n        }\n    return ret;\n}\nvoid get(int s,int t,ll *f,ll *a,ll *b,int tt)\n{\n    ll R = inf1;\n    ll now = -1;\n    int m = 0;\n    while (R >= 0) {\n        ll l = 0,r = R;\n        while (l < r) {\n            ll mid = (l + r + 1) / 2;\n            if (cal(s,t,mid,tt) == now)\n                r = mid - 1;\n            else\n                l = mid;\n          //  cout<<l<<endl;\n        }\n       // cout<<l<<endl;\n        ll x = cal(s,t,l,tt);\n        if (x == now) {\n            f[m++] = -1;\n            R = -1;\n        }\n        else {\n            now = x;\n            a[m] = dis[tt][T][now];\n            b[m] = now;\n            f[m++] = l;\n            R = l;\n        }\n    }\n}\nll cal2(ll a0,ll b0,ll a1,ll b1,ll tmax,ll tmin)\n{\n    ll l,r;\n    l = tmin,r = tmax;\n    while (l + 10 < r) {\n        ll mid1 = l + (r - l) / 3;\n        ll mid2 = l + (r - l) * 2 / 3;\n        if (abs(F(a0,b0,mid1) - F(a1,b1,mid1)) > abs(F(a0,b0,mid2) - F(a1,b1,mid2)))\n            l = mid1;\n        else\n            r = mid2;\n    }\n  //  cout<<l<<' '<<r<<endl;\n    ll ret = inf;\n    for (ll i = l; i <= r; i++) {\n        //cout<<a0<<' '<<b0<<' '<<a1<<' '<<b1<<endl;\n        ret = min(ret,abs(F(a0,b0,i) - F(a1,b1,i)));\n    }\n    return ret;\n}\nint main()\n{\n    while (scanf(\"%d%d%d%d%d\",&n,&m,&S1,&S2,&T) != EOF) {\n        if (n == 0 && m == 0) return 0;\n        S1--;S2--;T--;\n        tot = 0;\n        L = 0;\n        for (int i = 0; i < n; i++) head[i] = -1;\n        for (int i = 0; i < m; i++) {\n            int a,b,c;\n            scanf(\"%d%d%s\",&a,&b,ss);\n            a--;\n            b--;\n            if (ss[0] == 'x') {\n                adde(a,b,-1);\n                adde(b,a,-1);\n                tot++;\n            }\n            else {\n                c = get(ss);\n                adde(a,b,c);\n                adde(b,a,c);\n            }\n        }\n        for (int i = 0; i <= tot; i++)\n            f[0][i] = f[1][i] = -1;\n        spfa(S1,T,0);\n        spfa(S2,T,1);\n        get(S1,T,f[0],a[0],b[0],0);\n        get(S2,T,f[1],a[1],b[1],1);\n        //continue;\n       // return 0;\n        int i,j;\n        i = 0,j = 0;\n        ll ret = inf1;\n        //for (int i = 0; i <= 10; i++)\n       //     cout<<f[0][i]<<' '<<a[0][i]<<' '<<b[0][i]<<' '<<f[1][i]<<' '<<a[1][i]<<' '<<b[1][i]<<endl;\n        while (1) {\n            //cout<<i<<' '<<j<<endl;\n            ret = min(ret,cal2(a[0][i],b[0][i],a[1][j],b[1][j],min(f[0][i],f[1][j]),max(f[0][i + 1],f[1][j + 1]) + 1));\n            if (f[0][i + 1] == -1 && f[1][j + 1] == -1) break;\n            //cout<<'x'<<endl;\n            if (f[0][i + 1] > f[1][j + 1])\n                i++;\n            else\n                j++;\n        }\n        cout<<ret<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\n\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\n\nstruct Edge {\n  int to;\n  int cost;\n  Edge(int to_, int cost_) {\n    to = to_; cost = cost_;\n  }\n};\n\nint N, M, S1, S2, T;\nint x = 0; // now magic cost\nvector<Edge> graph[1001];\n\nint dij(int s)\n{\n  bool used[1001] = {0};\n  priority_queue<Pii, vector<Pii>, greater<Pii> > q;\n  q.push(Pii(0, s));\n\n  while ( !q.empty() ) {\n    Pii p = q.top(); q.pop();\n    int c = p.fr, n = p.sc;\n\n    if ( n == T ) return c;\n\n    if ( used[n] ) continue;\n    used[n] = true;\n\n    Rep(i, graph[n].size()) {\n      int next = graph[n][i].to, cost = graph[n][i].cost;\n      if ( used[next] ) continue;\n      if ( cost == -1 ) {\n\tq.push(Pii(c + x, next));\n      } else {\n\tq.push(Pii(c + cost, next));\n      }\n    }\n  }\n  \n}\n\nsigned main()\n{\n  while ( cin >> N >> M >> S1 >> S2 >> T, N | M | S1 | S2 | T ) {\n    Rep(i, 1001) graph[i].clear();\n    x = 0;\n    S1--; S2--; T--;\n  \n    Rep(i, M) {\n      int a, b;\n      string s;\n      cin >> a >> b >> s;\n      a--; b--;\n      if ( s == \"x\" ) {\n\tgraph[a].pb(Edge(b, -1));\n\tgraph[b].pb(Edge(a, -1));\n      } else {\n\tint c = stoi(s);\n\tgraph[a].pb(Edge(b, c));\n\tgraph[b].pb(Edge(a, c));\n      }\n    }\n\n    /* Rep(i, N) {\n       Rep(j, graph[i].size()) cout << graph[i][j].to << \" : \" << graph[i][j].cost << \" \";\n       cout << endl;\n       }*/\n\n    int l = 0, r = 1e9;\n    bool flag; // S1_cost > S2_cost : true  else : false\n    int S1_cost = dij(S1), S2_cost = dij(S2);\n\n    if( S1_cost > S2_cost ) flag = true;\n    else flag = false;\n  \n    while( r - l > 2 ) {\n      int mid = (l + r) / 2;\n      x = mid;\n      S1_cost = dij(S1); S2_cost = dij(S2);\n      //cout << S1_cost << \" \" << S2_cost << endl;\n      if ( (S1_cost > S2_cost) == flag ) l = mid;\n      else r = mid;\n    }\n\n    int ans;\n    x = l;\n    ans = abs(dij(S1) - dij(S2));\n    x = r;\n    ans = min(ans, abs(dij(S1) - dij(S2)));\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<time.h>\n#define Msn(x,y) (memset((x),0,sizeof((x[0]))*(y+1)))\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x,y) (memset((x),0x7f,sizeof((x[0]))*(y+3)))\n#define fuck(x) cerr << #x << \" <- \" << x << endl\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\nint n,m;\nconst int maxn=2222;\nstruct node\n{\n    int v;\n    ll w;\n    bool operator<(const node a)const{\n    return w>a.w;\n\t}\n};\nvector<node>g[maxn];\nint T,s1,s2;\npriority_queue<node>q;\nbool vis[maxn];\nll dis[maxn];\nll check(ll x)\n{\n    q.push((node){T,0});\n    for(int i=0;i<=n;i++)dis[i]=1e18,vis[i]=0;\n    while(!q.empty())\n    {\n        node now=q.top();\n        q.pop();\n        if(vis[now.v])continue;\n        vis[now.v]=1;\n        dis[now.v]=now.w;\n        int u=now.v;\n        int v;\n        ll w;\n        for(int i=0;i<g[u].size();i++)\n        {\n            if(g[u][i].w==-1)w=now.w+x;\n            else w=now.w+g[u][i].w;\n            v= g[u][i].v;\n            if(!vis[v])\n            {\n                q.push((node){v,w});\n            }\n        }\n    }\n   // fuck(dis[s1]);\n  //  fuck(dis[s2]);\n    ll ans=dis[s1]-dis[s2];\n    if(ans<0)ans=-ans;\n    return ans;\n}\nint main()\n{\n    while(~scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&T))\n    {\n        if(n==0&&m==0)break;\n        for(int i=0;i<=n;i++)g[i].clear();\n        int u,v,w;\n        char s[50];\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%s\",&u,&v,s);\n            if(s[0]=='x')\n            {\n                w=-1;\n            }\n            else\n            {\n                w=0;\n                int len=strlen(s);\n                for(int i=0;i<len;i++)\n                {\n                    w=w*10+s[i]-'0';\n                }\n            }\n            g[u].push_back((node){v,w});\n            g[v].push_back((node){u,w});\n        }\n    ll l=0,r=2*1e12;\n    ll a=check(r);\n    if(a==0)\n    {\n        printf(\"0\\n\");\n    }\n    else\n    {\n        if(a<0)a=-1;\n        if(a>0)a=1;\n    while(l<r)\n    {\n        ll mid=(l+r)/2+1;\n     //   fuck(mid);\n      //  fuck(check(mid));\n     //   getchar();\n        if(check(mid)*a>=0)r=mid-1;\n        else l=mid;\n    }\n    printf(\"%lld\\n\",min(check(l),check(l+1)));\n    }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tint time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tint value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoi(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<int>>memo(N, vector<int>(102,1e9));\n\t\tfor (int i = 0; i < 102; ++i) {\n\t\t\tmemo[T][i] = 0;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tfor (int ax = now_x + 1; ax < 102; ++ax) {\n\t\t\t\t\t\t\tmemo[e.first][ax] = min(memo[e.first][ax],next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tfor (int ax = now_x; ax < 102; ++ax) {\n\t\t\t\t\t\t\tmemo[e.first][ax] = min(memo[e.first][ax],next_time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e9) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e9) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e18));\n\t\tfor (int i = 0; i < cht1.ls.size()-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < cht2.ls.size() - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tif (int(l) == int(r))continue;\n\t\t\telse {\n\t\t\t\tlong long int al = l;\n\t\t\t\tlong long int ar = r;\n\t\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\t\tans = min(ans, abs(lvalue1 - rvalue1));\n\t\t\t\t\t}\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx +1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx -1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx  + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 10000000000000000LL\n\nstruct state{\n  int v,xcnt;\n  ll dist;\n};\nbool operator<(const state& a,const state& b){\n  return a.dist > b.dist;\n}\nstruct func{\n  ll a,b,l,r;\n};\n\nint N,M,S[2],T;\nvector<P> g[1001];\nll d[1001][101];\nvector<func> fs[2];\nint sz[2];\nbool dame[2][101];\n\nint main(){\n  while(1){\n    cin>>N>>M>>S[0]>>S[1]>>T;\n    if(N==0)break;\n    rep(i,N)g[i].clear();\n    fs[0].clear();fs[1].clear();\n    S[0]--;S[1]--;T--;\n    rep(i,M){\n      int a,b;\n      string c;\n      cin>>a>>b>>c;\n      a--;b--;\n      if(c==\"x\"){\n        g[a].push_back(P(b,-1));\n        g[b].push_back(P(a,-1));        \n      }else{\n        g[a].push_back(P(b,stoi(c)));\n        g[b].push_back(P(a,stoi(c)));\n      }\n    }\n    rep(s,2){\n      rep(i,N)rep(j,101)d[i][j]=INF;\n      priority_queue<state> que;\n      que.push((state){S[s],0,0});\n      while(que.size()){\n        state crt=que.top(); que.pop();\n        if(d[crt.v][crt.xcnt]!=INF)continue;\n        d[crt.v][crt.xcnt]=crt.dist;\n        for(P p : g[crt.v]){\n          if(p.se==-1){\n            que.push((state){(int)p.fi,crt.xcnt+1,crt.dist});\n          }else{\n            que.push((state){(int)p.fi,crt.xcnt,crt.dist+p.se});\n          }\n        }\n      }\n      rep(j,101)if(d[T][j]!=INF)fs[s].push_back((func){j,d[T][j],0LL,INF});\n      sz[s]=fs[s].size();\n      rep(i,sz[s])dame[s][i]=false;\n      rep(i,sz[s])rep(j,sz[s]){\n        if(i==j)continue;\n        if(fs[s][i].a>=fs[s][j].a&&fs[s][i].b>=fs[s][j].b)dame[s][i]=true;\n      }\n      rep(i,sz[s])rep(j,sz[s]){\n        if(i==j||dame[s][i]||dame[s][j])continue;\n        if(fs[s][i].a<fs[s][j].a){\n          maxch(fs[s][i].l,(fs[s][i].b-fs[s][j].b+fs[s][j].a-fs[s][i].a-1)/(fs[s][j].a-fs[s][i].a));\n        }else{\n          minch(fs[s][i].r,(fs[s][j].b-fs[s][i].b)/(fs[s][i].a-fs[s][j].a));\n        }\n      }\n    }\n    ll res=INF;\n    rep(i,sz[0])rep(j,sz[1]){\n      if(dame[0][i]||dame[1][j])continue;\n      ll l=max(fs[0][i].l,fs[1][j].l);\n      ll r=min(fs[0][i].r,fs[1][j].r);\n      if(l>r)continue;\n      ll a=fs[0][i].a-fs[1][j].a;\n      ll b=fs[0][i].b-fs[1][j].b;\n      if(a==0){\n        minch(res,abs(b));\n        continue;\n      }\n      if(a<0){\n        a=-a; b=-b;\n      }\n      ll mn1=(-b)/a,mn2=(-b+a-1)/a;\n      if(l<=mn1&&mn1<=r)minch(res,abs(a*mn1+b));\n      if(l<=mn2&&mn2<=r)minch(res,abs(a*mn2+b));\n      minch(res,abs(a*l+b));\n      minch(res,abs(a*r+b));\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,long long int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tlong long int value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoll(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t//\tif (N != 103)continue;\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e18));\n\t\tmemo[T][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst long long int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)continue;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e17) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e17) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e15));\n\t\tassert(!cht1.ls.empty() && !cht2.ls.empty());\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tassert(pb.first != pa.first);\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tlong long int al = l;\n\t\t\tlong long int ar = r;\n\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\tans = min(ans, abs(lvalue1 - lvalue2));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\t/*if (ans == 2) {\n\t\t\tfor (auto e : edges) {\n\t\t\t\tint a = e.size();\n\t\t\t\tcout << a << endl;\n\t\t\t}\n\t\t}*/\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nstruct data\n{\n    int v;\n    int next;\n    long long w;\n}edge[100010];\n\nint head[1010];\nint tot=0;\nint n,m;\nint s1,s2,t;\nbool used[1010][110];\nlong long dis[1010][110];\nstruct data1\n{\n    int x;\n    int y;\n    int z;\n};\n\nvoid addedge(int u,int v,int w)\n{\n    edge[tot].v=v;\n    edge[tot].w=w;\n    edge[tot].next=head[u];\n    head[u]=tot++;\n}\n\nint spfa()\n{\n    memset(used,false,sizeof(used));\n    int i,j,k;\n    queue<data1> que;\n    for(i=1;i<=n;i++)\n        for(j=0;j<=100;j++)\n            dis[i][j]=(long long)1e18;\n    dis[t][0]=0;\n    used[t][0]=true;\n    data1 tmp;\n    tmp.x=t;\n    tmp.y=0;\n    que.push(tmp);\n    while(!que.empty())\n    {\n        data1 uu=que.front();\n        que.pop();\n        int u=uu.x;\n        int y=uu.y;\n        for(i=head[u];i!=-1;i=edge[i].next)\n        {\n            int v=edge[i].v;\n            if(v==uu.z)\n                continue;\n            long long w=edge[i].w;\n            if(w==-1)\n            {\n                if(dis[u][y]<dis[v][y+1])\n                {\n                    dis[v][y+1]=dis[u][y];\n                    if(!used[v][y+1])\n                    {\n                        data1 tmp;\n                        tmp.x=v;\n                        tmp.y=y+1;\n                        tmp.z=u;\n                        que.push(tmp);\n                        used[v][y+1]=true;\n                    }\n                }\n            }\n            else\n            {\n                if(dis[u][y]+w<dis[v][y])\n                {\n                    dis[v][y]=dis[u][y]+w;\n                    if(!used[v][y])\n                    {\n                        data1 tmp;\n                        tmp.x=v;\n                        tmp.y=y;\n                        tmp.z=u;\n                        que.push(tmp);\n                        used[v][y]=true;\n                    }\n                }\n            }\n        }\n        used[u][y]=false;\n    }\n    return 0;\n}\n\nint main()\n{\n    long long i,j,k;\n    while(cin>>n>>m>>s1>>s2>>t)\n    {\n        if(n+m+s1+s2+t==0)\n            break;\n        tot=0;\n        memset(head,-1,sizeof(head));\n        for(i=1;i<=m;i++)\n        {\n            int u,v,w;\n            scanf(\"%d%d\",&u,&v);\n            char s[20];\n            scanf(\"%s\",s+1);\n            if(s[1]=='x')\n            {\n                addedge(u,v,-1);\n                addedge(v,u,-1);\n            }\n            else\n            {\n                w=0;\n                for(j=1;j<=strlen(s+1);j++)\n                    w=w*10+s[j]-'0';\n                addedge(u,v,w);\n                addedge(v,u,w);\n            }\n        }\n        spfa();\n        long long ans11=(long long)1e18;\n        long long ans12=(long long)1e18;\n        long long ans21=(long long)1e18;\n        long long ans22=(long long)1e18;\n        for(i=0;i<=100;i++)\n        {\n            if(dis[s1][i]<ans11)\n            {\n                ans12=ans11;\n                ans11=dis[s1][i];\n            }\n            else if(dis[s1][i]==ans11)\n                ans12=ans11;\n            else\n                ans12=min(ans12,dis[s1][i]);\n            if(dis[s2][i]<ans21)\n            {\n                ans22=ans21;\n                ans21=dis[s2][i];\n            }\n            else if(dis[s2][i]==ans21)\n                ans22=ans21;\n            else\n                ans22=min(ans22,dis[s2][i]);\n        }\n        long long ans=(long long)1e18;\n        for(i=0;i<=100;i++)\n            for(j=0;j<=100;j++)\n                if(dis[s1][i]==ans11&&dis[s2][j]==ans21)\n                {\n                    long long tmp1=ans12-ans11;\n                    long long tmp2=ans22-ans21;\n                    //cout<<tmp1<<\" \"<<tmp2<<endl;\n                    long long tmp=abs(dis[s1][i]-dis[s2][j]);\n                    ans=min(ans,abs(dis[s1][i]-dis[s2][j]));\n                    if(dis[s1][i]<dis[s2][j])\n                    {\n                        if(i>j)\n                        {\n                            if(j==0)\n                            {\n                                long long tsp=tmp1/i;\n                                long long t1=tmp/i;\n                                if(t1<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+t1*i-dis[s2][j]-t1*j));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+tsp*i-dis[s2][j]-tsp*j));\n                                long long t2=(tmp+i-1)/i;\n                                if(t2<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+t2*i-dis[s2][j]-t2*j));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+tsp*i-dis[s2][j]-tsp*j));\n                            }\n                            else\n                            {\n                                long long tsp=min(tmp1/i,tmp2/j);\n                                long long t1=tmp/(i-j);\n                                if(t1<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+t1*i-dis[s2][j]-t1*j));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+tsp*i-dis[s2][j]-tsp*j));\n                                long long t2=(tmp+i-j-1)/(i-j);\n                                if(t2<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+t2*i-dis[s2][j]-t2*j));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+tsp*i-dis[s2][j]-tsp*j));\n                            }\n                        }\n                    }\n                    else if(dis[s1][i]==dis[s2][j])\n                    {\n                        ans=0;\n                        break;\n                    }\n                    else\n                    {\n                        if(j>i)\n                        {\n                            if(i==0)\n                            {\n                                long long tsp=tmp2/j;\n                                long long t1=tmp/j;\n                                if(t1<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+i*t1-dis[s2][j]-j*t1));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+i*tsp-dis[s2][j]-j*tsp));\n                                long long t2=(tmp+j-1)/j;\n                                if(t2<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+i*t2-dis[s2][j]-j*t2));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+i*tsp-dis[s2][j]-j*tsp));\n                            }\n                            else\n                            {\n                                long long tsp=min(tmp2/j,tmp1/i);\n                                long long t1=tmp/(j-i);\n                                if(t1<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+i*t1-dis[s2][j]-j*t1));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+i*tsp-dis[s2][j]-j*tsp));\n                                long long t2=(tmp+j-i-1)/(j-i);\n                                if(t2<=tsp)\n                                    ans=min(ans,abs(dis[s1][i]+i*t2-dis[s2][j]-j*t2));\n                                else\n                                    ans=min(ans,abs(dis[s1][i]+i*tsp-dis[s2][j]-j*tsp));\n                            }\n                        }\n                    }\n                }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[j][S1]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(INF/100);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<time.h>\n#define Msn(x,y) (memset((x),0,sizeof((x[0]))*(y+1)))\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x,y) (memset((x),0x7f,sizeof((x[0]))*(y+3)))\n#define fuck(x) cerr << #x << \" <- \" << x << endl\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\nint n,m;\nconst int maxn=2222;\nstruct node\n{\n    int v;\n    ll w;\n};\nvector<node>g[maxn];\nint T,s1,s2;\nbool inq[maxn];\nll dis[maxn][101];\nvoid solve()\n{\n    queue<int>q;\n    memset(dis,-1,sizeof(dis));\n    msn(inq);\n    q.push(T);\n    dis[T][0]=0;\n    inq[T]=1;\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        inq[now]=0;\n        for(int i=0;i<g[now].size();i++)\n        {\n            int nxt=g[now][i].v;\n            if(g[now][i].w==-1)\n            {\n                for(int ii=0;ii<100;ii++)\n                {\n                    if(dis[now][ii]!=-1)\n                    {\n                        if(dis[nxt][ii+1]==-1||dis[now][ii]<dis[nxt][ii+1])\n                        {\n                            dis[nxt][ii+1]=dis[now][ii];\n                            if(!inq[nxt])\n                            {\n                                q.push(nxt);\n                                inq[nxt]=1;\n                            }\n                        }\n                    }\n                }\n            }\n            else\n            {\n                for(int ii=0;ii<=100;ii++)\n                {\n                    if(dis[now][ii]!=-1)\n                    {\n                        if(dis[nxt][ii+1]==-1||dis[nxt][ii]>dis[now][ii]+g[now][i].w)\n                        {\n                            dis[nxt][ii]=dis[now][ii]+g[now][i].w;\n                            if(!inq[nxt])\n                            {\n                                q.push(nxt);\n                                inq[nxt]=1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct node1\n{\n    ll a,b;\n    ll l,r;\n};\nvector<node1>p[2];\nll Abs(ll x)\n{\n    return x<0?-x:x;\n}\nll check(int i,int j)\n{\n    if(p[0][i].l>p[0][i].r)return 1e12+7;\n    if(p[1][j].l>p[1][j].r)return 1e12+7;\n    ll l=max(p[0][i].l,p[1][j].l);\n    ll r=min(p[0][i].r,p[1][j].r);\n    if(l>r)return 1e12+7;\n    ll ans=1e12+7;\n    ans=min(ans,Abs((p[0][i].a-p[1][j].a)*l+p[0][i].b-p[1][j].b));\n    ans=min(ans,Abs((p[0][i].a-p[1][j].a)*r+p[0][i].b-p[1][j].b));\n    if(p[0][i].a!=p[1][j].a)\n    {\n        ll solu=Abs(p[0][i].b-p[1][j].b)/Abs((p[0][i].a-p[1][j].a));\n        if(solu<=r&&solu>=l)\n        {\n            ans=min(ans,Abs((p[0][i].a-p[1][j].a)*solu+p[0][i].b-p[1][j].b));\n        }\n        solu++;\n        if(solu<=r&&solu>=l)\n        {\n            ans=min(ans,Abs((p[0][i].a-p[1][j].a)*solu+p[0][i].b-p[1][j].b));\n        }\n    }\n    return ans;\n}\nll getright(int wh,int now)\n{\n    ll l=0,r=2*1e12+7;\n    while(l<r)\n    {\n        ll mid=(l+r)/2+1;\n        ll me=p[wh][now].a*mid+p[wh][now].b;\n        bool flag =1;\n        for(int i=0;i<now;i++)\n        {\n            if(p[wh][i].a*mid+p[wh][i].b<me)flag=0;\n        }\n        if(flag)l=mid;\n        else r=mid-1;\n    }\n    return l;\n}\nll getleft(int wh,int now)\n{\n    ll l=0,r=2*1e12+7;\n    while(l<r)\n    {\n        ll mid=(l+r)/2;\n        ll me=p[wh][now].a*mid+p[wh][now].b;\n        bool flag =1;\n        for(int i=now+1;i<p[wh].size();i++)\n        {\n            if(p[wh][i].a*mid+p[wh][now].b<me)flag=0;\n        }\n        if(flag==0)l=mid+1;\n        else r=mid;\n    }\n    return l;\n}\nint main()\n{\n    while(~scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&T))\n    {\n        p[0].clear();\n        p[1].clear();\n        if(n==0&&m==0)break;\n        for(int i=0;i<=n;i++)g[i].clear();\n        int u,v,w;\n        char s[50];\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d%s\",&u,&v,s);\n            if(s[0]=='x')\n            {\n                w=-1;\n            }\n            else\n            {\n                w=0;\n                int len=strlen(s);\n                for(int i=0;i<len;i++)\n                {\n                    w=w*10+s[i]-'0';\n                }\n            }\n            g[u].push_back((node){v,w});\n            g[v].push_back((node){u,w});\n        }\n        solve();\n  /*      ll minn;\n        minn=1e18+7;\n       // fuck(dis[3][1]);\n        for(int i=0;i<=100;i++)\n        {\n            if(dis[s1][i]>=0&&dis[s1][i]<minn)\n            {\n                p[0].push_back((node1){i,dis[s1][i],0,0});\n              //  fuck(i);\n             //   fuck(dis[s1][i]);\n                minn=dis[s1][i];\n            }\n        }\n        minn=1e18+7;\n        for(int i=0;i<=100;i++)\n        {\n            if(dis[s2][i]>=0&&dis[s2][i]<minn)\n            {\n                p[1].push_back((node1){i,dis[s2][i],0,0});\n                minn=dis[s2][i];\n            }\n        }\n        for(int j=0;j<2;j++)\n        for(int i=0;i<p[j].size();i++)\n        {\n            p[j][i].l=getleft(j,i);\n            p[j][i].r=getright(j,i);\n        }\n        ll ans=1e12+7;\n\n        for(int i=0;i<p[0].size();i++)\n        {\n            for(int j=0;j<p[1].size();j++)\n            {\n                ans=min(ans,check(i,j));\n            }\n        }\n        printf(\"%lld\\n\",ans);*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nvector<pair<int,int> >g[1100];\nchar in[20];\nlong long ijk[1100][110];\nint v[1100][110];\nlong long ABS(long long a){return max(a,-a);}\nint main(){\n\tint a,b,c,d,e;\n\twhile(scanf(\"%d%d%d%d%d\",&a,&b,&c,&d,&e),a){\n\t\tc--;d--;e--;\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;scanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tint cost;\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[0]=='x')cost=-1;\n\t\t\telse sscanf(in,\"%d\",&cost);\n\t\t\tg[p].push_back(make_pair(q,cost));\n\t\t\tg[q].push_back(make_pair(p,cost));\n\t\t}\n\t\tfor(int i=0;i<1100;i++)for(int j=0;j<110;j++){\n\t\t\tijk[i][j]=9999999999999999LL;\n\t\t\tv[i][j]=0;\n\t\t}\n\t\tpriority_queue<pair<long long,pair<int,int> > >Q;\n\t\tQ.push(make_pair(0,make_pair(e,0)));\n\t\tijk[e][0]=0;\n\t\twhile(Q.size()){\n\t\t\tlong long cost=-Q.top().first;\n\t\t\tint at=Q.top().second.first;\n\t\t\tint x=Q.top().second.second;\n\t\t\tQ.pop();\n\t\t\tif(v[at][x])continue;\nif(x>100)continue;\n\t\t\tv[at][x]=1;\n//printf(\"%d %d %lld\\n\",at,x,cost);\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tint to=g[at][i].first;\n\t\t\t\tint tx=x;\n\t\t\t\tlong long tmp=cost;\n\t\t\t\tif(g[at][i].second==-1){\n\t\t\t\t\ttx++;\n\t\t\t\t}else tmp+=g[at][i].second;\n\t\t\t\tif(!v[to][tx]&&ijk[to][tx]>tmp){\n\t\t\t\t\tijk[to][tx]=tmp;\n//printf(\"%lld %d %d\\n\",tmp,to,tx);\n\t\t\t\t\tQ.push(make_pair(-tmp,make_pair(to,tx)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t//\tfor(int i=0;i<10;i++)printf(\"%lld %lld\\n\",ijk[c][i],ijk[d][i]);\n\t\tlong long ret=99999999999999999LL;\n\t\tfor(int i=0;i<110;i++)for(int j=0;j<110;j++){\n\t\t//\tif(i&&ijk[c][i]>=ijk[c][i-1])continue;\n\t\t//\tif(j&&ijk[d][j]>=ijk[d][j-1])continue;\n\t\t\tbool dame=false;\n\t\t\tfor(int k=0;k<i;k++)if(ijk[c][k]<=ijk[c][i])dame=true;\n\t\t\tfor(int k=0;k<j;k++)if(ijk[d][k]<=ijk[d][j])dame=true;\n\t\t\tif(dame)continue;\n\t\t\tif(ijk[c][i]>=9999999999999999LL)continue;\n\t\t\tif(ijk[d][j]>=9999999999999999LL)continue;\n \n\t\t\tlong long L=0;\n\t\t\tlong long R=9999999999999LL;\n \n\t\t\tfor(int k=0;k<110;k++){\n\t\t\t\tif(i!=k&&ijk[c][k]!=9999999999999999LL){\n\t\t\t\t\tlong long t1=ABS(ijk[c][k]-ijk[c][i]);\n\t\t\t\t\tlong long c1=t1/ABS(i-k);\n\t\t\t\t\t\n\t\t\t\t\tif(k<i){\n\t\t\t\t\t\tif(ijk[c][k]>=ijk[c][i])R=min(R,c1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(ijk[c][k]<=ijk[c][i])L=max(L,c1+(t1%ABS(i-k)?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(j!=k&&ijk[d][k]!=9999999999999999LL){\n\t\t\t\t\tlong long t1=ABS(ijk[d][k]-ijk[d][j]);\n\t\t\t\t\tlong long c1=t1/ABS(j-k);\n\t\t\t\t\tif(k<j){\n\t\t\t\t\t\tif(ijk[d][k]>=ijk[d][j])R=min(R,c1);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(ijk[d][k]<=ijk[d][j])L=max(L,c1+(t1%ABS(j-k)?1:0));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tprintf(\"%d %d: %lld %lld %lld\\n\",i,j,L,R,ret);\n\t\t\tif(L>R)continue;\n\t\t\t\n\t\t\tret=min(ret,ABS(L*i+ijk[c][i]-L*j-ijk[d][j]));\n\t\t\tret=min(ret,ABS(R*i+ijk[c][i]-R*j-ijk[d][j]));\n\t\t\tif(i!=j){\n\t\t\t\tlong long t2=ABS(ijk[c][i]-ijk[d][j]);\n\t\t\t\tlong long c2=t2/ABS(i-j);\n\t\t\t\tif(L<=c2&&c2<=R)ret=min(ret,ABS(c2*i+ijk[c][i]-c2*j-ijk[d][j]));\n\t\t\t\tif(L<=c2+1&&c2+1<=R)ret=min(ret,ABS(c2*i+i+ijk[c][i]-c2*j-j-ijk[d][j]));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[i][S1]-dist[j][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[i][S2]-dist[j][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(lis.back()+1);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 59;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n  \n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    vector< edge > G[1000];\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n    for(auto &cost : latte) ret = min(ret, get(cost - 1));\n    for(auto &cost : latte) ret = min(ret, get(cost));\n    for(auto &cost : latte) ret = min(ret, get(cost + 1));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\n\nusing T = pair<ll, pair<int,int>> ;\nvoid solve(int n){\n    int m,s1,s2,t;\n    cin>>m>>s1>>s2>>t;\n    --s1;--s2;--t;\n    vector<vector<pair<int,ll>>> v(n);\n    rep(i,m){\n        int x,y;\n        cin>>x>>y;\n        --x;--y;\n        string s;\n        cin>>s;\n        if(s==\"x\"){\n            v[x].emplace_back(y,-1);\n            v[y].emplace_back(x,-1);\n        }\n        else {\n            int z=stoi(s);\n            v[x].emplace_back(y,z);\n            v[y].emplace_back(x,z);\n        }\n    }\n    vector<vector<ll>> dist(n,vector<ll>(111,longinf));\n    dist[t][0]=0;\n    priority_queue<T,vector<T>, greater<T>> que;\n    que.push({0,{t,0}});\n    while(que.size()){\n        auto p = que.top();que.pop();\n        ll d=p.first, cur=p.second.first,cnt=p.second.second;\n        if(dist[cur][cnt]<d)continue;\n        for(auto to : v[cur]){\n            int nxt=to.first, cost=to.second;\n            if(cost==-1){\n                if(cnt<=100&&d<dist[nxt][cnt+1]){\n                    dist[nxt][cnt+1]=d;\n                    que.push({d,{nxt,cnt+1}});\n                }\n            }\n            else {\n               if(d+cost<dist[nxt][cnt]){\n                    dist[nxt][cnt]=d+cost;\n                    que.push({d+cost,{nxt,cnt}});\n                } \n            }\n        }\n    }\n\n    vector<pair<ll,ll>> r1(111,{0,longinf}),r2(111,{0,longinf});\n    rep(i,101){\n        REP(j,i+1,101){\n            if(dist[s1][i]<dist[s1][j]){\n                r1[j]={0,-1};continue;\n            }\n            ll x = (dist[s1][i]-dist[s1][j])/(j-i);\n            r1[j].second=min(r1[j].second, x);\n            x = (dist[s1][i]-dist[s1][j]+j-i-1)/(j-i);\n            r1[i].first = max(r1[i].first, x);\n        }\n    }\n\n    rep(i,101){\n        REP(j,i+1,101){\n            if(dist[s2][i]<dist[s2][j]){\n                r2[j]={0,-1};continue;\n            }\n            ll x = (dist[s2][i]-dist[s2][j])/(j-i);\n            r2[j].second=min(r2[j].second, x);\n            x = (dist[s2][i]-dist[s2][j]+j-i-1)/(j-i);\n            r2[i].first = max(r2[i].first, x);\n        }\n    }\n    ll ans=longinf;\n    rep(i,101)rep(j,101){\n        ll l=max(r1[i].first,r2[j].first), r=min(r1[i].second, r2[j].second);\n        if(l>r||dist[s1][i]==longinf||dist[s2][j]==longinf)continue;\n        ll ret=abs(dist[s1][i]+i*l-dist[s2][j]-j*l);\n        ret=min(abs(dist[s1][i]+i*r-dist[s2][j]-j*r),ret);\n        if(i!=j){\n            ll x = (dist[s1][i]-dist[s2][j])/(j-i);\n            if(l<=x&&x<=r){\n                ret=min(abs(dist[s1][i]+i*x-dist[s2][j]-j*x),ret);\n            }\n            ++x;\n            if(l<=x&&x<=r){\n                ret=min(abs(dist[s1][i]+i*x-dist[s2][j]-j*x),ret);\n            }\n            x-=2;\n            if(l<=x&&x<=r){\n                ret=min(abs(dist[s1][i]+i*x-dist[s2][j]-j*x),ret);\n            }\n        }\n        ans=min(ans,ret);\n    }\n    cout<<ans<<endl;\n}\nint main(){\n    int n;\n    while(cin>>n,n!=0)solve(n);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//      whn6325689\n//      Mr.Phoebe\n//      http://blog.csdn.net/u013007900\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <climits>\n#include <complex>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n\nusing namespace std;\n\n#define eps 1e-9\n#define PI acos(-1.0)\n#define INF 0x3f3f3f3f\n#define LLINF 1LL<<50\n#define speed std::ios::sync_with_stdio(false);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef complex<ld> point;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef vector<int> vi;\n\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define CPY(x,y) memcpy(x,y,sizeof(x))\n#define clr(a,x,size) memset(a,x,sizeof(a[0])*(size))\n#define cpy(a,x,size) memcpy(a,x,sizeof(a[0])*(size))\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define lowbit(x) (x&(-x))\n\n#define MID(x,y) (x+((y-x)>>1))\n#define ls (idx<<1)\n#define rs (idx<<1|1)\n#define lson ls,l,mid\n#define rson rs,mid+1,r\n\ntemplate<class T>\ninline bool read(T &n)\n{\n    T x = 0, tmp = 1;\n    char c = getchar();\n    while((c < '0' || c > '9') && c != '-' && c != EOF) c = getchar();\n    if(c == EOF) return false;\n    if(c == '-') c = getchar(), tmp = -1;\n    while(c >= '0' && c <= '9') x *= 10, x += (c - '0'),c = getchar();\n    n = x*tmp;\n    return true;\n}\ntemplate <class T>\ninline void write(T n)\n{\n    if(n < 0)\n    {\n        putchar('-');\n        n = -n;\n    }\n    int len = 0,data[20];\n    while(n)\n    {\n        data[len++] = n%10;\n        n /= 10;\n    }\n    if(!len) data[len++] = 0;\n    while(len--) putchar(data[len]+48);\n}\n//-----------------------------------\n\nll n,m,s[3],t;\nbool vis[1010][111];\nll dis[1010][111];\ndouble val[100010];\nchar str[22];\nstruct Edge\n{\n    ll to,next,w;\n} e[40010];\nint head[1010],tot,mag,num;\n\nvoid init()\n{\n    CLR(head,-1);\n    tot=mag=num=0;\n}\n\nvoid addedge(ll u,ll v,ll w)\n{\n    e[tot].to=v;\n    e[tot].w=w;\n    e[tot].next=head[u];\n    head[u]=tot++;\n}\n\nvoid spfa(ll s)\n{\n    queue<pll> q;\n    CLR(dis,-1);\n    CLR(vis,0);\n    while(!q.empty())   q.pop();\n    dis[s][0]=0;\n    vis[s][0]=1;\n    q.push(mp(s,0));\n    while(!q.empty())\n    {\n        pll tmp=q.front();\n        q.pop();\n        ll u=tmp.first,tim=tmp.second,v;\n        vis[u][tim]=false;\n        for(int i=head[u]; ~i; i=e[i].next)\n        {\n            v=e[i].to;\n            ll k,w;\n            if(e[i].w==-1)  w=0,k=1;\n            else    w=e[i].w,k=0;\n            if(tim+k<=mag && (dis[v][tim+k]==-1 || dis[v][tim+k]>dis[u][tim]+w))\n            {\n                dis[v][tim+k]=dis[u][tim]+w;\n                if(!vis[v][tim+k])\n                {\n                    vis[v][tim+k]=true;\n                    q.push(mp(v,tim+k));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    freopen(\"data.txt\",\"r\",stdin);\n    ll u,v,w;\n    while(read(n)&&read(m)&&read(s[1])&&read(s[2])&&read(t)&&(n+m))\n    {\n        init();\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d %d %s\",&u,&v,&str);\n            if(str[0]=='x')\n            {\n                addedge(u,v,-1);\n                addedge(v,u,-1);\n                mag++;\n            }\n            else\n            {\n                sscanf(str,\"%lld\",&w);\n                addedge(u,v,w);\n                addedge(v,u,w);\n            }\n        }\n        spfa(t);\n        val[num++]=0;\n        for(int i=1; i<=2; i++)\n        {\n            for(int j=0; j<mag; j++)\n            {\n                ll minn=dis[s[i]][j];\n                if(minn==-1)    continue;\n                for(int k=j+1; k<=mag; k++)\n                {\n                    ll maxx=dis[s[i]][k];\n                    if(maxx==-1)    continue;\n                    double w=1.0*(maxx-minn)/(j-k);\n                    if(w>0) val[num++]=w;\n                }\n            }\n        }\n        for(int j=0; j<=mag; j++)\n        {\n            ll minn=dis[s[1]][j];\n            if(minn==-1)    continue;\n            for(int k=0; k<=mag; k++)\n            {\n                if(j==k)    continue;\n                ll maxx=dis[s[2]][k];\n                if(maxx==-1)    continue;\n                double w=1.0*(maxx-minn)/(j-k);\n                if(w>0) val[num++]=w;\n            }\n        }\n        if(num>100000)  while(1){}\n        ll mi[3],ans=LLINF;\n        for(int i=0; i<num; i++)\n        {\n            for(int j=1; j<=2; j++)\n            {\n                mi[j]=LLINF;\n                for(int k=0; k<=mag; k++)\n                    if(~dis[s[j]][k])\n                    {\n                        mi[j]=min(mi[j],dis[s[j]][k]+k*(ll)(val[i]+eps));\n                        mi[j]=min(mi[j],dis[s[j]][k]+k*(ll)(val[i]+eps+1));\n                    }\n            }\n            ans=min(ans,abs(mi[1]-mi[2]));\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{\n    int dst, cost;\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nint N, M, S1, S2, T;\nint MB;\nconst LL INF = 1e18;\nvector<LL> calc_cost(int s, int t) {\n    LL dist[1000][101] = {};\n    typedef tuple<LL, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> que;\n    REP(i, N) REP(j, MB+1) dist[i][j] = INF;\n    dist[s][0] = 0;\n    que.push(TP(0, s, 0));\n    while(!que.empty()) {\n        int d, u, c;\n        tie(d, u, c) = que.top(); que.pop();\n        for(Edge e : G[u]) {\n            const int nu = e.dst;\n            const int nc = c + (e.cost == -1 ? 1 : 0);\n            const LL nd = d + (e.cost == -1 ? 0 : e.cost);\n            if(dist[nu][nc] > nd) {\n                dist[nu][nc] = nd;\n                que.push(TP(nd, nu, nc));\n            }\n        }\n    }\n    vector<LL> res(MB+1);\n    REP(i, MB+1) res[i] = dist[t][i];\n    return res;\n}\n// O(N)\nLL get(vector<LL> cs, LL X) {\n    LL res = cs[0];\n    for(int i = 1; i < cs.size(); i++) {\n        res = min(res, cs[i] + i * X);\n    }\n    return res;\n}\n// O(N)\nLL calc_diff(vector<LL> cs1, vector<LL> cs2, LL X) {\n    LL cost1 = get(cs1, X);\n    LL cost2 = get(cs2, X);\n    return abs(cost1 - cost2);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> M >> S1 >> S2 >> T && N > 0) {\n        MB = 0;\n        S1--; S2--; T--;\n        G.resize(N);\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            string ws;\n            cin >> ws;\n            int w;\n            if(ws == \"x\") {\n                w = -1;\n                MB++;\n            } else {\n                w = stoi(ws);\n            }\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n        }\n        vector<LL> cs1 = calc_cost(S1, T);\n        vector<LL> cs2 = calc_cost(S2, T);\n        LL ans = calc_diff(cs1, cs2, 0);\n        REP(i, cs1.size()) REP(j, cs1.size()) if(i < j) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs1[i] - cs1[j]) / (j-i);\n            for(int dx = -1; dx <= 1; dx++) {\n                ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        REP(i, cs2.size()) REP(j, cs2.size()) if(i < j) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs2[i] - cs2[j]) / (j-i);\n            for(int dx = -1; dx <= 1; dx++) {\n                ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            /*\n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n \nint memo1[1100][110];\nint memo2[1100][110];\nvector<pa2> G[1100];\npriority_queue<pa3,vector<pa3>,greater<pa3>> pq;\n\nint sa(int r,int t){\n\tif(r<0) return inf*10000ll;\n\tint e1=inf*10000ll,e2=inf*10000ll;\n\tfor(int i=0;i<105;i++){\n\t\te1=min(e1,i*r+memo1[t][i]);\n\t}\n\tfor(int i=0;i<105;i++){\n\t\te2=min(e2,i*r+memo2[t][i]);\n\t}\n\t\n\treturn abs(e1-e2);\n\t\n}\n\n\n   signed main(){\nint m,s1,s2,t,n;   \t\n   \twhile(1){\n   \t\tcin>>n>>m>>s1>>s2>>t;\n  \n   \t\tif(n==0) return 0;\n   \t\t\n   \t\tfor(int i=0;i<m;i++){\n   \t\t\tint y,yy;\n   \t\tcin>>y>>yy;\n   \t\t\tstring s;\n   \t\t\tcin>>s;\n   \t\t\tif(s[0]=='x'){\n   \t\t\t\t\tG[y].pb({yy,-1});\n   \t\t\t\tG[yy].pb({y,-1});\n   \t\t\t}\n   \t\t\telse{\n   \t\t\t\tint r=stoi(s);\n   \t\t\t\t\tG[y].pb({yy,r});\n   \t\t\t\tG[yy].pb({y,r});\n   \t\t\t}\n   \t\t\n   \t\t}\n   \t\tint in=inf*1000000ll;\n   \t\tfor(int i=0;i<1100;i++)for(int j=0;j<110;j++)memo1[i][j]=in,memo2[i][j]=in;\n   \t\twhile(pq.size()>0)pq.pop();\n   \t\t\tpq.push({0,0,s1});\n   \t\t// kyori kaisuu basho\n   \t\twhile(pq.size()){\n   \t\t\tpa3 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(z.y>105) continue;\n   \t\t\tif(memo1[z.z][z.y]<in) continue;\n   \t\t\tmemo1[z.z][z.y]=z.x;\n   \t\t\t\n   \t\t\tfor(auto r:G[z.z]){\n   \t\t\t\tif(r.y>=0){\n   \t\t\t\t\t\tpq.push({z.x+r.y,z.y,r.x});\n   \t\t\t\t}else{\n   \t\t\t\tpq.push({z.x,z.y+1,r.x});\n   \t\t\t\t}\n   \t\t\t\t\n   \t\t\t}\n   \t\t}\n   \t\t\n   \t\twhile(pq.size()>0)pq.pop();\n   \t\t\tpq.push({0,0,s2});\n   \t\t// kyori kaisuu basho\n   \t\twhile(pq.size()){\n   \t\t\tpa3 z=pq.top();\n   \t\t\tpq.pop();\n   \t\t\tif(z.y>105) continue;\n   \t\t\tif(memo2[z.z][z.y]<in) continue;\n   \t\t\tmemo2[z.z][z.y]=z.x;\n   \t\t\t\n   \t\t\tfor(auto r:G[z.z]){\n   \t\t\t\tif(r.y>=0){\n   \t\t\t\t\t\tpq.push({z.x+r.y,z.y,r.x});\n   \t\t\t\t}else{\n   \t\t\t\tpq.push({z.x,z.y+1,r.x});\n   \t\t\t\t}\n   \t\t\t\t\n   \t\t\t}\n   \t\t}\n   \t\tint ans=inf*10000ll;\n   \t\tans=min(ans,sa(0,t));\n   \t\tfor(int i=0;i<105;i++)for(int j=i+1;j<105;j++){\n   \t\t\tint r=-(memo1[t][i]-memo1[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t\t r=-(memo2[t][i]-memo2[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t}\n   \t\t\n   \t\tfor(int i=0;i<105;i++)for(int j=0;j<105;j++){\n   \t\t\tif(i!=j){\n   \t\t\tint r=-(memo1[t][i]-memo2[t][j])/(i-j);\n   \t\t\tans=min(ans,sa(r,t));\n   \t\t\tans=min(ans,sa(r+1,t));\n   \t\t\tans=min(ans,sa(r+2,t));\n   \t\t\tans=min(ans,sa(r-1,t));\n   \t\t\tans=min(ans,sa(r-2,t));\n   \t\t\t\n   \t\t\t}\n   \t\t}\n   \t\tcout<<ans<<endl;\n   \t\t\n   }\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[j][S1]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(lis.back()+1);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n, m, s1, s2, t;\nvector<pl> e[1000];\nll dist[101][1000];\nll d[2][101];\npl range[2][101];\n\nvoid solve() {\n    rep(i,1000) e[i].clear();\n    s1--; s2--; t--;\n    int b_cnt = 0;\n    rep(i,m) {\n        int a, b; string s;\n        cin >> a >> b >> s; a--; b--;\n        if (s == \"x\") {\n            e[a].push_back(pl(b, -1));\n            e[b].push_back(pl(a, -1));\n            b_cnt++;\n        } else {\n            ll num = 0;\n            rep(j,s.size()) {\n                num = num * 10 + s[j]-'0';\n            }\n            e[a].push_back(pl(b, num));\n            e[b].push_back(pl(a, num));\n        }\n    }\n    rep(i,101) rep(j,n) dist[i][j] = linf;\n    dist[0][t] = 0;\n    priority_queue<pl, vector<pl>, greater<pl>> pque;\n    pque.push(pl(0, t));\n    while (!pque.empty()) {\n        ll dis = pque.top().first, num = pque.top().second/n, pos = pque.top().second%n;\n        pque.pop();\n        if (dis > dist[num][pos]) continue;\n        rep(i,e[pos].size()) {\n            pl E = e[pos][i];\n            if (E.second == -1) {\n                if (num != b_cnt && dist[num+1][E.first] > dist[num][pos]) {\n                    dist[num+1][E.first] = dist[num][pos];\n                    pque.push(pl(dist[num+1][E.first], (num+1)*n+E.first));\n                } \n            } else {\n                if (dist[num][E.first] > dist[num][pos] + E.second) {\n                    dist[num][E.first] = dist[num][pos] + E.second;\n                    pque.push(pl(dist[num][E.first], num*n + E.first));\n                }\n            }\n        }\n    }\n    b_cnt++;\n    rep(i,b_cnt) d[0][i] = dist[i][s1];\n    rep(i,b_cnt) d[1][i] = dist[i][s2];\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << d[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n    rep(i,2) rep(j,b_cnt) range[i][j] = pl(0, inf * 1000LL);\n    rep(i,2) {\n        rep(j,b_cnt) {\n            if (d[i][j] == linf) {\n                range[i][j] = pl(-1, -1);\n                continue;\n            }\n            rep(k,b_cnt) {\n                if (d[i][k] == linf) continue;\n                if (j == k) continue;\n                if (j < k) {\n                    if (d[i][j] <= d[i][k]) continue;\n                    ll hoge = (d[i][j] - d[i][k] + k-j-1) / (k-j);\n                    range[i][j].first = max(range[i][j].first, hoge);\n                } else {\n                    if (d[i][j] >= d[i][k]) {\n                        range[i][j] = pl(-1, -1);\n                        break;\n                    }\n                    ll hoge = (d[i][k] - d[i][j] + j-k-1) / (j-k)-1;\n                    range[i][j].second = min(range[i][j].second, hoge);\n                }\n            }\n        }\n    }\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << \"(\" << range[i][j].first << \", \" << range[i][j].second << \") \";\n        }\n        cerr << endl;\n    }\n    */\n    ll ans = linf;\n    rep(i,b_cnt) {\n        rep(j,b_cnt) {\n            if (range[0][i].first == -1 || range[1][j].first == -1) continue;\n            ll l = max(range[0][i].first, range[1][j].first), r = min(range[0][i].second, range[1][j].second);\n            if (l > r) continue;\n            bool flag = (d[0][i] + i*l >= d[1][j] + j*l);\n            if (flag) {\n                if (i >= j) {\n                    ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                    continue;\n                }\n                //cerr << \"Ok\" << endl;\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 >= val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                ans = min(ans, abs(d[0][i]+i*r - d[1][j] - j*r));\n            } else {\n                if (i <= j) {\n                    ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                    continue;\n                }\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 < val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                ans = min(ans, abs(d[1][j]+j*r - d[0][i] - i*r));\n\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    while (cin >> n >> m >> s1 >> s2 >> t) {\n        if (n == 0 && m == 0 && s1 == 0 && s2 == 0 && t == 0) break;\n        solve();\n    }\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-2;i<=m+2;i++){\n    if(m<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    cands.insert(0);\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[j][S1]);\n\tadd_cands(j,d[j][S2],i,d[j][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\npriority_queue<pair<long long int, pair<int, int>>, vector<pair<long long int, pair<int, int>>>, greater<pair<long long int, pair<int, int>>>>PQ;\n\nvoid func(vector<vector<pair<int,int>>>&edge,vector<vector<long long int>>&dis) {\n\twhile (!PQ.empty()) {\n\t\tlong long int c = PQ.top().first;\n\t\tint cn, cd;\n\t\ttie(cn, cd) = PQ.top().second;\n\t\tPQ.pop();\n\t\tfor (auto i : edge[cn]) {\n\t\t\tif (i.second == -1) {\n\t\t\t\tif (cd == 100)continue;\n\t\t\t\tif (dis[i.first][cd + 1] > c) {\n\t\t\t\t\tdis[i.first][cd + 1] = c;\n\t\t\t\t\tPQ.push({ c,{ i.first,cd + 1 } });\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dis[i.first][cd + 0] > c+i.second) {\n\t\t\t\t\tdis[i.first][cd + 0] = c+i.second;\n\t\t\t\t\tPQ.push({ c+i.second,{ i.first,cd + 0 } });\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nvoid func2(vector<long long int>&dis, vector<pair<long long int, int>>&box) {\n\tlong long int st = 0;\n\tint id = 0;\n\tfor (int i = 1; i <= 100; i++) {\n\t\tif (dis[i] < dis[id])id = i;\n\t}\n\tbox.push_back({ 0,id });\n\twhile (1) {\n\t//\tcout << box.back().first << \" \" << box.back().second << endl;\n\t\tlong long int l = st, r = 1e13;\n\t\twhile (r - l > 1) {\n\t\t\tlong long int mid = (r + l) / 2;\n\t\t\tbool flag = false;\n\t\t\tfor (int i = 0; i < box.back().second; i++) {\n\t\t\t//\tcout << r << \" \" << i << \" \" << box.back().second << \" \" << dis[i] << \" \" << dis[box.back().second] << endl;\n\t\t\t\tif (mid*i + dis[i] < mid*box.back().second + dis[box.back().second]) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)r = mid;\n\t\t\telse l = mid;\n\t\t}\n//\t\tcout << \"r \" << r << endl;\n\t\tif (r > 1e12) {\n\t\t\tbreak;\n\t\t}\n\t\telse {\n\t\t\tid = 0;\n\t\t\tfor (int i = 1; i < box.back().second; i++) {\n\t\t\t\tif (r*i + dis[i] < r*id + dis[id]) {\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbox.push_back({ r,id });\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N >> M >> L >> R >> K, N) {\n\t\tL--, R--, K--;\n\t\tvector<vector<long long int>>adis(N, vector<long long int>(101, MOD*MOD));\n\t\tvector<vector<long long int>>bdis(N, vector<long long int>(101, MOD*MOD));\n\t\tadis[L][0] = 0;\n\t\tbdis[R][0] = 0;\n\t\tvector<vector<pair<int, int>>>edge(N);\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--, b--;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif (s == \"x\") {\n\t\t\t\tedge[a].push_back({ b,-1 });\n\t\t\t\tedge[b].push_back({ a,-1 });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedge[a].push_back({ b,stoi(s) });\n\t\t\t\tedge[b].push_back({ a,stoi(s) });\n\t\t\t}\n\t\t}\n\t\tPQ.push({ 0,{L,0} });\n\t\tfunc(edge, adis);\n\t\tPQ.push({ 0,{ R,0 } });\n\t\tfunc(edge, bdis);\n\t\tvector<pair<long long int, int>>abox;\n\t\tvector<pair<long long int, int>>bbox;\n\t\tlong long int ans = MOD * MOD;\n\t\tfunc2(adis[K], abox);\n\t\tfunc2(bdis[K], bbox);\n\t\tfor (int i = 0; i < abox.size(); i++) {\n\t\t\tlong long int al = abox[i].first;\n\t\t\tlong long int ar;\n\t\t\tif (i + 1 < abox.size())ar = abox[i + 1].first;\n\t\t\telse ar = 1e13;\n\t\t\tint anum = abox[i].second;\n\t\t\tfor (int j = 0; j < bbox.size(); j++) {\n\t\t\t//\tcout << \"a b \" << i << \" \" << j << endl;\n\t\t\t//\tcout << abox.size() << \" \" << bbox.size() << endl;\n\t\t\t\tlong long int bl = bbox[j].first;\n\t\t\t\tlong long int br;\n\t\t\t\tif (j + 1 < bbox.size())br = bbox[j + 1].first;\n\t\t\t\telse br = 1e13;\n\t\t\t\tint bnum = bbox[j].second;\n\t\t\t\tlong long int l = max(al, bl), r = min(ar, br);\n\t\t\t\tif (r <= l)continue;\n\t\t\t\tlong long int st = l * anum + adis[K][anum] - (l*bnum + bdis[K][bnum]);\n\t\t\t\tlong long int dif = anum - bnum;\n\t\t//\t\tcout << \"st dif \" << st << \" \" << dif << endl;\n\t\t//\t\tcout << l << \" \" << r << endl;\n\t\t\t\tif (dif == 0) {\n\t\t\t\t\tans = min(ans, abs(st));\n\t\t\t\t}\n\t\t\t\telse if (st == 0) {\n\t\t\t\t\tans = min(ans, abs(st));\n\t\t\t\t}\n\t\t\t\telse if (st < 0) {\n\t\t\t\t\tif (dif < 0) {\n\t\t\t\t\t\tans = min(ans, abs(st));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs(st + dif * (r - l - 1)));\n\t\t\t\t\t\tif (st + dif * (r - l) >= dif) {\n\t\t\t\t\t\t\tans = min(ans, (st + dif * (r - l-1)) % dif);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st + dif * (r - l) > 0) {\n\t\t\t\t\t\t\tans = min(ans, abs(st) % dif);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (dif < 0) {\n\t\t\t\t\t\tans = min(ans, abs(st + dif * (r - l - 1)));\n\t\t\t\t\t\tst *= -1, dif *= -1;\n\t\t\t\t\t\tif (st + dif * (r - l) >= dif) {\n\t\t\t\t\t\t\tans = min(ans, (st + dif * (r - l-1)) % dif);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (st + dif * (r - l) > 0) {\n\t\t\t\t\t\t\tans = min(ans, abs(st) % dif);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs(st));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t//\t\tcout << ans << endl;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct state{\n  ll c;\n  int v;\n  state(){}\n  state(ll c,int v):c(c),v(v){}\n  bool operator<(const state& st) const{\n    return c > st.c;\n  }\n};\nvector<state> G[1111];\nint N,M,S1,S2,T;\nll H[1111];\nll F[1111];\nint useX[1111];\nint useE[1111];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\n\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();  \n}\n\n\nint make_dijk_tree(int X){  \n  priority_queue<state> q;\n  fill( H, H+N, INF );\n  fill( F, F+N, 0LL );\n  fill( useE, useE+N, -1);\n  fill( useX, useX+N, 0 );\n  q.push( state(0,T) );\n  H[T] = F[T] = useE[T] = useX[T] = 0; \n  while( !q.empty() ) {\n    const state p = q.top(); q.pop();    \n    if( H[p.v] < p.c ) continue;\n    for( const state &e : G[p.v] ){      \n      ll nc = e.c + p.c;\n      if( e.c == -1 ) nc = X + p.c;      \n      if( H[e.v] > nc ) {\n        H[e.v] = nc;\n        F[e.v] = F[p.v] + e.c;\n        useX[e.v] = useX[p.v];\n        useE[e.v] = 0;\n        if( e.c == -1 ) {\n          useX[e.v]++;\n          useE[e.v] = 1;\n          F[e.v] = F[p.v];\n        }\n        q.push( state( nc, e.v ) );\n      }\n    }\n  }\n  int ret = 0;\n  for(int i=0;i<N;i++) ret += useE[i];                         \n  return ret;\n}\n\nvoid add_edge(int a,int b,int w){\n  G[a].push_back( state(w,b) );\n  G[b].push_back( state(w,a) );\n}\n\nint lower_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k >= make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\nint upper_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k > make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M >> S1 >> S2 >> T &&\n         N && M && S1 && S2 && T ) {    \n    S1--; S2--; T--;\n    init();\n    int K=0;\n    for(int i=0;i<M;i++){\n      int a,b; string w; cin >> a >> b >> w;\n      --a; --b;\n      if( w == \"x\" ){\n        add_edge( a, b, -1 ); K++;\n      }\n      else\n        add_edge( a, b, stoi( w ) );\n    }\n\n    ll res = INF;\n    for(int k=0;k<=K;k++){\n      int lp = lower_bound(k);\n      int rp = upper_bound(k);\n      //cout << k << \" : \" << lp << \" \"<< rp << endl;\n      if( lp == rp ) continue;\n      if( F[S1] < F[S2] ) swap(S1,S2);\n      //cout << F[S1] << \" \"<< F[S2] << endl;\n      //cout << useX[S1] << \" \" << useX[S2] << endl;\n      if( useX[S1] >= useX[S2] ){\n        make_dijk_tree( lp );\n        res = min( res, abs( H[S1] - H[S2] ) );\n      } else {\n        int x = (F[S1] - F[S2])/(useX[S2]-useX[S1]);\n        for(int t=x-1;t<=x+1;t++){\n          make_dijk_tree( max(lp,min( rp-1, t )) );\n          //cout << t << \" \" << H[S1] << \" \" << H[S2] << endl;\n          res = min( res, abs( H[S1] - H[S2] ) );\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<stack>\n#include<time.h>\n#define Msn(x,y) (memset((x),0,sizeof((x[0]))*(y+1)))\n#define msn(x) (memset((x),0,sizeof((x))))\n#define msx(x,y) (memset((x),0x7f,sizeof((x[0]))*(y+3)))\n#define acer cout<<\"sb\"<<endl\ntypedef long long ll;\nusing namespace std;\nint n,m;\nconst int maxn=1002;\nstruct node\n{\n    int v;\n    ll w;\n};\nvector<node>g[maxn];\nint T,s1,s2;\nbool inq[maxn];\nll dis[maxn*101];\nconst int M=101;\nvoid solve()\n{\n    queue<int>q;\n    memset(dis,-1,sizeof(dis));\n    msn(inq);\n    q.push(T*M);\n    dis[T*M];\n    inq[T*M]=1;\n    while(!q.empty())\n    {\n        int now=q.front();\n        q.pop();\n        inq[now]=0;\n        int a=now/M;\n        int b=now%M;\n        for(int i=0; i<g[a].size(); i++)\n        {\n            if(g[a][i].w==-1)\n            {\n                int nxt=g[a][i].v*M+b+1;\n                if(b<100)\n                {\n                    if(dis[nxt]==-1||dis[now]<dis[nxt])\n                    {\n                        dis[nxt]=dis[now];\n                        if(!inq[nxt])\n                        {\n                            q.push(nxt);\n                            inq[nxt]=1;\n                        }\n                    }\n                }\n            }\n            else\n            {\n                int nxt=g[a][i].v*M+b;\n                if(dis[nxt]==-1||dis[nxt]>dis[now]+g[a][i].w)\n                {\n                    dis[nxt]=dis[now]+g[a][i].w;\n                    if(!inq[nxt])\n                    {\n                        q.push(nxt);\n                        inq[nxt]=1;\n                    }\n                }\n            }\n        }\n    }\n}\n\nstruct node1\n{\n    ll a,b;\n};\nvector<node1>p[2];\nvector<node1>nod,line;\nll Abs(ll x)\n{\n    return x<0?-x:x;\n}\n\nll check(int x)\n{\n    ll _1,_2;\n    _1=_2=1e18+7;\n    for(int i=0;i<p[0].size();i++)\n    {\n        _1=min(_1,x*p[0][i].a+p[0][i].b);\n    }\n    for(int i=0;i<p[1].size();i++)\n    {\n        _2=min(_2,x*p[1][i].a+p[1][i].b);\n    }\n    return Abs(_1-_2);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&T))\n    {\n        if(n==0&&m==0)break;\n        T--,s1--,s2--;\n        p[0].clear();\n        p[1].clear();\n        nod.clear();\n        line.clear();\n        for(int i=0; i<=n; i++)g[i].clear();\n        int u,v,w;\n        char s[50];\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%s\",&u,&v,s);\n            if(s[0]=='x')\n            {\n                w=-1;\n            }\n            else\n            {\n                w=0;\n                int len=strlen(s);\n                for(int i=0; i<len; i++)\n                {\n                    w=w*10+s[i]-'0';\n                }\n            }\n            u--,v--;\n            g[u].push_back((node)\n            {\n                v,w\n            });\n            g[v].push_back((node)\n            {\n                u,w\n            });\n        }\n        solve();\n     /*   for(int i=0;i<=100;i++)\n        {\n            if(dis[s1*M+i]>=0)p[0].push_back((node1){i,dis[s1*M+i]}),line.push_back((node1){i,dis[s1*M+i]});\n            if(dis[s2*M+i]>=0)p[1].push_back((node1){i,dis[s2*M+i]}),line.push_back((node1){i,dis[s2*M+i]});\n        }\n        ll ans=check(0);\n        for(int i=0;i<line.size();i++)\n        {\n            for(int j=i+1;j<line.size();j++)\n            {\n                if(line[i].a==line[j].a)\n                {\n                    ans=min(Abs(line[i].b-line[j].b),ans);\n                }\n                else\n                {\n                    ll a1=Abs(line[i].b-line[j].b)/Abs((line[i].a-line[j].a));\n                    ans=min(ans,check(a1));\n                    a1++;\n                    ans=min(check(a1),ans);\n                }\n            }\n        }\n        printf(\"%lld\\n\",ans);*/\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(i==j){\n\t\tif(dist[0][t][i]>=INF)return INF;\n\t\tif(dist[1][t][j]>=INF)return INF;\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tvector<PPP> vec;\n\t\tfor(ll l=0;l<=100;l++){\n\t\t\tvec.push_back(PPP(dist[0][t][l]+l*k,0));\n\t\t\tvec.push_back(PPP(dist[1][t][l]+l*k,1));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\tfor(int l=0;l<(int)vec.size()-1;l++){\n\t\t\tif(vec[l].first>=INF)continue;\n\t\t\tif(vec[l].second!=vec[l+1].second){\n\t\t\t\tans=min(ans,vec[l+1].first-vec[l].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=100;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-3;i<=m+3;i++){\n    if(m<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[j][S1]);\n\tadd_cands(j,d[j][S2],i,d[j][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(dist[0][t][i]>=INF)return INF;\n\tif(dist[1][t][j]>=INF)return INF;\n\tif(i==j){\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tll va=(ll)dist[0][t][i]+i*k;\n\t\tll vb=(ll)dist[1][t][j]+j*k;\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n\nint n, m, s1, s2, t;\nvector<pl> e[1000];\nll dist[101][1000];\nll d[2][101];\npl range[2][101];\n\nvoid solve() {\n    rep(i,1000) e[i].clear();\n    s1--; s2--; t--;\n    int b_cnt = 0;\n    rep(i,m) {\n        int a, b; string s;\n        cin >> a >> b >> s; a--; b--;\n        if (s == \"x\") {\n            e[a].push_back(pl(b, -1));\n            e[b].push_back(pl(a, -1));\n            b_cnt++;\n        } else {\n            ll num = 0;\n            rep(j,s.size()) {\n                num = num * 10 + s[j]-'0';\n            }\n            e[a].push_back(pl(b, num));\n            e[b].push_back(pl(a, num));\n        }\n    }\n    rep(i,n) rep(j,n) dist[i][j] = linf;\n    dist[0][t] = 0;\n    priority_queue<pl, vector<pl>, greater<pl>> pque;\n    pque.push(pl(0, t));\n    while (!pque.empty()) {\n        ll dis = pque.top().first, num = pque.top().second/n, pos = pque.top().second%n;\n        pque.pop();\n        if (dis > dist[num][pos]) continue;\n        rep(i,e[pos].size()) {\n            pl E = e[pos][i];\n            if (E.second == -1) {\n                if (num != b_cnt && dist[num+1][E.first] > dist[num][pos]) {\n                    dist[num+1][E.first] = dist[num][pos];\n                    pque.push(pl(dist[num+1][E.first], (num+1)*n+E.first));\n                } \n            } else {\n                if (dist[num][E.first] > dist[num][pos] + E.second) {\n                    dist[num][E.first] = dist[num][pos] + E.second;\n                    pque.push(pl(dist[num][E.first], num*n + E.first));\n                }\n            }\n        }\n    }\n    b_cnt++;\n    rep(i,b_cnt) d[0][i] = dist[i][s1];\n    rep(i,b_cnt) d[1][i] = dist[i][s2];\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << d[i][j] << \" \";\n        }\n        cerr << endl;\n    }\n    */\n    rep(i,2) rep(j,b_cnt) range[i][j] = pl(0, inf * 1000LL);\n    rep(i,2) {\n        rep(j,b_cnt) {\n            if (d[i][j] == linf) {\n                range[i][j] = pl(-1, -1);\n                continue;\n            }\n            rep(k,b_cnt) {\n                if (d[i][k] == linf) continue;\n                if (j == k) continue;\n                if (j < k) {\n                    if (d[i][j] <= d[i][k]) continue;\n                    ll hoge = (d[i][j] - d[i][k] + k-j-1) / (k-j);\n                    range[i][j].first = max(range[i][j].first, hoge);\n                } else {\n                    if (d[i][j] >= d[i][k]) {\n                        range[i][j] = pl(-1, -1);\n                        break;\n                    }\n                    ll hoge = (d[i][k] - d[i][j] + j-k-1) / (j-k);\n                    range[i][j].second = min(range[i][j].second, hoge);\n                }\n            }\n        }\n    }\n    /*\n    rep(i,2) {\n        rep(j,b_cnt) {\n            cerr << \"(\" << range[i][j].first << \", \" << range[i][j].second << \") \";\n        }\n        cerr << endl;\n    }\n    */\n    ll ans = linf;\n    rep(i,b_cnt) {\n        rep(j,b_cnt) {\n            if (range[0][i].first == -1 || range[1][j].first == -1) continue;\n            ll l = max(range[0][i].first, range[1][j].first), r = min(range[0][i].second, range[1][j].second);\n            if (l > r) continue;\n            bool flag = (d[0][i] + i*l >= d[1][j] + j*l);\n            if (flag) {\n                if (i >= j) {\n                    ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                    continue;\n                }\n                //cerr << \"Ok\" << endl;\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 >= val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[0][i]+i*l - d[1][j] - j*l);\n                ans = min(ans, abs(d[0][i]+i*r - d[1][j] - j*r));\n            } else {\n                if (i <= j) {\n                    ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                    continue;\n                }\n                while (r-l > 1) {\n                    ll mid = (r+l) / 2;\n                    ll val1 = d[0][i] + i*mid;\n                    ll val2 = d[1][j] + j*mid;\n                    if (val1 < val2) l = mid;\n                    else r = mid;\n                }\n                ans = min(ans, d[1][j]+j*l - d[0][i] - i*l);\n                ans = min(ans, abs(d[1][j]+j*r - d[0][i] - i*r));\n\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nint main() {\n#ifndef LOCAL\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n    cout.precision(20);\n    cerr << fixed;\n    cerr.precision(6);\n#ifdef LOCAL\n    //freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif  \n    while (cin >> n >> m >> s1 >> s2 >> t) {\n        if (n == 0 && m == 0 && s1 == 0 && s2 == 0 && t == 0) break;\n        solve();\n    }\n    //cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long long INF=1LL<<60;\nconst int MAXN=1005;\nint n, m, S1, S2, T;\nchar s[100];\nstruct edge{\n    int to;\n    long long w;\n    bool type;\n    edge(int to=0, long long w=0, bool type=false):to(to),w(w),type(type) {}\n};\nvector<edge> G[MAXN];\nlong long dist[MAXN][MAXN];\npriority_queue< pair<long long, pair<int, int> > > q;\npair<long long, pair<int, int> > now;\nvector<long long> ans;\nlong long cross(long long a1, long long b1, long long a2, long long b2){\n    if(a1==INF||a2==INF) return 0;\n    return floor((a1-a2+1.0)/(b2-b1));\n}\nlong long calc(long long dp[MAXN], int k, long long x){\n    long long ret=INF;\n    for(int i=0; i<=k; i++){\n        ret=min(ret,dp[i]+x*i);\n    }\n    return ret;\n}\nint main(){\n    while(~scanf(\"%d%d%d%d%d\",&n,&m,&S1,&S2,&T)&&n){\n        for(int i=1; i<=n; i++){\n            G[i].clear();\n        }\n        int k=0;\n        for(int i=0, x, y, z; i<m; i++){\n            scanf(\"%d%d%s\",&x,&y,s);\n            if(s[0]=='x'){\n                G[x].push_back(edge(y,0,1));\n                G[y].push_back(edge(x,0,1));\n                k++;\n            }\n            else{\n                sscanf(s,\"%d\",&z);\n                G[x].push_back(edge(y,z,0));\n                G[y].push_back(edge(x,z,0));\n            }\n        }\n        for(int i=1; i<=n; i++){\n            for(int j=0; j<=k; j++){\n                dist[i][j]=INF;\n            }\n        }\n        dist[T][0]=0;\n        while(!q.empty()) q.pop();\n        q.push(make_pair(0LL,make_pair(T,0)));\n        while(!q.empty()){\n            now=q.top(); q.pop();\n            int u=now.second.first, cnt=now.second.second;\n            long long d=dist[u][cnt];\n            if(-now.first>d) continue;\n            for(auto p: G[u]){\n                int ncnt=cnt+p.type, nidx=p.to;\n                long long ndist=d+p.w;\n                if(ncnt<=k&&ndist<dist[nidx][ncnt]){\n                    dist[nidx][ncnt]=ndist;\n                    q.push(make_pair(-ndist,make_pair(nidx,ncnt)));\n                }\n            }\n        }\n        ans.clear();\n        ans.push_back(0LL);\n        for(int i=0; i<=k; i++){\n            for(int j=0; j<=k; j++) if(i!=j){\n                long long x1, x2, x3;\n                x1=cross(dist[S1][i],i,dist[S2][j],j);\n                x2=cross(dist[S1][i],i,dist[S1][j],j);\n                x3=cross(dist[S2][i],i,dist[S2][j],j);\n                for(int d=-1; d<=1; d++){\n                    ans.push_back(x1+d);\n                    ans.push_back(x2+d);\n                    ans.push_back(x3+d);\n                }\n            }\n        }\n        sort(ans.begin(),ans.end());\n        ans.erase(unique(ans.begin(),ans.end()),ans.end());\n        long long ret=INF;\n        for(auto p: ans){\n            if(p>=0){\n                ret=min(ret,abs(calc(dist[S1],k,p)-calc(dist[S2],k,p)));\n            }\n        }\n        printf(\"%lld\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nvector<P> G[1111];\nint dp1[111][1111];\nint dp2[111][1111];\nint INF=1LL<<45LL;\nstruct st{\n  int x,v,d;\n  st(){}\n  st(int x,int v,int d):x(x),v(v),d(d){}\n  bool operator<(const st a)const{\n    return d>a.d;\n  }\n};\nint n,m,s1,s2,t;\nint ans;\nint calc1(int i,int x){\n  return dp1[i][t]+i*x;\n}\nint calc2(int i,int x){\n  return dp2[i][t]+i*x;\n}\nint check1(int x){\n  int res=-1;\n  for(int i=0;i<111;i++){\n    if(dp1[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc1(i,x)<calc1(res,x)) res=i;\n  }\n  return res;\n}\nint check2(int x){\n  int res=-1;\n  for(int i=0;i<111;i++){\n    if(dp2[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc2(i,x)<calc2(res,x)) res=i;\n  }\n  return res;\n}\nint calc3(int x){\n  return calc1(check1(x),x)-calc2(check2(x),x);\n}\nsigned main(){\n  while(cin>>n>>m>>s1>>s2>>t,n){\n    s1--;s2--;t--;\n    for(int i=0;i<1111;i++) G[i].clear(); \n    for(int i=0;i<m;i++){\n      int a,b,w;\n      string s;\n      cin>>a>>b>>s;\n      if(s==\"x\") w=-1;\n      else w=stoll(s);\n      a--;b--;\n      G[a].push_back(P(b,w));\n      G[b].push_back(P(a,w));\n    }\n    for(int i=0;i<111;i++){\n      fill(dp1[i],dp1[i]+1111,INF);\n      fill(dp2[i],dp2[i]+1111,INF);\n    }\n    priority_queue<st> q;\n    q.emplace(0,s1,0);\n    dp1[0][s1]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp1[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      //cout<<p.x<<\" \"<<p.v<<\" \"<<p.d<<endl;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp1[nx][nv]<=nd) continue;\n\tdp1[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //puts(\"OK\");\n    q.emplace(0,s2,0);\n    dp2[0][s2]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp2[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp2[nx][nv]<=nd) continue;\n\tdp2[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //for(int i=0;i<11;i++) cout<<i<<\":dp1:\"<<dp1[i][t]<<endl;\n    //for(int i=0;i<11;i++) cout<<i<<\":dp2:\"<<dp2[i][t]<<endl;\n    \n    vector<int> b;\n    b.push_back(0);\n    b.push_back(INF);\n    int L=0;\n    while(check1(L)!=check1(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check1(L)!=check1(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    L=0;\n    while(check2(L)!=check2(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check2(L)!=check2(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    sort(b.begin(),b.end());\n    b.erase(unique(b.begin(),b.end()),b.end());\n    ans=INF;\n    for(int i=0;i<(int)b.size();i++){\n      ans=min(ans,abs(calc3(b[i])));\n      if(i==(int)b.size()-1) break;\n      int x=b[i],y=b[i+1]-1;\n      ans=min(ans,abs(calc3(y)));\n      //cout<<x<<\" \"<<y<<endl;\n      //cout<<check1(x)<<\" \"<<check1(y)<<endl;\n      //cout<<check2(x)<<\" \"<<check2(y)<<endl;\n      if(x==y) continue;\n      if(calc3(x)*calc3(y)<0){\n\t//cout<<calc3(x)<<\"*\"<<calc3(y)<<endl;\n\tint d=abs(calc3(x+1)-calc3(x));\n\tif(d==0) continue;\n\tint tmp=abs(calc3(x));\n\t//cout<<tmp<<\":\"<<d<<endl;\n\tans=min(ans,abs(tmp-(tmp/d*d)));\n\tans=min(ans,abs(((tmp/d+1)*d)-tmp));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[j][S1]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[j][S2]-dist[i][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(lis.back()+1);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n        \n        bool flag=true;\n        for(int i=0;i<=100;i++){\n            if(i!=k&&dist[k][S1]+k*x2>dist[i][S1]+i*x2)flag=false;\n            if(i!=l&&dist[l][S2]+l*x2>dist[i][S2]+i*x2)flag=false;\n        }\n        assert(flag);\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.answer\"\n\nstruct aa {\n\tint now;\n\tlong long int time;\n\tint x;\n};\nclass Compare {\npublic:\n\t//aa?????????????????¶\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\ntemplate<class T>\nclass cht {\npublic:\n\tvector<pair<T, T>>ls;\n\tbool check(const pair<T, T>&l1, const pair<T, T>&l2, const pair<T, T>&l3)const {\n\t\treturn 1.l*(l2.first - l1.first)*(l3.second - l2.second) >= 1.l*(l2.second - l1.second)*(l3.first - l2.first);\n\t}\n\tcht() :ls() {\n\t}\n\tcht(vector<pair<T, T>>&vs) :ls() {\n\t\tsort(vs.begin(), vs.end());\n\t\tfor (auto v : vs) {\n\t\t\tadd(v);\n\t\t}\n\t}\n\tvoid add(const pair<T, T>&p) {\n\t\twhile (ls.size() >= 2) {\n\t\t\tif (!check(ls[ls.size() - 2], ls[ls.size() - 1], p)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tls.pop_back();\n\t\t\t}\n\t\t}\n\t\tif (ls.size() == 1 && ls.back().second == p.second) {\n\t\t\tls.back().first = max(ls.back().first, p.first);\n\t\t}\n\t\telse {\n\t\t\tls.emplace_back(p);\n\t\t}\n\t}\n\tT f(int k, const T&x)const {\n\t\treturn ls[k].first*x + ls[k].second;\n\t}\n\tT query(const T&x)const {\n\t\tint amin = 0;\n\t\tint amax = ls.size();\n\t\twhile (amin + 1 != amax) {\n\t\t\tint amid = (amin + amax) / 2;\n\t\t\tif (f(amid - 1, x) <= f(amid, x)) {\n\t\t\t\tamin = amid;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tamax = amid;\n\t\t\t}\n\t\t}\n\t\treturn f(amin, x);\n\t}\n};\nint main() {\n\twhile (1) {\n\t\tint N, M, S1, S2, T; cin >> N >> M >> S1 >> S2 >> T;\n\t\tif (!N)break;\n\t\tS1--; S2--; T--;\n\t\tvector<vector<pair<int,int>>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;string w; cin >> a >> b >> w; a--; b--;\n\t\t\tint value;\n\t\t\tif (w == \"x\") {\n\t\t\t\tvalue = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalue = stoi(w);\n\n\t\t\t}\n\t\t\tedges[a].push_back(make_pair(b, value));\n\t\t\tedges[b].push_back(make_pair(a, value));\n\n\t\t}\n\t\tvector<vector<long long int>>memo(N, vector<long long int>(102,1e9));\n\t\tfor (int i = 0; i < 102; ++i) {\n\t\t\tmemo[T][i] = 0;\n\t\t}\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ T,0,0 });\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tconst int now = atop.now;\n\t\t\tconst long long int now_time = atop.time;\n\t\t\tconst int now_x = atop.x;\n\t\t\tque.pop();\n\t\t\tfor (auto e : edges[atop.now]) {\n\t\t\t\tif (e.second == -1) {\n\t\t\t\t\tconst long long int next_time = now_time;\n\t\t\t\t\tif (now_x >= 100)continue;\n\t\t\t\t\tif (memo[e.first][now_x + 1] > next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x + 1; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)break;\n\t\t\t\t\t\tmemo[e.first][now_x + 1] = next_time;\n\t\t\t\t\t\t\n\t\t\t\t\t\tque.push(aa{ e.first,next_time ,now_x + 1 });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst int next_time = now_time + e.second;\n\t\t\t\t\tif (memo[e.first][now_x]>next_time) {\n\t\t\t\t\t\tbool ok = true;\n\t\t\t\t\t\tfor (int ax = 0; ax < now_x; ++ax) {\n\t\t\t\t\t\t\tif (memo[e.first][ax] <= next_time) {\n\t\t\t\t\t\t\t\tok = false;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!ok)break;\n\n\t\t\t\t\t\tmemo[e.first][now_x] = next_time;\n\t\t\t\t\t\tque.push(aa{ e.first,next_time,now_x });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcht<long long int> cht1,cht2;\n\t\tfor (int i = 100; i>=0; --i) {\n\t\t\tif (memo[S1][i] < 1e9) {\n\t\t\t\tcht1.add(make_pair(-i, -memo[S1][i]));\n\t\t\t}\n\t\t\tif (memo[S2][i] < 1e9) {\n\t\t\t\tcht2.add(make_pair(-i, -memo[S2][i]));\n\t\t\t}\n\t\t}\n\t\tvector<long long int >nums;\n\t\tnums.emplace_back(0);\n\t\tnums.emplace_back(static_cast<long long int>(1e18));\n\t\tfor (int i = 0; i < int(cht1.ls.size())-1; ++i) {\n\t\t\tauto pa = cht1.ls[i];\n\t\t\tauto pb = cht1.ls[i+1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tfor (int i = 0; i < int(cht2.ls.size()) - 1; ++i) {\n\t\t\tauto pa = cht2.ls[i];\n\t\t\tauto pb = cht2.ls[i + 1];\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first));\n\t\t\tnums.emplace_back((pa.second - pb.second) / (pb.first - pa.first)+1);\n\t\t}\n\t\tsort(nums.begin(), nums.end());\n\t\tnums.erase(unique(nums.begin(), nums.end()), nums.end());\n\t\tlong long int ans = 1e18;\n\t\tfor (int i = 0; i < nums.size() - 1; ++i) {\n\t\t\tlong long  l = nums[i];\n\t\t\tlong long  r = nums[i + 1];\n\t\t\tif (int(l) == int(r))continue;\n\t\t\telse {\n\t\t\t\tlong long int al = l;\n\t\t\t\tlong long int ar = r;\n\t\t\t\tlong long int lvalue1 = cht1.query(al);\n\t\t\t\tlong long int lvalue2 = cht2.query(al);\n\t\t\t\tlong long int rvalue1 = cht1.query(ar); \n\t\t\t\tlong long int rvalue2 = cht2.query(ar);\n\t\t\t\t\n\t\t\t\tif ((lvalue1 > lvalue2&&rvalue1 > rvalue2)||(lvalue1<lvalue2&&rvalue1<rvalue2)) {\n\t\t\t\t\tans = min(ans, min(abs(lvalue1 - lvalue2), abs(rvalue1 - rvalue2)));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong long int dis1 = (rvalue1 - lvalue1) / (r - l);\n\t\t\t\t\tlong long int dis2 = (rvalue2 - lvalue2) / (r - l);\n\t\t\t\t\tif (dis1 == dis2) {\n\t\t\t\t\t\tans = min(ans, abs(lvalue1 - rvalue1));\n\t\t\t\t\t}\n\t\t\t\t\tlong long int cx = abs((lvalue2 - lvalue1) / (dis1 - dis2));\n\t\t\t\t\tif (dis1>dis2) {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx - 1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx +1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx -1)*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx )*(dis1 - dis2)));\n\t\t\t\t\t\tans = min(ans, abs((lvalue2 - lvalue1) - (cx  + 1)*(dis1 - dis2)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1000\n#define HUGE_NUM 9999999999999999\n\nenum Type{\n\tA, //S_1\n\tB, //S_2\n};\n\nstruct Edge{\n\tEdge(int arg_to,ll arg_cost,bool arg_is_magical){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t\tis_magical = arg_is_magical;\n\t}\n\tint to;\n\tll cost;\n\tbool is_magical;\n};\n\nstruct State{\n\tState(){\n\t\tnode_id = 0;\n\t\tnum_passed_magical = 0;\n\t\tsum_cost = 0;\n\t}\n\tState(int arg_node_id,int arg_num_passed_magical,ll arg_sum_cost){\n\n\t\tnode_id = arg_node_id;\n\t\tnum_passed_magical = arg_num_passed_magical;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct State &arg) const{\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,num_passed_magical;\n\tll sum_cost;\n};\n\nint N,M,S_1,S_2,T;\nint num_magical;\nvector<Edge> G[NUM];\nll min_dist[2][101][NUM];\n\nll getNUM(char buf[20]){\n\n\tll ret = 0;\n\n\tfor(int i = 0; buf[i] != '\\0'; i++){\n\t\tret = 10*ret+(buf[i]-'0');\n\t}\n\n\treturn ret;\n}\n\nll calc_len(ll slope_1,ll num_1,ll slope_2,ll num_2){\n\n\treturn (ll)((double)(num_2-num_1)/(double)(slope_1-slope_2));\n}\n\nll get_min_cost(Type type,ll tmp_len){\n\n\tll ret = HUGE_NUM;\n\n\tfor(ll i = 0; i <= num_magical; i++){\n\n\t\tret = min(ret,min_dist[type][i][T]+i*tmp_len);\n\t}\n\treturn ret;\n}\n\nvoid dijkstra(Type type,int start){\n\n\tfor(int i = 0; i <= num_magical; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tmin_dist[type][i][k] = HUGE_NUM;\n\t\t}\n\t}\n\n\tpriority_queue<State> Q;\n\n\tmin_dist[type][0][start] = 0;\n\tQ.push(State(start,0,0));\n\n\tint next_node,next_num_pass;\n\tll next_cost;\n\tState state;\n\n\twhile(!Q.empty()){\n\n\t\tstate = Q.top();\n\t\tQ.pop();\n\n\t\tif(state.sum_cost > min_dist[type][state.num_passed_magical][state.node_id]){\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int i = 0; i < G[state.node_id].size(); i++){\n\n\t\t\tnext_node = G[state.node_id][i].to;\n\t\t\tnext_cost = state.sum_cost+G[state.node_id][i].cost;\n\t\t\tnext_num_pass = state.num_passed_magical;\n\n\t\t\tif(G[state.node_id][i].is_magical){\n\t\t\t\tnext_num_pass++;\n\t\t\t}\n\n\t\t\tif(min_dist[type][next_num_pass][next_node] > next_cost){\n\n\t\t\t\tmin_dist[type][next_num_pass][next_node] = next_cost;\n\t\t\t\tQ.push(State(next_node,next_num_pass,next_cost));\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t}\n\n\tS_1--;\n\tS_2--;\n\tT--;\n\n\tchar buf[20];\n\n\tint from,to;\n\tll cost;\n\tnum_magical = 0;\n\n\tfor(int loop = 0; loop < M; loop++){\n\n\t\tscanf(\"%d %d %s\",&from,&to,buf);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(buf[0] != 'x'){\n\n\t\t\tcost = getNUM(buf);\n\t\t\tG[from].push_back(Edge(to,cost,false));\n\t\t\tG[to].push_back(Edge(from,cost,false));\n\n\t\t}else{\n\n\t\t\tnum_magical++;\n\n\t\t\tcost = 0;\n\t\t\tG[from].push_back(Edge(to,cost,true));\n\t\t\tG[to].push_back(Edge(from,cost,true));\n\t\t}\n\t}\n\n\tdijkstra(A,S_1);\n\tdijkstra(B,S_2);\n\n\tvector<ll> V;\n\tll len[3];\n\n\tfor(ll i = 0; i <= num_magical; i++){\n\t\tfor(ll k = 0; k <= num_magical; k++){\n\n\t\t\tif(k == i)continue;\n\n\t\t\tfor(int a = 0; a < 3; a++)len[a] = 0;\n\n\t\t\tif(min_dist[A][i][T] != BIG_NUM && min_dist[A][k][T] != BIG_NUM)len[0] = calc_len(i,min_dist[A][i][T],k,min_dist[A][k][T]);\n\t\t\tif(min_dist[A][i][T] != BIG_NUM && min_dist[B][k][T] != BIG_NUM)len[1] = calc_len(i,min_dist[A][i][T],k,min_dist[B][k][T]);\n\t\t\tif(min_dist[B][i][T] != BIG_NUM && min_dist[B][k][T] != BIG_NUM)len[2] = calc_len(i,min_dist[B][i][T],k,min_dist[B][k][T]);\n\n\t\t\tfor(ll diff = -1; diff <= 1; diff++){\n\t\t\t\tfor(int a = 0; a < 3; a++){\n\t\t\t\t\tV.push_back(len[a]+diff);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tsort(V.begin(),V.end());\n\tV.erase(unique(V.begin(),V.end()),V.end());\n\n\tll ans = abs(min_dist[A][0][T]-min_dist[B][0][T]);\n\tll tmp_len;\n\tll A_cost,B_cost;\n\n\tfor(int i = 0; i < V.size(); i++){\n\n\t\ttmp_len = V[i];\n\t\tif(tmp_len < 0)continue;\n\n\t\tA_cost = get_min_cost(A,tmp_len);\n\t\tB_cost = get_min_cost(B,tmp_len);\n\n\t\tans = min(ans,abs(A_cost-B_cost));\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d %d %d\",&N,&M,&S_1,&S_2,&T);\n\t\tif(N == 0 && M == 0 && S_1 == 0 && S_2 == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{\n    int dst;\n    LL cost;\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nint N, M, S1, S2, T;\nint MB;\nconst LL INF = 1e18;\nvector<LL> calc_cost(int s, int t) {\n    LL dist[1000][101] = {};\n    typedef tuple<LL, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> que;\n    REP(i, N) REP(j, MB+1) dist[i][j] = INF;\n    dist[s][0] = 0;\n    que.push(TP(0, s, 0));\n    while(!que.empty()) {\n        LL d;\n        int u, c;\n        tie(d, u, c) = que.top(); que.pop();\n        for(Edge e : G[u]) {\n            const int nu = e.dst;\n            const int nc = c + (e.cost == -1 ? 1 : 0);\n            const LL nd = d + (e.cost == -1 ? 0 : e.cost);\n            if(nc <= MB && dist[nu][nc] > nd) {\n                dist[nu][nc] = nd;\n                que.push(TP(nd, nu, nc));\n            }\n        }\n    }\n    vector<LL> res(MB+1);\n    REP(i, MB+1) res[i] = dist[t][i];\n    return res;\n}\n// O(N)\nLL get(vector<LL> cs, LL X) {\n    LL res = cs[0];\n    for(int i = 1; i < cs.size(); i++) {\n        res = min(res, cs[i] + i * X);\n    }\n    return res;\n}\n// O(N)\nLL calc_diff(vector<LL> cs1, vector<LL> cs2, LL X) {\n    LL cost1 = get(cs1, X);\n    LL cost2 = get(cs2, X);\n    return abs(cost1 - cost2);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> M >> S1 >> S2 >> T && N > 0) {\n        MB = 0;\n        S1--; S2--; T--;\n        G.assign(N, Node());\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            string ws;\n            cin >> ws;\n            LL w;\n            if(ws == \"x\") {\n                w = -1;\n                MB++;\n            } else {\n                w = stoll(ws);\n            }\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n        }\n        vector<LL> cs1 = calc_cost(S1, T);\n        // REP(i, cs1.size()) cout << cs1[i] << \" \"; cout << endl;\n        vector<LL> cs2 = calc_cost(S2, T);\n        // REP(i, cs2.size()) cout << cs2[i] << \" \"; cout << endl;\n        LL ans = calc_diff(cs1, cs2, 0);\n        REP(i, cs1.size()) REP(j, cs1.size()) if(i < j && cs1[i] < INF && cs1[j] < INF) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs1[i] - cs1[j]) / (j-i);\n            // cout << \"X: \" << X << endl;\n            for(LL dx = -1; dx <= 1; dx++) {\n                if(X + dx >= 0) ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        REP(i, cs2.size()) REP(j, cs2.size()) if(i < j && cs2[i] < INF && cs2[j] < INF) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs2[i] - cs2[j]) / (j-i);\n            // cout << \"X: \" << X << endl;\n            for(LL dx = -1; dx <= 1; dx++) {\n                if(X + dx >= 0) ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        REP(i, cs2.size()) REP(j, cs1.size()) if(i != j && cs2[i] < INF && cs1[j] < INF) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs2[i] - cs1[j]) / (j-i);\n            // cout << \"X: \" << X << endl;\n            for(LL dx = -1; dx <= 1; dx++) {\n                if(X + dx >= 0) ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct state{\n  ll c;\n  int v;\n  state(){}\n  state(ll c,int v):c(c),v(v){}\n  bool operator<(const state& st) const{\n    return c > st.c;\n  }\n};\nvector<state> G[1111];\nint N,M,S1,S2,T;\nll H[1111];\nll F[1111];\nint useX[1111];\nconst ll INF = (ll)(1<<29)*(ll)(1<<29);\n\nvoid init(){\n  for(int i=0;i<N;i++) G[i].clear();  \n}\n\n\nint make_dijk_tree(int X){  \n  priority_queue<state> q;\n  q.push( state(0,T) );\n  fill( H, H+N, INF );\n  fill( F, F+N, 0LL );\n  fill( useX, useX+N, 0 );\n  while( !q.empty() ) {\n    state p = q.top(); q.pop();\n    ll c = p.c;\n    int v = p.v;\n    if( H[v] < c ) continue;\n    for( state e : G[v] ){      \n      ll nc = e.c + c;\n      if( e.c == -1 ) nc = X + c;\n      int nv = e.v;\n      if( H[nv] > nc ) {\n        H[nv] = nc;\n        F[nv] = F[v] + e.c;\n        useX[nv] = useX[v];\n        if( e.c == -1 ) {\n          useX[nv]++;\n          F[nv] = F[v];\n        }\n        q.push( state( nc, nv ) );\n      }\n    }\n  }\n  //cout << X << \" \" << useX[S1] << \" + \" << useX[S2] << endl;\n  return useX[S1] + useX[S2];\n}\n\nvoid add_edge(int a,int b,int w){\n  G[a].push_back( state(w,b) );\n  G[b].push_back( state(w,a) );\n}\n\nint lower_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k >= make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\nint upper_bound(int k){\n  int st = 0, ed = 1000000000;\n  int res = ed;\n  while( st <= ed ){\n    int h = (st+ed)/2;\n    if( k > make_dijk_tree(h) ){\n      res = h; ed = h-1;\n    } else\n      st = h+1;\n  }\n  return res;\n}\n\nint main(){\n  while( cin >> N >> M >> S1 >> S2 >> T &&\n         N && M && S1 && S2 && T ) {    \n    S1--; S2--; T--;\n    init();\n    int K=0;\n    for(int i=0;i<M;i++){\n      int a,b; string w; cin >> a >> b >> w;\n      --a; --b;\n      if( w == \"x\" ){\n        add_edge( a, b, -1 ); K++;\n      }\n      else\n        add_edge( a, b, stoi( w ) );\n    }\n\n    ll res = INF;\n    for(int k=0;k<=2*K;k++){\n      int lp = lower_bound(k);\n      int rp = upper_bound(k);\n      //cout << k << \" : \" << lp << \" \"<< rp << endl;\n      if( lp == rp ) continue;\n      if( F[S1] < F[S2] ) swap(S1,S2);\n      //cout << F[S1] << \" \"<< F[S2] << endl;\n      //cout << useX[S1] << \" \" << useX[S2] << endl;\n      if( useX[S1] >= useX[S2] ){\n        make_dijk_tree( lp );\n        res = min( res, abs( H[S1] - H[S2] ) );\n      } else {\n        int x = (F[S1] - F[S2])/(useX[S2]-useX[S1]);\n        for(int t=x-1;t<=x+1;t++){\n          make_dijk_tree( max(lp,min( rp-1, t )) );\n          //cout << t << \" \" << H[S1] << \" \" << H[S2] << endl;\n          res = min( res, abs( H[S1] - H[S2] ) );\n        }\n      }\n    }\n    cout << res << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tif(curu==100)continue;\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(dist[0][t][i]>=INF)return INF;\n\tif(dist[1][t][j]>=INF)return INF;\n\tif(i==j){\n\t\tll va=INF;\n\t\tll vb=INF;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tva=min(va,dist[0][t][l]);\n\t\t\tvb=min(vb,dist[1][t][l]);\n\t\t}\n\t\treturn labs(va-vb);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tll va=INF;\n\t\tll vb=INF;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tva=min(va,dist[0][t][l]+l*k);\n\t\t\tvb=min(vb,dist[1][t][l]+l*k);\n\t\t}\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 59;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    vector< edge > G[1000];\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n\n    for(int i = -10; i <= 10; i++) {\n      for(auto &cost : latte) ret = min(ret, get(cost + i));\n    }\n    // zinsei\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-2;i<=m+2;i++){\n    if(m<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[j][S1]);\n\tadd_cands(j,d[j][S2],i,d[j][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\ntypedef long long ll;\nstruct edge{\n\tint to;\n\tll cost;\n};\nstruct state{\n\tint mag;\n\tll dist;\n\tint id;\n/*\tbool operator<(const state& s) const {\n\t\tif(mag!=s.mag) return mag<s.mag;\n\t\tif(dist!=s.dist) return dist<s.dist;\n\t\treturn id<s.id;\n\t}*/\n\tbool operator>(const state& s) const {\n\t\tif(mag!=s.mag) return mag>s.mag;\n\t\tif(dist!=s.dist) return dist>s.dist;\n\t\treturn id>s.id;\n\t}\n};\nint N,M,s1,s2,t,magic;\nll d[1000][101];\nll inf=1e18;\nvector<edge> G[1000];\nint To_int(string s){\n\tint ret=0;\n\trep(i,s.size()){\n\t\tret*=10;\n\t\tret+=s[i]-'0';\n\t}\n\treturn ret;\n}\nvoid dijkstra(int s){\n\trep(i,N) rep(j,magic+1) d[i][j]=inf;\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\td[s][0]=0;\n\tque.push(state{0,0,s});\n\twhile(!que.empty()){\n\t\tstate st=que.top();\n\t\tque.pop();\n\t\tint mag=st.mag;\n\t\tll dis=st.dist;\n\t\tint v=st.id;\n\t\tif(d[v][mag]!=dis) continue;\n\t\tfor(auto e:G[v]){\n\t\t\tif(e.cost==-1){\n\t\t\t\tif(mag==magic) continue;\n\t\t\t\tif(d[v][mag]<d[e.to][mag+1]){\n\t\t\t\t\td[e.to][mag+1]=d[v][mag];\n\t\t\t\t\tque.push(state{mag+1,d[e.to][mag+1],e.to});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(d[v][mag]+e.cost<d[e.to][mag]){\n\t\t\t\t\td[e.to][mag]=d[v][mag]+e.cost;\n\t\t\t\t\tque.push(state{mag,d[e.to][mag],e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool ispal(L a,L b){\n\treturn abs(cro(a.fs-a.sc,b.fs-b.sc))<1e-9;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>s1>>s2>>t;\n\t\tmagic=0;\n\t\ts1--,s2--,t--;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint a,b;\n\t\t\tstring w;\n\t\t\tcin>>a>>b>>w;\n\t\t\ta--,b--;\n\t\t\tif(w[0]=='x'){\n\t\t\t\tG[a].pb(edge{b,-1});\n\t\t\t\tG[b].pb(edge{a,-1});\n\t\t\t\tmagic++;\n\t\t\t}else{\n\t\t\t\tint ww=To_int(w);\n\t\t\t\tG[a].pb(edge{b,ww});\n\t\t\t\tG[b].pb(edge{a,ww});\n\t\t\t}\n\t\t}\n\t\tdijkstra(t);\n//\t\trep(i,magic+1) printf(\"d[s1][%d]=%lld\\n\",i,d[s1][i]);\n//\t\trep(i,magic+1) printf(\"d[s2][%d]=%lld\\n\",i,d[s2][i]);\n\n//\t\tputs(\"done\");\n\t\tvector<L> vla;\n\t\tvector<D> cha;\n\t\tvector<int> Aa;\n\t\t{\n\t\t\tll mn=inf;\n\t\t\trep(i,magic+1){\n\t\t\t\tif(mn<=d[s1][i]) continue;\n\t\t\t\tmn=d[s1][i];\n\t\t\t\tvla.pb(L(P(0,d[s1][i]),P(1,d[s1][i]+i)));\n\t\t\t\tAa.pb(i);\n\t\t\t}\n\t\t\treverse(all(vla));\n\t\t\treverse(all(Aa));\n\t\t\tint K=vla.size();\n\t\t\trep(i,K-1){\n\t\t\t\tP p=intLL(vla[i],vla[i+1]);\n\t\t\t\tcha.pb(p.real());\n\t\t\t}\n\t\t}\n\t\tvector<L> vlb;\n\t\tvector<D> chb;\n\t\tvector<int> Ab;\n\t\t{\n\t\t\tll mn=inf;\n\t\t\trep(i,magic+1){\n\t\t\t\tif(mn<=d[s2][i]) continue;\n\t\t\t\tmn=d[s2][i];\n\t\t\t\tvlb.pb(L(P(0,d[s2][i]),P(1,d[s2][i]+i)));\n\t\t\t\tAb.pb(i);\n\t\t\t}\n\t\t\treverse(all(vlb));\n\t\t\treverse(all(Ab));\n\t\t\tint K=vlb.size();\n\t\t\trep(i,K-1){\n\t\t\t\tP p=intLL(vlb[i],vlb[i+1]);\n\t\t\t\tchb.pb(p.real());\n\t\t\t}\n\t\t}\n/*\t\trep(i,vla.size()){\n\t\t\tcout<<vla[i].fs<<\" \"<<vla[i].sc<<endl;\n\t\t}\n\t\tputs(\"\");\n\t\trep(i,vlb.size()){\n\t\t\tcout<<vlb[i].fs<<\" \"<<vlb[i].sc<<endl;\n\t\t}\n\t\trep(i,Aa.size()) show(Aa[i]);\n\t\trep(i,Ab.size()) show(Ab[i]);*/\n\t\tvector<ll> xs;\n\t\txs.pb(0);\n\t\tfor(D x:cha) rep(i,5) xs.pb((ll)x+i-2);\n\t\tfor(D x:chb) rep(i,5) xs.pb((ll)x+i-2);\n\t\tcha.pb(inf);\n\t\tchb.pb(inf);\n\t\tcha.insert(cha.begin(),0);\n\t\tchb.insert(chb.begin(),0);\n/*\t\tshow(vla.size());\n\t\tshow(vlb.size());\n\t\tshow(cha.size());\n\t\tshow(chb.size());*/\n\t\trep(i,vla.size()) rep(j,vlb.size()){\n\t\t\tL a=vla[i],b=vlb[j];\n\t\t\tif(ispal(a,b)) continue;\n\t\t\tP p=intLL(a,b);\n\t\t\tD x=p.real();\n\t\t\tif(cha[i]-2<x&&x-2<cha[i+1]&&chb[j]-2<x&&x-2<chb[j+1]){\n\t\t\t\trep(i,5) xs.pb((ll)x+i-2);\n\t\t\t}\n\t\t}\n\t\tll ans=inf;\n//\t\trep(i,chb.size()) show(chb[i]);\n\t\tsort(all(xs));\n\t\txs.erase(unique(all(xs)),xs.end());\n\t\tfor(ll x:xs){\n\t\t\tif(x<0||x>inf) continue;\n\t\t\tll A=inf,B=inf;\n\t\t\trep(i,vla.size()){\n\t\t\t\tll a=Aa[i];\n\t\t\t\tll b=d[s1][a];\n\t\t\t\tchmin(A,a*x+b);\n\t\t\t}\n\t\t\trep(i,vlb.size()){\n\t\t\t\tll a=Ab[i];\n\t\t\t\tll b=d[s2][a];\n\t\t\t\tchmin(B,a*x+b);\n\t\t\t}\n\t\t\tchmin(ans,abs(A-B));\n/*\t\t\tint ida_=lower_bound(all(cha),x)-cha.begin()-1;\n\t\t\tll A=inf;\n\t\t\t{\n\t\t\t\tfor(int ida=ida_-1;ida<=ida_+1;ida++){\n\t\t\t\t\tif(ida<0||ida>=vla.size()) continue;\n\t\t\t\t\tll a=Aa[ida];\n\t\t\t\t\tll b=d[s1][a];\n//\t\t\t\t\tshow(ida);\n//\t\t\t\t\tshow(a);\n//\t\t\t\t\tshow(b);\n\t\t\t\t\tchmin(A,a*x+b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idb_=lower_bound(all(chb),x)-chb.begin()-1;\n\t\t\tll B=inf;\n\t\t\t{\n\t\t\t\tfor(int idb=idb_-1;idb<=idb_+1;idb++){\n\t\t\t\t\tif(idb<0||idb>=vlb.size()) continue;\n\t\t\t\t\tll a=Ab[idb];\n\t\t\t\t\tll b=d[s2][a];\n//\t\t\t\t\tshow(idb);\n//\t\t\t\t\tshow(a);\n//\t\t\t\t\tshow(b);\n\t\t\t\t\tchmin(B,a*x+b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tshow(x);\n\t\t\tif(x==2){\n\t\t\tshow(A);\n\t\t\tshow(B);\n\t\t\tshow(ida_);\n\t\t\tshow(idb_);\n\t\t\t}\n\t\t\tchmin(ans,abs(A-B));*/\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{\n    int dst;\n    LL cost;\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nint N, M, S1, S2, T;\nint MB;\nconst LL INF = 1e18;\nvector<LL> calc_cost(int s, int t) {\n    LL dist[1000][101] = {};\n    typedef tuple<LL, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> que;\n    REP(i, N) REP(j, MB+1) dist[i][j] = INF;\n    dist[s][0] = 0;\n    que.push(TP(0, s, 0));\n    while(!que.empty()) {\n        int d, u, c;\n        tie(d, u, c) = que.top(); que.pop();\n        for(Edge e : G[u]) {\n            const int nu = e.dst;\n            const int nc = c + (e.cost == -1 ? 1 : 0);\n            const LL nd = d + (e.cost == -1 ? 0 : e.cost);\n            if(nc <= MB && dist[nu][nc] > nd) {\n                dist[nu][nc] = nd;\n                que.push(TP(nd, nu, nc));\n            }\n        }\n    }\n    vector<LL> res(MB+1);\n    REP(i, MB+1) res[i] = dist[t][i];\n    return res;\n}\n// O(N)\nLL get(vector<LL> cs, LL X) {\n    LL res = cs[0];\n    for(int i = 1; i < cs.size(); i++) {\n        res = min(res, cs[i] + i * X);\n    }\n    return res;\n}\n// O(N)\nLL calc_diff(vector<LL> cs1, vector<LL> cs2, LL X) {\n    LL cost1 = get(cs1, X);\n    LL cost2 = get(cs2, X);\n    return abs(cost1 - cost2);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> M >> S1 >> S2 >> T && N > 0) {\n        MB = 0;\n        S1--; S2--; T--;\n        G.resize(N);\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            string ws;\n            cin >> ws;\n            LL w;\n            if(ws == \"x\") {\n                w = -1;\n                MB++;\n            } else {\n                w = stoi(ws);\n            }\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n        }\n        vector<LL> cs1 = calc_cost(S1, T);\n        vector<LL> cs2 = calc_cost(S2, T);\n        LL ans = calc_diff(cs1, cs2, 0);\n        REP(i, cs1.size()) REP(j, cs1.size()) if(i < j) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs1[i] - cs1[j]) / (j-i);\n            for(LL dx = max(-X, -1LL); dx <= 1; dx++) {\n                ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        REP(i, cs2.size()) REP(j, cs2.size()) if(i < j) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs2[i] - cs2[j]) / (j-i);\n            for(LL dx = max(-X, -1LL); dx <= 1; dx++) {\n                ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,int> P;\nvector<P> G[1111];\nint dp1[111][1111];\nint dp2[111][1111];\nint INF=1LL<<45LL;\nstruct st{\n  int x,v,d;\n  st(){}\n  st(int x,int v,int d):x(x),v(v),d(d){}\n  bool operator<(const st a)const{\n    return d>a.d;\n  }\n};\nint n,m,s1,s2,t;\nint ans;\nint calc1(int i,int x){\n  return dp1[i][t]+i*x;\n}\nint calc2(int i,int x){\n  return dp2[i][t]+i*x;\n}\nint check1(int x){\n  int res=-1;\n  for(int i=0;i<111;i++){\n    if(dp1[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc1(i,x)<calc1(res,x)) res=i;\n  }\n  return res;\n}\nint check2(int x){\n  int res=0;\n  for(int i=0;i<111;i++){\n    if(dp2[i][t]==INF) continue;\n    if(res<0) res=i;\n    if(calc2(i,x)<calc2(res,x)) res=i;\n  }\n  return res;\n}\nint calc3(int x){\n  return calc1(check1(x),x)-calc2(check2(x),x);\n}\nsigned main(){\n  while(cin>>n>>m>>s1>>s2>>t,n){\n    s1--;s2--;t--;\n    for(int i=0;i<1111;i++) G[i].clear(); \n    for(int i=0;i<m;i++){\n      int a,b,w;\n      string s;\n      cin>>a>>b>>s;\n      if(s==\"x\") w=-1;\n      else w=stoll(s);\n      a--;b--;\n      G[a].push_back(P(b,w));\n      G[b].push_back(P(a,w));\n    }\n    for(int i=0;i<111;i++){\n      fill(dp1[i],dp1[i]+1111,INF);\n      fill(dp2[i],dp2[i]+1111,INF);\n    }\n    priority_queue<st> q;\n    q.emplace(0,s1,0);\n    dp1[0][s1]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp1[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      //cout<<p.x<<\" \"<<p.v<<\" \"<<p.d<<endl;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp1[nx][nv]<=nd) continue;\n\tdp1[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //puts(\"OK\");\n    q.emplace(0,s2,0);\n    dp2[0][s2]=0;\n    while(!q.empty()){\n      st p=q.top();q.pop();\n      if(dp2[p.x][p.v]<p.d) continue;\n      if(p.x>105) continue;\n      for(P u:G[p.v]){\n\tint nv=u.first,nx=p.x+(~u.second?0:1),nd=p.d+(~u.second?u.second:0);\n\tif(dp2[nx][nv]<=nd) continue;\n\tdp2[nx][nv]=nd;\n\tq.emplace(nx,nv,nd);\n      }\n    }\n    //for(int i=0;i<11;i++) cout<<i<<\":dp1:\"<<dp1[i][t]<<endl;\n    //for(int i=0;i<11;i++) cout<<i<<\":dp2:\"<<dp2[i][t]<<endl;\n    \n    vector<int> b;\n    b.push_back(0);\n    b.push_back(INF);\n    int L=0;\n    while(check1(L)!=check1(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check1(L)!=check1(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    L=0;\n    while(check2(L)!=check2(INF)){\n      int l=L,r=INF;\n      while(l+1<r){\n\tint mid=(l+r)/2;\n\tif(check2(L)!=check2(mid)) r=mid;\n\telse l=mid;\n      }\n      L=l+1;\n      b.push_back(L);\n    }\n    sort(b.begin(),b.end());\n    b.erase(unique(b.begin(),b.end()),b.end());\n    ans=INF;\n    for(int i=0;i<(int)b.size();i++){\n      ans=min(ans,abs(calc3(b[i])));\n      if(i==(int)b.size()-1) break;\n      int x=b[i],y=b[i+1]-1;\n      ans=min(ans,abs(calc3(y)));\n      if(x==y) continue;\n      if(calc3(x)*calc3(y)<0){\n\tint d=calc3(x+1)-calc3(x);\n\tif(d==0) continue;\n\tint tmp=abs(calc3(x));\n\tans=min(ans,abs(tmp-(tmp/d*d)));\n\tans=min(ans,abs(((tmp/d+1)*d)-tmp));\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-2;i<=m+2;i++){\n    if(i<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    cands.insert(0);\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[i][S1]);\n\tadd_cands(j,d[j][S2],i,d[i][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\nll dist2[1001];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tdist2[s]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tif(dist2[curv]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tif(dist2[e.t]<dist[type][curv][curu]+e.c)continue;\n\t\t\t\tdist2[e.t]=dist[type][curv][curu]+e.c;\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tif(curu==100)continue;\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tif(dist2[e.t]<=dist[type][curv][curu]+e.c)continue;\n\t\t\t\tdist2[e.t]=dist[type][curv][curu]+e.c;\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(dist[0][t][i]>=INF)return INF;\n\tif(dist[1][t][j]>=INF)return INF;\n\tif(i==j){\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tll va=(ll)dist[0][t][i]+i*k;\n\t\tll vb=(ll)dist[1][t][j]+j*k;\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdijk(0,s1);\n\tfor(int i=0;i<n;i++){\n\t\tdist2[i]=INF;\n\t}\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<queue>\n#include<cmath>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int lim = 1<<30;\nconst int maxn = 1005;\nconst int maxl = 105;\nconst ll inf = 1ll<<50;\nconst double eps = 1e-8;\n\nstruct edge\n{\n\tint to,val,mag;\n\tedge(int a,int b,int c):to(a),val(b),mag(c){}\n};\n\nstruct node\n{\n\tint to,mag;\n\tll len;\n\tnode(int a,int b,ll c):to(a),mag(b),len(c){}\n\tbool operator<(const node& a)const\n\t{\n\t\treturn len > a.len;\n\t}\n};\n\nstruct point\n{\n\tdouble xi,lef,di;\n\tpoint(){}\n\tpoint(double a,double b,double c):xi(a),lef(b),di(c){}\n};\n\nvector<edge> v[maxn];\nbool vis[maxn][maxl];\nll dis[maxn][maxl];\n\nint n,s1,s2,tt,sp;\nstruct line\n{\n\tpoint s[maxl];int top;\n\tvoid build()\n\t{\n\t\ttop = 0;\n\t\tfor(int i=sp;i>=0;i--)\n\t\t{\n\t\t\tif(dis[tt][i]==inf)\n\t\t\t\tcontinue;\n\t\t\twhile(top&&i*s[top-1].lef+dis[tt][i]<=eps+s[top-1].xi*s[top-1].lef+s[top-1].di)\n\t\t\t\ttop--;\n\t\t\ts[top] = point(i,top?(dis[tt][i]-s[top-1].di)/(s[top-1].xi-i):0,dis[tt][i]);\n\t\t\ttop++;\n\t\t}\n\t}\n}p1,p2;\n\nint f1,f2;\n\ndouble f(double x)\n{\n\treturn fabs(p1.s[f1].xi*x+p1.s[f1].di-p2.s[f2].xi*x-p2.s[f2].di);\n}\nll cal(double pl,double pr)\n{\n\tdouble l = pl,r = pr,m1,m2;\n\twhile(r-l>0.0001)\n\t{\n\t\tm1 = l + (r-l)/3,m2 = r - (r-l)/3;\n\t\tif(f(m1)>f(m2))\n\t\t\tl = m1;\n\t\telse\n\t\t\tr = m2;\n\t}\n\tdouble res = inf;\n\tint po = round(l+0.5);\n\tif(po<=pr+eps)\n\t\tres = min(res,f(po));\n\tpo = round(l-0.5);\n\tif(po>=pl-eps)\n\t\tres = min(res,f(po));\n\treturn res;\n}\nll sol()\n{\n\tll res = inf;\n\tvector<double> bl,v1,v2;\n\tfor(int i=0;i<p1.top;i++)\n\t{\n\t\tv1.push_back(p1.s[i].lef);\n\t\tbl.push_back(p1.s[i].lef);\n\t}\n\tfor(int i=0;i<p2.top;i++)\n\t{\n\t\tv2.push_back(p2.s[i].lef);\n\t\tbl.push_back(p2.s[i].lef);\n\t}\n\tsort(bl.begin(),bl.end());bl.push_back(lim);\n\tfor(int i=1;i<bl.size();i++)\n\t{\n\t\tdouble va = bl[i];\n\t\tf1 = lower_bound(v1.begin(),v1.end(),va-eps)-v1.begin()-1;\n\t\tf2 = lower_bound(v2.begin(),v2.end(),va-eps)-v2.begin()-1;\n\t\tres = min(cal(bl[i-1],va),res);\n\t}\n\treturn res;\n}\nvoid dij(int s)\n{\n\tpriority_queue<node> q;\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t\tfill(dis[i],dis[i]+sp+1,inf);\n\tdis[s][0] = 0;q.push(node(s,0,0));\n\twhile(!q.empty())\n\t{\n\t\tnode t = q.top();q.pop();\n\t\tif(vis[t.to][t.mag])\n\t\t\tcontinue;\n\t\tvis[t.to][t.mag] = 1;\n\t\tfor(int i=0;i<v[t.to].size();i++)\n\t\t{\n\t\t\tint toit = v[t.to][i].to;\n\t\t\tif(dis[toit][t.mag+v[t.to][i].mag]>dis[t.to][t.mag]+v[t.to][i].val)\n\t\t\t{\n\t\t\t\tdis[toit][t.mag+v[t.to][i].mag]=dis[t.to][t.mag]+v[t.to][i].val;\n\t\t\t\tq.push(node(toit,t.mag+v[t.to][i].mag,dis[toit][t.mag+v[t.to][i].mag]));\n\t\t\t}\n\t\t}\n\t}\n}\nint main()\n{\n\tint m,a,b;char s[20];\n\twhile(scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&tt)&&n)\n\t{\n\t\tsp = 0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tv[i].clear();\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%s\",&a,&b,s);\n\t\t\tif(s[0]=='x')\n\t\t\t{\n\t\t\t\tsp++;\n\t\t\t\tv[a].push_back(edge(b,0,1));\n\t\t\t\tv[b].push_back(edge(a,0,1));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint val = atoi(s);\n\t\t\t\tv[a].push_back(edge(b,val,0));\n\t\t\t\tv[b].push_back(edge(a,val,0));\n\t\t\t}\n\t\t}\n\t\tdij(s1);p1.build();\n\t\tdij(s2);p2.build();\n\t\tprintf(\"%lld\\n\",sol());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#define llint long long\n#define inf 1e18\n#define xmax 1000000000000\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct edge{\n\tllint to, cost;\n\tedge(llint a, llint b){\n\t\tto = a, cost = b;\n\t}\n};\n\nllint N, M, S[2], T;\nvector<edge> G[1005];\nvector<llint> vec;\nllint dist[1005];\n\nvoid dijkstra(llint S, llint x)\n{\n\tfor(int i = 1; i <= N; i++) dist[i] = inf;\n\tdist[S] = 0;\n\t\n\tpriority_queue< P, vector<P>, greater<P> > Q;\n\tQ.push( make_pair(0, S) );\n\t\n\tllint v, d;\n\twhile(Q.size()){\n\t\td = Q.top().first;\n\t\tv = Q.top().second;\n\t\tQ.pop();\n\t\tif(dist[v] < d) continue;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tllint cost = G[v][i].cost;\n\t\t\tif(cost == -1) cost = x;\n\t\t\tif(dist[G[v][i].to] > d + cost){\n\t\t\t\tdist[G[v][i].to] = d + cost;\n\t\t\t\tQ.push( make_pair(dist[G[v][i].to], G[v][i].to) );\n\t\t\t}\n\t\t}\n\t}\n}\n\nllint calc(llint i, llint x)\n{\n\tdijkstra(S[i], x);\n\treturn dist[T];\n}\n\nbool check(llint i, llint x, llint a, llint b)\n{\n\tllint f = calc(i, x);\n\treturn a*x+b == f;\n}\n\nvoid make(llint i)\n{\n\tllint x = 0, a, b;\n\tvec.push_back(0);\n\twhile(x < xmax){\n\t\tllint f = calc(i, x), f2 = calc(i, x+1);\n\t\ta = f2 - f, b = f - a*x;\n\t\tllint ub = xmax+1, lb = x+1, mid;\n\t\twhile(ub - lb > 1){\n\t\t\tmid = (ub + lb) / 2;\n\t\t\tif(check(i, mid, a, b)) lb = mid;\n\t\t\telse ub = mid;\n\t\t}\n\t\tvec.push_back(lb);\n\t\tx = lb;\n\t}\n}\n\nllint get(llint sx, llint tx)\n{\n\tllint big = 0, small = 1;\n\tif(calc(0, sx) < calc(1, sx)) swap(big, small);\n\t\n\tllint ub = tx, lb = sx+1, mid;\n\twhile(ub - lb > 1){\n\t\tmid = (ub + lb) / 2;\n\t\tif(calc(big, mid) > calc(small, mid)) lb = mid;\n\t\telse ub = mid;\n\t}\n\treturn lb;\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M >> S[0] >> S[1] >> T;\n\t\tif(!N && !M && !S[0] && !S[1] && !T) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++) G[i].clear();\n\t\tllint u, v, w; string s;\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tcin >> u >> v >> s;\n\t\t\tif(s == \"x\") w = -1;\n\t\t\telse w = atoi(s.c_str());\n\t\t\tG[u].push_back(edge(v, w));\n\t\t\tG[v].push_back(edge(u, w));\n\t\t}\n\t\t\n\t\tvec.clear();\n\t\tmake(0), make(1);\n\t\tsort(vec.begin(), vec.end());\n\t\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\t\n\t\tllint ans = inf;\n\t\tfor(int i = 0; i < (int)vec.size()-1; i++){\n\t\t\tllint s0 = calc(0, vec[i]), s1 = calc(1, vec[i]);\n\t\t\tllint t0 = calc(0, vec[i+1]), t1 = calc(1, vec[i+1]);\n\t\t\tif((s0-s1)*(t0-t1) >= 0){\n\t\t\t\tans = min(ans, abs(s0 - s1));\n\t\t\t\tans = min(ans, abs(t0 - t1));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tllint cx = get(vec[i], vec[i+1]);\n\t\t\t\tans = min(ans, abs(calc(0, cx) - calc(1, cx)));\n\t\t\t\tans = min(ans, abs(calc(0, cx+1) - calc(1, cx+1)));\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 60;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    vector< edge > G[1000];\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int64 cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n\n    for(auto &cost : latte) ret = min(ret, get(cost));\n    for(auto &cost : latte) ret = min(ret, get(cost + 1));\n\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\ntypedef long long ll;\nstruct edge{\n\tint to;\n\tll cost;\n};\nstruct state{\n\tint mag;\n\tll dist;\n\tint id;\n/*\tbool operator<(const state& s) const {\n\t\tif(mag!=s.mag) return mag<s.mag;\n\t\tif(dist!=s.dist) return dist<s.dist;\n\t\treturn id<s.id;\n\t}*/\n\tbool operator>(const state& s) const {\n\t\tif(mag!=s.mag) return mag>s.mag;\n\t\tif(dist!=s.dist) return dist>s.dist;\n\t\treturn id>s.id;\n\t}\n};\nint N,M,s1,s2,t,magic;\nll d[1000][101];\nll inf=1e18;\nvector<edge> G[1000];\nint To_int(string s){\n\tint ret=0;\n\trep(i,s.size()){\n\t\tret*=10;\n\t\tret+=s[i]-'0';\n\t}\n\treturn ret;\n}\nvoid dijkstra(int s){\n\trep(i,N) rep(j,magic+1) d[i][j]=inf;\n\tpriority_queue<state,vector<state>,greater<state> > que;\n\td[s][0]=0;\n\tque.push(state{0,0,s});\n\twhile(!que.empty()){\n\t\tstate st=que.top();\n\t\tque.pop();\n\t\tint mag=st.mag;\n\t\tll dis=st.dist;\n\t\tint v=st.id;\n\t\tif(d[v][mag]!=dis) continue;\n\t\tfor(auto e:G[v]){\n\t\t\tif(e.cost==-1){\n\t\t\t\tif(mag==magic) continue;\n\t\t\t\tif(d[v][mag]<d[e.to][mag+1]){\n\t\t\t\t\td[e.to][mag+1]=d[v][mag];\n\t\t\t\t\tque.push(state{mag+1,d[e.to][mag+1],e.to});\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(d[v][mag]+e.cost<d[e.to][mag]){\n\t\t\t\t\td[e.to][mag]=d[v][mag]+e.cost;\n\t\t\t\t\tque.push(state{mag,d[e.to][mag],e.to});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nD cro(P a,P b){return imag(conj(a)*b);}\nbool ispal(L a,L b){\n\treturn abs(cro(a.fs-a.sc,b.fs-b.sc))<1e-9;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>s1>>s2>>t;\n\t\tmagic=0;\n\t\ts1--,s2--,t--;\n\t\tif(N==0) break;\n\t\trep(i,N) G[i].clear();\n\t\trep(i,M){\n\t\t\tint a,b;\n\t\t\tstring w;\n\t\t\tcin>>a>>b>>w;\n\t\t\ta--,b--;\n\t\t\tif(w[0]=='x'){\n\t\t\t\tG[a].pb(edge{b,-1});\n\t\t\t\tG[b].pb(edge{a,-1});\n\t\t\t\tmagic++;\n\t\t\t}else{\n\t\t\t\tint ww=To_int(w);\n\t\t\t\tG[a].pb(edge{b,ww});\n\t\t\t\tG[b].pb(edge{a,ww});\n\t\t\t}\n\t\t}\n\t\tdijkstra(t);\n//\t\trep(i,magic+1) printf(\"d[s1][%d]=%lld\\n\",i,d[s1][i]);\n//\t\trep(i,magic+1) printf(\"d[s2][%d]=%lld\\n\",i,d[s2][i]);\n\n//\t\tputs(\"done\");\n\t\tvector<L> vla,nvla;\n\t\tvector<D> cha;\n\t\tvector<int> Aa,nAa;\n\t\t{\n\t\t\tll mn=inf;\n\t\t\trep(i,magic+1){\n\t\t\t\tif(mn<=d[s1][i]) continue;\n\t\t\t\tmn=d[s1][i];\n\t\t\t\tvla.pb(L(P(0,d[s1][i]),P(1,d[s1][i]+i)));\n\t\t\t\tAa.pb(i);\n\t\t\t}\n\t\t\treverse(all(vla));\n\t\t\treverse(all(Aa));\n\t\t\tint K=vla.size();\n\t\t\tnvla.pb(vla[0]);\n\t\t\tnAa.pb(Aa[0]);\n\t\t\trep1(i,K-1){\n\t\t\t\tint j=(int)nvla.size() -1;\n\t\t\t\twhile(j>=0){\n\t\t\t\t\tD x=intLL(vla[i],nvla[j]).real();\n\t\t\t\t\tif(j==0||x>cha[j-1]){\n\t\t\t\t\t\tcha.pb(x);\n\t\t\t\t\t\tnvla.pb(vla[i]);\n\t\t\t\t\t\tnAa.pb(Aa[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj--;\n\t\t\t\t\tnvla.pop_back();\n\t\t\t\t\tcha.pop_back();\n\t\t\t\t\tnAa.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvla=nvla,Aa=nAa;\n\t\t}\n\t\tvector<L> vlb,nvlb;\n\t\tvector<D> chb;\n\t\tvector<int> Ab,nAb;\n\t\t{\n\t\t\tll mn=inf;\n\t\t\trep(i,magic+1){\n\t\t\t\tif(mn<=d[s2][i]) continue;\n\t\t\t\tmn=d[s2][i];\n\t\t\t\tvlb.pb(L(P(0,d[s2][i]),P(1,d[s2][i]+i)));\n\t\t\t\tAb.pb(i);\n\t\t\t}\n\t\t\treverse(all(vlb));\n\t\t\treverse(all(Ab));\n\t\t\tint K=vlb.size();\n\t\t\tnvlb.pb(vlb[0]);\n\t\t\tnAb.pb(Ab[0]);\n\t\t\trep1(i,K-1){\n\t\t\t\tint j=(int)nvlb.size() -1;\n\t\t\t\twhile(j>=0){\n\t\t\t\t\tD x=intLL(vlb[i],nvlb[j]).real();\n\t\t\t\t\tif(j==0||x>chb[j-1]){\n\t\t\t\t\t\tchb.pb(x);\n\t\t\t\t\t\tnvlb.pb(vlb[i]);\n\t\t\t\t\t\tnAb.pb(Ab[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj--;\n\t\t\t\t\tnvlb.pop_back();\n\t\t\t\t\tchb.pop_back();\n\t\t\t\t\tnAb.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvlb=nvlb,Ab=nAb;\n\t\t}\n/*\t\trep(i,vla.size()){\n\t\t\tcout<<vla[i].fs<<\" \"<<vla[i].sc<<endl;\n\t\t}\n\t\tputs(\"\");\n\t\trep(i,vlb.size()){\n\t\t\tcout<<vlb[i].fs<<\" \"<<vlb[i].sc<<endl;\n\t\t}\n\t\trep(i,Aa.size()) show(Aa[i]);\n\t\trep(i,Ab.size()) show(Ab[i]);*/\n\t\tvector<ll> xs;\n\t\txs.pb(0);\n\t\tfor(D x:cha) rep(i,3) xs.pb((ll)x+i-1);\n\t\tfor(D x:chb) rep(i,3) xs.pb((ll)x+i-1);\n\t\tcha.pb(inf);\n\t\tchb.pb(inf);\n\t\tcha.insert(cha.begin(),0);\n\t\tchb.insert(chb.begin(),0);\n/*\t\tshow(vla.size());\n\t\tshow(vlb.size());\n\t\tshow(cha.size());\n\t\tshow(chb.size());*/\n\t\trep(i,vla.size()) rep(j,vlb.size()){\n\t\t\tL a=vla[i],b=vlb[j];\n\t\t\tif(ispal(a,b)) continue;\n\t\t\tP p=intLL(a,b);\n\t\t\tD x=p.real();\n\t\t\trep(i,11) xs.pb((ll)x+i-5);\n\t\t}\n\t\tll ans=inf;\n//\t\trep(i,chb.size()) show(chb[i]);\n\t\tsort(all(xs));\n\t\txs.erase(unique(all(xs)),xs.end());\n\t\tfor(ll x:xs){\n\t\t\tif(x<0||x>inf) continue;\n\t\t\tll A=inf,B=inf;\n\t\t\trep(i,vla.size()){\n\t\t\t\tll a=Aa[i];\n\t\t\t\tll b=d[s1][a];\n\t\t\t\tchmin(A,a*x+b);\n\t\t\t}\n\t\t\trep(i,vlb.size()){\n\t\t\t\tll a=Ab[i];\n\t\t\t\tll b=d[s2][a];\n\t\t\t\tchmin(B,a*x+b);\n\t\t\t}\n\t\t\tchmin(ans,abs(A-B));\n/*\t\t\tint ida_=lower_bound(all(cha),x)-cha.begin()-1;\n\t\t\tll A=inf;\n\t\t\t{\n\t\t\t\tfor(int ida=ida_-1;ida<=ida_+1;ida++){\n\t\t\t\t\tif(ida<0||ida>=vla.size()) continue;\n\t\t\t\t\tll a=Aa[ida];\n\t\t\t\t\tll b=d[s1][a];\n//\t\t\t\t\tshow(ida);\n//\t\t\t\t\tshow(a);\n//\t\t\t\t\tshow(b);\n\t\t\t\t\tchmin(A,a*x+b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint idb_=lower_bound(all(chb),x)-chb.begin()-1;\n\t\t\tll B=inf;\n\t\t\t{\n\t\t\t\tfor(int idb=idb_-1;idb<=idb_+1;idb++){\n\t\t\t\t\tif(idb<0||idb>=vlb.size()) continue;\n\t\t\t\t\tll a=Ab[idb];\n\t\t\t\t\tll b=d[s2][a];\n//\t\t\t\t\tshow(idb);\n//\t\t\t\t\tshow(a);\n//\t\t\t\t\tshow(b);\n\t\t\t\t\tchmin(B,a*x+b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tshow(x);\n\t\t\tif(x==2){\n\t\t\tshow(A);\n\t\t\tshow(B);\n\t\t\tshow(ida_);\n\t\t\tshow(idb_);\n\t\t\t}\n\t\t\tchmin(ans,abs(A-B));*/\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\nconst int64 INF = 1LL << 59;\ntypedef tuple< int64, int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint main()\n{\n  int N, M, S1, S2, T;\n  vector< edge > G[1000];\n  int64 dp[1000][101];\n\n  while(cin >> N >> M >> S1 >> S2 >> T, N) {\n    --S1, --S2, --T;\n\n    int edged = 0;\n    for(int i = 0; i < M; i++) {\n      int a, b;\n      string c;\n      cin >> a >> b >> c;\n      --a, --b;\n      if(c == \"x\") {\n        G[a].emplace_back((edge) {b, -1});\n        G[b].emplace_back((edge) {a, -1});\n        ++edged;\n      } else {\n        G[a].emplace_back((edge) {b, stoi(c)});\n        G[b].emplace_back((edge) {a, stoi(c)});\n      }\n    }\n\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    fill_n(*dp, 101 * 1000, INF);\n    dp[T][0] = 0;\n    que.emplace(0, T, 0);\n    while(!que.empty()) {\n      int cost, now, slow;\n      tie(cost, now, slow) = que.top();\n      que.pop();\n      if(cost > dp[now][slow]) continue;\n      for(auto &e : G[now]) {\n        int64 ncost = cost, nslow = slow;\n        if(e.cost == -1) ++nslow;\n        else ncost += e.cost;\n        if(nslow > edged || ncost >= dp[e.to][nslow]) continue;\n        dp[e.to][nslow] = ncost;\n        que.emplace(ncost, e.to, nslow);\n      }\n    }\n\n    vector< int64 > latte;\n    latte.push_back(0);\n    latte.push_back(10000000000000LL);\n    for(int i = 0; i <= edged; i++) {\n      for(int j = i + 1; j <= edged; j++) {\n        latte.emplace_back((dp[S1][i] - dp[S1][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S1][i] - dp[S2][j]) / (j - i));\n        latte.emplace_back((dp[S2][i] - dp[S1][j]) / (j - i));\n      }\n    }\n\n    int64 ret = INF;\n    auto get = [&](int64 v)\n    {\n      v = max(v, 0LL);\n      int64 aa = INF, bb = INF;\n      for(int i = 0; i <= edged; i++) aa = min(aa, dp[S1][i] + i * v);\n      for(int i = 0; i <= edged; i++) bb = min(bb, dp[S2][i] + i * v);\n      return (llabs(aa - bb));\n    };\n    for(auto &cost : latte) ret = min(ret, get(cost - 1));\n    for(auto &cost : latte) ret = min(ret, get(cost));\n    for(auto &cost : latte) ret = min(ret, get(cost + 1));\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll INF=1LL<<61;\n\nstruct edge{\n\tint v;\n\tll cost;\n\tint type; // 0: normal edge, 1: magical edge\n};\n\nstruct point{ double x,y; };\n\n// y=a1*x+b1, y=a2*x+b2 の交点\npoint crosspoint(ll a1,ll b1,ll a2,ll b2){\n\tdouble x=(double)(b2-b1)/(a1-a2);\n\tdouble y=a1*x+b1;\n\treturn (point){x,y};\n}\n\n// y = 0*x+d[0]\n// y = 1*x+d[1]\n// y = 2*x+d[2]\n//   :\n// y = k*x+d[k]\n// で定まる下側エンベロープの x での値を求める\nll eval(int k,const ll *d,ll x){\n\tll res=INF;\n\trep(i,k+1) res=min(res,i*x+d[i]);\n\treturn res;\n}\n\nint main(){\n\tfor(int n,m,s1,s2,t;scanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t),n;){\n\t\ts1--; s2--; t--;\n\t\tvector<edge> G[1000];\n\t\tint k=0; // magical edge の本数\n\t\trep(i,m){\n\t\t\tint u,v;\n\t\t\tchar cost[16]; scanf(\"%d%d%s\",&u,&v,cost); u--; v--;\n\t\t\tif(cost[0]!='x'){\n\t\t\t\tint c=atoi(cost);\n\t\t\t\tG[u].push_back((edge){v,c,0});\n\t\t\t\tG[v].push_back((edge){u,c,0});\n\t\t\t}\n\t\t\telse{\n\t\t\t\tG[u].push_back((edge){v,0,1});\n\t\t\t\tG[v].push_back((edge){u,0,1});\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\n\t\tstatic ll d[1000][101];\n\t\trep(u,n) rep(i,k+1) d[u][i]=INF;\n\t\td[t][0]=0;\n\t\tpriority_queue< pair< ll,pair<int,int> > > Q; Q.push(make_pair(0,make_pair(t,0)));\n\t\twhile(!Q.empty()){\n\t\t\tll d_now=-Q.top().first;\n\t\t\tint u=Q.top().second.first,i=Q.top().second.second; Q.pop();\n\n\t\t\tif(d_now>d[u][i]) continue;\n\n\t\t\trep(j,G[u].size()){\n\t\t\t\tint v=G[u][j].v,type=G[u][j].type;\n\t\t\t\tll cost=G[u][j].cost;\n\t\t\t\tint i2=i+type;\n\t\t\t\tif(i2<=k && d[v][i2]>d[u][i]+cost){\n\t\t\t\t\td[v][i2]=d[u][i]+cost;\n\t\t\t\t\tQ.push(make_pair(-d[v][i2],make_pair(v,i2)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<ll> cand(1,0);\n\t\trep(i,k+1) rep(j,k+1) if(i!=j) {\n\t\t\tdouble x1=0,x2=0,x3=0;\n\t\t\tif(d[s1][i]<INF && d[s1][j]<INF) x1=crosspoint(i,d[s1][i],j,d[s1][j]).x;\n\t\t\tif(d[s1][i]<INF && d[s2][j]<INF) x2=crosspoint(i,d[s1][i],j,d[s2][j]).x;\n\t\t\tif(d[s2][i]<INF && d[s2][j]<INF) x3=crosspoint(i,d[s2][i],j,d[s2][j]).x;\n\t\t\tfor(int k=-1;k<=1;k++){\n\t\t\t\tcand.push_back((ll)x1+k);\n\t\t\t\tcand.push_back((ll)x2+k);\n\t\t\t\tcand.push_back((ll)x3+k);\n\t\t\t}\n\t\t}\n\t\tsort(cand.begin(),cand.end());\n\t\tcand.erase(unique(cand.begin(),cand.end()),cand.end());\n\n\t\tll ans=INF;\n\t\trep(i,cand.size()) if(cand[i]>=0) {\n\t\t\tll val1=eval(k,d[s1],cand[i]);\n\t\t\tll val2=eval(k,d[s2],cand[i]);\n\t\t\tans=min<ll>(ans,abs(val1-val2));\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tif(curu==100)continue;\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(dist[0][t][i]>=INF)return INF;\n\tif(dist[1][t][j]>=INF)return INF;\n\tif(i==j){\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tll va=(ll)dist[0][t][i]+i*k;\n\t\tll vb=(ll)dist[1][t][j]+j*k;\n\t\tans=min(ans,labs(va-vb));\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<set>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n\nstruct edge{\n  long long x,v,c;\n};\n\nstruct S{\n  long long x,v,c;\n  bool operator<(S s)const{\n    return c>s.c;\n  }\n};\n\nvector<edge> G[123][1234];\nlong long d[123][1234];\nset<long long> cands;\n\nvoid add_cands(int a1,long long b1,int a2,long long b2){\n  if(b1>1e17||b2>1e17)return;\n  long long m=(b2-b1)*1./(a1-a2)+.5;\n  for(long long i=m-3;i<=m+3;i++){\n    if(m<0)continue;\n    cands.insert(i);\n  }\n}\n \nint main(){\n  for(int N,M,S1,S2,T;cin>>N>>M>>S1>>S2>>T,N|M|S1|S2|T;){\n    for(auto &e:G){\n      for(auto &f:e){\n\tf.clear();\n      }\n    }\n    for(int i=0;i<M;i++){\n      int a,b;\n      char c[99];\n      cin>>a>>b>>c;\n      if(c[0]!='x'){\n\tint nc=atoi(c);\n\tfor(int i=0;i<=100;i++){\n\t  G[i][a].push_back({i,b,nc});\n\t  G[i][b].push_back({i,a,nc});\n\t}\n      }else{\n\tfor(int i=0;i<100;i++){\n\t  G[i][a].push_back({i+1,b,0});\n\t  G[i][b].push_back({i+1,a,0});\n\t}\n      }\n    }\n    fill(*begin(d),*end(d),1e18);\n    priority_queue<S> que;\n    que.push({0,T,0});\n    while(!que.empty()){\n      auto c=que.top();\n      que.pop();\n      if(d[c.x][c.v]<=c.c)continue;\n      d[c.x][c.v]=c.c;\n      for(auto e:G[c.x][c.v]){\n\tque.push({e.x,e.v,c.c+e.c});\n      }\n    }\n    cands.clear();\n    for(int i=0;i<=100;i++){\n      for(int j=0;j<i;j++){\n\tadd_cands(j,d[j][S1],i,d[i][S1]);\n\tadd_cands(j,d[j][S1],i,d[i][S2]);\n\tadd_cands(j,d[j][S2],i,d[j][S1]);\n\tadd_cands(j,d[j][S2],i,d[j][S2]);\n      }\n    }\n    long long ans=1e18;\n    for(auto e:cands){\n      long long m1=1e18,m2=1e18;\n      for(int i=0;i<=100;i++){\n\tm1=min(m1,e*i+d[i][S1]);\n\tm2=min(m2,e*i+d[i][S2]);\n      }\n      ans=min(ans,abs(m1-m2));\n    }\n    cout<<ans<<endl;\n  }\n}\n\n\t"
  },
  {
    "language": "C++",
    "code": "//      whn6325689\n//      Mr.Phoebe\n//      http://blog.csdn.net/u013007900\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <cstring>\n#include <climits>\n#include <complex>\n#include <fstream>\n#include <cassert>\n#include <cstdio>\n#include <bitset>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <ctime>\n#include <set>\n#include <map>\n#include <cmath>\n#include <functional>\n#include <numeric>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n\nusing namespace std;\n\n#define eps 1e-9\n#define PI acos(-1.0)\n#define INF 0x3f3f3f3f\n#define LLINF 1LL<<50\n#define speed std::ios::sync_with_stdio(false);\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef complex<ld> point;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> piii;\ntypedef vector<int> vi;\n\n#define CLR(x,y) memset(x,y,sizeof(x))\n#define CPY(x,y) memcpy(x,y,sizeof(x))\n#define clr(a,x,size) memset(a,x,sizeof(a[0])*(size))\n#define cpy(a,x,size) memcpy(a,x,sizeof(a[0])*(size))\n#define debug(a) cout << #a\" = \" << (a) << endl;\n#define debugarry(a, n) for (int i = 0; i < (n); i++) { cout << #a\"[\" << i << \"] = \" << (a)[i] << endl; }\n\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define lowbit(x) (x&(-x))\n\n#define MID(x,y) (x+((y-x)>>1))\n#define ls (idx<<1)\n#define rs (idx<<1|1)\n#define lson ls,l,mid\n#define rson rs,mid+1,r\n\ntemplate<class T>\ninline bool read(T &n)\n{\n    T x = 0, tmp = 1;\n    char c = getchar();\n    while((c < '0' || c > '9') && c != '-' && c != EOF) c = getchar();\n    if(c == EOF) return false;\n    if(c == '-') c = getchar(), tmp = -1;\n    while(c >= '0' && c <= '9') x *= 10, x += (c - '0'),c = getchar();\n    n = x*tmp;\n    return true;\n}\ntemplate <class T>\ninline void write(T n)\n{\n    if(n < 0)\n    {\n        putchar('-');\n        n = -n;\n    }\n    int len = 0,data[20];\n    while(n)\n    {\n        data[len++] = n%10;\n        n /= 10;\n    }\n    if(!len) data[len++] = 0;\n    while(len--) putchar(data[len]+48);\n}\n//-----------------------------------\n\nll n,m,s[3],t;\nbool vis[1010][111];\nll dis[1010][111];\ndouble val[100010];\nchar str[22];\nstruct Edge\n{\n    ll to,next,w;\n} e[40010];\nint head[1010],tot,mag,num;\n\nvoid init()\n{\n    CLR(head,-1);\n    tot=mag=num=0;\n}\n\nvoid addedge(ll u,ll v,ll w)\n{\n    e[tot].to=v;\n    e[tot].w=w;\n    e[tot].next=head[u];\n    head[u]=tot++;\n}\n\nvoid spfa(ll s)\n{\n    queue<pll> q;\n    CLR(dis,-1);\n    CLR(vis,0);\n    while(!q.empty())   q.pop();\n    dis[s][0]=0;\n    vis[s][0]=1;\n    q.push(mp(s,0));\n    while(!q.empty())\n    {\n        pll tmp=q.front();\n        q.pop();\n        ll u=tmp.first,tim=tmp.second,v;\n        vis[u][tim]=false;\n        for(int i=head[u]; ~i; i=e[i].next)\n        {\n            v=e[i].to;\n            ll k,w;\n            if(e[i].w==-1)  w=0,k=1;\n            else    w=e[i].w,k=0;\n            if(tim+k<=mag && (dis[v][tim+k]==-1 || dis[v][tim+k]>dis[u][tim]+w))\n            {\n                dis[v][tim+k]=dis[u][tim]+w;\n                if(!vis[v][tim+k])\n                {\n                    vis[v][tim+k]=true;\n                    q.push(mp(v,tim+k));\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    ll u,v,w;\n    while(read(n)&&read(m)&&read(s[1])&&read(s[2])&&read(t)&&(n+m))\n    {\n        init();\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d %d %s\",&u,&v,str);\n            if(str[0]=='x')\n            {\n                addedge(u,v,-1);\n                addedge(v,u,-1);\n                mag++;\n            }\n            else\n            {\n                sscanf(str,\"%lld\",&w);\n                addedge(u,v,w);\n                addedge(v,u,w);\n            }\n        }\n        spfa(t);\n        val[num++]=0;\n        for(int i=1; i<=2; i++)\n        {\n            for(int j=0; j<mag; j++)\n            {\n                ll minn=dis[s[i]][j];\n                if(minn==-1)    continue;\n                for(int k=j+1; k<=mag; k++)\n                {\n                    ll maxx=dis[s[i]][k];\n                    if(maxx==-1)    continue;\n                    double w=1.0*(maxx-minn)/(j-k);\n                    if(w>0) val[num++]=w;\n                    if(num>100000)  while(1){}\n                }\n            }\n        }\n        for(int j=0; j<=mag; j++)\n        {\n            ll minn=dis[s[1]][j];\n            if(minn==-1)    continue;\n            for(int k=0; k<=mag; k++)\n            {\n                if(j==k)    continue;\n                ll maxx=dis[s[2]][k];\n                if(maxx==-1)    continue;\n                double w=1.0*(maxx-minn)/(j-k);\n                if(w>0) val[num++]=w;\n                if(num>100000)  while(1){}\n            }\n        }\n\n        ll mi[3],ans=LLINF;\n        for(int i=0; i<num; i++)\n        {\n            for(int j=1; j<=2; j++)\n            {\n                mi[j]=LLINF;\n                for(int k=0; k<=mag; k++)\n                    if(~dis[s[j]][k])\n                    {\n                        mi[j]=min(mi[j],dis[s[j]][k]+k*(ll)(val[i]+eps));\n                        mi[j]=min(mi[j],dis[s[j]][k]+k*(ll)(val[i]+eps+1));\n                    }\n            }\n            ans=min(ans,abs(mi[1]-mi[2]));\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Template {{{\n#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\nusing namespace std;\ntypedef long long LL;\n\n#ifdef LOCAL\n#include \"contest.h\"\n#else\n#define dump(x) \n#endif\n\nclass range {\n    struct Iterator {\n        int val, inc;\n        int operator*() {return val;}\n        bool operator!=(Iterator& rhs) {return val < rhs.val;}\n        void operator++() {val += inc;}\n    };\n    Iterator i, n;\n    public:\n    range(int e) : i({0, 1}), n({e, 1}) {}\n    range(int b, int e) : i({b, 1}), n({e, 1}) {}\n    range(int b, int e, int inc) : i({b, inc}), n({e, inc}) {}\n    Iterator& begin() {return i;}\n    Iterator& end() {return n;}\n};\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ninline bool valid(int x, int w) { return 0 <= x && x < w; }\n\nvoid iostream_init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.setf(ios::fixed);\n    cout.precision(12);\n}\n//}}}\n\nstruct Edge{\n    int dst;\n    LL cost;\n};\ntypedef vector<Edge> Node;\ntypedef vector<Node> Graph;\nGraph G;\nint N, M, S1, S2, T;\nint MB;\nconst LL INF = 1e18;\nvector<LL> calc_cost(int s, int t) {\n    LL dist[1000][101] = {};\n    typedef tuple<LL, int, int> TP;\n    priority_queue<TP, vector<TP>, greater<TP>> que;\n    REP(i, N) REP(j, MB+1) dist[i][j] = INF;\n    dist[s][0] = 0;\n    que.push(TP(0, s, 0));\n    while(!que.empty()) {\n        LL d;\n        int u, c;\n        tie(d, u, c) = que.top(); que.pop();\n        for(Edge e : G[u]) {\n            const int nu = e.dst;\n            const int nc = c + (e.cost == -1 ? 1 : 0);\n            const LL nd = d + (e.cost == -1 ? 0 : e.cost);\n            if(nc <= MB && dist[nu][nc] > nd) {\n                dist[nu][nc] = nd;\n                que.push(TP(nd, nu, nc));\n            }\n        }\n    }\n    vector<LL> res(MB+1);\n    REP(i, MB+1) res[i] = dist[t][i];\n    return res;\n}\n// O(N)\nLL get(vector<LL> cs, LL X) {\n    LL res = cs[0];\n    for(int i = 1; i < cs.size(); i++) {\n        res = min(res, cs[i] + i * X);\n    }\n    return res;\n}\n// O(N)\nLL calc_diff(vector<LL> cs1, vector<LL> cs2, LL X) {\n    LL cost1 = get(cs1, X);\n    LL cost2 = get(cs2, X);\n    return abs(cost1 - cost2);\n}\nint main(){\n    iostream_init();\n    while(cin >> N >> M >> S1 >> S2 >> T && N > 0) {\n        MB = 0;\n        S1--; S2--; T--;\n        G.assign(N, Node());\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            string ws;\n            cin >> ws;\n            LL w;\n            if(ws == \"x\") {\n                w = -1;\n                MB++;\n            } else {\n                w = stoll(ws);\n            }\n            a--; b--;\n            G[a].push_back({b, w});\n            G[b].push_back({a, w});\n        }\n        vector<LL> cs1 = calc_cost(S1, T);\n        // cout << cs1[0] << endl;\n        vector<LL> cs2 = calc_cost(S2, T);\n        // cout << cs2[0] << endl;\n        LL ans = calc_diff(cs1, cs2, 0);\n        REP(i, cs1.size()) REP(j, cs1.size()) if(i < j) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs1[i] - cs1[j]) / (j-i);\n            for(LL dx = max(-X, -1LL); dx <= 1; dx++) {\n                ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        REP(i, cs2.size()) REP(j, cs2.size()) if(i < j) {\n            // cs[i] + i * X == cs[j] + j * X\n            // cs[i] - cs[j] == (j-i) * X\n            LL X = (cs2[i] - cs2[j]) / (j-i);\n            for(LL dx = max(-X, -1LL); dx <= 1; dx++) {\n                ans = min(ans, calc_diff(cs1, cs2, X+dx));\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n/* vim:set foldmethod=marker: */"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 100000000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<ll,P> PP;\ntypedef pair<ll,int> PPP;\n\nstruct edge{\n\tint t;\n\tll c;\n\tedge(){}\n\tedge(int tt,ll cc){\n\t\tt=tt;\n\t\tc=cc;\n\t}\n};\n\nint n,m,s1,s2,t;\nll a[2001],b[2001];\nstring w[2001];\nvector<edge> G[1001];\nvector<edge> G2[1001];\nll dist[2][1001][101];\n\nll labs(ll x){\n\tif(x<0LL)return -x;\n\treturn x;\n}\n\nll getnumber(string s){\n\tll ans=0;\n\tfor(int i=0;i<s.size();i++){\n\t\tans*=10LL;\n\t\tans+=(ll)(s[i]-'0');\n\t}\n\treturn ans;\n}\n\nint ag2;\n\nvoid dijk(int type,int s){\n\tdist[type][s][0]=0;\n\tpriority_queue<PP,vector<PP>,greater<PP> > que;\n\tque.push(PP(0,P(s,0)));\n\twhile(que.size()){\n\t\tPP p=que.top();\n\t\tque.pop();\n\t\tll curc=p.first;\n\t\tint curv=p.second.first;\n\t\tint curu=p.second.second;\n\t\tif(dist[type][curv][curu]<curc)continue;\n\t\tfor(int i=0;i<G[curv].size();i++){\n\t\t\tedge e=G[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu]){\n\t\t\t\tdist[type][e.t][curu]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu],P(e.t,curu)));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G2[curv].size();i++){\n\t\t\tedge e=G2[curv][i];\n\t\t\tif(e.c+dist[type][curv][curu]<dist[type][e.t][curu+1]){\n\t\t\t\tdist[type][e.t][curu+1]=e.c+dist[type][curv][curu];\n\t\t\t\tque.push(PP(dist[type][e.t][curu+1],P(e.t,curu+1)));\n\t\t\t}\n\t\t}\n\t}\n}\n\nll getMin(int i,int j){\n\tif(i==j){\n\t\tif(dist[0][t][i]>=INF)return INF;\n\t\tif(dist[1][t][j]>=INF)return INF;\n\t\treturn labs(dist[0][t][i]-dist[1][t][j]);\n\t}\n\tll b=(ll)(dist[1][t][j]-dist[0][t][i])/(i-j);\n\tll ans=INF;\n\tfor(ll k=max(b-1LL,0LL);k<=b+1LL;k++){\n\t\tvector<PPP> vec;\n\t\tfor(ll l=0;l<=ag2;l++){\n\t\t\tvec.push_back(PPP(dist[0][t][l]+l*k,0));\n\t\t\tvec.push_back(PPP(dist[1][t][l]+l*k,1));\n\t\t}\n\t\tsort(vec.begin(),vec.end());\n\t\tfor(int l=0;l<(int)vec.size()-1;l++){\n\t\t\tif(vec[l].first>=INF)continue;\n\t\t\tif(vec[l].second!=vec[l+1].second){\n\t\t\t\tans=min(ans,vec[l+1].first-vec[l].first);\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tll l=0,r=1000000000001LL;\n\tfor(int i=0;i<n;i++){\n\t\tG[i].clear();\n\t\tG2[i].clear();\n\t}\n\tif(ag2>100)return 0;\n\tfor(int i=0;i<m;i++){\n\t\tif(w[i]!=\"x\"){\n\t\t\tll val=getnumber(w[i]);\n\t\t\tG[a[i]].push_back(edge(b[i],val));\n\t\t\tG[b[i]].push_back(edge(a[i],val));\n\t\t}else{\n\t\t\tG2[a[i]].push_back(edge(b[i],0));\n\t\t\tG2[b[i]].push_back(edge(a[i],0));\n\t\t}\n\t}\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<=ag2;k++){\n\t\t\t\tdist[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tdijk(0,s1);\n\tdijk(1,s2);\n\tll ans=INF;\n\tfor(int i=0;i<=ag2;i++){\n\t\tfor(int j=0;j<=ag2;j++){\n\t\t\tans=min(ans,getMin(i,j));\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d%d%d%d\",&n,&m,&s1,&s2,&t);\n\t\tif(n==0 && m==0 && s1==0 && s2==0 && t==0)break;\n\t\ts1--;\n\t\ts2--;\n\t\tt--;\n\t\tag2=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a[i] >> b[i] >> w[i];\n\t\t\ta[i]--;\n\t\t\tb[i]--;\n\t\t\tif(w[i]==\"x\")ag2++;\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\n\n\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main{\nstatic int inf=999999999;\nstatic int n,m,s1,s2,t;\nstatic int[] ex,ey,ew;\nstatic int[] d,mag;\nstatic boolean[] vis;\nstatic void dij(){\n\tvis=new boolean[n];\n\td=new int[n];\n\tmag=new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tvis[i]=true;\n\t\td[i]=inf;\n\t\tmag[i]=0;\n\t}\n\td[t]=0;\n\t\n\tint min,pos;\n\tfor(int i=0;i<n;i++){\n\t\tpos=t;min=inf;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(vis[j]&&d[j]<min){\n\t\t\t\tmin=d[j];\n\t\t\t\tpos=j;\n\t\t\t}\n\t\tvis[pos]=false;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(ew[j]!=-1){\n\t\t\tif(ex[j]==pos&&vis[ey[j]]&&d[ey[j]]>d[ex[j]]+ew[j])\n\t\t\t\td[ey[j]]=d[ex[j]]+ew[j];\n\t\t\tif(ey[j]==pos&&vis[ex[j]]&&d[ex[j]]>d[ey[j]]+ew[j])\n\t\t\t\td[ex[j]]=d[ey[j]]+ew[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tew[j]=0;\n\t\t\t\tif(ex[j]==pos&&vis[ey[j]]&&d[ey[j]]>d[ex[j]]+ew[j]){\n\t\t\t\t\td[ey[j]]=d[ex[j]]+ew[j];\n\t\t\t\t\tmag[ey[j]]=mag[ex[j]]+1;//\n\t\t\t\t\t}\n\t\t\t\tif(ey[j]==pos&&vis[ex[j]]&&d[ex[j]]>d[ey[j]]+ew[j]){\n\t\t\t\t\td[ex[j]]=d[ey[j]]+ew[j];\n\t\t\t\t\tmag[ex[j]]=mag[ey[j]]+1;//\n\t\t\t\t\t}\n\t\t\t\tew[j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\npublic static void  main(String args[]) throws IOException{ \n    Scanner a = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    while(a.hasNext()){\n    \tn=a.nextInt();\n    \tm=a.nextInt();\n    \ts1=a.nextInt()-1;\n    \ts2=a.nextInt()-1;\n    \tt=a.nextInt()-1;\n    \tex=new int[m];\n    \tey=new int[m];\n    \tew=new int[m];\n    \tfor(int i=0;i<m;i++){\n    \t\tex[i]=a.nextInt()-1;\n    \t\tey[i]=a.nextInt()-1;\n    \t\tString s=a.next();\n    \t\tif(s.equals(\"x\"))ew[i]=-1;\n    \t\telse ew[i]=Integer.parseInt(s);\n    \t}\n    \t\n    \tdij();\n    \t//for(int i=0;i<n;i++)System.out.println(d[i]+\" \"+mag[i]);\n    \tint ans=d[s1]-d[s2];\n    \tint gap=mag[s1]-mag[s2];\n    \t//System.out.println(ans+\" \"+gap);\n    \tif(ans*gap<0){\n    \t\tint cur=1;\n    \t\tans=Math.abs(ans);\n    \t\tgap=Math.abs(gap);\n    \t\tcur=ans/gap+1;\n    \t\tint x=Math.abs(gap*cur-ans);\n    \t\tint y=Math.abs(ans-gap*(cur-1));\n    \t\t//System.out.println(x+\" \"+y);\n    \t\tans=Math.min(x, y);\n    \t}\n    \tSystem.out.println(Math.abs(ans));\n    }\n   }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint[] s = new int[] { ni() - 1, ni() - 1 };\n\t\t\tint t = ni() - 1;\n\t\t\tif (N == 0 && M == 0 && s[0] == -1 && s[1] == -1 && t == -1)\n\t\t\t\tbreak;\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tString c = ns();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tlong[][] dist = new long[101][N];\n\t\t\tfor (int i = 0; i < dist.length; i++)\n\t\t\t\tfor (int j = 0; j < dist[i].length; j++)\n\t\t\t\t\tdist[i][j] = 1L << 60;\n\t\t\tdist[0][t] = 0;\n\n\t\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\t\tpq.add(new P(t, 0, 0));\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tP p = pq.poll();\n\t\t\t\tif (dist[p.magicalBridgeNum][p.cur] < p.dist)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tdist[p.magicalBridgeNum][p.cur] = p.dist;\n\t\t\t\tfor (Edge e : g[p.cur]) {\n\t\t\t\t\tlong nD = p.dist + e.dist;\n\t\t\t\t\tint nM = p.magicalBridgeNum + e.magicalBridgeNum;\n\t\t\t\t\tif (nM > 100)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (nD < dist[nM][e.dst]) {\n\t\t\t\t\t\tdist[nM][e.dst] = nD;\n\t\t\t\t\t\tpq.add(new P(e.dst, nD, nM));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Long> pos = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tlong bi = dist[i][s[0]];\n\t\t\t\t\tlong bj = dist[j][s[1]];\n\t\t\t\t\tif (bi == 1L << 60 || bj == 1L << 60)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// i*x+bi=jx+bj\n\t\t\t\t\t// (i-j)x=bj-bi\n\t\t\t\t\t// x=(b2-b1)/(a1-a2)\n\t\t\t\t\tlong x = (bj - bi) / (i - j);\n\t\t\t\t\tif (x < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpos.add(x);\n\t\t\t\t\tpos.add(x + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos.add(0L);\n\t\t\tCollections.sort(pos);\n\n\t\t\tlong mingap = 1L << 60;\n\t\t\tfor (Long x : pos) {\n\t\t\t\tlong[] mindis = new long[] { 1L << 60, 1L << 60 };\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int magicalBridge = 0; magicalBridge <= 100; magicalBridge++) {\n\t\t\t\t\t\tif(dist[magicalBridge][s[i]]==1L<<60)continue;\n\t\t\t\t\t\tmindis[i] = Math.min(mindis[i], dist[magicalBridge][s[i]] + magicalBridge * x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mindis[0] != 1L << 60 && mindis[1] != 1L << 60)\n\t\t\t\t\tmingap = Math.min(mingap, Math.abs(mindis[0] - mindis[1]));\n\t\t\t}\n\t\t\tout.println(mingap);\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint cur;\n\t\tlong dist;\n\t\tint magicalBridgeNum;\n\n\t\tpublic P(int cur, long dist, int magicalBridgeNum) {\n\t\t\tthis.cur = cur;\n\t\t\tthis.dist = dist;\n\t\t\tthis.magicalBridgeNum = magicalBridgeNum;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\tif (magicalBridgeNum != o.magicalBridgeNum) {\n\t\t\t\treturn Integer.compare(magicalBridgeNum, o.magicalBridgeNum);\n\t\t\t} else {\n\t\t\t\treturn Long.compare(dist, o.dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint dist = 0;\n\t\tString s;\n\t\tint magicalBridgeNum = 0;\n\n\t\tEdge(int src, int dst, String s) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.s = s;\n\n\t\t\tif (s.equals(\"x\"))\n\t\t\t\tmagicalBridgeNum++;\n\t\t\telse\n\t\t\t\tdist = Integer.parseInt(s);\n\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\n#define int long long\n\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint N,M,S1,S2,T;\nvector<pint>G[1111];\n\nint dist[111][1111];\n\nvoid solve(){\n    S1--;S2--;T--;\n\n    rep(i,N)G[i].clear();\n\n    rep(i,M){\n        int a,b;\n        string s;\n        cin>>a>>b>>s;\n        a--;b--;\n\n        int c;\n        if(s==\"x\"){\n            c=-1;\n        }\n        else{\n            c=0;\n            for(int j=0;j<s.size();j++)c=c*10+s[j]-'0';\n        }\n\n        G[a].pb({b,c});\n        G[b].pb({a,c});\n    }\n\n\n    fill_n(*dist,111*1111,INF);\n    dist[0][T]=0;\n    priority_queue<tuple<int,int,int>,vector<tuple<int,int,int>>,greater<tuple<int,int,int>>>que;\n    que.push(make_tuple(0,T,0));\n    while(que.size()){\n        int c,v,k;\n        tie(c,v,k)=que.top();\n        que.pop();\n        if(dist[k][v]>c)continue;\n        for(auto &e:G[v]){\n            int nc,nk;\n            if(e.se==-1){\n                nc=c;\n                nk=k+1;\n            }\n            else{\n                nc=c+e.se;\n                nk=k;\n            }\n\n            if(nk>100||dist[nk][e.fi]<=nc)continue;\n            dist[nk][e.fi]=nc;\n            que.push(make_tuple(nc,e.fi,nk));\n        }\n    }\n\n    vint lis;\n    lis.pb(0);\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S1]==INF||dist[j][S1]==INF)continue;\n            int t=(dist[i][S1]-dist[j][S1])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n    for(int i=0;i<=100;i++){\n        for(int j=0;j<=100;j++){\n            if(i==j)continue;\n            if(dist[i][S2]==INF||dist[j][S2]==INF)continue;\n            int t=(dist[i][S2]-dist[j][S2])/(i-j);\n            if(t<0)continue;\n            lis.pb(t);\n            lis.pb(t+1);\n        }\n    }\n\n    sort(all(lis));lis.erase(unique(all(lis)),lis.end());\n    lis.pb(lis.back()+1);\n\n    int ans=LLONG_MAX;\n    for(int t=0;t+1<lis.size();t++){\n        int k=0,l=0;\n\n        int x1=lis[t];\n        int x2=lis[t+1];\n\n        for(int i=1;i<=100;i++){\n            if(dist[k][S1]+k*x1>dist[i][S1]+i*x1)k=i;\n            if(dist[l][S2]+l*x1>dist[i][S2]+i*x1)l=i;\n        }\n\n        chmin(ans,abs((dist[k][S1]+k*x1)-(dist[l][S2]+l*x1)));\n        chmin(ans,abs((dist[k][S1]+k*x2)-(dist[l][S2]+l*x2)));\n    }\n\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>S1>>S2>>T,N||M||S1||S2||T)solve();\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\n\n\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main{\nstatic int inf=999999999;\nstatic int n,m,s1,s2,t;\nstatic int[] ex,ey,ew;\nstatic int[] d,mag;\nstatic boolean[] vis;\nstatic void dij(){\n\tvis=new boolean[n];\n\td=new int[n];\n\tmag=new int[n];\n\tfor(int i=0;i<n;i++){\n\t\tvis[i]=true;\n\t\td[i]=inf;\n\t\tmag[i]=0;\n\t}\n//System.out.println(\"t:\"+t);\n\td[t]=0;\n\t\n\tint min,pos;\n\tfor(int i=0;i<n;i++){\n\t\tpos=t;min=inf;\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(vis[j]&&d[j]<min){\n\t\t\t\tmin=d[j];\n\t\t\t\tpos=j;\n\t\t\t}\n\t\tvis[pos]=false;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(ew[j]!=-1){\n\t\t\tif(ex[j]==pos&&vis[ey[j]]&&d[ey[j]]>d[ex[j]]+ew[j])\n\t\t\t\td[ey[j]]=d[ex[j]]+ew[j];\n\t\t\tif(ey[j]==pos&&vis[ex[j]]&&d[ex[j]]>d[ey[j]]+ew[j])\n\t\t\t\td[ex[j]]=d[ey[j]]+ew[j];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tew[j]=0;\n\t\t\t\tif(ex[j]==pos&&vis[ey[j]]&&d[ey[j]]>d[ex[j]]+ew[j]){\n\t\t\t\t\td[ey[j]]=d[ex[j]]+ew[j];\n\t\t\t\t\tmag[ey[j]]=mag[ex[j]]+1;//\n\t\t\t\t\t}\n\t\t\t\tif(ey[j]==pos&&vis[ex[j]]&&d[ex[j]]>d[ey[j]]+ew[j]){\n\t\t\t\t\td[ex[j]]=d[ey[j]]+ew[j];\n\t\t\t\t\tmag[ex[j]]=mag[ey[j]]+1;//\n\t\t\t\t\t}\n\t\t\t\tew[j]=-1;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\npublic static void  main(String args[]) throws IOException{ \n    Scanner a = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    while(a.hasNext()){\n    \tn=a.nextInt();\n    \tm=a.nextInt();\n    \ts1=a.nextInt()-1;\n    \ts2=a.nextInt()-1;\n    \tt=a.nextInt()-1;\n    \tif(n==0 &&m==0)\n    \t\tbreak;\n    \tex=new int[m];\n    \tey=new int[m];\n    \tew=new int[m];\n    \tfor(int i=0;i<m;i++){\n    \t\tex[i]=a.nextInt()-1;\n    \t\tey[i]=a.nextInt()-1;\n    \t\tString s=a.next();\n    \t\tif(s.equals(\"x\"))ew[i]=-1;\n    \t\telse ew[i]=Integer.parseInt(s);\n    \t}\n    \t\n    \tdij();\n    \t//for(int i=0;i<n;i++)System.out.println(d[i]+\" \"+mag[i]);\n    \tint ans=d[s1]-d[s2];\n    \tint gap=mag[s1]-mag[s2];\n    \t//System.out.println(ans+\" \"+gap);\n    \tif(ans*gap<0){\n    \t\tint cur=1;\n    \t\tans=Math.abs(ans);\n    \t\tgap=Math.abs(gap);\n    \t\tcur=ans/gap+1;\n    \t\tint x=Math.abs(gap*cur-ans);\n    \t\tint y=Math.abs(ans-gap*(cur-1));\n    \t\t//System.out.println(x+\" \"+y);\n    \t\tans=Math.min(x, y);\n    \t}\n    \tSystem.out.println(Math.abs(ans));\n    }\n   }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint[] s = new int[] { ni() - 1, ni() - 1 };\n\t\t\tint t = ni() - 1;\n\t\t\tif (N == 0 && M == 0 && s[0] == -1 && s[1] == -1 && t == -1)\n\t\t\t\tbreak;\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tString c = ns();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tlong[][] dist = new long[101][N];\n\t\t\tfor (int i = 0; i < dist.length; i++)\n\t\t\t\tfor (int j = 0; j < dist[i].length; j++)\n\t\t\t\t\tdist[i][j] = 1L << 60;\n\t\t\tdist[0][t] = 0;\n\n\t\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\t\tpq.add(new P(t, 0, 0));\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tP p = pq.poll();\n\t\t\t\tif (p.dist > 1_000_000_000L * 1_000)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist[p.magicalBridgeNum][p.cur] < p.dist)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tdist[p.magicalBridgeNum][p.cur] = p.dist;\n\t\t\t\tfor (Edge e : g[p.cur]) {\n\t\t\t\t\tlong nD = p.dist + e.dist;\n\t\t\t\t\tint nM = p.magicalBridgeNum + e.magicalBridgeNum;\n\t\t\t\t\tif (nM > 100)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (nD < dist[nM][e.dst]) {\n\t\t\t\t\t\tdist[nM][e.dst] = nD;\n\t\t\t\t\t\tpq.add(new P(e.dst, nD, nM));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Long> pos = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tlong bi = dist[i][s[0]];\n\t\t\t\t\tlong bj = dist[j][s[1]];\n\t\t\t\t\tif (bi == 1L << 60 || bj == 1L << 60)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// i*x+bi=jx+bj\n\t\t\t\t\t// (i-j)x=bj-bi\n\t\t\t\t\t// x=(b2-b1)/(a1-a2)\n\t\t\t\t\tlong x = (bj - bi) / (i - j);\n\t\t\t\t\tif (x < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpos.add(x);\n\t\t\t\t\tpos.add(x + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos.add(0L);\n\t\t\tCollections.sort(pos);\n\n\t\t\tlong mingap = 1L << 60;\n\t\t\tfor (Long x : pos) {\n\t\t\t\tlong[] mindis = new long[] { 1L << 60, 1L << 60 };\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int magicalBridge = 0; magicalBridge <= 100; magicalBridge++) {\n\t\t\t\t\t\tif (dist[magicalBridge][s[i]] == 1L << 60)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tmindis[i] = Math.min(mindis[i], dist[magicalBridge][s[i]] + magicalBridge * x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mindis[0] != 1L << 60 && mindis[1] != 1L << 60)\n\t\t\t\t\tmingap = Math.min(mingap, Math.abs(mindis[0] - mindis[1]));\n\t\t\t}\n\t\t\tout.println(mingap);\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint cur;\n\t\tlong dist;\n\t\tint magicalBridgeNum;\n\n\t\tpublic P(int cur, long dist, int magicalBridgeNum) {\n\t\t\tthis.cur = cur;\n\t\t\tthis.dist = dist;\n\t\t\tthis.magicalBridgeNum = magicalBridgeNum;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\tif (magicalBridgeNum != o.magicalBridgeNum) {\n\t\t\t\treturn Integer.compare(magicalBridgeNum, o.magicalBridgeNum);\n\t\t\t} else {\n\t\t\t\treturn Long.compare(dist, o.dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint dist = 0;\n\t\tString s;\n\t\tint magicalBridgeNum = 0;\n\n\t\tEdge(int src, int dst, String s) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.s = s;\n\n\t\t\tif (s.equals(\"x\"))\n\t\t\t\tmagicalBridgeNum++;\n\t\t\telse\n\t\t\t\tdist = Integer.parseInt(s);\n\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint[] s = new int[] { ni() - 1, ni() - 1 };\n\t\t\tint t = ni() - 1;\n\t\t\tif (N == 0 && M == 0 && s[0] == -1 && s[1] == -1 && t == -1)\n\t\t\t\tbreak;\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tString c = ns();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tlong[][] dist = new long[101][N];\n\t\t\tfor (int i = 0; i < dist.length; i++)\n\t\t\t\tfor (int j = 0; j < dist[i].length; j++)\n\t\t\t\t\tdist[i][j] = 1L << 60;\n\t\t\tdist[0][t] = 0;\n\n\t\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\t\tpq.add(new P(t, 0, 0));\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tP p = pq.poll();\n\t\t\t\tif (dist[p.magicalBridgeNum][p.cur] < p.dist)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tdist[p.magicalBridgeNum][p.cur] = p.dist;\n\t\t\t\tfor (Edge e : g[p.cur]) {\n\t\t\t\t\tlong nD = p.dist + e.dist;\n\t\t\t\t\tint nM = p.magicalBridgeNum + e.magicalBridgeNum;\n\t\t\t\t\tif (nM > 100)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (nD < dist[nM][e.dst]) {\n\t\t\t\t\t\tdist[nM][e.dst] = nD;\n\t\t\t\t\t\tpq.add(new P(e.dst, nD, nM));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Long> pos = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tlong bi = dist[i][s[0]];\n\t\t\t\t\tlong bj = dist[j][s[1]];\n\t\t\t\t\tif (bi == 1L << 60 || bj == 1L << 60)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// i*x+bi=jx+bj\n\t\t\t\t\t// (i-j)x=bj-bi\n\t\t\t\t\t// x=(b2-b1)/(a1-a2)\n\t\t\t\t\tlong x = (bj - bi) / (i - j);\n\t\t\t\t\tif (x < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpos.add(x);\n\t\t\t\t\tpos.add(x + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos.add(0L);\n\t\t\tCollections.sort(pos);\n\n\t\t\tlong mingap = 1L << 60;\n\t\t\tfor (Long x : pos) {\n\t\t\t\tlong[] mindis = new long[] { 1L << 60, 1L << 60 };\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int magicalBridge = 0; magicalBridge <= 100; magicalBridge++) {\n\t\t\t\t\t\tmindis[i] = Math.min(mindis[i], dist[magicalBridge][s[i]] + magicalBridge * x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mindis[0] != 1L << 60 && mindis[1] != 1L << 60)\n\t\t\t\t\tmingap = Math.min(mingap, Math.abs(mindis[0] - mindis[1]));\n\t\t\t}\n\t\t\tout.println(mingap);\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint cur;\n\t\tlong dist;\n\t\tint magicalBridgeNum;\n\n\t\tpublic P(int cur, long dist, int magicalBridgeNum) {\n\t\t\tthis.cur = cur;\n\t\t\tthis.dist = dist;\n\t\t\tthis.magicalBridgeNum = magicalBridgeNum;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\tif (magicalBridgeNum != o.magicalBridgeNum) {\n\t\t\t\treturn Integer.compare(magicalBridgeNum, o.magicalBridgeNum);\n\t\t\t} else {\n\t\t\t\treturn Long.compare(dist, o.dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint dist = 0;\n\t\tString s;\n\t\tint magicalBridgeNum = 0;\n\n\t\tEdge(int src, int dst, String s) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.s = s;\n\n\t\t\tif (s.equals(\"x\"))\n\t\t\t\tmagicalBridgeNum++;\n\t\t\telse\n\t\t\t\tdist = Integer.parseInt(s);\n\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\n\n\nimport java.io.PrintWriter;\n\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main{\nstatic int inf=999999999;\nstatic int n,m,s1,s2,t;\nstatic int[] ex,ey;\nstatic long[]ew;\nstatic long[] d;\nstatic boolean[] vis;  \nstatic Queue<Integer> queue = new LinkedList<Integer>();\nstatic Stack<Integer> stack = new Stack<Integer>();\nstatic void spfa(){\n\tfor(int i=0;i<n;i++){\n\t\tvis[i]=true;\n\t\td[i]=inf;\n\t\tqueue.clear();\n\t}\n\td[t]=0;\n\tqueue.offer(t);\n\tvis[t]=false;\n\twhile(!queue.isEmpty()){\n\t\tint cur=queue.poll();\n\t\t//System.out.println(cur+\"pos\");\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(ex[i]==cur)\n\t\t\t\tif(d[ey[i]]>d[ex[i]]+ew[i]){\n\t\t\t\t\td[ey[i]]=d[ex[i]]+ew[i];\n\t\t\t\t\tif(vis[ey[i]])\n\t\t\t\t\t\tqueue.offer(ey[i]);}\n\t\tif(ey[i]==cur)\n\t\t\tif(d[ex[i]]>d[ey[i]]+ew[i]){\n\t\t\t\td[ex[i]]=d[ey[i]]+ew[i];\n\t\t\t\tif(vis[ex[i]])\n\t\t\t\t\tqueue.offer(ex[i]);\n\t\t\t\t}\n\t\t}\n\t}\n}\npublic static void main(String args[]) throws IOException{ \n    Scanner a = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n    while(a.hasNext()){\n    \tn=a.nextInt();\n    \tm=a.nextInt();\n    \ts1=a.nextInt()-1;\n    \ts2=a.nextInt()-1;\n    \tt=a.nextInt()-1;\n    \tif(n==0 &&m==0 && s1==-1 && s2==-1 && t==-1)\n    \t\tbreak;\n    \tex=new int[m];\n    \tey=new int[m];\n    \tew=new long[m];\n    \td=new long[n];\n    \tvis=new boolean[n];\n    \tstack.clear();\n    \tfor(int i=0;i<m;i++){\n    \t\tex[i]=a.nextInt()-1;\n    \t\tey[i]=a.nextInt()-1;\n    \t\tString s=a.next();\n    \t\tif(s.equals(\"x\")){ew[i]=0;stack.add(i);}\n    \t\telse ew[i]=Integer.parseInt(s);\n    \t}\n    \tlong x,y,pre,value;\n    \tspfa();\n    \tx=d[s1];\n    \ty=d[s2];\n    \tvalue=0;\n    \tpre=Math.abs(x-y);\n    \tif(stack.isEmpty()){\n    \t\tSystem.out.println(pre);\n    \t\tcontinue;\n    \t}\n    \tif(x==y){\n    \t\tSystem.out.println(0);\n    \t\tcontinue;\n    \t}\n    \tvalue=1;\n    \tlong left,right;\n    \t\n    \twhile(true){\n    \tint index=0;\n    \tvalue*=2;\n    \tleft=Math.abs(d[s1]-d[s2]);\n    \tpre=left;\n    \t//System.out.println(value+\" 1 \"+left);\n    \tfor(int i=0;i<stack.size();i++){\n    \t\tindex=stack.get(i);\n    \t\tif(ew[index]==0)ew[index]=1;\n    \t\telse ew[index]=value;\n    \t}\n    \tspfa();\n    \tx=d[s1];\n    \ty=d[s2];\n    \tright=Math.abs(x-y);\n    \tif(x-y==pre)break;\n    \tif((x-y)*pre<=0){break;}\n    \t}\n    \tlong l=value/2,r=value,mid;\n    \t\n    \twhile(l!=r){\n    \t\tmid=(l+r)/2;\n    \t\tint index;\n    \t\tfor(int i=0;i<stack.size();i++){\n        \t\tindex=stack.get(i);\n        \t\tew[index]=mid;\n        \t}\n    \t\tspfa();\n    \t\tpre=Math.abs(d[s1]-d[s2]);\n    \t\tif(pre==0){left=pre;break;}\n    \t\tif(pre*left>0)l=mid+1;\n    \t\telse r=mid;\n    \t\t//System.out.println(l+\" \"+r);\n    \t}\n    \tSystem.out.println(left);\n    }\n   }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint[] s = new int[] { ni() - 1, ni() - 1 };\n\t\t\tint t = ni() - 1;\n\t\t\tif (N == 0 && M == 0 && s[0] == -1 && s[1] == -1 && t == -1)\n\t\t\t\tbreak;\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tString c = ns();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tlong[][] dist = new long[101][N];\n\t\t\tfor (int i = 0; i < dist.length; i++)\n\t\t\t\tfor (int j = 0; j < dist[i].length; j++)\n\t\t\t\t\tdist[i][j] = 1L << 60;\n\t\t\tdist[0][t] = 0;\n\n\t\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\t\tpq.add(new P(t, 0, 0));\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tP p = pq.poll();\n\t\t\t\tif (dist[p.magicalBridgeNum][p.cur] < p.dist)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tdist[p.magicalBridgeNum][p.cur] = p.dist;\n\t\t\t\tfor (Edge e : g[p.cur]) {\n\t\t\t\t\tlong nD = p.dist + e.dist;\n\t\t\t\t\tint nM = p.magicalBridgeNum + e.magicalBridgeNum;\n\t\t\t\t\tif (nM > 100)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (nD < dist[nM][e.dst]) {\n\t\t\t\t\t\tdist[nM][e.dst] = nD;\n\t\t\t\t\t\tpq.add(new P(e.dst, nD, nM));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Long> pos = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\tlong bi = dist[i][s[0]];\n\t\t\t\t\tlong bj = dist[j][s[1]];\n\t\t\t\t\tif (bi == 1L << 60 || bj == 1L << 60)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (i == j)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t// i*x+bi=jx+bj\n\t\t\t\t\t// (i-j)x=bj-bi\n\t\t\t\t\t// x=(b2-b1)/(a1-a2)\n\t\t\t\t\tlong x = (bj - bi) / (i - j);\n\t\t\t\t\tif (x < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpos.add(x);\n\t\t\t\t\tpos.add(x + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos.add(0L);\n\t\t\tCollections.sort(pos);\n\n\t\t\tlong mingap = 1L << 60;\n\t\t\tfor (Long x : pos) {\n\t\t\t\tlong[] mindis = new long[] { 1L << 60, 1L << 60 };\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int magicalBridge = 0; magicalBridge <= 100; magicalBridge++) {\n\t\t\t\t\t\tif(dist[magicalBridge][s[i]]==1L<<60)continue;\n\t\t\t\t\t\tmindis[i] = Math.min(mindis[i], dist[magicalBridge][s[i]] + magicalBridge * x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mindis[0] != 1L << 60 && mindis[1] != 1L << 60)\n\t\t\t\t\tmingap = Math.min(mingap, Math.abs(mindis[0] - mindis[1]));\n\t\t\t}\n\t\t\tout.println(mingap);\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint cur;\n\t\tlong dist;\n\t\tint magicalBridgeNum;\n\n\t\tpublic P(int cur, long dist, int magicalBridgeNum) {\n\t\t\tthis.cur = cur;\n\t\t\tthis.dist = dist;\n\t\t\tthis.magicalBridgeNum = magicalBridgeNum;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\tif (magicalBridgeNum != o.magicalBridgeNum) {\n\t\t\t\treturn Integer.compare(magicalBridgeNum, o.magicalBridgeNum);\n\t\t\t} else {\n\t\t\t\treturn Long.compare(dist, o.dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tint dist = 0;\n\t\tString s;\n\t\tint magicalBridgeNum = 0;\n\n\t\tEdge(int src, int dst, String s) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.s = s;\n\n\t\t\tif (s.equals(\"x\"))\n\t\t\t\tmagicalBridgeNum++;\n\t\t\telse\n\t\t\t\tdist = Integer.parseInt(s);\n\n\t\t}\n\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\n\npublic class Main{\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid solver() {\n\t\twhile (true) {\n\t\t\tint N = ni();\n\t\t\tint M = ni();\n\t\t\tint[] s = new int[] { ni() - 1, ni() - 1 };\n\t\t\tint t = ni() - 1;\n\t\t\tif (N == 0 && M == 0 && s[0] == -1 && s[1] == -1 && t == -1)\n\t\t\t\tbreak;\n\n\t\t\tArrayList<Edge>[] g = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tg[i] = new ArrayList<>();\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint a = ni() - 1;\n\t\t\t\tint b = ni() - 1;\n\t\t\t\tString c = ns();\n\t\t\t\tg[a].add(new Edge(a, b, c));\n\t\t\t\tg[b].add(new Edge(b, a, c));\n\t\t\t}\n\n\t\t\tlong[][] dist = new long[101][N];\n\t\t\tfor (int i = 0; i < dist.length; i++)\n\t\t\t\tfor (int j = 0; j < dist[i].length; j++)\n\t\t\t\t\tdist[i][j] = 1L << 60;\n\t\t\tdist[0][t] = 0;\n\t\t\tPriorityQueue<P> pq = new PriorityQueue<>();\n\t\t\tpq.add(new P(t, 0, 0));\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tP p = pq.poll();\n\t\t\t\tif (p.dist > 1_000_000_000L * 1_000L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist[p.magicalBridgeNum][p.cur] < p.dist)\n\t\t\t\t\tcontinue;\n\t\t\t\telse\n\t\t\t\t\tdist[p.magicalBridgeNum][p.cur] = p.dist;\n\t\t\t\tfor (Edge e : g[p.cur]) {\n\t\t\t\t\tlong nD = p.dist + e.dist;\n\t\t\t\t\tint nM = p.magicalBridgeNum + e.magicalBridgeNum;\n\t\t\t\t\tif (nM > 100)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (nD < dist[nM][e.dst]) {\n\t\t\t\t\t\tdist[nM][e.dst] = nD;\n\t\t\t\t\t\tpq.add(new P(e.dst, nD, nM));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tArrayList<Long> pos = new ArrayList<>();\n\t\t\tfor (int pos1 = 0; pos1 <= 1; pos1++) {\n\t\t\t\tfor (int pos2 = pos1; pos2 <= 1; pos2++) {\n\t\t\t\t\tfor (int i = 0; i <= 100; i++) {\n\t\t\t\t\t\tfor (int j = 0; j <= 100; j++) {\n\t\t\t\t\t\t\tlong bi = dist[i][s[pos1]];\n\t\t\t\t\t\t\tlong bj = dist[j][s[pos2]];\n\t\t\t\t\t\t\tif (bi == (1L << 60) || bj == (1L << 60))\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tif (i == j)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tlong x = (bj - bi) / (i - j);\n\t\t\t\t\t\t\tif (x < 0)\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\tpos.add(x);\n\t\t\t\t\t\t\tpos.add(x + 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpos.add(0L);\n\t\t\tCollections.sort(pos);\n\n\t\t\tlong mingap = 1L << 60;\n\t\t\tfor (Long x : pos) {\n\t\t\t\tlong[] mindis = new long[] { 1L << 60, 1L << 60 };\n\t\t\t\tfor (int i = 0; i < 2; i++) {\n\t\t\t\t\tfor (int magicalBridge = 0; magicalBridge <= 100; magicalBridge++) {\n\t\t\t\t\t\tif (dist[magicalBridge][s[i]] == 1L << 60)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tmindis[i] = Math.min(mindis[i], dist[magicalBridge][s[i]] + magicalBridge * x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mindis[0] != 1L << 60 && mindis[1] != 1L << 60)\n\t\t\t\t\tmingap = Math.min(mingap, Math.abs(mindis[0] - mindis[1]));\n\t\t\t}\n\t\t\tout.println(mingap);\n\t\t}\n\t}\n\n\tclass P implements Comparable<P> {\n\t\tint cur;\n\t\tlong dist;\n\t\tint magicalBridgeNum;\n\n\t\tpublic P(int cur, long dist, int magicalBridgeNum) {\n\t\t\tthis.cur = cur;\n\t\t\tthis.dist = dist;\n\t\t\tthis.magicalBridgeNum = magicalBridgeNum;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\tif (magicalBridgeNum != o.magicalBridgeNum) {\n\t\t\t\treturn Integer.compare(magicalBridgeNum, o.magicalBridgeNum);\n\t\t\t} else {\n\t\t\t\treturn Long.compare(dist, o.dist);\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint src;\n\t\tint dst;\n\t\tlong dist = 0;\n\t\tint magicalBridgeNum = 0;\n\n\t\tEdge(int src, int dst, String s) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\n\t\t\tif (s.equals(\"x\"))\n\t\t\t\tmagicalBridgeNum = 1;\n\t\t\telse\n\t\t\t\tdist = Long.parseLong(s);\n\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\tsolver();\n\t\tout.flush();\n\n\t}\n\n\tstatic long nl() {\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nc() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic double nd() {\n\t\ttry {\n\t\t\treturn Double.parseDouble(ns());\n\t\t} catch (Exception e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n\tstatic String ns() {\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tif (b == -1)\n\t\t\t\treturn \"\";\n\t\t\tsb.append((char) b);\n\t\t\twhile (true) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1)\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tif (b <= ' ')\n\t\t\t\t\treturn sb.toString();\n\t\t\t\tsb.append((char) b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\n\tpublic static char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\ttry {\n\t\t\tint b = skip(), p = 0;\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tbuf[p++] = (char) b;\n\t\t\twhile (p < n) {\n\t\t\t\tb = is.read();\n\t\t\t\tif (b == -1 || b <= ' ')\n\t\t\t\t\tbreak;\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic static byte[] nse(int n) {\n\t\tbyte[] buf = new byte[n];\n\t\ttry {\n\t\t\tint b = skip();\n\t\t\tif (b == -1)\n\t\t\t\treturn null;\n\t\t\tis.read(buf);\n\t\t\treturn buf;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\n\tstatic int skip() throws IOException {\n\t\tint b;\n\t\twhile ((b = is.read()) != -1 && !(b >= 33 && b <= 126))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tstatic boolean eof() {\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\tint b = skip();\n\t\t\tis.reset();\n\t\t\treturn b == -1;\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tstatic int ni() {\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile ((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'))\n\t\t\t\t;\n\t\t\tif (num == '-') {\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t} else {\n\t\t\t\tnum -= '0';\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tint b = is.read();\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic void tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Heap\n  def initialize\n    @obj_array = []\n    @key_array = []\n    @index = {}\n  end\n\n  def add(obj, key)\n    if @index[obj]\n      update_key(obj, key)\n    else\n      @obj_array << obj\n      @key_array << key\n      @index[obj] = @obj_array.size - 1\n      lift_up(@obj_array.size - 1)\n    end\n  end\n\n  def swap(i, j)\n    u = @obj_array[i]\n    v = @obj_array[j]\n    @index[u], @index[v] = j, i\n    @obj_array[i], @obj_array[j] = v, u\n    @key_array[i], @key_array[j] = @key_array[j], @key_array[i]\n  end\n\n  def lift_up(i)\n    return if i == 0\n    j = (i - 1) / 2\n    if @key_array[i] < @key_array[j]\n      swap(i, j)\n      lift_up(j)\n    end\n  end\n\n  def del_min\n    raise \"heap is empty!\" if empty?\n    min = [@obj_array[0], @key_array[0]]\n    if @obj_array.size > 1\n      swap(0, @obj_array.size-1)\n      @obj_array.pop\n      @key_array.pop\n      lift_down(0)\n    else\n      @obj_array.pop\n      @key_array.pop\n    end\n    @index.delete(min[0])\n    min\n  end\n\n  def update_key(obj, new_key)\n    i = @index[obj]\n    old_key = @key_array[i]\n    return if new_key > old_key\n    @key_array[i] = new_key\n    lift_up(i)\n  end\n\n  def lift_down(i)\n    j = 2 * i + 1\n    k = j + 1\n    if k >= @obj_array.size\n      return if j >= @obj_array.size\n      if @key_array[i] > @key_array[j]\n        swap(i, j)\n        lift_down(j)\n      end\n    else\n      l = (@key_array[j] < @key_array[k] ? j : k)\n      if @key_array[i] > @key_array[l]\n        swap(i, l)\n        lift_down(l)\n      end\n    end\n  end\n\n  def empty?\n    @obj_array.empty?\n  end\nend\n\ndef dijkstra(g, t, s1, s2)\n  queue = Heap.new\n  queue.add(t * 1000, 0)\n  count = 0\n  dist = {}\n  until queue.empty?\n    x, d = queue.del_min\n    dist[x] = d\n    g[x].each do |y, w|\n      next if dist[y]\n      queue.add(y, d + w)\n    end\n  end\n  dist\nend\n\nloop do\n# .times do\n  n, m, s1, s2, t = gets.split.map(&:to_i)\n  break if n == 0\n\n  magical = []\n  orig_graph = Hash[(1..n).map {|i| [i, {}] }]\n\n  m.times do\n    i, j, w = gets.chomp.split\n    i, j = i.to_i, j.to_i\n    if w == ?x\n      magical << [i, j]\n      magical << [j, i]\n    else\n      orig_graph[i][j] = w.to_i\n      orig_graph[j][i] = w.to_i\n    end\n  end\n\n  g = {}\n  (0..magical.size).each do |l|\n    (1..n).each do |i|\n      x = i * 1000 + l\n      g[x] = {}\n      orig_graph[i].each do |j, w|\n        y = j * 1000 + l\n        g[x][y] = w\n      end\n    end\n  end\n  (1..magical.size).each do |l|\n    magical.each do |i, j|\n      x = i * 1000 + l - 1\n      y = j * 1000 + l\n      g[x][y] = 0\n    end\n  end\n\n  xs = Set[0]\n\n  dist = dijkstra(g, t, s1, s2)\n\n  valid1 = [] \n  min = nil\n  (0..magical.size).each do |i|\n    t = s1 * 1000 + i\n    next if !dist[t]\n    if min\n      if dist[t] < min\n        valid1 << [i, dist[t]]\n        min = dist[t]\n      end\n    else\n      valid1 << [i, dist[t]]\n      min = dist[t]\n    end\n  end\n  valid1.combination(2) do |l1, l2|\n    i1, d1 = l1\n    i2, d2 = l2\n    x = (d1 - d2).to_f / (i2 - i1)\n    xs << x.ceil if x.ceil > 0\n    xs << x.floor if x.floor > 0\n  end\n\n  valid2 = [] \n  min = nil\n  (0..magical.size).each do |i|\n    t = s2 * 1000 + i\n    next if !dist[t]\n    if min\n      if dist[t] < min\n        valid2 << [i, dist[t]]\n        min = dist[t]\n      end\n    else\n      valid2 << [i, dist[t]]\n      min = dist[t]\n    end\n  end\n  valid2.combination(2) do |l1, l2|\n    i1, d1 = l1\n    i2, d2 = l2\n    x = (d1 - d2).to_f / (i2 - i1)\n    xs << x.ceil if x.ceil > 0\n    xs << x.floor if x.floor > 0\n  end\n\n  valid1.each do |i1, d1|\n    valid2.each do |i2, d2|\n      next if i1 == i2\n      x = (d1 - d2).to_f / (i2 - i1)\n      xs << x.ceil if x.ceil > 0\n      xs << x.floor if x.floor > 0\n    end\n  end\n\n  best = Float::INFINITY\n  xs.each do |x|\n    min1 = valid1.map {|i, d| x * i + d }.min\n    min2 = valid2.map {|i, d| x * i + d }.min\n    d = (min1 - min2).abs\n    best = d if d < best\n  end\n  p best\nend\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    N, M, S1, S2, T = map(int, readline().split())\n    if N == 0:\n        return False\n    S1 -= 1; S2 -= 1; T -= 1\n    G = [[] for i in range(N)]\n    Gx = [[] for i in range(N)]\n    L = 0\n    for i in range(M):\n        a, b, w = readline().strip().split()\n        a = int(a)-1; b = int(b)-1\n        if w == 'x':\n            Gx[a].append(b)\n            Gx[b].append(a)\n            L += 1\n        else:\n            w = int(w)\n            G[a].append((b, w))\n            G[b].append((a, w))\n    INF = 10**18\n    dist = [[INF]*N for i in range(L+1)]\n    que = [(0, T, 0)]\n    while que:\n        cost, v, k = heappop(que)\n        if dist[k][v] < cost:\n            continue\n        dk0 = dist[k]\n\n        for w, d in G[v]:\n            if cost + d < dk0[w]:\n                dk0[w] = cost + d\n                heappush(que, (cost + d, w, k))\n        if k+1 <= L:\n            dk1 = dist[k+1]\n            for w in Gx[v]:\n                if cost < dk1[w]:\n                    dk1[w] = cost\n                    heappush(que, (cost, w, k+1))\n\n    def check(f1, f2, f3):\n        return (f2[0] - f1[0]) * (f3[1] - f2[1]) >= (f2[1] - f1[1]) * (f3[0] - f2[0])\n    def f(f1, x):\n        return f1[0]*x + f1[1]\n\n    que1 = []\n    que2 = []\n    for a in range(L, -1, -1):\n        if dist[a][S1] != INF:\n            f1 = (a, dist[a][S1])\n            while len(que1) >= 2 and check(que1[-2], que1[-1], f1):\n                que1.pop()\n            que1.append(f1)\n\n        if dist[a][S2] != INF:\n            f2 = (a, dist[a][S2])\n            while len(que2) >= 2 and check(que2[-2], que2[-1], f2):\n                que2.pop()\n            que2.append(f2)\n    m1 = len(que1); m2 = len(que2)\n    ans = 10**18\n    for i in range(m1):\n        px0 = 0; px1 = 10**18\n        ai, bi = que1[i]\n        if i > 0:\n            ci, di = que1[i-1]\n            px0 = max((bi-di + ci-ai-1) // (ci-ai), 0)\n        if i < m1-1:\n            ci, di = que1[i+1]\n            px1 = (di-bi) // (ai-ci)\n        for j in range(m2):\n            qx0 = 0; qx1 = 10**18\n            aj, bj = que2[j]\n            if j > 0:\n                cj, dj = que2[j-1]\n                qx0 = max((bj-dj + cj-aj-1) // (cj-aj), 0)\n            if j < m2-1:\n                cj, dj = que2[j+1]\n                qx1 = (dj-bj) // (aj-cj)\n            x0 = max(px0, qx0); x1 = min(px1, qx1)\n            if not x0 <= x1:\n                continue\n            ans = min(ans, abs((ai - aj)*x0 + (bi - bj)), abs((ai - aj)*x1 + (bi - bj)))\n            if ai != aj:\n                x = (bj - bi) // (ai - aj)\n                if x0 <= x <= x1:\n                    ans = min(ans, abs((ai - aj)*x + (bi - bj)))\n                if x0 <= x+1 <= x1:\n                    ans = min(ans, abs((ai - aj)*(x+1) + (bi - bj)))\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  }
]