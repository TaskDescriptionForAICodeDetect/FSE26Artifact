[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_N 1000\n#define MAX_M 2000\n#define INF LLONG_MAX\n\ntypedef struct {\n    int to;\n    long long len;\n    bool is_magic;\n} Edge;\n\ntypedef struct {\n    Edge edges[MAX_M];\n    int size;\n} AdjList;\n\nAdjList graph[MAX_N];\nint N, M;\nint S1, S2, T;\n\nlong long dist1[MAX_N], dist2[MAX_N], distT[MAX_N];\nbool visited[MAX_N];\n\nvoid dijkstra(int start, long long dist[]) {\n    for (int i = 0; i < N; ++i) {\n        dist[i] = INF;\n        visited[i] = false;\n    }\n    dist[start] = 0;\n\n    for (int i = 0; i < N; ++i) {\n        int u = -1;\n        for (int j = 0; j < N; ++j) {\n            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {\n                u = j;\n            }\n        }\n        if (u == -1 || dist[u] == INF) break;\n        visited[u] = true;\n\n        for (int k = 0; k < graph[u].size; ++k) {\n            Edge e = graph[u].edges[k];\n            if (dist[e.to] > dist[u] + e.len) {\n                dist[e.to] = dist[u] + e.len;\n            }\n        }\n    }\n}\n\nlong long compute_min_gap() {\n    long long low = 0, high = 1e18, answer = INF;\n    while (low <= high) {\n        long long mid = (low + high) / 2;\n\n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < graph[i].size; ++j) {\n                if (graph[i].edges[j].is_magic) {\n                    graph[i].edges[j].len = mid;\n                }\n            }\n        }\n\n        dijkstra(S1, dist1);\n        dijkstra(S2, dist2);\n\n        long long current_diff = llabs(dist1[T] - dist2[T]);\n        if (current_diff < answer) {\n            answer = current_diff;\n        }\n\n        if (dist1[T] < dist2[T]) {\n            high = mid - 1;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return answer;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%d %d %d\", &S1, &S2, &T);\n    S1--; S2--; T--;\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, len, magic;\n        scanf(\"%d %d %d %d\", &u, &v, &len, &magic);\n        u--; v--;\n        graph[u].edges[graph[u].size++] = (Edge){v, len, magic};\n        graph[v].edges[graph[v].size++] = (Edge){u, len, magic};\n    }\n\n    dijkstra(T, distT);\n\n    long long min_gap = compute_min_gap();\n    printf(\"%lld\\n\", min_gap);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\n\nconst ll INF = LLONG_MAX / 2;\n\nvector<ll> dijkstra(int start, const vector<vector<pll>>& adj) {\n    int n = adj.size();\n    vector<ll> dist(n, INF);\n    priority_queue<pll, vector<pll>, greater<pll>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        ll d = pq.top().first;\n        ll u = pq.top().second;\n        pq.pop();\n        if (d > dist[u]) continue;\n        for (auto& edge : adj[u]) {\n            ll v = edge.first;\n            ll w = edge.second;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\nll solve() {\n    int N, M, K;\n    cin >> N >> M >> K;\n    int S1, S2, T;\n    cin >> S1 >> S2 >> T;\n    S1--; S2--; T--;\n\n    vector<vector<pll>> adj(N);\n    vector<pair<int, int>> magic_edges;\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        u--; v--;\n        adj[u].emplace_back(v, w);\n    }\n    for (int i = 0; i < K; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        magic_edges.emplace_back(u, v);\n    }\n\n    ll low = 0, high = INF;\n    ll answer = INF;\n\n    while (low <= high) {\n        ll mid = (low + high) / 2;\n\n        vector<vector<pll>> temp_adj = adj;\n        for (auto& edge : magic_edges) {\n            int u = edge.first;\n            int v = edge.second;\n            temp_adj[u].emplace_back(v, mid);\n        }\n\n        vector<ll> dist1 = dijkstra(S1, temp_adj);\n        vector<ll> dist2 = dijkstra(S2, temp_adj);\n        ll d1 = dist1[T];\n        ll d2 = dist2[T];\n\n        if (d1 < d2) {\n            high = mid - 1;\n            answer = min(answer, d2 - d1);\n        } else {\n            low = mid + 1;\n            answer = min(answer, d1 - d2);\n        }\n    }\n\n    return answer;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << solve() << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:37:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge {\n    int to;\n    long cost;\n    boolean isMagical;\n\n    Edge(int to, long cost, boolean isMagical) {\n        this.to = to;\n        this.cost = cost;\n        this.isMagical = isMagical;\n    }\n}\n\npublic class MagicianRace {\n    static final long INF = Long.MAX_VALUE / 2;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int S1 = sc.nextInt() - 1;\n        int S2 = sc.nextInt() - 1;\n        int T = sc.nextInt() - 1;\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        List<Integer> magicalEdges = new ArrayList<>();\n\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt() - 1;\n            int v = sc.nextInt() - 1;\n            long c = sc.nextLong();\n            int isMagical = sc.nextInt();\n            adj.get(u).add(new Edge(v, c, isMagical == 1));\n            adj.get(v).add(new Edge(u, c, isMagical == 1));\n            if (isMagical == 1) {\n                magicalEdges.add(u);\n                magicalEdges.add(v);\n            }\n        }\n\n        long low = 0;\n        long high = (long) 1e14;\n        long answer = INF;\n\n        while (low <= high) {\n            long mid = (low + high) / 2;\n            long[] dist1 = dijkstra(adj, S1, mid);\n            long[] dist2 = dijkstra(adj, S2, mid);\n            long diff = dist1[T] - dist2[T];\n\n            if (diff <= 0) {\n                answer = Math.min(answer, -diff);\n                high = mid - 1;\n            } else {\n                answer = Math.min(answer, diff);\n                low = mid + 1;\n            }\n        }\n\n        System.out.println(answer);\n    }\n\n    static long[] dijkstra(List<List<Edge>> adj, int start, long magicLength) {\n        int N = adj.size();\n        long[] dist = new long[N];\n        Arrays.fill(dist, INF);\n        dist[start] = 0;\n        PriorityQueue<long[]> pq = new PriorityQueue<>(Comparator.comparingLong(a -> a[1]));\n        pq.add(new long[]{start, 0});\n\n        while (!pq.isEmpty()) {\n            long[] current = pq.poll();\n            int u = (int) current[0];\n            long d = current[1];\n            if (d > dist[u]) continue;\n\n            for (Edge edge : adj.get(u)) {\n                int v = edge.to;\n                long cost = edge.isMagical ? magicLength : edge.cost;\n                if (dist[v] > dist[u] + cost) {\n                    dist[v] = dist[u] + cost;\n                    pq.add(new long[]{v, dist[v]});\n                }\n            }\n        }\n        return dist;\n    }\n}",
    "timestamp": "2025-08-05 21:38:23"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MagicianRace {\n    static final int INF = Integer.MAX_VALUE / 2;\n    \n    static class Edge {\n        int to, len, magic;\n        Edge(int to, int len, int magic) {\n            this.to = to;\n            this.len = len;\n            this.magic = magic;\n        }\n    }\n    \n    public static int minimizePathDifference(int N, int M, int S1, int S2, int T, \n                                             List<List<Edge>> graph, List<Integer> magicBridges) {\n        int[][] dist1 = new int[N+1][1001];\n        int[][] dist2 = new int[N+1][1001];\n        \n        for (int[] row : dist1) Arrays.fill(row, INF);\n        for (int[] row : dist2) Arrays.fill(row, INF);\n        \n        dist1[S1][0] = 0;\n        dist2[S2][0] = 0;\n        \n        for (int x = 0; x <= 1000; x++) {\n            // Dijkstra for first player\n            PriorityQueue<int[]> pq1 = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n            for (int i = 1; i <= N; i++) {\n                if (dist1[i][x] != INF) {\n                    pq1.offer(new int[]{i, dist1[i][x]});\n                }\n            }\n            \n            while (!pq1.isEmpty()) {\n                int[] curr = pq1.poll();\n                int node = curr[0], d = curr[1];\n                \n                if (d > dist1[node][x]) continue;\n                \n                for (Edge edge : graph.get(node)) {\n                    int newLen = edge.magic != -1 ? x : edge.len;\n                    int newDist = d + newLen;\n                    \n                    if (newDist < dist1[edge.to][x]) {\n                        dist1[edge.to][x] = newDist;\n                        pq1.offer(new int[]{edge.to, newDist});\n                    }\n                }\n            }\n            \n            // Dijkstra for second player\n            PriorityQueue<int[]> pq2 = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n            for (int i = 1; i <= N; i++) {\n                if (dist2[i][x] != INF) {\n                    pq2.offer(new int[]{i, dist2[i][x]});\n                }\n            }\n            \n            while (!pq2.isEmpty()) {\n                int[] curr = pq2.poll();\n                int node = curr[0], d = curr[1];\n                \n                if (d > dist2[node][x]) continue;\n                \n                for (Edge edge : graph.get(node)) {\n                    int newLen = edge.magic != -1 ? x : edge.len;\n                    int newDist = d + newLen;\n                    \n                    if (newDist < dist2[edge.to][x]) {\n                        dist2[edge.to][x] = newDist;\n                        pq2.offer(new int[]{edge.to, newDist});\n                    }\n                }\n            }\n        }\n        \n        int minDiff = INF;\n        for (int x = 0; x <= 1000; x++) {\n            minDiff = Math.min(minDiff, Math.abs(dist1[T][x] - dist2[T][x]));\n        }\n        \n        return minDiff;\n    }\n}",
    "timestamp": "2025-08-05 21:38:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_ISLANDS 505\n#define INF 0x3f3f3f3f\n\nint n, m, s1, s2, t;\nint graph[MAX_ISLANDS][MAX_ISLANDS];\nint magical_bridges[MAX_ISLANDS * MAX_ISLANDS][3];\nint magical_count = 0;\n\nvoid dijkstra(int start, int dist[]) {\n    int visited[MAX_ISLANDS] = {0};\n    memset(dist, 0x3f, sizeof(int) * MAX_ISLANDS);\n    dist[start] = 0;\n\n    for (int i = 0; i < n; i++) {\n        int u = -1, min_dist = INF;\n        for (int j = 1; j <= n; j++) {\n            if (!visited[j] && dist[j] < min_dist) {\n                u = j;\n                min_dist = dist[j];\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (int v = 1; v <= n; v++) {\n            if (!visited[v] && graph[u][v] != INF) {\n                if (dist[u] + graph[u][v] < dist[v]) {\n                    dist[v] = dist[u] + graph[u][v];\n                }\n            }\n        }\n    }\n}\n\nint solve() {\n    int dist1[MAX_ISLANDS], dist2[MAX_ISLANDS];\n    int min_gap = INF;\n\n    for (int len = 0; len <= 10000; len++) {\n        for (int i = 0; i < magical_count; i++) {\n            int u = magical_bridges[i][0];\n            int v = magical_bridges[i][1];\n            graph[u][v] = graph[v][u] = len;\n        }\n\n        dijkstra(s1, dist1);\n        dijkstra(s2, dist2);\n\n        int current_gap = abs(dist1[t] - dist2[t]);\n        min_gap = (current_gap < min_gap) ? current_gap : min_gap;\n    }\n\n    return min_gap;\n}\n\nint main() {\n    scanf(\"%d %d %d %d %d\", &n, &m, &s1, &s2, &t);\n    memset(graph, 0x3f, sizeof(graph));\n\n    for (int i = 1; i <= n; i++) {\n        graph[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w, is_magical;\n        scanf(\"%d %d %d %d\", &u, &v, &w, &is_magical);\n        graph[u][v] = graph[v][u] = w;\n\n        if (is_magical) {\n            magical_bridges[magical_count][0] = u;\n            magical_bridges[magical_count][1] = v;\n            magical_count++;\n        }\n    }\n\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int INF = 1e9;\n\nint N, M, S1, S2, T;\nvector<pair<int, int>> graph[MAXN];\nvector<pair<int, int>> magical_bridges;\n\nint dijkstra(int start, int target, vector<int>& length_map) {\n    vector<int> dist(N+1, INF);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    \n    dist[start] = 0;\n    pq.push({0, start});\n    \n    while (!pq.empty()) {\n        int curr_dist = pq.top().first;\n        int curr_node = pq.top().second;\n        pq.pop();\n        \n        if (curr_dist > dist[curr_node]) continue;\n        \n        for (auto& edge : graph[curr_node]) {\n            int next_node = edge.first;\n            int edge_length = length_map[edge.second];\n            \n            if (dist[curr_node] + edge_length < dist[next_node]) {\n                dist[next_node] = dist[curr_node] + edge_length;\n                pq.push({dist[next_node], next_node});\n            }\n        }\n    }\n    \n    return dist[target];\n}\n\nint main() {\n    cin >> N >> M >> S1 >> S2 >> T;\n    \n    vector<int> original_lengths(M);\n    \n    for (int i = 0; i < M; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, i});\n        graph[v].push_back({u, i});\n        original_lengths[i] = w;\n        \n        if (w == 0) magical_bridges.push_back({u, v});\n    }\n    \n    int min_gap = INF;\n    \n    for (int length = 0; length <= 1000; length++) {\n        vector<int> current_lengths = original_lengths;\n        \n        for (auto& bridge : magical_bridges) {\n            current_lengths[graph[bridge.first][0].second] = length;\n        }\n        \n        int dist1 = dijkstra(S1, T, current_lengths);\n        int dist2 = dijkstra(S2, T, current_lengths);\n        \n        min_gap = min(min_gap, abs(dist1 - dist2));\n    }\n    \n    cout << min_gap << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:38:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappop, heappush\nimport sys\n\ndef dijkstra(n, adj, source):\n    dist = [sys.maxsize] * n\n    dist[source] = 0\n    pq = [(0, source)]\n    \n    while pq:\n        d, u = heappop(pq)\n        \n        if d > dist[u]:\n            continue\n        \n        for v, length, magical in adj[u]:\n            new_dist = d + length\n            if new_dist < dist[v]:\n                dist[v] = new_dist\n                heappush(pq, (new_dist, v))\n    \n    return dist\n\ndef minimize_gap(n, m, edges, s1, s2, t):\n    adj = [[] for _ in range(n)]\n    magical_edges = []\n    \n    for u, v, length, magical in edges:\n        adj[u].append((v, length, magical))\n        adj[v].append((u, length, magical))\n        if magical:\n            magical_edges.append((u, v))\n    \n    dist_s1 = dijkstra(n, adj, s1)\n    dist_s2 = dijkstra(n, adj, s2)\n    dist_t = lambda src: dijkstra(n, adj, src)[t]\n    \n    ans = abs(dist_s1[t] - dist_s2[t])\n    \n    for u, v in magical_edges:\n        length_variants = []\n        for length in range(min(dist_s1[v] + dist_t(v), dist_s2[u] + dist_t(u), dist_s1[u] + dist_t(u), dist_s2[v] + dist_t(v)) + 1):\n            length_variants.append(length)\n        \n        for l in length_variants:\n            adj[u] = [(v_prime, l if v_prime == v and magical else length, magical) for v_prime, length, magical in adj[u]]\n            adj[v] = [(u_prime, l if u_prime == u and magical else length, magical) for u_prime, length, magical in adj[v]]\n            \n            new_dist_s1 = dijkstra(n, adj, s1)\n            new_dist_s2 = dijkstra(n, adj, s2)\n            \n            ans = min(ans, abs(new_dist_s1[t] - new_dist_s2[t]))\n        \n        # Reset magic bridges to original lengths for other combinations\n        adj[u] = [(v_prime, length, magical) for v_prime, length, magical in edges if (u, v_prime) == (u, v) or (v_prime, u) == (v, u)]\n        adj[v] = [(u_prime, length, magical) for u_prime, length, magical in edges if (v, u_prime) == (v, u) or (u_prime, v) == (u, v)]\n    \n    return ans\n\n# Example usage snippet:\nn = 5\nm = 6\nedges = [\n    (0, 1, 2, 0),\n    (1, 2, 1, 1),\n    (1, 3, 5, 0),\n    (2, 3, 2, 0),\n    (3, 4, 1, 1),\n    (0, 4, 7, 0)\n]\ns1 = 0\ns2 = 4\nt = 3\n\nprint(minimize_gap(n, m, edges, s1, s2, t))",
    "timestamp": "2025-08-13 07:20:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MagicalIslands {\n\n    static class Edge {\n        int from, to, length;\n        boolean isMagical;\n        Edge(int from, int to, int length, boolean isMagical) {\n            this.from = from;\n            this.to = to;\n            this.length = length;\n            this.isMagical = isMagical;\n        }\n    }\n\n    public static int minimizeGap(int N, int M, int[][] bridges, int S1, int S2, int T) {\n        List<Edge>[] graph = new ArrayList[N];\n        for (int i = 0; i < N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        List<Edge> magicalEdges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            int u = bridges[i][0];\n            int v = bridges[i][1];\n            int length = bridges[i][2];\n            boolean isMagical = bridges[i][3] == 1;\n            Edge e = new Edge(u, v, length, isMagical);\n            graph[u].add(e);\n            graph[v].add(e);\n            if (isMagical) magicalEdges.add(e);\n        }\n\n        int[] distFromS1 = dijkstra(graph, S1, N);\n        int[] distFromS2 = dijkstra(graph, S2, N);\n\n        int originalGap = Math.abs(distFromS1[T] - distFromS2[T]);\n        int minGap = originalGap;\n\n        for (int magicalLength = 0; magicalLength <= originalGap; magicalLength++) {\n            for (Edge e : magicalEdges) {\n                e.length = magicalLength;\n            }\n            distFromS1 = dijkstra(graph, S1, N);\n            distFromS2 = dijkstra(graph, S2, N);\n            minGap = Math.min(minGap, Math.abs(distFromS1[T] - distFromS2[T]));\n        }\n\n        return minGap;\n    }\n\n    private static int[] dijkstra(List<Edge>[] graph, int source, int N) {\n        int[] dist = new int[N];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[source] = 0;\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        pq.add(new int[]{source, 0});\n\n        while (!pq.isEmpty()) {\n            int[] curr = pq.poll();\n            int node = curr[0];\n            int currentDist = curr[1];\n\n            if (currentDist > dist[node]) continue;\n\n            for (Edge edge : graph[node]) {\n                int neighbor = node == edge.from ? edge.to : edge.from;\n                int newDist = currentDist + edge.length;\n                if (newDist < dist[neighbor]) {\n                    dist[neighbor] = newDist;\n                    pq.add(new int[]{neighbor, newDist});\n                }\n            }\n        }\n\n        return dist;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int M = 6;\n        int[][] bridges = {\n            {0, 1, 2, 1},\n            {1, 2, 2, 1},\n            {2, 3, 1, 0},\n            {3, 4, 3, 1},\n            {0, 2, 4, 0},\n            {1, 3, 7, 0}\n        };\n        int S1 = 0, S2 = 1, T = 4;\n        System.out.println(minimizeGap(N, M, bridges, S1, S2, T));\n    }\n}",
    "timestamp": "2025-08-13 07:20:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 1000\n#define MAX_M 10000\n\ntypedef struct {\n    int u, v;\n    int length;\n    int magical;\n} Bridge;\n\nint N, M, S1, S2, T;\nBridge bridges[MAX_M];\n\nint dist[MAX_N][MAX_N];\nint visited[MAX_N];\nint minDist[MAX_N];\n\nvoid dijkstra(int start, int* d) {\n    for (int i = 0; i < N; i++) {\n        d[i] = INT_MAX;\n        visited[i] = 0;\n    }\n    d[start] = 0;\n\n    while (1) {\n        int minDistance = INT_MAX, currentNode = -1;\n        for (int i = 0; i < N; i++) {\n            if (!visited[i] && d[i] < minDistance) {\n                minDistance = d[i];\n                currentNode = i;\n            }\n        }\n\n        if (currentNode == -1) break;\n        visited[currentNode] = 1;\n\n        for (int v = 0; v < N; v++) {\n            if (dist[currentNode][v] != INT_MAX) {\n                int newDist = d[currentNode] + dist[currentNode][v];\n                if (newDist < d[v]) {\n                    d[v] = newDist;\n                }\n            }\n        }\n    }\n}\n\nint solve() {\n    int ans = INT_MAX;\n    for (int magicLength = 0; magicLength < 1000; magicLength++) {\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                dist[i][j] = (i == j ? 0 : INT_MAX);\n\n        for (int i = 0; i < M; i++) {\n            int length = bridges[i].magical ? magicLength : bridges[i].length;\n            dist[bridges[i].u][bridges[i].v] = length;\n            dist[bridges[i].v][bridges[i].u] = length;\n        }\n\n        dijkstra(S1, minDist);\n        int distS1T = minDist[T];\n        dijkstra(S2, minDist);\n        int distS2T = minDist[T];\n\n        int diff = abs(distS1T - distS2T);\n        if (diff < ans) {\n            ans = diff;\n        }\n    }\n    return ans;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d %d\", &bridges[i].u, &bridges[i].v, &bridges[i].length, &bridges[i].magical);\n    }\n    scanf(\"%d %d %d\", &S1, &S2, &T);\n\n    int result = solve();\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:20:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from heapq import heappush, heappop\nimport math\n\ndef solve(N, M, magical_bridges, S1, S2, T):\n    def dijkstra(start):\n        dist = [math.inf] * (N + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        \n        while pq:\n            cur_dist, node = heappop(pq)\n            \n            if cur_dist > dist[node]:\n                continue\n            \n            for next_node, edge_length, is_magical in graph[node]:\n                new_dist = cur_dist + edge_length\n                \n                if new_dist < dist[next_node]:\n                    dist[next_node] = new_dist\n                    heappush(pq, (new_dist, next_node))\n        \n        return dist\n\n    graph = [[] for _ in range(N + 1)]\n    magical_list = []\n\n    for u, v, w, magical in magical_bridges:\n        graph[u].append((v, w, magical))\n        graph[v].append((u, w, magical))\n        if magical:\n            magical_list.append((u, v, w))\n\n    best_gap = math.inf\n    \n    for x in range(10001):  # try magical bridge lengths\n        for u, v, _ in magical_list:\n            for i in range(len(graph)):\n                for j, (next_node, length, is_magical) in enumerate(graph[i]):\n                    if (i == u and next_node == v) or (i == v and next_node == u):\n                        graph[i][j] = (next_node, x, True)\n\n        dist1 = dijkstra(S1)\n        dist2 = dijkstra(S2)\n        \n        best_gap = min(best_gap, abs(dist1[T] - dist2[T]))\n    \n    return best_gap\n\n# Input parsing\nN, M = map(int, input().split())\nmagical_bridges = []\nfor _ in range(M):\n    u, v, w, magical = map(int, input().split())\n    magical_bridges.append((u, v, w, magical))\nS1, S2, T = map(int, input().split())\n\nprint(solve(N, M, magical_bridges, S1, S2, T))",
    "timestamp": "2025-08-13 07:20:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    S1 = int(data[idx]) - 1\n    idx += 1\n    S2 = int(data[idx]) - 1\n    idx += 1\n    T = int(data[idx]) - 1\n    idx += 1\n    \n    adj = [[] for _ in range(N)]\n    magic_edges = []\n    \n    for _ in range(M):\n        u = int(data[idx]) - 1\n        idx += 1\n        v = int(data[idx]) - 1\n        idx += 1\n        l = int(data[idx])\n        idx += 1\n        c = int(data[idx])\n        idx += 1\n        adj[u].append((v, l, c))\n        adj[v].append((u, l, c))\n        if c == 1:\n            magic_edges.append((u, v, l))\n    \n    def dijkstra(start):\n        dist = [float('inf')] * N\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[u]:\n                continue\n            for (v, l, c) in adj[u]:\n                if dist[v] > dist[u] + l:\n                    dist[v] = dist[u] + l\n                    heapq.heappush(heap, (dist[v], v))\n        return dist\n    \n    dist_S1 = dijkstra(S1)\n    dist_S2 = dijkstra(S2)\n    \n    if dist_S1[T] == dist_S2[T]:\n        print(0)\n        return\n    \n    low = 0\n    high = 10**18\n    answer = float('inf')\n    \n    while low <= high:\n        mid = (low + high) // 2\n        # Modify magic edges to have length 'mid'\n        modified_adj = [[] for _ in range(N)]\n        for u in range(N):\n            for (v, l, c) in adj[u]:\n                if c == 1:\n                    modified_adj[u].append((v, mid))\n                else:\n                    modified_adj[u].append((v, l))\n        \n        def modified_dijkstra(start):\n            dist = [float('inf')] * N\n            dist[start] = 0\n            heap = [(0, start)]\n            while heap:\n                current_dist, u = heapq.heappop(heap)\n                if current_dist > dist[u]:\n                    continue\n                for (v, l) in modified_adj[u]:\n                    if dist[v] > dist[u] + l:\n                        dist[v] = dist[u] + l\n                        heapq.heappush(heap, (dist[v], v))\n            return dist\n        \n        dist_S1_mod = modified_dijkstra(S1)\n        dist_S2_mod = modified_dijkstra(S2)\n        diff = abs(dist_S1_mod[T] - dist_S2_mod[T])\n        \n        if dist_S1_mod[T] < dist_S2_mod[T]:\n            high = mid - 1\n        else:\n            low = mid + 1\n        \n        if diff < answer:\n            answer = diff\n    \n    print(answer)\n\nsolve()",
    "timestamp": "2025-08-13 07:21:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n#include <tuple>\n\nusing namespace std;\n\nstruct Edge {\n    int to, length, magic;\n};\n\nint dijkstra(int start, int target, int n, const vector<vector<Edge>>& adj, const vector<int>& magic_len) {\n    vector<int> dist(n, INT_MAX);\n    dist[start] = 0;\n    \n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n    pq.emplace(0, start);\n\n    while (!pq.empty()) {\n        auto [d, u] = pq.top(); pq.pop();\n        if (d > dist[u]) continue;\n        for (const auto& edge : adj[u]) {\n            int len = edge.magic ? magic_len[edge.magic - 1] : edge.length;\n            if (dist[u] + len < dist[edge.to]) {\n                dist[edge.to] = dist[u] + len;\n                pq.emplace(dist[edge.to], edge.to);\n            }\n        }\n    }\n    \n    return dist[target];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<vector<Edge>> adj(n);\n    vector<int> magic_indexes;\n    \n    for (int i = 0; i < m; ++i) {\n        int u, v, l, magic;\n        cin >> u >> v >> l >> magic;\n        --u; --v;\n        adj[u].push_back({v, l, magic});\n        adj[v].push_back({u, l, magic});\n        if (magic) magic_indexes.push_back(magic);\n    }\n    \n    int s1, s2, t;\n    cin >> s1 >> s2 >> t;\n    --s1; --s2; --t;\n    \n    int min_gap = INT_MAX;\n    \n    sort(magic_indexes.begin(), magic_indexes.end());\n    magic_indexes.resize(unique(magic_indexes.begin(), magic_indexes.end()) - magic_indexes.begin());\n    \n    for (int Length = 0; Length <= 1000; ++Length) {\n        vector<int> magic_len(magic_indexes.size(), Length);\n        \n        int dist1 = dijkstra(s1, t, n, adj, magic_len);\n        int dist2 = dijkstra(s2, t, n, adj, magic_len);\n        \n        if (dist1 != INT_MAX && dist2 != INT_MAX) {\n            min_gap = min(min_gap, abs(dist1 - dist2));\n        }\n    }\n\n    cout << min_gap << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:04"
  }
]