[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_SIZE 100\n\nint grid[MAX_SIZE][MAX_SIZE];\nint rows, cols;\nint count = 0;\n\nvoid countPatterns(int row, int col) {\n    if (row == rows - 1) {\n        count++;\n        return;\n    }\n\n    int current = grid[row][col];\n    if (current == 1) {\n        return;\n    }\n\n    if (current == 0) {\n        if (row + 1 < rows) {\n            countPatterns(row + 1, col);\n        }\n    } else if (current == 2) {\n        if (row + 2 < rows) {\n            countPatterns(row + 2, col);\n        }\n    }\n\n    if (col - 1 >= 0) {\n        if (grid[row][col - 1] != 1) {\n            countPatterns(row, col - 1);\n        }\n    }\n    if (col + 1 < cols) {\n        if (grid[row][col + 1] != 1) {\n            countPatterns(row, col + 1);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    for (int j = 0; j < cols; j++) {\n        if (grid[0][j] != 1) {\n            countPatterns(0, j);\n        }\n    }\n\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:35:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SkiPatternCounter {\n    private static final int[][] DIRECTIONS = {{1, 0}, {1, -1}, {1, 1}};\n    \n    public static int countSkiPatterns(int[][] course) {\n        if (course == null || course.length == 0) return 0;\n        \n        int rows = course.length;\n        int cols = course[0].length;\n        \n        int[][] dp = new int[rows][cols];\n        \n        // Initialize first row\n        for (int j = 0; j < cols; j++) {\n            if (course[0][j] == 0) {\n                dp[0][j] = 1;\n            }\n        }\n        \n        // Dynamic programming to count patterns\n        for (int i = 1; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (course[i][j] == 1) continue; // Obstacle\n                \n                for (int[] dir : DIRECTIONS) {\n                    int prevRow = i - dir[0];\n                    int prevCol = j - dir[1];\n                    \n                    if (prevRow >= 0 && prevRow < rows && \n                        prevCol >= 0 && prevCol < cols) {\n                        \n                        // Normal move from passable cell\n                        if (course[prevRow][prevCol] == 0) {\n                            dp[i][j] += dp[prevRow][prevCol];\n                        }\n                        \n                        // Jump pad move\n                        if (course[prevRow][prevCol] == 2) {\n                            dp[i][j] += dp[prevRow][prevCol] * 2;\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Sum patterns at bottom row\n        int totalPatterns = 0;\n        for (int j = 0; j < cols; j++) {\n            totalPatterns += dp[rows-1][j];\n        }\n        \n        return totalPatterns;\n    }\n    \n    public static void main(String[] args) {\n        int[][] course = {\n            {0, 0, 1, 0},\n            {2, 0, 1, 0},\n            {0, 0, 0, 2},\n            {0, 1, 0, 0}\n        };\n        \n        System.out.println(countSkiPatterns(course));\n    }\n}",
    "timestamp": "2025-08-05 18:35:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint countSkiingPatterns(vector<vector<int>>& grid) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    int rows = grid.size();\n    int cols = grid[0].size();\n    vector<vector<int>> dp(rows, vector<int>(cols, 0));\n    \n    for (int j = 0; j < cols; ++j) {\n        if (grid[0][j] != 1) {\n            dp[0][j] = 1;\n        }\n    }\n    \n    for (int i = 1; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (grid[i][j] == 1) continue;\n            if (grid[i-1][j] == 0) {\n                dp[i][j] += dp[i-1][j];\n            }\n            if (j > 0 && grid[i-1][j-1] == 2) {\n                dp[i][j] += dp[i-1][j-1];\n            }\n            if (j < cols-1 && grid[i-1][j+1] == 2) {\n                dp[i][j] += dp[i-1][j+1];\n            }\n        }\n    }\n    \n    int total = 0;\n    for (int j = 0; j < cols; ++j) {\n        total += dp[rows-1][j];\n    }\n    return total;\n}\n\nint main() {\n    int rows, cols;\n    cin >> rows >> cols;\n    vector<vector<int>> grid(rows, vector<int>(cols));\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            cin >> grid[i][j];\n        }\n    }\n    cout << countSkiingPatterns(grid) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ROWS 100\n#define MAX_COLS 100\n\nint rows, cols;\nint grid[MAX_ROWS][MAX_COLS];\nint visited[MAX_ROWS][MAX_COLS];\nint patterns = 0;\n\nvoid dfs(int row, int col) {\n    if (row < 0 || row >= rows || col < 0 || col >= cols) \n        return;\n    \n    if (visited[row][col] || grid[row][col] == 1) \n        return;\n    \n    if (row == rows - 1) {\n        patterns++;\n        return;\n    }\n    \n    visited[row][col] = 1;\n    \n    switch (grid[row][col]) {\n        case 0: // Normal cell\n            dfs(row + 1, col);\n            dfs(row + 1, col - 1);\n            dfs(row + 1, col + 1);\n            break;\n        \n        case 2: // Jump pad\n            int jump_distance = grid[row][col];\n            for (int j = 1; j <= jump_distance; j++) {\n                dfs(row + j, col);\n                dfs(row + j, col - 1);\n                dfs(row + j, col + 1);\n            }\n            break;\n    }\n    \n    visited[row][col] = 0;\n}\n\nint count_ski_patterns() {\n    patterns = 0;\n    memset(visited, 0, sizeof(visited));\n    \n    for (int start_col = 0; start_col < cols; start_col++) {\n        if (grid[0][start_col] != 1) {\n            dfs(0, start_col);\n        }\n    }\n    \n    return patterns;\n}\n\nint main() {\n    scanf(\"%d %d\", &rows, &cols);\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int result = count_ski_patterns();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nclass SkiPatternCounter {\nprivate:\n    vector<vector<int>> grid;\n    int rows, cols;\n    int patternCount;\n\n    bool isValidMove(int x, int y) {\n        return x >= 0 && x < rows && y >= 0 && y < cols && grid[x][y] != 1;\n    }\n\n    void dfs(int x, int y, vector<vector<bool>>& visited) {\n        if (x == rows - 1) {\n            patternCount++;\n            return;\n        }\n\n        visited[x][y] = true;\n\n        // Normal move: directly down\n        if (isValidMove(x + 1, y) && !visited[x + 1][y]) {\n            dfs(x + 1, y, visited);\n        }\n\n        // Jump pad moves\n        if (grid[x][y] == 2) {\n            int jumpDistances[] = {2, 3};\n            for (int dist : jumpDistances) {\n                if (isValidMove(x + dist, y) && !visited[x + dist][y]) {\n                    dfs(x + dist, y, visited);\n                }\n            }\n        }\n\n        // Diagonal moves\n        int diagonals[2][2] = {{1, -1}, {1, 1}};\n        for (auto& move : diagonals) {\n            int newX = x + move[0];\n            int newY = y + move[1];\n            if (isValidMove(newX, newY) && !visited[newX][newY]) {\n                dfs(newX, newY, visited);\n            }\n        }\n\n        visited[x][y] = false;\n    }\n\npublic:\n    SkiPatternCounter(vector<vector<int>>& course) {\n        grid = course;\n        rows = course.size();\n        cols = course[0].size();\n        patternCount = 0;\n    }\n\n    int countSkiPatterns() {\n        for (int start = 0; start < cols; start++) {\n            if (grid[0][start] != 1) {\n                vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n                dfs(0, start, visited);\n            }\n        }\n        return patternCount;\n    }\n};\n\nint main() {\n    vector<vector<int>> skiCourse = {\n        {0, 1, 0, 2, 0},\n        {0, 0, 0, 1, 0},\n        {2, 0, 1, 0, 0},\n        {0, 0, 0, 0, 2}\n    };\n\n    SkiPatternCounter counter(skiCourse);\n    int totalPatterns = counter.countSkiPatterns();\n    cout << \"Total Ski Patterns: \" << totalPatterns << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:36:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SkiPatterns {\n    private int rows;\n    private int cols;\n    private int[][] grid;\n    private int[][][] dp;\n\n    public int countPatterns(int[][] grid) {\n        this.grid = grid;\n        this.rows = grid.length;\n        if (rows == 0) return 0;\n        this.cols = grid[0].length;\n        this.dp = new int[rows][cols][4]; // 4 directions: 0=up, 1=right, 2=down, 3=left\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                Arrays.fill(dp[i][j], -1);\n            }\n        }\n\n        int total = 0;\n        for (int j = 0; j < cols; j++) {\n            if (grid[0][j] != 1) {\n                total += dfs(0, j, 2); // Start moving down\n            }\n        }\n        return total;\n    }\n\n    private int dfs(int i, int j, int dir) {\n        if (i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 1) {\n            return 0;\n        }\n        if (i == rows - 1) {\n            return 1;\n        }\n        if (dp[i][j][dir] != -1) {\n            return dp[i][j][dir];\n        }\n\n        int count = 0;\n        if (grid[i][j] == 0) {\n            // Continue in the same direction\n            int ni = i, nj = j;\n            if (dir == 0) ni--;\n            else if (dir == 1) nj++;\n            else if (dir == 2) ni++;\n            else if (dir == 3) nj--;\n            count += dfs(ni, nj, dir);\n        } else if (grid[i][j] == 2) {\n            // Jump in the same direction\n            int ni = i, nj = j;\n            if (dir == 0) ni -= 2;\n            else if (dir == 1) nj += 2;\n            else if (dir == 2) ni += 2;\n            else if (dir == 3) nj -= 2;\n            count += dfs(ni, nj, dir);\n            // Also allow turning left or right\n            if (dir == 0 || dir == 2) {\n                count += dfs(i, j - 1, 3); // Turn left\n                count += dfs(i, j + 1, 1); // Turn right\n            } else {\n                count += dfs(i - 1, j, 0); // Turn up\n                count += dfs(i + 1, j, 2); // Turn down\n            }\n        }\n        dp[i][j][dir] = count;\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 18:37:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ski_paths(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows, cols = len(grid), len(grid[0])\n    memo = {}\n\n    def dfs(row, col):\n        if row == rows - 1:\n            return 1\n\n        if (row, col) in memo:\n            return memo[(row, col)]\n        \n        paths = 0\n        if grid[row][col] == 0:  # passable cell\n            if row + 1 < rows and grid[row + 1][col] != 1:\n                paths += dfs(row + 1, col)\n            if col + 1 < cols and grid[row][col + 1] != 1:\n                paths += dfs(row, col + 1)\n        elif grid[row][col] == 2:  # jump pad\n            if row + 2 < rows and grid[row + 2][col] != 1:\n                paths += dfs(row + 2, col)\n        \n        memo[(row, col)] = paths\n        return paths\n\n    total_paths = 0\n    for col in range(cols):\n        if grid[0][col] != 1:\n            total_paths += dfs(0, col)\n    \n    return total_paths\n\n# Example usage\ncourse_grid = [\n    [0, 2, 1],\n    [1, 0, 0],\n    [2, 1, 0]\n]\n\nprint(count_ski_paths(course_grid))",
    "timestamp": "2025-08-13 00:06:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class SkiingPatternsCounter {\n    private static final int[] ROW_MOVES = {1, 0, 0};\n    private static final int[] COL_MOVES = {0, -1, 1};\n\n    public static int countSkiingPatterns(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int rows = grid.length;\n        int cols = grid[0].length;\n        int[][] memo = new int[rows][cols];\n        \n        // Initialize memo for skiers\n        for (int j = 0; j < cols; j++) {\n            if (grid[0][j] == 0 || grid[0][j] == 2) {\n                memo[0][j] = 1;\n            }\n        }\n        \n        // Iterate over grid to calculate patterns\n        for (int i = 1; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] != 1) { // Not an obstacle\n                    for (int move = 0; move < 3; move++) {\n                        int prevRow = i - ROW_MOVES[move];\n                        int prevCol = j - COL_MOVES[move];\n                        if (prevRow >= 0 && prevCol >= 0 && prevCol < cols) {\n                            memo[i][j] += memo[prevRow][prevCol];\n                        }\n                    }\n                }\n            }\n        }\n\n        // Count all paths that reach the bottom row\n        int totalPatterns = 0;\n        for (int j = 0; j < cols; j++) {\n            totalPatterns += memo[rows - 1][j];\n        }\n\n        return totalPatterns;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n            {0, 2, 0},\n            {0, 1, 0},\n            {2, 0, 0}\n        };\n        System.out.println(\"Number of skiing patterns: \" + countSkiingPatterns(grid));\n    }\n}",
    "timestamp": "2025-08-13 00:07:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX 100\n\nint countPatterns(int grid[MAX][MAX], int m, int n, int x, int y) {\n    if (x >= m || y >= n || grid[x][y] == 1) {\n        return 0;\n    }\n    if (x == m - 1) {\n        return 1;\n    }\n    \n    if (grid[x][y] == 2) { // Jump pad\n        return countPatterns(grid, m, n, x + 2, y) + \n               countPatterns(grid, m, n, x + 1, y - 1) +\n               countPatterns(grid, m, n, x + 1, y + 1);\n    }\n    \n    return countPatterns(grid, m, n, x + 1, y) + \n           countPatterns(grid, m, n, x, y + 1) +\n           countPatterns(grid, m, n, x, y - 1);\n}\n\nint main() {\n    int grid[MAX][MAX];\n    int m, n;\n    \n    printf(\"Enter the number of rows and columns: \");\n    scanf(\"%d %d\", &m, &n);\n    \n    printf(\"Enter the grid values:\\n\");\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    int count = 0;\n    for (int j = 0; j < n; j++) {\n        if (grid[0][j] == 0 || grid[0][j] == 2) {\n            count += countPatterns(grid, m, n, 0, j);\n        }\n    }\n\n    printf(\"Number of skiing patterns: %d\\n\", count);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 00:07:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_skiing_patterns(grid):\n    rows, cols = len(grid), len(grid[0])\n    dp = [[0] * cols for _ in range(rows)]\n    dp[0] = [1 if cell == 0 else 0 for cell in grid[0]]\n\n    for r in range(1, rows):\n        for c in range(cols):\n            if grid[r][c] == 1:  # obstacle\n                continue\n            \n            if grid[r][c] == 2:  # jump pad\n                for prev_col in range(cols):\n                    if grid[r-1][prev_col] == 0:\n                        dp[r][c] += dp[r-1][prev_col]\n            else:  # passable cell\n                if c > 0 and grid[r][c-1] != 1:\n                    dp[r][c] += dp[r-1][c-1]\n                if grid[r][c] != 1:\n                    dp[r][c] += dp[r-1][c]\n                if c < cols-1 and grid[r][c+1] != 1:\n                    dp[r][c] += dp[r-1][c+1]\n\n    return sum(dp[-1])\n\n# Example usage\ngrid = [\n    [0, 0, 0],\n    [2, 1, 0],\n    [0, 0, 0]\n]\nprint(count_skiing_patterns(grid))",
    "timestamp": "2025-08-13 00:07:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_ski_patterns(grid):\n    if not grid or not grid[0]:\n        return 0\n    \n    rows = len(grid)\n    cols = len(grid[0])\n    dp = [[0 for _ in range(cols)] for _ in range(rows)]\n    \n    # Initialize the top row\n    for j in range(cols):\n        if grid[0][j] != 1:\n            dp[0][j] = 1\n    \n    for i in range(1, rows):\n        for j in range(cols):\n            if grid[i][j] == 1:  # Obstacle\n                dp[i][j] = 0\n                continue\n            \n            if grid[i][j] == 0:  # Passable\n                # Can come from top-left, top, or top-right\n                total = 0\n                for dj in [-1, 0, 1]:\n                    nj = j + dj\n                    if 0 <= nj < cols:\n                        total += dp[i-1][nj]\n                dp[i][j] = total\n            elif grid[i][j] == 2:  # Jump pad\n                # Must come from top-left or top-right\n                total = 0\n                for dj in [-1, 1]:\n                    nj = j + dj\n                    if 0 <= nj < cols:\n                        total += dp[i-1][nj]\n                dp[i][j] = total\n    \n    return sum(dp[-1])",
    "timestamp": "2025-08-13 00:07:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint countSkiPatterns(vector<vector<int>>& course) {\n    int rows = course.size();\n    int cols = course[0].size();\n\n    vector<vector<int>> dp(rows, vector<int>(cols, 0));\n\n    for (int j = 0; j < cols; ++j) {\n        if (course[0][j] == 0 || course[0][j] == 2) {\n            dp[0][j] = 1;\n        }\n    }\n\n    for (int i = 1; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (course[i][j] == 1) {\n                dp[i][j] = 0;\n            } else if (course[i][j] == 0) {\n                if (j > 0) dp[i][j] += dp[i-1][j-1];\n                dp[i][j] += dp[i-1][j];\n                if (j < cols - 1) dp[i][j] += dp[i-1][j+1];\n            } else if (course[i][j] == 2) {\n                dp[i][j] += dp[i-1][j];\n                if (i > 1) dp[i][j] += dp[i-2][j];\n            }\n        }\n    }\n\n    int count = 0;\n    for (int j = 0; j < cols; ++j) {\n        count += dp[rows-1][j];\n    }\n\n    return count;\n}\n\nint main() {\n    vector<vector<int>> course = {\n        {0, 2, 0, 1},\n        {0, 0, 2, 1},\n        {1, 0, 0, 0},\n        {0, 0, 2, 0}\n    };\n\n    cout << countSkiPatterns(course) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 10:52:18"
  }
]